<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96db00f7d0c4021be884d25926adce3b2ce5ff1c4c7831f0467e94c0ff31c7aa879967379a7ab3b4e015e1d3f13b8e12472124c8027bee16f7015514b5bf01b730fb57d07d8325a56c2f7129586c24f1eb10d194ac5afd656dbd34127757ebfbf36829269795a0e3d419cce9debea8bc3e503c403e8a5c05b8230ea7b97de24752d5247c94e0f809d7a94263d99047a2c7f74cd1407a5774829e0532d46b33467493f5684c7c84e02cf6c4194c3e65d4abbc46ce8931f95c7f5e2590b238d114f87499d408cd70313143aee71ff5a150f2abff36e1b7d53ebabd099ed8f791a5f33e152dcd4dbe0a8c0119969b0936e96036eb061a08d304dfc6ac7446b87643b480f2f0c09fe17eed5c975be4aa6435fda8fd4c74300b0acca0f19d7fd224b12c3f3ca66fc8ff993def3ba9cf6cd0b86e7caa0816c90e798ae15a5578676e281393c2584e5b66e8149d240cf31b1367247a1886c5527f6b30338e9bd6ba762408f51aa834e655d277e16e81c6e6be14d40532018cee52bede88627ffbcf2c1a84695f68d6179dc7b34a8200f8e3969f25f3b931ebce2fb3edf8e6bfed01401a209cd4b0a2adbe74f2dd65532652c4c62d0e7464f0d16de1ece90510ebc67b58f6c6aa603ada6fa85cd26f04954e84654b84259da7768de3c7b881525c0899885e9b8754cb679749ef7962aea30ce07a8b8557215abe1e324833ce575a63f515e513959d13fda25d29769a81ca4caccb4d64231fdf6c70a3219f6e2baeda4fbcb070a2b58ac4f08cdafb8e26641084f19d766eaa5c9aa5c2bff1558fbb9bc7e71793ad0efd1fb8ee9faa90035433ef5749212642f7f0bcb99cc38eb2566d4738e10907e3f583b10f06bd0e18bf6c25585652516772e1589c8f98c0e250dc4ecd45d45c01cfd9f66eb0f57d9df25b579b45d89e4e3d8dbcece26a30b88c9bd9cd001bddc84c09909507f7154039f56c4266ca5a148c64a4b1325b87175d7839595c48c6cdda43efd8ec9cddae6461279076ea12bf88c93d73b4b0e42f32cc02148e34d9960d575bf15868294350f955d578cd42d4df8fe14fcf93ba1094947f503b8ac24e02a55b9c873641f2192d3b23b4ea1a2853b5e4984913d5f2746bafc96d69584bbf1d2526daea2a98bc0ec4294237212c0861d08da81c90e08bc34758c3466ba9d0f09934c70f1dfc75c1be6a1ee97da4c3a5d4e9af3f466ef5fd466c5532b0968fd5ca4995e9eae83117e2903895ef4241827b862d550dab12575d159a245a2d751982a5617f80ed01818275b0129e6a3ea0886326da3f4aa0ab321f2ae63cab3657a5ed8f57423065e0921601f81c56f26676e9be51607a9b0da756f4e1d193988eb30201a5e9aa8521a71b5e6aab19fd39f3f2433407302e39d9959888960bf8e7c1ab7df06a330b65ca3d02a5b7fc4961b5ec552ea9915e231dba9ce9702d78c8852cbe5d7991e5b0f8fe6a919486bb42e200b63ba5710972007c052c3670eefdd5014ca04bee9a170707e94f6489a120206080631cbb8911e679d81ec5d2ec51744cb3e3058ff7dc737d433b8de9de9a1c1f050a005d0c6c54b80c301d52360376dba737eff5ba608e38c1ec33a95c2a8178edb5cb8f4ddadccf4155eaf1fac89752b413c33c7ee919c5c82570541ae2ebaa8fd2fd7580cd0ea376178a4be2aa1d4524000695257c5320c4cce0f51539cb67871a559173c932921512f9a06a76c4e2f107b1baa842819de7d9b0c1bb9334da5c5f43189b5086714660d1925b74339cc0dc3a1093db6d311452d1416eba132887697c4d20a7af620aa071314c470e5a2734392b3d81c3ac6f68650b996576b521ed6d78284b81d0e4a14f6b1638bfac1beea6a94b5e39bd2759792b99d39dc62098ecd00f92f26bd09ee28599dbe0b7278abb6a735d7ac778b3cf4ed37c1bd29215399f67e099b46ec8a53cd49895ffaacade56becc1812ab137074cd029cdd9c8bc2361bb09c5f908c24d289f23b177832d73286902fca67db25fba3d94ca08be30cf85ac670e31daafd3adcd597e9b470d7011729f99380fc7f95bfe906d1de6116e3979c0bb25247ca86e66567b4bbd1a2a2e95a338fbdb6936f1bafbee311d76529f16475e25da1beab70b828afe7c39748fee9205a8f8aa11d561980010fabe645af6d77e4956864f44e434bd5bcc1bc86abd37aca9ae97514bbb8b3783fb08e0bfef77c5ef32107d2f034ea16dd8bdebc88c5ed8905bf1f1a24483b174f6b1dff88ef80bc4fbe1a487844177f3bb002ae53f0fdd4cf2fca7f6005be26b3fa2692a13e6fc38b39bb215293b4cba2fcf79de0e47592b288786aab058f591d5246b08e272c72d7ff69c2f36709fd9bf2a7eaeea70d48ae2f30e9d0fda7df5e1e2630e1fd99e00dcf2516f9fe7fb2e210b9d5c97dad04a313dbae6bdb49eee82e2533bc2b2ef40234fd8a71e51353f9dc401d8fd674c894172207233ed7bdd256c4eb43e9665c61bf1dab8201060cb47a92da6973e84e4cc8c64fc161564cde0087b1d04032fb52c1666210136df373713de178d0f41371d015a7cdedc2bef2c27f0001f1fea234497880a0a545bb2b1146e14e7b1fbbc6ee5aa112c72d7c3a12029b0c78272ac66c194c202e2d299f57fced889586cde9972b149bcc6ba39dc42f7df9bb11fa457fc607b5bdd7b689cb191f7c1a5394d4ce4eaf18abbe179ac505366ce66b6436d89c4e89f444073f51647514c25371edcb7eef5b4bb5cf0c14090e5b0dd358e62926c0890e9e072eface45a2844671d9951dfdac24ec6c0c886cffe32a86bc4024a55285da013733ebe40c9c180c20d423ef53fcfffe628509ce7b9739200a8aed8c5691935adb44688f75af8ba789bbb9e407680c14ab03cf58edb389e9ca0aaf568202e63d6dea8a64b8ab2cab5b57bb4d7e069a6e0cd2fee65a18b36d86168de0f713a096f5d24c9d9fbbfa377fa2e3ac01eadcf2cc6ced4d1df5b2de45fb919e3ecb6684026d4412aa80b8f025f10f711a41e1db378b1d7fc67eba28b33545fb163e5f3afdbecc885a4422bebf10a7abfb1ca908948258c363f16c00d14c0d3438b50248cfbbb4cd298f4945cb62291fea25a48162abb70bc3fce4ab3abc21512018578302bee66f5af4b59850bb8e821d40186132c926911323b095563361c2c5f0ed796e356a1ce536b3ecc82fb8b24fbdcd218b3dd04a2ebafe194dcfe344683fe7976b4e53f2c89d906ca4eb42815efd7e813e10b401a2a344a0275cbb45b9e3cf2f66d0ff7320cc3c220197a2654f32bfaf7432e45abe1340c4a7132a611481f3b4d99d82a6a39547a570a4120b9097e955f4c0eabe410bef03d7f427953c1119667be1fadf9a46fa21111db295b2981515ae2220d0b1c8e8a84008954e0cc2641f62b1766350c7174e5f9512d7e1a8c462c0f0edebfdfc4a8ec1fce9e3e5cdff3518060b67e5eb04e5f3cbb96103d13b36bea737d42f44d71d47645c28e4672a12090d182d4ab0ab370398fbee6567ad7d5d843f4e848e563fa66253044e817626302e02853bd27775fd7ad1764bd8949ef16b25fcbf3ad569c114e98acb494a731fef684635ca202faf159a486e8e71480b06d9551528a22bc1f902016bb68b7b073f161c673aa42e1a7389bc89c981865a3ed07581832b4e8877db4499f02413557ffb41f5760f1e0442d9cc025b23db2f4780a2795d6a7cacdee43e8864283707b972b7c2b8f5e96ea12004b4034c194ffef3979e7e89e6c93e27257c839454406d874378b44dfc87ccbd072936fa74fc54d085a66c9931b322d035f070ab63cbba07bd92df25a3bd9d44d22104c9f38f51e59c41257edaa6babb4e058eb1dca61a2a5c4738f0b9fb1c1f6297517f3ce71a9508162e35787a3395b02a9161eec4585afa70d6870bd4fe4ea87c95eda05573d0bb40f68000ecf626803919cd8ff0a23558e82357b7fc9533bb4600845acd03145315996d04f82d9f16213ff68456d306bdc4f48d54c27837e220015e46cdb36a282a57b9f326a96dbbad708af7a32aa366bb3e274186f4cc63649ec058f5abef9df5a1a4c8665b5dd1684061d6b6adc4a1b0bc0af311ad235b02a7798be8f60af6d8768d65de140b3e4d873ed0453e01775d6fb1cf0fcaf2eaf7e50ba7048bbc7cf7a31eb4f22d20446f6e7da9034172e0d777f50a3c1143ec36c1fa0b5908c39b4fd8194ce4b2bb537ef9faccdf7cdd511128edd61f9d18a1bb6dab16b9fe3b6f71470599ee5beb087d8da55683d8697f4404c0fbde07b1d92bebc0bf6e310b02aa2d32256d2794fb0e5271fb37823f6759f111b259ab767d5f4e5c28e2fef75a2966cd41f43d9eae9b5ba82930032c518c05fceec6336bb17ee448a397da32fc115320d84980ae8bedffa387832df8210104182cbec365cc2a1b2ce64febc12432546844b74497f4d90f6a1d0360c9204bb2c976ae079c850f6f40581429ec0ae16808bce63a1a48ef5c46eef61313a1e501d6937854dc3b2330965e21463ec1ab99b17eb530152125fe621649968f63c2222b0c6f56a6a6829f9c1ebd4d186263227d6331d818ba96b282011b1aa20dbb1545dbd0f0383a6273859d76e3c4486bd186fb3b14d3d9b9edb9dc235eb64f7eeeed415c72fd797bec2bdff1fc03e27e6059871b968ba268cbcaed71e25e82f5095613250b3b84c9b185faff9761f55cc963a424985f997fb8d0a0f4fc1b3f74b5f8732bf9df3145ef707ccd3ed30d89008ca2a18587e43f75ee16ea6a6944ff77c1ba7fb85865b7af319599a17967d17db5d1a0a1b0fb21edeae94ecbcb5eae81c0aee06bccf76488d6aa265018f644253bd5dee63fb36f199efebfe0d2eed97a89addf56a89b6895a2e87b9a3c303bf6fd4a9b193c4abb882709d5b2c12ba2c95c4fd3a8b24eeea75ded1b7b7ba04e721e7fd6400ba1f1a1bc5f5c51488f2587cf99c97ebb0b2622cf10f6f87efd4f17628710bf74cb16a359c44136459addf8e6240ca7d828e916f6fb6a3410b2df2575bc11f03cd2310200ccc9679ae0e4b8d18330ac101a11df3be500bcf7d674cbec1f2afc3d6230bd4e102fa26195f97d7402b0fde18388b9755264f54b1d251f26c9085c42223041f12621be55c045c9d0d39158d6a402943804ccfb81e2a485a3f516f1351424e9e2afb140158948de2d616b0a51e59627c72c99f7902f0725bce3e26a37d90427a6b8ad289f161b5443313cc42f24188cca0faba874ae3e3d5afdbc307d3e4f67c1b161b35922f6fa4f770aaecc1d895905934a6065da26ff2425f8569fd839f2e052a68a6689666920f06bee082bfe3679b7270094ac2da84b8881fbf9b9a2c30821ced2f766c7dcf367288d7c3d8dabae104c22dabe1e87c50e4f26a3f5c729e55c290775820c4a65d9dc8fdf63a27e44cb28eedb84f88e52598190ec91b15bac32fd5f920a0f21ede8751fc695fdbd107440fcb0e1c235c6ec71de2c6df5702f078c666feb1a692fb476a0849020b1ee407bb4034a9d86312c896b87f692a6013e086bf415b384ccbe893e1964061b02f99321a7a7e97e1e78183596a1bced4b971191f52c8fc02dc2ab2c808d561ad25f4a698b5259af9faf974315b7c391fd79fa5008576c75f9298e3c36d8ad981b042e701fd4fae5a789d3befe057644f7e38c4df457409a7fcd6e1d21dd3553b1782b5590f0c72e1c70aeb4cb2915f1dfe94df666f3f8f592ef1b9332ae86b929d1bca73a468209a406ab7b2450409c5508f0d5a5c18b5a8d215aac219ce228ba0402ebaae5bd200eb2e00feb2357dc5a4a00f1e040797d1475e2c75c1d42ee6a6290f19e6b0c9635bb8accedc041ab452eb04d880a873282cd13831cb655b8004b2f8a69d890d01949784616c67f202bc43300f9942e26007500661e24c3812817ad3134000ff484f51db75fd9162746303dfbfa23f3a218983513c1c72508d38ff3669d50b0882ed626d224ce81d16b8c7fe1d6fff7705d3cbd2860e83a1dc1ad99269e4dd515120f3f32fbd4a14072920bc491d545d25db98341eb80115899ed451ace97ca4cd9c0e78a0416a227227100c3a8808b38f2c05bd76d5dd0db6da9f5c7ff403c61cb44e7608ca020e11ef2424ffb8e5469278eb3981380084bd0dd95c4e05bcdad035f0e442fa93983c03373732a328914beeafad2ba32dd98a752769cb1dde83d7c0791ed930ee74a563b64f4291f22c8d4fba03866b71d2d5ad5cb8074b874f790dbae391bbf5679a3258ac068c6e8992cff6edbe5efe4ec630e29722bdafcbde3d7a61268263dadb1e94cfea51babc41a891ca2b51ac3121862e6d2160f45466cf87fd457dbe9f4325325f175b0b330d7a78c4c08033e647fd41d9b7140b709f18ac7b4ddfd4a7c09d9c1acd50b74caf2b81cf872198fab9542e27405b583891e4fab6e7e59b3e3e928c1b154a290432e3937d4950c83100e53d2a72e387710805dc03394cc3fce2f7195694e46b53b10f97dbfeebb6c2e466fe55b6fc7fad6891552f87810578534c4737af4f33458a7acb0d2a792cb3a0a4e20e960aa71625b1c765410ea62a09631c635f7d5293a7c7bf41c5eafe197df7a3d54fdf8d91ab900281e43e75dae27de9c3c30a521141f57e39d5ddadc9a67d06b56ba0e6ff8d53546fcdc3b2235fe38210377c979fca3788de3cd14322aa04571b65c8f94963000c13a6a856a1c60be619f2d3d01315611856cb726f204b4ad306783921225d782e57d4cfdcc28c6621fc0795ed47a1938ff6fd2e4aa05ed15b2b66382d2a65eaf215f3c5a23df31ac9eb28d94786507dd4a0660bbc657c5a1d096e629de06bcb009dee2dc180d4d1d820d9f3e0ee6dd5324ffe0e2f0fcb7ec616f6770a66ee5f3710b3b7da78101119f62d717184fc19fa36c8dc1eaf79849ae95333b0cb7f6fd11b6c0e85a74fc47157ad5df8ee0e9bda958a929147eeeaf61973af0cee8378c7caff1c279d36ac296571c2c068b798af5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
