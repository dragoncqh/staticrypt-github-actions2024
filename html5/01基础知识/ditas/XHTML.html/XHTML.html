<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bcdc2b0916a43024ed99be4e31ec1e0ea9283211b17d5decd789af257b399e7bfa31b91389ba977f32f8cfddc946799b6ed4b424d7309e0f1a6a944a37158a8214eef82222b15af42ab58208f75e271ce8a5e3e764fc163702f66927b6fd19df4a64b4760d8c8fa45dd96e5f639dcc341228c38251571f2244b001701a2194bde3dd46847ab5a75802da335b216f208e9169e8929f713a2f245529eca6ff38a88fac57fc228d6a1294978d34b4929b566c995110f8d478e0610833a26582cb0ff911fb5f18a2fbbdf5349eaabfdd2838c623d77e674980bdf13f8298c038c37e5c0fb9294454bbb1e750350e1d9f2bae2fafa7775860dd9586096518fb2f85824c523b047ffaa671dc5a281f773163b5343bf60fc7f5b4849c07bbec5ccba398955af05b6a1f803de9ba411f400fdc71fde4f51365a497291fc5f42983997f6f8ee042be7cffde6e9436f8a8e4d7227e3d01b9c8273318e366ed3ba87040f53fdb45fda0ed86b4fcbec37b10cf53476a9a80de89f96d4b86437dd3afa8db55c594c70a60cbe886694ead5e9304f9ef45ca01b360450b3a72a21ae7ed161969e0c63908714d827647f2be761ea990402cdf6407034462a0389bdb32756713cfcf908984cfbded00da2a6a762caba030b246a17c804309af7a44bc06ebe0a7c8930fd4f1a52e66f01df0f9e6cfdf94bfbece45aca560a8688bee868605fc37f972e92e737e1e3800a97e9c15db35b86ef63a046597ae526e2ada1d2a812a5c9a6d5fabb900b49e2bceab28cad4c56824f97ad4b673e6d303e6af07951fccb3eed31600964c889384f1f1a2a16d0b7327b8d07c255171d6a82c5a7c88fcdaf8529d7fd7b5e7f52fe107b9161335f45405f62b314e0a27bd903fb5352916638223c04eb01f60ed850b3d7c12081bf0360904f390482a374c86472b9fa1460b5a2426d4c74935378b7196c95be6fea7f950a756fe07a85dcfaee2d41636f3b117c59447ffa383360ba749833a5fd324142a686e5e13f7b69ab33f341874336280cbcf31be1b61feac2a8abbd480a1557cfdd7be25c8acafc28e0cba221c9369d12f1e630ae3a15ccbafc7a2ae1ae3a4e65df0a19600b49ee828045e8a5ff9d430b81ea1a7976defc47fa610d9054a1828ffa7e5bf50d86d8fc7fc9623ddca670d726682dd8898ee67d63ab5aa55c962f07c915c6a0fdae7af92d9e91ed9791995f7335fa88d81902e47fd178d32ab12845be4fcce018de1c78c1ef7c783afe4243247b3d85b1cb70a24ab0a7131b9fc42645f47538d8cd4a17af3a27ec7cb3434ce757b86390ac55d6999b395b3c1c6f9bd5a4ef703900f404790f882cbddde26f53c8c42cfc9468514ab215cebb8130c06dfe680c4edcb339e269383fd08e0c66bdf4d83cdb0e3eae1cbff83448604c35161953cb7f135bfa1c10b612a855a0c12a918348956495042d22b6fdf591e8764aef2da03ffc387a11461d77dd3a87aca7fda7590853c2f46fa008095094b6e20b40294b02188235d623a7b6d598398cc72428e39e54ff3c8765dfcc6609745df21a7b154b545dfc7ed3b74db38802560dd1a37c4cb07344408f1bdcb6fd6f2ad82ad4c5d9bc7b14bbac135fcf1cc01da5cc30a1ca71cad5901d645c15a2188cdf3d248bf404d697f25ce5cb94ed2e960a51ecf305bb3feab4badab6abd5503ed9f06890bef5b91e76b07deaa880fe0185efb43cf88d49dde7614fa8329d69fb6120be212da0e58cb853deedd59e426ee41b3db73afa0531d0c30aa2e6eebb7817e02d2119007851c6ce9591b7ebe5e1d2d33b8a6117ef6e39fa28a55bcc3e9ac95423667efb1344257e214f460087cce267910b011fefe49ce38dc067b3bb2243575e59a1739c1c3f70ecbf2fc09de76f1589ad725127720b2dd4270ca4657749247021cb068c65bea177cb54c32ea20f4b27bd12e8f117045ccbd0652cbf042d0863f48bad68389fb580851cc9d31175a8e1aaf9f83f41313447ccc5f6dc36c2cf0fea4af814d9dbf5322336da3b601b75ff6e292170a4f8ecc6a7079f86f9c308d5abadaeb7a002112a41b8f5e1ba02e1382d4a1652077a90cfec7cd96f2ecfdb65d548ddfb83fff97ad5e2df0a32e9221c58438795ffdec045c8f9967b7d90b0ac2ec8ba06631c71713c07b135081e4a20a7bfca09bddf5b1d4380858064053f611f8a60c2e809bd4c76afb1ab866bd3378cf981afd7c1e4b6b4e5d308a6b723bd2836d94d1b961432d969b21e1910ad4fe60729c2f8c7af434550246b9a3fab8298fd73c67cfe946c1f467396676a935ff52b90abeb2b84961a26e898b3611dbf7cf2cf716ad0457da88db99e8c8ebb7f37454daa0db12de18f63c8eba7a2189fc537b0c941a86273727dc4830e6dd585c9ff5846b29e840b9cf35dc47cdf2dbe7311c2c380ccbaa41e8b32b9eefd3d67d8ac833f40db79aa7467a9f9195428d2276a25f56a7a858882ce42bf4f18ce6ba59a12c889874adc850af77bb246b94396422cd84bd7dd4e56a7bc6763bd100cab46201d26e6494773fb42b8618855addf87d6facc1dbfd48cbdaee0712d5d89aad60f5b9b7bc7f09c23ba9f3183fd28c9184511702861aba303076d02adfae5f4367a3d83fd94816c8b3a7bf24eb940c770292a96090d47308b3b95751194f97699222860b8477388b26478e3d66e5e9d33835bcfded31087be2e992c46e11d5f5b9375381c49da2bd730b4642164472094510e1de0bb1c6874fbc68acc8b4d4cdfbd7c94ff288c42d75ff3311d6309b778bc065d46236aaba591ef0dd49edb6c6bb53bcbaf88cfb3e186486e7af790ef58cbc6dbc42fa6dcd377574e7d74a6a8fa0633bd67a7df440fffd24e48af5ca6de40a96ebf5cc990c376faec788e31ab19affb748cf753901675d524ff6c21b8ea4a58308096f7c7300c74fb2928ed16114d1d149e828c72ac8fec5ebf93dd6eba2d03a4359b0c7c072fd66d9195c0898573ebef076ee05b4d7d69bde40195dc81d557629f859a37c2b1b597146a80b8ca8194b351ea2da35a355633f8582a817917f85312f0bec7f3814c5bbe71d395836a0446e76dd899ab30006bf1eb9e4527f70d6e60589e06818ea584443017fcd19bb85e4d9ee24abd7fee0fa64e5a636069bfb7e7662adcf0a36a08d43eaba89aa73099880f7edd6d26519efd4d2e866c79b68e236f076f935628e3c8017bfdb90114699186112a1c65204951e35bd6a82c6d9f87e16adc2f6a7ddb86e569392d65bf576cd3a5171ad22e63c026b48d82c5ae21defb6166db7c90bf8bce9058f87d207e2ae6060b6c6808bdf00b02cf0ced6ed429b2505bf141d71e751c603bf90a0b9172a96c592802d5825d1f93f30f79ee1cabd1c255a0fc8effbaddd85abf32de9bf4f424c62146d3635d2bc0a62a509da2bcb1bf1125d51f1ca5638893beef8e789079ee291fde72963fe89a337906b6bb92afa6dae3374adfd28387bcf864145ed2682a56f41bd41bafa941485fe2b5cedc9829df9c6b6fa65c179cac8f32ae874026d9faa1d06b82e0446f9637d08005742a2eb6ee81932efacbd8b5ab162d695ce287532215c8e3b70fd8d5d325e2d202fc7cd43ff4c2a445ad8d71d5580e46ff7523e5cc7001b137d1535bb7efc6c60c1c8a96434aec4857ce10065c11078b0c02106bbd8585ab5e3410240bf33b9cd15d53e717aa95e10a661542a2a350318cd7bfb30c9d3d8fa3d40f505221b5782a501d8eee7580aad786f087068111c111aa19f6210d6a824fa54743c2f135675c25643d74e708f781d4f9c6dea3fdb83aa59e58d8c295a00e4e28f8ce7269009705cd70fa7ed89b8c97ca1347e629f584a20a086584cacc469835696940626501b07d88406a18b8cfcdb099b074537c2645730d5b6d886424c4dc1d5e5c78d62eedfd78943e3fcd94e2acc378c2596cab2443a8b1dbda0b732ee228878b2a13a2f805ced898edbead18c87a768a680919bff048f1a889086c7ce8004046e1aa7df6117bbae3a6526ff4fbeab60b255908e538600e3323373345b8f6ea1ba1a1ffe7b97bff1d1876e6fc4e863325b4a87e024fbb039e29f07f5a616a6047e68c7c9ca0d526261488f3df2cb7521639e0093ca4280224f1923a3bf94c6556eaa98ae2b57426ce6bbc1fbdc69ccf56a643fcffef311a782794129111a07787b519dcb202de120b508029ea9c64dddf939440dd3751ebbeaa8f95fa26dbfcc9d1cb66d3693fb0f050520caaca9f6f5fa7a46318d996b73481a28e9dd8cf3910c4c5270432fb296a95b10a047219d95a1eb27660a3213e7ac7aeea68c18e1e890af07c2c67d80a93edb51876d977bf699e75d13ef8cbbecae336761c25257f5445866cd42e5a093d7322891dcf253dff9d582b84464d55222e0b375ded95fc791e6a6fa48197752672edc319356ded869f666107a7092d3ed86c2cf8476e19aa18d5f11734a5aa82f9e6e619c449b161774b6fb3d2ebc83e8efa075758913492d8cfe1376fd88e7e7586a4045e6287667a36fbc793b1bba932c6cb0fff4ae3efc59fad0226eb2b1ceb5178265ba8793194a26821c0cd7cd804db8e27be59c12bfc46603e7eed8de683b64ed4fb07e3a994bb794c383848d3b64981306767bcb983f5c4994bd14ac9e91b19e314aac52f036f14e2ee6e30ec34317a6abbd42acfb0f1a9cfeb665025fea8d89b9e0866339cc004a0ab2813f7e900125bf1d644ff7cc219fb78994ef3b9622e747961725b8614112cc4012a51b42518bc9a91806b8bdda904366dd74bc22853c6e670525eeed98ccee5a252a334790dedfa45f981e8c8c2097d39eb45e25e838a5cdb3bf9453ce75a0790b190f53cf2afd7c847d0c840da0ec808133708158d86d920715ed28974d77e91916aa1ec7633cb86cea8a211bff94d92a10b5cea3987f2a247fb1423698fb8b9d46993c598ffb85b9a1338535cf5b51788498027ded0ff22d6f5ae6dcdfb152104904d9690c5df1ce238de905ccc436687df4bbd7350d1c7d6793bef4bc7bd77929f53ac998e8b01415c27f11fa67897791b5589cb7a78de9329fb6beb7e3d7553ae9ee845642a7c527b41dcfab06951ed99dc60c0324d7b94803b86fc6b73d4ef4ead4cd88db51c42887fb218fbd8e7eb3da45bbaf9bddc099e50afbd259dd82063983ef1bf1c84ca97182be4c9a4efa4d911a2c1eb81fc100aa3877a5a7ff4efd337d2c539d7ebe46cc417af3aaa21b287bc14918b0a41a648930bef6daa138b34b302485766ff1f500c0e150dfa5d046836ff23699e1614b9af70516df8218363a011fe3c892f23c43276ac423910f8833c833dde8ee14c9488474f002e3fe75026a3c0598f74b59407e43cc7f26ded0f519c1acf461dc4ad57481e44f71ffad82af4be23208902a49b486c7ac7b92554180e3ea82528da78e45e5bae747d625f333af9a958d591242d19fe988ebd896c0a9d8303aba46431b77185b1794d5aded4b31fe0515bc236c69b45cfca009d5e481bd140f5e82943c190242d36cd7fd01b1af2b149be4a1b84733ddf94d6b9e12672fb0ceb667bbdedd6d0e6b40131e8ccfc2cce0bb1a09c177f0b639f5cc779e139e761fc1c2c924b79b0e95152dad2f279d0e4f9c85d9bb03ae396f0d24cd73cd09b2bf11062e6c2fa36a145ecf1636be96cd5386bdf4a480ecc7207c678b56982b2e1a2975e3b050b1141fb514d642158978c23b99d58aa69c6ec24f0096f55126780aab78adf60f17e95c85e3cc3c0c0abf7eeeafc07e58a4377fa3cd9ab12e204d31a0f4440c96161898cf149b0cff9f861a0776d0a1956dd428cc1980bc10d141a316fc2d7daacb71b2f109b28a15a5d9d74307d26a868d2a2cf2f14957c86b22330b062c7d92648d04581f959facca716c3a1d62abd10d730908760794c147514ce0e83496365fcfe49891ae843362100e64d5b5397d25181e5af19f0888b907e6cac7d22b05a20158c120bdbc439e74c2938a533b2fc1f5bd7e3e58570a8d9461b476a7ac6c3172aee8cc5dc02203b86549780e86394a3dc392dfa6a431848f2227fc12863a3dbe8d5bed26815f19e846fdd465bdc377fcc51c4587c86758bcf5c8728e7a9c1794e1fb2a4b1329db30ab157cd0eb47b83eaaa3e113d58b3ba80ff18888c8b7da40a2df186cbbc09d6e9ac681ad831fd011acbcabe9e499f98baec9accff29dfb3b37b98180591e9dd188e3eeee90f50d8e6834d9a9a894120e1a830343d64ac25fc655ecd05cf0aca6c8cc2f1b49128aab283d71fc022bf9b79c246855e884c61f744b916ce85dc353ff7e5d7ad45e6cbe3447457419e2d44e22692478138919a5c9b063fbf76756cb713bb355c8775ed96518c9b2c426bb356cdd67ed1402effcf618aac73dd6981137e2ed22127648fd0d8964751ad64d040f3bb54a436928531636bf1c7c763efb811f24844ba6fcf7f89af6a210173bbabda1106f668388d514b79d42808d1396c8daddef8d3d8809b30b8995cd9e559272916f909b478231e3d8e787e1eaf59550a9c82715161ca56c385a2514129e60a3f040b6137556146dc4e388d33e77a6ae160861dbfeb1a9ae93d4f0c78d488774bf0e3254658bb4092cc56d622f90f819a014e2973e7bb2b3923d32a1072c127ab31f8ed9c1a96ded54819e6ac711d92473ad1a184d00b9038fcef9af2f2373f0e541c7c1bf26943321a7d554a756294a0ff8a5b89e18bdf625ed18dfd17692614ae197cba494657620dcabfde0391958c8ab30d594bc20b2901f80a2194a417028157ff17a79b97a452012bc643edf8c58ed2a9671f1168b20424d03dd182bc160a63461db393df3b558e3cb3ea407b99e5575cbb023abe53ba0c5735bd65d5dd2784100797d128e9f0018c707cd670660ecd07bd30dd9a0ecc06e590af1aafdefe1f37c00697df911d4fcd2ae6425836fb2cf9a30fcf118b618f5f2d2170cade41039d52ecdf3b5c96207a8718f055664aa4a5d0936c5eb29521a088ddda85eaa2400113cf9afaefe3c4f72d3f15ba256bad00a7f2879c1881a696b4e9f2bba5453fc4339f0df814b05845ad2d10b1dfc9adde4821493b8116d37d0573722a506e50112ae8ff9283ee5f5ffb9c92976d5d7ed53fdc094197b4fc0bfbf58a58cbf8730552d3b86954512b7844f3da4ff31a026b270f75c1ec6e30c60eaeed6414b73b33408b27ee7540aec1125f3d95e5c4a7ff5fcb67841d1060af6f465edac9ff2deec776f92315f8ae8d01d6a067a1996c631bfb85b72437696146a4e4c80bba7f8724a694355252be73c8c1b541eb1c04f3fb4f9d0ec3be759ff710b201f52b889438c2b5c0db5811c808c2cebf98235b3157469a79a5831c610bc73159343219bbae6ef76db12bdc0b28519ccd596de9d122b60074c04e2228ecba615d495c8a8e08f8639ca4f1ca9bd246f58aafa311939960d035d2962f450b041c6ace81f5767361d1fbd4381144171653fd6943dc3d0108b0259ab38319775a76f1de7948d5b8e930ca72d908f6186e2d36c60fd0f9b791e0563001b8b0fbf91f8eb959716baa751fce2bf3b3b43f680b017374e03200e5c1c2b676f4f2042f9a0c609d46da026f1e2db897135338a7b3238a41eb2d5f0da92142b5d71451d5bae122db907d6218e52c57ca02720016f6d74d55aff8773db58e4ef03e4e71b8e11a46e396e297fb25a94a4a539a9462b648400e710eaf3b8f0ae79a9d1389bf72e10496d096a314133903f3b30dd8f14a5d1479d6976674e63c1fb01f92d957cd40c576266a0d6152e3c2f6bef40592eb158bd19e430e6bbc96cdee770f39686929f7372b3515675bed497b0c806ab76eb4243ebe066c75aeb5df198507914f8ca5fe6a696fbc3e48835bdf6cbf2cbdc2d11099b03a376efd2947e6662593d61b801192c06c20a15e973417f7d59a00f482690a2db2d4b9794163557a2144dfc2c9afe20efcf1e4119f8c8e27c513379998d29d04b2e8f03a9fb1ab69f11743d4c46338e385bad00d3e05584c3d4a7a534a52cfa6df5341ebbe0109281f4139b3da5e1b5cc5a9be44f7ce73a964617a9ac7191823b175d3ec06472a68ffba4a5f998ff4a781e980bc1eb521307e3cf5b474ba770323c8b70ff2ecc0f6246a6dac8f697142ef06bdbf9e4b707216c913d1fc95f4dc769a33cffa71999a34d3ea81176aec31c47f9bc3bf55a1fc17eedbc046b078d469d3517013d3ab0b45cf286845fa187bdf6ce27041a287c84f6bb8adf540ba52827662c98611121f884e27c46861973660de1504f6b7fb33002b678cfa7ae5ae87e5463fc36ca865e6f268cbca46b43689833a4323ec9a2cb9e771324e892d8e0f59958cf0e3d218bce687a739e0bcf24404e5508ba14c77f264954c2dc3820802f77f7c6abbd905bbdf097c6a8b312a449939229d82de7da92653d0e2dbf6c840d1586c3ad81f011f672c4334333f0a2ec7230b6180c8ebb678464f6e21e182705db52f26836e283881ee42dad7a5e8b027f2463cfda794067775407abaa1189ac7381ceeaab52abdff23c6b7036de8d521880b9ca500e122f8255d51fb28726fcde7d000cdc630427e9fed6ca053f0e8097e75476a9a85d6fdf186aab0c033efef242f8c9e8267e547b81f12d6abbc44a554eb793e4792ae75627fc99bcff122427e2b0958c049d07b7c2464b3d017a62ed4ae5f91dffa00e115c854451e789e91034189482e7e2f028e399254a60a5d259119290ed78f6241c4ae268a5cb944bd4a0fa5516c6beab4c27e2711d59c27c86722a50b1268e591299d7da9807a2ab66a840b414d91139230134468bfb74753b02ee3c7cabcb6f27ef6798fd0b69a4a48ee2bfc0631a65b4eaa8ae0262ce04cadd73bc030f07f42dd2584325ddd7c94a9d81fae61e30fe96efcf3348fba4141077882f84a660dfe7fb8d23327405f5202df7eba3e125defce3519d5419ad0dad4e4e937501dbfcfa017928953332adcb076187fb5f98383405386c85a250ab2fad88c25964eae9d78ec95a3902dd85598b949d2885fc615d89816d54afa483d2e3b6b8afc1aac2da12919092a9135c77f2ea9492c1e38426f93e454771a771bbcd897270fc176355758e4de16d4d051181035664be0e80edce77540f4c434c4e517af7bf6e63ca6e3a926bba3b8cc7c209c2cc8818efed7902cbcb34ca9a3eaa6efdd2d4739309c52d9a78bbafd0dd9be3930cb9125bd9eb513e1f385c867cf6ec1e3a59752b535a1e4f664b492b43fab5cac90038ae4f5cc0de7754293fb2a13ebe4cdb046ff1f5ec9c8dd6e27ae95fb1c52ffb581cba7d2868d6a99b54b2f79039cefb82f4c353bc3318eb6699c920036e1f992827ed5d02f5b3c525efe6e5e359731f18b21ca880f47fdcb5c5f980da075d403f919b5780df08f64ecfb04d1e102d2cf4790d8c1e42c0e92a796f3e3dff6a2b4c00cd6807eced51027fd1d2b0c1661d5163d391127d2d4e05e5ac1259d0402ef823c382c6e26b30818350a90d88704442e99bf2beee8aad79ade1ce5181bdcfd92abb4d68ba6a57ba1a2617691cf41762793e8be418e247ae3797acb7b5f2adbaf172c83d9fcbff9296bd2fb27be56df1fb972786c7d70e0a4faf0f5239ac2dcf48681a4034bd5c84d45d4841a734a38be6a0ab508542741d3e245e64704352ab345c0fb546be8c65ad036d1e3ceaaae1d4606f7798a59b62b5f8ed499d11f35ee214bf2d1950e0a084a5f1fad80f4dfca60426d3c8d32266a462bf93dfa06b41b8002ba9e106bddf80e931dd43d29d348f0efe18c67544dafe834ac89ffc78ff7149f2442c813833f024a17f45667d5b918174df9bdb611dc5bf42e91f56d50caf362ca7494dd7de1e1edbceb0dde643c850d3b221f9c66eb1810eda8605413fdd9885a221505cf5337753ab818924cafc73047e1922f1516fbd70b2bab1b3fbc0fa16843d3aac8fe9ca896a19753c7bc53f7a3a0db772473a0db6f05841142c43dfda583e74187f08c48e29393c244f6a937ddbe4f47763ffee511d2c8bf96754a55bc490e5b7ffb1b4ecb554cc2cecb6728e404c633822e8518dd936c470d9f86a0bd7ec65b90099b9ce02540cb7c33c864f144fa5c945dda75ae8dd3b19c17c8c045a9d47e9c398ead758f208448e64b43dec3aff87096014f77cf2915ca0b9d9496ef1520a504e93a1555c4d61cc414c58a34d9e2e3c0a70ece01c478b4f3de013326544e2a374317136b6132be9b3abd192159df1340921f9c0718ec094bbd602e16536730aeb6b14151e697fae82444a78acde5617dd14f09a064a51741a351010275f7bcafce24ca94523acdcc74a548ed0f8b2776bf53b15ec684a866a6b3a120ec88299ba70b87f25442a792a5d00a55f53b348327c63c8128d94d8ca71c75e6117430ca2cc664033d1a24338c0ed4985e3a65efe5173799f9a7a5a231c65ba692dae92e95dc265331dec6d1044a7d8a433630379e42992b5a1a52e1b9ccd8b4818537e2403ffaba6918653eb11e39228308ca02148c2ce6cd9096d0c0c0545ad5748deb7aea56358b57cdaf0128efd4afa23fdda1131fdc2aa65dc2f2f3f61b7e61680233d66027b0c35c0b333a8a47bc808bf6a1833209d74101f922692d14d07c5944d9c6fabb86376164983049e2914b3690f6e503d56062fde3d06ae0c9d03bd023757a3054ed50573c4fdeda2fd9082a64dfed56be58c10165413385198dde435eb5376b16e35f7df7cee0edb49ad60885ce58391469926f04207aa71f59e0fe9555db7242aab1349026af35ee5d89d679e4b1787e344ce3063357ec13f5644973e24359f9a54ac50b2e137b5922b092b4cda6a5bd64886fe4393a4cc5dc95d3aea88d7eef7a72fa75cd3c4b4ab78c792ebdd97f1c371638cb18b129ce7b9fa0fc1c9be61dc748a083af8d9e19c8ace43ea61c5b4dd6bbc7f61574cc2679bfd5319dbcd3a2960186344243e381b84e135f57ae096986c24818d47b59d9e2fedbd0bea86ce9140f88502154dd8c72e56f04a6cff67ae81c4f3c19b5d53e0b50707f9251833b092f463076a01a819f0c036d7d5e0913595ffef15792cf184f2cec62a1c33bad68a92e4786be484d86e0054bc3d32d19aae173a83dd99e1c68127009134fc5ded047b6b5dd5c3b57b3f94256b98e400e3ede1b0be991a432bd4a7e0773dbe554dc5877360a204d340b639e6ee5cb6d55377890f702d67ace0429d3c5c6359f55d0aabbe963e793fa6171bf9b9d1bb3cfe403e0daefca6b937ae9f4a5406e92b3a24c3e8dc542363ae78c8bfdd63429f976b13e5974fe1c031fde49559f89adfda1407d0e80e629c5cfae9e3efa9eb847cc33a0ec82b8801e7749177a422fa864ada282116cf0803a8e4a85f4ccb518f1d0e9738734fc5457449403f2e6ba54aeef0c35b521b75494eeb681cea14037408ee2135d040d46458b21c4aeeccad6515629b0c5a11c7b2a903bad387c73b687a935fbbb47efa7ac0b540e261237777588143ce8535203002bce009b1226d454cab95d35bdb1d64b370619f1c2fefa7d95a69b5866052c972d71c69e47c326c0ed487822398a53bc88593fedca10846ad29f654fc86d1e820ffcdc2fddcd2b08cf807e303137ebd5469e78009d35240314328e52f2f5d2b2499e2542c6560a462e0e0ce4d5c0c2c19dbd1dd1afe4644143a738323b4937ac2b9f9793a467d4ee22cfeac2a49b5ff2a0cfa6ed7bfde11915b4fdf8a7bb130230f226ff158c8f58828605bd4d8fb50219399b7806df51c43bf8d1b03b4206beea2532f8c5c2bb062cab612faf6c7c5ea4df9f8a7e12b6ff4e9a3d1105f0fceefa9ebcec5f1676c337c194dbf7f7d43381c9bcf95472ebca699a435a95fccf6cf0ad27cd1ad203084d51ab7239be01079ffaef456cca43ae9e3e845f0b6210e9c6c64fa82d057366184b84214eedfeefcfb55494a887f95b9384df99a173071844534128a6300804a548b9f2c591661769c7d8d5ae61b5ac42f459f25421c7cbfb38d0f6148c592db5e8dc50ae9d029acd93772ccf5e711e70a3ae4b174ddc7d5a5737683a3af4bee2cfe1fd342d5b558715b38166de3b136d24b2164878cb9cd138172d00dcad85d462ab91d5c4dda12be29418c3ed7109d05c2218622b6ca1fbe33c8249d6e6bdabcb2315646fa3748a5b8ca2f96c4e6fe519498aad06ea5d80ddd1648ca628ee1e473ae0bcffa069ba22d493e16fda286acf8f55fe6684e1e24f16519ca9d05dae40e4b17c50c4053fa0905ae969bb8e679818caad986453cd2b4227a8c908916791063cbc40c5101261f54707c96c9fb1c2e4027676ac1aa38563255bb292d6edfeaeedd87367f85271ed07fe97453be2fc12a26827426e026498862001eeb50585e48fcc7f6ac93ebe4ddea04e2f4d6aa85c7f36f153f27579b36e8a85622676a4120d061669c1357fb3e46fe9c314aa8c4b4073652215f1d6046bc7409c6380094acf857a43f9cd194f0cb78b945c8758ff3615fe86edf1f71cd963ad77cc1ec3f06935ff3c1d10594c933fc29b55b68f99c37493595b26175ffe654a9b7d2d4c327810d05ff5c72af62a070baf725b606c83d6b498992c5d70f47e2af7fb5e97b0e28cb94eb83b4632c0666bed08a6de5e5227f96eca689d03d45952361a7484740ef7939b84ab962629270b3d10d4efa7a5159e05d336bc7701d7328f3fc6a865d2fca54fb6afcc63f77ac1734cc0cf7ac39da83caab68ffbe8420cabe51b63ce55aeb3efbd0090e777f10fd2cf3f39da2eebc7a8d8a6347830c97a1fd701217849f6055535e096e647b9854bf8ab4d86638f116a762347ebdcc7eb61725086f5afdddc7ca44b147f510f6b0a356f5aa3286747d687b23e4131534500bf3fca080e290ca04f0e87e01e0b9a756958e2c476744d8edbeb22e10c6894e860b08fba98db972736836d9dd6776c8605ead8a89e2e2a20d4bff48c7ecde38819241fb3400404e24bcff523b821b45368a4111498b95e4574a609773799f8c1e7a7c41687839501ed86c1107bc284b452f7c6c9f7b857d52b49947b57873b909154ee77cf3a9125c03e9507d001e15f53badd3529db218e2171bdc44e6ea2d530753b544e5b2cdd14a4c5a44d3955ffb3f7471e981c5af2faaf9afdb5889f59d5da25978f8bb6d6a459ac8bffc5a2fa455815a736e7e3c8f61647cc96cb334bfb7811eed2d6e8a42c3e4118c7457f5640744d33faec3d13c8422d834f7845c2065026c6fbe2e37189f01b443abe75779585a4fb49db0c65bf9c896b1dbb9b645b3ea53e920523e39351927ecdfbc2868df1bfc9492f88250e264d798b17b312cc8b1a0696d3fdd31ebcc22fce72beb30d37f62a949e69c351f3e5b35be34a574f6a76166f81f2cfaa556116ddd1a2a64a3cac674772611af3f99563dd43638679ae0db922998950535ae4bad6e27605504b198e91db4b772b845953726da1cbcfefc458fc1b212a968a4fd6306eff982b50d17359c5dd7a9102a75ffe4d07cfb0cc554c8082f8aa65179f94673c3e363366ff1b5f3422ad1fe0cccc7e74d81e6c8c21d4bb5ffcfba9b577aedd1936fd8c6dbf3eb9dd630e8ab92a6adda1ada1b99772ae496e1a2b88755b0acfe92fca5ad328ff4ad4c6e3238309a0538a9b1d7d0ae38d30da82d2ec27ef4dc7261779baf0752883588b58a7d7e37e6de80e79f3491700665c0e8cffa5f55958623a4a1925562cd5504986a3b1d10349a48f12de010a201956c51978bed4ad54ab44bf7cc8f8a9f5d282c69c48fb2ff914db97c0271d96c26f0f25b783f8e9049d86c5432420fac50b1f34fc645e131fdfcc0d016bda3a6a029e1703c8fd927e837f8b0ef5db7f5dac87d9d6b4e6ecc62bed6b990f7e1856a3c758924eda0512d6d1cbcfae7dfa2d99465851fd910f3dfe4d6aff0fb2f1a52ff455c8972e837eec38ca3b8fcfc9e394589ddd53bd2fd993613ec59979dd7ae9698821fafeb752b82b819862c49a6c483236c5a08b9bf6e14a619c655169621e7069191cbbc55803fb66d469a0a0a18223379d3ad32e37c8f24bac59b73b02ce3d783f3a7c385e99e0710c6c6f15af4b7baf0ec618fb57b4943c731ba12c446edc8b5d37aae1fb5ae930b7668f865bf9c0f296c2cfc9e8de8fac1b1abc23152e2915153937fa59b792f737e48398e66b8af2d6964fb0029fddc596bf822a2741a53ef46006297e799b2e527476314b4802c931e568613dbd307a83c0e646843c12ae3eebefa96c4974bb27c6bb41a06fd51e03d0af86ad0941cdf0d78ac05a4a4681b0c7a9c5ed48f92ff24b6403aa4e5640c10b189351ec923f210adb2fe463c778955784cb7671db962a101c080e4398be595d958723786e03cbcd44a9cdd3236dc9f6ba2a38a4b5513bf93e5d312d4144f693b7b8be35d27b87a77e6cc43473cc41f7b1de27fde99c8f57906c581311c27f917f968b8056f7bfbad8cd5d14fbc56df4378395d439ae60ba646cc591c95e20c293eaeefd0a8fb01f2794cf8e103836455175b829e23a8d548704b7d8d8ddb0db0d1daa6e3affaab8719bdd20d77b5b7136f270538e157510eb2d31222e3ec92a2676c09f42ebf695e15a5c360589d4c362dd9e7f15c6ef7adb2cbf71bdcc0823abd9f524fb4ddc0a8b489cebc1eba6e6407fc2396cec88e4075170341ea8a7f655ec51ccbb65a13be5d57c60fb6843d01e627e0de41d1d7318a0c17c8d929741175bf3a7e3fb89c004457983724170fcc21c874ebe606a2e78588e40ae9a295ddde1c7916581cc19594e987155be1d91e0a85af10c67dda1a80375a95db8fe5741bc570bb803346e22d4a66e329887cef7bf17abc033fc8acfa645ebf4b6eba862dde17ede20cbfd1e9aab3541e2e286a56b911d6c31226fafdc68050eee005038b88abd952312af06c2ffabf177c2edc7401f5e335665363b1b06618e98b24f7db25ad508a2880bbe3597e799814f99bc528d32a4228dc4b559e5d6b22e5a5a8510677c98de306dd1f0565376321ac5f431ab090262876a2767ea6cf11e77ffdfa813cd7a8cd91a10215e4b9483069e50a751cc9a9c87c620b6224a5dc3331c13257a91539e6477aedf97df6cb5a405f21acc4e8e6a1c7109b58805a4c5074b87d80845d4286ed53af11cce7a7a1f8f3ef2106414065d7bba582ff1769f823e53dcd24eb3dbf6c7f93940c2c7aa4b5dbd7a94f5135df54c91b90c080553cd349a9adb5dcadcbac82ef9db5dd9ee15e7c85e36e57b481388b90b60378ba93c30099e9e0a2a85644568d399f1c0693cc994b119e5f62329f19539ec43339382d4049c2fc401c96e65cbf19d72bb5dd66f5c9a8fd9e13bacecd00aec7cba02e4168e0f4ade07398e93746e1a7c55df698381fef1787f31d046f7b8664b687372f061c1650658b936e768f6123fcbc2dad5360ef7fb6d0e60af2f08fbdce619e02b37ec59dcfb9f327ead08c06137b7ab61e53d2907178c43a65558fe164475390674df71f7c1010f04f502d1f80806bf1b8a653d72b3410565124ca1e89009bce97fb4af753fd49f758dbe13b8564c9f998a1175057465488f3599f17beb29924c25357ba5a2ec045452c630fbae5ef31160925f619f484e2cb5b5581bc1904a9c685458670a07153eaf9bb23fdd066e130405953b652f0475f06290f1f05289fe77fe36cc7fea47523d3a72bbb617c18ed688be74c87091fb99fd8265b01f0079a121ea2570e324bbcc649accb07c0ebf7a03bb21d0de7a29d6db2cfab65e9f6cff111c3d5ddcd04f16a95e00b7b28ebf842616fedefdfc7abe75a663c4b4e741f2ad9830c3d8075b8fb4f4b6fb3c64e5e6c036b170e1935c0a03f87e2d6d1f7fbd494b62ec34a71ff3080b04fbfac2dd9eb83a406907a233b2cf1abd942aa9f51c6e92edaa3bcfbd9aeddc9c38a9c7b73f4c80094960942283da9175dcb56be73b49b859a7cd708e53d42263ef3ba972924024cdde4436ab69034ab6130b4bda0818c635746b9b61e6b4d1001a8ead5e025c99ff70e6180e3fb3b208e83778bb18cf29f847a895ab644041a48c352e1de704743f007c127568b79e80dede096cb78bc7270db87c9ab0cd378eca9e8c508c33deac3fe42380dcf2fcf86b1545336d5046a384264acef80f92314f146d13e1b424a58b336a28fb765b1779d5b1285e1d7bf5648ea8886e33ddf974c5492fe7217351ab5995b8bc9c4593653182f36a89d4ab7ec2b1d50961cbd126afb1ca1b78df4d6df9d636bbb85e98abe2ba5bd4579855942917f6cfe6c7df6aade762f9cf6c3665e3d894447591db2b6ba636077f014587ba976b973badaf52b2b5ae6d322c2a1f14700686e63b546f109b95086df053d0f0a04c05b675f0b563568db7b898acd141346e3ac5ed36dc269c897efabb7478bedd8d2bb1110e76e4eb0725740687910bfb9f2d6e915e5f6a493cd5af897c7bb1ebd07ce552a8fc38c9e36d03ec1974032b96bc2df67354514182446aedb4cb2659b63e69f05730f8fb5017b2867c7576f83c1c5ccbf27a7fcea8c6987895a05a023b47e96438e35a73cf4f2927f4fede66c25323423c4de359d439473db52e09edd3e5bfb20fdea10164beeec61b03acc21548598884946129368be36a7b97dc097eac8efd7c424379e8bb4947fea522ecf664794aaa815e1514098117351857e5ec8f9911affd7d4b1b9f5c70a16136628bb83233416fc02ec785dcbf9477324c9a6c627be989b3afd29983f8681f242bca8ca3b5f849aacd420ca574c4af3758b9846c8ccac03c605b0ebea640034c9c9879511e7c0ec6990c92de8594c42ab34e78e9a422224b191203fb9451ad563ef26c94fc20b23706c41f297d1e560927bfe0cf0e6e4b535cee0c7d0bcb34901075a62ad1758b24d45aaa67edff27bafccb2c7868a4b89e27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
