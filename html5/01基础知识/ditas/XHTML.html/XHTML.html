<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af3da3065c0b70db2977d42093d0d0c8e3ac04e4d9e71121b114ee4a4cfaf4b6ebe1aa593e7f75863fa76f6e345954fbdaa06c37274c251b4ba07b73d94dd294c1af1a48c8c3dcc20a9c1cf9698f2e8b15e0da750692c68b0b4eb07602b76577da3951b7c77b7ca17e8abc160a7ddfb5d5eb4a020b982a0470ccb633e94c060e020563c56cca235dcd2a7b7e0d4198dccce214dd68782617981919635cf7a7f741aabcaa7400c37ca175012a283d3e155bfb51a88f4732709934318f1d2ccf46840f15b17c8310057df12b06e5779037d567f14ff7874dd5cb3ce62860a17b4898a2f5a9cd5fc000e0748b092c6d4a1fc42dcf245b2708a08dffc95bb9b44ce0a01012a8ca5b2138451052b55ddc5715c7661faaeb4a55f3853aa28caa6104c21a643e534fa6b6c0e8b2f96c50cb64a94d21fe8774e52e9e883178ec89c2b61b1dc61914f63e3587e86aa7c76763762d0483c7ac2c26a6154c3ad572ffebdd8fabcab3776ac02947fe5ece00f617c5f6739a3a61c765ddf0b471413a555ed23e5754e025c50504e0b33c84f6b42bfe58fb187f5bfbff66bacc9b8ce1712fb7170dc51ccf2440efa9a9eba29fe9ca28e77a3b67edcd7cc2ef19fe2673f200ac9d53f80457c8df0ca03668504fb6aa1f21eaea3b51330ac20d4ba71be1cfdc28ebbdc7991dfb68a7c5f9ed340a6d970f9251a052370f16e341672726128e3efd64cdc7b1aadd213f67c471a819ea592c1329e11e987f44ae6efe7497c8a0596ef23937162c969022c6cddfbf789ba0ad07e8fcb673b4b23a965b5a4245226e9bc31b71d636ebb62579dd3810573d8cd7983d4a60804254bfc49df05e5f61c20feeb205393725d06b1d75d608a77be2df4ebac0a695a4514a858cc56127693b617730108ee5e79197389c9a3bbfe22e2f19af05921f882858f1f74a8ddd968c2edb18cef96feffad1bb0ab5e125343d64a423cd1ab35e3a59d00a7b56dfe3d0f1ca368ac883a6fe9f0fc4f9914758455378f5849bd278b23df801c46e1099789ab99d6017d5ac7084625ac08047f3af7e222383dbdaf8029369ab38bdf1cc9dd17c47a544ca5586cbac92cc67b8efd022d95b6796ba622099c7e1c4787d3817afaa6c566132ef523b9e2b2d4bd13d86f599a930d1b3d617b9fd20ecb7f4d663fd049eacdc83ee77b9c37e46595799f6b2b3e81dfa7e2680eca93a0244b79ab7825b78028196dd5f2a698c5c4b35b8366f46515d7318d268d004ac060ddfc9d9794113bcd088c26d0a4df87588895b1a23e675a8da3368c3fe29952959c69fa9cd51f1e752e25a579a8bcb9820b086908b067001c09ae7b419da5fb4b007f225874bc4ead31c801c7960f376b9794f0305b8382ecc009d05ae087b48517a2bed316176ea93b0ff99acd1f17545392921e4fbb521199d07a533cc5234bdd5e555afbef25416205dd51820212f2619da06ef43c85d4c37caa756bc2600a7f3c0ae295f6142e65c39c3f623f4e59654e39dbde801a096e56f8008eed74c5ac99ef3731af17eb7eefdce48cd29b944910680ea00b3780437ebea546a3a4d876714ebcb1ad5ffe0ff8a329a723b5d4f0284656d3f4e66083132d76e06a55c67b64defc262e8a4d497185d023d35c67c84c96925959ec3f08ca7a1129f31bfe9419e6a1449a783417526e1e34b5fa493318d95b458db020b8b80fdca3ba1e893866321cfdcdf768afd44c78e6074ef0b835de9c4bbd5b9ebb2943f227ed5f005122d431f46f1059a6533810d6291c76ffbb8fe2c453b6e16e6353fbf3486e000b22ade61adbf9dbda11efeeda40cb1e07703c85e75da173994903dd7a3cd134fa0a725b9e6c68993eb62bf94020197d607734ff6c4d552b70609501acafd5da5d03ab12a911225cc13e6dece0f166e0355d4acd2a75ec1026dc2dc75941a2da65264615d4f9125cd04392880c98aa209ae62a8090c86db83135f318725ab761548aa78d6dd00ce3aa66d0fa53d5b4dc4a0c490d4b1427dc201bf1edc0f29cdd956c7f4f9c634f402e18cbbd22523813993bf4416382b0482fa9792fcabb04664fd773e1039a20a9e9f9263d176fc8a910afffd6c68110f0c8da30a16e3578796a30a3908d284aa17c979b0ef100f50c57af68a519da63da5518ba6fc30b9624dd4369856911a074a38ddb1f346e84a76ebacd8d6599e67b5a22fb304e8e547c42bcdff8b1b19148ca1f620b68ca3b5297800c1701c89a4e5f05a005c3a542ba9bb3e04c4c2b8064c1685e2449d7edac2f673ec35ef7549338e9c7b77cfcbb5e9d0b77e1806766566d0513e08d84e30c2164f9bf5e07b827a9a58a9f083538360cd222e6e4dcacccade70ca0c41c18d8677132a6221149f81bfa1eb5ad52f6ed863192da075dcd533a4562dd8c357a1a1e1b0b518bd5dc71ce0c1bfe7e528447608978027f3393ebab4fcb626ecd792361d87a12da3ae5c7fd402c55984c2aef90633562630e954d475a6f071bb8d64333dbdbc90907c166b9894e261d2b5f129738a65a1a619fd77dc45edcb8726e4295d5d2ed19db4faf11d8fb161b501cf84d0d6c08eef968d4cdeefad99622794db924e498f0e38a8a51d96f3aa2ffa02b60e794044dcf783bda87509cb62238401200e8126ee142cc8d72f9ccd621d74e6decbb0641a0c873c06fa90b4934d77d246f5522c3326aa3f71311b7a82fce2c3c17a70907a54859db7a2ae20fda7899d40e2c23eda7e34e69cc5c9247e9be219e59eedc3c79af78ff174edbc5d5bb30f10ed55282b2ae38f0752f3c18dd123257eb294dc8139448a1cedd239fa1dd4f4022021f5b15b0aa3f395a3d56a38d7ca11ffb59f00b47c692d982618124fdf2dcbaad74039df0fa248b0b1b55d8b6c5d7cedb08ed7ee92190eca66d5c82185611ecbd7f3ad3a75e6b6d464ad29f08ec29461626748b69d123186eb774a6dea603b4b211df3507eabba17b5ac43c99daf548d742d95b8bcb5e8b05aec3bacc8d4a280f4c5c0c267ebb6a343dedce20495bff0f5a3424e450055c492527542941e9f392ef15a5b88faf99f193b45a117feb88ea4cbd7d7a751b8c143e60c437fd09a13d1687f3cbe802dadf82fdb0a49ff416b0e1c567c51350d783b9d167b837ab12e1a5f1a2bb20c49812b467bbd448c46aeb7220b39ab020615cb2a23c3c1e8e6d1de6e8d515cfc3dd585984097dce976a4765be345f606c65b45d399b7cee47c5b6d929c27ee229b0f175352b48495cfc53b8050f9d0785023f8a862a15fb2fae221953b14d39f6846fccbdd5dd6a771442a15c6d370b0e0a405ac7475371e0dd85a5106696388573ee593ab28b5379b37accd709c88738a55d60d22ab4c936ffb3f3876a151c2f86ba197ecf735cce74bbb95df8ed94b07b3804d5827c7519cd50400fcb6765dac8c8999a1f4b5df24e739780174d57396b229da44f1432d485fdb025b1c31c6d7eef247e3790a234c4b2e0b39b4b65d780a0b6d1fb93e138bda33da1316038c37acee9363d5270f36b600487268d132919f5c304023874c65ced4de298f43c07d327d018f4d02a2350054d29e2cf3cfad0dfcec1c0d586ac7c7e30ceb7d8a819d4a082b4d3d5aff79fe9cbb9cc53256007af477b6213b7977fbaf3c360d5054482ac79fa840183fd0dc8b42cdeb5497cbd8500321f4b3eeffcf7b1c5d2cd659770bedaedf4e8f969604eb109a97a763462f94ad9ede070d8243b373d6fa05311ddd7ca8a89f06a802748ec5e12f9ba0285e89ca35d51631ed736893c4c18a2d2f78aa70059c21e77d7df9ac01efb2d52fff77454796c791d07c88d8db0f9494377bad7444fcf1a99bbb9c0762620b589ee7c97b0b859d5f5b7498de7773ce12a891fa0cb82372b7eddbf1957a7b1eef2e05bbe2122aff9b962fbef2be5a084c21be5c38076c6483c1cdfd96d53d58a009b7601efe9a07dc256d77f3139f0ccbe638d86330a8bc92eaa99313eadbe1140224b048d6d6615ae6d77c648ee49a4974dd98085a6d0224f6a2897921535ef3bc0997c0fbd3700efe80028c8722187306ba2608ff703e84bfc6828ad6b08e1c99ee5eae305b9b50c669b600e18998ff1acd8a489313bdbe68077639027b2a4154ea1d903de571f75d572fdfd5e81e9da0b69f3a2b5b7e08a28fe01c7e26708636528bbbf4b3e2b7794723c541eba04ceff511012a515b44b3ff88471c76ab8ffb92630126b4c3b6b94dde48a6e621afa62c6f374f909a9a17fe3feb6bf8037713e7f1156deae22c8491ff2ef9da0a82138f30f86d62764dd480fc8ff2d7095ecf00f1117fad778670798a3def6ef144eec4c2e836803996846b9f09141b47d34009fae731cafdd30c8cdf39d2dd6c11365973b1455106f0d51bce0c647978387220e5062f82814c8bd4dd1f406524fd6f83a942337d250d7e7893282237cbd70b491430967e983f1e608a34422a0211968a696c1cb9370aa0d0d52064f28c85f388bb4779aba188aa049224ff3530f87823c21af97d2a360cfa74857dedc7db633dca60fa90008b884a1487ceb005072f6ca18b0ce716656a080fd503efa1880e3935e6dd210406d71d52a0a54e7f09b763265cea50a5ed6c1dbd1999da7316d2453dff4c6633b2275a5b17464d881bb3247b74048c7a93a6ff9274d3590a78f6446f1215e49c9b761e236daa400d5fc34b11fb265063a1bcff7a0feeab9d336790e081447c1f22e479a81f5109964a061ad5e24adc2c593c7c72752a03ce446bb0a7474bbc083a8a524ce46dd44a57df0c29de59ca83578588d393d016b3b1023d56648c3ee813de544c1f7aecc946dbd3c7c30904205a0ec6032a9af1437d9b9b79127fc0e1939e4735755d7bd481ed2ba9d5482c4981d0cde370ae2f500d4f095b101b445588917f6534da0edd3428d65adba4d3900fdd5786df945d65a0dea85d5f9036d7c4df32ca99d32f8a6941976e02f56d454ae1e05920e88348fb855cc257aeea0ec8f03613e18a3e4670b833c5d4652f939bce47a304d5e3837ff941daa86188e425a473c176b8b13a4e2f8daf4b8e096d49a070fb6accb0a7d9c9048f6850507ea1f837c27db8b5330f119b423dae1a0adbdd6b8b377fec5894a2bbe01aa8bfa8123a9f4ad85c2612898af0d11299f793cfb5b8ee457ab9121ce15224c61299f9947ce8cd915ee96798eb699927f1f40265db0438161ee6550fdfe986d7140929957768439ccb884f06e0d3b87e285fd47958d540affb1470144150f85fec9f08c4c1ba6162e382915dbfc1d51a85cbf67930599dc4b9471d5c3306bbf7da99604bbce83ab75595aa1d729b936be68944183a5d83fe70349bcd183fb80a44e6aca960939bf272f4064ebf8b319b11ab99b3654da7cfd0fa53d0aabf9fbfdb701d04317e58f887322237c537c7a0c8dc215a818af9e1fd54dc683249d822d179e8a7c0b4f44391be17e46c0fb804770959057a2ec031f7342e72b2c15496062a9a92017012bdf53fa36d15f5ea50fe01195ff9db0da62b03d0e1a99c2e33d9bae87611d03a09d3ae331d7703d8babbff2c43f68bb64820dc691040bd421474848eb3cda6a70842fce68bd0b3b4dfcc07be04e08b211fbb230c30d6af7a61435430808b879814c520ae1b0b7788a60c13c87d31bec87e88a0b47e1fb34113959497ff22e788dd7dc435f0429285fa8b5bf8de74881bf01b64cfffc4535c7779dc41d7cd40107315b71488577bf42be8bcf836c286afebdcd5979219a5e4232f59b1d0b6f2912892660dd969f3681b169df21c6db8380e57bdce7043e59949ecf3c4172b32e1562626cb2fa05781addbef9c051e0ad414200d8958d2309873ed06d1f1b0622a2239060d5c79a20fc5d7503911467c89b1e3d5b4649b4e66bce23cb5eb7afad2d2a5166647eddf991a6941b8ee27c4a90b8c79e8dc0b53c3e78873da0b5d234324df21da4c63821ccbefe951983662f7b0952cf323ec096aa4d1f72311871d008958848d37c07c846183e657dece6f4bc7eab9c7275f444efbc35743d94b987f9bcb917864da9ee6427da05ba401544c8a34b8af6e5f5e2e094560ed3199127c131681404a75cb38d63582c34fcedb5e7445c105a42a636b10f503554e05d17914d52715e114a8024d2df13b2107ebf5e5c3c9efb7ef43986ea7ae748756f86024442133e0cd28da6850f563516b4bc8e00a402e56fb85bfbbd4a4feacb642de57531049dfc3f865e6e401430eb33af49099a515255d606ffececab4bb88b1825168ee3551b3b3e29c4ad5b8637ef2f07d70df4c084cf0e7f3e7404eae6abadf83d7d8209cd41715e6ec3e23c9ce40d63868ee1c57c52985196ee28bc82b4d9f1dfad9cacdc45adfde4426b606e708b26f8bc0bdf142931c1235e9f2cf427625790c3d718f730ad7b3d64fe3146203c11f0a7944f119b1452720011e933be0877635d4a30167736e93a29f5ad838a856296557cf3028c69676894ab282fb25144c48d8538a7e97226be7aee25eb9e12d3b9445f7295d89ef51bc91c4ebf0a0af22eaef055cd30a7e9d8ac3881b9f1380ea43d001341f7c872b94380cc2ae3dec19ca5410c913d7e240365619656f8d17e74a7ede4c06738d2ba93a6d1aa06dd72bc040bf5b781931179d848da2645dfd11f6d45cc780d2f20bc97003be6f2d41c86c6eaeb1e76e66100b33c056274578119aad91e8bac0791b5d158b912bb22a84fe86226d3711e36487fd66c8c4b3ce64839aee520480b2c4d71982121f90a1dbc9d2cac8d9ee4b5eb4222057c8de4abb2141c5f2e9af98c1042704b2a8e4399c719696eba446fcb1ab64df9f05656d366e048b8df2fd64c3cb30d307204e842611a8e0aa8f069c21fbd96b9438b27a7c8d2ae41b706207c179c6c5b6c64cd6bb654053eeda1db0479ec0e007d4086dc5cda17195134e1718fb0fdb349bfdee5623a1794ba5b8eee88f3d1d6d46c4059d1d40152eb344d41ebea505cfee493c7b216dc4dc3a13e2dfcb2135cf0ad59987e9badd2a57734256a93b11162347b98b9868b07ffacf9936787676829e3108a9f0c0ff3cf07463c7bc10a12b53c8ce2f6b3e04dd484e8372790751f04ecd67da1ef98f211e9a07b3fa3e2d136c5575fafde91dac81a9705516a80f55507bfee8cc2b56aba78809a0144ec23d3492d86041f24c5acc0c9547769d38e87c3564986c2297c30ed5d361e21752cc6af5241546d634b601697ca43eff588ea2c931116c7b5e41d57aef1dab7a1a4bc723c558bbf8f2a7f180ee74746b5d6168a8c4d555370f6635eca0f986c83981304d984dd5f38109cbe0e87394a7e128d71357c2da8a0f5c9b3ff133d3828fba96251d6686e31e9b2d38b616e41a3c2c334c45a80afe359a90c6d999602bb3466d8264d13f9b1796bc62aefeee5e53f2e74e3b9ff2dac7842c3304628fd206f24c8dcc6c2928574dfea131e8cbb423db71b172df813429ae3ccda4cf7271b822f8ec95151aacfefaf6531f3c57931efbf5f5cf1de6c3430f2fe4eebc9735dc45272baf97b5963f554b428bb734f5fd567d3a601627bbb7bd388c35d257083e1d4aca31466857bb66ad4e46470ebef9799c7fcb404aca92ee3bebf8755ce3cdb15862571d536116e0563bc3071c528735949b7e713cee0f83526201833aa0475824f910a3092c2cd5d28b47c95838c841d9f65e7e53c4c76ea30688066f48ebe926b1680fa346de695729b7ceed397883afac6288dfa5de59a0ae9bdd08ae8eb452fd193106080fddb10f6cd7b251c6c44ce59a063b4a98b4cb26b154f2c7a83fa532b1e496f2dab86dd61e6f55962cad8049a29cafefeaff3ca71192407489bec03a847442c4bf7a4b5edb22d68856905ee7b9bfaede3a9f959043a0897f520754f3b0b8f9584359874050e25c69ccb8c16b1861738fe721d804670e7ba3015602d130ce6d8d144cba9e9ecb58c897ac4b6fcc4f5fc78b6860769edfa5034fbce2936e4a0ba54473a3960e5662dd5ee48c60ee82a8a0bb95e8fa3da1d3de03f31a456780c4eb86c60a5d8c7c9d090ffe6468d9f4a92db93340e8f57c9dfd8ef1b4d4b261a99b75ecc04f9c722f7e69633d666e2e20696e4257a8d835f7f80d613e6787bdb0dde393d4c9b56e59aa5f9af1af084be2e96a333dee23554d598fb250c4323034b5cf721609c3c23d01b1b2a078dd6da3e0be5cacc3538239ed8eda99ec56bb74e1ab80a2171392d651fa71f06f60629be9d2277f3629626e4d40492c4b37e22cb795ac3e869e074feab5b58a5c1dd22b9de21511b4386737292dcf1385b3e86d93393bd7ca01d4d64d58b98ca0d3a5acb1e149be0c77d418a028af9a2d5d0ea259d5f5c356169ee8bd1150825009a00ae988996aaf4c7c073b658059a39384cb0b29ef4eee0a1e6622197d802b77f2f58ae18a4ca86aa547b58d04adc0cacd8fa05c7994ad64a578b84a486d21d64a83b3538770df635c3594972eb48469a8910cac0994345ef2929f7223b8b0952abfa04377d97093d0a3a7e7a49da5e60aa7e7e5833ddcc874c124298b040ec6e1b585049709f369878365ea5bfb08d35591204a47e7e4634b32c3b130d92bebe1ce4604ed716a2bd505597bfe369f0113aca15459b4f2b1de651603a1cea246492b7c5bc0f69c0f82775f944595f3e39fb7c4315d18079e7864d17e1a79fa95712747c9125edd06aa81e98212563d251d7d622478ca3a883a1acf0035916e6b2089de3d4c65bbbfa3029f3e970fe8fdea8a54cd6d1f8c0a29814a33de7f752a55f2f435958c37491cd4fca689b85439ee4d5f3e8eabc54dc38c5e57c36274f5ed172e7034046d2066be1d725452020136c6d197bb7c63e2e1f9e69448c660e7dc12c7a29db66cebe149738a737c0a5b1ec16c25f5cca77a5818b4ed1fbd682b612b57064afc131b9cc8e40abc7d7ff515da0455e22f1ef96770362c00a7f36685f15a96d88937b0db01f52a884cd9f71c9ce93daf5c70726ca1f8054c13f04f78f9c849102676d607d5a251c69f5c5073a7d423ef10c6c5ede73ca3ce18ed0153b33c9b21a78f73615e56fe5dd0dc2ee157ad497c58408c19f6b51f9e544ed128555721ed341f37c575c6f77d5fc64939cb3a410fc11ce799391507c138691db15df64511a49e08006e719b2befbd4e216bc702bb5aeee0d1e19a7247bb46ee4a8814c6f270243d90fdaa997e5b001256c833908c390e67be46121d34ddb92fe1b3b372c78e8726f0b0ee65116aa8d418cdefa625b3e40d363203cbc37281d2ad71deb900a587e64b72c00d50be9fcd3f92f53c52d60a7d51fecc9d54db4843c0ee59d46b5ab59eb193699cf2cb6d7ae2e318e2139b9e14ce6615945df7688a0c85ada6e26105ba03f7557e4ad84479e93d4493dae10885ac7d51c313e6418cf2ed7c86c9912fc52bcc8e6a775b4cc29c3ee80e03868f18f588fb40fcb6e3dc163d62b0f0e1e36435658f07638fa025eec7bdfa99cde0afae0c07355bd6d22b3514b81e6da167fadfd0bdb3020952acbc42ba559461b37d015df6a900f019739aca7d35c8cd6e6f18fb67d432798416e104dbaa0f4bc3a995bd7c255244d35d707dcfc6a0897c96f2862ffd13a321314264842dc75c8a51f43cfd7a14b850a2659b5398126ff43917e9a0ab2aaba0fed20ab332e326cac16f1a9429efdeec4a158cd4c80ce86b116227821a3ebb30be749fde3505c1926f084b4dbed058f0aa4235ab3e5290338e444fd77a2249c92ca9983da84fcfca9cfec8aacbb33a176ea8f126e72d620aafaab088cf7ddfdda78f2e13a2fc41ad1bd0851612317c436dba45defe01d6f0a6b20b8a98cc077ae43f77d80848a928d06452713398518222762acb2413b66b2ac9d9a18afef7b6a7bfc6b4676093b911759b07b68792f885acde9e75c4f7873de89dec31c41d9054e3e8d22b759775d4a22f49dd4548a472807415a054997de76b81b18f4a5afd8a7cb4f05c25882f3784e1b5cf9e5558a389fda770629916a7baf7a33adc20f432455769562961d925897ba3d4ecdb9a121882b75ab7c2acf15793ff321c74e84c31a154ac57e7d7681cfd52c809b204de0ea49fe75110405a3d4b55ea2c296465a1587960fce1c4bb0c45d99ac4436467fa9c4a89c17a9ea1514cfa0330460224e35cf758690425dfac571ae1a60bdd4db2a15e53def5767fa4ce7fcbca5659f6d44e90e44b9ca52bdf3d597c679e1583d209de348a75b257570c62dbce06a46af682d28cf3cc5a3c6e4b6f96af72ce56bf440157c0c5977210fa8b9da48b25ab16661fe5857d906384fa3ed74bc3d1f60a9a6f18856b2334b6ea55ba50ba1cf0d2cd6120a98d7cbfa8440e4545002c76ce0f4ec26301c7a81b1ee01903f11afa9973868648539e072e6bc41f7c7742affbdc62890a582d3b19320181deeefc11e47587b412fa34c656182f0b765e6303186b5eef6da4e20e4a6acdc6c65554c71a2e6998ec2ab30811b02406a7cceebb8ad3562b2bade4ce585b57fc47cee3ec4210aad1bc8b9c025c440df03372e0e5e720d7150c09db847aab2149e343303d0606d74fac76ea1a805eef1d64f1e1b18219ea293ec3cb02ce56b57a1f93409a28141a879a1e138edfeb61f3d2d8eddc6c202324660afc670a5209cf3b8dd20c7f066326c1eab2fadaaff45a675896461ba7b0fcc4f2751fb632f510ef4447a84cbc1f6a8fdd62cc76bd5d24b99ef3255d58a06722151e5615a143f6eca98d8f5cd81466276893a244f89cb9abdeb404041aea3781f9ee58d05620163b2d0c3c3060161b74127d115ff872782716244b940f5accbf63157c252128007ceeedc71a4061af5ddb219995f1b8e92a06e4bfdb3f3ab27e026d4b6f41f3590c82d04a32a4ee31eec40e9a1033c2c7488a7a0b90464588ed95aba2e7b53bf2a0ece12fd3ef0ea12ed2b3ae20922b2f595822481165eb0f6c806585664a872b0c48d27603bfd2588d52220a37ec71138c70dc18c55a90b92ae9c9ae91d6cea4b849805ca72a1a36832859aaab35bd70150f5af6ef6412f6e516e2c4fac3792429e1e22d1ff8f349ac555285940320f68155caff17077caf7b1201b53e20eb3181d3af1f95151c00517ff601897e0bc6edbfa2cccad11e2fa4a803f818a138268515e86060144bf3c3fde938746cd9696bbf529cf80ef7a18989121e7f282186b3fbd621c1894efefaded929d4171379f2106bbbca09f2e3c15d733820f621fc9e71953746bdd3e4937ca779f2e9429824cd726743f62a8b9b237b735a95780508d84bb703e69ef730c7ae595261b25372edbcf6b11568034fae452aa831e2ebf49ff9de8e80e34469c069ce2fbfb31ad2df141cdcbef50ea7734dfa064a21c40b5f7227f60df257daf15e001dea05f853756832ef8380eba27bd14b9233bbc33e784badd51767823d6a144294e525015b0111340ff5e49c5b3cdaf9576c5ebaad0dcb64fd8b4b3ddda32fc68217bccb1d84c7babf215d1db3a58a5a73707ce328cdfc35220ebbe87c7c991ffb0b144def41fd2532629599583e683aba1c82c0959c668c91b1d98f9659b90d7f12a71d453b677f986220363653b7ec46f0a43fe89c9b8934725237e72ce321f721d8d27df11f902549727734a76a82e62e7ac27417d606bc662af9f9b5328a3703a95878a6bb572f7c788fd6fb0e919d885d203636df067f6be0f22d048ebda9f4f43bc1a5b3dbbab01dfb0d76244939cce87bbe9aff525a63c7faca45fb451af513d96535e1f257e97439295ec89c8a5fd845b802b28709528b38e12ecb70fbea137aa3d13519dd33831c5a1329bc77cff86976eabc3bf1044c47ce1dfa6a3bf22f424753cfbaed5ae76d0795e416499f1574c724dd8333bd5a9993ef3bee11c28b98d4a7153bfeca0962aee1db731ec7a02d4a91803a4caa25513f5db0377a2fe362116ad039324bc953d57b9eb7463a52319e9631d629bd9d22b0d7039aa5eb0e71b8403cd9c0be5879680ed083cb3d7b57d6bbab8be9f0046bb537758884b6c1af436f666c7a98bf08dd3c23c91bc465d1e7855842fd9f901d737cfb96c4f0576da435a8dda516bf1a69770b3f1c09b278b0ec3dbc0200d351ca9138c01dc95ac1997c563ad69945863061d3da1d3fba1d86e49afba6e033a1f847caa43dac605feef2ce06c63260c60f9abecd18b10d2b35ec099d01cb5237a4f5ffc72afac2abfc35c61188b212610447db3f4d7406410166929efa6fd391b6031625b88d6f31bc3edbbedb05d72ac42609d597c96957f4abd18c13488431dce8487c97b1d53e62c712eecff4aa0d6534fa5f18190645823f850e1a4c291bf631b6cad29861e92288aa9bb570b48f3c0b5a3e8b49e427818335a1d576e8c37c5078091c4db7e6c2d755cd3582d02c0f7ff63897b033ad2436ad4464bd087803ede8aa8de6aa06c415ee1ebb380eab225b117f676f88daf44ed5234f96a799a6a4bca2d791790ae48689437f29858ac8d617e397c6d5ba8ea440191222c10c852d3252b728503047c8c8f71f35a0468ff5ed2a37254c4e10a463980ed98054538afac3ca65f2cc8831d21936f9605216e73a0c1ba1d5b0a01e324c4373edd240d0c4a9619bff6fe3826a564a2216219a7d1b89df376915c9a24682d98844795caec81691e166c7a693c6bdda8ce98b81fee32068698fd94e6d76f9b85fa207479eafcda76e09469655b42e8bce2d5bb20f4b1a3e87ce263fdc3055a2ce299440609274e0a76cb191f8dfbced870d18fd011d784903a485251efb21e6845155f32f2d7603b214b56629cf087a2b02285ab04b9f32681865c72c88a5cdcda6d80eb6e5688754c6765e8c46a052dafc2c5d2612bc27f8937c2ef4a99b5f53fd385ddef3c86ac08557df23a4aac503e821b89e364ddd4d5c2bb1acd7604dac907837f700b9a35a089bbb2ae47663dc05c4bbe14c8c060f79abf2a0311ad88c61142b152232d8950b2ba7b79e0e30467fd45a6437d43e16a8ccc1458a532af333d018c588531940b71fedf9237f8bdb5bc113062ae3e16c370ad3f27f2b526ef525f2a22ed2159355c6f099713875dbe1f5f028ea9e04f4d93a49a619e6f4ea9210b322ce3ccca99c65c21af538f5665f45e6ca1091254714171582aa1707a2f0d3597a1c01ada92920fa63cb1973a6622a1a8d31e85456b02d2766641df4030c5e219f8d0855037213cf6d16e756ce94368569574585266d13b62ba8c0719cf61a993e27b2f8b4edcc3e9a1626dd69499f3b8081562c6821d4fa77321324b96490fd672ba1f54452290c040a55866577e2b97f5423ff90ffa14efe25b3b23fbb971f2c38987f0ddafe855ae6bbb8e430409436bcaa7efc2194b50dab191d8838d5d43d4f0af1ba0055cb82827fdd6ad608532cb99d57ef1c9a7b6b3c51a739e9b58a3a1ddc3076d6cf39db5d896ac20b41e01cc18a25de25b19ad2e32099f155e3f6228e2d937a59ee21c3eeb9c7b9c311418200b8387924b968807e5a99fcd9333775e838cc07ed89a17c0b4d8d7a53897a7bb4547f86604de6f800ebe64d0af26e97cc0ad6f91f966e4c49a2f14540b4b47bc0d15627ba44559fe347d35fd2188d8d6f2bf1f6a3e34e6af5aa6c4d5cd63b51028d63806675384319ac7e4bb4a6d352848e057241c78206866f3256b2353ae6010502b4df3bd3f0d96f5b210479029bad65700c73e3150adf57d21eb3d9f1227144a0e81908db523c04dbcecc318c9a373ecb6356948eb3c224aa04aced293a6690054a426858fc556b877ceb78f272152fe0890cdf3dd133b0cfa279f9d3870a372ce72f68cc7b80aa94d359b20ca620ac2f40d4402ef6c4ee0fc11e9233f81e39b9a01e38a6f623fe34d37a48dddc77eacf876b0948a2a5fa7d3495de4137cf040115c2927d47c8dafa1ef1bd69ba08cdd1f32889ebc30a67cff46e826a8ac6343856788819a28da3141ed5430e6170e86b21e48106fea78605c5d1bd42e3265a9b2aa8113eb88a74095f5cdf6e7f348b148db738fbea789a9665f84437675768ca7f3f7f3c47e02c143c7777537e04f837e186a46487501fc639cf978b453d675b7ce39dce51bf8beec904c066266387656bdea45d44499b8d64c38ad6363933867988d9d230b36c0409bcb91df678a4af531dcb101794bd566b0922fd75cf2a04bc58de1a5ecd62d6ef98fc2fc9e9fe47ae5584e22c6a1cfc35815c757d491a311755191f00bb14fe460f7c06618fabea3f7a845b95e5a9fae59fff2db9cf4bebca625a72306c0730c85f20a2ac872993696f122ca08c025741fac8ce0328596575dbc11f6249ce261dca0a4045451f8c29118aa65dba02f63d5b12ac60981bb5ffb8e528acca22b20e01adfc9c160a1a092015459af0c04ca86d145890ba000d7785f6c74f8aefbf3772d3ace971e6472085618266d4533d7f50cc80dea4ad71229b0431c692d72c478091825aa5be8315509b577a0fd81c0984d554dcc4900ac6f5acfc51e3e60d02dcb0d452a53f73d7be2ddd7e996da54d0238c0aa9d14dfcfbffb792c3cd9416603d359e92190d40d4488e06c49932cb8ae7557ec06a1797b91666278b4b1b5f7893aa21dc88be1c8c2546b9527f9c5cbcfa82e62283fdb83168006be5885e316a17477ca4647342c6d70ea113da8d2f7ce8ff1248511ac609438ba66ece676ea93807d8acf1e4d95a62b7dbd6d11b5c637a5854860d09aabf45169ff29c2d3a43635113ec92a1ca6de1a2ffc5652b244159c02e752eb0e544811a8a71e76694c5bbae9c6972f4d8e9e7583ef8f877657c3afd99256cd64538c2d177e0254b7ace49cc19b78051237b803123e5f2cbca07d50c01d6e9067bf80d178b9a184ed44fbe7117083f1ec01bf29f9db272bc51ce9bdc813410769a63768cb3536222af5f2a5615766fec65572a2a13b07fec4606f4ec4b8238ec04d53f67195b6cbf90b397e4625827624ebfbb82bac97e31629346b94fa271dd62cbeae508fbbef042c0f37ece583373a92a4d5b16dc54d9a7e050e34004a99fc9529bb4747ba663cc55329242001cc5c94083250c0a13bd6894f99d1c358c88fd42869188afe35fc00d9de91730f6793166dcea1ea3f3d5a6e2ef31ff784efab66fbf844e59c47feddd7ac080825cc87c645f20e9cae8832d1df4b782a22affe2d662b35a5b221a3c5954193bdb454a012ec76e2d1f43422ed58b0cf1e026a21cf99326f778aedbd5e53091c11d05b8e02a4d6353cb997998867b460bd4fc9d9ee46e58931b404d233bd9c04df7229b268c0c542dd7da598ffc7cf7b130c6b579820723d57a8b02ecb7c4299690a6b7f6f3c70b1aad8c0d2241e0075b9531b3ff2dcd8859f86eef35bdc86612ea6c4a3356a1685e916d4810e86cad7d22a29e0d5c2cdd95ddc09664646ebc52019ed28fc9ecc02a7adfae01eea196cbaddaa45f83313776249376202172300ab799e6d82862005285a8c0dd3de6966dfc7af9dc9073fc37ce346e18efea9222ec3381aca02dfe152c1634554db6194726c818b5032f7c0c1aa2f3492f1be387ac340b29b9938065c3d05589ac6e725fd3ea121d53165153b4166e14b60715a8d8d765d213c274555cf225fdc82b24b3d801224423566deb82b553a6ec9de0b43cf51646a3aaf71272249676bd0c9ffe1d4ede76b516c0faa65dd3c0661798c6a58900643ee5a8959610dbdbc6eaa17415470ca8327a09ba06c18092270978dce7966a4d60b95dbbb96039ed84119695f8b4a5ca1c2dc5596c19aa713527ddda035ad44f106f3cd977bef8e59ad6ea93d5da71f91790b4500f30eac6e9ed53787078a1ff31b83ddc91b62e1ecfa76517097418dfc04852b83e8fa8af41a377bc7f41b92842f697fca711e488d2f7344f46c621b270e18efd98fa91d87b8347f1caa8a03bce0defecf4d795b5494f806eb79303b97ddcfbe6c24400055dc6957f1f75438b0ca9c334aa0be3a33623fbf317f4a7bbfb1ad433e8c4070de1fc4e766eb65e70755ea3c8600b6aea7738d37adb04a791d6a38825f3b8763fb57f30cf06c04779f89d2b96d31089497d19cbda6ea95a308fb492d6f7d053632e8f9eebc6b890358f306c68c5ae4a4b9ba51766edc8b0048db399878395b8d845d7744a5792201361818e58ad47aace20bc3e1c7b193bb9f53e4421124159c76426783a11b9f231008f9bd9e43bcc79448c91a2c9bcecb922aab6bde2d324e5b241dc56de0b5474e4dba5f5b7ec7df872100ce2fd91ac59ab2e0f0577e73485295433dcfd2469f8008bf7670b2b078e98b54a9245029ba6091535a6f3da363a1fbc40dc5e61c621f68193925ec6198067c0b1f0e29b8eb03ea3e8f8e64d98bcecd1d3787ee62289a403d46a6294895f519556ba14db216b6d5a4a8bd013a860632327ffb0094c0b2d0c61b6ee6c730ab65a401af0ed93acb65cf6dadb3dc040cdaf6856e29a3fd544b3f3018ab8a221df6d82beb6440d9f96ce8a4dd71092d4d471767975c8fd070cd1c5636fa083400ba82da98fb5eab3134420426853bb01a687f959e2d5c0a90f60b208bd2b9a003f8c7634bb8588cc7ee03a099a1d4ff37b2bf8376d0390b2081a715834a0c76512eac3264e48d49c1425f9c57f9369a7c658fe63beab4a1ccbacccb042e2d226bdeb9e499d018fe69821174d69ee6d75d900cdb8306608e884332422a061a2d029c6a31a939bf221cf47c508664ff00be7d63bbd8f778e39f2293a4a23c3ba0fdaf5af7eb20910d84ff42f20f6e7a96abae293f7b665a40e52a60cf01e3957fd8befdd8a486a6e654e0bd4512601838044f207fdc0ba81a8cd2fdd01bea50c2838e77d8357795deb7cd5d9336c1dba6e2077fcdc61bb9021ad416b53152a281b9cb27bcf90d86849ca1c1c96d91ca4315bfa08c200764780aad6607d5367c1892","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
