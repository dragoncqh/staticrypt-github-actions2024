<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"699f8491d4571f6719f07b8b2b20cd2d63ebf352cf88048f3d6e240abab09fc68c1034a54bfc99e31470e49452164e0c7d86f1eb8cd70eb41b047b9a73f692d863107f781a49f6129f2e6a0bd21534e5eb895b8b2ed79be4b3c6a587c502239926e0750fadbb5179fd5a5bc5af22215e019dd573360ba25369b51bda1d244d1c3bb143a12aa8d33f521838c7ea6e759a5a54d3f799956bba980504b6a07917e723aa7a685565c023457f56e16aaa0f93800c8201be78a254c4ed322721b4b1f76a8dbbb9c3f300da044e12982c70c5d5a867d3836ac0a780ecbfe726fb3deacb3e6a788ec805bdc24fecc9146f6668fee737c0708d3f10aadf389761df159e618820a7780ccc3ef23ad74e00ea78d9a3c8dcab668984f020183c36bde30cd0653affc7ab2a12e17b625b0311173f465681933c38828f9f651836db389e1bdbd035c37922d15f41165e9c655f2f8e1e322e0ac0837c9d1c39d550743a8cf2f8d67ae07c1166d7071c5243a65e4ac91363d569ae6c30def858aba9cbcf49fad4613e763044e5d025c0a90c136d872818acbb2ca27fa4012f3e054fee225fc8c1761beca55578c1bda732cef4ab29d6596a3d03f5c77eb1911106e8c9949dc96a886f04ed80e25baae15546e87598d8116ba8aa652514929fd3d84851d818bc520d067f846a771138c3d627609dfc7c6b59c7ba407b82125472ae9c2d71a57c86609a6f2144f9c847209ca1c87b71ca67458761148129a5650aa03c5de52ff8b302ec48d1cd673b366327952e7a6f293cf794f6959401c69c81a5c1e988d8397ca53725b5466cc4d42fffb27896aafdd7b28bc9ef18a010dba0a1c2d349566be5b20caffe551a75666bba85fe4479a7b8fd4135de5efbd5e116dd5679ce746c4a5b5ddddd16df5807e3ce36e4e27ade4e34620cde2d89c6470eaa3eae511b167bb3f8d228b65d07a082ad7e2f8a84db48de860ab5ef7559255f3105aaf990020510677cc7461ae8ac47df6b3729f5ff731fbe1e93eaf08f591346c5566d1403fdb14acaf81ec1096607cb914c4fe6e2c9474b4638f263e16e7ced26d72be473e37fb5f569268b4a9d598dbd63b2347c351cb108494e915a8d08d5f43308b7bd8ec4a28da200e1b7f1ceee355ca6d4b2f8266453a31eb1dbe2441f8f1d267249ae9a6c863110f71ce228e64e380098e2cb7489aa32d774b8cef33df3375dd8712647451a5ce79d5cb9c9c5cdf15fb6f98a040cef43bd966da6129754979c9b932ee143b1a5325d2ee8f508c92ce3b2ff64d26d2d6046952bab2e7dbed50f672569e295cbf80df1fde6ccc2becc482999a862029cb4448c9d6d40fd708712992ceda5046489e978feb5f2d23e22a8583b7fe7636dbe0e804ac1380238e9fc43b03ce11d972954f579281d2497c77edf2d710493687457a93f61b9de025e768063504136159cc645963a7721b814f6131566ad56266343173d8fa509671fad0e04e564b7e40cad3ba915f35e9dbd7ab2abd226fe4581ce27217b38dbf1d4c3b3f72270c17154c5421726eb6e97851577b10f61ed76e683417fcc08d58eb06e3a1f1831b2a3c93aad135b70144c081291e6be9f126eb16838f37a6040cd477d75fc4225bc5b6d08dbf3a48d8f14e8c04f4e914e1b1ea83d8a0ef9a480e2e5cbdb6fe46864dc59bfa4601d201882e6c2dfe3024016a2afde6e767c54c5a881c7f16d3f1e10fbcd987f5afc149fe53f5de09a549076f10e277204803ba4f7dc0c8bc3747b24505146ab3c2616b030806ce8dc310ef06b8685ad8052f7b24adaf61f0dc019c3073e1fe0215540f4a23b2bbc04e4f258a29ea81e6b91c9d99d47487a8861ad37c802c4cb13df60574e96fe178ddc0a6a010552f26e1e16d69e7d990190caf0634227732184efcdb7a824eb6d38a1ed09b019ec7ad3f4695a58626fb526cae466a7a4e6c76497964550f8e37f507851a4808391ec23a78e886252b3584d1d3d8d4ff6dc8181a1d0496ebc3ad1128227cc85b0aeb101c9e19522e96887844488b56a6fec80e82d74518a2d3d087c26e35132a4df1c6a30aadd3f6fe797b6d8f6dbbb7443827aea25fdb570520b45ff2d08da0f50c2f43aa9f6f8b2e22752a119c18c6297d50d9d3a766748423a1e64e8e7e9d149467d133eca3605277c782f408d83429e5dc2a6bce2e98f643d32b8245beab755ac0b821941a92bc73d31d8c01164adea0dfb0d74377ab6bcc8aebe85e596ca86d1af828b2958f02efc1194be3e8066699552311e5c99758a8664a35d2c06fbefea08ce3d4e61ae741855c8e5ec75b9e5c092ab246407374a842986d4a46fc758c8cfec3f5a9171296e9c649cca2eb1b6e9915303dec42fba3af98f1d33d45a3104a10bb5721d03326fb72fc95add527c02b6be98cb78e7ef12832cae6a84b55b9cf87bf07e3ab4097294e7dd373152c419aa7aa702ed66674034f03b921eb8a9495f2fca3ffdf11117a5cb7fa957c5659e67c247bc98bb156ae928728a8270c52313f80e0745cfa3787fa3044fbf85a1bb9a4d30aa7eb18e895e16dfa1def02e1d67b72df2a2a0ad6e12c102ee74a36748377cfdaacf54480f786b6747e893f87f8d21aae151d47cfab68598bb4a517ca890650372eb1381b33c0e2b94810e45a55dba3cd5a45b38f1061450a2b1d68e5ffd40051cb8e3afbc99f49dd675079f846a2162a7c4068e6d4bb815beaa9b0920c4fa2f4677e4c4929cdfd4413d78c8ef9b4ead6b477884ca385ad15fa4192fd818b9b727d754d93575c8eb840d958b3f5b904d4de7cc23b13260c6e7b2bd2e21f5f77a9a2cdc49557d4e24244fb0874b9b53d6ebb235299cf37c1dfd39189986b5011cd52b43e289aec2e0fe8267c9db826316d8eab45c02b71348d816b56e68b1f0bb7b6337ed8e8b1dde670c7a5c40b5d162455ad31ca7d04fb880715196224086f14d8ea2cf2a35fb77846c3ac9252cfc93c8ad26e54c5a93acbb1f2e8b7f94eca468ea51b56759c8fae199a6added6fdb01db5233bcc22ab4ae7a8026f0934d0cf4bb9431634883a4a06045c99a3949fa2d23f0b7d50389301bc9da1f5aa17096c9e8077b16299d710b14a0381acf3e8104ce6b1d701f998767f8a0d926eee10a16e60c877fb6087e42b6d55baf4047c4673f54e970a9c4a8dd39f918004c3b191d3368c57d58e9de7f36cdf2b883d8a42df73aa5122fc4d2d7e00572490e1b7b8b978fa29392e32a644eaa1e2ff1ee0fe4d3b819115a8ecbef210e1409e6a6ce7dcdab813986c0a512aee0b688abbb5f198f22472a3e464cf393036e088df8297ce5ed59238882541d79220a7834aaa497ddf60f289b882d9499fa8537a25d668d29e754aa98ffa53211a7fbb496c336ee6e90f9dfc302e33a29fbf8e37c27136bc4bae1cf7b69611de4c8ef039c40b5558c8c6647be5da3779c579bc1c83dbd9d9d9cb7740c2e65f9f9c071f92fe7571053626814147591304efb6a70211c25fe6e44a41bb130ae68609fb6f1ab0dcefa04f168b049ac746f05a292b2393756186a8badea08d0ac3de8e4fca2c2a2f412b1a0f47254d67d6e557d1be3d4c87383502fb6f9993b151c51cc4a0c942b8b1fe812c222e21357ab1b2ad37f7b92fb9b3b8e839713aaf3432dffce812e31435b9ac41b5fd54e3845269b9e78aa7673280cc1c191f3ffde3b7714e4893df81c7a62cec6434c4a9a5eeee9d42218ec2a913ba044374673717e387656a5a256e7f40828946d7cc328096073a8492dc619a9043a48d8361d7d4b90a1e5f5086418a9fe4a14a3df600beaac9883a3fac76dec61459d50bee4e94be884d6a8b85bc99e6479c750f85df5583e1ddb5851bf6cc61fa3fcc2ff321c480ab68640ac5c056736dd7697ec55b8f2648c04c75a515de61acc96630b70e383e0a0ff0cf25d695041554e0bfdd4c94ad17262d3f53ced4bf197adf085524e32b3d9ce81d788d5e2975cffc81083759262ee96c96240db229e48842306e28727323ec08ef675605e6dd031c2157cedff95fea9458f4cf4e42e4eca18b4d24eed3839525de1492ba7c9d0f6209472a2c1cdcd229edab9cf215db2cbed29fd57775947d278f16061e753ab5f4f23173b0871f7065e363475f57be7f182376030f2e6ed9e56bb2b7ff318bc477614cec667b097812ab6c9555c1e557bc076830e8d704eecf647b5f139141e055d7926a3b7da09f78fd456656b21d7764157900adb6e7e590b5fad1e6ed22b621d8c8925b35fe5dbbe23aa3ef6ccda0eda0bdd52aaabfb2261d108ea5097ce80dc4f378bde24c70835a84eab0817d633c1fd619f25c86695a2e795ce7e8374e554ce61e8a2db7db3e52f7d448915a6358d20e6c53855ddf8cde7662e94fa4849cda7cd967a96d7141653740c13fca01ef4cb068b13cb52fbc76157d326b66436507dec6501f80028feab7fcd56445d6ab543ac6c81f60616eec641ba4a5362671c7d54a0a592fae3fe406354565cd6964de3f438647d05cd69bc3ee866f167c96fb79d4cd41b45cd729abb89274700021240b6ef8d6282ad14d8a6209c08bda88022501e583725b8087160f2fb89e138b55a6eeecfd7a4d42a808f95392a5c2f344784dcdaf9c983e53b21f653b29a31c8fedcec0c6184f8e9d6e864eacba18578657129074a50f741c4445eccffe18366d14ab86543109d3e5ca42056eee9a0860ad021acfec799bf364b893f9b52d57fab803429afad4e37cdc5a9a8ce62b7b960234da13460d1c7bde780f8dfc34c4c012fa05a3c78ac8b4cc616a68aaa540977526b5d94f0d0b0b713496a063280154fefab31fb902686640b012dfae77ddbc8e007b44bbeac948269e9361c7ace9d8b3faf883e2da910a483b016cdd4a590c9a8be522bd25734c9de80d8209dcd9de2026e8e4f13f4065e0d94c001607243eeb72d66181ff9d63e08381f78d899d64dbd0aa847188fbebbf876b6199bf446a3ab79c49c71a42c1413ce53d4971146fbc1d4c0fa1763029b448ee51f6a1b02ead4907dea8ec039c7dc4fa5d9f2cb7fc6ae9af81d22b596660a046280c2fa3f2114817fa6d0c63f5c182a9a70ae253f2e769c500c30c3868627a276417c458d039d87d24350c057490edff142a599a9021208f591c107d8104d642171ad0660a8c4a170b77a8df4bd528a58202174aed83050eae55bcab04ee4d47cdb24f45d6086c397b85008552ac26883e59e9b91375465739d74d07595c546726f76b244bc4982d794019a05eb8bfd4ffed3354343d7dcf2de249eda425f818f22933a0c28b22677b26a87ab2e71fb7b7c00652f325e36591b88c32d275edbfb1a32ac97167d91247bcf04b254ba83745a5b71c3eee7b90abc845a59e7e3ba64f47145234937322f14564e86137a06a0cb7dcaa396f8f248ee0836feea72aea3cee4990243c78cc7422a4f436a431ed672ce0f3636301c1fb3e80a7185f1f7957ededeaa44d4dbbadf6d1989b461106931d145ab00250c39f1c5e6c71c7c44ad8089b2af5648a972292814f0c3871545ed2210bf8c0fdd2439f67fdcbd38ab4511cc54d0c4e6bf7ddc04df7aa7628b8d7720b760038cbc1a3e23d8f7af58155eec1c4b0a1cb4bb88c0c034e87f57a292af1ce0e9dba01e5713e97bb346bffd5d7af49acc1e0bcbf04b57b02d915dadf084bc9e8bcd91fef675e3b4edcf5f46b06ff183ba26519347712919a0f1de2c4758d8d0979c0ef0a05eade2d3a2e3f6d17e14640d8cda32a55634604a5865ac6f486110bb4196e3b064ff45218198e2f7da698870a81c320e8d8cf1ca1f34316fe73765c20d63272b2ed3e0e3c6056d78a0d249c8d5d6c99c8ad219570908d70ba06d5f00e34666f110fa6c286564de69e0e1835e70c9fef265aff62ff6f110d774424d9672b2881ebc3c3ed1aa0492f57c5508e0d92cefc43562fcfe0b67e2688064c036fa4edb0e1eca60f8821bf63b4dba28022aa5c770ded331458012e9b9148c09916c579345f8384244415304e9cc37b264f8720ecf898b91b3f5d7a4ea902010a86274888aab555b0bfd905b046ec68fef2d4072a628e00c782b036f31ae9b2f0c27c7eeb49caf3790676442c996c82cebc976de29c6b252696c94fca561a15fb4e5577f35da96040c6b7ce8dd1dac64c1e46f2427b6f1d97aaa3b0b9f532a5d8473390e4270c9fb247c33ed435a214e8d9574af4a34af07259d2cd149dd1ef54cb8c3d7da84df0f303b83f7765beb930002e133ab000f680e950ed6a391ecc58b74bdc0dc9d732d5a4f98111f1553e01f74c44b04c032eaed2555989b9d97e4efe1a0bb4021bf07bd2db14ec7a822f842b212a3292a0869498a0b83522dde0d01bbdb14d0f3e7ce88eaf3325c448ebe296e8ff88eeb167193b3224a8d5d93a0fee4c2a61936e8595ad4cf3b73e49d8052b28b3f2f002e1a49c17980a5ca8be7484c04a57e10411931d2725929bcd8f59d542c27fdf600e69f4c2e2a6b06c32e2043cac9fe6cedc31da6622528ad50c712ec1154dbd488b1c52e7a096ff1a2b62f840893f08a1fa0d07cbe952c9ee21d9626da3dac81c99e2e4437f5b94149e3a3a83382fa68315692ee432d5dcebb70d507c58e015c10b8d6f81ca5cab55de251118f83cb7dacccf2c1451edaf2d1cb0f9c7ac7efb6dfdb7c344eb629d814f3ed5fa815a57dc2ca9e4bfa41c6411823d497902573945acc34403815b1f14729e60c76bc9f33608eec6f2af48c301fdce6763a5d73e472dfa90db9065ff2b5c5afba7ae1e0a4c54b20e7692bbe504ea5f88393c1acd129c7eee4eeb7d5bee67ecf6ce5b7a70d7651268a954b7bfc183e499b4fd5adf06f4bb3d82aa4355876f11c495575d6e56f4ad7fb4c7b5bc7382142ecd13158ec87a9f6322ceb7cc5647d859aaf99a2183a21edf6d9b26e1c11fc8f722dc2643436ffc54add9f688994fd15ec885f81884d506f750540b42998ba3576d02910257ae4e32a41341b7fc0b93a49d2347201bb42ba832447f993c83a437edb8ac6d0990939471d8ae91c108ea9675c9cdeae2a94ba2427341bc5ade1d0a693d6820d24053002d96e0e6ac8bb921b3704c3e20a79b40c4956bf668a3d35dad28d462502940f624f953f916ae4cea4fb4f9dc22bcd80a8947df3f8e43b6ce4b0b47c751d8eaa8e7cd9b9dd8a9255fb27daea83cb1dd8812a202936fecadee633e2228c17fe23aff8727f2416bb7c74aaa201ff4545f39c86e2ca9820297b63dc3c6efee8da8b434f3a184f1ff7fcd1613546777bb6e63a83346351feeb321bc3ff89bcb985432180d5ff50909a46e1aa6ec37a23e262fca662f896e6641a91a2af786dfbbec28dcf737e73f65ce07d9482f79b22903b7ea95a7fc52368f09dc0d931a5ad945794bd58bb6f78f818eae3303929608f5a95a1a0f13d17fcab11a778af035ace7fc2b7a4a5de9a07b9070112d475f1b507023be2649a8ad94a85729ee6f327623afd4eab84c32207c443f07153942408cdfb04375adaf6b52f932f1a37f0858dc681f212479d7a7ba97410430f59a799f414a2892a32f0306a3979f8d3491a3db8973277af478255ae2c8f6a1bf707622e59e6d21b5beb8ac09a6ef16e5ab6e65d8c11f7bf025685231de0591a4de75b2f80f0d59d103fbacaf6b5d4af2e22df603fd19004b300a1d56030876f7e12c3110bc1ae6af63c8067c1c4d630ffbb0370b603285264505865ab2d41c5e0ee3eda4e3b3076492f3b49a50056ae9a61622b9f730c3c064a14e5b2c453895211f6076076a82a4064af19d0c532b2505662e4a82d13ff9ada70c6f104dfa21bb1bf6e4a19f00d639295388b3a37f96ad3fad9709971703149877b8b3bd039a3dd28ba7c76314e869df4c866df084588cd5132ca1af280135ac5e5cfcabc42864da67d06f6eed45c5af1b8541e43a25d506c430fdbf96b65dd0f2548e04556f167ac538cda2e31ddc6b33301a4abf528fd93510f200c6af201a45e72c6c88cbe2a4ce4f112b593aff69f350b6738b558809df2f8b08838c90b69681503348d1e13fea63946ad5e221bd78e79869b5155321db097dec39d99c3f8d483d233737f0da8d8575ef1c0bd883792fcfde8ad38be2997d791ba83e04841c35e59fb4ec0bf18cb3bf08433e1b60f656648558d46f8f49187b43021f9bc671fb52dace1b3858bea36bd77fb094ed3f7bcb4b83d936873c85900acb8c405c538c57dd1aff0c4cc03a449a3c36b73f9670f9862ba226e05d8f61aa96fe30f74b4ff12d2db5f32c03da0340c3b8e1df28dbcbe04ab40af05aa0300944a36218cb04230bfde7ff262ba0a18e3011ddef4a417643b8b76f78c61519502f23dd11bc34167158ce3f119dde3f457a630e2b384b3bcc35048244f7bf650d55efd4aa75fdc4b4e86d1fa7abdceb11547b4e4b044a3e6e523b42e4c890c7d2348031a6e6023fe7baec49ef89a70344901496f4df96f3b66ade37441e20b6e792a77bcf26c174a6ed26689e649dc23168c9195c07b77b08374f41193d664988d177906a43f53c55f6c1dcf031d5917d3d760171df8d7626a74e436fa82b5082915efee437957aa04c8eede2c669dd78ea36a96927fd39337e20563dabb362480e617ffccc2fc4a0a44d8542b74e35a03d981e4eb94a7e3cdbea1999da105e3fa1b9513ee2bb58b1e3698503f1e45847cef6421cbcc46e9789905af4f9678fe6d8472b2f10cd1b63a7d3780b63e37e91656034df1b6402cd303170f88e520c6c9a268f55d4ce2759b17e42aeb99ffc1ec3060ad5599a0f0d105c147473b1afa6ad1315dd95fa0f9f2dd5c3268808fd1c2fc1de06420c41e8112f430fadd27bc9651bc1862613fba37c7c0bc11b658b04261e9a6d4da6099f1f785ecbf850b11313a832bcefcc9695e3e45f442d94358a455a3c7a26c0dee2c7d3affb2f27ce52b88262a06c323f8b4e2a638c54037658365a194e06d6863fb1ee31d2cda187b5ab4b330b5fbc2e6542648b6e4cc8fc88ab79668b4150f76ee8bc29324f4b63c6c067babda8584ac59a626bebb776547de73cdb83d25975effd311238c8ed0f7cd1a27e2476ba344f3130fe1e5a0a4f0dbb1c39b83cb528af2ca27cb906b35048473f94fff02066ac286a792bcd78e0c41494acbe5f1a8ce1e99d4bfa42520f198597673fdd93840a12bc0a3547a9dfd9cf4688ecd2ee8638a308620b475ea9141599610f6423c6129d75eedf8c3fa2a559083ef955be5ae73d139240f21eb256f2b0c35929cb969c7a7cb3fbd30b0166c2beed6afc9a8ed8224e7639c37beb2e583b6a1cceb92adf93d70b0d989126e57883133569b708dad3c6530f4e74648295ba40ff665bcbf8fb0ff4ecdc10d71bad67c083e043f7902bf652a13cd5e45c2e0a385aea5eff8d62e25535b99d2011ca7881432b6c58d9ad6c807bf1b180d7578d6076ab40d943c82fb144658498a1c50c33f6e80391a4ca4cb082d07fb29a7726cbf0dc0f1e8e29f8b171259369bd50c45ab5596220b63d08dfc2929e7e86fbb4a07b759dc5c19f869de03e4d5844688d0885f138498a453a1581542dcd5b7c09bab5ee65e55e3536f326edbfe2fe15d6d18cea0694c159b8f71c81dde13a8183730901d9808492370e04493bbb1af7882b59b26aeb4fb0bfad0b373d74d382f564687fb6f40de5df12c6e7ff39ae587c6f2a4c7f2c338ea3c3e7dfb080d2d3325f838866101d2fe49a4cef42ecc6caa984b302b1e48ee2bad97bc36868358876affd43a1231e93103a4d2c4c5a526ca7b3e3b350e9560134fd3c39226083c338cda3a920c368f50cfef0a71a5493d713e95aeb91540d63087fac8eae2893ea84dccd3ea5df9841b7dd1d9ea95e92a37a909c751448b5b867ff5f86fb37257cade0d215390e47e7b072c30e5ff50cde25dbd0803fbc30065fa45055ff4a5610c50fe61dcccbe4c73b3c6af2270547215a16db10d05586454214a6966ca09604ac3b60ceef5cf8a2d6fc7a31c77b633cb7f9a76b5e29443897eee3c0728d2557706bba2814cb25955df4fb9736f3ba4f8ace5e5fe303dca301a6db3d32d6595a65c13117bf2a395acabff023a242ca46fb73a4ac204d486dcd8b23bcef3e201fccf59b74a1bf71bf1806ada3c8ad33b5ca9821ac199c55248343c6576ffab0f7d186a94985ebdb18154c96620d19af98b1b057574a6478148c7834528a5a23e5486ae61c277b17606d8dc5174c116ba8f63567acd73dfe2f83c65afd0b5f814717e3d760687d18d33fbf031c4ad4f39c596a4f7b266095c50d7804718e2d4b5f98ffa93e20898252eafc9d500a0abebc14a2cd7184aa74f042db1858ec90854636efd79eeb933ffd33c6e4c116a9f1ddaa47473fce9e4d69bcd8ade1bc789ff84cb2c17190b089b7d1473db7fb97b7e03c9fbec7ce8c71f72a39c2422a7ca2a8a95d5fa55601b529968806d83610eca8391c9983772530f127fda676ff27a085abb78529261f525d09799b50359d3b6b5aec2284e949ea0357561f2a145c2a82944d70f18c5710fef9c12d04d33ab8e1607bc7c301100b67844cf1f34382dcd47830b911809b9bd7cc29a25c022ede3b8c9b2b79cdfb22da3b0bb6495eebf3f03f71b0cb670d26413b1e22785e55b431ac6d2defd041e4f9a2184bebe16715dd556878c2b11f9a0b71bf934352ef3914c81e3d15885600d29cf9369f0501111eeb87ad8639628ee4c5011ba4f8960b0867e33f77e06d3d4e5f72483780116f92d281e4712f302fc1a558149b16cf46fdbf25706d4fb7e2f74ebe0d97e72cc2a0d9eb4318f0de99eae4d44c5f1e9f1e0a44dbf6a90f8b1ddfec685c92662f58c0947de360500438ce29d8c690d8d7726a5f2421b6cff2f388b8a0d7ace8324dfac9638dfeae0071c8a8ebc2b5f3398dce6887e03d51389a66cedba158bd52b0654862bc5b1d08f708963f9b57a9853b387f962dc5d0ae0eac765790ea2178e7cebde3031f422cdee88378510ef55e029bb5b7164e29234f193b1ef07d8f3199c6f3cd44f2c057901e40f592daac975a48902f4880581a966e29d730eeff0a8d0739cafd9e4cc880a09aae7c0b59c398c481fc2687c8480ef5e9e877a96d7a0d6b29058114cc6cf3456764aa0a21b8c4565facbce6b956944798177c0b4ed3d382f86dbd9c3068920379be8c1e6594b245fc613451ef2f87de450208ac40f61dec4eac3691158292939bc90d533a723d688e83142c4e35b5fd1e39870a9cdbd9979f734950a171e1e8d929c9408f6d9a1e2514f6bb39e43ec012e7ff2ce72fcabb56a9447b005635ecb12d274fc189805329356fefefbcbdec037367d458ce0150c69149f826dc0845afec7dd5ffa5fe54e0c39c4e8bac1892f58a0fac6dc1ea321e0a63464ea5abffc9b49cbc99875cf1e973bafa847d03eeef2c41faabb8d75407fd573ffb53bd803ccf45a3baa500885e11cad9df993a50f4dd1dc0c8dcc41a423801115d5ada7c2ddf5a49d13b67cde1600ae3ab049e8560621f75742e2e260de336d9535ca3045f6f73dbf42371f36fe10c5622be9b2b35245300d22bb5046fa929218eb1baa59dd5655f090ac8e63573d11ddf240c21319ea8b7ddcfe24dea023ddae6512b7d6d7e8d8a7468259f6d9766550e741a1f225e4e569e3423ffc006ee090e0afad7821f36a0de7787aee906d3a5b398a906bb0e5b3266b7bf8205b366d527c4785c6ca087b40f0d6f332623a7eef18e4eb8f6abd3fb094faaf371e0684f9f1c2af139d377db660b3f5ffe50d5ebbb2a6534b26a48129770e1560c1ebc6e840ad16affefa6c224293f87a0f631747699425dab903efa76a82d0521cea32c44ece0d7cda25b4b9f67049002c6eaecc10f1fbee964fe7e7d3e5bb8be23c610c36a11e53134e2af1f0979f1069b1907ec81d6fb76366735a6a5325dcdceb26f8c9a2b24c7228df508bb032665a5bdfe051c21638901e0b38c7eaae0d4bff8fa8553f22edc8aafab08f6bae5f53bea2d3f2530e42672af3f94a12b9705d7d036300c6e9e8b562400efa29097ddcc9f91e3d6a9659051b9b0ded60724cd57e0bd85a860e15f0a3c54d5bb92a86dd369d7353cdbd513c62ffed56fe5d0501e54cfa0f3d4314f5ea106fc4430126f0a04c0c36d0d7b0b547ae19ee14252ed4ab80fef416a38740bc3c8f6b9c4a216b069c6cb5161fc77ecf7a51383c2af170c72f9470af0d23364948f0304e773e38c37c56187b5c80d40c7d15b00a42a7001033533bce213f255fdd975d7e30c1884fafe06b0f477285e553a110915c270382e92d5d29ec7218a4e6c4965c6c4a5b58feed786584bbfbaffd2a783213498f7dd3ca6fdccdf1d872b6f46ca429b7272a953e160f18de15d8013de9a2db973b261f7ad52196993ddd97eea34b165eefd94791941b028e72e42be8956ff13463d75d95a37539f8ef84f0e66f805d47f675d726e1f640a45f903a3572052aeb2cdee33d8a0220346c1274194b6fdd4d5aae1e6205614cd243ae78bea63be82f52f34c2dc9be94123ad459e37e155b5ef7785c7261cd2c6ba66a67f3e49c52d504ec52f666cb5d37b89878a3b86851fa4c47ecb43152b7db351c0294c39c0bb9c7c2cae0df05bfac051b94d8523d17ef7f56292e112c235d3a31447c6352477428503439f6bc2beed3a3caee21b925de0d4e21cb9322c7a59372395696baa37fe9ce649ce484ed813cf9cbbf4d1697ffdb77341849ee2f1a0a8b3f7b1815118c7995b078ad9c12790f213491e9d6c6c7e62d3944a4e8ab46285e24517d169571b1dbd0e83a969a2c95750fcb87a5597160e3e48738a4a2aa590b1549e18f32c709d37fa7fae611a5b9d59b59c68391a1ed077827476d055fa6b780ac1cb12b812cf379587c39dcec56338647f0f856850c66fadeb26e979b13095e50ed3a4b163daf8509a966f3386f3cba92f4aca2e46cdf4e6ee44ff187668621ff9dfce1ed15fab32d837d7550cc6b836cbb52a6f026df30d78ee3664e5583066ab41a9126f60c5daae2b3b652be05c7287a49c52fe85c43335da8a39f9ff0289567ebd54067edf019a20a850f178c1d8b26125e01dfe741183baa5964855d955be9b1ec73736c9d4b90ca6adde83b780c53068047a4525f4345031cd2492a93fe9ae9afeb981d8d711313c649cfaa8af47ea349c21d27550eea1fafdc5b9c45c5ffa031c2e915322af2e99498c0bacd71067ba3bc9ecdf9942b344dccbb93f3814038de2b414c2026048510495ae7f53d7415a9d6fe8294ae01bdc3489722b4a86d884d07ae7257c3f846f8062b399be29cd5ca484d1d904224628e5f6f3bad04467a377ec27c73da31b7194f2732a9fed800449d66b6fc0c98f9429c21540c076718d1839440f0ec62c60f12990f6946a38556c15a61c49594b76e00b10cda226ebc68264ed31715133c3d196eabcf21369cd9e3da030daf59b394a09a53627c122a4ceb1d8b1885073d6d6be9ad83c63e7406bc43519bbb35a9f1b6d6d683744ec8925ac09c6ba3c32cb7375ac924b9d624afbbd12cbed7a3c3ca4718cee453758e6d885aad2fae8cf7e89e3e346382dabf0e6802dc00600ba53cb285add6a5b70e11d0db4140602821b1d519f7755e87ddafb0a22b87986e2c5066af642f2b925eb4b023c8058e9d47259a63b36b578b19ffb97bb22d35efdf824351e8fb71990686a6d0df290cc65186e9eb93385fdbe4e2cc33bc83a8d9dfd442d5314fd8fa2e14c5b6430573442612fccb41694ade3bb30534f9a72ece265d017c879c1c6336bfc2526587a6709ea29497a389f32f5b1b70e9bb10a87125b8aa688dedd12190a0e5d813a2754c9af32b2ac418709ec317d0fb27916ed1e76e9a6982f2c4621125615f237c1524e727279792255a352b82fcfd124d2d9985101e514ea11541cebbee64723e07c4a09c3fc8bd882e9f2f73e3b12755ac3a0e7eb369ec1913a17b264e84bc31d33c257f8962d77052d25a83965e96940ad0f2787c5d209328e8c21c533661307bbbd24de0a8ad16aa0b7533347dc47d2434efb378c2cf9d40b05d3205b38999a17eb1736265919731dfc0378458ee4dbe5ef1b4938f41bb765ca05c88739228aadf427a9c1a0c0c64ec665de236516dbfc55620254eafc0173cc12c4bb867ec214490678d69dc850384762d6961599b07b8eae97ce05afe171fd2b655b673a14fefadf58c9a529ab90391b28838feac1ed4d50f915dc4ce86b0ce338c140c7261c70fb386d32c6d563fa82407776e2921764616031be066350cb0e45df1764a9e7f0c1ad50b77dae476245097ae73cd7653bf230fa33b38bda2d1409eb88f2addd20b77744e07efe172e407a4ea5fc6d1743708fa03ffd6963695ebb74195f683d87518e6642eefaaca2cd53d4b1a6725e9cac11384b7e1c43f7e0b17e7aa0859edc7a057b8ac64c34fd44a0d92946384b09f43d4d5460d2084f64bc381dfe6e1bd212487556ff8bd8038a3b7ff1db7cba64d1db3c9c3996b1de932e5622a568dbf84e0ccc00fea6c9b3e09c7b0cf787f5430ca252cd5a687593d8a507ede79bb2b6e02234ff8d5d5d4213910f5c330c92a0e1f298b8f754a6ce937f6f2384d4e7de74e91ca3f1c24234726035c33122fc4df986b42fa9b2708a61ef9cd29d71b4796a5e9c82ca92ff6bd9ce76d7de3961d84bfc0b6e7fd0b13766b4bd90872297995b8dbe34aefeaec7b192f60274d8d5dfe17f90b30fb215d86c5d5b31d2934043b57c5d0df2c2e68588ade43151fc830c0fdeb7b4480126afeb8df8e580ef640013f34ff4315bd8f844af289a23e18dcaa76f7306800c4009952351dc6b48c8fe47c5c7d3cc164d7ead21d8ca6a2b1d919d44831be65c1518be49a99ab1aec75619d1e705d40a08c33073670228662b35f0f73f4600f92e2d8b9f20fe95939ca99a41b9b4f64a3e3e68efb66b214043e8d6d921effbee1b2b77a2834cd7a317f3a8fac0d0769eca7e9f47c727d7a6246a46c070ac18241cae8f2d115e38827a599e4dcf402e13f75aac77873373f54364e808205a99ff088e2583cb98b53a6a63e99cfb5d194b611b0fe584a404e336e60ab86cd4e39f62cceb3fc86233f19a9dd459b5c65bbb99566a1ad8e3d33daeb99e1b2013771f99167cf78bb753c594c05cbf66bc65de40c158d7519770bc6e190386530f833605045fe4645312dd4794eb6b242780c8491f3f88fc990a1aa231d09547ff41ccd32baa7a4bbc2cad7693d27e0bb1669b024b195f3c6281c779c359cae396bfc30f59c1cb334fd8e666b8f81937f426b19949257e2e5c20311400aac41a8aa8b82ef49284eaf66f8185fd34090ad856ff09398861e493ffdf1c95001827948c45355e4ef3540bf5c591d1d8064589302e3fa4be2ad87ece375b73c11b4b262f6b5f6c197e740a2c16d2585436ebb7c42d67f3ecaa958bdb5456ff0a6da53c1d0104be6f84cb5e3f820e129893e42e995acfe2333d9da9d58fd1a5c31da8da6ebecaa9f8cbb86e21de076908ea1c74ba69ac4a803a62046bcb33b1610fd31331ef76dafd44ec2536afb5ee4e1cb5caa5b1a78435fd9a5d73362a7fd70079463faebb5b2d6d56ae197e4586321cd6dfb9d59de12fda7b28f9160e327b26de9e3dc6f8fc7189921c42c9e318684c095a7b46543a9656d35dd853bc6640987ec5879bf0c9c1f0a75b11f1a5c8e05193f4606d60b27936efb66c60f119863fc7730c5461e6fae2591e025d2bbf181575d246d1b20e8c6300939a244fbbf20cb86e6e24e03253aacc17f527d5b67274776dbdbf609c74e6a4c0ae25153fbd2894cacbe1995dae976ec152058da77b4bfc0e4dd1a0c36363172dc6ef6a899efabcbe6367254d99d0e356ceff1f63974a143a52eb8e9d1c35fafabbb0fb362ae577e2a54114ae7237b5a50e02057c505c65bafe7b8119a18b98e3972f568fe9ad048b4deb4c9a0179a54f69a14697fde15e62e163caa7f4219c4f59ee570d8f398b67c604f642c8c8c734f7cf3d19e6fec073e25d21ecbb54fda23d264a005323ea56c20e9615072512a41549e30687edcfdc1d76a5a6f68e9b571871aaaffe06a1fb6ff4ed76cd36049e8297d18560e26b9ed4c0d57e4b3e32e2a55a52471208697f70447b91413da8d58d6d0fb145fd0ac54e22fb1d5af9739022ba51ef6d088fc12ebf6a89b25225e1f6a43d2292bfb253779fc6d90dd8abb58319fa2df81b3e1b56e31c7f32e39e6536333afaa5ce75e3e47b100fdfd56b16b653190385fd2b3f60bf3957f98fee3ea506abd974274b266a84fa7318365e837d218a391023706fe840970f6adf04988e4cd0deef2581e73496a531ba9de646267373f8329498b4b5e55113ac110de7967f9acaf4a22ad1de99be507748f8d6fc255e79f00a75ed549374cb7c0b4f0851d627dc5a8827b98815579c14b215dc5e4e6cbfa5375365fd69102eef1b0c3da789ca2f4cb61cb0b71d0ca6922e007222daa3dc50f38c1debd39889cd1fca2184c4f83637c6e1af6712674872148a9bd9dbc7ded098cd88124fee344a4de6237e77658a56f773fa0f765fa2a276f5ee9ef8310a2940f6df7fc8e521136f7223d47cd34a8608bac631a110c772a6e83a373b15af797dbe6e2104ffb7401ef160b2601d035a336de0df1f9aae646795f0f2bab08281f3b589d2188b4f5897070aa49ade4d56dc61c8a58b0b66482bcd01c2ff6fe4ac76c1cc8cf5a7f59ba2884556aad9aad8fb5754daf31f4746f3ba41b935dd9fbcf4f920d575df2b576ea470df36a0570ccfef53a4858ec5d41c13219f5cec9b2619d7827f67ad67a835f9a118d389b592e83a9ed9bc0151aa459214fd218747cb29b4bc36574dde4ffe6e3932a1d0a7d73d4387f0725524f97f7ffa07a5aa8c7fef7689334ec257b189338b0fa37a9fb3f0a246a358f2dc75911bbc8c0ffcd29aa5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
