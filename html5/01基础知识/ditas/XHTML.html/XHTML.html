<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7fdf34ab4fe78c3e351bc9663b7cc724ffd0f2ebdd943cba9f277f6f61fcde0d1c0b154df0becf8c2271db55f5890efd3ccadc7927311ef490edd7577492deea8dfd460dd7c60d5793a531b64c0ab5c29d09842c578144cc370c032cc0872cd2a794c5f52e4843971ba29f61f1b33c50e7bbd0f187e47cca55c8b6523469ad5dcbbee7d39a8c3b7dcd82d153967af465edf85c997a29e997cc8082c455999ceccc4938b34539a5c2afccccb29986b4c97d81c0e268cb332e0435b2c5fe8c85e2365a0ce1fdee9d01f8d05cc77e271bd6a154b23d6e5406505919fc62c618c9549d9411fb152f97a20811678334f9f99db5ea6d7fb9b8191440fc60b056da408902fe99b5eae60c49ffb1fc5a9e48961b554623cfb7e6f2ba37d4c0d9faaf14410ed5e47e49130ba290d7d683b8ff3058835de652edf6dfb937f1fd7ed0703b9243d7ab136309f238c2595ac1a7e27f99705efe556c4d8365453fab50ad09ba145f6160fab33e823ecb666d00f6286ff0232f010a2441a2bf92eafbdfee3031cd0104ae4be51aed57528c7d13eb518f4d8e5f1888b5793e01be10626cc3e27a20596af65672ffc18274b975069fd884bb4bdaf30cae92f32dea3a348b9d3521bec18df1d87146c3ef7e50cc1f077d5510518757ba4277e0fd3cea83a2b3d79c1a7cfd1defc2cc0a36ed9b06dcb74bb9bee8eb2609adcb0f282db0ac8dbd02ebc379b9a0c9039ad83defff7c84c9084452f21337362ac2bd5707e2c99f939039d14f2b09663435b3154dae321d1494af14050a4b8058ff3c999977cb4dc6e554b85967e3f06e16626b553ab4722a8cf31fa35bca86c8507c53b657a52298914e95adbfccfe6cb46451f7cb91614edbe97ad45c53b2b932533c05d58fd601754d12cdd0d6dc595d1b2bbc85d1a7bac1535b090ec2903b86ab7eeeb3cff921e39461b30596a992f95b253a8d36440e836c6475bfe66e2d9a87bbba380c59ad5607e32ab780634774239c61a0e2cfd21fa4aa1c6201155d072fd224974db52b97678bb71fdbca29fb66df305557e87a41e20501abaed0344e3f51f58c6d2056c57b223c50344d65b023c65459150d492d69110689edfd20eedcd9b0a7af3c11caac3ec58db97429a7a8ba31933341d864825105d658c96203d0151827bfdc24696270719049daf0d552c8a424eab4aab1246cb7604e73b6e25f4e026611d325bff12c780a9d75d3bd06cf9eff9276b97de0ada7102e7df58ae05e6e6648474f59ee2083412c8db9f4f6cab0b2559ba61b7ecc05d38faa44f86dd0c44a9aa0fe8467141973d891f644a409367c190ee86bf09c2713e1b22cd3d4e746d82695f5ebe5c64db1f49decdc64640434c4ab84d77c4518c4707de6ba230d54266afe6a9c678565bb2ee9db551e4ce214860c1a0b6838c908587fa6b6b0d0d3c9ddd421981e4c398b6f65b34b76b4e0e4abf11fe2ea39173d3fe7a54e7947a56d3cb68808aeed161560651359ede89387799d9124c123d46c028be1d47c499da606308461fe0d3cfb6265a480bd9790096fd1c890d5d8aac4be43c3ba6b96137ab87c064582ed594bf7ca1241e27ed535ca6c84cafece21b43fd83af63dfdcd54102378ce95316e848f2679adcc712a4c21a49cdbb99538e8380c5427313fabffac74eaf18a00df84d1411def76e76dc3bca0316b92ba8b755b13bb1fff74c8f6d151c86cfbece749f44a3cc06b4437bc514a04567fa6d881e26d55c031c00fdea03ae3ac5b062565072d2bfd5eddf522136568dd13587947dfc95de71706384fa050883e282d8d06f749c91ba8a5af3337952a5ddae0907ce6036f6ae81de618c4f995706a384d5fe1778e15e60f7047446a80b043d012b4ff8814c23887b24b6a17cf046bb2df53f149134b42bc01439657d304036b115570a396332b749202563b3b32e98f932baa1875c849d55f6a465c2ff6ea3ea8a28225572b8d5f79d8ce272b6aebe21ec2daf6675441ea04a22fe68bf4588a2b4ae07075f316b7e236169af3d75df07a7eed3fa9567a974e3af6eb55870251eb7c7ad9912f897993b91cb64c6602de4b5a2c3b9dacef997599ae3dea60c039080b0973e1ee4123d32914c94c485bc9c37f9a90b0b6008db3c3acc2ab233a098d3f3821e135c4ffd3c12f02442bd4972e4354f196022269b85250cbb41992cf1ad427da8a1f6a4fb9f2a161f3e34a9db6992a92aaacfd4714194ddc8f9049b9a558b65e75c522bd82d1539c9fb3c27972ad1de460b85b5016d796ae7b2c7dec18188935819e55433002c208c6cd073664f9fafb9d9348307e0cf963d95a722c49133f2e2b7734987578fee7417eda5c12eea8f690bf4655eecf04d6fcba3f7b185199ca863da9dd0eeb583adc17edaba7ac46f9c4ada4180faa0de127c914a30949fb079e2bca3ecea574f8fef3242ee744475aeea9862f1dba0bd6f2a641942dc823d1708fc33a4d61d3c401ef8d3c7a0e13aa092f3d1e3dd52dd3cefb344b84c3c51fdb7b2388502f6897496ef54443bb0d118271e63629bdc58ef78923be1654e30007bd35d68654191122e763986a51f64fb8bc834da7ff23f37dd531a4bb91de5cc992c948ee7feb58b7eca2e4339b9ccb7276c8e7f6ac6d814c6a7f570b632ea73fd0ab064d39f36d219738e6be317c9c76e0ce4049a8d49da700336240abc0c7a1328a4cba14e50e1e6cdcbd6ce0add37568aa5b74dbf4a33bfaf9f97978f23c6c5063f02d6063091b7c2a992a553d509f10b5ca4ca3787325c93c94c81611a9c569fbc5104813a32c7593590290149d51001cfe04b0d2f28a54b8b30543776e193838e7de2cda79e9d01a7ed5a854ab8a141322b14c9de511950c510a796f3c8ef2000774fa9e894c6f7516a11b4cab484807d733791eafd6cd4f098dd4c13a7ffd86d56813832ca2595de07f69ba53acf1ba0c9406607f425605d4a692b0a0005777be4deb2b9de4a89da1a99009fbea92195bfb156ac491938bdd6aff6e5bb907928f885e44e76b13a5ebe646a22bfad0bda83208211bd7c8e46414298ac22f17b2632e909e85585596c56bdace10efaa3a35e96867e36eecdca401dd689c78ced9c1a1681899fae8315401c5416a7999b3f1e55a2cbe8164894e4a2599960975896b0b66f54b796fd7b8cd4e09677739694911ea21e28ddbeabeb08ca732981b52e99d6eb9d1f83bb99ddbe609af38e9349a8c795f00e4d7d55a8716da3d188241b1e4d1180e533c3542fed95148545746dc72cf1e248bd3e61c280ce871102a45d9293f36944399a48ea4cef72b59db016758928e4725e29cdda263aba3d552af88f7ddabb357f06b5486d2567301c1129c5929cbf16a81d38ca3dfb3ca85019d07e88df28b83028282b0cdce3bf3b87bb0cce714f1b47095a7485c0f4601ad59bdcf105a7ffe1f6fee02d2ddf6b3124b9209c5d0e9d49761305b6356e169d21144ad87392f8eaa7320cfd35af9f61c2a0c7da62e6ff359ad00a66f664a09cfb5091fe3b4b07d45699ca1c02f9f3e5052503dfcd2ce1c14fa664738d0c0d38a34b243662109026c15b15462d8231180aba3693b4883ac75822995b25e31c9f47af40136b90aa779be8f1ad99277378f17e5daa7b62452b425fc0e7fc1c8c0f4135c0af1ddf979db0e5569941861b31296ab6ccc55b625271f8b6098c2523974ed8bb03d488aaf2c876184da581b73fb79937d3aea4a69407ce3c562067696f513f226b067935283486ac0353ee2b1ede6218e99c88c2722cbc36ac4aad1528eaff9c4fee6e483a23093ead8164ad244b696b61271dbeab8e4ce81ab00d349ff7dfd65e80854682ad92d556fc582ca138e3d2f5368fb10fc2ec400ab5a0ddbabf0eca608194fad7dec23b28277980d1996776a7d3ca121a77d2c28da840ba53617835c93093d3ee651f2724d0a43993871484e74105b0a64826731fda9d321fe5511aff766c5d84788ac9d797124a76942ce57708a0b9bdeef1eae8a74b44c6a9258eba3fc2c60004115172d0367ce01d974922996c76ad21297ee612b280c04f3116f07eb5d09277d999572ee3cfb66eae4290e3bd705b44812f314f29253bc8d2aa27b692a6988898cf30c6a5d383abcc566f890aa93fb9126626231e2a650697008e3326f953ba986602ede4ff0c11164def10643e06dee6d679568d04ba6c08266e04fc678c61fd77cb6cc78e800dca2139c4321ee561acf394373f1cd33fcd6fbc279374b3d757344bea0bdca27fecf9d237e243185dbedcc123eeee037b580967a910a98b79dab364200e70e38f4ad11d232294a106e6240753d93b06416a2167ca721418af8f49f8500719c82a18ae851ea537680a3205c5c3d8a60f2d1fed5ce0d9c7bb433f729068cc827179b2fdadd253fc82da76a78e02db32aa6b2d4a46591864bc815b39fd9a9b92ac54a55de7176ab7f394d675075c38cb1c25814914cab17bde7f1de27f72eb45972e82a741a87e2e7ba2211fa7d2e4e7a59f2eaf2d4e99231599a6d7cbe32a53f439725233d9bca453271f0a67b9c4c397797f44a236f8c0ef2101543fe87025ce8474265aee7765422adbcbd7931260b8e3e3d6939621b9d3edb3208dc977ef9650aa0c83a53f18146bfdf284d4e1927e724ee7228c4209b7385d364ca3c603653accea044acc2523a09b8af935d6cead3c575e3d920adade4ce73a5dc567179ec219a33ad3534f8fd0ae3a4676177a1e879dcdc611780144c74f7e7342ae143eabfc1bfe9c70cf3688422b66ab8e25118dc6060f186714f72a96c3ffc92b5b56e9a7a60500f59e37b6ddf0f0e3c49b040f86bef24e87a165dccd46a945e94c8a981d839947689ce09000a099ce856a4ff9d306da62717735caf0320fb070657cb25bd7717d53f9c23e6892d057d1b66e241fe96c24c4134dfea2f50ed7f2355a14aaecfece3454c0b6c45cfc0d381a25698ad9430453148939f276096f87bd40e4669934397368eb061d73b307fe18a7a2e0c4839d4a6d243659fd94c8cd4b9f37c21af207cd8e5c3fa4ee2bcce8f34c1494b91a672d9fc5bbb8c8d911ebbcbdf3743727a9326ea1caec0044aa44ed7ce88d0bc233bcd76d1b7b72c63371b7ce5a67e4a1e2539406ed66e24c569e7fd86155ca60a4cb6a719af8cb9f02fa4c16f36a77a5fcc2639b867c0dbdf019732924dd2666b746e79ba55bce27bb6ca38eab01d1ffdc60c0784d9fe8b10e1247186cb2852fef5002808fefd354e4273fd06e9ae926949d1b5ae05b3b2f06f53900e217403ae0d04d2f1289db33131d783ac6df55ebbf34c622f86af56afc04454777272f5dada73c34cf8eefb46b7e74bcd27ae99732c95b408cee750c392779ff78aa5f53ab5d19d56aca0bd0ae15901e4e91e43efae8c92609f5bf55899f9ca8c4c12eced8a015a269556e40da6ff9dcad59d81be978e819e61989e56c7a2b97455157a2f4630d9cdb3a5b7365104e9990d3049f10e6fcf6ca1d9fef73017eeba76cc9da8abfc66d634a6b2cf6efac93ff00a0a30cb027092d07a6a2b4cfa9c096bd99d69cf19ea9b5d7aa31fadc301f7d3bf1e846366e19d63519619994c4bdef8b423b19618df0936e0907aa5e94dc7cfc8510491f1d5e975e5747cee122a2d8c9e8558d70001bce4efa09c3258226ed96d50f5f63552bb035a9c989acd536001badb4a75b892df755cdf0a46c78d88bfc37af2156d57dda80d4d7b44831a39f47bd423908e3eb3821d35980458367c2e6fa136cc295dd78697c1473cdacce6ef91e2ff04a41e5612f431c2ad29fc723c895f7ac3bbb06081461afa24f946b0e346869b50eb9c21221c8593c7b8aed908c9aab09782dbb854747450f8f0c799cf9a3f4cfd19647801671c3e79a8aa4e7aa27f63cb60c975e66fd2e2f18c8b55262f8576473bdb89c7ed6bfb9885734cab42dab9b879724f7d9d83f65dface79ae836c7b2cf2205b21684ad339b6f351fc58494999e3e4116019898ecf4eeb160ba720ff4407994ed0230b4e4ee4b1df0b04f083ca430295521c636f09832029e23a0fe3c6d5c7752591252493ce17b8934ae6e1b40e6fa6ad70cfb0523540c451772ad7812c510f9e34a102062628889cb8d915a17bd6d7d1be3936cf73c9aab2c8e6bfb58931a3187323c2855eb5b67a4e6560b193700fe120f182007e2e22062b9e89d94c6187744f4dbe0be9b03283d5385c2a18e4b8e0998636f9114b12070e4cf63fc1c70ba91804d2ea860de974fa4b270ad0695dd58bd2ed5f7ebb0bc5397f51a11e3cdd901c1827d8f9e82f71c00552591f8a39c6a9b74a67193575d170be31e3306072bdd457b115d36682c8106124b9a5b86e7c7829c7824c3990f1c189a86d49a29df1a9518ba69d888600f5722215c78dd3b93b517942235c58d27e0aedb91b5967c70d4c33846b371ec8e034a700ed9292c222884a1fe1344b707f7364847d94639a0fa4ce90a5918adca1a57f6acc256db898ae9a664e8982128732d87c301e7911835848e558b990a91ed0f9af5f0d102f2bebe3bddc65edd04f557c24c431c939863281c7a1c64e590370f4cf9b37190648f78a598dc30f9468fbf07f58f7f8b7a053efb2f0b4ec35493dc8d7bf5a2ae01d88e811e7f0546a0e31509812f0b6098c9fa277357df7abdf35c7c97e0a32ef35025f7a9fe1e64fcb0dd86b95b716711523b7c3247a7b3b9d9eefa89e96d505d2d67f00dd5c2f440fd6e3391e7c198a1eda251e182c1275801572fb6d3710dde2e61bd9491f5deab7938fabe043e52399de32c95e0c7ffcb85e077c6451a96d5d567474cfcb764d5321f1a430c082cb4d2384e33a45275b228ebf06f921998509f277460443b7d172e2b6f2f3e61b1b549730aaa3da6115521796d4b4e4d3cc257fb99fdc8feceb4d70f4e1f72ee0084efb5fe2e94fd1d480b4bed25c71afd09733c4c1eeedc580bb102f499db53e51822323c51f216331019049e62fb2849089fd87b50edeb690fda2617ed79840bbe05502eb2bc8a82862001e83aca78be92a05f9ca57b832b088569c0a720287994f317d7f6d284f6ec31cf73f50fc35664df4938129bb2bdcf4c0551bf19ed25765af27027f76ff2eccdf0513da7f0839ee33f5ab8c68d11d054e4affb729fc73810fb56e5fad91a946de4ad8f62af23b56714a77aad1ba3a9a9ab08b043693cf08c581cbf2f7181f374dba6b82435e16a3ec410f4bba53910f9209e8f8c26845390846ad25f8b59b2dca1c20807c673a2a26c47af1510fbec1eca1fb1e2d9422331b08feb4c23c28f5ccaa7cb438122f0e2f4da208db25ecfd1710081f55da2e46d09e469d5dc98f2cb4394ee417af1c2400a2a1fd0007b5b5b858dc22d4ba7a23d87b83a2446af7fcc5123d49b77239fb93f7d51f3f4775d5e004c7999f23320fd04b6e682e39aa70d1ddc9c6b405823c167fd8b47ac2efc8ee1242ab2cea78945ce7d106adb912332e849727b4c481d147f3211942c944b968a623297bde81a6afec5b7f139235b5159b0cd3f50835da48f6dd9c8e8901a16b2edd9c0dcdc77746361617cea7b3611f4963446923c6da43ebb5917a4e33c37e41248d0843ec3675452cc75d15198183584c8c1c025202f287e687893a491cada032bb2ff7d40758579ffd4e347d7635905486989cc13b3b2e24cd984a856baa376fabe2c6018b8ea1590b2c11ba9f284e740cbfbec19a77f7f3753db2496842a93de743fe06a1dce9782c1b4d2da7e83cbac2d9f514ddd8924f29e70cd5392cab38c81d93437d8a5253683655f5a1b48cd8d2e88d189b000f0e4856bef878c94f67c1713b24adecfc2afc517bea9599300feaea7dd528b1e85a8b30e4f4ba25f68faf14ce2240a47a27b87e918c08a7adfe5fc7ddf3b5abdc2d9ee1d4175ce0220e7d942dac78bb378c1c61be4272c694625367d4cca07b3d998ad06e2c0f925397f7469f205ecb6e6f94aab12fa9250c98cef37851b7320cc1d25a1e07439a29e1134ee1fb20afac606c3196c521140c4f84649076709c5271363338bb0cf005d2f4d79173f0b5def57db31a9fb18555a986c368c658264d3d7d64d6f4ce973cb4eef6b66e8f011c7f4c280187e468d24dece1b1f9dc651f0ab6b4197b965ab40025b35089c0dada69da3374213e86ea64a7044c2e4ca7c8b0d954f955b90f4f0b142d17f1600d71c072a303713d52d9311f7b6a9d26693c0dc47f93f27a87b144fe7616dea36abc41c466f9ec92ff6dccc0259d7ffe9ba2f93519c62cb7a0d10726b07a368b6c7e1efd16c5a788541d1224b51286eb117ca3129335f1ae6627abece80065e2c7f2bf06330dd3c1be25df36caca97979015461ef96a9b5fb5adc0a039aa552f0f55e7688c1b523a9a0dbeb6f53882202513db8e9b98e6ec1eb156acab75ed4878def9a461eef23e14d456050176c410d757195ba65264571085b90875338957832de9c7c25d3f67c8e08de971d702b93b10d18ab2456ca562069144e007619c181f4410730da8853021494b7f919ffa2cef54e85f50d6eba850fb452b41935953353ec7c3e7ae118aaf9f0e0b7acd5d7a97eb90c8e8159f018d5fa9d22c19698740e8347c9fe9627ca0f76c789668f04ddcef6b52e8e4eb74da6ee05b067ceccfba7ec7f05fe3444a241a0359c442b5576b143987dc95b5eba3b6c8b5c377351b9a70a69b962789ef909fcdd9ad35efad4c45d287ee030e7ab0f5531d4a1ae9c87ee1b5c3386db893237e7db45b2cb8619b98e5577f63b7e3f2c5629e08bf9987330ad4ca7daff594ab260157a737be87d5431e57838fb5aff6267e51022fdb6d8b832256a30de6cf24a2fc39398aeebbce00b1106f500fb514fdb3477d5c3eb71faed34c8398521e865f6722aee8dfc8f54a577e521d2625188cf0639bc14ea1058bcf4526a4a1f13668cc0c5c16cb56d26236f76dee91c1fde8910a853532016c88767647bba9e3344a46c7450c16e6677f1e23c1dd57adab012c22e1c31c2d2c78ae40852366ac314e76a9230ab2fbebf33166e94fe597b71b54aef63eb4b2aa677925ee50f53b860402cbb77c6655a82f2772ff1aa7eed800778a0e7fbacaa425ac2a4da856a11cb54ba54f566ad1faa2fc5d9711722f015035ddecb6ec528c03fa666c2b225a982c73fc48235ae35c953c6e0237890997cb1c183b8c3403e63fd69fded8c59a867913bb4f33bab2b86b79d66b3adde1b26a9c53d98fe2f7e0d1a02d9ca00189406a917d1d60757bce79261b063211559389a02b85a3e06ef5506cda1d3bc0d8f746355e1f779796aeb51975a175d3c786fb2a069062a82fb8c2db875a9d99ddf06e632d105d051fb6b9a3146a55b57635c99915c22513c8227e9a5a2567cb6ab042839e8e1b9c2961734e0c90365a213aad0cb3f616de2a8387af37181fb1db6fa9c47065b0aace15f9a11ef72bbd400db5feb33d0a6ab5c2d97e509e74637e027603356b18153237423422b8b9461c483b980921ff9e1a6e22dab60b4acfbc1f75d8c78c95d5e186b558d93fe39f1b7105f463727e3f7b5cdfe9f90f91a0787cdecca2cd92644c0bb57d6425074aa2429b9986e47f9b09950da75f3ae3ec48d76a770804036cb2e593ad3758c319746d2ee879fd5c9b249e0d9666f9161eca1e0bde785b4b31edb1d3e195413e4a5ac47712c4cd92294ac3989a10458c4bbbc3d015bdadcf42726e8c2ad61abcbcc0da0cbff4a1cfbbc5a0da9640f50452c9c748968ee44a482c9766fc669475ef99d2db70ee3a1b545f5bad9eb306b7d94b42e8be2725b26c2a88bfcc42d997f8416e1cb4106ff56a6536a1a700c2c5deac6fe1ce15919d6a515fc8c738d50e52ea96f05e8456d2e7e6ba47f74e1ae5f153263b1f720d283af40b294860e26c11da3b8942bb229358004a7fe5e58144c60e8576131c08d7f9ad9872feade4f50550279692be5e51b3a16ae4f7a78d45c32e909ecfef92d1469d59c6cd3c7baa94aaeb0bb48d0301dfd958ecf5da9452a7cc6fc4c9b5306fa5aec6697b19ebea0c902c112b4fb688203ed7d358ceb86224eab8d919c7e78f28f61ef662cd969492631f03b805e518bfcab0ba355296ec0c0759803b32d5e2756d4d8dfd234fb0b3622b008314a19bf4d789c868055a51baff4b1e10330745074f052a773c7a4262ecfc23a0224a16d523410cd2d4559720cec0257989c0c10258c80cba3e7b21e05700e2dcc54458f9fe6c7436ce21cb2e5e419aac6275baa3e2490546299f9b1a51af712ac9346e2a49efa4616d89943e179959886241aee2f543c0e95c51760138cd93a6e8bdcd6f1ceca20b55c3428e285d5ef6307daa9cfbf0fca4dbc3639545fb30e4e9b44a15a3b87cc908d053db6370b0fa14f0cd89c0391cb234edb6d70287e7787339448509b64b944904249bbc35d2befefa00800f56b00dfc8bd9e6655d9513d32c9fe2370d61a569cd333c23c1192512411a469acc95a88283732e7753b097f639c958de7ad37f00556699ea04d11d57992c9ef43949fdebe9cc3ec6338af1bc6dffaf804dc2d52294ad0425169754813f8e8fb977144c30a8c65adaa46b3f10428afd139adc96ce5dfc527e41056d44f9456dcdb3910e7446a15d069e3d4c081cc0be6864be9d205ecee3b80ac9aae4847a87b60fc9b9d8563230d821ff8dcc7d875027fb0be9308c6b61b25219126385d674510eaae2a4126365c0bada89b6d394bc3d20b7b6b31349afd83c14f32471eaeed64d516d1a375e97e962e185de431fd450faa80092d8569573fc37710caebefedefdf780d25583285c588b3b07128be26940fe5c6f5e7a11ed255f18d2ea7f86b0a1aae24976d09d38ebbc224c027f8345d559224df30a240123569fcb96a3c308486f5c5c65fad85144e8ab3e0aa05ab8f52012cdf1c07c4343403e1fa3a5fa55cdd1d5a6d4b4f9b0f07b580acf886cd035ba392402b53f9e66f23f4842faa0674d6bb45a8e2aeffde04dec5f4165440466459f56bc26ddf0693bdbf37756a8c2075c0f5c6cd60e169fecc33745f537e24fab3b6f457923611d61656b5822456ca2f2c1531a252dfea30e76a89f87af9ff22e270b1e9acab2b1da396a6d1b68693b09e476be757be7662337cf6ea95446a219d9b4895b0f7b8f12cf45f2f687401e416bde67f407ea6aab568ac71c4ede009b6d393f8991dad768c8821a2e75a4aa01f7574d4abfbffa1b861efa2eb018016f0aae60e886764ac8b28a55fcde33b4739de823b19c78055c3fdf609921fb90efb1aa81d31b7684650a6da78b5a8f9b0150c0e9c5b5ccb27d86289df3b44f51aa9328ad834f7a8fd9d9ac9b9c719677bd4b6e46a425a99e771f21bb07a2c8c241ca742862195fbb14da4356ddfd6360f39c4c422f48f47042ed9b89d5db35d8010a8086e02741d57d9f9ef3097c4da649b1d6fc9e320c9f33045bea0207f94e5a23c00806e266755a4befa39ce1c0b1765724b7dce9c88237371dcb4f62ccab53c0f5a95e376a8607a51f18f79466f91a6bdbc9e161378f705cefc8c78c495e14a11e35ad576de1897c623e1f3244a789e911a7a6f254e57d38b64698dfee83c8ac14788ad1992d3ab7a9b5affde46167fb5689041e2c7b4829e50c8737af13cc637703fd0000473f88f28dca284424c9c5d05cb72e8b0f433806c8e452c0f08ee20571f2ea7495e6fc1fe650c995f913e2afee87130dd3d9e6aa1fcaca9af3d3d59a821862cc518fb9aed3262ff1704abfa1c412783fffc1c7ea37daf81ab637ea8533904d5a79c598da009ed1b16534dcbdb95225e08b17f00aa964fd9308e35b40e27c0c140c0676d23c34f8e44c8c24be8ef836c14626e7a61219490bfb569e4b56b96fde437f8328965d6f1b79f53b184bfdb392400303a4f6627052d20bfdd9b351817677ed6304faec76fdcb6b42ae42d18da062e55325a0107d68f4724b40479bcf09d9bf49564fd26d5dbb5f152f5b1352ae293ab704fd8084cd719284e5b44e322591b2b35b39620dd5d8dd8316d9818c0d867c2047d6d4924f17d86ae1e07afc2f7dd712c4628d613f8d6c52e50dea5a9b6f784158c0a8d589434518ce77c897be90a01a406b464017c7b06cebdf6ee1817d33490768e10a0214b37e502c36c6230b425d5f5bd3ec0df757bcf15121f1e5164cd6943a71ca336bb540c11f82416eb37d31e2d1fe86ffdc9516054a481dc7280b094f0bd91c6369ac4aa6b72ee9b1420213a6881c59da60ad4217a9b0dbe449c0620b94b36bf3b112da624f6b7deef906dc1d9463f912c3cdaadc0df0c3f03fdbb525cc78508e858f644c07444c18389b020e51ab933f7f96c0364fbb48d34d732c8770a306a394d6a483adf0fbfa61103d8fbf3db7dac61bf1f79717c03e1adec923a3a18ccf9cbb749fbe66cc20095c923f4f316c2f59aed3de3a06a4cc874e5d9d4ba87db368cbecb29a8f2e6631b6504a206ae03d563250a5f9c43f3bd13018a58d60f9e1c193e3747d7f5065339fbf02ced9e28507b53628767ac94e9dfa00ddb9e4ed8ddbb1443f689aece7e61d3b65a0f34f20946c2c7eab2221be4c8504eaf8852546dd9c0e09a141e4bcd4f662e5bc3f8e4b56913269af978e166ae3e155891b75393345b4207eef2bdd178e415f077915d0ae6209e2b7244c83d6d320d500ea0fb753436761e201eaaba913dbf44c5affc8a9201abceb837064eb53a2cc0432d8239afde671501efe306171804b90f7020a87f538a5c3cd35bb180215ec9ca6dba8fd25c7684a6fc46cca3e420f51b94e0b7be05e5bab6b8108f1464a52f76b65e8fabceb23bca803e5c0a035e633c05abd80f1f70e7f5b5d803a3b021b2b6ef0d77ee099ab6952dbc997084a212f903276f333277db553b0193ab3cfc062620f40a8380d31b0f8079e3105a8a9e686099f55fd2c2b7b11248be12486dd8c6fcf273c237b61bda01347b5a3e469eb9bd3c52122bd5e3516a9294526a4685fd1c24c86564d52c312a420b12170c5bbd5d42590c178b06c6db627886337460bd6376539224bcc2fd4930e8554836942d8268526d8223294e2d884f4db8a35c32fe64141e965ba32505aca4c916fa43f57edba7fa76d6a0f203dd7d65af1771aeaead301929d4b4bd0bc73dd0c1ce591e2a13935a1fe26b883048ced25110148cf52366c2c8718305e70398dd1791f9e00e484341a9f979ba06bbb36af2cd407ad3a302b2f3cc03a406ec6e28f1787f2ede2d5dcc4f42e463c7291a5fa1206fe37257e08868474bb62df83d6b64dcffe4d8b784a2e069a2dc613f02f6ad9738f72de0fca400a1aedaa8f8846068e7eb0f3036844724e08551854de21b0c4cd30ccfef9cb645954a344f6e12de68eabad3dd0c2535d7cc85f14a792a09289261daf25e5947c031f8a918ad90da164926a19d8e31718d31782ade89fe633a542cb4435b3974eb295a6f30395169ce2868ebcd3f7704114be8a46c913a1051e603c5734ff47d186ea9e531ad722fe32bd71e3fcd0adc4f90a16b4e49f3bcdf43f214afd917db1401c4a0bf183ecd186b1980cf8e11a015bc14a90213400c6bb72beb63baf469020cb3ab9a7b6dbce10127a3e6fa18c7f1e5d4d22082261f455a97372ec215081752b386dc3e640f8db0b2abb0dd882b69d2b826b684d71e55ef2465037f7f91779afe8cbd66b5555606196f38168868cc19299752d180f5f9a23ef8cf3e927d1de6095363d4085e892f95071dec9f36a2f2ca171564022dab2fdac0fc391bd4bc3f898f9ea9dfaa9f4658107bd93ecfbf889a22df02d662bfbef220439216b9a368dd2669703bb02da6e95163a66eb99241bdf06fcafa4bfc130570996d7145377b88074f2c432d1101ab82fa77a93040a9ac8da54c288eec0c1783c9069cfe3b09d5cf865fd02e37fa824d5736e3a1586cef982c39747e1e334cd62bc5520328f43d3e84d1fcc18d95c5bde77a6418fd58ab515326e66c72c50a3247016dc09b227b4e4e76c6c86ded1ef8ef711944231bddbcdba9debb97046de2a431ed5a126a88e9a94b203b69d63a32637aa88d5a5fc68fe9134caf771e1735c5a6de311126aa9fb410c495402f782decf8ec5dc1f215ab6d9f3f6705703ebf53d8dc43b697b58e8e763b8193f0fed3b8b29b6f0c1a81d39c850407f111434424bdf61f60e9899875a26514980644920ae9fb8cbd3d6e3dd0af5eee87af4edba98a85ae267ab16f7b1e75046bed407237ae07d0f6717789c60bcd6be2fd6f992f919a79e46ecf3f933e3c1c8171b1c8305833773e0f37748f7a57371f9f85aab9fceeea4141ea1b1961973329d17263d227dd2ca4d3065e8c78256b7ee9ec2f61e461d47c79acf5e79902ec1683ffcba222bf0926ab9775c157cb2a81f8e740d21afee04d7a86d7adaf9dc8b8c3426c1b425ca9febe3de5193e3b734fe5e883ca618ae390248ddcd9e45dad9e5baab61847ee1f5a9489ab4c0db1e8d29b0eb9c92d7dab94be80caf6a6a4a95f821528fc113a455c3a33c748d9d43fb408b4486029ed0c2ce7059d030aad3dfd7b0ca551b282c0901126659b34a62d152be60ac926a1df5bc0dd33bd92aa6dc12f5f9f631d20f7a32bc8cbc60e215d825d3754b224dc9f3a6c15e920a5eddca097e7a08e9172ad3caafd5220062ffefa2b929e86506ab333bdfe7cf38420da3945d2e6c66b0dde99e6010a0e8204ffe84d819688337800cbdfe984b5e0e2ae3723d1fbb245feca6eefc263a2e331dfb14a5aaa8121a1876b02f18083c532b320e6b313d3693509c093852602dda3b27039f3ff4082005bf818d0182b70b4b239e6323d2188fd26753608de577f806b83ebfcdbd69620fba116a1a3d4b3ad7757599a0698d1889800fed3a5ddbd56916bd3e582b0f6615b5af20ec4c124725a7a32d68af8beeb49ed53e5066670ecd2da972cb9964bfa3b9abc10094cf33440db151831116cca2a145abcf7e70f6ffdd0829022b1cda406f7d0ebd484aaecef635164352a86d8c2d9c0bc70375705509a883c97f27c17d1f81908e41e7dc9709da3b0ac40d2f9195d45165d3b3df4febac57aa77f8bcac4a4bb27a4e90f46b2420523a13a7166ef6fa3cfa0f3a4c152421724697f6e68ac18eb6b42ec041e8080ac3d5dba86d116791ec1fd74f384a75c07e32c4e98d79fe47cefaabdf1c1db8b86374048b9b496ea6200633784f18ac57de159f08a46d52ffad7f078276b8611d90eafb1182cdb8ae4d82fbfed4df38a43f530d705896b82bea0f70c4756072c9410a240a5a35db243b889568cc456d6b43c8bb8b81e3137b7ef347cd08938eb3a29537c7ae1f558bb0e387295af8f9c1b94b62050f2ee91cd61eb1c49f67f09d9bebb307562ac1e4ba7ab990a1552fb7d6a5390898aaff81f61fd8ff52fee22e70eee71c3bebe1ff5a8362e6f9b308b64a92d32c51d6be435ffd76f274a85e1ae516135a6489600adec9b973bc05463da27c8a581bb68f83144ec2648cca4028e7a6de8038568e4567f5652e27430994be161faa9212d90aa3abf4aa1ca00793369651b69f5590faf1c26da9e319edcb5185314bb815913abb4e53bea4647083e9bb33edf4a07974cc49d9c7ecc26ddebc86f5c8a21b5cbe34b5b8754cf9b3f5ff4af294bd877e1b2343bfb2768c4ae9e6d327b6baaa7d3a1fb6c0a824c787acf95edd05d496755045679204ff2c9531bc510dcc8ba6e553ba8477d7ca443f64aeb1f9c61aec431f66bcd1ac8faef98ccb44948ecfbfad66c2aff0dba75c97b4702f9f843852261424afeee6a0311c9aa3848e00bb4f440ddd4e2654f329455fd0fff1fefc0dec7d7701df672de533258e586768d9817313fc65fc11d458fc22b548ebd2d4a79294dc9fed9c2df8b280aa72a0329bec187a5a0e55c2f97f1eebb51205c6d813640a4718ec1eb646417ca639baf1a0784acd07c0eea069f175a4590a79c67ccfc8a7cf85c9dcb2068b14dc9007f4b9324bb46eb27074c80e3c2b8669cb4b0647f0579bdfb0e511e54d56bc2792eb8b349764d3dd3a7e1054780c123ec36fdf7bc681c4a12cf2f700d27cc035a0c8bb16ebaa3153c82e17da545fee59a66e94ff72ce23dba4650c0c4161ccdf9ea820505e8559bb626fdef2f32680663ffb8c9c9d36a894c33843bc600f536cb0ee5394b09bcc6b6b223c6d11a36d8752f7c9d64d5be0b871ed56971be8005a9ad9b3b843f04d5251a510431a58261ec915c1570c2ca95d0885744d4b5bdf2453292dbc39a8030c25f2950131d108c4843a9c006ae61698991927f8a9a2b0fcd6c8593dc0323480270de38ae661d4fd5fa6806add30416d8460f2e4e6c344fb3e5d18c673ab50c4df326608197cde3084bcdcbebbdfcf72735a29bc2ed8d620a4fc4849b5f39ae622f094cc179d99a946a3395a69b74648c061c2f774bb96ef9b932b5144ead0114ad48bbf1ed4b6ccbc873d4fa2510b50a8f5d7024e49fb33660e3d783fb2a3259b6aafba44761fb7f10e7219572175aa25268347f69ca322e6ffd451a6906ccb8c6d1475e6609094f64c776d9e437f17f3a8471c1573eded2734d647a431ac667b4e32e80da776e1c78844b5ea43e530623dbec86e23c0c8448cf90dafdbd354aeb441234fbc5e856c7a6c39a0a4db67395b0b27e92c23d791c8fae6a6e7874bb1702431501d53299c7d8e01dcce80cd45ae0c6ab7bc282337de090da07e04d7b49e1fe5e9f583a4a86d8c464f31be2067ffa9f61fafc31f584d7b4144df7456f8533f1453cbd02e88de51cc5f4737f56db8765a96f0dab99c5de8ef420991069403aeebf9c0b677a409cb1d0f6a84f287958c3c2ede6b8d1b1a1e0f9b5f05149811a56a4006bfc611621a02e9320f0fcbf0fc7b78bb3cbf70610cd110c2fbdfa87ad78d76a1c2ed8eb79f1858d1ee7926d7b05896a2842d64e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
