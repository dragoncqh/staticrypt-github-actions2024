<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51cb357caefa9ee7d58a9b72d5a1db97e19c94c18b432bb49077757e9bd32337bf33c47f8b1f9efbb7c4ecfb3abe435e658364554648c7c42f39f07b131220e54be8082e9a5aea3ffb90955b05b2b0cf084b93bac43dd1e35a98e16dfdc35bf2fb598de6465beb24b634f9fc626a7d218abce4c3f47d6fcfea28bd9d4ad52be12e6f34034e5f7a451e575457ca2d6bd64680989ecc2d25ddaa38d8f1e2bd1a4880487bc5149e5ba34bc066ed775f41a6aa71d9ea9af779ab5d4598e956ba3e111e0e1bebae4e49dab995f185709825b7cc9e417f319e44a484180397169acd5cd5ad125d243a8ebe91f88d1135571dea71ab71349a9c867a7dc8681d8323894e61c8861d544dae2bf7e8224ff1f48a300f94f9af335c743278ae4f18f8fc12d93d8f987b44e0784c4e2e03c430c9ab65e674f485e004f81663b818b60eaa5055fb8218a538865a8097399c58389be6f474353a3e5115805bb7d09d6ef22cc3c06b509793a2eb5b8f2518095067c557bb66b0a12e1e569dd952926025e9e7f9ca719e87cbd51981d405c2055b46daa74b79edf27e0762fb2b0bde927827c499c567e92ad0754c881697ea08b9547df6e5030d9c7de1cdd12b1a4b1eba3e7df43e2dc81b316fd6b11aa3817214006f52a8b2659b12834acd162a85f04667d279047d5a8b100c3f76a52f3a1e06b191981c68ef9489378b3825ac943487f371dc99f5a679641a0fd5dfde1248d89e9cee3cc9f2f542491a33fccf7667098a4302b94cb1d1e21f98fec9a0711599c4dedfde764be389e5f58ce5d99bc6c498bb0dc6e085d0f0033df6d9ff5c86ef34a61bf6c8182efefcd4ab7c8133c52af282a0f2a103246fc2a69c0c1e6d50c7ef107e5b7e0c6e197fdb8558005376b579aaa573c1f79df84d240d47fc0db7fc8f035060338b9411332c4a7a66b582183780e583a6ab4f9eed8c291ee4c3a82e0decf0f67ad26559eef78daf7f83f70163a3858bec245a883257cdc39dc1c3d7ab945f17a4993e1a592e59e31d72ac7ce4582ba96aa6f9d3c47dd109769834964b4c038d1a83bdf3440185d26cdc609921ca0889e3f408d177b7f024de60fe4a2d44696584ee5df053e7687686368cbeb2e77e30b2cb6f5a123122aa428c75d406c5ca43a74e55a76bc18b9336ef3c9a43a68075b989904e7b24a4e1f26af0050fd9e6ad46858808b04f2ece673c3703187f6a8d34ed23c9f13d3bbff3b24560133bda8cdb8af39195aa55719d5bc582901e70a7c85f5d5a16e0251620f674a927d3ca0c570aa633bd7dbcf29ca5b02aa5f572e9fc68b47fd9743cdad8e0965ef9df1bf77482aadb2d3864584edab6613c4ef04c397e001f5c6b3286f62c574ecc45fecd0208d3042e6a2f995c9bf4759d27cae36a9b34f4c3747d91325cd5ff13239ee2de908d923276d6c93816c6878e301f7f0e8b94aa6711349b15dbda8a2ad021e69a38ee7e8cf3e908c11bc9ad68353b1f2a7f2440b050fac4d39aa7397456d90bfdb9bb59365e74e710f1cfe4e735eb42537e5d3887d2b0cebb18ed3ae9384a25248ecede5889e6859d461c312c36ac293922308e65370118c134a2c048f89a0390c708aca42cc5c0be2e1d0f3fad1151d72e2afd8fbfbaa421baa5f59c655e8b2ba19bd9b7153a363cbf8ed588cb630865d152a48263156e9f7bbd9f80efa0b25b8982578b82b0a6b5009d4a6f3ddcc45057525ec01d6a1ef5c5834538189fc95605567ebee471a069ff5a507fa497773c9dc2375948b2f6a9034fd21132d1887ed868342552b4103f06195b88c5df4918a3a35969bdfae0dade1e4bf05609b012864556e46a84eed590315cf8cd0a224c23c54e57f6999abb02aab61c78ead1c059904a044684e5b4e43598c9b84e7f416cda60c9d1bf12c153068ae2bb32174404fab89b1f46e916d58e84e443b3e487fbde47179d2f7a0e9008d0b88dbf7b8a64e363217683c0af919f2f3af76bf58631f65acc35fdf06ba19607bf4e1dcce7ecd40249828b95bf2a2a61da9e80ef53dedab3c18cbaae9a1228219e3d7e9c3d3e491326238dcdcbc403c5148973756baff74a0a612a17eb0fb07c4e49882afd1202f1a43178ddad0e3577001a68b9c14679353d1f633dea61b2267f08cfe50ad3530cbdf2421447e3f06c42c96de3a9e6b76cb4d6ad1ba8db9bdb803c71443e70d58f2ea28e4458f830387379bb9eb7787f368f314e8caba44b2bdaecd01a6a283e5f7c1595b2c496e94af408376acb315237b197f7a854120ce5f747f40be0f27e166d257ee047b3149f15331799296c56175e6ea064ab9b8c4da8c8408d71b7b777667de92a8919c72520dd75b9a4f65ba7a95aff0e7ce45152cad28d0071dc4948dd31a0e01a63cfef4c7545e3b232d1c1172958b9bc7c5dff1a0f1661ee34f322af17516dd6f518d094f7a618e950e31c988b96fac675621928179c9d12b27a6208e8698ce680bbc8d2124485408f02d9eee222427f6e56225fd3efa7170b81c1017bddf34863e126c2cd1d3b367c881fc5e3eefe07aa1afe0cfec97beaf92183f7dad158401bafb3ec8e85204d3865801296433b685f683ab7b69b360ce2deebcf11f78272473b6c1caf41603b873281cafe444058d12c8fc97b12db12c42f895f176ea2a5702bddd1f86613c8e051c80df514d871888ff692cb9c0051b3e36991d2ac2aa43d0604eac6bf93ffec05734db27f8476267db2dc96ee5bcf80dfc3fc9fee3637f3b9a234d759b485d7f3a64dda19f3336759dd354874e729769894cb61eb41ecda3ff05e0be11c7fb3084249329af142af4d9c6f5a50187be8384420995349eacdd95f5ad2ecb8995ad42b3a100b4dfe856a7b684f74c6f615404edc42c1cec81214e352a78ddc9cb4efd114cabfc432cdf3abba9c5dccf5563cd78885d1bb713685585a5a026babb8d24a209838000b92cdf70c678a50005c01112f93d81a8c38c866cba53bc9655926987b15ce969ddbfd8c6a9f5c7eff83063fb0266ef5e37d18a8135c7bdf1bdc5264f64a672d9126240d2447e3e8ff7fbad8a99a31368fd8179b20f958b3640ce89d38346bed7ac0aa510db68c43d385f24b25538ba64fa361609734e57a1b6f64774f4bd66f30e65f172640e0957d08abe7735726ff66a7035f07819bafbf5dfef6183a41df1aba9ea066302619a69102554d0d9945aa4d6e2396c010df23553977d570403f799573281d87181a062e9a9eb10f98e15ea416fa6c4c191781d6e5cdd9ea4a2105c5a5df785c622564221b5d469939165645488d81f476ad9bf2c14ad343538fef5430e419c6a0f0beda31a7ea4144164eea02718fd77ee768265f949c50ca0c325185a5351e0dc48cec41fb2c6e2fa1898f477ed4e25b1060c23ed468494a9a2829ada24fcf425790241547ff62147d34153321e5fa394bc2f551e5a65179d59a4beb5a24e85e2543d0aba40393b91c719d6f537b87459eaca70e5d6ebd1991b6cd6184244606573d248d646f0bdece105819b65af9e4c3ff79828f55ba89e9c0073c56ee8078f5ffd02ce14cf7c12dfa0c30d6242229eca27714864c9ea2b81f8556355a4be03d9efe7b7be87edd8a8126c626a838f56a18fd677cf70559cc1b148603618f3dbcfe753006a2be7bc7970ffb510e94f8bf0bf53beba79d2e465f8dcada454f5c656ec31036c90f3a565eb8f6a3d9f8e6ee574042347907e053e20b7c9e5f87d6682062a2449870399e4d7beaff34a0209fd3e730b190398861fa7d403be1e013617118339c25ea5af6d4032d4066ae1bae18dbe9cbbbbbfb9505fdd2ee4d9024fb9f652f3db64337c90c4029c092d96a5aad966b3c6ce69e3131b2b8bb1a5b383df81abe85e4461bc9cd96ff02b86627c2481d1a42eec5edd547c3eff0975a7cbc1420f199efb19aec6c8b66ad131d1a5d87d5f00fad6a5b6dd0f3d369b159a15304586d6027a3527aa7d029a15e532bc728a88f8e12439d12e7bf93a7d052f9367d6a1e29b32ebf6b618a7e0a5415a9663ab58572d334012b99a6abdf519778035cf5ed12aa5cbe93944383ee9b3bc76a5b2ef47f2cebfeb6edcbf417b891dc1aebcfc3d4930a45f3f13e44057b991d5baf1ed90c968a2fdd43452763aafca30d8d16b659e23483649144d3316958875ab1b11befbbde3887aebe9623bcb414a623890678ed5eec7ea78a58aa00dcef94b9dd16ad208c286df503dea53e2504f75aa9dae804065ef15c2a94ee0112553eb61636f3ff76f68c7cbaaa5888b008f4f56ff72b787527ca705f19409fc749a8be113dc62ae75d23125093523e079d1a4c0a3df57268e928bfcb3a4308995241d635fbbc61fd6dc6c29d5ff830181bdd1d5f18d8220d910daaa81436a8ae3839f976dc952bb46e20c4906ae9af7855d6413790b7ef0921aded706b3116c2aa0ea446db2f129b7bb5e9e70ada5a7bda6a7e69cf1d45f39c1a38f9af25a23da6408ae09c26dd856b136f7be3bbb14ef27f7d624166e4dad133cd9b676ffbbdfdef82f7fd68555a9cfcb6d87c77e1e2af3245eef84481dada1bb7d0d5a3f60f2da97c53d2f00c2d2dc40a23f4fe635d161fc3896da2f36d16fb9d0f5181a9b559ce194e42b66e0ab348b1c9992c51009d4e1138362a1596b1f22c5d27ce88a6ac35a7039da245a33360f8eaf401191ebcc3dc5a89a7f06c0b654b6a35cf8112fd8b301523cfd9b5e2b3d8612a214d3f62cd3696abeafa4fc4190808280c597adedc38a773717e5e705df711c505bffd191f17985e7b75537ae58324c50f9d5286762dad14aabc36b929e856cbaf0da30582c3aacbf746dd3c5c432a6a26248092814fcdac8210a9a6d0f1a148d480831cf7496d3ffa1001e7e438bd78c25edb62f67cff122ec881e5363260cd6aa47443673d00442ecb0a607775dddfcbe4727041460aeaefca82831ca95e3493c1a6440c9136619a1e85ba2531f7f354dbfb01d57b0720521c5417e030c15ed8a7c913209147d48f2fc7961eb2f8aed8181d29b1eaffbc82885635546b7f03184c2789489611cf9bb7d1fe6184f4281e660ed0816e6a101de825e04f86f4eebc99a0e069a7dd9ab0ae7fcb6fa927e9fc1c518ad5f88a01eb3c5dd952484466984155a04ff56e86fe6953ab70767a3c4ef6dee1ee12a3376b0df99c93f35cdd28f1f5d0c20e641863ac0b1b2255a4466412ef94f78925ac37cef0f86b16de7225cc40b76881063e6192c11ee28e4aed049116c07f8ea7d4a83433f0ac405b356f69dfd136567c1a957169855749cb92febd357aac078da5b4d0c36086bd0dfd0bf8552de9c2b277592909311702b42bf8a005e525a91e8d0ab61f7fe7eb0792ea255c52bdb3ccae654329f25a07d41ac0f064121bd5c32a02c64bbf75e8e8c544205d056d63f92543dbf6b91231aeae5d8617b1e165a9c7fd3002a25aa30747364982d6b7feb6df66075a4a4f6df239f63643265c9a2f57335955f02c66f811b196e5bf838df58f87db9ceec4f585cc605b59fe8dbe48f093559394fdd55f227e00e86c4893299b3fd57932c549e4d2b4f5ca249b00280dac0902fd8c005ff2a9cc754ae3c002b167b35a00c473dae002844926b87b8a972acecea3b35be7611abd0854889fe39d1cf113d7cf1c45eb2735112a69ae986424f87dbe1fbfde7f80c9126e648041143dbdaeb9cdeacd4b4dc67fa60381b45e3ccbf314e9163ced23a9ab2a474464c0e48693c99167c96a073c6c7a8a144da729a4fa8a0392751d3ae695491ef1fa62001933235a6ea33e2b951510443c87786ec7a510bd57025dfa4eacccb3a2468f6575d162398543161d14303c6a96ce538aa684d35e86474a7457739d1ff850ddabb86f834c763d33ee63f695d3638199286a2c160b9e0959a5048b13122f213c6e35cab5448905e57ff614ceae22ac2bd946ff1fe44b8907b4391604d3969337c7b6814d6444193c16e285804773f4bf8c35332c8f0f7bcf3804087cb4846d69e7cd429f0cf4f52aa9a4b506a5d1204bd1766f29ca64c4bfa15cea28db26810b0e164d4917bfe3fc4bb87861aeeeba47d5acf3cea7e48887c3c924d5a4228fda120dad7ce62c0c69b87227925bfe3ed192e0724f063d5428e7b918c932c79b9a25e5f3d033ce762a708c1a4a731aa202557f37d30f45e89dc9e26231b3ee6d7fc222d62358845ccb612e83891054e37185f825f57803dff5b553aa8a71368fcea63e0d2328687f2d5d548b9c31762431f11e75ec664e1805e48b7f5584f511d19e70e50f83314fa4191909067259faadfc91d5601e9208401affc39b9a800d7e483d55290ee6d9672331744a0fbf7023d1178352a3cbc7a0e01c59505072148d6b963b20ea6028727a2e252668b63b680b8f0e563760506eeb6f9d484d13ea352edc5946ac7dc46ec7d73fcb598cc5555bb86b82680962e5aa74b4f8efd48de97da4da33026aa443e4d823e71cc5af4741bf892dbf93bb5caa373c5ae8077b94fd373d54af54bcb9922b2c670ebe8609b4b295f1203940b1ad6bb98575fce3a18c0adc5ad81e9654b8b8d5ed9eec086868e1d74ad4fd007f4fd4c448957344682cdd2d33c1fc67c81d9d7ae8f474c3e8e645822de6db049a80883bcabca3e2dcdb6f075e1682d56f334df09605313136739a6dd8094d17a11e6ba076e30a7c54cfc6723642cf068bf00ec5302e30d0ac9fa215c90442d3ccdc7e3d9aa1ca0711a7d52a319b638b9382b99ed322b80a7a1207fb8d16b4b5a3c2a2d077fe0380c07ff6252c5773ec7d39bc81167a127c4ceb540c8cbcb93c6e7d29b05ad512859331652ef1d3ec42d6caf53f883f571a4ff923adc05abad58777c459dfd2ded7ccfc1afa597e80f08a9eac407476e3c99f94a727932b6beb19859a3931a6f328b2b15f328c75c127dba00bd3caaf568374ca385fe77743ac3bc59bb296a0b143b5b954fd536e4b65d345cb4f6a91a202a19a30a74615c6799f7b372d29c8e9e3710bd8c8951e01a260e1a6ab129434dec5be06de8390df0fa8c66e7fe23029e7375b018bc4003ae87deb2e778c02b594a4c0a400ff000a426720b5c7d4c6811a0b09d71b18e7e601543d57fd8f953e02de84844f29052d0ae0f455019131c38ad26f708d76d2777f1d8d4d58d13a3bdb17b67488d25d0808921efa4ec15a17075c920d21c2cd39dbbdd5c8708e3a7e68275fc689d5e482c9c8e3b906e5be92f5f1bed503c284a53ead5e60c2f6105d222e25776ea957e6f6c848076816e4bc5e2e363379c754607aa8b4251e6d3cc34f9a5a7ab287486604231c619b6c2345adad102ffcbfa29ca3bcfa011de99b7653a033fc8afee51255b58162741191435068923e8973d6d41a084f92f8a6103258aa53b17eab24792bcf7838ce70505e1eaeb8b3ce9041f1fe613bb19c0739daf249a05627d271b641bb24ad5c143008b9757f5f0c122a7041460425684cd8c2bf7986bc4303e5c2f16755ae63f15cffe8af06cb59c244ecd4a48b286db4c844c2843673090baaeaaf8a91c42c65dfc8ecf6488795f46eb6f6df66137b6ab3b9419d673279e95961da887bd31c4f8191616abb4f148b9b8307ee938fc7d847e030ded1d59c91579842ff747f414ca5572f07566a7962759cf4d042133e3c153cc8c99d1e5886c53aa9056a5b01631d7bf87ba1ec23bad3bd6a68c98beaff2e8b732411549839c05e942e9eb07534ccede180f43df408996bdb76d11a8c12b98ce2615edfa1a6f0ac48e7717d049a11de4cae9c653a4a744a6f886ef664cd4159cf6e3f871f4747e27812e2dd60133783239bf88dbed86dd716de0aba7182fe91bcd92026733bdea0754b1c38108e9410180da8b96d573efd0ba2038310343da4c2104e748ef61b4021462e8fa6a833eb6e32fcd060a11dcfc62fe168210815dcf96493e5ddcf997543b1ca43ac69bd50d78f81726fe06941d94a857186af00d29e5421676eb1f72ab335861b61cf27a1a67b35890afc86baa34c1080169a347f0d597f659b3967f0c39c05b0e1e52708ca7601d8d50750f9e658deae9953885a72fd033d88c6e92a44821d763fe6f36cfca85656df4be7652920e2e7c547a7d7809e2e35e27e8680bd4b6c8ccddd7f6d5eafd721ff082d6823f75df6cb09b641f14b86d599adb59b1c153664338b4f9f682ca2b13dd8df8bc3451eb266c700bc98388b66e3218b62958f37288d63cdd460165afad6312942c7fd096afb3fb5df6ca66e05edb2ceea623ce369488f0d5edb6991492076c7b8001390bdd04561263c6ad77b07eab65b27365633bd9dfb6e6b616c52375c6e212e3a22f2c72cf0ba0aa70482f922de02e6dbccfaf0dc23cfa8d4881227edde874e9be8379e05ddea08e6ce7670c8c5d33423e9caa9ffc3889d7f0683dcf12f8bec7df9db4bf84fe78fa6b105f4e81f8c255dfd978298c05518c20be065ae6cad3c14a4f17d8e75f18bf4f6abfe1fd504a060da7d0c3bad82ee5f1a1a6ac125481e9971bcd5b9b6c076110359d7006223bd5509e1986294b50a8259239be09f164e9daf9b875f951ec67abf1d4e18717e64a4ccb77e8da41d219f5b82e5cd94fd46e8252a4f37dea47ecfe6178069ae7ae4a1717810be810b1fe827e546e579e3b3dd9af0f6ef7c97b1333672bfe00f4edbb13a5295afb6ce81240e940bc004954ebabb7ebc303106bb3a3bf4297aa2e4d07a2810ce968f5ee97a7d41e211267908e8d840c2454be635fe5e296c5ed7af2aa1c7d16edd2ee488994c5a71aecf2311b9d95afb9847acaf27efe5546f9d206bd9b8eb9fabbb4358936ffa91bd262fbeffab401d65608a68df0cb59242cb2bc62090d6908dc2b29cfa5adc99737bd2e0a376c1cbb6903da694bb7d27a245d9a300a3c54e51cfb01718f07dc1b1758fa243e543134f0239b45c36a0a52fc1cbd5d24d7acf5f787f4a4434fd285494d0e6a3a3c2009334dc519120f73f8def42f0788a2a71a0753eec9a1941ee4995d062047bef78ffac943151ecfe562a5c46548030a3e85ec55f15529df0199eefb9bdbb92ddf271542cff4704db3279ff2bbb856063e13c51f01f9bf8a578bed7984f05dd4d53101d8080233c6cdf82ed09e13237612c5e315433a0e5965c029929ab78cb831e02b7ca064b067a5661d4bdc255adf8f7ed3dcce12ad77ff1f92ba816f2e45f7ca5d41d48f35d320402c97781af6de11c7232fc76621a6b4e6c8240bac8ed46eac4728f145541cca11dd45c47773cae0d4a7c51364a6c9e30a8ebdcc067f2a09175b54a448d02575ad37ff0a0874b0751ed96daf022b3e6df635a5b6fe8fd8ba8c8efac35c98150d0bd984f04e0bb26db683a8d74da9d7b5d58f20e266cb921a46c2947b38201b1c6bbf1e850c9f611d85070648b0cb0a1d320f2ba54dcb7baad775f67384e5a633c6a2fe64a2aae20e0f78dd64ac75a76cde164d47ff9d62814e3f4c095bdc49fc38e0bcc5db0a66abedee81c675315ca7078becbfc0b39e708ae65393f7136e79aabfeba5c53b71204860dba1b0210192a1a758addec7f98fe40adb30890b688a5212445237ea2ccbca7e4b85e8c7aec7d6fa206e18580a5ac6ec52605d3ae2b246545d4a32f128ff8ede52cb2fd3414e5efa414d942a5a965e147cd1fd8fdf95fcc725fd53ffb2b2e58966b8749098564e466453713ef54a166a1d7ddeb947ae6cbaa2214371d23da2bd0d2636c1eeee68632e9eda9ff6d2b46ef81a445a1a211287fe626afb5c0d134422a9a2342d0f5f702d5df31427a5b13ad8a3790b91f08b9690043f98dde3fd27a07764b7ba0349f32c46951fb18fb3e6c2049a5367733d526a96110bb2ba096930691812ff004b1c81d213ac2d6979a30d306102f4cb2c330e7658df7c40f9b6f66eed291b4c86ad503d601d41be6798fe04ca8ce6343286245fb2ce1c700f204a0c10b7b320e7edf69b3b8b43997677ff0e7ff92a9dbf2199fa39f5e5f50b6988ba5e8d2b77ceecee2aab7d0a50d2f07d0c34c3ad3c1cf443564f42b2313f8f1dd71e01ee5e1408b0140640a83fdc97ab7bc91061263dd4e0b41deaf9b225a7591a6251724ed6ee1f392ad15d602ec50547994809685e587f2d4949a47946e27f7e5f7965d3db1dce3c761c236d445f9433b1ae764136dbbd5da6b41f9a70c9713d42d2176b402f223988eff06db31b62cddc47f1302a19e8b0e21f179f664f3ee28ec7284fba484d2b58ebd78394876a257c5c80570ad8fc3420dcbf393b7b3fb4af51748843657a20005c04cc0a5bdd61d9de5f56fa114546e6c2ead92dde7af846b471e83dddb1dbca29a8f8002ab03e164fbaefab0aa115954908990ec1095ddf9dd2cdef42f23a33ecbec78172c11918d683dd1c33240a00f13d9e54a5180a5c1acf9264080062fc1b29c0cf72c084cc80f0969046da61999b5bc954d0f18f639191ff59908a968ecd1e371db56899a319dadb2ef9f922ed6944e6a0aad90408fe976cfb3107197c828e7b60c27362b8d63342ac565ffa286144b37dcddcb144b0617e9937d0c23e5b3b6025beec65b9e3a7605c0e9d38391e3abcdb4b94c9e1f24b93be18d8e1570235f94c4a1df5302c7ac9d4612fb5d2f65a8491da582a816113b1de0cd16c9cfd1350f1dcd1db3714604c5a6d9d47edc75da7cd6f57ea0d3f5cce2471859bf9e2dd30147475a550b6e7573c04cf27eb389c112cebdd89cb666468b73818c0f1761e57073a82eee91165eddb4b4fd497c0281644c54d2ca89e9aa6dba075813762a31bfc336d0b24b8860834ea386700e546dd5db695c9649c32ba6d96143869289f696e1979d1afa29d86de935352fa181bd764bb0db4b3ef29771c9e45321815158a2211640af755ac7a1b011927a22bb9528e8fe508eaa0a56dfaf5ec242896ee264861f24484a6ca0b77405480d6271f07466fe761e75d95ecc19a99ae688b23e10323a6bf608e3d67d750f94128de645b73b1e246d2bf9fd3a8dfdc6843b97131363da6089fce9db9c8170eefd45178a3101f9bb53f6ddddb2f04d903e9b226c099a0d5f08b6558826ea2d6447cf44dbc922e362eba7f0985067618130f221f54be32a375c1aef77ffe0db0d1099eb0ae3ae2730c293642eb597250bbefef019f9bf78ec681bc355c144c562cfe9ac3dc73c9d742e8359dc9f94356f6aa2af6dadabe98cbf2668c8ad735c90fe76432d50db86ec83201bd2346dfdaf19fa9b19c65d7199ae406402aca133f47688832e2ed1e8f750b569eb1a724f08dfe1151d908f75ad747350eee4908ce8f0ffff009f7f662f7f7c52e1dd953e5b0ac8fb96d097ff9595b336a66add7ad6aa0cf28f65dfd6794d82807b05c4eb778bc61c2382e3ffbe7fc6afdfd49217d14c214e1b9ca575d183fd324359bf8698d9da95897158050a334ff66f1231c22c809be845869b532e22d90c81e102a056b6ac9634397e8a434f96fc6fd31286f71fa35ca1daae57bc1b4290b128081c79aaa044983991b490dc57e58cbb91d4834e8d224a9f0dd56c2081a5248a325bb5503d7d527969438a268091f1c0d9faba8b234d3b8bc7f367e436269197238bb35fec50956bebee41d018b2cf0909fd44f8d29f334cfd73d5c5c8a43b72417f0189c4f7ee0c9f4f5246eadfbccb29f83b72fbc8ccd46bff67e71d56727282dd8c617d98279929baf287a1412aa309a671ca167c2cb941f596d75a90cd10974a3017fb86fb86bdca63c9f8cb06fb8991e50eff772f62f168d01f6be145374da38cdd469cb7c4d6dd1ddcf91de122e7b624b8b39d932135bbf0c269d4732837a4af6814b9d3127fa450cd440778aa8d671be17a1afc1fb63848d411c9186d5e1533b28e863c6e7de12965bb7b29fe110ab264c143ac9309885649524b97282deb252e02292e50fed2783219948d3ee22be489aab413707cc41801a49b5861f0d45c6ae200aa9ff8185e379b0a4e7db239f807cf1b0e3da659d4b318ed49605d776ed72ad6f14eab896ef8f355fde7c8c59bd2b6ab98f3c8818a04a6b71d8240b3b0f97c0903ff51a51b15d3d90ea282bcf7cec7f18d2cdfdf50be331b8099304d259b70af08c553deeb8748c1708746d8e69c1432e4a5c98f3f343990028effee457b3e3d914fe3b9dc4d5192c95d701d404d51c595f7e1321d896da2cc8a89a0106bcfff43b60a9eab16c5bd7dc93ead18c57b70520978c6fa1f975bf32f574d2dd5ca2e56365cc1372f857fa27933c6b3acc6eca147db5c05f82660a005e00895fc2eef180bb52902d20242513505f0699efa48893424603926d34681d87d07154ac4301b469f9dbdcfd90ba139566e712cf1f26aeea91dd356c0ef01b6067338eecd50d5f73674f007ff4c4f15f0014b2091b46c3d929e26a3b6ee9398eb7a5a6e9d8db8db89e50753a8562b35401b473389dd57e65bfa6bf5088a7a359ebf24c979767801332545ee04d21cfa43f7ba20ccf0f728c8ebcf39556111644e4ab15fdafc08874a542a1735898281e849610e3e26cb1c913985d0ea8c89090b30cba6f5c73c5d1e52e9f533c9500528925e46b34aa90a3af5b10f8d2d3ef81d86468fd37a9c7e7db1c36c972d71b787ed48050fdf72bf9e9dd71555b2d9d0c1c100072265706790b3fcda567be8d90100669aa6c492a3a3eb824be73f3ce56a348d7a1942c6b045f328324b9b905823c2cd6fa03626aa36f5c4f7b79fe5facc56a0f16d8da755e39b46cab7df3f65c12048efe3df2f680d97b87e928b0a19fcb1d4dcc95d304ec88be5ae7d8bcacbc0390191be64103421f02142107959bbe879384d08791983d3d712a328191303b243ee7568bdef4d98ea8d1330faabeadb072c5ae4909be9378ddff2bd5a018d28985e199f0e74312e52bb56e37cc5c7f6824ed394d68484824a39c31d1493e9bcec25c11f382cdd689c8858ed220d940c17896fd55cf791a5af1e9532345e66811459b2a948efc6573bdbfe7ddf78b7a0e824e83ff3de6554b62371991a274416e929f075594601e6f18ae8ef50eb2f7811fe3368a0f8e065fb58354e53b132cc1971a02db8a5941b921f61e58da91f029a96ee9b1027e9cd625c2abb86de379c16b8b24cd6456fab12e48363198b15a0a0680384af5dc0b7f4d0d4750703e2c7767ae185a5502429da1201c846e9afb824b9e576a4e05d04beefe373003bf6ce9cd5451c63e47aa0207d8efcb377d5b2db073e9ccb171a15e32550f2a32a79e9f650402b90dde7610ee8544b28a2ca4abd3ee88c2307414fc4833fa9cb0b67933ff006ff6e1815e7f9e103c0fa51ed43601dbd4814b1f16b58d5f02e2c238e15694fa607fe14b92fe3af49a87029daddc1de388a2ac1dcf5e12e4a44d76209fa2bb1377ce99a17c9d6677c73b946ae60d02c7d877728836f530b9d8abb56851ff7c5b1c6acdb3616a385ab600e070bbb4264459701cdea1754ea384699d1c4b2009ce5cf88585557964435af31c5a8455b010fe9d6b933e81a1ff473b525a5ae0dfff2168c6a7ccf730c6e28ff18cd6d2952e89279526b0cb1a21a548c5818b766d8197ba639743272ecd4e06b6d30fd6e0c68f45fd9839edd10418ee00cdd09de649384272ca0e40d589ea7721feef46c8b5de5e0ab2f6839064863794f23e59573a7d44551c75b4142773a69c0a84071251ba8fd8ae73700b40119c5d821be2dd926b19451778ae9db6dd4a036c0c0a65db0b46d01d4c863682dd4825c44fd8005ab92e38bdde519b7d7355f4bffc3c513a315cc06c05025bbbba4781a216f3bcbf95bfd60b172e5fecb72ee04e99441c259ff5fdde7c66e1137eb9f426f6f6c12cf769de7dd67cfe44b3602062f5e94f075b8986c1fcfe96bafc853d5336039e76dae9e51cc8fbb5087c5335d281ef9a28ba3859d11e11b5ae8a266c3a8ac97615be9275d68e809e4d1b9ba250a13dd144d59c689fd899922eb45f1bd96954f6e2a4d73b49a01bd132534c6ec8c0a609580bf9b2dbda07f36ca36522e51c35eeaaa62811ca3e1f8b77a8662398eb6e5e6637865ce277747ef4c9f81d203243776f214dd45d126106bffa1caf41ffa09c340bcee8b452c7e44f32bcb8e620b881c2f0727e1912e8cde2747a3878b8a4603c48ef4da7ad4407ca035e14f7b3bceafd6f509682f45df39e35ddbe8276241047bfaa5fa1f4f595c03edf419f307887462406e65893f9e57e6eecc06f26585fb7134f27686a3606c65a396bf0e801ccb643fdfbb3dffa52c12dca33c53ca2a1b04fb3ea652fd148efdb653d8a02be0331bc06e59805c4438d24db039bb838f131d60b896f8828c9dca4e9c42ddeb648af4e803c681ab8e09754e68354175009eba819291d5d23bb8e446672a6e6f97f7010d6959e24b222b3cfba03e2350d1b8e91c63b58b3208bba6b10755c237ad0b2ed207f3d4632f0286ce98850161a6f780095b6b31b58213005b552af3f0101888d197b775bac16e35b296de444f3472756ca93221ce47f4cfba131e76b1e9a79016c6ff1d3f00adbc6e78bb4c33fbccd10bd418c03e79fc978e04dfca895047d1fce0abea2ca234927e7eeb6590bbc16fa4cc29c76205c1c00bef1ddc1a51d65e183a497718d9cfdac9c257c32fda38a347d7bf8b593c9c06029a3316e2f59771f5696c730a966e65113f6ac0a2de4262b5abbd3a43167a0543c2e781dbcdb87abcc9dfe1ce5b908b746c456fab899af32c10fb43554d65a368870462b505d3996d944255bb1f0e74eb3c6bd51a28951cfc28602ac3b16384e0075303648380db9b5e1a33501aabcd72739e8a75dee15a6d7d684f2c7502b5a65382dd883fb883b54b198633b6f5a2b62190059089a92c50b77778138cb10c6220cad525eae428921ec444878c488041182575171b542b798aba6858705d7f58eb84911d14db602bea13e26ac2ed70232f7cc7493ecfa0573d6069bd3af1c92ea26a94e8b7f33e5d6d8956bbec882f5914ad085529c8cfe89c3bdd3291ae7b929fe5e37d1fd1d28dde79bcca7614933b14adea9a5eacbc61c2d5b7f6280e07b177475587d3aa3f76268c11e65c2826f3afa8f324ff8125d465da0628d4ec3fc61e4b92c2924a572b4df7b033428d2c8417b4b658b9b3c5cf43e7da5512dc163664522a62934f3f63656312381caf538be24ba411018fac58b52ab1c6acf7e1030295a3665111d6348d02d123b7c8e9d421a0b01f5f4e8fb0edd50be5c7b6defe864948e67cc2b9500b47b466af8d19f948f72ad1bb902bed374788f85ee6e3807b649718d0dd7f442299d41b03d761c1a6f33d58b0848da3735451f2bac36d120ba3890ae261f9efba1d4c4d099d8756a899cfdfae5651ea140f7611d878f1770d30c49dcea45be3d2127b03be68b524481ec6e59d08e572ec4ba2922259ee0ddaaaecd8074fc2254a49e90ce5f18b2cfb65a1a726961d6a3e332480349532f76c91b3e5e695300f40d62fc8945059c463b0658386bac3767636c99b7b5bdc912f42bf24220c49a070e11f02cf21c05bb15d76eb10bbeb1e2c6a51b9201506f209caf87d30a4f64d057be3c3ebecf365f06fe15a79cf80082ce33204291ede79f0721d1f487eb3594b645054ceb319d46bc9a41cd31ad0b08732f64b11a0867e2f2495f2591d48301adfefa7d28326b332386febc048131a0af8ad59d073856425bb65834fc0c8dfd9789f458ddef2a3a7eedc577d50816ec4fda9adf731abf1cab675d0da8edf37308a1dcb802e2f232f6c82b4d1b9141671436b7bf704be7ec0bf53ec838c1b8ba8432b3422507ad398a70f2922fe0f5cf4e180f20466cea6592a8f13cebfd698dae0eb7689535d1503812e64be2d3ea28ebfc4c64e8de9d66aa66d6315a3a3123b1e2ae0ba2f0dde9c17a8b61b83c15de883188fe07ef1e672a4b22838b49ba5e069f58f35390b2a6f064602a53b830cec83a3d665322db648e0bdd0e38a7347cbe2691bee74d168ea13582bdf094ff2fb9f2c67128bb0a9f7bd6da5de45435274f5f87defd96cefa20c2119a0e566f34bf78c9e61f7daf064860ace5000aef6ec48cc481f9537d5c84670efeaa065c0f94a36988fec6de0188634aa7b0806c07c17bbe00b2cd81d01ccd80a4e6fee4f882aa03fe27f95b866d230b34b105ab3d2d17ffaeeabf84af95f294d41cda9540a44f575a358df05747ce42648a7f089db941054fc9f06d54892b6d0d469843562e6bfce7762a49ffc0bbd9c8e27e3caee06a2d4dff04622a444cc65cf189f1fb4ca6c5581628c0cf9658677236fe498e2d5c9b9670cf6131914daa9039d61d1cd6fb6e15461321b1d6c8d144a6e72ffe5b19713eb6feda859285919a3696f9a8880f3ef5c8f882ff1a64f79e50600bbaad7c2ca95374908862ccbedbf7adc390ee7ccf957e9da3ed4b6fb552326a6d1d6105362d7e3dbe57bfda51f0986e22851abd9e20ae5dfaa44eb0c9dea3f9f231818724b3bdd2ed67a54f2d35a947681ed0e306ef40f494d1a6bcf8f1d49ce42a339790ffb416666cfbf57e486203bea80ed274b3f78a9ce812e2f9e9c4041eef878779fa4ee2300297b0190bcbb104d0c044fb01248976abf4d85937d664906e339e2ae2e1783c12dc8e0c5447e5fe31142d10aad1af561c8188fb51347292cdb5c55434d8700a06ad135c249a78718fbbaa6a1e254421f3aa6cb9dfc0ab8e30d996686bce3f724fe31e5c1f0a5d28d689aa7ced205b81a7d5ebe0b469ebd50a429ac012cf1a46a40ec0516626443afbfcafe308a0a2e841177192787e449811446df7ffafcd4d5cefe8307071a034964a4cf82d806bb246357a1349a120f9a419c7995775fdfaeae260101bdb4223357be48fe6951264e5366fd3c8314e3b88acb226fbba0686f3e29fa30e9282a77d448897d29d9bf316606793b94e0650115d23046fc9bc4a44034da28892968e01449e4b0bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
