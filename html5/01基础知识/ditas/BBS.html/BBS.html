<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d99a9207e876f78e373765af203df67b7175ab438197026a91f6ae1d96f180a4a20ae811c3c360c3684a176456a445c1957acbc54d33766af1db139393dbf3271cefae6c77883722cdd821bbb0a8cd278d1d33b5489cbd842ba10913346e25342e3fcb919dbf5ea2461b2ff73a7b39eeed613e1734933ac212370cd5b2c35abbb4fb89309576aa49a889f4934e1a06d93c05d75564331391e4c2c2f77efba6ac3741cb83d98875145a00ff16e4a59961b189415109a76200e0546ea0b86fe21a8d5b5a9a507fffad1654ad414d2b8f791c2fc516c76e30146c9ddeda9a058249f18a98f89a16ede63c12de349a6634740a4014f43c0c3d01b285572e2604d5e8bd42c3d7ea5d73b408fcf0600355380376aa9d5040805b8afb4bc0394ba86e18e1b34265592a731eb8f21668d1fb16206b61319863504fff4b9b924f282ed857871fc1ea3fb483b6ae97640570d748c6d903d8d40d41802e2dd00a95ad10187042cbb2e2fba907ecfe701092693049cf79a87cd6b771450ea9bf5e3dd29c2c99bbcaa8dc515cfd5c48558fb8b96f3ab421c702baf85617faa5463f442b0dfdeea6a5ae151c99e3853cb7fa9f16cb760a5ae0dbdf5d5ce9849e2f521aef4014e6f7195a1dadb737dffa8b9f801c908d14598637c8edc1893034eccc2ddb32c0f86fb02e5b5b1dd6e16ab65ce4ea4c3651825b3f78f73b1577487e72f095c536a1f462f0e72f7e4de97deb8fc56150d670b721e21d97aa54510f47935d1d91fb55a71d2adaf55b8ebb3d57d788f1384f61d14c830692768c2b564d295d8edc26139ca8e3018712cee7add45f799b815646e0a31cfb8e73e07c10ea85ce780c89eed13e9145973ef029b63ec375ea939e61232bedf509141e7df133a7d216358926652759ee763f144857c4fee91e8a37a71720ad594fcaa455e4ced9fad4ba5cce1e374549464a428bce5d602798d17c1c91b7e3e7fe387e4df0a0c807d50d1fa1c9383f85790c56aacfbbf85705c01d548b7aa24a91d31d820e265065402ac806a7af5c6b35850a63a00864ddb0482d685b69ad5ccb3ced9ddb3f7a4aa033ca168cd9368bbbb8b7930de2e6d251277455729805dd5eb4e781d0133bb739f42eb62400055ee400665c6202c105e8e82d9af86e15581e862670fef353fa8f10a88aff51d7d4199d78de97eb7e133eb98069f8540eb22c9af847f258968d3cd4c62c34ac6d4ecf3189bb8dd0e9ffaa3f464646336dbc3cb6112b96eda3e9d2f60c9d3f3e3efdd4d4b91105eff3a7779193f2100936d89230229dcaec8e6cefcbb24aae85569bf33fc5e3cad2db6e2c5b52183816728e5f203b26340d2dad6040a0d7e2a555c2de7510521c5b770c038f42a0bb3fc9b5721b540150b7818a00fd009ba1aa7862225d27f2474af75d4b7056c746758de3b047466e4a5afe5c0a8f08d4a87b4012bf87ac301ae5b48d0d52011297916c0b4926d15858ae96e1bef0f93aff58967800c2b61a7c96e53665b15e7952a57512fa38a4081d2ee3ede9ab6129e9540b3cdc53ecd409492d8a231d439a17f3ac78aea9a240a32fb34007d246caf571a8fc6412435ef763287bdec0b644e5b9dd5f280bc5379a408d01c04bec9e7afc0d5829c21f9147e7c6e24ac892b54a7ac3da68a66ebd567bfd48ffe2906981857da39601cf9a279ff188a688fa968851ed97f3445c68238afd68f3d0c689e9fdcbf7d7a0a3651d5769c00dd6796803916fa1b03e1eee997de143cb7cfde075f75726c284117734ec49deb1f0b703a10ffb4fea48c470744a779abd0ac89785da01cd6756e07d35fb481e8f68feb3636810b10913b345e864420b69384e500f02eb5057e79312af375592170480f24511f3e0f5d43682b8383ce2abb53d8eaf3b2421bd77f535ead1200b25833bfc976536869c6bd05d8b4d7bc357081f42330274da9e36f28da878fa7e6a521d79dd76ea55010e56a8ba5d68c3e55eb626533c75e51b7e1480eab9418453dc26860950a060a0ea1bc734a1a3f41ed5bea13cbdd58badd2e7340379b619c126931713fbb23a62a6dc243a82cafb06f7ba61872dc70d09e41c893fb60b1370c9a5b0c96944b8d51ecae392e66dc9f455be980646fbe968a57c11541f68ba14ba14f7440f460bb8fca754dcb4dca899c3ca97ad36aeb93c3cd962f136e0eee14d95a0644115bae6cc1fa8c01ff1c3a4012c05cf32e38e777cedbc07241d9f69e24b6425982ff522affd20ce0dd8bc23e57523045489c7c9fe9ade1df68a7b61cb46103e03bddded7186980702fbbf433d127f59d2751495d7f9ce955766e1dbd96669e790366fcb22d363e6a365c72e71fef776fbc9a0588eb1d5e88e1e2bd3cfa03ea2939dd70350e0cb139e2bec341a2711cd0d442dbe6074adf4632b1c229b0bb8058dff3a359957fb1b64491f765b76dfbbd62704104da61bce6a92210fdc087d9e1152490fb57bc7e4813b0bd18d56c08b6793a308ada39eac176c8d8baf3d44719144f817d26004b948b26b64237d5fa1041a2bb68550f2155af9bf9ff7c9a738f28cb0700062461e461edfce9089748b2126e500b99dd6ce616848bcc6fccf52c820fe3dfcb978bc04b7edb8803ac24f918697e3e8ce6afc5746b0cf9ad31a4eef2dfcb5d93c4a5b9721fcb854d28583b7e325cb25e68f2e0e14e60dfc4e195edaf5913213094bb8a571a02208f7cb13d7aa5002d67f7d1e6144cd91191bd2c117ec5e73fd04dce832575af2b0f3162c3c46690d2bcc3b993254992b4656f5706567d249796746a4c78461f7bfbb5f23b0496da43eafdfa79de21fd97392fc1c7344716c3ba90dd661988dcea95916b90c2aeb5ed11cde9afb28758cade8f481048a595aa61e0ff5cf831823135724e2e06ec57e956ceb1f9e976021ac34c17e61b6f6aed9aae433f5839218b4a3e68c5c761cb7b4e69f3f2e62d3382975df3a549e98f98b14e55fc82938be2501c58be002602f1b3454aefa3ee36ea26dff7022066f9c90f25a71639f06e6fec00dcc9320fd5b85c60cfcc1986627a321908a7eb0d56386d9fcd112a6cdf822befdf0cf6e7cd718e411eb0b3619a3d72cfde974809bb1c2374f16c6581b08ce5fa6a671432993f24bb9ffe546e3898a0e14c03f529445b5b80b8f4affb5c80c07d994d59dbd1684fe31c5ec455e491e51bb64471bd5a9e076abb9a8d1f9401a865aa0c320d3044ed82f89b4166446b6b5727061f43d07f6a115ecb9da0df37f4be809b31a3c633565b984b5240ddb5f7a5498488df7e9df8aaa25ccfcd3ae4d63bf8014df5367ca11cbc29320982b9a8c10fcbb48b9b4837b002c732a2a637de14e42da82d106d207ad460d32c41324c1cc1d92b17161bdcd3e0fb1135ecd23ab18b96bdfa57ca10cd07adcdc577e901dfa8650630781047e3ffd65265feb597f8bda44bdba0d45501536de86aada0186a42db74682a8aabd6868baaa533c0df77fbc7de0ed7878dec6fbd9b218e5672106d01d6662b9199c55755b86bbde715ceb18de3271682ea4ef28854aae4ecfaa43344974af65c1939e59a0bc63b61f04c10ffa15bc1147ee386321e11d9eb9131ecd698714de9e8962726e5a9b2d6d0a6316e95c5e4b94a33e5a28f95e7a182c814339940f4d767804c8a5a9998a201d6a97eba61c8ddf34b2d97792140d13476cd907cae96691c4eb34a403653701e06e04fc30e20fa166ef12f7ee7f23af9e9a709afdcd4d2f8d773a9157eca9240e4883a4f43dafc130845842d3dbdd0fa1741eef1424dd22e38a7e936a743ead1cf1884ed078a7b5992ab626f5a181b9e41f60e5e124ec86a35f2fd4b1362ee689c024e0a444cafc5771ca197eb7b9449c4aa8e1324230162e9cc5fdf1c9006a812ee7c92bd60cf22abddb9820d9329232b16ea3279f9d42843f9ae56cba412e6385edd975e5479af06f7b79491ca30e63019e3ae6ba174864f0114710b612e915c39be1283c17d8f746d0ba6b8848b7a82461e76b52bf9d5618b2e11f15f9a044173535d967df7da19dfe53300cb3f11d235e3a2482e75ecec44a0b4d927a1770ad5fd10087d6bff5e913688db9288d68d67a0d13f85f767dafb643bc0e904eb8fe2d0effbe1ef064963e8fe10dc34acb5524c9f3f0cfef5b93fab00eaf2a2eb0cf8e6a8db0aef8ee797c5ce1f1a9f405df1428827f05fbb1f065344fc635fe3d745f67ad1b8fdb4fc3f2d7eda4ec4166da4443c5ae6a5fed72aa1ef175b60b47bfa33c5a50700c5f33184d8ed6416ec2e912d0c147ac16e61c66025258a1571f88ab17112f0501cd4f01dbb78390cf76782bbeeac996c3268664b8e45da34415ca7373691f748d16852f6971328dc167856c6341f6dea3ce3be2eef5a02d2503b78fab6ef88cbc03afc47cf20afe0898d374c2eaac18c2807782def08dd95c76f865f3b16b25b113a093d4278fb52d3b2e2d54e32ee2647ee27ecb1057a82b430dbce0ea080c1241b83f672bedce01c1e4d2d6e5b310e6682d059734c68332c2ed4d8390f4b9747d8a7da12b8634cd561d62fb25cbbc0af0ede955a6c6e13c1c4790029f53965d7f23d0f5d63af3a82c8545d344ad450133c0119efeed537a4b68d85b319f71e58fc1ff7e6f205257923de47d9493c65aea7792e012826cc9d2082d3d8bb772c2946f0de4ce870e717fb98c7a6cd0f954b6a48bb68f00593409bddce6fe6de753824373381db753cc328905f47206742c4face5a0d5dbdfe39b60413184cd1b832f44b21f68bfabaed2ec9228f498d6c322a9567d0c7e12bfee15adf936b75254d8e72b2aae9171ae02a7b843b2d5ff9930b5bacd0fe5dec7e287871600a1d4389994574e1e8f3289a57189cc2cfe9b84104521998247aaa33da27f1e2af40cca2f28f1b967c4f9367c2b708eea2655668c4cb43a50762df169b77161486c70475d091098b4250cdd330937c3cb53c9f84759ad67efbfb93a2a4dbf8e61d95014a2601c0a7772e514dc73707eb16fd3fca4081cc694a70e5f4228d8feb8af9d914dffbcf3abd92984a25b11f99c8d94054175f46ae8012c1149961abda527b7e3c6a3795f053d0575d29c7c8786e2f906f5d7eb1cf8f2806084ef29555f0688cc9c005e950fee4337bcbcd0146ed383a5199ebca30b7a15b717fced2cb0dcafd5a61459ff8306125a051b5498b3334b621319bf9183ba97508f879168256b5b2dc5ca99d9a6d8811390e51f3e7b7a85311d7397c4e433d3c70d406c8f5f69496a9bf0e4e1051b8c584ae13a490207ef59114d94195e3c553d2e04b4b82bf603735a5f13ef018ba460c66b0fb32e954a7e743d373295c8e691d7829fb4d59006acf8e444f34c63a040e2bf648e46b327264ae1ec0e008b9c8826c57598a6d7e885b0770505e81f69d6c989c478a4ef400da87ac154e43844906eb60833bbb44e3031fa8f3c183d8ff3e8aae0e32ad0edb353d28af828579166ee8e9a26d46a1995d83d4f8c6cf539e48720fad2f2fc2680103e42c1b391b064a112a99ef37d85bad0cc1aadd0a80794e69f79a7d485d8e131230287fc702007551d552ec290c74d9703af6115fa591c9e719173825e5ac79435b984f20bb417667318eee518977fd5bef6642a4e40880167ffdc3f4a6cf2e83b260f3e66886d52f72f8cb56b4b6324f26d88c12e32894013764a89e9ad2479f7f715d50116f06ee37131a587980e9775e510430fcbefeb4132a4f7dbf28e42dea2afbfe7d27627903754127877fc85dac2b8874d6920cc1d7d3b2b3fa5d0351ff5349a6047e46b177eb95bdaeb8de4a216033ddc7fb49aecc1af0c39749895031d773c6ca0762cea138c0e2f2c5914785cb81c726a5cc8ae0dea8dad537ffa93726fb9f725e5900678dca3946c6c846a3a9a7d389c14654d171b4f75ae3e0acd7a8b23068baa5996da3b9ad15f1f3a30bdbf7a3c116245b5954275ffff3a5347ac532ffbbcca206613a096e9915cb52efc503ea2dc407f481f5c79a2c119d97fbcbaafea11e2ae12f03375fd2a593a742679c5094177dd325bbcd131faa355b7c7fe01fb8568a5e590b550960c41844545907c5850889c4026877f98c9684c7088bea4a17eb4b63d80c974c7ed27c2b712aff9b6a3b1f9ad2ff3fe3dcd0e9bf7b0aedda7e7339ba9277ce471dd6372db1ec3bdecb8b7848fcf3c12d95de2c052a5e65e26dda5364a07f4850b5fcdcbd4e7da41d988bbe928fcbf56d1d705a7e61c911d0b9d0e4295775c92b4793841760c2fdf77768e5bf8656e32e6e3cb5747adcf2f068610fa18139de0bc33513d57829e054b9ac52c469f05ba2afdf5cce270664dfe39a34cad81a7d76297ea04f35b4aece73ce4463113cb25f5e606998b6adc4c885dc1d1fa5f6a53fee717aa33005be7010fdcb9965b73d8a9b6b93e9b6b6db27d421b9388c8f4e8c51e46a012778da6fb304d13fbd8e71253feebff74ac9a5d818f3e405a2b2b845c86cfde5990f7eafce7fcf0818ea5068a9dc14a5db95895232adbe8fa99b19b5c6d2d8683a8bb1cef0ffb13c90f40b883cefb4af7e7d9b4c06469a7d5e9f3c01c0d2e65c0733a7cc446ee39673fcd43de387a47314cf30bbbe1b3892b4094eb063aa6234d3b7fc8dee7b9bce5126a38b84ae625f10ff5761efcdfea25f03af580316012691b126daa1223a1573e72050cc7646356e36ec6c65e16e4d335bd166eac80e6f5d1f27718a245ef9af89e4d7b1ee960dcc07892d14fa87763bb0c68a9482ffdf99b2ba6f85660e1d21712deade5958aa324a669c49fd17abbb3c8c4db606dc8fbc9f836f219847e3b139d99c105b0d35440067e7b2d20c761627b0f2bfacf2d9523f20f822a64440f06de5955a94a1034c9051d782b77cbaa6d03126958b4b9d948552b8524339b3971daf55b5470520f82c11846637c7933c1b73e489912eb3a0dd1a33e06c5120d3ace2002cacfe92336ba1162ab4c4c2f3e1267858eef50b1cc2470f77deada2e99ac9c73ccabaf9e0f355505f30d39770039a1d0403c53395cfb0644030fb4d1bda215d53281c72f821e8a073392de1be41adb32134e64f7cd876fb4da79d1971e8e8d52191d6ff332ac7fa74441bcec602fc5f1929219f051e40966420f61c7a6f307fa4bd889e7ad2f00d7f6f31b23c9ae9736ae2b2bf41f403c393dea10f8ed1228b7b786610201ccd714b00e62adc66ff33cbf752e1031c512a71ae9952a2804294f027f97718fe91ca588f749067658394742edd2096fd0f63a85771e87fee48d6df905ac7c5992d7d666eda8ccccd9b830a2a0ca4ec121a4293c0a5e50b1d721986dcddbd1d0661e3b53af6771562c7aa1d6ba0caa3603f8b740507e14c3bf808e07ea5de04ef4661a46de668413263e4943a50fdae75c7c365e1bc996f3d05edeec7360bbaf2be39383db1e467fbc8647b44a80880180f5920677458f73bebfc9feb92bdd275dae42b419cd6dd17d4aa1035338f9baf9532057e866447fc8e215a0471537881c140fc602791cf240dc7438492d4c2874ed19f6d9d933f731536065e033bbec468d4ee34bf5f607ffb96d5f845364e8684bc752ef41e689e61549d4719e3710851de9b9af71672a4a45f8be24c0bfcc0c0fe01c7f4ac13f088a7f93f5f3e34e9470aeead76a94fa32fe4297877170c7ea4327d67ea4e48247670b944b83bc7b6d362fac148075cfe761770ccc276d3c8f7a91816bcb21e581b3257add81126112f612ec94550290946a3fad3ac9c04000722e1e60ad1865d6abee10b13c7140b2cbace9f6087c663c7bd2ba973fc40d5bd2511298c74d62bc1df97997d89a8f8962e98dd711ab0c77b63bb363cc4fb85660f1270aeecea707b7d93500dc76b1f1361d23d19cfca9a2fcb0dcb96593d43ce31cf59aef12da4ec764e7ce593e8e27d1e0ace2fbb888bfa39ffe652fee9f2949971fd1f03df976e959ed3dfd19e05fa566ab16273ad75fad2c51d62e21657798ac6ab0c980c1897010eaf2d7a381ec24fe3cd22d629807dc433d5e75f1d52bfea3d660feb325c5ff2eff4482971540debd4204a1604316cf10c7fbb8287083404368f3d9c9bf2b082a02ab87a7afc389bc3aff7c247ad5da9fe6c7c6ebeb2603e3283f42411e6d6ef97e004574fd03144e81c85bd528243a5e64dce81745705c94e67e141b54f848e5a737ddeb6f277d3f5e811b2f3e2ba13b1a64c3899ce59f1156e9ad69cfc0833edc14b0ef7d6017de027a594578c411a7f58d74c392acf69b6b379963c5b1f4a1f3e235c6f6fdacce34af016918c9384cd6678ef841b4388c8256297aa77c54cab7507db1b859b9617cc4c8f1faaa243fb2e58dac3c99efa3454066840deae5aea589f360da20afc6bea4ac34e4ef90777271401ba5b1f027f8cd269ba3b6227df4a2cbcbce1f4154165c1faf93ddc714227475e9fabb4e0ba0c8617ef4cfee6bc84369658bda20830376d3f1c9088e1bce467cf2fd5931f2ffe59b5195f5c3118676d32f09d1064c164f2f9d6e93cdb87a800e475d79a604a88d20cd403100515d9946709a510f19b70b6883a6f0847b6f59c0359c35194647362d4427c0f8659c59effca7e1bf4488dd3402b226b15c04ee46242b31cdc24bfafe556cc7f381afe3238043e9101fd07acbe5d405b74102415d43cb0cb5b656799b461ee5a5900a8c4892e9d19adc70d6ff081bea4dd7014db267a8fdefcd174859e3df040bc6f1fde57ba364bc4eddd802891e9dd4e169d12b98237bc9ab223950b1d968c33ea6b83e5b70af03fbfd9a5db936bd4b053c3a2adaadeafab59ac151a8ac8886cc2dfc493c7d9bb60ff7ddd82250f553bfca5c805801b5bd319413678fa0d7628162f2cb336aec2d5e44a42ee716e97ed39641f7c0f79df952d78c030faed8dc496e920459099b6c06bd70579d81eb8a6081bb8ebc0281a7df745ba57402c141b689635d505b3ba9fa8a1f13b8bf1b3ad4566e24ae47b3448aea7c7402a50a5cac03dde2ef71dfa95a2c7e89890b4366c2aaba4c27a909ae6367960fe7287be21a1b04e0b65e0d7b258a1a2145c06c8595dc989fcc23e6f7a0c372f8a735e72983edbbd7f1361563094296266ac6c354fa78969a492056169dcf06ab7b3c6f49df7fa6710f4ce1f11379bf64da7bd41754f53f4c6dc00ed53f144558957022747acd5caf68c4c8f06f8be200d8276891f248ab48710478f11f0724dace78c5a2273337c7c79b855f2ce8520cfb7c5c0f6a09d9f207cc2781187d585a217ac8ed25b3226adda5e4bc9df350047dd1e43ff5af72463d52bd334882295653516a5a56464713c00c2f104374fed1b020f7f9ed66f642a29790894332250e27933f9ea6e2e3fbe215722311dadc9afc52b280de2ebdb89edd059745c534834fa94cb575ff3c3445a7d623037e1e7ba98c10a10cbca1304096916b90ef438683d0e75286b4e8dc44d9cc3449fb9c6beaae26f97983a36d7355ba21fd8c16719e59f0d6fe44132df2883b3304ac71dc03a7cb14bb98a5dd84a887973a4b9b9d7443d1c3f9347effc442add5aaa88a055891313922f844c0fc753866579b3c4412db9e51396355831588c255fc111d3f3a771d6dc683a7521b3a51d8960ed0edb293252319c5cd230e654830f2978e80abb57489773a233d71f6c4b01b04e27c5f091aa2245e3397a411844130929f6dd9d9b7e5c3a45d5ee2b91b978249fb3bdfe095f70a6941d0deed0e85f64f5a5effa669b3ce7ed22eaad207aabbfe66195020ffa66f0f28dc29df89f9528a9a5a388c64441fb90a1685d4970ad901cf1dfdccd907ffa5f15515d97b1e711c067fee7205ecccea859bf6f7942fd0c0306d834c16527897df7dea93ad4032e9413b2c5543960f9500df26c55625e87784ca4906d4b706928da6aaef824f29b58587076329cd505aebb23370efb4addb75016771e14d22921f37fb7b2198c16950338f1218022a97462ca72f3fb8ec972c89c7ceeb615fe99703d9eccf344a66c6a34223d078f5c60d65d58a9456c4e65bb33698943a2cded0d1f8deb2d1dbd33abe00f86803a9624ea0eb055d754f0ed69702a3caf728baa191ecfed798335618cbb18c5523d908a2a047b1d19d53a7bb498f575dedfd50c6d75f92ef3ce9202a641d08a016ade7372bc71c2507673fd3c975934746b4f4b151f4f62e9d6f91acac7c25c7510a8b7c0a3a4cc811da3da5a578a64bb980f8045544920e8c8f8283c280a91d8098aac400dc18b744d7cf228bbb2896649f64901c76833a423770337d72f4f75e942fd3e1ed26292a362c56c03584058a47ac28948383eb42f3d63b2e7d720496d6901ec049f53655cb894b525ab6b735eb1c13d108b48e6d375127be03af7031265e981f3a1b93912c82794bd879c857e058a84782335972810cee4f4c004384fa34bffb62352eb71bac3fae8e9b9c254c20dad26fa8172901398e301c768cfe1165f674d56b77d14edce29c007ca78f2530d1977c18187ae2d0ebbea7327146a23f6e002c0cde8b0493798eb13371481a37bde96cc35eafa0415125ce3612784d11fd78a4c757c315fb6ac791f5a53dcb76a8e8fdfe02cb0d19c0c07ef5ebaccd88c5a5c578136febb85ec1172e37afe23ea068328d7c5c02bfad4d51b9cbf7557e0b89e9cd6f618cc40d5df28f7b97b87f9201ffcd4e1e8d2c817f4c3ff306fd7bd3530c96b68fa8c38a87c2a61eb83abc2eb8036a7e6752f112e32ef7fc9ee43168cbf303cd2d470703eba7a91a375cd06d8e5a4c60da13e2ef6dc3fcec0e03fe9dacc19b4b1aa7a5523b2ab17241ffdf4628904e637e9c5dbc2624df654d4db5ac86cc85a42d8e83aa7a8270dd79975fb59c8207b9e5b460ef665e4c67585aa97d7fb7191cbd8f55f32d235a4446e2fc38567e3689ee12bae388681269cce351eabdb0d837e65f66a1b59687e67718cb967d5abc2fac2830ef305c7858246569a308f6d721146e313b782e62f1ef2b0f5e6ee4d59b0a4954df1658fe86fae81f04b8f49887d5e521f7cf3e60476aa50debcc9aad5e49fb297e69affcfce06e61dad22ba235197e1594f655b7432e3c680dee02c52252c63531c093a1ab3b2b08f0728a139e54528d8071912a756bb919e105771f292963b8246b491a437b1daca7a1c8c2430e0e386b1d70923d6283234c39029646df0b4694fcb6b61f1214ad99dc362d3f2480b98e0155c1b28f5c150cc98fd55bc7e97e3cbd44e3639e1747c5ed2abbb38d0ab609f65061243c7bf7e6434ab0a56f6f5cca4074fde13950c96596db637ce7977fb84a1ad1b508ebf3481418f50e5969c15dd165dbc59d2536f604a8476818cbb24a68afb596416aa96a5d5e71c76ea8bc6f4485973d2725f9d42c07fc9103a66e2ba765963df4ad0722253eed39d990e586d96afbbb59a0af25e579ae18c86310c4170bf899d8fbe5ecd03ae88b0ebc703e2b5fef0f79b5107841c19c58f8dee788c950596e145a105687da09327099e97c6d360a0aa117248ac3b1865bff76c307df0791b0f148d6cf979cc9b279898a59d25e9530128cd552d85d166448c679114eeb561a2800c604423070eb56781a715d468e05aeab2c368f56b99e285c07a261a8a643c1944bf2638cd802d638546e6fd955290c6d66ad2ab78ca763260bd125454d2971fbd6e826aaeee713820ec349c118ed45bf40762af9e2b1217b22cddf0da70777c51e71ec8b5d0b773338e29956854f23440dd1af7eb46a585e6d4ccbe2f674f497a69c36aba9795598a052d6115c21f4acb0682e98a07a9421e1207b4ea47e8123e08d1c620465127286be69aa35557d6bff3f276c5d616f91ad6042c7215a8e527722dc967210c843c838efc8225812ecd581701faf5b42be5091ceee7d58d9d2eec2687591e8252c3a61a7299f99990c567fa33530368e92edabc587a9f7cf6b58346e5f92cef7de202a75ad083b53c4978fab8d20abd92037f5d179a0f6d3dd744418af3f943afad080d263afb282cb2bbc7be202920c10b1f16f040a9ca0c96d841f1b5d15851828b959c72076a2d0e7488ab2361aeaee05e8a1efa011aad0ec563957f78345e32472a1ecc16586dd010c2cd59dd01bb2a93bbfc59220e4e846597c49dbe46ca5256b93b78fa46f5f77255f1c6e00ad15398ad1077447e6993cb9839dc9e51d9d9879f50959739e5d2be839a9ff8ee5d5bee1f465f004f9716dff4eb72dff0f2b95acf4fc879118bff9bb82fc50fc4432118599a9d188d8aae81e1c3715511520f72b7efa3b36cea7bea82201e015c6a077f3696095accfe6552e1170e72e7dfd8f9f7d329fffd1a8d11ac99ecf5b2895ca1f5cf63bd2a17833262b92c055f97d355858cd2fca124a29a380df2ec1a50c44cc99b6e1b6cdd08411669b8ca99660710dd19d553e82cb8b6f1556e097e5a47ec44bba0132fe230bb6ad2e77dca1ff5168a44c108910faace925451325c7654302b4c8fa56382f8facaf420cf162906da5c6a6d11475b4e9828d7b857ae0b134a1db8b7c75c852b587116c78770fec58c7d6e94400c82ce9fd464ab4821080ba66e6e481db00cc8f44504019a7412ff336867e9e3a4b8cf4298bbdda44f97502f2d26ee24c2f4fd098e73d2b08856a3594eb3447f2f41d11a474f9a89a82cfedfceb4e5816ef552a59bb565c915e4e84c5a41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
