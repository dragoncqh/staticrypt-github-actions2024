<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecc6672480190b717678ef4d2d7a2ba1ce8db19cd725b41ccb848d2effb30b7934a1a8bb0a9beba843dc6287b074eca87f6a17e47709e25c49fae5c46d76891d5d596cec2ec6f40dc827acc077bf18c33ee82f3d0d78bb3d3b56fb06664597c243192afaa880ce450d728bc24406bb97208fecf17f0a18d4fd3ca4c12920ce6d2a2d14545882ee848d8e57832b129ed66115987e8c56ce2e2c68cb6087bd46d7d81f7361f120dc8dc837b99668ce93377892311d04d8d82c73edaec6e2c7eb10b89ba531eeb73d2d84caaba124023a77e1614190f27369029668c69437906089b8788b2a79261977c091b314c2c6440c36dcd8813d0f97d0b9a5564dca1cca822f20ffeafa1d6eae1ba0d518c4180de68d2f32747fcee317c84fd78e6a87d4c31cb6ee9e049164abfdb4a24058da2e8ee3a3368a32fe3528e71f31d973ff2c5653c804b8fd4ee351b193be46d3ac2e115fc33b5f5034eebbc071ed388abf58027a1154e99752673cbdd231a2b3211b0129c930fcb087f379bacf9a2e7036922fb3b0faed156aadf6fd0309f22bdcd2ca0e521df28313b53c8cee2e30542cbe4b0e92a8f02c39faa73f65131146317bb3e15e6decef275e785748d1d644e5d743d0451e8b93531da41a2dd9abafc710311d6c710143e39b4fc9dfa424b48c3007809b4cf0bd3a12ffb7bb05cb553272b75b8935b6d91ded75b3a5e352c131cf7088e427874dfdf8f6f5542a057f845f40afcadb276414156016ccf91217854fb75191e59f349608614ed87f7c5c5a360ab788a85b9ba68f71502849d02278f4221c07d7aa2bff96bcaa4348fa10a228d53db3b3248472c617a5e08bdbcd4d966b9bae17181c5fe2feec3892ff4e46189921a9f5ae78beefdd6d54dbcdd40b64e10c93018d366c21039e2f008d86de249d13e333bf35ed84fd4dfa44536e95a329609f21b86e503122ab586ad0a0d4d63973cbb28cf3f6456e218b3a0ed1303e03f84a47cedf1e0f4ce6bde7559469d71c59d5da01c7e27b944170414a94d1e4cb057e68d8d6d2e6f2abaec5777b913f5b46f20f975ec4fcd2ebcd70e019a6d9aaed75a2a2b0115e553f7a3b2e1c18d9d7e61ccc435748d228fc6a6afce91c9c92afdacd09001683b876ebf70e325a1f6202dec1f8a4b14c04d1a310e1fb45ff4593f2cea97e9d1d15911c8028296ab07d5c8f219f7aee056a3da5fb0975b2130b3794360fd05f1786e582636a56f88ede6f279f6cb253c2a2a0c404d5389bd8c6ebb0cf97cec3f41477b0b2f54bf226ba0850efe54064eb50681ae98d91d7928d229413ea8da3fa1eb20deda29ed30cf45719e797264ebe86bcdc14d52f38846d40d47efd3ebe8947814422d8186a07c30fde6e10e5949fac667b8529b41a1c106752d02d2c4ff76b2338701c748b6482065ece5a6791afe8c16bd5dc864ae536b10b102d69a1a7240392873526552c47f3d5b7bb837a81be063c5c23950009c41ae7434258428f4940fb4594c1973e523327ef21a2d632ed4766e29271e2e9912e7833be161c609aaa6d4d831fed49ff9b2bfec56a026cea76169e4c1ae9352442b79e29afea378568e185ae0305ef46a86761cc68a06076d14affe0bd326bdf55182098ea79cac80c9519949b1f6866d73d32fa263eaaaee850f8448a8ff2057d2e2cabd21259b1420af35a2095be7fe80ce90724b27b7420128f399ddef56f8dd91bc1b689a7db3334558928c3d7d4d53f0858f2269c407811b1d39035225faaa1024be09b006d40ebbf737152fbe528a607f5478af57656e89872c3238479cd17337849dcf22763154affdba51da662b03c58d5082ad81f0477bd5fc7fcd03d9a22c82c3385bccefbdba65b1224ec3a5223042c340c39cffa91836003c0bff5f50c249b910d92a3e51c7fe52681ba5093eb9a3cee4200fb8b440a6bb4c2978805147825f8ad58a836eb84968134d5a36a2c3d92291f842880054dd68d36d23c98f069f73983a53f2ddd6a5f37f24d4a703c63d463dcd92b0cdda21215499ae034218987a2aafc0d5057732d2af4b17bd7bbcb66f664d7860e7a2b23ad7680d964a25b921bcb48cc0216f4cdd4cd0db34ebbe974d7e27c1768467896b410e9ece3f6e21a7530ea3e5684503be151fb342c57557e24ce38ecf454caf5a2262ecb467808c67c5260cdfd6735db5fa5378386a478beb8bd29f83223e2b2e575e2d18488df1a293c8e46c186acab233832472992cf614661dac54bbc56ed546afa789b387c3139a50a13a095d3d754519e7102c52677e631ed522ecb51fb4c9e8fdb0be10556d0c79aedbf776a4697a69ea50ab27070f14e1aadefb3567de668e7efce8028509eb160c18c109903f7801c599109e9b97f1145c2ed9f63c539beb1081a4c3c1eaa857164205edd3390bd728eaa82fafdee4480e109bd23f47146b281f2a09deb323fc93c4511035662311e877d3a771f41ba5db90bb9834cddc9bf3440c023bdb343941fbe089434a74fcea581430a82efaf5d6cefab11262e1dae9aab4ef350785b4f343c4f996efe1afd64372038228995f19e90e0dd7af8b8d3426d35c49f3363443533901508d0687a3cf8d7b443342be85d7959cc282994c10ed61bbf36e519e9a230bc5d58b10ceee4857fcc0fa2d2e1eefd4fb590572db635569f38b954913fe54a46fe302dc62c96117e4aa90f768e5c728720e79faa90bf82bb705abfda5a5fcfd5445b7eb6b72cc72ab40327e42c62a28647eb812b8ede16c34321a8f71861108e83c5ad34f68607410f660048cc452589e15afd3cd955969e904f92d458540e50e50d26494c4c3f04dfba4765da3e694e5453ea20ac4b5abd7d58e1bafe61cfc2caf69091754d753b5479e38ce31b44d35f9d144f81f8f18ad9a6a201043269c91ed2fbebe652501f766348568d157e3694272918fe429d4a99c3b312fbe08068f9e50c79824028088739a8d563cfaf5c55802d47826284b98706a7a345eab52f1c36073d2cccaa831329a5fb7f3f5ef24a0d7bcf244b481fbd637b1b35a631bf8fc1c8f386aa0eb12cf9550f45e1298cf6fb3f11a5225d1cb57a06a5fd6e08db053489caa52d23bf8a13b576b434dce88ff2d77854bad9a9afa4debae00cdd905870a7c604bc62cc8f8c9a31fb3eac9266fbf44e548a70499a02c4b29f60c0460549ee950ce7552e91da11b8761340b8c93dbee131c0c3639f84d88409e06bbae833049e436f65cca34b5392a83b99c63988ca9837012a07e96a971ba6fa55786bcd788192a77e7c373dab833dc35510099ddf395ea4c1d0bffdc4668287af5abb81e979b3f46861ed59c63d082172e3dc65c847b769cb2f1ace86ea67e46f3b7febc459c5a09602adf97b01766c4e6ec63b0fa3eea78c113596eff11742918557bbf9edee8a109072b36be8792255189dc0af044c939df235082fbb429ab2051f76822ecf19da6cbf60da7b843e60e63301e84d93a1218923d745fa1d5a144bb4b5fe1cbd74a20e3737fab3bd8954358d79de5668e1ae2ac10b0ed25c1ddaa21db503d941a86bba8c13eb2dfcb8ffa760f2f1fab738003c8c7523b9ee8aefc8237ad0b63559d8cdcb591b511ec210b7f6f3d9ffc7706eb79bec14d7de2112f33df7b6cea7eec13853b9174793966c54085cd6449b33e1ab80bb41beef7f864933932148b066a078ac07a691cde85fc3c6820aca53f8b0b32fb9cf3952053f85143d52dd35049f947fe167212be9d762e8df771a6bd0e1c8ea86f13de371b3c6baee02365143af581c4d77301b5d253fa7ad978487250ed831ddd0fd9d1a307286a06966eee25a5a8bfd964cbf4098e5a66558fba3f907e6ab02e5790948aa00440bd165fa7a1a2de33898ddf1c0139f761d2ded301c0f8efa84668873801dbe4ce8638e63a53e71e8ea5330b6d6a3556baefc43400a1b8e0a20e1cd1a1aece5ec00984b7e309d63eae381e496ecd072ea248490c4855e34dc5d3d788bf44963b83c279dc7e883388c555dae78a0af9e1f97201a37485a4a67819949219952edfb24fa8ee41e1f664dbffc4f2503cf3623b69ec348ff5f365aa1a28e0abe41efe6c8084e434ce4e18596cbfe4995001891c2bb547740d21aa45a7bbd6ec683335c2a2e5d19d2a0454ce5aa9e9ab66f19a13c6357929cc27cfd8a7ed88db545bbed5bc22087602977accff88c07db9b0aae3852568da864d0a4678b92f05df84545b8a8a65c38cc30b04f4cd14ccdc5d412f157019231841b7c1431e8af72fa27ef8c1b8ac8a168b5e778e1e15407c2aa1904c6a187350745b6d699259d9df2a57beb1b089d30b17ad79e4162a625e8c836892b313f9dc9d6a57e00bda1ef9be265a9426aaa0bc6f23e51deb07b891125fc556d746f355d383d87766645c3f35ae67dac5e2bdeede7b9ef5c568a453d78c54dd0ff4fe715a3963687e05084c5cd261acc2d6960ba1c4ba342c78c307fa2c9edd3f5fa77aa06d2b2b216d647fcb1291756dc2678b0e059feba56349356ada0bd559f2466bfd94aff22e5d973e943c41389b7f8f4f0ab1db7e93d65ce777c81d90a60a0d937bc8904c3a38cbc679142676a26f39b1808f60f0f58927ff7944c3dedc09c3797e4fb0b9ccc1c7750e746b8a3a76791b6da3d24f48a1201513725a8484df9d7eef3df56d495b9e16106a74990fff595ef5549a9563e54cb7ff0f96d9efa2aac3797056a3fd1986fd618b5f0f536afdf0a5cd74bcfab688fdc39b29206f639045c4316e612579b2fcf0cb57dfc66dba58ea28211f85fcd3432789e9adfd7bcdaf1c6d51a8564b6e9c38e8f6dea5c63bff5f3104203ce2e65bc2b9e6cdd18caecb749ed3f0d6b71d0ec82b981ba119233af8eed871940ce5e695c17ccbaa7709b1e9e7776dcfa7e541ec2eec29ef232a76584c04e79519c46085ac8ada1437810ed42ff2d7c36abb53d7d50e74f2412492c458c90d2f7cba18f3431ebb5a904e87ec63b9d06aa4ba7604596d20166bbb3546119e07338189b3706ec9cee7e543bf8e8e1c395e3766fb122ebe59fdb7a84cdec94c430278ddbe25c866559ebbeef4661e476585625d1f913c583ab54e58464e1a56876a88ca176a6beac0f0122b805a7cd2747b1c82554845446ddd878cd26be0df6166af3d588cf99b4b756471289854b9330c739922c0f47758b693bc5dee4c6683f43a3508e352c29126efe173d3e689540bf7ed56a3673cc2db591e90098a47d26a3fcbd615eb84946509846599eb533e6c974a3c5eb59a70f01c477769408ceb17ad423412b05902247b0cee73b9b64a91fa1b6b7c22f36e37e79505ff4ddf5984795797d886c5e4b980d1819c06363beab6e7fb1c5fa646286a7329b42689501afc3e37a0db210437846ade3b906516971d2b0badb38d8d2b8b1b3cdddc59eb6f361429e04cf550d1bf09705078542d32ee3892cd832d534bf2b532c5e6b645220f49dd15b7c23ddc6f5f1d542c24191160a07670b29eb80b3ce8b95311920412dc02d6807c1559ffd8862c4c0b174f0157a36db11384bfa3bdcadc7a0e3da1186da06bc44502ae9bcd48dd3b6ad242c31353b209bad656934924a4cbf632d06c00b87641dfb5deca7ae9438e9b428b93ed6ca970dfd0ee22498e795eda7844954e93b4badda5e750f92a67a380c9e05b171e7a45af81656a52965a6b69c5fdd1b1ff02cc73fcc95f4b82e8ce71f07bd91380ad9efd26bcdd951e04d4f1eb778998feb60dabb2eb70da0684dd2d19de1746ca0c1531e3e657b88510d7a10fcff53294db1c043167768220dedf783c80b8b98cc40a3821a6eaff92d61016c26430b62fb042249375dfa93d79f9a5955424b3dc6e130012ae913750e9b8bbbcb1d174580babdf743be65b00882d69cdd7b456ec4e3ecc539b776b66e2de04a22917050cb44a89fab6551d9657d3d5e12a71733bd50d9e63f0ffc0ab8faad44418a1b31996ccb9be9140c6f5afd1d368ae1c86c4294a9a210b2fb27e1a9df850fa4ab5ccd11706d5635927eb6179b16a9143b2218e1b1dd700be036e38d723c29aeb9cdb36e04c18a66350b5b5931ee8483848a6b5d088fe7dd6cbacc46b68498d034660da88ea0471d515d985405c042663da498134925cb6ebda8590b6fc79464bd96fa22ee67f9359f8940c6ca3a14c9bede97567c77e90886a579eba54aee60589f3b859de0f8dacf25d7e29d1bab12387c3467fcc207b06585070df090e77cc1b65b9de6ed9e8e8a4e68ca8e201393da0de22b3ad5cc332f96881aaa9ff7af055ed3f2db72885ee9c366b37de89facbc2eda20cfb16b5356535bc216493e4405f8100633ba5a456cc98569e38d3a2cfb14cdc8ce2a7dc17f5b2271c5ce8702dc2e675cddb9937bb70b4ee45bca4a0653cc2b22c4dd86059c5e9df7f37652655495a8dafe8bc83e408d3be7e614ca2442d860276f979eb5fbf7ce5f6f9ce456203b3f9f2a0af9ea37cab81e15e85d81fac29ffb6dc3645ef13300fe210d257824d3e160208acc50585af0acdcb632090dfb15efed50c7564feb8966817d00d5fafffeccf1892aa62122386613f27e16d98f207042dd1fa32c477760f908d435a981905d10d28dc96a029a3c462b2b564877511050b67090ac53d3a07e5a9b205a2aeffc3658423de028256cdbb5ca610a78193b7cde720b02d1b7908046c83ffe91fb07853b02e567fef62d3647bbacb639ed1c9a3ce48a69a1767f3bbf7a0dcbfe1eb7affcd5bf965c48ab708af1b5e16f7fa474406580c9cd3b9b28a259cb3e3ee67b30c98f4b975da8aef322f84696c473244c3e50b806417b4ab74deec0ff06ac871a4a521fc320954b6d409cdfa83e6e2471afae56fc6a745f2bbf187c1eafaad4582c224ee009ffade50abda4dcc9419aa9a8b76d502312fc9b79095c6c38c194253fc3939985157a596c878d18f92e3ebe1a61ea3a9ee916afe8613e1a916fc932a9cb9ca53a9640ef8e26ff6a073495a82dc818be191a2c2a734f6884c39b252bc57b0855fcb3daf9a59f3f8ad6fc0cb9212e6afaf3ea21aa4ce7bc25d152e9123c908d5e4f0431c85187a9c05dc51d93f99e7c9bd677e3ad5bc238a06a6273f21960e80d8ceb20c96ae298777fed730856a54fafd9d13790ac57097b9fddd727033628a2af945f671c782b733bf77ccd3c97a44f61b0ea55898aaf86711963edade232553633818e9cca67b5a5a0b12a3b31ac97da217a62763bd3084610332777f5d15af7c60df029b5acb68db705cb1feabc37d53c1fa55cca83b8a020854801a800c43853d9084781f6efcf0679c144198f1833a486b02a9cff77805f6a4cdad024abc46e1defecd08c4ebc5ca57e9ea05f6f51e5bfacc5ce2411eed8d3600b1d0e01597b545b58931e5ccfa17ce7879c2c11d648ab33e4378b3120d94d28b909b517a9cefbec626e824d8db0ab9bb0f9b45eabd46b5cc06ae96de110cc0c947929ea1414edbdfda3f563f78ef89aa6c60e8ae28be704d2bd8d35b634ba6bb140606b70a00c1252b54ca669d1077b904ffcbf0a82c22faf9874175efe1cff6f8c46080a6c7e5012ac276eb1aeef969fa2e146f6a804c74a7e593863dcd423baccca395d17d2ba84a4d0af04df4d9773ec1e5fd68f0c29c679c04ff1e48192dc8c7bf7ca4abbbef8f109c6a7b1b83264f8a838f47ea5760350ab309061ec66cceedbbe574473aec2c22789a89dbaae5ff137a2c00a964feeb855730c90aa04401c247eae1752ed4c233a2a8fe8c355003179b60ea91dfa65f08d1bb1925ae3e89308e08604f9212ac141175b6aa683ed8528c54ad45fa6d82d61e9d4441f9c1b181ceb3fd7128a086295a4682200fd9a49789a3ff58bab4784a8acb719734891d0f22d22a548dbce67acb278f52fd39c3bba3dcfcc2f159920e15925fd332afd9b7c021305176f0b8403aa52c9d03a2c7e6c5632edfa9acee465c1cb679d685dd873ca416b00f1340da1dcb7c64e3df5763df2a3d727de2c6a8dcc47cba9e9fae81a03fc295f0c298d50784318a3fac8620cd9425720f2603ca562211ffda2a6820c19833487f69f4395547d2fb6f763841e3a782d0818c6f34f7b35d2ffdf433aee19f4324d5576dd4e8fc9797a03f05770b0fb920bb9f54b1158a524a1c35442264e1f1a5e26c30b6425efb607655b798571363abb7f855835c926adaac9829674622860bd5fc6c416f4c778104d2ec533e814dc021e6f840c3983db1642bdfbee7a63033d3cc8a38645acec2ba29534db01d2c2eee268c5f6b85ddeda5e88ab5036b34281cff03ce508bafdc82d8742cd5deca11efa8c59975d62ccd5ce05084b66135117a5cc65dca5337e66611701996da23652a9bed4a9d139a727dea6fa454909e5d459a7f82c01114d73e784b26278af4a44b35a114aa5cb660b2966940e53e9f81afeecb7afff0e587ea39bb6918a9ad9b64589bc986a2d5d62b17a26773691eee2076144f11512680476ddea10328094359203cc3777e0865352bdc2409a2e36b11e8adee6ad28b9e9deefcfa9f79e851bb0ddbf3b5dcb3c922a3092194fc6cd56b7bf01928de061569aedc076325f13479ee9e52310f5bd91c6fe0bc0e466ebbec333949a12c0bfed1f71fbf0e99df1b3f86e8500a10dd67a2a56a7302e1651a85b0a038e5c002aa4d130c78443cbe5c6b25165f0c968b85bc774aaaa6a4eeb16e3941430d89b4e4d34411f77febaaffe324e8e98c746a02951a4f10b1c7d957a8295cba1e67a5bdaaffb6ae1cb6679209e7e8784577461c8858a7bf10f73dd96d586ea4b8cf7a6f7e6f8396cf5f816bc862a5eedbf01282d0452450b3f366331a5a66b420173470087177b717d77b4e7194b2cf459af20b1f0fec0d0bc987ee873ac0a12840f205d4747b9f8b93843c789995177661a8124184388f20e60d1cc5a077ee31888084e40625645132e24783b85ac7650c268a94743bf580a96c4edc1bbd3a26ad64ad20aaace93313bed8cb1d6a1a947cd19c5bc23b5c131eb190e31fbb9c77562c11903a6146bfa76be444f7796f27eb7c6821546a600f3b0910440cbd2d3ee40d69aacb411a3fe8c7b92ea270533ee09cfb0c6374e3fe94007b236122b3a73b387dfe5b2068dfe629bf5b47aaf5427632f60d2d224e1f48b86806b37ea47ca6704511039c6f06090c138363345bc27120d269f462bcb6385f4684f47f7b017d6cd2eb38c25a052b6ff9e4990de6dd64bf4ce7200dc25837c6614ef7a128c9fd55ab47ff99c9f1f37cb2d7272b2886851690f0e453cace1f5b4e70f1c18060a76e0af196c25772c9b3758b5c8c86f7263fd38d5c9ee4e2d7259a42c397842a982112b5e65889a6447650597a818b9a045d68cdd161f97c2981e4a24acd1f902045178b1d1c70d071718b5fb51ea4efa705aa56a1aa809891af3d2c0f3cf566b92ba2cadf4e4f34ef50b2eb381cada761dc73b492034f2cbd6b9ca8495f78697f033bdefdcf8340f5f7861f3359716e9febc33517dda914470476c85cc2ee0e8e23e7654e68cb914bc42bda54b724506af19274a3914f79b23efdbbca9440bc20142795cdab7e51d08ba3fda25c0f36893216aab4786583c9a1cc489d641e7c3124f4dbd710866b43feb2513743aeff09664542869de96ae2585b820f66e022623180a2796ab5fd7603af6cf3494d8d7164183960efee8bdae3d1110d2a6e62c7d4a73d54abaa11619665bc58e91d2ef1a92a41c64f85d86aa047c75246a7914ef8ff788141343760ee672bfcc557515b662c42e9c75cfdaed64e62dcec31f5d1de5cd72988a8d12069314f0d52ad4995da2e0ddfaf5ebe636b8c9d5f4eceb82aa0c5e95114acd01f45a963dc9d002678fe753a0fdaab49a79961090a6887f84e686e7d2b06e9e2304df0732f7c2ea21626f2351d2f22743b700e5dd33f14fa9697e1358b7ab43df282ac9872ed333e96a1b47695c6f76977d53b5347ad3f893ceec5c2fdf1d8208f6ee857a587cde5df776050910869c6a09acbc98d20071761f6b7fb9ec286b0f80bc1346ef56b060ba43cb8a57d6fa87026928ea5c4ea537be83e56ce027f67cb58c846ac12a48b1d07149ae443ccbbb1df8bed0724c470c06274fae7d132b3b63bd255dcb66c60253cef9f1cdd0ccff36e1f5cf611e318503be8d7f5af4823f07b488770ca48e481522fc8d1f5c4f8e02506c2d3edcbfe5b0a4e5020c34e14d8a2705b3ea1d68efbe48b464d134046f7210e85ae674cf271a46e42836c6676c2a615008fceab0f29e0a9ec3b798457a0388b4a3aa6c1c2f5b724ab0e638a0bad017cfd856d0202953fc7e5da487e37e2e73951490a6153f4c0d7043f9f71ca619e38bcbc375680c1f9eb1bac993b476416db7d38a947159e40b9ae98cc2aa58ed05e95a193771beda089a90b1fc8169b366f85410ecdcdafeea4aaaee9a22e0e15fa48542c653a566e15d1c6b4fa712038fedd073e3a73f6407ccf765bd9bdc68478861720c2c1dd2f40bac87ef588633b991dd93be39962e8e89c8ffcd57528d86ece2f1fb81d8bdf1d3b0a96823afd1fbdeeab9854701edfeb5ef1a22d685d78dd5613e2ea8957d16a29ab53dd8c0b3e113271433accced4fbf05980d236bfd6ed050701951789b51d54677046756326d344fc3714fb0d1cf36efffb55206b8c72b2b76d604aec234085367a019d255e7f1c9ffb95a38806ebb7a39ea18a984c22ec86d471ba34bbff79a5c60905a9b6fa1b79a8037194ffd52e168df2931ad0673b743e3537342ca1be0cc90b4a9ace9a57091bc980d0973f06497d23db89ba9bbaae6a38312213b9c673109a2c44cf3c8dbd10acf766d1cf27c7ac1aa4f194a13a44a843ab1fe579dcb3ceaa5dfa0364782b93966c820bac9ff47166aac0026dabb1cbe6f24c8cda2f12be460b2c952b11cb0c184105091dd491185e33ef1b842dde0f84776e37a85277c7d7c913a889f88cc98f94c89b1a27900970da5dc2972b39b8d16e84d29359364bb4e4b7f4322b37e7237bd2eb2fec78e8aa83ca1efa2946f66711a043e4c6624f0004d1fc912a34de54f08f9f6ba05788d6d921c5ff54959f2f7947ed6337d47f0ed195812a50f3acf07d84bf6cf9e2d5a74101c0cdc19be66882d955837dec29cb2c0f5d9f4834898cfa476d38a7e350d5f3dc2a9288c7ff357d70753ad39c986cf37e879ea51d37a0c5b6c47f4ab410c495b110bd589df5465065fe1b66f1bc744542af6189b15f8c2edcbfe24a23932f64b5b02e3ae6395165c1e18196d5df063db65516a1241724063126616b1ee04262a5d71fe79656a11ec20350df088efca69cfc18492b65a7ad066589ac091acf8678d2bd1d46c34e7214bfeeaed006622abd7b05d3d4605ee737f37dd82c7ec89198ae8b9fe288e35971efd13884295d934a629904948de19f07046dc3649e06f375bb35dac3c017d1bac2ccded6687983d65735d9ec0540d3f1ea540eef27951e434d349ccf7617e123da937b97f4b6f36829ac7c947a16ab56fceb0608285be44030579033041cd1a5cccad674466002e88b817b4943231b5d6280125f58a9006068e9492b74f0625ae2afad4efc29149f1ccacea06039cb6307f09aa195f804bae1b09b425561dde4285631fe8ec5d77ff6518a7f8f4611cb983723597c6ba41a02ed2eab9e65eafb193265c4de24a64ac4e7ecdc2c53554912b12b03e04f4e6c57de12baaf46c7ce62c54c03ec80074336eea75507f41e4484154e50fab44c598aca2ffd73cf3d636540348e450dc883fa558c79bb02c54f5afb023dbddf75281484170e6fd461e6e468090b70ec9c996d73a236df55fc57631b964c51efac9a485b56b56d39e04d39b4ff63109339a0895a1c7caa4c9d118cd038e9fa45f27c6eca61c2d7cfcc74be3839f99997c6b49a70da165f23a5aa09fa5f39a8989e89d07bc03e8087a77e30c5a12bb2d03338bac885026f5b5295224af3533d15df2da0349c9a4b4430ffefaacd923511cf3d6e208a37e85639b711c84333350188fb02e18ff17075556f89d3b0bf37e3ed6ab2bbb944f1d48d755379b01fc3b01d616f62f12cedc7dc752bb03c24b7f389d71b7f1566ae7c3ba1d0b2070f72db8dec5c58573ec732a283a7a6d265a1ca6930bb31c04117d28edd6f2744ca2fb17fd451101b17e57f6e4e640d873316b2482c02f4ea36d2122f43d0a303f0b5a5355403d022e91022384016e7c333ac7a8d14f3f4cd8396dcbaf2c4538e6dd55604f2bacc9e468acf90d1df90a459a977e38af8d4b238661860b5a6615f2d80ad275ad24343abd63f1d81cbddc6174e5c713704bbe2e6a2b07831d838e8f8833dce9762bed6caca0273a3d6fe5ad2ea4329b84b4500fdb2225457f940fffabdea14e914d373bd7a1a9d13eda534649efca523196ca03e763609cd694afc5633f856a540ab00232261d664305775a6a8dcc94ce1920f81099f07f6b04ac3f374f64902be001b6d8dfc9f9b2b1296c526265dc6041e36858ac8e01ef4d31ff36ca5ed315de3708f2a22a43eaa0956fddfaa1661323075646a16c1feb7e03188ad05c4902c96257d762f1a591c2e7e186eb87376a53604f474e40a1547dacbaf01c6ac3c648e8a179ceacf31bcc9e7342301284c87be0cf053c72d26ec6ed96e5b66c9eeb35a0e96b7c19be76a71fb157728256bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
