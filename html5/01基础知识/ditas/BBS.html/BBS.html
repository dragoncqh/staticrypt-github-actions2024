<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd582ca01cd4a4c6ff651fd41c11f8427069f524efbe920e9ea43cad86843965ecbfbe296e66f37587d92812bbc37f3a5041f6e66e8dd792f1197472b31bc8adffa43b4f30ab0b1a89bf3c130e96261387b8b0104c0a88639e1e31cadc2112b56fde66f3ebd7b51b63ed68b120238a462dd6873e3e79f40b384eed5f1eb3a2709238ec2e378405992842899bdaadfc5c9df460f13eab8e39ab978e986d58bc4ac8e02bcbbf8d014981ba42b403389c3797171078ccb9fe5276b45f435581f4cc19f0c35dea15a634ccba7139216e9e4adda232ea611a9d88f1405f7d75d0d97352efbbda94f8928e642086a5166e3756061aaabdc22109a242101bf2208b03138b647d008798611456ddf2e8c857f7406ded268846c20c89de6f4d80b8afc332ae2c13e84a8c317d2024b4c6212b6cf203b16f04aa9a5c22112467e9d74985fe7dfadc19c3085a577665249bc943ce8675339bc2e33972c1fdcdaff203228c1b6bc4d1266d68e976c2e89d14914383b3892ab60e9348399e1b11eb45911760e22f5b371c66f61ea8e3abbad6a74c73cc29839fc70779b221a7b6bc8576932505b28a5af7779222289b45e9a7367be11f0c0d04d130b88abe5ab079479e21f1d51d7f5e50ca31970a957ca7cb164a0b4c7ee497b3abf74b09fbcb95793c506b82013fc2f81bde8ba0946d7656add934a76fbb4ef106d765cc9a264a181ca9d93c16c483b8a6d533f6869eb2b1667212b85bc74f39fa32977681272b04868250e1f8266aff8bc08aee7b6730b092fa4f84525dcca25113f24f62790ae804ad1c770c8a4b5996419e643e10f2800c8b08eecd707a36862e467d4e001fb5cfe6c5f29bea63e71a6abb36ea203f0b59fa6fe979f1f3aee693ea6105226aa2aa0b03737495f286cf6f5e6e8e72aa136a126be87decff39f4073aa082530d0d2b4af73e913dd89701c07ab33393db16d7ccdf298799c8ad5fbfab02e3d63a90c634c5194af8e8de73a892a247b3fd77172f2f2b8d247408e9c525d3a856c80f8be7f2e571f831f8ccc8d10d312ecad37aac01541c0172231db8b63098be4ae2a78d6aabc6f78d84b94f0fae3eb229748a6cbf5d6cbdad9b521280b4e056d3e4f546feb06c77d92bd40b4edecda4354c30ef5c78625048264eb3390a8f1fda4088a3ca225a2e64d4ebdd9871695445beb44e79cae2a4e2f08bbbdbb05103c8aa8dc56d61870678d8f4c46729d16bd2b398248c617fcf7ccd91665dbea8caa8f234a1712aa3299208d10d48f3ad8d600cd2b8443aa740d2e25a36adb9e851746b41cb804c3b0a9e8f8592541614a96816984219c62f86141fc8803e3127e32ce22296881c792711d2a075f5066e540f0f05af307df15c8c09045e3e7ab33995863e26a99840e1642dc5631e0034ea1951f7afef2f0033bc1747b3dd31621b3bd78c6b7304cbd1d1a2470f36a9577d734c47688e38faa648414d521efc801d9067730507e2c58242ea7dbb937adc1cd52de49627c0a6d079a43a65d683f9ce89c55c80eb47f737bebfcc6cbfd29d3ece425d8b27dc8663bfd5f8708e8d892531e709d200301f2c65e034ea37b2ef8175b3333f68d7e9ca0cb37fd672fab7c0ffeb826443ade66edf1adcc651edbb49858be0cb678416f415da4c4bda3f64c75790391ca23a6bbc0d39323bf417413dcdb7b3b1032c6029c787cab0e843fe0fa2e200b8c22671f67afc15e6b8450ef795c50d525761954d73fa522bb35cb6a585313f95a9004218e752cbce0f80f0f41c17fcbaeb4717b0098bb27de83f28d6fc2ccfe4f384fdd4e123b0acd79d03fdbe8f7d19d68f5ddf2ace2c3403104388cb67757a1122b8b21d1c7e35e91b41ca0d7154539565d7bec06adb6eec669d28630bf41a4e396a75e20493ce4f8ed2c918a3431d52a54ce7c89d75665a226c47b42ade50ed9b668b40ef6444b36e6638d357660e4fb81d3b34d50930650434b81e6e9a10fc6e4bd4d674079e0fc353c86c62db07a6e63b61a1e846dfe390fa85cdcecbeaccb1b04f12d54b51d6452b81c74f4e3602eafdb4364d8de335b3f8355b51fd8a2dd88a0f77b02e1f6d3957aae972e726ea6acbeb801d8a9ff10ecf56bc69d2630b948de88988d37e767ed56830ec62f2804a3b6e2983a8623360a0636fb7a3820d2f4b081d56113113e8bfda30eb696647f605442a9a4458a32271eb816a880518bfa4389b413e3a25f7986606ab87cabc813968ccb48fe4df506730cc7136975dc67ac332eb1dd5624ad6f5a96fc29a3e0c903ca941c638e79c421616ec55e5929ac71f10be588f98a71edf1835dbf60d059ffaf7085dd430fcdc31a6fcc1198550412653a1ec440f4e2c709b8a4c1d863bc4a50de84a473bbf7ab3b5ff128eaa04d04f3d12446db9a27f0425ac67bad9e0658ffe0f10ac9dffcb4f03a3535fe2d1a32f61e5d01b1dcca5a74126715d18714039a296fda5c7a298ac6703b2ba6117cd21cfd50256288c9afa59ab76936c3c0e83532fe6b02500312ffed360c173fd0bdf746a900032dd7ccc187f8dcaa5a077f53729744c35467aba6ca4337995af5604aed6d0870062a7555966bb21f633680b38388b70b529ec6196d17229d6a6530efec1c357de36d38cde28fddf9a7349ce9df0f4e7e612f24a96f1ab5a52f6df1c238615f8a228886bbab86e04614231585ced52dc62f4869a714ff97b6081db69429774a0defd2774e9324ba6778a4e894139f2f96ae7b1573fb3d5edc16d874dcf5ea537f929e94107548d523c04b03d9cd54bb1c2f6598fc55f0591d1f32601b09b59f91b80722532e1b0a3255fa8e8620f14f75bea3f4cd02ae4c4a8253621be4f11c0a0d705af7a951eca391245c85d64bee20ecd4bc5408074a7232e7d4b036f2de071e9c69611051a3797bd87931e312f485c56894e96617f1e89a273eddaa1db8bffdf80e82e5765d3925d4facf88ac0498b50714815378eff48b23985778274158fc104b0aa2793912e5c2f0f479648a123b9e1d6da183799426ea6f9a962f904c973606f0606f0c5e3c5bb56701cb3e6dbf9add0dbf456a2884297b6c1984b1fddabe2ddaf4a84483b197e2b4e255896ef50576bfade25895af593ad542ead838ffab2ac17d87ab02774908291d801aff9c3081d1faba319d5d18f8e48d5c01de46b6afacb6fe59c8b908fc4a08fab1ae9cac5caeb73b9ddaf5dadc33298ef899c14c4718feb0ce81d706f5f0c630ff36b3f141220f149a1d4f465181640e2c30b6da42d957ed337c66f13d5cb8e3a846a7fb76c4a754ff124101162f2596c30f0a703f4708b2f626cabf8ccb8909f627a7ae288234353c59449089baaecfe125a8a87b73a1cf4ff01df086216219ad05e2e028a998e1007a5e1260853ff04a2ba3baca0329325187bde72cca401348dfdbcd6c18769e340f65dca7e698f8ae7c55de749c221b381ba402d006dae717375bc4dbba6ad9220e2c8a28adb967510e037f154a8e5f83b17b6c5e8a00c99844247b9caf5b13d49a70fb3fd61e7f9be256f9aa147a4d5f0b47618b72a9e51236ed7fc509743168cbb60f5615021b26ddaa7d15630563447b779d923f363f9cb5ac61f8fc6794973916fcc691383d83eddbac4a4e208cda025378295c69585a606b94695ade48456d1c1b4a5bf46a98f2e476009a1845bed9725e44ca355d491b4f5ee48e0f6e5c6bc93187861a9f03a6fd09912b7d88482b1c5cccd8728fd4df74f706e45029386ea94c8000bb1d23096eeb2f0c0a086d48ceb83cc58627badb865b691f1f725ac74ab1fa540d364bbe5503f82e8a232d160e5c2bc887dbe6bf18e6a714c49a877b3d7c26d8f20340a116ea904c27682ff173930c3a56a31c3710cbce30628127979bcd60256f359250c3df177e8fad16b91b0b60909bba0badd83c4ede4102e6133a40330a5c30448bfcfecbe7b7b563da8ae1a5496b7aad0b8a8b7870f844a70d6fa66857fb80e45ac4e299f05fe54b0c365a9878509bf2f66d53059f38557cff23f7ab6f0ecdfbdad4e542fe8869e4acf1d4d3ea212634c451144f4037b4e473b953c5ac4e65e7da71bbc93b00fcf516aa9029a628177f56ba0ff9a84a2973c4622c440d20d79f21c3354931d4ebf7bfbf72e80553c31179e80ce244f91a0860148edbf264581a55ab0cd30b89a45a9bd8661b413703ea230619fca933ed015d080f549504da7e78622590964d7815f31d90e3ed4f8ff761e7d0fe1cb23460a6248940272bb690d6b5546e7cf64519cb5b9c1ef175a3021e0a5f6a3319160df106709d3edf2d8789782a640b39f19d03a52b005ffe8130918e1ba8455e107b840d7fd21961869ced1c3490a1781769d96c5c517d77fad7127ace1fecee7d5497095ffcba719d1f90f4c547eade8f85a19e0816d9e53c10739f9728717be3b370067c00189c10a2606d9268776e690aacf7f3f034ed046539e2bcd0285a1b82f38a212f1134be0c58bdf232bbbe02c6385af0258df8c6d2266a4d7f1548cb2201a9193341b68180dcd10e4e9de3c079a4c63de971b3760cd2692d7aff751f0020892cb3158f22ba089d932e037c0bb9a094750b118975a4617a18f7ef2a8685e025a9444b362c11aa16a002cf0721e2f479c348590adb057296eb59c5fb11857f42c7f29ecaf4f29c68ada0af517657272391463fd2d45e96ece776e8052a6e5e6c16d47378920494d457ba39883de61512033d897cc27c8eb640f2952115c3b54ee6e8ed499f38d0fe61a4bd03eaf391cb857cd3116a1f1a7fc594c638579cb683ee83f88895ea04caa5af74115c5544f7ff14cc0ea5e5375b97206a0bdaffd6c35064bfe6fc1d49b03da867df13c1283c28e55a270d40d1c120fabf9f17c996b5df7d8646933b44bdbbf953b4e90bd12cd0e501aeeb590d5a7de32c095a684ae8f0fe1babcb4cd04a86fa26750f049036f560841f9175eb5569cca478df60e21ad401b4f41a48a251bc80e776da4407671fbae4bd0d9a6171a4eb27100928bce1c6ead2242ff6d4994dbbacf91f552e051584207940a0024a1b6e6fef42ca08400970f533c9f1dfd586ee4f7ab79cf9d56be430c6db00d162f7d06df783ba11b5487e5eb50bdc62ca8bc229bdca62bd66232c57339e7338fc367e75faf55e2efa8c4181e56a1f205ecb49d8d68935d6a497c658b9fa4229906666ef7c712f67a076f07d5316c134cfc9e3b48845705dc328300ec2f44fc16dcf09baa4b479280d5b713ee91ae7e464410717c788ea84324f6cefe7e4f9115218e2825a88210137f5d9a5a27a58036be6d78fec13bcd46b9b9992c5878384cfc086551d714929da5c2ea8bda5264c7790f68771b613bfbef886bf4c5ca7a561aafeed177bb198587a56e0a456bcce92a954f94858c798502785c54f9c5a7a1381d1d92802a0c9a6c75904b38f09210191916afbf58d1dc5beb04c2919ffd9171bead8d63da6a530709b7a32e16f79d328bbc7dc41abd67efc8cc057ab5eded0c4e35e5ee117d4cc36abbd73ffab1a6eeced8e8cd96081ab5727f843006acbbc9b677767b21b19f2bb55092961c7ce37281141661c432ea1041e51805a5143109b180d112149bf918873b1cfd63586959303732e9470e1e5c5df877ced6596cf73286d24e85e18643da553957646f03ce51bf9819aed0edb892ec5ef6284473dba3fcc71c891fc8a00c92de6519e5e74a69200610b1ee1b982725cad5c6d252f106399e8e7fff7999a27c9fbdf41fc6f1f0ee698a103b31aa7d59a9fda0ebc7a6eeb0a6088a7a36c4920d2f05347c742a4b7a3bc8aa33f36c09e2e1c0815f1f1ad558b4643202a98fd66628b390d994bcce7cd7e1e2c84a15603f49f9de5c4342732041cf0643558b1559247d346034a30db8df0b3b7335f105991eb2a4a2ba41d47953e52bc0f28738a9fc3cbd99f26921e1577233b9a9ce3781b2702ac68cf5cd0461026410eb5c5535b837c6ada38e740fe9045160f6b6ee387875b278b8a255c4f21d33fbc17ec25f515c290c62966a70e99fa5311b299ecc4ab2372b517a0d161af87d03b51a56493c21e790a2b2fa6770b15af15a116e7661f942c3641aa2329081041078aa08a76b8b36e20e4dc48919280a6fb932597193d1301244b6a7840caf75b744610b1260b378483ccb74e9c3a3112076d1b1b1a93bc494fb00bf6ec0baf4a25fc6321f6d742d4be3e5699acd1e12393c53b307ed6d07141d9a6c71191e369f8770f42d66db61fa062449f646faf74679ca74f301ad779ce9b5760b4131fffcc89f8ff45908cea1639c958eec0aff7b503334316e58e0b0b80b76c5dfd4e02ef100ac87aba991314cc1cbd5c2db10b14a0032e1b385e231957f0e19d6be4e61b46ad842c9a4a69812aaac9ba8b968f0602fd0518046209f58f262199ac0d4197bcba57f25370c2b0af3b0d64fc6320405b54be8356797fc002f8c8a4a0093a4c9fb5c8c10b619e437a89e99d591b6928b172c59ffa4c0879a918bb4a69c67113d54c147ae45d8d1d706511f9363401869fad91eceaf02ac36f2dbb755a8f930a88d65943198fb7ab22a93e78a7c2e8afdf591b149a7e53f77c5d8f5f0c758d637818d02335ea35f9f147c4218c4d270546a03fb3d7ec03d7dca8df834ede90794ace20f8283a3b194eed7d0f65bb6d3a72037e301f0b33f461ef1339a82d2abb631c3c197e0b58fb75b89cc4faf8485285e0a9951dda18631bf4466cf584404ab7136371180adea3248a317d30f033e2ba01125879575b68aa792425b46aab99cc45f95194f0d56a7f6ba1cc94999dc3b0972de3b6c6bf1d12552b0cad5cad69029f0bce17c8e26ec13917ca0efe6e8db276aba4f89b13d41b6f80ceb9205fc313c1a7913f9de266214956ba6f30c2154fe87552dfd97659a4af97729e1c895c221e1d63d483ea3387aec44426bc595fa1b57cce7ef066fd49f0eb0fdd1764919b346045af3783e15a669890c820e2f49fcfb4be4614f1cba555da309ca14bd263677da6127165411e309bb273a754d3cb2550c02a31b5ac1df32483bf71b295dcaaf374bcbc33d551c064fe5dda0b550650b819c094eeaf7026323e80d47a5db61ffe39d7441ef88fccb9654b264fda80e4fc6ac9ee47d566260e388fcdb5adb9a4e8154dc6b835d3ea7e109a94b08d6f85d1d3272dff61734bbac214be22653489c38d8a3423ebea93bd5dedfd1f9bc58e8530fb7e32cc6abeb04c63b9decc4caa216c39a4d8ac45bbb43dab59c8bab6168cc88b73e6bd56e2a17a55cd9ab909da4c7aec2a3d7f847b292b7b744c68bc6a8db8d56fa37549e9c8e5b4e820cda3d70d5674b9023f9ce603377b1a86b24a0f78089ba4445cec3687fedfddc038416fbd247f7a36848ba04a1d4745f9ec71cc4033223f28ef79885d0acd65ab2f4a7f044d9b7dd7a838e568df96baf7e9f67525de321c98095ba6b5f071db85819d78d04244d79c7731d7a36b1a6e8fb839b5b7e0c3d386b421cf173def68fb011cb8d99b067c0057526eb492e8747e5f75a275829f218f6142bee3cc61f181a0ef206df55fef6acdbdd20018e16fd3c19ac6296054c4c85a86d95ae533cf2fb74dfac6b88eb2763104107b7730af8429d5a200af75052d11684c242fbed5f6dbc67a811feda733eb60f209ce82666e1f74254ed94f904875fe6bfe831000356a6e19c30285aa6e6c9c06a8d90d35eb1a24a82a8017f386d504e12c1a6dbfeaa222edd4df1bd6aa2e7f996aedc057543c7f31cab82d52df4905f301aa50baf08e89a7ca0afabfbab65b2fc2fa0a451ab99c37c9b2ea8f47541a38913f2f7b5b70926cf6c70a63a41899bf1a01b731602676a5ec05bc5e32e61f246035430f537696c92ca512df8b8b92a32c978100e79d7fc9b6c1d8df357ce276a40c004edaa93b8951f7893c94360f6c77aa7a75c944eb61d88c6c5c34f14b6a22470f8cf9c2ba441cd00d9f999c4aa9e0a4459cb418d2a409591adceef758d9f26bac99bc4833a299f64a2f274d129ba2d4fa7109a6567358e0d2b68fa429d7c444812a2184f6a4ce3be186bab6d4e5609587c22595b677e8fd330efceaa5764bdb27983229caed52d372a4683219276099330297ea720f40f6b7f2994c483943aeb310ed50248708c1ed2a8027145987618ed5883411d42740db4bc2123e104540ae56ca59a2f7a2b43cbb9a00e05054c28139b024dcd1e8d12cda1200f196526cd3b94ca3383545f66a3d26de48eb52b784d2456f7002a24f13d89a2e59cb64cac72b6b728786d13cef53bf09a80a84895b9e203614636c90c755ed7ef63fda97ed0aea208fc56e25a56f311bfdcdd5803d780995aa12497c483c637592a38a3093af9f8554d9de6c79bef3023a7bcb83bea5dc599edafcff92a2d017c1b04a53f651ef93bd80b46287b5c8e3a6dd401f1f07f6a93712ef9f7e56d9c763c626c432bbb76620be2c868426556a98251ae2507af3d67800273a7c3bd0650b46ef02e824370d9c78092c0c73282e5c71b686e8006195816fd52f90db96f689718bf8807cb5883f54d1010dc3dea5aedd55ce8dc7eafdbdfc23f1e13f31e5dcdfbba44758a1b5d5084cea5c505f3836d091677383365f337309b467d863a263f3b49f8dd13efe087fbfcd43ba53f9760000c1d71e0688883aef1314155408b56367d0cde5309c1a782971bf7723326e30f553415d2cf39e9c5ce436be00ad5257adae9124157f7121edd55f3cf6d0893309ad229ad9b00bfa9b4235d597e31cd95d55e390b3a8dab8ce33c894999b71b70e37b40e1c71c4952256ccbbac34e271ae0aafeca9b2b57d0374bc38d4ff61084593d4f26ad556170fe2ef4bff3170731b2043ebfaf66a1871c87491a33c0c9ea3ff120039320feaa9c29785f79c741873097d05d39408106c8ef539cd9cde1072f03d15616a3a5ede1778ab39710f9d71709fc66c546c1d5d3bf072fc61a1e25355c2d606367efde38ca0168d7481fe1b69abe5c5799f225363a37a1924e7935ef24aeeb1f19627ed4685d85bf852a4701e0dec1cd030917a4094b333643a7b19d99e84ea1dc950d6162d2162cc1f130d5ad249105cb951e3c76ff08dc2ca78f1686d614a7694f000d48507760f169cef9afe81ce3bc1fa4333d1e7399f0e0091cdc99a0766fc3745026653acad588c1a481284a4740ef7cba40270e9693956acac9edd5efe8b67f593753a6c6a4a7dae4c7bf50efec839bc606f9a84d3e1e6fd8b86cad0c0b9b0b91deea1798dd0c8eac5293c35b11123dc89d4eb78335ec5a2c4a086906ca161007abbfeda7a76065d4569a75ee5ab99b48bd9625ea167e52bdd458fa84a5509bc9d09b50d9bdc195aeb819c40d556e74deaac402aa70718c14893033c81d92fe5545bfc5c972c5d886ba37a800006540eecfd8a74d3bf9dd9c7e734ed005d2760079c1d213213246f5b3f88404dfb46ee3244f921d554eb87c7c42a5bc729f29daff85591545bfb3bf81ac6da6e5e4c75a603b350ae8350c4293ad5cc69cc81b6c67dabe967100e817b3ee2bcdda6403f24a0f1b4bfa1533cd95320ad494f0c61118a0c3d3ddb320a3157c3941dd8737ea82d30732ccca2cd376c64bb1c886ff86ba3cff866b48aa4a94d23e2c7bc09b3effbbe29dca3644754076e8b2dab014a96520aaab7947480cdd87f2be306af92beea7c7b88efe326150fa15ce7c4eda07e48c44b1d7bc786908a6f6528ad906eaa732228c08fefbba93069aef2b0d16aefa66f6e054d1b0ffc719f5965d9a48c27833fb1c3d5063468ab0b0bbd1e538491db1c8229ed86b65bf6bff25b377cf347687ea4bbd2d07e2d65abf6746860af6b73162051839ce2386aed5c963960cf7a6f9472dbf374f1bfddc0bf6bec1fde0959c19edeec4d61b81ef849d6e3b743ad676a5c1265b6017437540a89fca9426f5cfd4ee24596dd6d5813cd589319f64b7167f4a396a9ab0a744b93abc7799ba0b80dbf1921600715dbd2a95a597ca19888bd506ff61aff73f572b3f75f550ce5a386951b06b4f8ca29f080ffd02e156a7577500f0eddcfd7260557304f4dda172157bc2379913fb8ad25be32104e2bccc7bd7b974f63a821ca16d0e4e307749c293764f4b1ad5d692e23655fd1c622154afd8d3b6a2457e1648542907cf9efb82e5457f71101564b61c35b5a59723b0e4c94ddc64453ac843f8d7e400f416640fa2e4bb607dce3d62ed830cebe66c9a9b143681442053f580d61d360ba84b27a3be6063746ffa8df638f78cf8a5932daaf34a93a7b00aacfcbb9264f77f8ec36bb0806a2993502a499eee1210531278ad387bb987d7d938181029d90cc572fd6cc9b5568cd68727b7f6ef7ee7b13c3ffb3f17952238c5fe5f8b907325abd02895295ebab6a03e6a937bff1290726afac5e6f3b3be0504f5f7e3e65aef8c928199ba5ef13e5f0d8cbcd233ae37044097e421cf6befb9690998466d18d823aaecdf8f026ce9a9a449cee5b548946fa645e77a1d3e8742bdbcf5b5afc132f60a54962c272d4e553dba14bce500e46f2f04f6dd298477d41c3d15582f4634086856a44e1f2e82e1604dc2a0f076b8b49b4559aeb99c6ebeed4029bb799dc9bb9e6561daf44ef000349e5b52eea662241d74c6b4530cf4ca65cb83b2795a805bba4da7eb314e99f03529879cb093f176c1834b21373781f3c24ec2055b0b606f3d042b1c1553fe4186f8f114193db3474d18c2b6698a3f0ee5af90e76fe83a57d5964c67fcc293c43e78f9229d08d815422537f5970e2cfb3f04a7c752b68b330fc217877f0f34d611f745735f3807955442ea0c3a3700f5fcbca678ab95a9d5ed3862447855a058feeb0415a58940d40808604e493313977475969b4719485cfc8f65ff352b29ba4fff1072ee47078964fab8f18e4cbaaff5d2a12c7c1b2059503bebe7d2298d2e330ae54194d18514c511a70ef25594cfb39559010c9f41ac5d291ee79c9c6b4750c1af794807594defcb221a3df92651c4a07663630859bd8fca92bf16ca341c59a5b031b2f0bdd194f40cc6651efcd4df1dd76ffb620dd916835213ba41a7894414146c17a1e83144f55a9df62df3f15a3adae4a9f2df672e5b3647b981d67d711beaf15c662c07bfcdf9fddd14a6d5207c39ef521e33efc20a41ef3707ffbc3ce45396b1b1552fe28acdaff91b38f7efaba98c7f57300df2b84ce445bf2434532f189da4cb312c29df919500dce984735c52d660c799162f6cafdb6635c5c307920aa27c5bf30ae482fcc55778744b841235384d0f42c4f901c59762346769aa52a3cfeed0cd7da4d44e634dcd80e24fd3f7af863c0a58a757f134c509085f48ff91a2089fdc3627357a0653d5da9a09ea0797cea2f1936faba5e725fdf66c9d01e55d38976836ebad387216d86ff867c82e8f8437b4a40a148d25dc78543db7cdebbe78231d2dc4e8d9fd4973fe853fec63d8d2b348f7f64eba29a24c6ca362703914dfdfbabfd514112fd56bac1810f83b3d1897d61420d4bd992cdd17f57f446db4ecf0965719f6abc7954aa76d7879f38b61518f4345728dcac55d829bfa5b959d330cfe85a3bf233bb2ac3be88f083654712ade3f05c6a26d2711695dec216bc96a54179a577554fcea2f9944cc371651d9e7002281c32435ebd0742fd4ef2b78b403df4288ca9287122fcb49b78858f3b1581a17cecedc67849abb27b81f79d057bcad16a2daa34f42bc5e5f382394207ccaf207df45ccf67bd73ef4839afbabb2ec43c55a8355a594402d1bb2cb9d75d9b41821aae09cb2eef2037835cd12ae83a3f2acbcafe25bad4e5ec6561902fb9ac2d4711dc942d04ebd8886c9470f1581b5cb4416c9e28ebe04124008c1293428f48c9f676dbc491b96343a11d443e20eff0a4ff595e09f46a146cd157da975db3b260f00891276a3d5f39b6c8ec852e4e7e2f6e00c24d4f1bbdbc80469321466593ae8517672ca3a7da7bd2254d7e588dbbaa2e8f2295261ca37e49c774673e18107daf13bc257afc74b586b7e7b9cb0389c5f6d3a0c62113d93d89910c4eab87dc5e1f7650dcff7775e52eab3b11477f9b2096dbb2c414706951ae706244e8f409426749bfa3a8f04bc97c15bc8fdfbb58a58df302e99f151b2ea2f077b7176e994a346c0457c77364969ed5fa78cbe61093fe59ef45ce161f529af9bfa275ffbf978f7647cbc9d482b629ad0753eed15089498ea69c277b0dc347fe00ad4b465a006e2dc1e58c71f53ca251773df8110534bc50ff92a3b8aa4a88fbb8ef8a56ee6b676e0466d9b4584f0ff42b1f8634b95e25607698c6cc77506235320cb512cd721795d2ef5db7b176e80e34e408a9576c5cd03cc5efca8c3ddace1bf43d533c05d5738b2211aee102588c18872311ebae8813fa4868cb39b3ae2ea18e271418802f221ebeae0cdd2a801fbe5d929409b4d1862da6ff6ca21059cc189a984de2768935cab935aabfc5f9ae6e23c197bd9ba481cd2709723ede726124fa9d0bcc8f3811d77905fa3873a49692d04f5d56312421e9dbe297b62921e363a7ec93ab50dfdecffe3c96db8d9fb93202a9c288c76c0eddc169bfd3b64e1fc3a0476987519045f8600b597ae4913c9bc5e9fa1d71376a42ebe40ed7bb46ae5bed78f6e659cdb48a43f33b84c0013210a90b2f1fd41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
