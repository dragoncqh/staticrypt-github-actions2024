<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c40e533c21fdf600f8575c36b474c9113dfa3856385cda47c8c2cf7425cbd526715b6e07e00c81de7e545b0c7dd338057c1f0118fc1befd5427cacab2306b4d5e5a8b052961b5fa67ddd7cd904912d3b229f5aa0c7b2e7e04ea6bbe4aff392b2c53dfa85389a5003d9f6aa0e4981710e4bcdeeede842e2921eec220b33c9b0b6a6398caed994affc67e2d9db595d6a6ea9a463553e5d1488bfb6fa6658dd34476b2f1cfea94026c5bd48bbf96c055871ece0fe8aeaafd4205538d4806b8f1fd03d89b0b756a23f5fa8295738c8fee45729eef830042ff35a3afb1b7f9ab14aab9d4a9edb11af03468a56b303d6ffffff92ce161e5333a065f1b3930dc4c74fbdf59d7b2ee2e8598fb2573c380f1c14da1c632e47c8bae0341cbc2472fe43c9e2fed6508ff42e6e8c1ae67a67b054eeea79f28da56c6d622190432a83b82157d2c71e2690f64973d0ce017c857b7eb994b9a954dda223d4ad8a832decb694f1d6570934bba5d2e5cb6ce8396665728d5595e7d41e9a1f06fd0eb4e5226325e462fda4496359e77dfe52714332d37aa1c1995609a8c8e251aea0d9988177bd6da20607c23701555380f33a8d4a586221264c0054b190efb5cfdee3d0f04b8de5876403b54daac73966a153d14f1687881576ee881bac366323594d45e18ff38a362dd5d667303c46b2ce67fbe1cc24ffc925c47d4839976ae703285bbc140fc834b83e25bbcf4a5f75f7d7792914fcb4ff83f90b9471694c5414a995dad3e5ccec9142c376f66ef3533fa4f68bc702640f15a4d244d8005226508de7558eef19b1b8845d60d4018953769f6e9a3af824af4a0289148b305d2ec3e98934390edbc167c769089775b7a226d975cf42763135008414be9b04ce6406ef44db1093d1ed35af9c5339fc6f12fea23fe111fd5e302d3c1929c790dda5a7d27dce0d0efeeaa1903af9a8ebe0a5f8f9bb3922a28a80706c7d2cc66aa028141baa04e31a1f93a222293a4f54e5bb15bd259834bf35f7ec31a86f5e8737f9fe8b78698d8d2648ba2ce5b0677887d32c0720e2ea25c50c1529c9bf9840775f2294ca18420fc2dcb7d1205ec64dee8d72385126b9d4b5c1535ca6f0d6380a0360379a9030d947eb058c26bc165eeb52b866462dc10fe65160085a2abf448ddb0a82ed3aed589442f5776c80fd73dc81f99fa6496f6830d116986d47166abb22a4bfe1c7a896a0bf70fb4db59bcc70223d387a313ebbecd51610c93f726b9d2ecb79218501c0aa911b5c2b144827f6e7894607450de7173faaf4d60c2ed45a02abbd09f0b9f1f115a9aec6e4bfdf3ee281c7d323469956c5c390848310e0b314e3ae4fb041aa96dcb1fe6301ab3aec10e75a2d715b81cf7651e30a9c67fa22875e657f393ca6bdf8b0a3750cb7d0b8dd41aa566aece24c0ecfee320cc5d5b4c40c4ffa5dd14ae377f0ada5909e9d0a84abcf801d98dee3484b557a08241bf5cd2c78040e5361619789674ce28437bdb511dc6cae6f10dd073389aa133287bdd55860c8211ab75e511fd4f25e03c0f88e0b250b5f420174275b5115f7855ef47f2687f69698850409829cce37b8c68d5829f1f474bfe22d9054a39bb011856ba91a07c54425c9aaa3830352197ca3f86b8d087574e2bb47cbbd1e3d7d708834ed6fecfd2f77ae531042f80fc34bfd7908f85e20f3dc2d3b2b14cac2f1db0c160e181d9ef320c7179a7370cfcd338b01d155fc263079dcd0b7aa5155bd6a66eac02451e5823aaafae3a927b7131e614000afe42539256e1557725735346867725b1cf490ff00a3e768195cb4de4114aa53822e1e6f639e34b7c7f8d40490082f790fb51759a4b14ffaa0cbafa640feeeeb00c20229c891bb40a74a712fb1d4f9b430dcbfd5815453d0a762fb060454c6b89d1b81efb72a1d8cbd09fd5bce86d335bb9ddca0c620c23b1b4417c761c0ae77ea9b303cce3a541058ab58b716c97c673f72c026d463d24c08395fdf030ebef7e9eb0d91193894c2cd632d27d311c961b633b4d1c6a07f7b1cf9901a5dfda06d0687c2c416c303526c09b149a4d873ec5eebaf978e8933ad77d00a69a71d6a0c05e89dfff78ccfea2ddeeaf84c8ce788d56d1d38a3e5f4f3a69f11e321a3fd0ff0b53eef8d301d5d130b1a2899ae534c013c17132107b1b2d58c79bcaa28a5f40d1519e00a021602e1fddcfb07b28019532222cf41116171457b861d37d2170b6ad09fdfed244ce89512f4a99ae01a1628f7fbb7009631b7c6c3a6a369f004c9bfbb8ac9cf6c425a0b67a8986b248c44d246295b80fcc0d586b623abdd8b1216d91568904c36019e2fd43dee887c6870877a066e9341a7243e171befb24ef188b4162deb9a1de342bef7cab161b72306cf346ad5314565055e3b3d8bbb03c0d0128646aafcf650d008469313a1126bf8f32a7ebb36d6d77dcbb7f58a6995fbb958fb05661b8c2c19e4eea465a2bf7e8bc0c2d7a1805172493e7e49f6ae246d32b75a1b9b8422ccf26514968854a7a711b34a669c206cbd6bdfb50da57f5a64fff78a5b8e1d91372c876bdcd4f6ff1cb41401bc2face1d385c88b1b6f063e229d3d55674aabf2c70d10e37e801f895ab5b4bd9326c9d2af0e5ce3ea73e597ae017f9c8835de3b8bd7af8406b5d7f87da94a10c2dad89bd8e62da431f1215ddb0ee7be01d9e3bafb16afb837b3e1fdb00f35de3717af29ee09ca5e0f09d4178642974c4c48c8c1e5f6399b8a699a9fe9d71a90c57fb48619164fc9c9aad4abd90c56829983b466f9f1497eb7cb4c2b0cc8f748538236d49e468277279e9fd98221460da0a04f1a703b7d5509965998f72383fc417979047fe23088f79071243506f59f5a4bd53c3f3b5c18679f0b167b1ed399fb6eafafb099cfb06a438b897807564ee3d45be7db66156cf85fd4bda5c0bed2a66c41fa45d1d27e8ef5fb949e44b92701a844497ea24be05b12967fd01eeceee4fa483607b6e8932bdf09c97cf0d90f4f788b525e8dd8e61af80df9f255644164fcb9a5cf2429fecce604766fa5155bd57d8de9c52249cf99a58c96c907a06b3195ba99aed4c8d77697fcb3e8616d0fd3226fc4ebdd0a34570b2fb7aadf07513e5920a93e20eea9c0b61b240606b1cf2cb0819dc2728aef07107afb7ad8131788f1da8623e3b8db94d7520f40630bd2c6072a57b94b978d1a8585c69675ce65d3d765069cb8c22f5d5c800c61ecb815af56e63411b291c644c3b9122e3e07abba51260821eabc67fab30b897255f0236ef1085e59e6ffbb56435e110925ada9a3a2242a77cf49bde1e299c8227eef163948ce50e6188cb16805e73d4528896423934d12d63e91d89a0633664b31bdf72230d4867b7679c614f7212c27b89987c1e76deb54bce8a5dc26f7c3dbcfb7f9c7aff7fa1edcc3b51bb40875078337337382289b720bc119f2bc417dd18f81fb1185764b59d42bd90c334a27496841c8bab026d3a45bf5083b3659b5f38624702eed5ca30f95db0acd3446484d2103e04a716b3e4a7a3afa4ec91ed516eed947d2a4de25b1c4417955f22314fb270fa3c524e8b12e9603ec52fd7ac37409082f6d92a8fb19a92fb5a47d26cadc658a065ea5a73945941271592334dc100572541daeb92c45a11cbaed430a4efc194a8ed59eaef0eeb839129a6023660fcb31a697e25450104408f24e53480fa3aebed0928e856aa939d78ac3c4cab9d3c670a7720b11c13deedf6644c6b3e6c2121deb52c2e63ac22b501a9536b48681100706af7b14172a37f44035621659e2813e8e5d7c3946ced4a36dc911ed1da8a3fc53ff988fd723c3d4247b1531db57bc79ece008f420597aa813526693ac2ac4a86a5efed14451b755470548be9828f81eb0676c81f85d548f294d125a9f3c331109eedfee9b14c5410d6967531addb5f1ac85da1fe80ac57816c379435b46266cd9ada7ab3722c3a3e020057edf5612980895799a0a8612d40c1a425485ead20496ac9cb7359c3a0afeecdd4c232c262b0a329e608aa1c0d701362edea1b1df95f48d9221104932dfb78e6ef6b5fcd83123d744292b948700af2f87d6f966b0111f2534260f451591e6687587190a62cdcf919acdbacb20d47ea14f585669ccefc6353ec10491ad63c88e317427ef493740a2a7bcfdebbbc2bf923e323f3e0ca75b6edc5f1471067d160e6e90612ced1a33bf34307a455df27d114cb315f2a94028bfa739471a8445c32ed428b51e75a747b7597b6b301387ce274edaef59473e6e29f781d9c810a4743bd4e34a3e3d7f63714092643aa95cad16b1a16bd87c9f50c8d07374195db13b7bf2627b7f5efe11307290c05444c67101bc2cef27c92a669e691791c517a7c6276282889eaf5e6e60adab1511e2cd46fdc6384b6e233e7aab632314e0dba5ff5b97a4b6d1f013619ebad138023aec69cff751715e43fe87420163e83f27861a0ea4a08a77c917e6c38e7d68976b90921585621873882a53e6c0fe529d1d06c45a4f6c529907ec580910c54d576fb9b7d9186aa2469505ecc54e8cf9d92076ec5b0ed71ab6553f3726a0a4faebce7df3573b0569d32bd35d077be67800623cb669a458b8fe2851c0b0a3c64f4aa72419a9661e8ac174544960d2bdfbfa010d8552f6566c77233d3ac7c21696c90a28dc2745b1e73de5cb0d899622f38a2067b94f9aeed8ed09da560e8bd018e68d54613ab38e8ca8b9fd3417929b677e31fdd9dded6d2dcd93dd7025ae41f61d6024a08089a15dea0fa8896bbc72648f955c7322c6ecdba7193e31abd53d863e3a64eb39ba7d9672573ee753e68e6646f9e72a5dac1ab19395d03fcfce34c97716adf00b30139771675112ed9025ff1ab68ec22c41172cbeea47e0edf2b0189e39aa0ca6c59f43a3fff6fffbfbf0b062823dbb5b82d1be988f9c5e07089160c15df84aebb500704fba8b05dcf1b6dfed4c90afbfb06a613d6f48fabbcf84de87241d5005bb909709df71fd03fbeba2a418cf14f920c177667899e19ec4430674b8c778dda8b6d3790a81a6c88f4a7d7ba075c262f3e9c5a89bbff50069b2f50760bca07b11e174dcdb1d844f288cb57df0b510197454e4fb9d02666128f92129228206ebef9add4b816b9d605b9f4313acd8300e64d14fc649a472cdc35d53bb1991968597f96a31c614ee0e2e25d06c9ad79a43937469a54326e19042707cb1b35c9b60d96e0f2004eceedd126ad9d9fe519f2f61ba97e55e72e8810367c039fb14fb429e973a16f3d5f9a1973212755e178a5db14d2b27460d4a972a0ebc41c06182d01a48296986345b7250f7225e3322d634fc8f65a018b1e7525651b1b20132ebd7ddccb9133dde0c5629d86672c8bada3a4482b6dad77b198e940c48b4c1642e5e01b1101dfed18231700ba45ae2098e562b17000ded86b2066f9276fcb90d19b00a7ddf34f95c33b7fb8b107b7e5cbc7ff14a317a07e2c8ae5b11080859579e30617b77296a4e60f15207b1e18bf2e3a8593a834898166f3efa2b5c1ef55781db241613472921e6e35e615328cfca90ca6583005a9bc4f1a1bc813a4f90ffa097ad12b184a941523687e1b6269625bb7a7d518bb33ec72ff32e1e6a25d44a7e62471e67a0bfd567787a7cb32928c57df76579c60830ff6e52042610a3626e457d3feb3669679fa0fc928ccb507d0547b6f17a1bde82bc325fa831c4ab4e9fb0540e5f2f648c338e0f705894f3800f597ac5a4aff646c9506281fbbda51d58403bbab2deb1f85168b490a9d2ad9f05f1254e533489534aebc8e53771b27430dcbe74f0ef2216d9fb4a23333267cb14c3a720ccfc113a05d11633df3a40a73dad44316d6bf681f73c69e6459e2962e0c5b6dbc4d5edb31ff85ef4131d58c7dea80a3a0fa5d927eaafbf035adee57a0579f5657f85c148624e5ce8191f6999f0f179e154fd2ab8e9568b4c3d819fb5d3b4e33288dfa4d6789fb7a63892dd51dc1e4eb3355ce4a5904b00f5631190ae7a3f168ab501a8e5cf7530dfb2541ac62827788c0e131793763183c324b56cd4db0fcd3c103ca632f7134a020afccb3374a5f6ccd0e82b4832d14e863b9477d17ec28e9fd26d4a5d1ea9b0883ef7af417bad8e883ace5d86b05c7ac8d6ff48699d370917e524696629b5644bc2bfda619cf9714d5ad58888a62cd9c21ea60a4fa3a17c9f6fae4eabf6922d2ca2c9353eff7461e46765bf9aae67f49e0d4b4ae4b07e44d51450f256209d9cbb1eadf63f56f260d51dfc333c37b3a0d0f336ffd7f5d9914681d255f2b164fafc29c3370e1a4202f3068ec2409bbcb76cc475792e058201e42890fd35c6eba94f7553d6fe78083632742ee9bb80ca5413c346e276057c0a2c9c80f674e0474afa30dc7924c3b2c6cd612ffd551d87bc41472d3fd7b27cd2aa3a271b709c4e38a77b90ec07be79463cc33182f30827ddbd7436d6b32babfbe6775bed9d25a81d94a9a96aa996ddfedb5ab36d920a66d54f97f493e8fd55bcbecde77724e75bc294300845a461a2e051d10f940bbd28b197277b05b80bc10eefbda8cbdcd3083e40b1fe108f0f89b8c080d2dbbf7bec2e03f25a7858cd997eeefabae0bfcd5b8e0840ed9f2ee98f382358a6608dc1047663bdf24450231edd817e1027866e92a61442e12d38957a55edb853dc43f4def222d8c3df3a0f6e5dfd5a5cccb7f4b26585c376f8f0fdeb4f83b79939200a1b9c7e6aba393039b986a310209a6676d7844d9e38d437ec19832d7707536bf58c68bcb1fa314d5c5aae00c626f086675037323c41c5ffcda0dbf0e7c71b7719886b650a7a8a3a249f8c2a6bfe6702ea595ddd2b8bd1b8e3c944b71513774665cedb26bed0149ec6d9da759fddea027cc80bb711f73411df41ac9e8e8f5fb1f243f633783f89004c3c95faffa3621187825e0043c9c430181ec039d44df75200927a5366a795b9e20bfbcd3ec8eb351bf2a80c52675bcb70cccc0fc589a2180e037e3075b2f82b6d1cbdd70f70b86d4fb6952309d6e99fc611c7b658dcdb25d769ef4f12dcc09cded23dd2061bd96e0088df91af3da72463625414bea246bac56e3bf7cfaed3724ab5792da2341533933b34e95bed3408cdf85a6efd838947ba807bdbfedb47f40cbd61e236c0e29564cadf56baab71263f93028c966fc13596538dcf9183e4ce8e8d18ef89d3b6f2917e948170ca173258f4b49d8022073b9c5e6adbd74c6b6f86350bdc3dd18e8c38c7cf5c2d553759b5849867ebeae9e0dfa1f2dd5f2549b896fc9f249c27257cf417e52b10b9c31490bb0f009c45cf26826b1c3cdb0858c448af5205fa4239a226c461e5d24e986118ff73914ebb2a9bc871a721864e00c3910952fc6351ff4e9798c3527897cafac47756f30a4d5d46705c32c2322afe98c0d0b695d8851481dd2d04539553b3939798db394c6cf9c44ef6c84ec50f165b06c7abb300c7e8f359f9761e01014ac147f1af8586bdb49a7fb73a3b0bc4645d641986abafdea62f86f0c3ad0a11866c98fe01f2c83b86e24ffba373b8f596815eeecb5970090218c503e119255cbbd21a527191d5e855b8f5bc95ccc28b1f9088ac1e85887e3873974174ec6f132f4cec8387246811a7bcdf910fa2b82426447743e4be8b90e013066d5b9a3f7ff3172392c42f84ddc959484200058e46abfef6b66a795530d0ea9d9b7adb84fe7390dd0494a56058066b4bb2aec4368fca956acfd83e0cc3a85d324aded51dd112f4f450ab033e67b47ff6ed720506b9c2e1e71cdd0bc2c31131823ee02cb325e948c36b00c505613715bc4f904e05e5f344701ddc9bc8778dbf3c78e0d9cef672b4fe0b14752fa76fc4c7ad1d111fd09d54242057a245ebb020cc14d404f1c6a1a0c157592ce865f951443672f10303dd5a60e75ee8c97c1610ecff9d294b55336ab0d1bffdb2583f372609ba88e3b276fa3627be07d018fbd54ba9018e208a6b6be43a0166b401a3f2e6bc675ebc1bcc6ee054f58605f0c38d10be2b082ecec4d7d3fe5cd8c890d5ed64174161f378ed68efb50e8065503c145b4a7530a7aee35d7b36ab121312a750f38bf880914450e8c07c929cd555c9503e9ee7c3da234d59982eaf7815157f3694103e911d759d7198bdb9c226caef21f1484d6c366d0027d382d1952ae6f7e022146c3ccfd44b648e3ea458b8a7a704dffb864ce9aeafd5e7a50f45430818e9865eb970920788304c30d0d3088467adb8f665c78fe0920c143d0fce4f0031e26b7e38598905f35b6699db0dd5401efddc279342ea071fbbf38a73205aa055d831fdca49abf42e8a534923467eb8a86ed0fbc50a87e0afb87fda931355f0d108a91d8f5db8bfc3f0b59688c0a3afbd5e171b6b534048910c036b34c9836e7c9784993d640173fb785a599330e854e0ddd165fa79fe65c452dca332baac6b1a7ec2454d56eef093aeed71220a208a4b53235c237a2b90530a35f7f8285ae78723066c406106ce80662b5e08636f7ef11688810c2d00da23a5fc83bb5bcefda1d103434349c4e353e3f01a745a89ccb10d29efd044f0123b4b01507d4ab3d712e3afd3d835a3e2b759f1b53b868554c8d2d571bc50765ccc7c0a99fa8b15504f8ebd09c85cd45d300cdf1004c2dab79e99c8c2ad3cddb6149e365d2a7897496ffebe54c3778c01938472635020d3f9b9dcb9d208e297eaea0213c779ae52a63b4b167d8818d1c269a1c4e124a4ef9f225717994107e65b434144efae024f6b5c272efd94e635a9a1a81d897b88b36c1ec7cb303f540b56b91665094362f906ca144d5495dd064556e3fa14a2a2bf2681dedf2aac236d19eb77d82c6476ff7e66bc5927b7329520bce5bf13879bbde98b393bd537e6a0544494a78e8797dc6dfa326ca6623f8e62a1c4412d8292ae0e8634db8d04da4dbbd6982ff300f95e5a8791c592f19f4eef5989d6242a88ed64dcebe3c50794040ad01ae242f9c15f7e12561f19905df5f8ec383f5ccc7e7b8182e259a4ad40eec2277d76a34fdda8af9b7c82a9ab4ff7978ad8ab0c1d00a0fc52a840dbfd8a57c94557294d24a843387bd25db15f6658a2ad465aa287e9aec3b84c7bce11eca66196b3ecd74f6ebb0e01f256d6507952d525ced98f5c213ffde627722625930d9f8b72291b89b9ee37d245879ceb54247ddbbe475c42f90311fc403b1025e2470238383087ec86c017ac1c063f9e0b4374baa9c1ae86727387f72cee7c7b6c941758d7eaba86ae07ae1bce24d5b55342c863cd97909dd1a50677b76630a46a9961ba05c82ab5591f29f0a4e2c976de7679515c37704a812c3d33d155029c03209332b77735e2842922282e03b196063f15b71b318091385e1fd4c68852246a7c81d84c9621db250f6bb79d6ecc52833188bd32c3907ecdf8fae7c5cbc20cddf773217bbb0a56977f41192dbbd7a1a302a208352691cbb2ad206afb56f24c5d308860d833b664949f2c4c588c8b9d4de8dbcd5518e5f6f01b268f04ff4d8d8c04b80d615d8452bde429c2267b2c6ee97935bfe004dfcb66f49bfc9aa3142b639b446528b844c261d1941862797c5bbb44718a34a06b8ece5aa535638e9289317b76c4ea69daaacace8727df9cba02808fba8e93b0d1be054fc50bcf03b3465ed580576378539622d73f0c3285363a0aadb4eedb8a9ef17fbf0a86c30b2ea150c225bef46d6a4bb2775ba45785942208ae9a7a509db76d972921e094a6d0f3e8c2095a425028a6f3a181d56d5549b88a19970f00e35886bf33f1aeb04c57d59c4ca734d7486c757a5fd66f7417577bd56c3268641b5d66dde95e6cc084947cef1352b01f320952b3cb158f2bde357896b0ee86cd052f0c7ae1c580ab5e3e38a68f13a43ae8fa8a0ed6d74a568701e6592b4c98f5dbc1488288629f5366a0ff0ac651300252d9de21d1f0dd041c79fdf44a8b15b15ef1ac3dbc6eadd78b5449a7e77d019e59415af385ac6eaf239c3eb7257f42167647411a5976d6a77e0cdf23c2bd15c54c7f54a4c7693c47499cd153d83d04d415e0d34cee718fec69ff35bffe536fccfd1a93271ec8b071bce10a523bbae306dcba172324319a4df0dbc6f7efe05833fda7fb36a12cb16ecf6cd10a02edbe69284fc29aa4c5baa851edc82ad6006590cd55feb12a7bd91156fb634dc15457c27a76e3aad47cbbab6a2526b87186f8b5698a8fec55a1653b1a6bc55868a9a09bce162bfa6c0ac0755f725416baf59a876c7cc678bbf5165f3f68810dabf06c61e82ab7b2faa93fc81e99fe30d203461a09cca773eba9589b0af2d5f9079408fe63352dacf4b65ccfbcd2b9ccd62ec4942ccd388a2d389ba4c455a3c59f6143775a50b65463752fd82dfd8d9bb8f1251e6c89f243148bf9e4f746622b4b9f683e41ca03aae5a5a58befb0983a6d09773f28c34e3c51903f991910aff9120c226d1eb9421ef670c58ac9791d6c8c71a3e9628f317d5af02ad6b09d91e9729232c12905d09c51dfcc2459eedf1af1b365fc841b5df031739e10cb5a3a632e3249a7a79905f864d9a796a0c8d4cda20701c73c78d9750ac65f041a3a08880fb1791410ffc0d2e1888256c6f780e26c4b010d1c35f15765f5f94d8e42b3f85251a9913715a7f8e326a5b823ce584a0a2781f6d987dab5b3ca7054b63777d420d8f3d61f3101cb5d971fd26466928f3e2592ca4d60afb0297e16c9962d72c9db13869e96d21f86c217f55349068907ce6fc50cd92d455c664d1d8eb09f885eefe863872d2732e8c84324ad4e24420979e1b3d14129713e5ca03aad1657b8a6010484607d75fad9e24d18f31fca67c7bbf78716dc76031b46279dc859c6fa8cd88417361794577865f6c4691152b6bc358081663677b00b115ecd02f203e4b42cbdea1401df9af3fbe203a75949007f437c2046ca23c2890e219bb9184a0871fab049760357f38e9a74cb4dd2a8b5a69a7af7cec8612165acc627b9190a56287e6e5a1afd1ead568f98d9277497a7f999a71460fbbb8de435b29a41718543c10690cf22eb146b4cd9b94c571dc5b2051f9cf393f2a4f0998d7ad1bf5ebadfb1dab1851f35f4db0d05382da7ffbb7539f934d504f88ca38dddc899f1a74c7dd2fb4f263894b336ec91011c01c87c74e2c7075a6d1a964a05eb4061dd775e57df6ee33f5c5ec422d0f4452ca52575e378bbd4857e0f940fd982eed04cb27eb7ad77ae39a9346a759d3ed747047be7cd0265292d7d4d037d8b7b19d84c27f8080176618aed097e707d46d467829e5e3654bd6d39474dfb4b9096ef9976faea396964bb374e291c02439953976b4b0c1ed93d64c61c229fe176fed0ee265377775f771786eea754973beb73af5bb8a14da133c23956ab24d692a97d0f9937d48106969a8a0e76787528499c588d849c3c2152806fd9f57a4e9845a6ba1fe76212c7d82f631c86c50b6cc60f7f5e413a3747987bfdfa341afe6683bfad7cda551393fc465cf0a32239d5a869544a04e9add5110146964990b1e24ec8eead8644326b2dd44a50f34e2a63e67a237633aab8ceefac4b8ff1bbce6b343930e74e634194e4044bca4eb2c863ee5923460143a58d2d19752631b8e835f7016491fdce8976337418c64a5e7430955495ba027bc0436b4e09f9d18640cfdd8dca84900e3abca6235e95b03c83f6083e76c69e76b9e7d7b3748aa7a9edfe18b90e67fabc428c8ace9790bce45e55b0542d3ab9fab77ebb6aeadc296ef12c1e9b78727a8907c623e8ebd5ae6b11872560bd077a4812d0592a30353f164cdb61eadfda2accf0202f0c5872d27dde66ee04ba2595d9688d7f6d94b52e0cecfb04162b17bfc0222c071dcc47d0f3bce4637899d5d9266c225647fd9e400ae912c78e99fabb676cb6a915e843c827c9e966c6959dfbd01fed1dbc45aedb6ab06f848e602faece0de0b96eeea349c3aa3a367a02c0e8666e940aaef8c6d23b3421c985c12ebcbae78c6dc87bce496a62bbe1e417f36e623aa135ea63b56d8281ef4d991ece647dffccefa0d8fdf8f0fe98f0278b2373c1733674a31a8b067ae6aea2faa158d53a233bad14a15080c140062a13ee45ad2f8cd0d61fadc74ac212cf20b8244204490f2c9458922b7a691fd344723871e59747fdd5e99fbc4245927d07e54d5ddab285b9f5150ee046ee9be810ee546d3454d6292266e7817329da24bde3cb0021451f15cd5aea772763b54b9a0e8c00f4a0092aff202665ac7cebdcb45c4a531b7847466d9673e0320af13fdfd7b5c1db20e8b56977b9e4f064a7afd0f9c98461ba517edf6af0e8f53580d88091cdd18c2c4f56e9e5019cdac6d1d9424d6a928d695d488fef482980f49e550b91563e6071dbc4d10fea1d7086d2b837bfe1d6f99be3fcef171e8ff83fc321ab417f9f2e609fe14062e8469d83de2c9fc8988bbfcf2001db723dbc74afd95a4061412de97f1d8f74188437a9ed85ef5a284f1f5fd967288c9cbff84f4861ed1ede4e6d5d0cbb663cd24ab90eb408196fdd92122cc6ddcd36f33055b872dadced6fdde87402b1df67eac6dab82aec0d1b4cfdde9e55c327f5c685b76cf097d97b8cf2e083aceb4f592141ae87a3705c09be0d0d766b996d74c931de2d39f6e9cdf4decef863bdd86167d2fee1d62e42c7f48a1cf2bd967923939d9eab93e1f1ede83602fe86acafaa118d29adb68cb324c7e60c23ed3349991cd49cb41c7c63fc4761efe4ed034fa1b2745a93e02cca168fafd1864083dc8f0a4b1fabdb9abeadf9cbca7c5314be5a0cff55c2ab3fbc4311e9ba44c1ae46d59add0d8f1d31512ea23540bfc24a9840eac20993113400536cf58b8a758a3ac76d2df80268630fe2a611e6092b473f948b1f4d2c41f5f0f9e4721e776a1d9f8a43df62267400efa6089879c305c43e63f3c0602f9bd361e459013298a1532a2fedc7caa31a08ffa97a6ef92e05e7b910c19b4d0db6d3d08fcc9cf0187e3b396a8494a750f85f2407c6f1315da40cacaa37cc9cd5c9ab5a17e4bfc6edde09f9074323dad10791fae9307e209c94628ff9c098af6e8f84802eacf314dcfb6c49d111db86537dd04dbf331739bac9a0ec0a96bb44991a36c26a4b2ad0c8af99446adabd1d56fcb30678ce1e19efbe8d7135282956490057978f37f56ff333e540603c234037460db34a1c4e3c513133ee7d3abd8aa3e79775ad2b44f53f7d05e5e9edb2e6440602d63fd63ce20235ab6b588cc608dab97aba084d1190c088e12abe63b09a755f5ccb3f892035a6c08f45632dcdc5b0f7c3ab92f4998b44e4aeca89e158dcab81c9953abef2407c8083b1a1be71323a2a3cb11ee93e8900f3b7bcf6730adf841aa17c20151e550c7b4e0f85be37ef314525223d4016041dc8d0025cef76ae6f067b58fd67f1c89cbd5ec73a37c0b60d796cb988ea1315304a17b9a3f8bac18d98f725baa60f5f73826c8b01836a8eb731a22e581076981102b119dfc4526bb05a5a179f980dc9c314110c62a14dbed4d15e8df32cdcd56e64bc3e300e216c61b5870792d8e8b59d2fa46d821f912441b28583b931ca7971f279b07f46768bfe70b7de4bc30fee7a44228fa251798c61db14da3551f018f166a655c69134f2d83f3ebc37273ef8252bfaa14f78c0f5228a62193a16c976387c42b85b85fd9f2b54d108eb845a96c4eefae62a10793ece9e75571c3c4a7b3fbf05ce08e4e44591e0c49f994a48313e4ffd3b07b9b031dae298636a7bc026e3d8e0fd041fc7189ede70d7e0bd6aa065598a05a4efa233e91c7c73f8b3be249ee468a019477ddc959e96e210c913bf9c72ec643e46c5581c86672012ce795e86b454a00ec4e87b6e119e3d2690ec45fb52307ff458c42474c500c923203f8031fd2a4c510c11726ae993310bbd33c620f9905b7bd234df195b4d75d598bf40114e0879665c6120be23eb05b02aeebac08312a2fade08de2a45c9d959d4b7facd257b5e16172ebda62274f487084b6520fdee8681c783720362a394b1d63048779a24bf9503fbca48612478cc6282316728dae66861e02dc7fda1c443f330d3e98742aed421f85e1005e062ce448da6a738958228ca86ef96c62e2b7c03241242b75fabc48b7b655469e45a8caf0fb9eb43f505231a2f8bbcfdee16447cb4b6ff2ae73a954161c8a725c4ecd6e273d6b775b4e83d1d02fa2e3f4adabe573fd6941b5e45e90c8e8462864544ace0dfdd7f7e6327c5a12ee631802d5c68be43a086fa2edb5d9c946c612a6002a2f6ab69563b4408a3c2f848b311faf2ae0c04ee12d23d9eabd40cfbae3179f6bc49529d43692c9b20a6ad08d06a5ee37480100c43676d072fe7286e063a16d6f12a7d7295214a7f0663cc2751b8d2d32146443edad03983e1bb94c508ee446d87de38ed86be6c313869b7fb39ce2d5fe37171890d07728cbf3cfbabdcec40bd40b0f81c5d813508adb0b9e86d7665e943d1afb8f7c966c29af428ed95081d324969e2ffa34f75e68d2d695904c8d973067904dbb42c17dc4ac2c79d01d56a11db4bab807c1040def63d2ec9ef59c9902ae0f68d6b9a046d728442e6c7d82dddea7a0f4e34f86c5dfc8e83a1e606d2ce493fa5481d1389771f0767e6756611f71511e3afccbebc6b25ddaf2fc6d72e1930f2aa38fc1264e3c0f1fc4f984df6f11bb9983acca423b48f7386bbed6cd707a7e5ca70516d1b71c4adbf68eab32ea147e62eb04036f3dad84b9fd8522e90daeb9bd639065b9220634817efac800fc3abfa0637a0e421c999cde1b0f739624c9030bd2f58693fcf2da958233924689db85b19307f95b6a55fea93f2dab3e03386afc2d129d11b9a9cacb58b6ca4c318ee50d51ef1b005654b032ffc72fb013bd841e78364925b077df41c37442aa502652ea8857de0b943defd3f538ee5a610c9ba74304c5132cfb930438ab5a31a0d184cdab0fdd6042d831435140397b8de2517294c4f816a47c3aa1f7c08d70d72f85ff72694972e53c410b87919e55c9719b517c4fd92196f90eef42856e9894db0f58b0280a65e54de0e84df52eae598ff048a608d7912ab88cb70404e74fe3f2c9f8921d8f34cb473a4f1fbb3b816c7c9ccc8513b84dc3e81c553207208f1e30b42659904073233a77636a5bef885cde02f7e0b87afb9abe0722d19d5a39ebe07b4f3b5e6933b0cc0e687bb19f1144e411b7eabb33e0345337c3cb2618de19ee0cce226ca8581e9aac5f64dcd07a4c8fcb04a326b5140217d05e2bccba32a5b059a0691ea4554364405d88d82df63f29a35fddb2362adc9cc389627a5b08ff301d889c47820214a86a8325b9b26e77765945985a21bca3accb8e4415c70beeb91521730df0f4ff429da13d8defb1f599475582b504ec73a791c104e024724024cee3408b0b1bb81f734c7fc55410c8219f725407d107cf8834b96877120ffdb3faa3049cec275f3d05aab984b5bdd44923d3f75bd2cca14bc918d0b761d9597f9644b1d3d8f428a19b5d21ae43efa1ad83f83c2f3e18c7cd768e61f1f456110998c7e92a9357b20562bf54cdb2ea7217115ed389a95a87993d9530df3b4fb786c21f660609cee056cedf50bfa2161b68bfab8d4b1ca67ee535a88c670cbe2cd3a42baa1cd46aebd4d0c836e7efebecc3349fd1c5024419ebafbafcddccc5667b9ed482b71a7d70498a2b1f702ec536aa4f5645649600e2189839f6b8d9d32f0ff0fa41ed55ca9d7d3ee1fe3aca75c13170e9b17a4306731a265b384c26d6b3b4eece44c14a44fcdaf18a38afa59b4dbe644c019ff854ad73ff59a9ea440d072749c7e0fa0a42967318ba14a3f1d84b502d8502dc2c8aad918e49b1d53fcb31702def14fae7a43425c48abf73d0d7a9cde3f4ee796fd49a22443f89cd18da68f903716b01283763d2f01f8cfc1a77fb54598879ab3e220954782c3f6557163f9e083841e421190f2d647eec62516d1c4c3b89d1137ef0198b29b9924ca3d1fc25bbeac8ec733b8a282e170ca7885e5c3ba01576e8f387798eee6202665f561aaa916b4adfbd925541e967206974aa8df07d50f103c43818097a7b693d33e769807c9e2483a08033c45e378745c7ca5d7d15d7d1fb5f34d80a92138adee5dcbfad12b493ffa1187772fe53ab0a4cbd30cf4df42b04f5fdf55083bcb40999c8123fc9d4c4b8db23fb15e58e8ba4b385cf51d4696961403cbe990bb0ffd05900fa151cfc3d55ea6884a9093d3bef7685d11737cb2daa7a4d483664737b92e583165f3b91f5f450a126decf2c0409d630dbc770c8593c753b9bd385410b8de630f68bb04d38b6a8185d5c6a5138e2275db60d9180faa041e61d2344926a089edadd83ee5bff8517bbca42b2ef1ccf16ab7d0a548273ece5080366096b724b32ebc02c6d7f898cc583a287e45936f55a3c94d53fd8e8c6cd67753b0f7260c602ba50ab6e84a476df546aa45231b9456ef2c32cbc11460f463c29fc52e39a5c6847f44fc433cf5717b98b386199146bd59d5c88a1c86f4e517e28b3b145dfa050bce3e18aef49cf49012cd7b06f19b335820bde1c7c1767a8cb1bad7df76a5e5a830e27729a1289179eaade5fb8e7bb3fcbb25440e23864183a23156f3aad4a282699e6c3b5d7cde9e1c693fa6d736debe67eacc2773eb921f2be26ef904a1eeb3a975ab475802713e8e7c357c114052862e56095cbc0b515ff3d81edb39e0551ffe23bfe05147680568bc02f00f80717820e5730274aef69468225e083d2c69b5862f55a2e4db8d1cbaf49a662c5dae7488f8278aa57bed630f2a37df620aa37b907dfbd977024f64ab4c6fde30307e5b2d28b7dcfb72f879b22e8e59394c69b3a127bf495d731e52c36b84750069b71b6eb11b280ac01515d7743fdf89022fc0073ab0e32265c3fe33c7fc46c5b7a8bb6b8e6875dafedb0341620a872a2c4229d01d36e730c4d8acc5c598046750738046d876bbed5a1105fd2115abfb1a93333fc0acfcf1097a49b6b4ff1d2815af1da6ee3c26fc4a210218eacd6e75bb1b73453cb0c3d3df3b4e2fa3129e75530a692d48d887a0d89debf7b111fcaadb020f6d50b69dea17b774166c3b8ab6dbe57460dfb076e46136b064b17596cc715c65ff8a95f2778cd4cea263f51d69a111a0be6789da7ee2ccebdb8294297f383f8e133a07860f145fdc07b40f36159a5b1c98ee1cb06ffabe9490404f5f471342364c1d7aa77626ed635a6b14fa5a51a231e43547332cf4cb377cbf2ab57518b78bcb067b163c78521881fcada567b2f6313ba133cdadf8db8bb2b65c6d72705f888e36df1af922a90d935b8b119217888faa823ba597b26ab2729f4642bf4f7b8eeccce3e009e6d79f9a5f6805e2e5f151d79a131c521e84a61ad87cdadf83a97aa4a9928e0be089a4e4bd40e3940f2733f3f60852e077d2a0ae9ef1d9c29c846166e5775a6f49ea0c51a7f99fb5b5deea12b7c7e6d0adc6c2f467fafeb42902f5ae0e46b8efce34ac29eec739941692e6a0dc3ad5a2f442218c8b05a9d0184b2b9f5f4e31dab1dd4f357dc3433cdf4e2e31ef0f7ba55a35fb34a9fe667e4af2bffb7b3d567415f984d47a9d08eda054909b8cfc4eec2f3e5b3e7e928b12af6f2d0df05a358c2db3a1a6b47093be8c2eb796e666d42c4fb8f7ff340ace54dfbe040ca1ed6c23547a9695be9ac151867806e75ce8e89804e2f0ddf7e91ba48a472cc3509ed5e87bcec4098139a41342a609e37cbe4bbf39c0a3537b4f3a40e091f43229c84b4b9ea8abd1c2fab770d01102ad312e09c3b9a1befe16e6313b221f36dc8be5d14c1b9a6f4a21f727487d3e39f5a75ea29f35153a7c02247e26f75dfca2d72c27e44b31b1f4e2e8109507d77f565de33792bf478b55e4a1a7edfaaa4399c7884774f18083a0b121ab11f675b4d3f7844aa7f43783ed4e969103b759ca1d750ca9acc4e0fdaa8d30a5814c2a2ed7aa3599bc4c2550f5c53689462f15167d1a66c0ee5dcc1c68c674ccdfb0fafaa3f2a6417f86a3195abc711c1adf7809608c84e82c3830999b47680658066e4842285fcb757b45b39dbe6d446dd98053494b4fa1b24f7b6397de63097c314e3f03ee3abf3d99389a61b23da067e7dd27da3cdf9702bf2e88d28d451259755a9e2ca39b2335901bea514721867e75fd888384ab3860cd7b5e53249cd361afbb3199461cddbaa3e59f6fefaba1d87e0785ac486adc5089247709266300a7e085d6c2a8e6e7bf8e4d53d7d4c7c13f3c285a29acdd145b753934221513f5e3e9681b4c5d0f02142a55aace48ec190a44fe9328a35f1be9a92a6fa98c7d08e90f8bd20874469dc673235456659775ef50a8ea1377ce70aea46b27c24627140c663dfed18d12f8c12eda3145644ffcbe641afe2d05840ac0b7bd5e82cffe6a9518c5148f9b15be7800f3c2d136c5042e652c37d4cfa35bdce5703cec5628a9e8ee7ae88d122481e23711df914399d3f325e949d8b872d100762b3f6f7425b249c22dd62faabe50d84ee44c48a1f820a562ed0165b198e068c0054fab74372a8ad9e18d9bdb12a36c4bf69e5ff06eb8f6664306a2138331ec8751943a43554f92e044862436efe7c41cb3ece7c744b5ef977dcdbc1ce73b1f5dcbba24555fd892b3415c261fa1fadaf267377f0e9dc20a30db1e827b8531220dc7aee7f76cdd6cd21cebea6eab48acc34a53c8ec3cf69e444f50a737937c3a9f36abc82f440cb32c830056f941e01826e61c45d1e570084745595a9245cdeb885fcf5e8796e2e232552d5fafc13beeb4dd6fae9bcfd5481dbeb8b8fb26a77f86a3aea8de72d5ffc8638242e1cde822e2f3243ef302b67197ff7dfd7a896a8551f45939f258765c034905f4189ccbdb266ac1d8dde05332e2ada4955424596c919909ea5fbb4ac3b79f16b0fd8fdf888469987de8a41fa44bb357ea391896259ea448b4bd80eda65c30a58c1076176667872cde9faec99f613404648f792361d00b68bc1b1e4ae78d8cd2e52f240d015d97367537145cc85748a66085725769d1e91b64457f311131bd415189b2cc9129d3945bba25f2876d267336d5f644aa5b23d53a18e8826ce2a296bd2235094cb2c06df2196e5cf42cf1882d8c3198729f86540a1921f0a37cec51b23077ae554b95c5aebc8bd39036642b6f07f5b01f5924003b6b46716f6a45fd820fe34823caf992146f17183f39122b50830655d6c7b5abb529ebdaa999a34dab435947badaaf72895643b288867990edaf06cb9dbfdd5d172f0a25e11c8035f272d5bba4da74cc3d939be1a356c55bf862e8d259dbedbace49c09dbba7cd54008ce6d115aa057a6e3b30b43902fd6faee1ed556d50d0e235846530686eedd64b310b8c9b398164f58249ab0bcc8eb252963e9302f608c43eeebb21afa06ec59bcc3c3f8c81934c96bb4fe191672f11eb5b1afb0a7d4936919dc195bf655f969482ed769cde02862593584c4789576fda26e7bc1c2223d91a20c98f39aba8d53ebd131e5abb8fc4184aa3930da97ad8a8f417d945211a842a8981bf69590912ead21fa23e9caa0be8f46ddb6a1b9ca1f0d267241e07f363e27450543a4a3ba11ead4c6f71ffea72890c6090c08c59273445fa834c1379c22f58ad420ef7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
