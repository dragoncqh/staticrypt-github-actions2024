<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"074c12d41f95573a0d105206883283904d5d8725e3820afb86e2fa968db98bb53488fb041e20f16dcf8d8f2e12c550bd3a6433539bdbdf8e8ad9d72418d0ad41c962839dfa8a8dcc04119753bc0be1f98f79ba0304ae400796469d578c2dacc87de4fa02f6abfe3f080fdfed2ff4bd7d4bb74bd1567852681a2bb317101b0bb4265128cc528d6b25cbf292fe0c4e06b2d1f7875e9c4309ad2ae12079b36d378bcbae6261bb0d26720e64eeb732fe5e84b8884136431833b16408d0cc7b72c1e450692e61d2cf927133f5d47c85481a27b2b17597b587774ba4c087b3eb4d815071c84f59c15cd04d82b807353bd51d59e36a7a80facbc300dd0aa93432d85d089a3207e587edd0bd97ee5d41c9303961ea057a90f95d4c8cac03a2efb0abe227c38efc9eb107f8f9719c77ccfe839694c82319568bc9275c32641d11cb7ff1596a03bcd01fa6933c9c4c96d3d665730840aaea77edcc609a97d307b079a8300999391b8425cfef896b7b256cc031ce99bdb9eed3a7045497faa316158841debb38d1304ccb24907959362f887867fa8a90a3297729d1ca16c59ffc46b0663e35c88337b723d7d317f574443ea4c1966a99af98c28a19ce0ff79a387cd8d90307b4db1ef7569d5b749a2d9b70a9c499a6eb9ae291b91af5ae7eea3343baacdc3eeb3f3b6598941af8b1a84031bbb11f85f42d821887fbe52c92cd3523fb30e348b60974bf93e984e243a7dda5f98723b37e2e335e70816c0efc9cda91589d34af7ca2bc288db2e7c7f55e3b15d41b8f29f5d2971a379fcff9411cc8619832bccee1705abf65b6803a546d12b4716676d7ca966a0a7c9ec2498cae69ba43db8b35a8f66a0e636ef81ba0b3138655f3adbb4c16c2b7c9fb851f4624b1fe6cdb4119b470b0fdc01a533d11385c7231d46bf6b3778b6cfe29d9df5e6234b3dba3c9c2165c3630550c9558547a96d22eaa5b524f3aac2c1f415f07cf2aa9156e766afdf812c04c7345fc13a8940da70352ce2cbdc9f04331700036a12b7ed5c67609d51f33bea894e0f9d51c89b19d5721dee03fbbb83470a258a87a4a4784e38d0ab6d5fe1342edb3d80c8185eac0dbbc9910182794bbcc046a41c0b1b78c853b4fdf17979f0751df83fec84f8ea2110fc0dc187d46ae9f314dcbad1662c1494eb2f099feec2cc1633af8eee7ab956130d0b8f770a81f76c72460449d1c7f1c3938cddca952fbf9dd9818c4cce55efa48eaacbee2acd2d5ebf760c42eb0ce1473b76a678cc470c964420d10961fb886631c42639c8baaea02664478ff114460e787af162cacff71890da4d966e252efed4688d8d7d450950a43d690bd791146ee2b06a9d36dce99365baa13fc796fc440e9a94ca94ea4dbf17c1564927d8b5f23971274ebd9cddaff86f7323582538f113224aadbff0447ad66ab336601fce2d21884fc368de9f62744f5e7ff9143eed51f61130733751ff7df52b6121ed18997696bfe3b85c6422e2b6522e66a89e98ae868ff3487f25fd2c4c12ed7aced49be49cf4db676728c7b386bb0a0d61c5e0b570e076fc9ffca77cc8198f8d33acdc1fd6b89a697c3074541d29b6fdd462f99aaf348e970ec01c7f2db4e8fcb928b376c1ee7d4f63ec36dad636cc239e87c491b620efb92e8080e8f703d652faa04676e34ea8a2d8a191fc9d51e5aa1955376ea0219b0e3ae7b73e1520993453297a3f92399f6b8887b9fadf6b1306f717f7d6f0a1b7e43c3c5c1feaaeefeb85b10251a3f877dcfb9cef6ba96f492995930f3daa45a7091b5a35e233d16e0be9980e193c19f0a12c8af9afe0905ebe710d134db066d1ced27a9721a1d182e24dfc4129f095042df6d5ec35f1b2f92018d9e7e39608507ec3af6861cf0c517ed38ca2a3aceeb49cb0d51bfd170daa641e64276521846cdfd13967f1da3ecfa93cbd0eddcdf8d9b35d1ba60b3a30f4cb73e25f918ea8fe2ce8e305523d4eef5bb94abe5cabe050b77b6178d72c91fffd2599fb5de8f4bbdc9d355c13164b48925692d0832726cefbf561d5eac8b9aa19b412b53b879629f76018f201a04d1ccc7c6fa4d91f20e3de565dc58d19ffffd0cff1654dedd50995176f256c77b8594d23b3b33b483293e39505d82775316eddb3fbbaeb45bcce3bc9cfac66b06c032c3094a3fb380f25edafcf0eb36ae1923e7aee0955cba0fedbe50d8f8e283204a13280b09991bfd05d60b6019aa8e968c31f7886d3f628bdb7b662929e2090b0d650ef9698fcfb3372eda0d03b2290a8b112223692ab9d8743fb9be8a4cb33fc02e2daac8dffbb5bc2d9e63dbf3ff5d31568a2f92eb5dba82bf36461c0b45804f6e2d744e5712f7d1e2b1949f0d3632b8217eb5e16dbd908213bd76dd72ed4a5e7534dc98eb456bb12db009ff43d97ec995759ed56a473fc40ffdcb2bcb9a18de715c71785e0c97eae9d43f1e30968aee1587ec1b1b509f09b0734e635218751507a580a7b6be35f2bfbad4bf368c9e57fba375e658b574c8b1103019b7adf8803e30a6607d0603b2612c0aa1aa1cbd622c76be01a4e5f44a1d26b97aa3715830a73e82d853623095e4773544fe206f2fe8c90931e7412f81cc6abc348908775f6b4b5f6dc6c37fc4464e8a506c7b38cf1a6449f8e802bb25e8f493dfff7028abab8a2dfe76f193d0ab4c4aa395bbbb12f8e20a38328657c51d9bd4353e79add7ef7e646cb6337cb0f2335b8317a5be26e49589fd493a0bfc282049b06559b876d280856f1b39172efb832a76ab03b96be1ea8b4b544fca19cce37e677e63ff1c4fa73484c5d9b65ac643a4851e6710877fe1164aaedd5bb9877efbd720dc9f377580ee7514e8bd1b4454ca403e58632d09f853812232954c3b29bacaa796bf4f8fa04400d97a797131ee6a2ca8f368fbfea60a4b573952e11666ce2cef5072bb6bf7e10f6ad2fe4098a382baed920a399b21766d5525a69527cd9024a1b8816ed18e328947d2f13ddc188c9ab79d92d633afea0ee8d0f8a417a6f8cb18e39bded94578a6a45461ac855fd08a2e04cbc195271c5e322e8f48f610b13d5a2424084fca283b84801a3fe9f10345cfd1b10e39c80d96b907a5740669ec51020378b0bfd83ed476d2e24dd9b7cabd3c0303bd75d408718742de67340a3809ba55ef8917ffa327de7aa6bb795edc7a0c61b7059b5c579ff1257ed48519b854784a22f268508ca3b6d8fd040df04733d4c2db66a3ff428d17fc6eb93b93b32e15a1572d6d96d70ab0fad2cc2bb1832b412df2edee6379f613a37af213d91f36a6e37594f097b40e3194d63d730b0435634fce3a692268edaa283dfd5ff045e520b4bfa0a5b948a0f8c35de9a3c5ba4cdcf10a7a5b425af86aa2f1be89571933c6109f216ff6169462b707b829eb9deff9a6a8276d45fa17e5a91ad665e7fd8ed7b357135f7a470f2f9b2ce41aa5ab7c365debe69b50126178f3794140e5bc5af47f1fb7990e3fdfc6ac15f8756175e194e59b5b37b140143a78e48de41ec276039054906f2c977d3f691f1fd342704a0b4764510611d527f975f8bedf4b271939045a5b9f2fda4ea4366bd9bd3c8efeb7a88af7934a6bb0a09f53e1cef4cbc3cb4c2ddfeaa911836a26ccb4a89afd6b93575e03201fb7a7f021eb48c78604fb37adee6401eed2bd3dba2fd7715182a30a538a17dbb4de9fa46de0120d0e422830402c6c32ccc00ba24dae8541dc1b6e063dc226abbca4188fc7f829caf48c8c235f68d86b7005cc6a77b3f0c3f1881002758c0d8ec9426684482362b40b1e2c29669ca7302305f03ff3e5b4d2d6e7da4c24d5278c6d2af1021da98e53104178f5d2831335c7e2f14219793beef1892e7b1640b6cbea88f4450cce84e7f5fe96d703dee84639f6046c168ffedbcb84caeba44453599bd228a7c4feb65bfeb5a8503e4c5c741fe65906078afda219ddee4792908cd78752ca0fab575c2be23d70027e578f3b330f55fd46af56d8182d976f2920e54508900b86716b18fd3d2beeec97cfdbba1bb52d14f7387104d7143f2766ddb760c6518d1e7921d0f365af45553197af42336c99a6edfa4678b47220311397ad4d1b67dbc5fb4c93bc129180a9f868af01aa252b1b323007e550ec0e6c2ddfc091c8b79a85c4c87e30dc42e6dc9763d32d727df89c611a2f25e0594bd066637a7e582024f4090d1fbeb4f63e23fc1fd57cd9d73d9a673635e61ba25529ea92332d2a17c02f4172851770ce4e0c73fbb9bf203e944c68acf596e5e4316d5fa3d2e98d63086819beae1ff965df57bc2dd4d1ec272ecdd6aa549b04f3d81c0371831e668d8b2b98e5d98ef2da0a9d24bc427103842a24f25193d575eff1514a789422b7cdb611e11c9500011c829a6a204e8e2c447869c848939f0efde7bbb416c855c3955830f0e791e649539282b4eece9ee42550b0d5f4485bcfdce6a07132a08829b71135c64bc5dc6cf9766b070f33188dd645f7d8af27513feede68a0cc7197fe6f12f8bc4c393e719d02b50a122b6970c2c32884b97a62f84b815787a35904a58f0dd324d0e16499fa916e685b0c8b784f7fb61dafb867d99655f1bc0c48de4e80335cdd955ba1b7097504256efcb1fcf5b7553ffdd89652e1dcb2d2476b42b057cdc1755f4ad3834f79173cfabddc8f60874c535489468181123c19b472b61620e232dad5f435c547e211a3b2c871c130343332c9217b29ef2b3464fc709a004f672d16cf41dcf58afa2788fc866fc9d252c2bee5ff14cd6b4285cfa10000390c0af2ac5553395266c4360da34e7eaa530fc47cd0a0e9d368e11d4f88d0c0d7837f5212793b72eab838dcebd1290f05fbafeb6dd29d1a2a91d753e761078b5beffcd0f8eddf2a2b23cb90cf9556286485c55e1c80c9ce8c2302e844472de9b9adf757ac5d675df88d32de531b027e89ac07683c2701442efbbe0613ac5aa6e8814ed0905bf5e6b09e935da175b4f99e67d1f147b2e132821a602269c81ae052caef89ed9282704422c6e71bee678c8ab7b14f286d639afd19fb375e9cd5da957c3f5a4ec15de47dcfa0b54fdece96ee859e91cd397c6c94b4efc2d3855e005933f1eba561dc1d80b2a88b223987f0f587e984ed78fb7c2848416255db0978a39f0efcdc657284835c8ab8604c4d6ea3b11efd5c681119fc44a984b3c108bd27eae20c7f24288ad36ce848b1f06090c09691cf7b77759e7935c6926cb4fd9aaf5198c6cec53426e94e60fa7bed58a88677aed8b58703b20acf496ea36f6f73585466799e0c726b2130d93ea8e0332ac9b1b75d7b111606c47bcf6bf4bd72be5e8677b66e79bd1e57063b66b1ef23f0ea90fb408990c7ac3e8dd9af348151ed1dd39f7e60602d181b65039e5f33afa2567af0e6172c421d461e25a68971821bfba0ee812569e7675cce2aa0b31542d061846b57e1cdf6d81b0570377d77858841f7dfba28643d2fab3845a0230bb0b6bb61d3fa66c868733b3a535d386d409ad17f202e0d337a982dc7bddb28f07e75d680c7008ff909369f1f3449b52edfb4496ebff699a1470a274b30a143f3e720b4bb2042d824653c67b7472a938465e047841c4ba9e15edd8df3cc3a8a7a000538bd7c0a57fcc546a78aa9238e339c9cdeaddc3829646fc8c4f998051c18e7640d9d286d11979bd90e76c230fe62487e47d4a819cf6165f73e73b388a3e2fd14acfe9005bcdd753415e0a1e814b288402bfcc1a6e5cfe3953752b828a772824a389fa9d86840052204e63939b708a2e5ddede427df57eb3c68a0b9d315f2615e39875523978adc66c515fd48fc8ccd645ccc6eaa22f2f7deb162093f0b3d1892efd1fe187b21abef739b5a52e59d05fa2578eb275dd78497e75952c92b3658bd96b525a9538fbcdf6d7e98be0f8d93ed9bf414cf049a0afca2673c430df5d6d7ab2347412f06ca750aacacca244324e1a728000744fdb57d12124fed86a9352a8db69f7f8d991b9b16c018c38c4bad064b577075b432a3a90e1f2b3c5c9106bbf32631e4b412db34cb3980e97f66112a78e702115cfd053f1fb1d2564ba8af6516d37912548206ec3c4e62b95645ce7216d4fba93bdb6d687153165516cb9223bcba8825aab8caacbdae2427be826e73b63857d6d92dbc177510f5774dc86cd798465a1658bb2b81684ff21f70e5e137863e5c255ec386d3600cd7045d185c209be14ca69c19812a100839f2788c1f543e2da8aeec06f6a0fcf63fb83fd1b6b071a5d0861187083137804cd58f593fee997ed98601a12e182846f78e4f1caeb9e6f7209d213b2ffc93801e25b8d527075e3a2aaa79f4ac8070300ed733e445438d5c0feac534e46a5e52ec34b1fe13460588364cbf10dd9c36b44fe5b478b64f0eb53d824c43c9aa1d88605f75ed899f0e45b0a8d92ae3c81b60597807c3851e903a7e870686330b21232995412ed239abc86c4c91b7fae9339fe05c427b47af1dad0963047d13efba1105a60ea3c1aae617109ed74d56012d221e9e733cf2f54491392c6d519af994c3fd374ee3ce11fc181eb58584066605ee5b5fb9f7b2920d51272e78995613d3df2efc5f5ae24e247da9498274d316043273e51b16d7ba160d433c4102bdc00247f8ef3954c8be52b473d520ca7f120c18698c183bb52114d3d0b2f49e40991c15f5e979cce262f3926952cff063f224b3ae884d5cfb4631b3096d9669e6e1d23e48db6d2b0575d4443b3e0444e5d11c7322a8b6c65d6f3a81286ebb03c2f5121928b6c8095721d8bcec8cec75a999a5dddde306bf5ce881209a6a9c9f783e7a49692f5ff2c1085f2c9a058e1297fb27b735b21184ef18d19bddc47b60f8999e02003fd13af04c232db05f0f4fab7a0c2d412317a30bae80c84813d23ef935b98e7d740f5a24ceec98ab6e1240ae396d491b2738cfb8106c75cc3ebc5ecadc194e64d6828b429823f6c41d9faeed1453140412677cdb1142421e73f59776e59e075882f0704444fa3e4e95f4c85e701330519a710c0e0d07a76d440672fcc079e24ebf929c93b2e821a19a6e58b42f118d6c77b7ecdc53761eea162f84b1c794dbf8cbf3a9e00970ff70ade3e5bf88909ec98b85bfebbd1b8ee673f1c343b23e903821c8bcd7d13512fd1255f464e60d9b7a3d12bf329474237e1c50cfce34b776d1b25f52c1293a3e6c56426a767c5c59f14735240646de62815724703fcfe703c1ec7c0c63fcd8eb48be390b603f519d0c8e496d394c6a0950ab40018f62e29f5263077f79d740004e2a6c792c33f50882c9d1fb2727c45933d8b0e88976813de4f1ba90bfa4eabaf6d460a34f5c4e731aa2d366e7fc96b13b1b3742b1d9d2f774b17ca1a02e4962bff69d42a9d636e53a83e4e5d99d0b6a805aabec4ec573edcb16afc34c0ddd732ea2577e655a20f5c0adfcd6f4184f5998f500bcd8d3c9451e050025f2d35adefe544ce6fd1a5a6597ad67ceca1a0c8dd2d970d5afa34bcb141b121286e2819f9f06d1a9810fe331ae793e84ea098399a1fab02ef1b53ea33d8a2e7e621d84b1e7b42eb0d482453c65248cb058b6459b9a76153bfe7f870528cebe396c186ee1c85987f2426a458c1a16b072013b74fe965f7b0b63f8ab3918dc1231572a9a4bcf31233d0d421f2e10262efe1c3851ab24059a7f35046c3d49e69dd9733a7c6098621d8c888607c7d0f6aee90ca4668e245a0a4836d4d7330a0aa0210d67d58aeccddec2eebd124f5b7322c444d27e5e9fdd29c56eb33cd0131186547de9f47a2a7602b26c69f8eda8883c7ac6a22080d1fb73b74f08ed5031ecfe27e0e7730647acba24899ff07c8da68278ae1085d75774c5917326dc6f4fe025a75033f362e88b4e966454330b3bf5cf1de2d1bc91e7d5896ce3f2676a895b7d251819e07544beadc00157b28d471c468126f758ccfae961a43a078dc238952f69ab5fa21f4e45c6cb66b718ca3308c7bfca96f0f76fe7607e0f50063b97458b262c94175eef681a0a3959cbbdc48d5cab7fc8fa2bec7e2ef75cf7da87fb5b5384c94d49d79c023fb97e1667ecc9fe1a1eca2235e38264197e1a779ab9843c24fd59ee137ee2c2964be6d024baca93375986d951550e1c6aaa36323bea500aa94fa90259f1865f3a1cc59ec6e0f0f49e7357c96be83a00a4221cb1ccd5140aa33cedac4b4a79e1aa279e07c39cbcd453999106bab0386a63895c8c907320b9a1e58f1098edbc5e1be71af03003890fd352b074c1eb1c8149f92567e62b07dd19b0d8d21f0e4e4845c9676aa4db02c34cf3832c6aca92ea393cf99359e93f8538fb400330a6a456c072017fe86fa0cbbfeac3850f98277186d6fdbea61de6242fdf60e202d7665819a38b7f0288b769e57a820a5d0cd8e81a9e7e0bd380b1a301f3d42f0063691444da822b60221ed23c4edd64089898296505e30f276128ab3b81a36efd5a787bcebe378bc9816470685a1c6cfa63ce7011941080ad71e6a8a47a8d084cdd43d12c0162186c5d4f8274eb59898c87c1868f2c2962d6497335ad00f6de81e89ea34c37b7088fcff34b63bb1b5fcbc75a98d35869e2868a68926d6ca18938c83348cca935733f3eef01b0cee5de35b806b409679d09222d8f1fbaa610a6ed7487304e117e4a884421d80bd1c20cdfca76e11c2d254f67c59ad39c7864e69c4fc260e1fe06c362786ca2c33b37a2dd6d698703501e7bd5dd0234b496175a304b203cebf93cba1fd557ef63193772c3981d13bd55a8767f589368af369a61d8cdfdf8187677418d4de70ffbeff9102d13143318c56edaab4a762ddcf4029c5c096b2699d87849b33f29a5667df2f775b94cab03c5847963d5eab9e4e2a997fd4e5f41ccc39f808bf7bffb33eb5d2d454325b27713ddcb47810501368b2dc34b3c9ba26cb391609233ac1f04029e0108aaddf4866775969ffba33f64a0fc69a6a45292b98f3ee077a0f4286328908a110538080fb6c014cda2ec1d2a1def979ee86e7ee23331a9114681b446d7a4af7b055cad0564d922862ef023674ba9866956706d5de1ce36631b6f5860498ef52810e4b1bc1d9e171b5acefd8d715f6844ff8b55664824f48159707f90f80a92c382b6ee25ea86942ccc3d979b5df529c43ca2596f2ecda04c256951f58609ffabc09e446cde948acbfb9ca145f7f8a2459babc8f201b5308c4aeb2e99728ec666b1287c1853b9c3d399ae04c14e35e30fc08615901f80eca55658d1d760ebff967d98c6773b5d532158c45c1682a105bf07affdbf34ffe434ecae0318817dbf9556fdcde2affed4d8394c59fa4988817ab63a37011c2c86c2909dd06053f4f637a427e7cc2df972c25444a55e385a90f98e2ac5a8dd64473f4dc7217a769ed55e503dcb2b8463250cf8f9c4ed4d31aff0b193681b7369d6aad609bfb8a26eba7e9df646daa16d2cefa667081e1b8b528efa3e6801bcfe555235e75be3a64a4ecf3623b90254570579661c3f7e5435053c3a88d75d3319f5ab6187e2337fda5b74f13093bd4ebadcbb90ed0eafe17828dc82b039999bf6b82622db9e29edf7fd0415dd6b67f86b56936a9b1696cdfa97f284ace3cb7fe96aa59392ecb00bea4acbe6381ee95bf0aee44f1cfc0ef6456efa357bd9e4c898a24bb46f6fd43ce0bb6b4e0590ff48b157f8fdf2a844250f0815ba2784c9cf72c5a4aca7e194506fd54ae7e0978b80a8513b5f0d67e97c9c9f3fe3eea663a19b63fff55537aa179ab07bc5b02c8aac6b6b3aade0ba134267ba355a7b0bc5eaf76b51596a71788413269ecff9af6dd27bf9a30a8ad99e2e5501a10233dd2609e3b4a8e7fc0a2cfcba143d6461dd03b89863f173d5f19ad2261bff902dbba8f66bd7f1c99762a1b41c3f99d342ab3bb1bb6c15e8de7edf51f696bbe0fa9fe89fcb1245dd5accf579fecfd8c0883f905172d44f773c90f553367f0c1aadb9888a7261faaa407b0e9ad14c752c8a91e93965e112fa616a19063a021b284feca84092b9ac8819b80d2584de285ea31c5089f865909f40405e905b1e9ffad124226aa57bc01aa19f0a8f8c9ed1e7f8bbf3c0917cd5c312e939e88fae9a1e73a97df19e2d9222efee714b81d975ff169e75e4535c541d59df6a38f3b9b8b014181af1a99301c187930f068d88797085b85b138ad4d13c305b9bd3fd04c3af5c7e1779d77d02928600e3bce2fb22510d2d9eefa3fb61c080a7ea520710314f28ff61c53e534f0154b4493f3a4dcd3bf389af9fb7f87d8c2a95047d40e21967fab9f0f239a46d7e20fe3b6725571ac074ac26026506c5f8787cbbd16813bcb0ba530948c6fb2ee68895ee2cc3c9368acc4eb084c6fcc7005396e5504193cb7179685a05a0a80ba82e7b0cc5cb350ed49f33c716efa03b7fd0eff3316d425787548091b6acadc8309a581843e9a83dce932001450e133f6833fc2a6edc0761dac48d04a532379095d9d4920d0f8762475c9825197409ce41889acf9391c4b7ebcb86714698fa3a6795c8f48a8732377c471ff00cd58c4bfd0964ba4bf576ad153a3bb3e0badc6ec5656045ef01baf6c76e7a27ce24ebc9f8ddb28d1efd416c07cd0b3100a017051acec8aed9c4a2bbc1f266528f393c7a6d810c08a880a5042c8200891894679fae66cb1378e05706de6384f4e38a3d6313235c7017db7f83ed02ee6a4e277178a525a7b51ec212b65210413f6e9feccc9731d838a9b4f8453a750a91d82dbb1fe6ffbefc88fa03eb6a330437115b8374cc1b0202a6602f5ed1901de5b362715c83a1b715b3ebd742ec2fd90ee3b53cc0d5099271644c392fa8192b2171a5fe51c3b78e90f456f32b09f8c35d84ceb04026d3d117abee5e6e14d87f5a3acc1237ec6001bf1a8448c464adbe09ee4b39fbff2c67d7f39e37b7001b2314fb6e6153785eddfa2f6cce361b1e72022028313761dac02e05d41ec33ad838014809e56fca4e218940b0f59a3d827dbd03f09b98baccc7c8aa12e2011a40ffdbf71589d5b43169ec1ea8d85c63edc7267a6421749a9d436c68c5ec1adff3d66029f08f743730aacb845495e83d7ce1476b413170b2ea9275e645280a175341c4825e964c778704b93dc4e8979e9b865f51b9a1a8dc4fd190ab625fc261031d1eca10cf848e756773c30a5978068c0544327ce472a84d048ff7b5259ecce082e608e1865ea075a3b22c0b88464ff6cb621be7b6c0c9cd47cf2d2a90c5b17132ca79add9f01ec36127dce8506cc0db0e047a8c9ffc0646584b9f336213908f8c8f5e7ed5ea9127a3e56df75499ca05b81e6018f0c95de9dd9fad2c82a376acffcc8714921114b3c268250dbe2f19074ee103059542d17ffae9b9c1fc27f479f6c29cce7f537b90d9bd4b53f2a1de7fb344a2b6b7f8b9925cc88d682d709489e169f130f26ab59cc47c9ad7b67b247bfa941f63463aad6d90e16c158c67a72db017795e58a7eacf1a59f1ad5d21e894ca0529fcfbf4bf17a0ce47584cb04963b7772479ac831abd2bc9cd71046f59fb22c018616da705381384a50f811f36d311c2987d6eb5f86bfd6d727aae52e7bf7997993b3b86a3197a8f227201e2c0cd4faec77a318d7605cdd615ee6c4edebcb755d07f7b3d0e4a54140c2223ce5403e40cd610d5125a81f753d3940abacfedb3cccec0dc75f161a340b8689ad4dea84c33a3a4622abc9e5050dc847c3d343a4939469c832dfd81d363aff98caeaad99eee39e5f68fa556d39ad4b316a32299c6ef10cba1a5118550c2939f30dde2cb1784e10a807e76d727e4a22984b58ca260864f545d789c93f039b63b35f743b24f536509200f00355da162e94eccf8a2dc7ee908bfa7900e33489ae58d02583c69d36b70c64b6003a237751c0dec72bfa813681c235f4b7f75d4fa88939d6778b39e758b1297d0281d06c0cd278f5d60bac9f606eeabd72abc2ed20b41ae67e40043920951c1697fb6d8a6b2a8429d342c783f6c4af8c96ce57e855bc1e529fb846019cfc92d01f955197820f7e795cc79ada58ced9b5ae70d146f3659e3dfdf89f7e5b3472fe359df9aa0b434de3ac91ed0d2b4d32e80bac4ded9ca23abd2a7429f4b41b34f4310e05e568984fb6facf2309f66f8dd3ade7456211bebb85f3e3f3dbe7edd0a145f90caa7f933de47bb0d602e903738c7dfdc4948abc81076f7cb4b836a40fd65200771389d30860b982e05ad41cba3b6160c4433274ab6ac44e974efb3007d2301b0c8221f54e667d5f82bb67f3974b9beed28e870a9cdd6644f0f4b3e0895fb03233f132b442c510cef688324db91a8d71ede319cc1a133f92b84e7b1ad2080340e727d7c450f694ef141e4622832b9c1cf6752d63872623b01b553dcda2e447a706a699053077c40fd5329aa4eb782467f20f824ca86bd440c8b81ac849f059198b71215fd8571c6794adcddbec6dc62a69d0a4e4acd4599e70d3d2c7a6f743c3ac4209604f0d06b250bdd145a6118e289d90bf4b6e1ab373b52eba05a7126418c107d219eba81868234394bf41f9a98e7aa28c98de5b15f7e6692bb9013f5ee720af29f2aea7f25de67e128c56f2d6a78cfbc496068b9db33049115668ed3603694d365bd6f86e034cfe4ce493413648e755056014b46cd0b0444de267666aa67b6acc4c79abac218cd8ea6099e18c9f0b84fc7404318b23ba0735e4c80e76bf57c9f253fa8046883595fc61e5815602fd383357d72cf8fe9aae466950dd9294cd3c88ccf4e91c9c9a808aca86edc13e9f68c973bf7b1072bb42df807acac29b30cdcbc6b755f4e28999515d4ac94de275536f6a60761af570ea506b237b528188920e9594ccf9d19dfb88033a2aaaba8cdf0cf85a986c02250b4cdd40d7ed1d2a3d48bbd07c28747176058fd626eb213cf7a7a17975961fea06d81f2f4c79dc5993e8b2a510afe6ed666310dd1125bd8992c95312582b974ea46840f17b12d9500fa4856055e218719a2d9f996cdfd62292be531854c47d3b66c73b74b46c4a9b98d4a868f2c689e551c4b84ed1c6a08f92419a476008c6b2e1772a094d9c917d0b094fcfe181bb0c260357760cc5b724b096bb05977ac953fdbf5df8fd40f7463b9fd228e78b06fb751a021317c9700cdcc1ff8365ef3890da466ce60bdfe1ac6345232bcac2ed37bd1e1acc4f1ebcb64e6997873d5fba47bb01ae78e151a3f9fdec43d4780706589d2b28c3513d2416aab3944c8061af35459bc3a595325ed6dd728bc46ea5b4c8d07dbd6303688549905d75e360de7b3bd3f2d8862caa3f2e718495d730e9899f94bc46a0626472f1794d2a3306395714e7e9ff377a749bf9a40b8a1cf0132f0e81f4e3693a3423de4a09dc46f6109d544f8f8bb673567d1a8aed05732da425b3686ae937aac693fb259fa2b195b4612eff087b42223aee2749153b7e4866f5c1d1e43bfbd77b0ecc8f34b2ed00ad1ffad1f699b93fe04acfdb7d2209ac3af6576a2f6f6b4b9eb8e6a0fde6bc65f2f344b4bff02231823ec4bff339eeb69187eeff084d1743b8917e1f6688beaf6670553d45e54a966bff5eaa87f164b7385cf71de6f62219e25acbdf1f6dae25e0b33ee4de0d8c961f43f73020c04faeb1be272e715851b25dbbbec31df695371b92bb23380ad105079d428958f99cf2b390ff03814ddc5a0aec5ac5fc70f70da21a4323cf76451a6ba86917141b3012b3106973f88a1fff0f99231ea22ffdb07c3105bde8869edb0287b283dc56ee72f8a85735041e5f44caa73bba356a13ff0526a9a950be3d77f7ea6e1316711e3858225005a96b995358fda74c175aaf57d75ec4e63b2d9427c506c7ca6235a752f9f6ebab2b722e73e3f57a60e1f474fe53efe158536b7ba61b829c5aa832ab36b09b6b452c88b3da3a3a62f2b5c7166f06fa2d6a9c20accf3301fcb28cbfa0cb34905061cd4b533ee934310834d5497197acc77501682fe44202465b2241edb5d533358cb9de4912ea095ffb021b4e5a98cc4dcaa14c9fc304108fed04d98b6a1e5267affb3df1df205e9b2098e3fd58e5113a31c5289c242c1b8b64f94fd0aed8c5963fd338f8237c7014be30f59956c7ac9423c62b34fbc61b5dcda784059b204fc06520c256df22623c947019d88b51ccb4dc42c25dc9a252ecadd3a03db332f3e20ddc3108a31e5837c1d1aae4fb3a3924698fe405d2eb7fe82c8c0acc8f2c7acadd6b3351afd52b6360900c808958149f05771d8039cf71530de943a24e88165fa7ee681dab9d25524bd83e736439682e3ac2826b93c2dfbdf74983dc9d3ae05b688543427480b8d80887766042d058d380f1b286f5ce56ed18e7ed6051fcc74d06cac65a1ef776333324deb51f8cc56dabf0b318bc4e8ce2b748867092c54bbe1f54ddc950448b08446a7ba351bc644ceffc884a6dba210a4124633bc5f116ccd3650892b236a2f70116af1e25ede7611fc7af673f4c127a2ddcd0abc08aed88054ec2afa1275af4946cb041c1f3dddf3b5d3f56d90f4f4c842038146afe1ad489c00469d93746d7a3153ca217afee8828b9424e8601c581550d64c3cfdf849ed4fd46650c9a5ef0dfe4ced9b8595f4a19312021af299ae5538708f93a013cd8794e5c762ffcbc83e7ed58c1211517489195b13ff931b04639ca69177e73f32c7bb7ff8c8b14c45bf2a928f0971a133a55620a104c5989ebe536b2e386a6a493ea388f7f218a0fa729fd3a4c207b55ac827689f669bbd04d8b93f1d793633575cc3aa9e9eff17fc69f4e71414830e52c7a9dce3b03ff968c4276cf872c4cd59661b95425da21ba34748f4f590fc2d0cca6b919b23746838975122074f2f50b9214220f4d07b7da7c7aad4b13bf74c95ec5144aa00484214b01ac9ab403ce01dbd334e3a71343dc721a826a1a67e14e0fee06e06a039c95e0b5c30cf5beb505b3580d602e6aebee66cb8ac8addc3aeda143b531bd418f171ba90821fa9b62af8e09b7c6fd5e96215ffc72ce65efe20cb79b618efdee15ff22d9bab0ba39efa5878c6567c95826285f589312a8e127570c4d5b512c981a613e23214d599b69629a5981ca90ed4e7e2e3ac5c2d737828612cf04679fda9ea9510de9e3ad36ab983a8d1ec3caa428ecef63a3959e646ed0d3989e3cd6096d605013a8f8d450f83ac3063eee4d63cba46c54bb56d0ab1e53fbbf15bb7113b63791f9845599a23e91a664af0460369ec464e033cfb7e931e3be2f5c7a9cd0b4244f3ba09ec1b43653adf1f83a4c82d2a2a237568810ecdf7e4c4cf3a60fb1c6a60c8047cb6954ec7d9548fd8183740bbc9c1603fb422faf091608a69b7e84f38b927c7f71a040be02f2d96dcacdc30e6017bbc87249593c2c5dde2989d09423d81030705d2ce1ca64187848e819f947c42fc8448b60fd9c7639be672f092962b8d8a2a6f351798f0ca6aa0d5fb075ef9bf30be73dabb7a43f76bbf1750bff4649cd309d183af8da7075d2b395f0aad9ba1913ea0adca0998c0bad036702b2c9cf83560aec3384fbdd0ccfe2fc9c97bb6192b7a9b9d18d83a87d3ea705abe05884d2289ce756387336fea604354f24517e27f763cbc3d8eb6c045432a311c904ca333372e4a3905efd19d8873b9bba343fe6303bbaea3658e056ecae96ed78db6ab5c34b1eba558b9aa567c85c2ac2be930bf73cd564162d0601362e8647a27092c9505147f53f1883fa08667cb6be9a921f88006f89c5d751f9ed98fcfe8103e7a904d46d32bde2769a938563aab88cc8513f2210954b544e543840084f0fd3c0f69b1ead37d21062982450a6fb43b77e9aafaa0b69a1334a649bd46650cf4d4b9ffeaefb4a514d75d917a2817cec8e7f7ece0702d4cbafee2f8ba6c30d31330bbf70fdb6f7680c48e52a9b42959f81f151f0420f01cbccd066298de09581395e027cc38f1dc239ef0b454d0768a240602f18ed4a5ec776465942f092bd2ab8bd20e5dd29017ee140fcfc36f9a7d2305b54ae1857e50ef7cfc7a1f5bcd05083f54eef03b944d1be454d438600ad9094dcc80f12eaf037b41ec2a5d6e4c336fc764177a7693be8761e470d4f900889d973054fcea8bf0bca15aaedfb64c1f28b7de186f9e002b0162ab2381f6c907cfadf46ef926c31e05a80047ed0099b39f165ff561ec15331db9019b9f14e0b9baffc361aaf91b528365dad1b7e9d1a8abb5b49c2bba3c27d4b39f17515dee2906e75e4ef49ff42099fb60ce4ec7c53b61dde53ff65fbc30eb0d4c04a14736cf0661bc6db8e0548fe08944f34aa2f7285e6bf4fba69809a34735e25dcedc4c9526dbd4edc2a1c6b7d66cc4bd7845a2a000de0985f5a8b654e143902e731bfadf03ffee6c1c2abe8db90cac25e47dbdb4930fa47099c3f98cf29dffd2ac39c17e8dd9fb0e5874fcea455a8290b16282804ca0d6183fe36ce1106d4223c1a3a8f482f199a525faadb3a6cb6a884cfbda71ed883663da15ef1874dd8786091707399fd8390aada277b0d94dd899650c4079089b3ef4fd381de7f30f03c116114eb3105b0a24f6590b6f8cd83ba38625a950f32a6a45205826c779affe51914b4fa5ec8f2f9b234fc8f9349a608acdce149ab9ec2c1d9cf5514a7d7c200d8778b1f3c3a1c0663a70e1f94d06067bac1d0aad6c3dad126eac384cbba62a5499cb8ee8934d918fa413e144ac4d33997cec46e62c87dd2a951755a87a4ca2d2808f5adcfe7011df3c74d0a1eb36b47aca15b09e8fe9f80980fae475134ca08a7457935b57988e6c41627730029e5b58d351b0568fc326a8ef65e5f9533413c4043bdcfda7e40aa475d34c0b04ce57f2c02bde3cac3b48cc54a4e6aa04068c40b42b8534a6ce39569cc8c60c8f3795b811366e8d0b96845511e4a02cc5f57f79dc02731c3a438375ade4f0b0aa1eb44c876e5772dd5d881811363a7e86bd7d03f3cdc3a007b51f2ec6f912d64e9bca718c074cc5464c15391252e70c3bb67469962bbb37519f593d020d6dfe4379a0e8de2a233fa17b233b8f05bdf73a16d3d6723cd2567bb09b7fc272413f3c9fa1b9b05af641682252e094dfc129a7767e2033dd8dfc9ad6a0953f607d819f30834243f579a4e6f5eccb16057a9ab1cc7cdce25584420171fa01926e5df4eee2045f5a67167635876124918ab74665d59915d3dcd395168c2a4850975f02877b9231e650370daa7cbfc5782ea28b7f9c09108296bf0d97973613884f33bbc6130db4dd4bf4de5f115a862ee25e6a92a9eea061b3622f1958dd144f77e9762730fbedd7fd144e0e3a23195bd65972f37bd64adc0405f11d3ccd0d6ae71440992fc4afc3dcb2aa7d331e0b80ff52467f66e0f0dce1e4e49b273fec811c2b5ad17b8d952a0d09e911a2c6ce1af7fb3184351bc081df2d0299ca350a80d3e015eaf2c8ec05afaef4997bc743a528686bf2edd5d73c6e1afa0b0963354bf04c9946081b89aae7e3da0f67c90953e028efa0778352b4ba86f2b5be7c0730a230f5d6bcd85760beb9641b5a06d8f9da67124917b09064963c6c6984f298edc0d256ec34add4e777cfcbb493f231d0c2091750f9caf8a31fe532bc0659070f3c2140bb03591627551f886e1de8503747d46749fe5f19a086c09e669183adbb06843f3400d90d6fa6b9332c89a05d9e1f15c26c01203644059d3eec889f5fdaf61c5de8aa4ee0343df931c24f3b48e16ac60ccdb606b352cece2f58077452442112fee3ac5b3887c91efbe8cd747a50a9b023c572d0d976182f4f34eda3792957b327c2113aa1869eb1f85f838c8e9ac9db37b8e87f7ac4d5e676696c76dab955f8daf93ef7ac324e92bd5039b1d4ba37b1c8c385af3a1d3de0335d7e1414258db90791717f1bac8cb9cc4cddde598c878314ba383407b97ad49578b7ff9ad77f070e98fe981e0206068ee38c5da68f52416a4dd78adf76127b09bc14a3b1cb795c786ea18f9a18aa8c0ccc0d37e66a2aa5f549aa247cf8ca2d045bfc0f7924022017d60e216b9b875b5ca13c1db143d048c4dc6a6f9d28d2e64207a7fce451b9cd0d308a35fb446cefc6bf8e558d2dc1a7abaeaa382c116abae3c302a75d18cc5c23a56d448606bfbdd667b5686e95571c2f8bf48e3a33dfa32922ec8c812b00ca56e870e493fb53c5f2d13351035d7be29d36a186e175b37c18f704aa93b93a18f9d631cf712cb1ae1e14db528517c99e8dd2c8bfa6009d8a25a18f2386a7a9c1ea56b76c60cc38a5a628a211b40e413b0a10236f220424e0498c84bd22c9cf22a8ea60394cd83f0879adbe356ea7b13d6d41bfcc7f8bab5b8a6a9b311f29cfd2025ab9c4e24f59dbe400ec3c45872a64304e32b328622fbbfa88e4e027a1c0cd0d26225ba1c537a150b13bc2e31a0067e932eecea4ce9e9cc6e401bf553414ba82e1e3b2ed2abf1e54abb8fd36550e389a8512d91e04d54cb74f60c1eb6d7bb7392860b4cb6e5a4490ed265c9072a803e322701360d16d79c317d74a275c5288425703ccb0984f14a6de6e25bac5f090df316f29b4d1e03ee77a93a9f2e1db6494fc17be189ecf0090f14a141f679fdced192da4c09f736196c647be7d5120ee717c05cce8cf909fafb6a71b0d3b3d3f76517b9ccaa73eb2dc2bad5fcea5b633d934091fa3baf6ecf3793a6b3807749739e30e0e4e90a3c7ed7e34c3b3703022f5eef30b224b6733a2e5ab1dfe47fe1a1c8636415c5b1ce1abe7b347364ab9e7574eae1b091cc19a78a45a8a2f995e609556fc87fa7c02868f6e18ba4012eb0025633ea2aa49428c216395593bb6bfc1909e3280ee4d66645ffa340b939a78957212836b5bebaaa455ee75799603843caf02b32a3d7b8a5cbc45b005098789524e303b418c1e348b3dc1db975733b851578345e4056fecdd85bda68f837b24915f79edf6634ac777cc34a7318e5d4c3bf145d321995b7bb3f5099ec0611346179d4b8be7083b6e84936c3f2408409983237f2e863100bc0dc2cbc3ccd0ef6030efa2eb5b83487578f0a10106d1bebe9e1555bbc262f71d7095061eaf69c257821de435a2c0b37d06d4808df2deb6c386e93dcd6fadfc6b8f882058619aabef011cb175043099aef7928dce565ac0ece04fd0965585d56130a9d77153a519caee9bb64a32c623a952803e49345a4b5beab635d58912081cd1911ff3e66318247e6d271ddab767adb8223086508c43fded65277fef06d975fe71a14ea051f974b040224470f8cf696ebc65f13621ad347223dd1c4ddaf7355ac5d530e907eaf656b6e37436491ac105a4b5fca59542730e0ac0094dcef071e261e3534987a628be2cd142431d594e18bc4ba88b0fa94a54379f4ac29a317e362749596102ecbe40341e722f0d23bc85aa2cd191fbd33900f2174a4d984f0ec0aab97320637c2e286e197aa0e7fa05f22bc5b92bcbe765e356b544119d9b0f6d8b1aae6ae2dcfa270bac04edfc4dc2215a55a6ccf92e4dadc2661472e30e1677bd1e139566bf7b48835ec1dc8b9e8c259860b59e213a79828583d688e27c5a48df9512104be45e0ebad24796afa9a9ae2ef052d6cf2c275d994905877381cf53987d3ce7c47fa39dfc79aecacb69e5b2fd091f99ba7fced41838cbaea2bd1d49f41695eb2ee2d20c36ef78a69b2bb91f13a233b315523f83916d2cda55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
