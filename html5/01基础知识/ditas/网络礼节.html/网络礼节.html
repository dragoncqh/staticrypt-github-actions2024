<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1db0eafe670d004dc9ca89034dedd3b8c81d64fe3a1d6f0fb85f2da4938b28e8e482a15ce5e1df659b799b3b0e5b59adb5c290f0d65418be9fa59f55223e89ef7e966c64b43351f198a0c0e37106487786f29128c418dfefc8df31c2f58572e1bb2c961dac577fc4e55268225e752842db3ffc4990f28f6b521d5143dedeeef728f38afaa403c032424aa9314dab5c6f3bb824155c97a718894af3ecb2ec01df445d6d62d941fbaf1cd4c3c959fef05f41e9950a87f836538b39b4e1ddc24911a6a45165f0026e3d061d642ec35009b47e6f56926793567daad5418905be8a2e695cedbfaeeea0e819e9662005c1c39453c46c4d8d74229835f9595a53fb303320e8ac6a77450469a0bcea207ac7ee3aac796bea4bd19773306c0a69d051ff23d42df360a90f9d3ac3e02285dd9537beba2db398a952d6b5ce969c904a0dabdf29c74580249a264ad1dc8992f709866996b8b6b8cf9fffa247640b070d04d0393a1fd98bf114a75b843c260cdabd7ad798da8ca11af19caf45e6a0e1458a92b5f349312f375e770462486269d52a8535a2625423e3fbd460281bff684f436f5b4410f4345cb82275ee9e5d015c231f8f8613cb4c15658a5944e9b0eb65d97941f4377cb760162e192d9588c8438a5a71b930ba5641a5e4f7e642f6cca5d73af98e4fe0faf43f1733d3d7ef55be2bbed2314e1d0ec7a4e14c4f0a2c24eb9e82c26640390e9b6b129fdc558e4ceb19883bd37b88f1600993540564d1b82e0814319666bad00c27865d68e6a6feabcbe8ebe35d9467b7ba4e4613b842b2c46aa2f3c01fecc3fd3f258cdd214619536deba692ac718fa9d9f299b6552f1c6f68ac84949a563d6b791e1aa8f52315036669bdb7e131b3c03a6293bdbe46ec532aa61104f50d64f1e4838505289f076402a5ec1cfba53a2005af4ad10f2f0c630d584b72cb731ded0147d56882a0422334508b528b5ac3220db45d7773ae0b9b0ba9c3bf8cdecb51d3dde9d6fd3b3167d41b14391a7303635d7f979a9251d79b80fb193d390b66dd2867a5c1569c2d6de4ce1288da5ce7a7ab3fc6a36822eb37dfc71821e1f38a93625b493702600b501715455799950dc37cb162ac257874a51ccec5d09acd9fc1c6e7bfb890338a0cc317c320a203118974c54eacec8cf7a8a7c7b7c092012c739f735bd9fbc8570d45ac133df41e8fa16feb63e2ccd387c07a6159436c936354653bceb3b54234aba023d53a61e319a94c8f2673e16446f5d3ef5c532dce50f3a88942116a6a9de6d787ccf0b559435f2d60f64cb25de6fdbc26154ff1ebd03ad492e6e96f0999c391aa3a3fca5759b25b982573bfec5084d4f1c155bdb206ebf5b2bc041cd975f9965069402a305f9d26c13ef13163a2085a160854707c3b01edbaf4e9831f8c0efca4d94871f302dcfb1d2a41565b3772e93d1dbd06c756a967512afe8340d9242a578c7533b32540f441da4a6685789e506dcb654ee80fe5ce050c7d92398b572f123301a6dbca9cae47a3d09ba0264596432b818d991c1823b04849a110fcba44bd1e58f88aae822b19cbb51062f91a7f474e0d136109795e36c203c6e2b589e9f34e759d7d76ec59b364d1e7ec77ff28d00f25489a7af3469ad79d65055a3f3cd47a3f978d73f22ab865bf02870c0bd59ad25e65c384896473687f81d87fa06ab4cefe0091608bf8fbbaf13cb1d097f27af2de85c99b064786028a484e794275eb23e3ce96019c62cd4c258c196d40e66537ce79ad1f261d107d5667af99d637bcb816497a8cdab5345cbd548f9925c5fb84fa27a725a78e3e9463554ab05759360c46203a52605e9d4d29c8c7f13e31615d39ce7629f412d4084a7179574eb3ef838b5339cf3140dc76150362b4e7d12931aeb67fa22eba04a232f08aeaf21629d6351d5dfaf541a71295ba323a639d6d64a1df993d42f3b24be1f27b89436d9132db066859aafe8b3bb8a475d70e2345d5b8ea6b190157fdf7bf5aa7fc193d05cc010ebac7759933e9e193e58a6a3f28da210c393cd342129cc57363424f2335f41cb4c6498480d14679a3bf35490c009e029aea2260dd4cfee573c690ee141c49485ad46c514a4e17019dcf206006c2bbe7c87af4ced25ec3f4ef000683280eb45c861211e0d41324059cd7198bc148446bd2fd8b34dc11950f07eceee6cbea2f83efef5e88f251bbff02c3315b9564907846b28e163b9b1e65df2821ad7490d47a74c359602eece7f2dbd32b969e7b4a408def5a53047351b183f96ba65e9534a6dca4f69eb42ecf012c294b8494d05e710890912be81d4d6c10fd8baf6f89b705d2c21b5ae15ec1a5c15c53915c5f8ee0612969e925db4304cae3c2a77c0850f1c11d1d379061e54a4c62a2664d5e251377807f8c4d95cdda639c6107e74f81a7437fab0bc46ead3bb0a20e4232e33e3235ea29a9c71f368ffea9e3a1dc02116b37d8f6b7185ad0235223fdd2225c75ae30202cf46fdb7250e40086d14af3f11abaffeb22909448dd5227c086c6f623b5c18d5db16d484db5ae4315893bde05a8d3a0cc6aba2446987a98fc3757178d146a27bc8891864152bba68c6ea539a0f5538ff18c54c294225713781fab0abdf60d3756cc0426852e07a4c6fa3a6a182b879332699ce8d3cf747f8c31577fe3442a4c07dfd1728c07c9d62914c376fefc01d8f34395d7ce11443aee8637ac2df7398fbbdc7a24f77a6aef37c1f06b06be11ae564321f0107c42f97c16b7984c12d689bd61cc7e587323596d1bcb6f9b097844d23370d58895bac78de30c7fd83f827bbc6f476db140055fb25ceda35ab72ce21405656c7502c2e07a511387517624a144cd6d08e04b29deaf0e1d81983aea49d588704757083aa91c3c6d83331b984a7161277a17d9c023fded2d68b50987eeab727529b21b2357e14fc4a6bb51a928475f34f5cb5f42ab71cec97107fd63eaa7941e0c6079657454423e8d5e843f68c86dacdf0ab7963be5104b3524a70cdaff6952334f05d5894afb31dc71b6cbeaf99b02be70b86b27cfd8066ad86702e86e3ff805df49bb7c7895254d475a703c82b6c175ef2e2b7082566cf2012184bac9292a019ee61b434b65d2ad9399c788bbd913b95075fa51d95cff917ce1b332f69d7405905b628b40440dd7579e68c8defc2132b7385b0caacd918e0784193afd763ed609e29b1be24eb7a23813e83d0fc2f9d7fda22737a1e0706b97f3ab11f7eeaeef3e8a0995df26f9ff27acdda1aa628f35af70f28c13e854d736ddcb3d5b9cc897d76c9f6dab138ba4dbbce62f0532449bafdaa65b0219541c6d2795fde7414dfba0d99e87e7056b95bde9393e2c7bc652ae9e72e3fbf3cc1094a4367ce0158aacc7bd879f2bafc001ec392413f807db029298699a3505932e2b29a5fc73057f56d3170094e6de5c4d74518b737cd0843bd5730d0792832434cce8f555630292dcfa9d70cfdcfcbf5bc1355d720f6cad829781b326ac565e6377816c441fe0fa82f393784866a4c3fc7724f7f53748726c5ba1f9dc890d0211dea30d45aff7dfe04ff64d8660b309f482bdb99a1c1a1970fd01299df0b05509dc2c1a81343f797854329d66dd4b78ff781565f9d61661ff42835b21ceb5ddecef7c1d252682285b19071ab3d6f451f8987ba8148b68ffdf51407f3b967cc606b9c2202f3b117270b60741f6f5983fda8c01b540055db8ae58da4f63e648107f23c64b37b7a34bd7a0f6cf008c322cc347e2a5b993bb1c200309637002baaca6a420dfffc09c2f6b878a2e2a31f14da415030b397e974d861fa4d0b54e45096fef5796c4524cf371378a44631b1938b7450147df4025e97b3bf6650eaa276e5ed07ae5cf79766accb9055b3f6eeb06436fb8ab09aeb8eb5db6a9afafa774d915411e2518c314893c8c702d5b8f5d7458d1d0767fda3a1bcdc38bb58e7500a28853376a6f6199e6c520b5d9618853397db6e0f83d8a01fbec68c93c6b169a590399402b619ffd2f805808dbcee264015bd8e38db76ffdd2c03eacd1a0e188d97b0c0c36ab1f91289f8c688019f40ab4cf38d6a00fa9201ce00dbe4b31e38bd7855f8fdb2df639e4f0a866b793f7e58fc070d5fa73680f9ead29dcc6160a322e6362c02f4d4282211544300c7a8fd4937feb442028cbbe0c40a3703cd7064587ed81f40d70166b99604ab9a142fc7400c033dd700743325a65acd9a223a6f26227add64bc97c10373e3f22f162626273fcc8509227825dfefe569e7f22b63f59efb0a91c6377b132bb1416611f820719ad99645f32dc4946b4cd978c26f4e5386034ed7daa9aec739df6e395fe5a5a196057e3c66662af56355ea42223ef08be0c83a702baf6497fa21811319947772304a873ff3e77b5c26680fc5625ba37f1612f36265729573c4a379c3f16219b43038d93a9ba89464b84e7401822af556d60121a9f94ae8fda267d5e018d4aadbe91720d08be301a1682d370457da24fe88e57e65fad0db3f6cdaa39513094fce59fda12ee48d4432367bbc1561090564cea560c59a78c910933cc0c53c9dc8f97132fc43a9ce76fabfbaf09e3d1d0d813926e79c200865ddddecafd3ad6a43b64b45a1d00692d0edad25401e5799c6f643c59b3c64934727163a13f65cb6cad74ce69ce12d380f43de70292937e1766d27e15c1ba5da7f9a34548e9d2c625b28693c0ac01c195f2a3d39cd4a167cdb90294569fce670e59b6e5f9b49d025af30b9205dbfdb0bbe2a70759ea1a680f0b7f75632765c3b222d6831604a10b08c8fe5685eb868452fcd852df281a52f5c8bddac930f691e4d59c8e7ff6c0364d3b85cd7e774b7dbe54e75ebc614b9892821d51219d801c7e981e096d1649454a4b5a99477573a928c7753e37e711818468886f75221c11b7a6adc7382402ecc86ff4c0f8026d897931ad9d440c1a5c70be2c05df65f2f439adeca8ce09952944d173265f3f09a049b41d9ece46785c6876bcd152422d26462655b2ce09fd7823266bd4bbbbfb89489cee846e4863c770415db24d4a6975335da60d9f266e3e9bb8b895df7b635ea88d0e1a4c72f64eb6c35784f28b47439b8c82b4b4b295022019da87f83a1b2cf5bf84509fa1dac0c0683b1b4b30c660c88f5525b0796512826fd5db1a00ef122953119bc393063959bd553d389962e4a7128a5611b1c53dfa361934f48dcb48d537d955b7690faa59a30b6bf9f815a60ba11475dbbac0a862fae642354adb1b7bf4ad44cd70582e291e9ec0ad50913a3dda4df4cbc8680ea3a6ba9fe1c68c6012bff240d602e774c7ec675eabe30e40e96f00cfb180212c3661a437b0dd4cd36421d0aba1c832dc679f2decadfbcb1261fdf3bafa81c2ba62d2d7ba27b417b4a7da57346782f6388944682ea986a12f285cb354a3936c2f2fe52a66fe86d434445995047b7d080e2a127fe82f54797f0268e67746deccc9ad9711e22c9e2bb389d51ec41da9965f0b37b6952e4067d8c118d058c89904080269b309fed5f68c3957604d812b93bf5845355c82535d127ed9b480834ec69ac2ee0ef51d035f3b223bbcd1126b43f5ac815a30567ca3db4ef180090eeb9f432fbfe59f7b0fc73fb4f59d880f22235b23f3c0dc5410b5d8e493b05e193cec77bd0c246e988fe527516b3222248a85815e86325522a57af1b89ef3384b430c22fc86235ad8a72e525fc6c37d7169e0655336bd536328db7cdfcc8ae6aa14e78a5c7456f9b243c541fb2ff52804c3aa47e20e2880334a12ba216a54ee7fac267adb48914a89da80eb26311af5d92ef21af7dc7d68def4abdd7221e2d7ccdb3e97ddce9c5f89bbb79f90f1249decfba69055653bac2ac7ae84600b01105ad6c6a971e89fa586002e06add316c66d8ebea6852603470495d8890bdd098df87ebb9b3918ea47efecd7b024998f5d6f0aa2960f1afb905e7ba1bbdfc4930e30cea16115e40e637940740c6aea16fab532ea8d34bd49a4c0ae17dfa21e6ba7ddc8ea81ce7900e5e9039b515bd3b21fd88c39cb60a80c5119d250ffb9319ecda5b9d06b72973dab7559d99b316422d0eb716b2ccbe6576add1c6b8b2c17e1c1ba146365c51778927725d89459d56a6727ed736272595b0d9b0f44d1de8912ef518df4a100161b9a9d402915caf82f206f05451e3264094c8da122c938cfa580d7638b9801aa708b2347eae8c960d9a5492596c8612afb686fa3a1f243eb0850d15ade679785dcd1f04a87c45abbc902469be5d2de5034f7378e700e2b2e588df164abacfb901e4332ca809559b7e3b90e3eee4fde4ab7bb04385f4a5ccef658c87fc8da2a8c1ea4835e100a5a47ce285873db9208f9330fc7f9a87c72d1408058d6f5918f0af855212626a457ab277d82cd6a3ca4d7d9d7f8e3b5f55475ea2c823ed28b6950d0f365519870d2bc0af91dcf58b75d78f5704ce950c13e565702d24241c975165e58aa671332891ce0606754e69404502e7e7cf7780befbb0b74fcb19675eb3c680b95c37016a93d473dda9cf58f448dc66cb0678c5ce2f41d34cabf462081ac97e520c71a83a81cd85fd283ce11673674695890003e83737036b88be86b34ec897b243a12c16f603eb81bddeb812e9d73227318ebde0cf5284f7584058c8e8a752fcbadffe0ff435fc28fecbea4bdbcdac9e7935c04dc3a9f8d61bc84bc35a4d0a18b56f1d3edeb43ef7272b7516bc11a6cdf984c7135e146870c1f8f9e63a15b350d5eb3933e0fdf5f18da1963ade365d598cff721c6ff30017b241501886c2eead4e10e17e2ba36df2511b93bec07af53afd904e49e3c4a460ce1b1284d935dcfd6df128da55b78df484077066fb1066292063e7bbce4a9631596887ba042497403e82aa20a9a6776e598ccb65b78d0284665d960cbefced8eadb92f2feb9e2f14e95de3352962a645e1758a93bb3305835998c1847a9c3c9be6be4163d631858aae55e3a35bc173c3b9a26aa3ea08086a3be5714099d87d7c2705f81a4d69c5675fbb218ddeb129c4e7a9323b0947b6764181a8928d1e41eb9b10b8832974c80d5ffe824bfc1d202dd5cf137bdf6374ce1c764c4a2740d11ce7a22fc80ae13e1488c8c165afc69115c6e0c2b4bc2e8371c096693f164ba74a0242e28cd7fa7fc1d198b5c2068fa32b474b49b316babafd23668eb0c57df5e7951bb5456545911130f9f2e155258c7864dd67ca6e6684106a39f3a93be1236df8cc2c41eba0bb91de9181580c4ec2f3f5a699bf34884322afe50682b9cd6cb281af9b52b7e990a8d67e3a9e37f022dd16cc0d8547995c3a2f1fd3d835955ec28727456682351478031f6343a6c2ed16791ccb13be161e30444d5dbd9a524f79b99c6fb25dc111320127c932d00c748ea6073ee100fe3f79ef195b8850d73b2562342ea2a550cf2ec6fc15dd432e2f67fa885edcc7f344e83af3991887ef38136a4c9d24eb4c16fd235f1a1ad745c9240cef4bed962419ceb81ad3511b867b8c83b7ca3f1c032d531d788a96a216eec5e49724d4e7e99c7ea5db035b25e89f3bac291c563f640de2f873a7af36657176bcde5cc51da8a393ec88cd296637d6bcea29303fea495531c5e2bad6bf5ac4c8930e37321ec355e1526e1cf6ccf97b9fbe3528c57fb29568f7775a4ffe6d1c32d9620a795eb4d669d76b0b5320955a8200808afbad9a3626dd280044a56e0d491724a6917d5e7fd2113cb63dd07c2689a12a540145db741a9d71dab9672207ac6d0ba91944f4d415187f35cf6354ffe1efc284555d68ad923a792d27248e3bac2071939b17d6e51c6442580a958a4b550d7db45857289e546b0e88eafe27ef1807d493b0689d7badb1140c188d7fcb4715e25af4854c90ccedb021d3a9bd9f5afff9baeae777d54ec6cb3b7f216f6a8bdcc71284d9434fb9da5c84e579d5c15b7f28597c0e423f858fefac079f56e076afdf54a4f5c5d0a933536b6b5b8e181d2fd55351d577e65bcf34cf7d27172cc5a647a3dbbc510df4175b1cd3ee9fbeba7ac5fc42b03efffe7191e5be57bd6d3049bc833101f9849323a7c6ba62a22e9a210887d04bfbfe4365323cb9ef3fdee6da544b6a444dc26dd625ff9d980c289a97d185228e9d2e0978541f7cddd5aa3de38a3fee30e82c05ac9b3e8596dd69c25a8d1fbf6913bcc81ec5b028fc28a1d4c28a89a801dbb82e6e727be6514b5613952bd081289d33761e7d227014cf758f70d1b45062afb6127363906fa877e803bfd52fa8593370da7ecbc53b813273de66cc5e9af6bdd2aa9a964f91fdd661d69fc8bc6dd6efaf8db95575ac86dedd31efe34f0812b8e891ba33fc83307ce5b84db38f12cd638f32c86c00833c86fa4c6b0f9b49e8a7ea45e8d7c87e335db360b317dcf895c2141a274736fb540dcd220e39e6d72fb25a9fd589655e577910677f0989332ce76a6a25fc22865de50883ccfa1f10894dacaab3e32304c261a194481e2cee09a268385ac39b0ad5eccc3c761d36e48ab2e1865142425e7a1917d16f6beeb620eab0bbcfde78db1ca3151a8329a570f63b89373af5c552556c1a7e3c95ad2d24740d125a32b52c352329757d14ddc5bfbe8943bfabfa85055840433607d557ca1a272c74e71845e9fc86944613a0fed5454504016211f1234d078d7b79ac2cd2c3c72df0569df26c3b55e8a93f4734348215105c9520b4cc8de3fe19c4306d1ca537c93a040ff1396dd5e6b9fa1dcb6743061cb1f203809dd3101111dfe29b429c059c218f94198fa1a93a2374d60038bddbd46b235d2f8fde75e57367840a317c29214770599fae03e070ae0894c950f4ec8d4adbdee4f1dc51a5f41727785f0a3ff35733080529e1ffde91ccf55915e27057e793ccf6e1b761fd0e562a7c18d528915b24cf1e501d0aacb7a49449b32d0de21f6208ce80a484133b4e4b14058f93a86f4ed9c03b4e5d4ba236ded787f3f8e1ffc5ec64eda6af23a5024db1a6ad5ff35d0303e63f1ce5cc166ffb1e4fcdfb8ab91a65f3475d9a0185d053cadc7970cf4a75078f70100266c6560d0620f50807074badf0659ab8bf22ef950e852581ae3cddf99962a8209bbcb6486d0153342aedf6ec0160ec9463b8b283e552536c31329e90f9c240758b9ddeee561e2513e37a723ee59ae4a6a7642f5c522489bf3f230bcf9832bcb4acd229ed44bf25eac386e9d8a0bfc2137f8d8af98900ae81b3633ca6b6deffb66318671e248ef484a455c2dac0cbaea033303ef1bc2c127d932ecd77c32ae79865d55915b6863e2a4d312cea40bf6ae129a20b2dd84c74d598660c10621d07a97b02bef8e640b666b6518748fb040c8060b4618951d618773d4862eb4e2c14470305695e13606c00de5e5272fcb055ce0b537c0c2fc5592284d9371b90c44f1858af3e7f038be0c5bdf1d5f631028ef2c279f324db0dd2bc10a3362fef7f2bebb7ad1eedd23b1ed17bb2dcd247d26e86f8b6399fcfa4d36279c98053985f9455c2cd8c412c385e1a3a038b78d517f71c51c6b1154d528c19331d11ca64ac7220567328d0b136fc417ae5c7744e7a041c8cde757e416aa2253a8553fc3edf56c255f82a2317b0511b735deaf882cb7783edd28c9f13c11abdd85efaae6e28ef7079df08f4622ec1afb9fc9e1a3ba15d9345b3f0d5b60fc596bc01e404bcd2c417eb2e1d4c335a5e19b91da1885b2f246d6a502b725a660fae77d4e98dd84a843844efd6938b5cf1ee012d3d15bd7bfdec0c0ce2131a9dd73d23329694cc2c9b6546e46db8de91661e206819eb1357f5917801061e71adc0a9f37493553b4ea8f6a1fae255777d40eecbd64d094baa04b7574020c5bc9a893f654717865819b54721b7ce32baa72725d36355714826ee8c324b8f016117c36e3351f8a453709dac6dff7f298df7966da25387a789a7e9ad46bc4bfbf49bc60f9e9b3f23c6cb7f76f5780a0606d4aea9d75c4c56b792b3312716cf14032fbb286d86543022298713cd7e10187f89a22a3b300dd1c744bd80b41cdefe9b40e9f20c486593bc427f8f9da07dac88453a5c569495c68224d92389d8a10ee355455fccab8f76e82e9ca19619d372bca41ece1dbf0046018e8731a209ed72746d8e3d16f57b8fa8d532d29510116f0399123a5fcb26f55435de7727d56f34ca7ac69ec0f1920bf97f6cc98a5751e662dbe47f11395404821abb32d9ad5be9541e74c82e2dba3f350c72b47568655cd7faa3546855b2b09d5d8b335c01ec10d8f1d301e559c149a379e05618372b9db337f2d3da4786c77c99886b18527c00652b148ca0667fb7e5f6fe7e86c1d095e4cfa2fb76dbc828d76177da5d7a44b801911fb6ac54615883ab15cc8543fc9998d1cda177ebd46536e24969dd33b4acb4c579fa18b03aca78396b614988606f43136affad6de7f89ecc897e2a99ebede48cb589e141a04951b78e5ba49f5ad4b4120661bccfe01fd6e305a7164a32a5be73533a0cfa38a568f82c758254e0f91297340b043fa25a811cbf540212d5a172b8329f03fa9efd776a136dfbc30d4924d10686aeff6babf7523f762b80c09d8b8af5f546481fa7f0b0bf65ec7c37f9590806d58cc4be03777041bca01710361ff7307117eccb3231796655edc6642e90dfb63990048f5b9423e7bbe05749a3b1bda7131722caf44d83dae34c9fb4d15ce9dbf8c26fb16933a28847877199985ff4fd4befe4c60fcc208e07acef2f8f10b64c8b103f9c0b454a10a471685676cd4965d2e45976f1499a537fc48a668335a60ce13f905c0e908a5adf1c8b48e4e639fd2fd304e4edf4b5a66f875891557b708363fa52d6c8197a9b2c6b13071b5d68b5ddc710c138d6c1202a6bd2f4004f24fb730c375e3439994f1bbd323bd09d4dee8dee2d072e5885c4eb87a349d7bd3c1130d6b59b5bb915563e139d451c49b32074a5f5f56773ab7fab9ff1a0a9d942b933306b5105e4023fe9b414d8b04c27c1f7df80a513901765f213238cbfed3690d27a021410c5ffe49168ece1c68c934ae7cd9fbb59317f0b96787e9076cdc984afcca7236c0a2622cef0ef7bfd7017dfc7307ce2e781e6f9d421289d74ed1b47539057284da576e6a8052201ced0ab3d54a086cb45a63809a589c5c9246b7a747525ae2a2408d4d075538e6a5fb3e1d85173ee94d7ce57bc5cb9d0b319e939ea93b14d3ca07a46ee2f741d0c374828fe5937ff5bc6f099b16a2a707f2d27fc901d02d95a1ef71e2b9333b0658e9489c7e5d79db61d72713767e135bf879f7332f557329a066024baaf5ef003f887476f29da78660772a0794a05dd7977b50485484b1471331e586a52a3d0add282adf8acd09fbc5ecd9380bceb99026c2e5213f6a600e540ea9aca78e0a236c8e1a9af4e3c95bee8db6c99eca3f65fa97a3ffb049efc95c5f18e623d085ab5dc42fcd0351d2c124fb9bdd92a34631cbb9a3531f64318faf78b6633d17ce441c1e00a25bcb2edd4d29b77608985c018430c76ad8c71e66ddff513f12f9e90bb598528b537575940d6b21d2bb06b8768500261bf66a33e7d62d1d97a5bdd934d3a10399d76060eb8f836ca56cd2fde8b90cddb07b8fffe0cb7f9241efdf6b7324663c2f83645e7a883fe8570556015e2f26bbf5154df2e3b1110ea3c2aa9d2892bd62d8ba72b3dea9d18c889cedf38da3d04b11f43958496e82184daaecb392f68aeb9d2ebed3020bab6e1005ab6f478f8d9741be03522e349aeacb731d19f676ee7515ca50cd632713dc7213a7a69fa4948311eda15743fd35e55c2bf0560133402cd6d8a3c944d7cf373e896b7f2c1b3b18c565d77ec6afc2a77cc12e9b6784baf58d456e30c381dfb26f4cb8036f3622ea890ca1a0b572ba2b02735693bdd42119c97219a5cde07a2b881a16219440c6a0e4af85e62590fb3635ad671f9c01969914c4f650d9572783979d1d14e3ad5d17e19aea19441bc066204ea4c37929e468bf788fb3035b965360b608e93b8412b761f40cecb96352af60c4c1300ae58b6b9ad98c284f3d1212a90bfba7cad406c2173e5171a89dd2a05355204557072d60b1e6f7454208b27c1e020b6c020e6a6eb27787f042be611aba7fe79637571ef5be8323cb334e167091d0edb160f750dd3d6d55c4126242bb21d55232a469d52550eaff234669560f0ccd1d3a78946264132553c8085278afb9cd9b20d90492c54245dcef8d3bd27815ddb2c3f4866c0e41a324715e8dc59ca681d2a4e8b9b4be7e41f8bbd288fec073534c8a18bba52925f78b2362a68dc5536019ca463393b633a8be73a5f6d046e02763e4ff113ace728b6a18ae93fcfe25955d2b06e8ed1cc9cabe9527a191f574653a4cd788d1dbdf50515422f48ccf6ba0cee564c660298607fb1997a0757b58b6957b932fa3d1b8877fd863a4dae5498d2df4b65a404e7b5c9ae416ed64b74bc51e9bb9c7e970c28ec4795658b80946edf158a9746482b922e5233cdf2f0b2a79e647fbc4ec11b128aa7ea6660b6cf3b7508cac8e5dc85ffe3d2e710576278e943fbcc1b1e2ba90201fa80281e377887e73ae7dbcda3439d9b4d557c30db11463cff0d9f6ee99f7ff6c629160f1d5bdca19062e08e349156398f760107a8a4080441294c00597b13c14ca12904f95d2088f3c92f8e2b1af842a53d8a83af6ea47d27e1bdac60d04f24c16f97decda8027b011cf1b2b3eb48c572dcd391bf0c51aed9ffcff0fb5cd34a2e01fd450d8e8f52013b5d82f40bc0947c8bc5a000a663de82852a842c04e0716ecd94b184fab1e68a5476bd16cc7e7011fee288b995e3362bf522dc62e6e20ced035367a9f1e653a7f5b6ab348308a21e31e38f17362c6b0dc8984b898314d3c96efcbc4b76a9cf03795e77b47b0885911b281c22e9a74f0350422cf594d4667f0abafd09eb58c847a6cff1a2491eecb5c0bcabb4b78ae6661b9a647594a8aa9e70ebfcf930333f7933e433ec201c3bb1409e348fa87bae1e8a8a9d26413651310b01673c48780896126c655e6d4c1c92e131941abd1105710e17259a5b8e3693bbadfa6588a6a68eca89d02896ea9aa2e2048b1a09409d10492d71cc66f5e392ee0cb141d9d646b35bc2067bcbf2dc8863e290061352251e9fef7eca487576bcda54be35046b1e58fa5b894364f75f7555d1db88e8533c1d9079931d1ae25a4e87a18d9cbc7bdd85545ba626057779977606ae3c01a8604ec188389345419858ad73fcd4330d10bf6efce32bbc4e26849370bdb14e2aeab0cc80b0a126ab151261972e0662616d59e572233744717688731f80478b23503c00735ed3ab6eb183af611dfccca3f609f5ee7bceaa28fc811f59a0ca6a8e0d2ad969708e468f46d0e934a01723357b9778402bbd91be9ce3400e9eac4a49621edf8e01d40af8ccac701caa911a4258b717ca5310ac03703725f086586da26d957fb3c3a7cb790c472860f99e0fc0c43bc852200fab4eb8cc7cecf0512bff19f7a26ef535d713c07a6cc16d722ed62da07e66ac080b921d46d6c6dedb771aec055d00dac6ba19688eff0806be9b53c20d7d74631ab3c18e811a4b677be6ca36611a4e25432d9035c1cbad66e20e66cd326ec95ab1fcd79aa1715c627b87688de102799d27050c48bbd40c786ea3784ffa74fdc2ab422b49e2908ebe83eb8b938a586272b5d7ed1cd38eb448707020b0bef3272140f367305ae15b49e9004cd76a0058a2bbc1f2df28bdc69e2303e945be6c95098b18b98197ab65aad8b990f19f205cb77c2acd43e489f66682a4c8dfe9d581bce027f08deeb6f684896ebd24af2fcaadb22cffa950f3c728810220e080343883e659e2c809db160e89ff51eb408e36059b818ec49c174cdec819392ed063282d1e261ae4cbe2205a278e419ef59a7f2c1e3c830aa6c3fe0a3b5c5e37071ac5e7afab6aee9fe96e061e3aeec8d2271a43aada79e9189c7a021180bbee769340e6fbee1dd42477a6179557760a0e7145653dd1f48b28e5a9de5d6209b007d9ae1e147acbf31b12599db374cec6d7bec4636cbf348335b95308caa491ee6008e345fcc2686cd0b54f6e9c40e52090ac05942b63be40fc670ed04fd54bc31e97589482cfa196d5c6569a0fec909e35e3d819d91955df5f4a11da0c4c200d54c3420e10131b3435d73865480b86bb974f887e127f91bf27a7595218980da9d0e687acafc0393c2ae407c0d82db8517006feb324709f15b11a3c96f9052b619e7b3c8a082d3eeecb26def762f11cc4286c25bd079f5b13442c96a15a226eeb4261ad1ce3540c96476a0691fb605695c07e73eb44e0e23f5e6a4a49f3754f8766661c51cb6b82dc5dd6afc09384bf5606188fb84351fa53f3ad89bafbf6d178586daaf1f087a4aa5d1b72b1e04ea78876c9cdcbc6410fe2124e7c1222787058ba3e97c60d5c18c036f0d79654c8b0f0d7f4803b2adb0827a2d9f44d1a7fc9274e0d1d1076884c196b0198dbc885823c94517385493f65a9e7692b6831259666d1ba1b391a972ef977cd2a4427bf6181f2ee93d9855df6d81e9dcb98ac1dd6e02f762cd00f9a8ab16044771bd38b6afd44bbfc17e594f8a9af7f1dc20027b208ad3e9839481637470d2e7658e116fcb17bed71c1e2ba05538aceba518291c5d659914ebe8549f2cfefd0a375801b4003c92cfc306e1face95bd0a81f9a4199c200087b13964adc8c1ab7ec248681b7520d8415892674a327024311b21e96058789e39e320545c45ba14b6315692ddae28e6f3a05b7c7d525599ad95aabf2f6649683f74ba31a8d634ab185834f0a9174ef6d50920d658a87433128856f2dbe7edbe4c7c4843a44eacb32a683a96a43f8e80dcd245b89f983d18c416a0d71c042b7117ba8015af8f0082f6a2c336922e01db9e8287cc8998ea53b499552914673defd0b0719699ce81dfa0210c8bd20c228f68972b08780cec9b17512c0d038f812dbe1b448b63d741486416bac75e46b91b1e47a4bef8985d65127d1c8f872db26be25bce90018f96a301fd9e652bf217a5b213b6cb260caad0e4754d43d4a1f11027f933c3758ac78d0bcf88c712e03344ab7c77a1d4ec13d8bcc03e93d8138acaf1cff842f4c5e0cf23f8782918ba39f89a524ea8989e3dcb7bbea223c781ade55e9569a0e914ed03f8b9790245cdf379e77a9689c068f764d40d0482062cd7677fdaed006d69da84a095557a507c6d7889721b1fcd752165118e5d1d9a56cad34c13c5eb745851ac2adbef9aac62e9f793bb7b322e2fdd5bf3b9b602b96cb5e16913e21fa51e2eb9255bb9397c40ef3d2a5e5ae8cb368ef39751111cfc74decebfb80b8d61e38acbbb08953be8e22f0d568a354f1ce7dbac17ea44d55de97420d54e3277234bbf518ab60ad170435a4394b961a46f12a68bdbc0c8701010f7f90b6cd780493acad87aa484ecedbf71935e116bb4421817aba264aa0c7c4b6f3a586886f99351dbd40fa59fb1c9b310733b370cc535989fc916c4bf98023c8e97b539e014b1342cf6a170b65e268c5025492b147a8050999b17970a403e96c7349d6615d7fef89e57c482844ff93dba322cb1f076b5f39394cf2dabac50593f271d46881d4689618ac14c6a5fd423f9138e3a03cbd80ed066164bd275e72de77af401563857385872f8fed4ea9377d1f56eefed2cfea6137c21fac18d7a05364403e35ecb077f8ac3c4f6f36cbd5f8eb706c3632edc45eea9075c457a1531aba82e58d0e8b8c9285876442504d72bb1f22b2afdca5e5ba8edf7a58d019558f569f1754b08b11cb58e24d56fe56502543efaf9e6163d2a5e56fafff7070e163fb2164eab760e89607523e0c7c00bab61defb8bf684b4e06e6c32028a2e2f84d9db8a5eefbe769e18f5cb98760e30c2f1024627d05488208d0ba6f6e06be412d8c18fe24936424118e294753371806082315ec1434e9e6da8ba73b3edacbfc35e961bbca933117c150bae68307d2ba4eae7c0189cf6c1f86a3b413c0d053e96de958ac4bd57c1ad634febcfdb54355ef6eb162dc5ffb64aa5a18909aa82d633b9c77fdde90ba170049e27f104a2c6f9ead7481b61968902ba9571b7f86596c9f52fa73d4b0e333fae641afb47c61d40cae1679eb20a3c83799d79894970ca757aa3b7f7d2ad906457e41ffd6a5af1a0856a877f1e9d278cd15f3bf8721957331cb20171611992c5afbb182bc55815ae2e813928ca88b1678c0506273ed8e844eac634051c9682c4c82919d8cb4ac91ab8fba4ad9e4f645135ecc14b9a8a3f1972c04a954eadd9f347763bfd4583757a7869790800d3cc44568dd0ee0ad6b0f3eed48ecd0869f5acca2739e72ac0eeddf91310a6e237061ff836c5fa75b52759df4936e093ad765f7b202f0c1b71df4a1d68a199ff5f4436d14ffc11fb9b69b1292e5661bc774b12b398efb481fd85123bdc84d97a8826563ed4f4173a13171422b54eba05db6b395480b76ea3208a11624a1a3df0b04f70bcb17dd1414bb2a8b96edf08dde0b103cd85293ccc1d27242b167450df472a32faac86100b7fe3b89943a95377285da49223b1424b230a5acf7aa0c50078a0e6f6eadb1f195aac43a8fafad222e677d93dffface6388f70823bdbc71835122d4e3ad41e8b21afb7afa922d4ec6a13f0c001e15e8a2a95edcde6df7d3952c59e64b50c95f4d3e006bdca7211fae5c9dc4244ed2730c3f5397d29f6c8cd5ad5362b232784c3ee532f9d7bd033b15ed5ddef5fda39603113d608c9c1f6933406363b4dcc47fcff9f0a1b39c2ec62cad6b3936a6606e4468719651a1ac9ee281bc093d9dc2a6a1584fce25e479adc809634e68471da86ea380c45a8c453b43998903d552f08242269a5839a9f37c679a2ded4eaa1c1f2fdcda1a1bfd178445ad99430d181c3b822ce4e2d9e1ed670287f0abb0d3cfc4ddfa7f09b0cc855b43e9f7bca7ac316ef5b3518ef298a0464f739968e0744b338d32dea4aaf3bc512bac29f3fc34f2810b1dd9eea9e1d28b1bf708116bcc3636ee753bb6ef816437338cb8689c37cd1c45e24743e59d4dfa526f859214733c8e4536d394805c67dba5696d3f93643eb17820ef5295ceab89cd86938f77e87879b164ee0e034671f918c7f4e2b6c03f174b55d0e91c9e5333a03d3557e286945cb44d0cec762b54bb9d6f753dd09655e9735c2ce2c2e949576e8f5f32c5fc0d48114f88f5fe2ed2815dcce022eaa1cb0d76e9240d2bfcaf7d6784aacbcbd3ce6deb891bd608d21373c1daf0b7994052d0e087131eeab43c40236c88f9be6e2b0703062561129196d54726d93b3fca48ffd5d6ee7ddfa24d0cc37b5a27dce7bab40beda22faf3f0984476be873a701697af582bfbb8c034c8912d299699835898dd6c0e96ba5a8e82cc1bcb973a53812d39caa2771535e473b54fe49b6b53f5bb4f8729aebedbfbec6a529792c7bb49755f4120259d5f83e6b7371d254b2ce234aa375ff66dbc94414ed486a5465ab8b0e3a09553530057aae8db7b9fb9a324f681b255b08a72b602657b33d629656cc8372b07ac3c5bc0f186288560e12f26d410d8386b3698758cac5d9824d6f8c6c3c4a117295fcf2661397e271a93119d27a467e987c91a54474200e59e813db868d4ff0fcc64b663b227bb7e482b61b8a33d5bfc57f5f587c07e908fd8f96104ec2a4d9689c7ddce8a471cb175ef2e957e26020dc49b87e3bfab06b04cc05c5fb304c0fdc766d15d79a89b65516b4254468eb1c8f789f065d35428a9830c51ce35c375aaae374187aaf4fe359940cf6cf2d24be6a7fd24bb601c06f19599620da80ba6072ad8fd6c50ea6e6d78fdf2467fea14efa570c54d23b77e602d6347c533287580020867bd68bf9f47f9fb27733e7248d7acabb5100320407dd6eaf9d9a6a04b0215d649b3d0227dc8c28bcd8cb6ddd803fc5255590e08b480b02848b67c798a4773ce6c346cba4f210cda8d4a52381eeb3297ae9080a2f08a5458fc6ff8975ab1b8b45f7753bd820fbabfdb157e22cd9c0a213bfa055551fd30c2108bbd9a47a1ab2ccf340b9e6b47606af65cdd09b371299f0ded53626ec504e02a3272c3ab5bc39d9d705a690917eae8cef0b6d52fd13e4b02d8e10d2f851401f6059de90783f16d064c077264034967437291c6ade4b0451b0dc6ffa48bc73d418671d5ee1112d912d2650cb2b4efe0ddf98c054207d749a149fcf486d634dce4088044ad4e0be0bf7a15110a725c2c5140bda9769c84cc7f92df606f3457a3f61111c384529acafb191b5f7399145fa7d7ca3c1a20adf8b12f6d33d733e9e5c6b7d18e07438757c34e124a5cd82dbb6d211afa95b077925ea17a6d3a5cb013571ba212318df24878fdc22f7055340d39283661a8696982dbcbcfde648d3fa290460c0cc8d10a064be75bb8789daaa2c5a2e2c4cac4987d8768d2cf854c743300758af101b0995ae522d930b2367c98884cddcb44223111a50aea7a841775b9d32910eff9503cc7f09f5f3974ebe93da2997018d667016c3b6465dddcfe806ce367a30e37df66148f6a7ce1830a72467529e124e664d8ed851fc50ed450dbedc85aee88a1d336d6e56a7c231312577ad5b58528ad19af9fb75e786897597c42947f09ac95104d3d693ea7283d8769ad093c7fef4d79b15150c0d028ebc4be9526b61eaf529dcbec179316fe97883f11fe80e22368a844dbb725c3f96f49dfa849d5d6ab73b5cb898e4da8b70f6abaa4cff4b2fd629e4b3edfd62e6104f7489b0f8ea7d856ab86cd7effabe3ad845ebee655662c5b0f657f18f324d6efa2dd7338b819d00eb5d8a1145aecd866f944f7fbc48811c76030312bc85d75bb7ac16e7caeb2dccffb7c825e3c5c9ef239e667b20ea6d3e0f474dc3341ba4aa43c754a7a89908432d71637dcf4d6e946a5ceb8b6c12e66d3216a7f0859487a3cd73959e5d19ff704b5ab6b1f4cd0bf5791d9d72bddd3cf00e359798b1d060b717e7f7d3efdb707e0bd3ffe39d596fb3dd3f46f003277ffa17df7cf6f360830ccac0b8251818daeff1baac4c98c0042aeebde352d1125c38e12ae9d6c036d99f80f32108c9724851ff7c5170aea87d73ad6e2a99e3801e32cd427115e95635998fb922e48d6217d9199e610ea964f45ff1b1bb044e4f20c7f32e8e6aceaf1e020ca10478d3c42f910ab5507fe184f024e6390d3cf2b0b7a6f28c6ac145ce14fc55f9b6e084cbf4544ecfbb1df270e4f6165a856efa969d0befb8962ad4b1f6de316d822564ca1dfcdd3a11c2da61dda2324bc4ecf247bad3a149ae5ef2eade326f6115db5e4751872f8e4a7cdb431dc7cab6e6d8c53834fb7a2368decf863fd3543e70b016c4ab0b6d115006d6438385d07e272f786cc6958121edeb6d176ad10b4f76f16c4e3728ac0460c0c21b55dd3575ebf539284e72c912975d41ca651443a81134b6e53fe39b711680ed0cc3d7c284ca169242c34cc03f364651a4ae74b49b577cd2016cfe3c018ede75b43a8c946dee5624d9b37006267cf4d5a213bcc2c1e4336a77e30ab635cbc6bc557c4c3e4fb11da3eaa86f54cbce2dcf14ca7eb9a709bc24c3efc61ff02041708586bc70f0eee7b70ae0d2f847be09a346c5e1dd6886434e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
