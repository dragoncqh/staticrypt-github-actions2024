<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"59199236f48c985729308f1e0dcc8b441b6ab24423fd91f1af6d7b5511829522c6831baa64a79eef4e56b35ffab198ddc4ab3ee39cb9638b4b22740994d61cd1687d8935a48cbb93353aba98c4dbfda492995fd6da62ffcf30c6813482f6027f4e199476a127065fb3900a6aa7b91e9ec820261fe326aab9301d7e8c54a15283ea49e6f2c360a0c6ad6c3a9be6a5d58dd644df405c528a4305e0dbb506a31fc551207c3ff700e6948231fad7e0358d6cbea9514b0d718c979c8cc667f47575af6092935cbf3d6c5dde6b3658cdabf06f1142f9723c4f1eb4d6e4a38636691e540f52cb118059af07954b70e353ed928eec4de5abbfd1d53aa3b22b2accc2bdb79502ae1951c373c257a0ebf8f58d4bd7580130708e8fa10b2e66deca88e939b7a920bf672d2ac1fcc7ae6de2a94684345ae0ae5ca62473c5de6a41b67b799b5095286fd098f51431d46aa0d36a96827fad45e0176f91b2bb344ccf6911d0e40426a09aa32bbc1013855a3492aa09ea89c424019a384d215dccdb5f60d5c7c4ed4ea52d7d93b5168417cd69802f3f3c307a89a39c663aa733ad5fc29dd5b65cda0b91ef53abc1168e0afe48d05375090b5b8ce297f7df21d37af3b959656becbe03db732addf4f65b81dea931ee6d6f10618204044e349d0e3d88d8dc6a55403b957c1430e6ddb2893cadc4be7432852974d5b5933055a7a0a282cf4609000b92b7cb68736612039967a16e95f91c7d79a19ce778a1af6bf94828c0013eae903e2fdf460d2457254150a4f52a704a05780c9109bc83b276c3748773967601c89d5a993662d7748085089339ad58c06253de7ff163b9c659b06d8edd831ce7b55054e3d539078cf870bcbc094be60c28df8463686ea710d50bcee6602c28d5a85bdb8aeb9108e437736171022431a980e175b667021be4fb70ae654ba4e9b168c6f31e86121573156e9c33566d6846c6faaf20e84837b342b9d3cf173ce67682b90584e81868f14f7f927d05ae2ef9b52936427ebce5c15a4125740c1522bdf9656d45f71eb8d10fedd186f298b8a22d623b5a4b997705297bfe53fcbb836dbb69bd80ae82b387678a706f839d1a6c71198173f220462e818594d5ca21f07431cd371a5a02c4bce3c54af4b7ccc42bb1cd9c437aa06ea5409dcd3534cea18be8695745beca36084313e712abd261907994c3dc462ece8759bfc981214956559023fd37d814c7f7d08754e1acae13475295f97c9e601c6c4e4e252431c8314cfbb4ccc2ebc578820d7e93111e8ecf80589494844330ba1963b7e1e1eba12bfaf71d4300de8a6a77af59d80164f7f1eab786cb6a894733a08a2918d2999de4ec152b5fbbda8192f29e66c20e83590cce37244e839349232a83e4039058ae1ef11b7b72190dba2e2c8b66b37c9e1ed00079485fb06f34edc162cd5a9a76c5033970b19877f54ffaed8de99dbac8e7768cfa652792890a39c4f1559c308858b07b36fd2d2f1e5c22fd756a3b7b70a8e50a18536575503964b4799dafaa8df8a1a4dc94b87a2df3b1d2a3fc9356356eb402ffb5b5f01b592481754ad730e87611d6e3e7c412c015493997d50ef0ff2c5be99cbb3d23555ff4b02baa12882e523f46f5523aa55c8ba5a3b9137e1b42720e099cbc0eec81306236ac118499c5e7640d6ac23c95d63b469fb700c1c6615a016f79fb35f4b39a9ea25c778532bc03073d14ba4176af5ce3b4ef7386a5f4ff82d097b494d9b494a80b4ff9dd4cdac72373573a44112c5973bdd45267a6ef400c939082f9cef4736959f971ded31f311470a4cc71337596b37be9888bbb9503fb71775b97e80767be4b1f043306b7ab4cba54481980a8967a143ad0342628b6c6bf70b3f182af6509b3f365a0e231b2feaba10028446e6ed062ef3e9ddb91e0c7e60db03d9f51aaaac36fc8a28e23976997ac4478a8e3c5de14fdd635b8e8772096d0649ee0e99da6bf6b0cfe8110876951a94aecbd324545e35122571abdb9acdc70c7eef719b911dcc5010eaea53c6b54f160057cefba7c6fa6861d12e9e16837beb194b699759a7bdcc8121ea1165cedf1f4f3843e9c1f1c9dc536499486defdc4416dcf9a1c7c2cbda5723269bb47d7ed08011f45124548ec50ff7cd79c690e09aa0e20f91c8aac59458f0a19ce304b9c54813d33b1f7cefbd9acc5462ea933e7be29ad5c9e32cb5387cfc6e692a89d8f81577e8f91d9839ef6ba69ab5e962a2d5d04a281b7c7e534a3de48f7ccd710d9dbf889a4e0b961289ace80061aee9adf55e229024c08ff0640d86d92385668d47aa20a996b013b0b32831dc9593f9f5f2ed9370b13da406465971d96e3b4941ab840d300dca3135549ef1f396502694ae1336b074a54a7a23c027ab0c35b7214b32e18968357469a5f82277eee758864eb73080cdee3dddee80500d409fc1ab0d472927090e339f2744f9e9ec7ca8e8b5899822709b1b630cf2ab2746cdc6aee885cac9d39094f47e8a362b0d912d4953548634ccf2e5c035352381e528077724f273966477c06599382ed502cce52a10afa06d273f1fa57f99ca8a2fa7d83a6904a46428889fc976981fbdb19bbb88b6486d90675d3ec680cf16e3bc8d32fbc7c84deedd1ac5077e69e19575c9fe248a771cd7334f6ad6ea2141d433c1b4a3b2d4bc311e53088231a5e9e2a4cb12b4e44628059aba7514b7490da9b124b11d642704d2b9f92168936e8793ff31e22a853efa1b7e382d99d82b900bd42639320df8888c0d703abb38ed7d5cc145cb74d99fb9483a422180732e1e8c4c056334d6c39605af3a1a208960410c383c39361b80fe145927a03fcfc9910a5412b1a10e1bb0143849a791eb407a90707b56e7253e52f3264dc411e1a67a919279f4944596acdcb61476074ea85fd3d7ad926e4ec6d1cd48859bddcc3be918fba8e77f43bbd4bf2d359bf8ead6ce94dd82814c3a9840bc093e8e4d386eafb5498b1af53a4f58f1e6f9ff007c85c32c8e96831fd3f7e726933d74117deaee7fc5085d280b6be3abc6798336be98018e1494b44aec409b20528ad86ae113e100245996b31c5fe295f1ca4f27c0d9d44bcb60cc002baeb98274566cf7ca00f6309f4aae767419e9291b5962ace2b72c118c816b8a871133a5f2b26d939b2649b9dac8d8586d4d93ce02eeaf39841e72c8382280e39c606164730fd2fe064fc1afdc28da0aea84b0ab14f037434a140ec6208052a54c276b7b3749b0885420380bf4def5238fde44bcec0644aff79e6b9772895b51f85fb7d77bb78f73935dc12cfa87f7652bcf4d758c17dd870e6a43eb5b6828cab8d24a9ef9c992bf2b6acbe5bee81f48e918e9f2f1774726eeeb4fe6d4e7c71962bf8ad413baef9ce1e8ed0efd683cbf41ad3ca26a27e948b21fec3bf8962e7910632742a46236962eea374a162e6a82b612cec6aeccbabdae2758b61b826c85ab99e0e22b826a14f9b0114cb56b9ebebbd4a10b594c1885e0e46dda8866a23852a12eff00ed96274bbca2606459ff13f21ad3736fd79e2bfa908874b69b51fa2da7ec05368000c29f9a3541f04706589e52b1684cd0fa2010452e4eb315faa3c728d5ca34fd357684bae19b9dd7191f255e48f632f618c23c12b01ee82f450d2a96320a2a0bfcc36922d074bc529f44af22b5130568ce655f2725da940866f950e5369478063a255bcf293fba91e0e9f8b99de9e54d49698a3d8b5fcc1369931091dd6d78b5068eec56d175f2b43cff491190aeb4c010405170fb1b03fb26eb65413b303ad05cd699cc71ca7a23c3d88f0d6233636053f6fc6e0bd00d24c0f506280961dc9371f9c4dca4f382a01d7fa8ac3f8e10ac295e3bfd68fb3ed8a33aac17406477a105ce8566b9597151c9b3d71031f53dd1551cfb91f3b99bc0e95acdcc1a85880661b6411c2cb7ad61e6c72a17210a912ee63db977cb3da0fea3779222f2608235a53ea160f4ab3fd1b1109388f1bf25c778c86bb7697149a7b0c494496e426bf2237dd68533b968e50bcb02227cf6a65358974315e31038b7c684c9965df8b8ae15532a4c3e36774e9d6c408c02f930318909fff45f111a95a9e22165b7bca8fc0ea9879bd8d6bb971df2fcae798ca893193d6f20af7930b327fce72c51548efff698b6e9335ee255b0e6815655de7cb5a83c7b66f5a4f5e7ce6c5a7936e0393473e98071066b63721e40375793682d757d048e7862ce551489aaa53aa1a083abdeb2d95d943913290b6d849f1bb5128253a3a2388a708d689ef8724c463f7b5f788095ca929c9c60d59ff767e591af476b64871bce6ecaa3d819d9b0f764af0caac1d0d487751b72ef336874764d132b1bd436ba92e9743b27dd89c328c3fb4a8c743be0b5f617cd64efafd5870e6ff02ab96dd047f7a93e63d6434f07911e03fc52d6f3216e849941f600d29c0e0fd2e77c8d42c8e68b7364e91ff0530ab64c59743f14671cb3a1915982f6b13e3c3ffef4cc18ef8e571511f10304fc3cc3c311793990683c4cb2aa1f107bbb785b4a574c02b3b5eaa0354d98ff3d5d61ceb9c634f537f026d52a4608d24eae423f4b5d5cd22ef4d341da89c925e3679ceeb52c24f9ac7faedf92d24991956a2a92f16dcb5612d054ffb289b5f7d81f9dba9713b42ef7e37372729895b28b1086c8ed2bf98e1dddfca19534a548f6efce9c0ed207dbdcc9680401a783a30754c193ea22a229bd5ad30eb73bd9afb27c18e930a0052219423ded401045f64ff0307c4243804e0745ce14eb7bdd5163e702f6d5c43ad9ab2b5721fc3e17cd2175bff36b40f60d5ea5962378bbf24c14db62dca82a5188dbeb64fbd969764a402fa865984c11c2355ef33e63773f59725cb8316dc867e4c252c600ad96e7a04fed381b3d156c62b3d7cad45e4c46063b38885e797ebfce9d5d47a54aa1eda34fbe60e2897712030ab4f054d1d166560de3b812922c7c4e6baf36831be607ff38648e2cd8fc34ade48a94f8eb84ebb2e9868a4ae207df8d597840752e881ba8233a5906db7b8879e790389f2563b9d5600eb1478c50d402f44a7526e9278c868bc4899bc7e6833e510a92a0440806e017c500076c7080f625e03f484a693309e3c932bebc6c834b3c6892c45c57eb520253844ff3d775abe8f0deba15c43ebde51fd1bd02b62900d778fede7d4f8cc006bb54270b0180d16e539c13fd7fdf3895e9b8cd5852eb005dae00445083b05cdba17098bf53ec579c5f382842815ea3afbe3e0f933d3302fc0dcfedf11bfdbb129e6cc4b38633924da0c558e1aec75627b26e4749aba6280ca19fd2743392db48a123eeb65684e515334031f925569a15462ef783dcac5117a7735e1e71c6b0304a5dbd17fe4620ede5aa0a7b71a91515ce73fba2369ac42a3ab9857055f78e8fae3084254b2a993d0916c878d3b6ac49e911a6c06374d386f48b4953d0732dcc2d15d5f8b81860eb1331ea2c3d3db6e65fa5ed65c7aa24bb04b1af826cc4de0c9390612c4e2600d491091c307214d25df7d1c62bea5d43adff4384fb05fc0526a0fce3bbbfbaac0c628f949c03ad75fd13116951ac37207357191b6c5cf922dd39643e929b32bafae6e8f33738a23ff9ee97ad4d68d0f21e31cbeec24e854bcd3b3d54ebcd5d1669546356eb1bcde1fe9ec4a2687d54f6b6cfe24aa02ac276c80331b05cd0b85d11c83513674c166dbf344a77e18be43a54cba56786dbbabd3600a7deebbd51b687055d1151bc491a747de62d060c7cbc212048be3d70439775a115b5d4fa0a3caba010c95142751a5f2bb1043fc092e9162e1a9ff16c611dadea1a428857fb2e88fb6303fa4b365d2b954c6ddba341a9ecaca2230f213766d215cb2f334c33c176a9ce411593ac298d0fe21dde73a477bfc8e2b87abd6aad240fd70a2a38284122049f933ff3cbe8fe1cab9ed597d5565e7338d2491fecdcaac29b1cdcdfb7d020b508a7ff9c9a6a44b22d63997ffc222c9701a308ef2e1ef9cc4e4bdbffded56f19e7eef0a3a9dfc47efd6d955a67e3eda23798e229cdc9848c33d6afcf236e2db2d14cf5d9f7712a33ecc4df84a391e9be75247ccd01f4106aff6b1c8438bb3aed831908ed5a8aedb44431b412afc9db3146e12fb5f0b90028475d802095347c8dee188f42ec285195c922d6c257e8f7a39f19d3e20ebecd0bda1c53957d0b20ad9cff7044d40a3d31e16c7b5ed6a7145ada8527e06171d779bccb584c933b70220ca7953a98b82b7cee247af85cdff572f0534c8c0409409dd54c02151732a6c88de29ac93d407ce2914b3d9587a4611be519130cd9cb1c7b040b66f78b0b50425342381d94c10f51e204fa2d2b06f73afcbc9768b697f3f55926d8ba14b82f43fbd5fff610bbc49acf1eb1251154d79ceb88993eed6a1689e75a1014bef63afb9b91f871653414135009360e3cdadc41746b15c33da66df5034e7470b8232ae31525ca7088ab39bf8589ab97eeb1024cce5f0f93bd9ba85267e931e124790bf5296af0027e5b17c52b8bad33aaa9a7a7ad10c4db6cf4c145494dc803633047ac35ee439fb4c52beaaba471c5c92a5a749aed0a9e4b3f63ebc9f116c669449770223e6c42bc47a34c7024deec1afbfe4f1c372c9df2d807c0441e8f952551efb61c6457306c50579d7bd671a7ef426365387dfead34c375be2e352bdb3fbbbabaf31587a9a0c26435a50692856bcffc772b014a5d5982bd29381e42eeebbb9cca807375e3c7c3bc0fe56d34a075e8ed077fb77a2b7561b9918d03fe88533f56c54e661174f4c68741a1044165d64520353fce3d0d60cce672e1f39cd1c4367b9e8abc01c8daf09e43bf3be416078726c5d2fed85a6ef492cc201a3a66ad85ee35179d4f639571a1522abe98ce13cb58fd5fac64579bd6e4ed601cea4cb1ba5eff4fe762900f127a9c9bb9c9be28514132312f7213a14452a3fae441b0707e053f4b8fdb3ece2e51ba133432e6f54ca63caf1076d0c861c40ae05817b010155dbf868534e4a209673ca2e51c5c19c6220625f90e9d46fc93696d4c03024709547c700f7b4528245f8524f71c1373aab8e28dcdec38aac602ed48ceac89fadc4abb535ef0f36c0f7e0c2456913f08625d6b71714ad11651dd8ff35af455a729ab357b243bb1f6a8248d6b708601b5583cbd4905b83bedfd848a82416267bbfbdd7d4a4b84aa14a705893e6763fbc74b8d454fde07473134a084c002bf2c4043a15ac41f9f7c6ddc0a01de3beb3f3adf18d37c2133bd6ec966c1ee6d71a0d4af7f17fae6a44403e33d6fe3374a06bac346cd9b026914d165894a38e17c5366f1d14b8614ee43dadf4461c2172fa675682a0a1ea80b19eea6123840e5b38a54ca87675a6284ab8c847dd4734ebb79d204d5f935ccfa30052c3cb735e8e04c1521543440f8cb85f0062f4829785e3296a7934e063848b87fdb05a2bc73bbd13d5dfced9e65100e971c20dad12fd445a2ee1e6997e68066a633a25feb3417c300ef53db99782ed107540b83c2a7354b8561e62839137b13acf7c3c750e0b8afe86f9e699eaa1b5f072f5f1094336307ad34502f0f18089b22040a3997486ce239ffeca74da7dd16aa6164748eb26dbbae425f5211c48a09d730e04763084e1cf1ed48a7e1f06e0f14a527dca31594e3655696642b54d7b1cc311d928170b9a640db95e2d766705fc0ac744fb22171121fa4275c7297bf147c120051b15f6c3da2f76fa4d0e80cf8302fc3aa575120362d4d1969a2a9bbf97239f2a3ec30ad56ed3027f8c4b8b8174a497eedad2512919cc3d94c24def116cf1ffa7195c8446c4fef9e067c41706dc3aebf5683750efe43ea0e8a384523e01db2cf949aa1ab5abad0d40fa345a0d199ab3e2a85cb375bf667cf7e88e9593a2d8f7264b309c6d3d61aebcbead9bda0cf38041e2e00c1e1e5ae5da3d97f4f0543f7a8e081e6c80ed2040352715bd272ae9d32d963391ec7bf40857b4e495677246482730c7726a9c319f8d3bb125ce4255adfe7ae3eb165f854aed13b5e699861a129ee163fb73d788be33d75780033dbd2616ed1a4972c9485452bb78d4434ed989cdfcfb6506ef1ba398fe07144ffd038f9d32bad0cb4a3b354a527bf33104ef8480b7333c9a60d8334c5a5fd7ee8b0c789f00397b1135aa67dd3551c4bf5a85283bee5e7ac20c6ed7736c4004b746660b3387bacda93179494ebf998ede0de20561903fcfc397e6781785c7467558957468b93d9ebce968e333a45839e368a6c56232028dbba2bf25bee929d0f7c83b07ff66f182d3b127c326b921aa6df83e479dcac0e7fedc06300df2f7c07b501ac95fed168f43a7d85250d62d4b458938d6ef651815cde35334e6cd83988b7576e75061cf99f3d079a0105d1b8653954113496bbf53ee2c017f01c130e0011d80753fea3e02d423e8044651efc4e1cd513e2c267d0fad323cbacc3ea4795725cb7fdaf6b701ea7d0d5502421b6fcce05ca47bb1175a62cf927a310252dec3424f57c0d61935d77672239a234a72d2ad2469f077c939b450932001bc63c6b4a4ddbd154f80196e7c63efa0830d6f655611af4bf82a5fc94ab67138f9616e98aab7ff0eba01d0712cc0b04001e50e804ab1167fddb45f7969ea73db20f4420eb7f75fd2eeafd743146a5102b47c130c0577ac8a03ca9a2424c9fa562e56aeb667e4cafcb6ccac807dad38bb1dbe7314b7b9d8175c66cd87c1a83dad69b92aea64a12b787fb160c332fb453d5b28251487f9b31d33927115b2ccc9c9977ed7f6191c31fdb2eb6ce8c99189df71c776de48f98d52dc445a7f66d57b9527d4dac5aef31c3f006ef05b8d6d1ac31ecd0dbb7003fad5f7cf222687709ff4bb6231334220530f6e77ba75cf63ec518738c409dee0eeb9f8241ca08a5ee595ab90f92290899b39a9978974a2c7290ca488f4fc078097e21403e5efd6d39f31cc037aad1248ec9cde7768d3546164fafd66e38c8cacd1946dacf75587f97bb746a636348bb3b7c2698d485ad33bc2eeca94e55fb9dfa3094d60e5a933b51bb0dd7da9c8d6350656b714abf35dbeba90d1c89d9907c77bf4993855c0f57e921cd08160bbe29cc0ac802ad96fdc1361948b3862c1dc171ee8fc9adfef7061c0100dfaf1b441dd4e655cd5d3ea0d1457f7fd53921c7169d1efd274cc453729e77c6d38532d022708f688ea8f23ba8f56af6b24717d4d33f0a3a4862eea71d41d9977d7aef1f57bc51058fd65ce571764a969fe485eee5d172c2d81885392526b0c6db7a5ecf17347f285dadc98040b06a562b86a4cf4f7afab8650f87cfb6cd1f561f1caaf6c1f442ff3d0eb5d5b7adcd553e817f806c9588707c6497dfc945245c8b21d4de90bc1e0c55854a4a11f5942fbdb5f69c829715482434e34983077e2adbb06ea8b98ebf857e71f81087f14eb8fde6e85866d1dc1294536fb7f4a9418319a85a32eb855b6f99f441918c89ddd33113aa10baa2635a2c809e8ebacbcdb720307d5d733f74f0ee1bbc63ff4ab592073f055234b1f3ac935b35ddb25068beeac698eabbadd04f5050ab345127580622e1a918aeec9507249bd9a8bb8711d6a8d3eba5b94722632a4acc74d73b567f317d5d32251758704b5a93b1c08cd15827a81eb60c4acdacc0d03e227559b9973b7d8a0eb431af96953eb04363cdecbc64494e002a6cfd438f40865579637411a2d6e0f8efab1e568b10aad8818f89d719e09a14928830573fdb4039582a179844551f8607185d23b01db1736254ba7c23d11d8e8d8db3fa75564a5533dc9045d63c87a7bc352faa49bbc1974912cff1125dc250a8e4a6784159a2b6f044cdd68fc33c5b7b01cf7c9c7fb0d6d1577cd7df48e1428d3b13d2e380e35306771def842b47603d01564a06e172d8c1192490d62e52054c8c64d3bd3b839d83958d0d2183d151e7b3d275731e9bda5ca16713053358a68febc249c6ac987cdde713af40f38b00d514e653b091731f7defbe1fb8c4cce4e72d94f9797c8ebf434322009b50dffd8bd7a1984d541e6e05b193afc88fb2eef8b88c38a037ffcefe09783932af222df3af9e9d52a58de9f51f6bfea0d5a4629212a45d49d913f071b6f56aa095d30d65af2a42a61099e3e93c8a8c911d3e53afd304c088eadd9110537eb97ef35df2b6b3e2d74d081fc2d7af6d8e4c4573d9ec4ffd534a1f4710d7ca2d8aae1ddb7b4846b020a9bfdfc11f394d25d81488290feef15c3c88e03273a47ff50c44597f9643f5f1041a3867bbf547cd3864e388885abcaea9dd72dc1f7930f9f9772adc193994852228114312ac62d06a36854773ff5b0101388dede1846df15c19432e8703250dadbbbc3afce1afedca188b86f09c967fa888af2acdf3c5206644f7fdeebf6391e03815348258f8a047707d5623a739aa0f285677075cfcb66a485d17485a454564f015439d1ed4eb47191026168942b7a1845e9c7e39c1b2fef617fe05f617e7bfa01ef714c216f1e225c37b56694ea198ddb08cf75954c47eeb42c7e5d3dd16505fc3cb8c20ec0dfaf67367447c37e9009955fbcc7c407eebbd51895d0460e3464d65538afb7a2324576d9c6b4e2d4684d099e53325c44c24e31e7bbf43889584b234e1e162f7a736500fc76f7ded36b1030b23c524281b740f4d444ba9cb3232cf3ed9cb143602dafd9017da4aa25eeca10f4b2c6f7ed2ebebb8d47eb527e26534450246f9c8a73d53eae96881399c80a83f8644d8a40e1dc86088243df5700b3a66900972bd3387ca5e08aaf9a3a8edd537af06070dba22e24ada46c624a2f0a4470d7854c36522f2e338bab121dd658c21705ce4f54ce2dbb18a808de64487a39d0e43efbfd2ec1fca1130fad02c6193ded70cba628e908ce1715599cb91b23d825770c932023e51a249a2fa3e776cb0f31e35bd62644cb1418984f2d00ff470698dcf5b42db0b1d6eba1e169d06c0e9208d41f87af3bf6b8d6c5250e8f7ffdf27f18ff2459885077515fa0e0dd29ce9ef05780fe5826249623db5450738020981d8e1a74ff82d3f31955a26abaf8e675339d54107652cf4ca2a8d4c8a9da059715e78e5b746f37035805a20b98ed21486334c612f16a5bf3e427e2f5e6ed0b1986eb9303a3a49d27adff16f5a4a4ddfc244b6bfd7fd576dce1f04e5a7c7ace0e3c978f25c7c026fb04da78965f7c942046f8bea1a5637f7cbdbaee0fec613e5395da641cdef00181538b52c1a29900611e7a939f53b877c8e5bd6734a556b796ef198c90cd675ddbd56b69e2b51a08b046ef87c32e05ca1f7c8cbf1ef3f98253abb313eab00f351c1c1f660553c0f76acfb718217f43c0fdc8538b05c131d97625e145ed731e40b73f02f86165255df88828b9e512f491988c319b253f940684e3d3116dc4b4eecc687bc99981d3e10bbc27926b4e5002acda7c4a7c36a08fa597eda972c0cefe8f0bb52ad75637569829ab9a75a9a8f9a54e1641708b7f46e6bf18fd78d77c0b42b1303bec984ba3c91670904d28ce451c92ecfbc8e2074fe20e0cc31b02d304e01e5b4e04b7d2db06c7d6df32cfccab274a4c065065f15446f830eb6cb76495a33e070f1986b7456669ed230dc29fb84d1ee011f996fd42f62178be6c6c4e29b64a57988e99c79230a1a9c69f47af8ba5cd88f340b617c42aea5667482e8f77a020c3caa5561c0864d84258bf811a98d6d6f9ce11cc792b7295728a2ae80baf6955f84808cf786a94c1e977f40a641bb91e0e62065a3b7b5f45f2920a707fb348d42533f608ba9fe92e2533524832d6c5398c3e125633a9665060c60b77a354e52a853bccb4067b0d95dc26be1a9dcfd134b52fc461bd4bbb3717aba2a0b7e6d441a3a3da485bd390cc5413e262b3d09cb56191630f9f7d5bcff871f46b579020014b4f0012d4274b52b2c1957dc5de56d07a9c24f46ef73f8a069f1f5a5b524a8a8b21703f275b2237a2c937e331e39672218c247af2fcb03d64776daeabe1e1ac928c02cc0b053801e7947a29a9b2e899693e93c515dda28185767a5e263bc3a44138ee63be578a10e51114dc80ba2af2eda7f42c1915e57d08598758e478734b421103c453fbf52c15133491f19fb7211335314f34bf90d243207466ff91452139c3e6881d4563ef29e12c1b1e07c5f4163d6143bb583319e2e370af00a7b5c099804093234e97056994c9d13420390f5e6ddbddfe1444fb028860d057040c0a59954361798b59ee0eafd4210ace35b97726519bd91e301f188f0e7d2b53de5f206305dd2b2b1010922a83777ecc0bb426d8089068a538933bda266194ab0aafd684b0392e233aea188e88ca7e100d5a922591be3d727588e872844c51918a943a756243eedf496d1840572c6dedc21a76383cc84672f9aece49f61bfdbbd3847ecd9f51622c73f4f01bb783590fd7a79de3541bd48a3300981b8d375f956d255559285c7e0f3d31381c1db79790cd69062a3307a587b5ad2146ae1ed00de2d47905f28996ee0f88bf1d4350c153c912c1c3016dd21acbcd0fc836a90f73c1c3f8ca68f522fd1cdc2a2877e7269fbbb7f73df944a7dd44581945f198c8ac68220dcda76acf80ce8078f4c6d777780030d1ec244f55710bac5d716693d8d755b12a02df0bef0a54a0e2a76a9f995766f1c9548b50138b4c807ecc9291d934308e18031e07017a72628d56f47439dc64cbd1997ca2c61023902a8916f33fe1f6b4142a0bb497058228c5c6ae86c93b8d43cc4ada792baecc261be0ca25de783ceb61f55422c2913ca839dfbe433cc5e7cd45c1c4e20149fd603a04fcc122e63a9dadeb863becafb780d488617fc5f3d094eb2b439c561fb8d723245f16fa6817812fcd19ae890df86c997db9638b44f94890b6e22b73aea7b3608b4b2b270da3dba536cca21e894a36e0456decc448ee3592718ce20db5421255edfe738eedba349464149c9e9f2e376aa2877fb51ac142ae09a67a0fab6c34004f57f4fd4a57c261f12450421bfe4ef7f8c24bc30ae15d2d9ac62052ad2b9b09232e71d91a599c2409cb1deccbbe1fb91eb4561b3c08c05d171747cb7c8b586c48ad23066da2f256fc6479befecc36b7e879b305048469d641eb47b06035d708233b40676e265bf9f78aa56b5d9350c943158175a8a18bc044f8d92ff3e648766d4d3c25fbf4f4bd652c8316a1422084e029edacfda9d7de793e96095a5e390fc12f59e07bb95f1e41c489b89f21265d74ed515ae474780b86116d479e3370ef22aa52146b205441a0cd81c55d2f83bd45fd062648e7799adafb7f346bd3a5b25f10fac00e0fb06e51ac0d1f24d71cac4014f2e38497effddf692d4a3b683881af60ff0d8d3191698cdd154741cdfbbda6f7e247184c5cc667d2ffb92df4c33317a7d1ffd407671101562ca716cb5c636c67fdd81f9bde37fc85d7e983e31f62caf5d07523cf8f38ccaafa8cb5bb5001f5b5c1f9d0b76c8c246e43118556a5de4b7182ca556d33b0e7ddd6dcf008092943f864d4cbc3be6d0598605a42cd22f2e73f93353b9432c5bac5268289d04bbb6d250030b6f50bac56042a399b5681e2e4186fa9e8cfd4ce8cd05ff11b38814e70e5fdc7134c2079283dfa1b8a53dbe3f0fbe3326853ed947895c5f25e120c4fe704eece6e563d1803a235b848ebf46e0aa9ff6c3b2c87030616317c9e533913efc124099acf953f0bd777a250ad89601167e9952b6803d9fc63c4dc3659f7a30aecfc60257b0c86e0d70be76593ae0726dbf4a7d0e7bc7e043d689146cd9a724cede6df0417ddd46321e187ab8b9ee0f64869aa41fc4c91c0cc7927278c4f429ea2576a6f8a3105795d3e9b2dc2b428df86f459377eff2e5cf0f9c46179bc9837fce1e8d4d3948af5b48e86c5f64c7305490c17f9dc7c8e7d0e63972452c9581c2225f1a753c5abaa0115b13e7c0bbd1b255fbc9540b13923190fb220e729fc4785969312be276174549c627b78b47faa4e8479bc42e592aa8eff088e66989544345cd523efd0e3a4593a1beec0cf33d9c3d8cdc6c651726c47a1432a11f4b42372b61c891ee37619228d2f7e86b879acd4a037f4bf60b0642f4c7979ce270aa7ff663a1fa98656b0472d574f827cb3251e0ee20af83d8a3063322705dc2386495d363f60be47e245fee5543716e225f7e46a77b3c6f6fbc8f6dd607d5c47d0ecd40a0eebdce02592f0e3157d8d88a8fead4cad290100d895c8bd247ff401648adadf4c1d1eeab9167eeff1e13f38cc9f0bcff19365476f501bec130ede8e8e4bf3f7d5eb79642d7f684447d3e239fe67b714a15133a1e6e286458a9fc025dec2df141f4c50d020310745d1d47b4f2b4744d4ee683edde57c7d769c84e4883a9538375cd58d81ff3984254d5e0c62bf3899f04862e8b01bc0b05f4b577387de76137cea42bcbaf233190d6f411aa9c9cd6e5808b4e567a1179e7258730f5aef304fb1ce02ead8e440bd197e9ea4c16e6dd29ddde6ded54a2ddcdea6b9f2ab9fee5d22fa13ec8929ae72fa45eacc45e15fefd2e7fd5c086c36ae8b5703b01d2892b54904fc95300af789b74ef258cb3bb6cb4342682eba2ccb7d356cbcf1e4f53fe900a1f217ad796c70b8882755f4187c3bceda20f79cc871276069302335786efeadd11bcfac8e6e6292046a45f2dffe80e3aff5a03676a6f2dab0592b215b4216180512cb7cba247d5524441068e7d9149ca4e790fe5170f955de96c8ce62ce264e44c48ef1cee66b7bca4ec2b2d5a479f617dd811cf163efa162306ba712e074738b09914d405e99b538ebd58de9b1e34f05850fe3b8084cb98a379dd0ab0a8bf6ab56e8e6387bc890d3c66a6ae3d4b51067a4ad2a6afefd9185ea811652e08c2fa484405dad88fbeef9735bb0b0706343af789ad2e8cad2bec93dcf0b2a5b5cf2bd57fcdf1068ec1d9f6f4c27d380b9e9ce7134320c28cd817b7cb8d76a0ff382c5443abef72d9359c8e154cfb1e03cb3e712d8cd41e7e6201ba1037b716b6bcba6517c444b80760035f91895f343b3e3d86b35103b00215b7c3a11f1022795989a810aeec9ad6001464574d0e01bc6d85f5070b8a5380e5509c77b78ec69a53d85abdd491e31f862b3b1ec33df53842393f7e728b8c0ffb56ec5e9947547e648814268d0e98a625a6dbff29fa68a9fc2fe2fea56944be7b4eba378cfb209f5c12f0c9a6d2ddfdfced7249b3fd7507a9e17a784361a1219f93882f0806cfcbae23c8c5d16851f7fb42ea446d3a5ea362ab9e9dccd2efaa36f69d3770c3776bbb447f16fed214c9dd8607eca5ad1e798924faedfdd4c7f572ebdd1461aa4bab786f56c198a306e2c2c1c86feb43eab20840fc3447f349f8212a2afbae2d067dd4ad64dd19bbd7e34b8c74e2279aeeb0542bdd1ae708aad15953e22806e1d4511acc2af9915ae4a77601a3fc7a8d6eef02fa61f0fe4e8ec8f99f421b96be4c2c5ca6dce3ac76adb92b5ca393d058a5d049b0db3517c17a4930d1ef4bb104f67e7ed131887acb1599d9136dc7d3429721efac6ed06bdfa207ea9fb1a47b5c89961285b7e0c40f5483e2a9a7b76a7d340444543a3090eec48fb976dbe3798eaecc3668083995f7fcefe30543b8997f9af249fabaa37550bffd0e8e4a58d89f3718a8de475329eac3839cae9a68082c6685b3f2b596607863d7b993c0a8dd17dd43eb7568f55d5d2738815ac1ee544828f4e3eed141fdc1cc8f3c440c997023441bcea596adb664f6ceee1e6bbf67553252ec2e66372c082fde113d72e734eca189cb42a0259b44e929fbede627aef8f761128cebb5ac8f936b46ad29a215393494da068ff615f9d51a5b80ae1b68990144516deefe759ecd391dda1e8151922f6d435db0c7e487086de56e0d3b38ec41d9ea711e090811179fb2ca760b09f13dbd9a47c0b2ab6b5d4b8b64e3eb99f838a311be2c0a4295f2c5998904a3ebaba291fbd3fcb43577b68c085afe8f976c703bc0c4c8c98a3820b1c52fc6bf6dc1fa17b6519f75c0ed965481aaa88ce803e39ece456fc6787d7d65c0aa422769f24e41585ca3010b7f5bebd3a40a4b2c32ad1624f6116d69762b35b1a8868c2dff0bce13272bc28112d3be9ec9a9deec07d2ba46ad031012dfbd8d6e86e37d5f7a454be0e35ecbc0f80bbe8fe338c52d1068515071f750517f14186ad43839d96618033947272339ff4d801b56d369ae80d892bad0d55da7e604c7fce3813e07fdf4070b52a95a2c36c5294adfbdd89bbac6702c3d082c557c7f8c83382d7ff839688ba6068c4503321c32f480bc33f9d163201d9afd424b8293289cf514db759b6c50ca85f23fc75e466e5477085b5d364500c803fbc08a88a0fd083ea099d8e37788b981642e9f26cede702166c694ca517cd5cc1f3f0e8e25cfb61432d81edaeca11b3122145aaefdc2a9337c181310580e8da81cf5e3ea4169009cde269f512a43969f39111f2bf0d75675bd5c306796703d00c675a3f96e0171cfc3a2b8f001c4b252dc051a9a429d8fa36dd18377db442dfb2ab68709c1d46727526d865e7ae187067f45b7dcfb0403577b52f9c655456ecf966f7c7ec271e605a026bcdd793dd4932b7828eabbc2e6b37f8616e68651787f60e613dfff2a8bff5f190b04cc39ea45787a4a56b1ed87b58e95503b64209bd3b4c4f1e576dfebe5dd2cb41ff2289867e94a6250b343a090e1f7d291a6b309bf7aa7669a481be8fde01a7e6b8e9aefc4ecce07683f3a82c446acb3f149fb49d1dce7652a0ccdbc2d19d328fe17d195cf9ee8f8464928db2fdf598c629b5612b70f80380e0658c88b3fb98b71a1c66bdad76f2113fdae9cfc02eef8d457be829e3dc4db02dc67068324c7fa6201f6835367c407c41a484165a262ebe3231b1aabd7368bd7bbaa182d61b0afb5f94c21821a4c3a7dd06a962b8989e07617263081e638d7d283e85b937c557ee58532fb780a530ff6c10a32caeefb779ca3a11a031cf55509d0d321a77241a1d3e2b568b3fb072fc19f7140cfd2625d099dd85e88610f173714612c5b15488b4f917dfdffaf946f3a627528419ab2d73f06b09a487bae56b3fabd7f4ac85ae1bdf84557b21562f4acfe591935518ba58d4cd3476074634f4304b8800d827f26ad470b6c78eca1aa5d11b00bdd59b76c8fe938ad9c347cf84e797b536f5d63cd599a0c107b7ec77bbd2f00007883bbb3261b231c13d574ee5761f6fd98315abc254f614b3f3e4fd5ef29ec45cd365da4b2e833ad82d221eee2ea75367a0feb4243d34db58f41401fca516480ba0f6b5245c0e1e83e0b76517d69838a6795ab9199dd1e2262a5648be0f29a28da8e50a7db152b58d689742a3a660bfa2e4ba7bd53f3a83c60a4539694da8098e633fd8d4d8993a8a0c26524838965c8281bf05ad17dd3c3844e64137db44c77dafa85b189372ba8a58d6ddfe06655032dc4b19b811d0e5710f66003e1ec80374040c0af408a585f4e4f6a03f2002c8e825dfa5a65957e8ba3d4ec10c5a38e7c511f0e588cdc848ad56991f1b1afb8d70577a7ab8884f084760d482057b30dccb34eae44fc6e27963475b1c7590049b7e9d49d66755259e5b6580c7fa75aa5f1a8c0280c00646a2d2b5df10e40ea2cb6d608f7a8ebbc740b33a7203df3fff51e53ec6aaaae21438836f8cb05c7331e3595b59645b7ed113081912869e8b21384a596c361a52d1a18ba8c2e7dfa9d41f518a29bf3089fbf956ab0ff25f95704e4f44c27d6df90a8132c7e05c6dd3755019d82d39eb12d37fd6fd5e113492601acbe2fb9e4819e28f86700a8054e63e1c77d05ce2a274fb6c965a67e8cb14287ed008b2c05052d6f182cfefa39ef9379f6129a4b7f0d50c06c26e2d8217aa1de5317f2aaac9d86df5907a689b722809de5be20296ea468ad73b168b64686de8660e4d80cf5a31d40249750c04438001a8e9d3abe1fb5310454c1e65392ea6cee4b67a746581adece1d0163e9627b738c738efefe8b3d21d0a2aa483c6a17b8f6a98ee440aa95b04402be67cd10aeabdb033a215b93111a255203d147cc49c4c6f0f38f2735497345b54559021597464846a5c273a2bfb981249747d9efbf91d717c782e348dfc650e95efc5f288fa72b98c158274f0ef5eaccc4f06554c67e3e6466f2ffdc436e075464818f9702a7af2d8e2ba1d1a6f36e9be58597715dd09eaef1203d5784f4e95ed8f6eac213f0305a6a512f170272883240700f1173d2be512daf67aa1193282a9665ed2ad68b1c59805b59019e8df3bda419b03893db938b339dc56472bb10e35ce438358cb97f14065d44673784df8af49250071c7246ca4aeb8407960c6f7bda72fad2387944c995c3d2ae521c6e4dcfa4227b24f11cbd584f5884b7019dcfe983380983f141820413dd4e069b0ee89fd6de3fd5f1814d3fdafc514737b17fadde0d2ca5cf2f05b6902558395648d03c7272c93c877f7b955ac359666aa23d942d38bec454977cf3bae2ae53d6510e3704f91288f2633d7158b50d01188cc37b47b14da0530dadd62f80460f0efc65857a7d2e2cf96ea88088833ad7ada007ce49ed1dadb09e16462e29c59c89b8774a9da726ed0f392e79fdf4fd56b54001e87ea2eb442e2cb513e9355924a01260617fa9390e98cb2c9465a9403befd5af6435ce1009fb6894bda982ba2c1b284791953d3a5eca2f6317642563b384f8dd87c73cf3cdd4c9ab2857a47f3225c98483328b3935a6d21c6a0d1a592082d23fb5509769670aaa6d9b3d6efb89eebdf8c3154ae5652f5ff50a9c9b11d230338b8ab385e34bd0dc60e89cac5b14a673da93c46ea2e9f02a398111a3972349b0d36dcedee78ea9f131ccf1acde4f57d88289f606f533acd40297897bebac73c8f72cef71e995b9bb9579b9ae15f0d734092fdf28807dab3fe9022701accf29ac0e1d7650ae8cb91d0cc57ea81b3ff72e4c8e14336a96c6dbd717eceadff0efd4aafc4151ff4c7ffbad5e77d338d6060da983f82d11e9794cfdfbc96691ceff37f7ad439dc2fcd7bf698ac97e665c47b118e98429f63f0701f1fa238796d2ab99f3ce614e20e3c64f3ef5b888bcc0220e7d0609618ee180e0a8f9c7f9c92cb240a767bd5e47adcea11c0d7c6c5169bfdc41a6680d05a95ed014c56e878bf60e3aec92b70ebb91a663ffbaf75905f0983470cfd4b511b9109ff51262eb561d3864be6df551c84cea93a927d34b0d7cceb991a5efac22e41059aee611dbbc6f81469929012cea0303e6d1b75b6790c66efedaf24dd2b94277aa85aee58264285f54db3533bb07a0323b24acce266f33df2bdcd47aa5dd549c0cf4cde83c73340e88ef8ee18450b31bfa0f103223a6637d6ad25716b2bc9611c64484faa1419c0d915147d722b3266f396b6c0531bfb46fb1f4809d3ff2f895b3f59afd931e42ecb15edcf2b75225242211ff351b9544a2049215c00bff4b5dc953f8b05aa34a82ed873441db7bfdd25d7d12fd9749fcf17d66389026f79df060d7297afc82050f58d036147e00fde279682327925c34162368854b27219968328265633e53e2254b9125ee90bc58d551ed2f26ac833395d259259289309add20d9fa5e40d4a2227551f408a995be20bc3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
