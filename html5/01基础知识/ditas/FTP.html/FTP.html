<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b7f9b0709c090acecfad10fce98f8399c3bd778d6791464b99db7cc41011d64f573cf2b48843d6a813a3e2331650e9f4701af578d6cd4a09ceec3e7f3966483dd70a7eaa0ddb2f98636d766ccaf74cd9b063b1eb9890b33fb53b219ff128edc11bf68f077a1003ba926fe0f13141c24547f292b52ddc73f8a7ed352c761e422dc561d21595e89a4739bb10eb5cc8a891ab122fc591dee33eff8e877fdc6447c1e987cdc7a9136c0ada8f84e0c8ab809a979a9613c3949d5dbaf7437777f6e44bc3a861acb297480a0fbf2f6d6feceb139eb580ccacab0e8b090346b724c6b1ffd016c8c6afa8d9f4755f7e9e6f0976a25de0d6ffa17390c45b8c751fd9cf747aa6e38e220c154dfd905eddeee3d8ea66604ab588a2653b85f17edd72bda99d49e817fc9299f8c87b279da8e21976260c95b372329936c6443c1bde03d22952a8cb5d8f2575068123cb10aaf3f0be0c7e33cf847d37bb7ab457517b222aae5ccbf80ef5dd174a58a4b67aea48cf806fd62b88cc790fb4948a6e739f5685e85990a0f42410adf20e637a350a09782108f829821626e02753949e6f21a81605d893e38a362581e6a7ad780031cb6e039eded7d9e3678c2c1df36363bdb575e63c214a9a6fd2b5f12ffd64952111f4532d25397acedb48a4fba01b66fa5a93dbe9b6e37492534bbd986fe3076ed553a7bd9ef1f7fe0351ddbcbdc4e201d06ed7e42fac85bbf3722b37e94712f68bc3e14169274bffe2189391183b85d0ea1d54d3a5451b42629e3d0bf61540e20187c5e6f91683913330785599fd11e5572583448d1f87c3da6a889494b0f168220b8a33bd1e8ae32dafe9de641d929fbc1c0e8f41a79b0844ba908163534f92cd681957b98116b24ca783a2a2b9e94587e1f53f129b3d6f4e847c9d3e5088d1b2cbad87289046f26e2c648b0fe1c5baa8c285fc65dde26bb57b58426ba69db665f14b1644f1d9560dd29cf2f3f0313ef44f0fbcd4deec18c8fe4fff7894e8dbd65656940184b5e2b5280fb3981ce369fccfb063848af40228fa53b3f535b1072f3fc2809e9f2317ede8d518abcf8dfec55e1049b4e8640190f62ecb3d2931a91644dbdf459c5a3e17e93f79fddcb45bc5a687a60045db799b197f577e8839c7591c6ba552f0bcdef92bcec1643a3b86fba5edf94824978aee59f6c2cb25f0cb4553e2abb02ce6148f6814fa17c9141de2ecdd3fbfedfd3a647475a3268790679987f55884584918e2a2cb610f7db7162889a1f4b41b06ff88c150f683b2f85c9c4a05d7df6b68ee4b5fe83059a9606cb0532bf6f8015bf9c250a780394a68adf2c473a9e768b09325380ae733a207493c938fcb81ad1c0f05301f5b3390fdbcefc6c8e530612cb497c15e954958889d99c7c0d0eff0782c0aba295d0349c7667860ed53f6876fb1f09f551462c8c5227434b942e39734c8866a639dc7809977ac327256b3c8179046bf761ceff4259eb833be9e3cf13418ca79a9eccae0132c25cf9e89a78d3bb0de9cefc840d53527dcb5f566a307a79ddea10879a97b27e0ef9686de1177813755da4ec2253ac4e95bfb8db2f1791067ec7b5051c4fce64b8493222952cc23e7b0ac2934e2a7db9d0d4c0cd13e3188721d9e13154dfa7a8e8fc273019e71850d57ea7eb5736d1cb5d0ed0808b7ab62082499c0f4cabb18cee8f9907671d5f84bd811ea5706783977cc6a792dc67aeda2acbc1f040a2df527717d1337f192e3b5c72defa4e5f7724dccf6652d3554c68590db4de56424d72481885c57aacd6328bef4dda9033064495f947b235d629b4dfcd1e9948570197ee17c0530d7a91dc46dcdc8d25decebbf8c14ebd7d1d0c4595fb6d16d12ba3955ab7d7e8047f69b096034c4d1d76bac148c31bc1b5c976ac4d00b122349374ba130d4853fecb570aa3fb80e73de046f76df9ab3703c05f64ca53f56762150dc995ee2a38247d870f64805d10c2c7afc62c2bac130ccdc57fc47b97647b9f8fa4afec545b1e59b4cc56d2bea77a1b1c59bf0ecbd07f278bc8f3ffec03fca0de2d9f3bfc2b368c774d5ebc47c8bcea5b9b65c1ec61d8880ff2c007e18df802d2b6a7f2b9a01eeed1baba791e2b94c2a3b6f7680a67601256b960be1b2bb0caf0f65d14ad8ad2ccbadf29aad9c6f8accc753a9385090601b2876412df48c2cfad47a6b5a3458a9d658defeb6fe338306957996e328f174c7de7479dff91c68274ad8d0c02aae8140451a163114e7506a0c0a69948b1408e595a67b055be275f2e051b3518afd3423797bed3e3c33279d94bd44eaef93e38229bc866a2c93b3199a544314ed9af853270dbc78635e24455acd893294f9e9e4f2238465694d12618f798b6845ff9abfebea2176a4ffcf2227aa71819ab18b8743ba7d2c39a3a4045e48462b915698309e2031287e425aff3af0ac8141f66c48036d43255f04d4945492f5b0ac6a9c128478f5866b8c405ab09a4c3f63a81ff1fcd80cad2df2f162725e2ade1e63939e8338f2faca4e6903857a43517e992863401827715959305f8d181dc83555fc7bd4c787f5354788439f9c9bcfb4e7e7ac50206ef08b3b0020f1e5fb98dc984f8ac0315f6bca03db5f6870563c8d20875c109c30d58c80d1a5f3c3b532d99785a55f53d90928ac14044c63c5ee6d9aa2c5aaec41d5f5b5cf6dd07d9ba924ddd60c5faec80233dc1f3a5041fad24902e0a233ac269a572eae45ea7e27a4f8cb6f7db46568db072dfc9c09667c4367b002f66e5c759a386260e1ce2d0b561a3dfa24cafa1ea470e4a32f38edcb6ff5f9ffa7c8956f6611417f112f2f9fc62c6c85a1ac68ae1a043608bb1d571604c7b6e12e56142a717a6e3749926e362fdb8defb6a6cf6b2a2d68c0477a2f0f239b057b8182ce64a18cd0a97b5d122ad79d8210a4866f86c3d01530202ea127761be930f0744514fa19d97d5e54b8df31408c98c344e36c030278f6212442c77063fd1337dba1bc902b6ead8d7f279143f826f335a691434181297b0ed702849b3c6c44f3070c0087d5c117a427a3c18644f988d9f3ec36107cd957908a3ce88d93227e9bc69243d28b1ef39ebe254524a9ee93866eb4ca36252a3f7ff8f7fc52a285b50f41413a4cafb4bc1c52654d9cbc4bb108efa3ee9dfdac23ab5bd39355ade4e6a0af9ceeebb2f1191507d3c056b6b84237b68f33a55957e264742dcb39de4668ad39b4b6904b1609f3c316bc0f8a4a74ab2ae076e7fb9ff062bde064fcf657c2bed6da998483c4eb145df38e3a216f1720b0cb2000cfeb86fcb69261bca6575cd007c0222c0fc24f25b694d27c9a6239d25a4d4ca00f86d0953535f0ffe8bda1856d7fa69f41c0c79189a832b9acdda836e4e3c8156bfcc725f99916eea0f48880fd9b4cfd59d636132fd395bc05ff128a18e1d31a3bd31ab5dc50819d2188301492f45fcc118038c14ee0a370af958ac835fe85ff5410322ff0fb880d88af9ac8fe8c583e3792df09db80c6121273c93eea662185fd95c5a8642b082a12dd4721a07b8ae28eb9be8ab9cb72597dc6ad2ac59af2f667e82532d8036a295a36145fd20a8f2f14d491c2867ba33f41126b603931d55fc61583bfc5d888c346b6ec2ae0a80abebb18384e242e8434a383a5716f9507e9137a5140730e58d26a9d086285816bc4dc8ab81245babc21c4f76ba86dcc95fb69a2ef26b599fd0a045f594ba5f450b12b032cf676cd238d963c268be3f3575fcc35047eaf2a0263e5d706141e551abc70fd971fd62d516b59e06c154be2607e109b15173f88c3091e6fc8cb9d01c85c6267b7d0f917a2f962ee85773b7df48c9e554d41e035c2a75054e19bd1185eb9cf74db60761fbc2417c1d4795388c2a30b1bd24727f004577a5c6ce91850ba58b483c7f416cde0c566fa55e9e6701aa9dd0669805a556ae37234dc7760d105599a632a9a2d54a64080ae4d7547ee8e88437025c7c7f713675d747117cc38620ea428dc089d62be6c3717fe0a3db7b26ec65b157d3145f81b1852ccde73d9bff353b70a79e3feb5bffe250783d4a248af1b0159a05e1dd639c2aea5f4b0456a5aac81fcb948b6172cb073fa896c45f853a5ba937c7d250ff5396b475a8346876f8a6de5d3d6b06cd0b25380fdf52c5774231b5c7a72df4e6d9d95e9614cfbb1574a90446524afcab3251a1858c0835af8f2ed176019da834b6027b427ebc4aad971d2cc9e17f6d1b01ef3dc0d64902b63754f871e23233c6a33822fda35dcb831ca3c8b8b6ad998ebaec3c400472ac5b1f63a57c0b6b3d1dd5595583013decbc49e4a80948ad367cbac491e848131650e5985010b1c2a6a30992a5c5eec1891eab420e864a7d69a22749297ca193aa3eca3dd2f3302870ad06f453e00799d45ca440f0c8c81b3e217d5c79f4f1b00d8423a223731b10d62e9d0f54691dcc75063041b20a075714246dc5d49b8e8942da0d8d0a54d0b5468427de0d8ba46bb3ff9896168b7ba0407f13d43af898f85ff726554428a5c2fa4506f7fea65d84825878ff7af7dcb1fbba44bf50b6e7e90fab286a966b465445752b6da3690f749b15ed30f8716aac001f4664a71fa215320736f2b20139394eb4a4afff2b576a7907041548801b499edee10968cb83804d907fe4e108a324e0bb781e1c29e730f026607f33a98ef45926bfbd955c3be7d0dea01dcb680239a1e9cfc55ede2eb6b8c426b95a70d55b3dc791999229a0b2cd5107f021c5bc75f75697cfb4bd127171587e24b525d25f5b8568caafe68fa4bb62890697d91ca0292f72d327e10af0faf857d96a05f8d629b2f5ef61f91fbf31c2e2560430b99e929ea0f36869b7646b92bf855ec8b255731e4ab0c989c587128b2d7e5e7c723b47251d1ed58123ec79dde0e22c5766f8e78e65017a5bf38a632bb3929f5b43cf61a01de511039e6c1d01cd27c1a46127dd2fcb2850bf6af67f8817ff73fe3e4d9ca4c039a231f045f52733e0f3a83f1b0ad23e828fbeff7a91df4a81a65280345989de5d9f2f1e6b6ab50fddf7f540d3bb2090c318df66d179deb4151d53fd59f52361b210a87ef78cbbc3b98fc9b70d9c279cf8e688d1a99bdc0422241e713c351f22c30fa7ba0d6f3d17a89be0ef4903808cddb987a07d86b2e195e121b26fe25ef7a9a2649b9358038379ed4ff52b1f9f78dc80cbfc9ac0c18e9ca3b21c3dbfacf2db211a8df16ebc204296053bd7412340fd5962d08ebc3a446db4d2fc4fe1203c944fd62e6e4885ccdd361f3fdde6532e346a85a3a5ff4e5b75366154e16382c1d132afd0a00068d6740aedb4379d5d624eb25fbad8dc73777796aaf59510bfb28393e7b128717967094bc38a2bd830fe880a38c60d881311a3a6123810d9f8f4c04530c91d903f1d6e441ac25268bae09c709384f03dadd9b64b138e3321fd368c0e3ea7960e70094788a478caa46c19bdc68fad3700ae5fb0578ccbb03ab0e9444aaf826da1720add78ff819373363f0cdba0acc01f8fd885182b9b45aed6142c9d425ab87c093ab93520e82038990ba1c49be1c555e4a5f48716f6bfe6222ae8f4f8d66b35d989906655be2d9feb409b253b36482de0b2143af9fb750b1d7b71281fc08e8e74637c5c08ce8789913cf1df48ecae1498109425197985b41f8fec562873123b232a41f14dd5fdff823b55519cb309084314d1a7448eb5bd490ee49f5b87c1f876583c450dc2cb86841c3626b90cbbca5cbabf74c5700999c01cc5a018653a0faec86dc86c51e4fa24cc776553bb3830676c79add652c51f5d851d06f5728f8865e4d6ceb239eca5e711eefcef324f0e6d7002a69f9003e6aeaeb00d15babea98f7d06abd66dd441a3af66a990e4dce3d21fefeedf6f52fdc70eed82ab667811982c55195cbac07aa288a17c7abddd7e951c092aeb24ef68a134633546a1711856ee91cfa1eef00789d0cf7b67adaa0786f08b46abe22f588aaa780c7ff0fa5818532aaf327c92a873d5903aa9a9ee38ea07d3701d5eff9e9533cae9e42d65817485c6bd86e56103485e17816307d4c2a3bc58395c49e6b79737b1c97d10afe8a61f80d38c760da3e51569ac9584f94fbd6c96b3f372c4fa4efd6c320e6cddd8be79e34fa8eeaf88348abf122162de70f28e32892d7717548c4373b62f37e1b594df14d1d66b602a09f6d605794a96508db2c2cd2a4dfdf6a5aa4bed2dae8844918691b93217d0ba78e7d1eaad6ea5783a8ae1d804911e04a596bd7b36f7853ad571a6073a72aa6138de7046e3bb98a46ff192420d44ee5e347a916fde89dbbf398bef9300da76f97893d18d4fbd2f1e2596e9feece4a9e26521f1d7160b01dd1a62100ac8c7d68c1646a04055d7288d50fae057399107f18efeb81b4717b26209c7d476c52a458ee2b18ce4b05c3ee2679b54213ab1e85c7fb68c07dd8928fe639e4efd19cf6f5d590f58ce5eae87788c7e125c5507a34a6eb90871ece56cd186cf6d97342047aa9b49f858167103e15e9238a5777dababb03a2770335ab273dce16a78b380a202b82ddf1e70f1d626084d0ce04268326e7893bda3cc661a0e6ac3f2378d3c6e64927f97c8c025133ce2da6de6bccf3d1e8b66cd7e25e54b704ca3faa2503432c6c555a0156620c656f9ab3c475a1ffbc9f4b2186705bfee4989408d68b73e768dfadce41315b6899fc53f3ea96ed5535f474e6f4dd05ae9273cf8590a508149de6148b0b806d3bac19e3b0132a1e9269f29c5f2a14a70a0c8a9601171173f29855acafa075fe09e9bdc1d539cc316c979dadeb0c27eb551f8b154083d6645639c12ab4363ca329d8c7362bf22e094d0271c067c62ab2a2ac95ccac0e38680bcf628de3a1fb8e013c370baecda29f50d1b5982ec6fc16759800af29df5a574ca10b3bff0262a929b49c212ca976328bde941c24ca5c812b5eb131c93e3b322f7b6b9324493dfc5fc9e12a7bc7562c04eac92790eda5beb15610f14e2ca06d29377e4b180cd1de75593e88ec8d11087cd0a367328e38d3f662c7dda537d529ca8248d753f4e0493916ed7ba3445400bbe57777a2e85d4a10f65cf99599de1b3029714d739bbb16bc9515ae8119f94815921c2670b3be89b9b68c7b9a01cdd05a019a4011225f38971c2bb1b51321e37e6c147243f0bbe2390d52af3161149c3c12ab2b6e568a2cb274a4df6cb6a23703c6efbdb3b20492ffc203e5dd1fc69f2be5ea486680066bcdef9196f7e74ffa4ef80896f12db44909e3583954c966b23e53b1d6244e7b92a5d48a9eff3947f5d2ec70665dd8c03483f742592dbc8a4422c99d30a1091254834076625766a17ebf4cc0c25d1b26d374b45f997bb91f3ab07e7b602209cab033b48623d00ecaf5d15444b7d4680fe5293f4eadb43c09143afe4235581330dc19425ade04aca4d170004186dfb94956faab8f7ed6458fab980bd0eb3a8da6ba96d72294b79bd5a5732edacab34866e1aa9b5fb358ac13f9d88b7c2b2cbb381abd9229d51135167c1920fcd9f9fa9d82f579d0edacc721f7c228086f08083ff30bcda1b4bc828e7856ef72d1b3ac1935d03fb2225281f27f0dc341a1158d8aa76c2d4238850383f3cfd151187432f7fd8cacaab994022dbe51a4e9b688718584e6ad7430d3da121d777c917390aba724ca5113cff7f96c6324df8ea5610009addc82bca90c7b00e7db56196145dd3925343d60f483d0cc9758df8b575907ab4ffa029892ad6ffa69596417d4300e2d02e7369311338a955755e22743fcf99b764790a8a446a15242770e364ce2f439df41cbe754d01579d0a5dcfb48e0f0e4091caa9f85194653bbd0d34c639e713b0bae63f683c9a83e82deb7934b6a63bfb817c41570af19107c3566232bd7f779441a891d24d1d4578809e17a06a8d39a3470c2f475158009648c2ac69cff50cfc18e04006170222e6681e4261e7df921f19c4b05edfb93bb937aec10df4d37493361a002adae7b71ccf91e31e0b4267d739fa3c8a6dade9bf1185f6e6d73d1b99b6d6ee72ebb1050e68f70cd8926aaf06bc15f35bf6d128fba5360a52efddcecf59fae1c46a297125d9fa1df3be81039961a5e51d85646711a41e2edc6d56bf6bc2a6fcf43881ab536ed806f8a4fc518981751da8494d71b2dbfa1eae95a6dad2968d2914323e2da498dc319552421e59882ff5c5c9d6f2b2428aef1562afe3ae636cc103b6389fac10c83408a8751ac2cc87f4e72542b5faf4ce461fc2573c2c8943aca295ad21644db80d2e09af8bbd561df0bc9ae16d05cb330df304cb6ae515c37e49383e2fdb2bf6593c437d13226f57d88acce720264c466be2121fb1703139b1e65b04ec55d11003328c9c2dca53c5f4c1a385b3210d1ba2e797224565828c641655ab9332d5047889191664dc86e095e46aa2017ed75668d584bbcea75f544301c81fa90b39cdf9b56ef54eca39aa0f00f41068bdac09a6a020e97b600bd68467df1fbc8d3f84c7f287581fc59d49d35708db28e0957874bff5c8ab176fa83123e8749e65278d6b72caa33bf7afb2040848f178eafc123f2e509a2f467953fab783cc5d0b7c4ae3a56d96bd72a0a2b54bf9a8b6f71c3e9d82e969b86ccdde36cab321bc87a81d473f04fb1e3675b1f1ad1b1a42373abb3a58c2d52a658700ea3786da527bf2db3a5670a0230ee45d5258192e26918b62e12814f8e11d98e3dea28698e25eb934a4bf80dc0d74e07e15a89bc1174b6bc5ba4adf8ba08d271a439501504a9886ad5b97f15ec80c55164b7b058027b0fa9ad163753e154f9b22cea0945743895fb93f730581483bcf2c3d90aefe42cf4061855e460923ba6644043b7a29a428f80f7cc2a0c46e7309f37825c1b7c2ce888432d3fbe0eb98db81ef6bef04dcbd85ba245a16e1511af6086352b1a0686708db7cc5e2822c8a2ba39f2c0222f4c0890e921d6e145dad42eb935cf39cc8a658ed95df12fa19609af1314af29f7cfd392ede1deafa336547b90a1ce11ad104bf6cc7eac1df53458820542b1dad9ceeedc0e63fdb65c19058ecfa7b9088f6e9e36a4297350f2ed0004c6ae408c5cc131f6d13bd3e284e523ffb92cb44cb03db027c1d37418695b0b7208b448f2491a506e9427a9dede06f352f6a9641cea0c3b0693f0a8615dc2a3b7183f93291875d644d501d19b2ef4235ab023888a529c9d3e9546be1ba49dda93e7eafd92fd124bb72de511370880178d446e5e07acba1aeaa5e8c6664deb2f49ed43efbc251ca50abde106c5e44ba3c59235812cd02597f7b57cbea3dc9f38b17ea07d069fabc9b5de5e725b2bf9cbbc28286064819b890eab40e742df6dcd4dca9d8a9229bf5fe3b92a2ac396dee6fdd69891436fea47fb39ffcf3583b07a4229d8ce0a2bb3e51a524e60b25bcbe1c0bc7a9731ccd0019f85870913edbd24804cf79642875a644d339dc13b89081b1d0855820089fc1fc0c86ee22dcb4254e32a84619f8eceda60c481b0383c3dd30e46ff739ac81edf7e3ec5a17aace4fcc160e4315b225b5ddecc8b151496aa0de2b0cddd5bb432bb3c4cdb51456d42411dfbb3db7d084a7a1d4f944ebf704e475600a6d6fee24be0f309a5336b5d030d4306b48c377ecfd899fe322b9f313fd73f18c5bab909db5bfe566b23ff0e8cdb0bbef1ccf3b612877ef57c3e3ba347e89a569f66b5d53fdc21a8ed84194e20f4ca675dd13b184f088d3bb179a1f7db47e873a505a06d3eefcde49e201c7b897210e17dd06be28fa34cb0417c955b1961f964c048d8a6d8876dbf31ad1c29cd6e2795cf554b610d537cd0b1445c6cc5728cb28ef0c4af99bd8fa5a0157e080d86808aeb8c80ce9776fe76b7ec4678049146ee7fbc3d8581df251e0320b5106a77d145a9b54381a0843529d0b72ea8b77d8485420a72076747f63f0b2ef782ef091c626ed02789719776334b8cbfd4cf13d4d0724e39750b7f357640813c0ba278d3c80515afafbd30d8fb987fd217e4cb3d1a4e785f8a967bfc86bc78274eb4cf77a2abc1d3b96e71a900d1380fb4a910d038cab42939eff03f5e68f017bfff9a07b63afaa5e747dd3de1067c31aaaeca8ffa38c0260811cb49c111e96280b9b5df2eca3ef336a240a10b140effc5c0df9d157657a92652dc5ea7ccb3e400b935bf9eb35608029b05c536da46ee72e15734b929dab32af91bd4cb5db154abff194c23ff6f59d4b8c4c6fe44bd9ea9de25df9d296f614203bcc939904c2c8a710398cf1851ce0941bbb6fd40ed199b5a3a766e712c283abb6e03dfe1f94460e3e3494bdbfd08f72b16c41c04ad8ebed4ec524cd856ae3bba68482aac31893431dcc4f5139c34eb6908847c2f60b8a31da51df0f4b6904815a3e2f2989b806617f6d476e582d4623a0bad386758f13ac21ef49b3739aa8380248cb23adc626bd81d2bb8871dafdd6c160bfd75a3700d452d9882a13ca06dc9bca5a2f35ecdaeea72697aa5a9b1b8797961e2e5e56e65c103ca703b31d4e3a469eeea576c3cb80eeeabc714cb72c84644da4ce66216766d3c8176bd4adf1036f6b552eb392fbe97e2f9aa970c673251be56c247d35ca1f6b34629b6701201ed39b549ad8e595ad5150b1afc57dc47fb939022a49f8a102cbdd68f93d386dbd52dc78bb18ae8ef7533d4987e18d6dc7ad70327bf8535c5ca58abfbcce5b862d8c50beb8581ebce9ec795a092ad60a506730d5659bc1ea8b80a37804a943f04d05bd109a8945713afee3a5f970ebfb2f4f33b85327d407a35b376fb5b91e97eeba4064b02cc34bf01ce61a763d7fcad78565b4e68415918e6670266e030bbfb907c6be0862293a9c91f645cc44d323f580bbe32ddffbc2aef79a607c6199e6197e556fe6c561acd791cc0b9fd3fe06b08c83df4bf478127e8f42475223787c231e9056eed0669361d09f74d5f427c0e953be7b1f5c9c13c091249b479c5f001e049e36b4e39ed02d66209a2af813dc5d70bccd7d0dad5c8cc014f602094f8cb80bc566ec010a1bc6ab42f62f9853c998fc2f36493e9ca01fad34e94a5b39423612e81e732e5d9a5625a3036d67da6844728e871365c16ab205dbc9b61cbdb4547b503a83a04be435c1e8f40ad76c316fccda417f9eca8b2d9916bd7d09a03550dd768438a16d32cfbf35799046fd259c2f1080450660525e45062fdb3129aa738042995ca15f9e31baa3cc0bd365c967422467bd19773cc54149df16a87937d165db33c7d2bef133fa40b2e019bc4d31f47a93d496c45e2f669f52e30bf49b7f82b119bcac5b91c0a3164deca3bc87b4c9bedc997d877c2dcb5ba44fdcf67c512f6b49a7b328129afe09b99114913cb0e5475046c3b42329a02b0b2c7468d3a303f11ee96a074a288512e08b44b46f8c5628f326d3c80862226e6b11c2c9ee1097e832196e6a635c2471fd4807838a535be77be0d75f51809ad2c657a780e8127a63784864030c3c7ce8b19dda502a85f3f3025afae5949819c552e4bbbee1190382518c8056be47ff48837cc08f95f4eb22b5b376235a8052a9b28e17c0c41382e5560ac3c4135cfcf8ce6387580eb43c70cdcdf6a8013caea53a3c2efa4dddf85fcb3d6e15c18bcd174b195cf2ee7717df52e17ac763eea1ad704239b63b44f6aaf35d0b7a41539ba25c4ef58449bd32279ed458d167af1f4d938ae3cd2460b29fe8a046eaa3ec2cef4053b6b6aea89af46522fc12fe358bb3dfcb48645eee26bced4334862fc2f500770f57a037fa4cda90642eb0c677ae2a9ba66b9bf28e09c85cdc911c599766c3fda4d56bddbdff54cbc904323dafae5031f7ae50284bbfc93c5ac5250b963b7e96629855b5181a73eb3f498adb0f394d82786392a21cea3da10f0accf7f673332a64c6fd783215d32bdfb4314031f8233f913ec2fcee9730a340e9d07491ae7ff001f78fb869d69b1c12b8a0c94bb43d7e24fc7ea187112c3b2242711e2a9dac2e633fb24b7f5daf7e822f850b009265b19476b10d216a01e7e597131f79ebdab80f15d3b9fbefc16ccec3b4034db4176346164308e90fd1043bc4d64674591b829bd02073712ba90f25976f773c17d5d2c49ad5d60239e4728719feea6d268933616b9314230b558d7f159cccd9111cc71be87efcda30ca3fb16879a7a00ffc968a7f89a3a2fde6a72bd206de8df9b0cef864e91b26eefddad7749efa43ed29a23196a6844d7c17922e6c1ed179799176140e16f2210582052574f3366dd1c28770a632f5404aab6b9b2871ed670028f6de7e6e72cc4c264ce334dbbb2f7e10803f3ec7736e2ea333506a1c79e2f02b40b8c052679539c22b133a4dddb3520f0f3a95539f4f8afa050d1ceab78000409fd19ec608817da67042bd3ec30e75cddf9c5e5e6c5ca3dda4674efafd63ffd32bdc7090aa97474afb6d0cee8f4bae6696a98c7cec426d67ca1207e8b65d5bf29013442a86f249eb602043880ecdbdcae710c906ce6f4097fecb38b1c24ce67dd210ea39069ba65ad912343067f86e9238c870dd06a6bce621f581fb2dc29524b835696322633334cabcede4c086ea1008a00b76cdedb5259d229f3d8de21383b63ff7e188b5abd412b08347587ce789534d2021c70c4a30f21866f9f5fb8090a4e171d2ab53112d8d8c1b5b5dd71ea77af199c7b9282f6b6e2910b695f1033d81f75349c138b5f40ae802ae09929cf4768ccbf7c5eea812bca2f5adb3af7f84cc0c9b7647875f95a52b864e6ae85b18ebd50511b7196bb9cf904eac9970e3afe8e592ea89dd43db89373716ea6cb420a7157e097f559dae5df530cdcf3a8f3a0f5d476a06e6ac662514e567787c01b8346162e98ff11418ad45d4cb38269af8dd937eacce4806ba9965951ad12ea03f34b84ba153d26e3d2ddf26d0c348697e575599f9753e089a0bc5bf07c46184f618b01639566fb9df5bbe7772e98756571033c533e5010320a755a9dc80f5593897437c6038ad52b242fbc547e6d1649c8ed47b56576034c611e8d0b298a1a6ecf71a62d887709528d9b6852c5dc1aa232d4a2121284b13d95912dc251cf3105212e698cd66ee805c19e5ffc667a515290ab8b9c897b57fb647c2f0fedcffd4315a94717d3c29346d49ea8be230800128e5c42ffcbae2cb8fb4e32e8ad901f0e4efa296c2849b2c64832418866d4126c4dc44fbc20bffe5a30b61f0fe6b71ba55cfae79130baca68d5a1160fa5517951a975b506ea7c4989949464123527c9d53ed769e4aa21567ea5f27a2afc4f7aa82e3a373219be465500f5a7d711bc65608ca70da29f6015766359bbba24e1f344b60e536dec211c53539df010af0b57a8443e80b322e24a4a530335e1348d7ff557f7efb38f8a5e3648f338675b661e8c4067999a22d8a6897d87d522ba28c759551a7040ef96e275beb54f6f2ebb6717ee60dc096e2839c53c302ece114caa1e948ede92ac5645c7d0b025799a62b0894d0cb90141fc69a893dc9870cab9debaf06d78afcf931aac173549ccd0efd22bdfcab8146cf3eeecfb35aeb58aab5a43bd4c7c7be97ee9ce20db3b27c97ac70425e86ad9e727319b28292aa32add888af6145744c217cc2f29cf9c0ee36f83f96390c9f8edfc8d98012f98b41e9b4908a19f79744c1710ab66fbcd252d8270956904db25f1a74ee3d632cf11045f1cc50a8c9f77561e0562994a47c209e23ad4ad4d839ff7a1fddf25d677bde5aa42b3f8938652ff2f91d41287ae75a962f83e949f963c37ac4546972081521b8e3f78446f004a9b152d71cbbe4bf83be42eef9dd80b8d601926c6eabdd2f84105b18cbeebe0be78f09f3208a3fa1f1b795c19536754d45a1dd7b39ac436228b341be8967e3b302071a9f45c5ce54b4a0ef40b6719694c2e51dc13e6b6e117e0de41b7b1f69c5c7a95a36838f6d2c0564bf499c3707c9b76cb71960fd7a8936d6d2b7b2902105a384d99412fcbfbdbeca10d8f75345bf97b4356446b475c55c247452a359aad569960a91b514ef42c0c0f235d4e87f08bbfa58b72290c6b74ba371741b49f27aa12ab21b1fb1701045b27220d60d8190cabbfc2665f3e29da1936afd81ee23c507cc68186c01470f9d59ca5a34d59623c1220f700e3a71b9c15a8711209f2e05c8d35586f1d299c6824aef546ab5eb5140376609e8122ed021aa38e1e8b2f36389147ea9f523096812f4ac90cb1b3817712335391cf57890e3a3a5af83d0aa6154ee0a4cc7446afed0840eb65d129725a2aa0b7d280befedd48050515da72b9283be62451d9b4be3b0d8d262d694ca68ff533c3156d853eff4e3e259fc9761a1e320f0b5ab72cf55c90d5715a2c47ddcf52fd8037dc34b242021060d994eeefaca4a8e81ce6ee0c42033bf3f23106c73f0f5e419bf4b086db99760064d4f6556ab552e8e1e5c0a7d472b4e47a8cc055c18c2359773287f5daa21c3e670b7d0683ed7aae7e97dadc3a12682681ff283f461c80b8dc498b2aa6eab697c6bb43e8d64fffeac587ae57ad19f7dde7d7bbbfacdf3fe701b2bd65db7aaeaa98b0fe09c47a5b359430902613d3df62a2cc1150b62bfd6e2cf439cd8798ed5e8689b9f81a122c921dbb0319e9b94b265c69d1a0cc3266a1bea637cd6e2de3d36cd716deeef339d75823680f2a958650f683135d5280a9f42d1b9a942ead32842c52fb616728ac8bdcfb1427bdb8de5b293dbeb6aa01a73a35167436e707472ef048fe4f07059100cf40c5953f5ec0e0fa7c730894713e882bdd1e27c9c7fe2325a391da88524411f992ea72dfcbc60a71d6d69c731893eb9eccb096070e6c149ee06c950d8e1aba94b03f501c1bd352c9ca54094d6b4bf2d5cabc9d7f0d0229dbab7b581624ba6fcb060cf6aa95ec519f6874c915d16845663173ad8caea8b9f154d2340d02e3c9fe0dd8d2d2190b7692d6456f40bc46db5309a529205ab5b7e115633ff40a58c7222b83a1fb4bd141790a5ff67c23922f39abc7ea30e6ae58d8913dbcb8950d754eff8f7d31273c9c9e9d28229a787a3d25a41816451ef56e765225a91608f783d93d02050881b443e75b0ac0be71e9ac137050ef988d79036bd52eb8c3833045a79d2e41c1189abc5310fd1bbf49d301a240d9779991f5a254b64e583b107f9c88989bfd5bccb612e0a3a4f1dd2ce2a163eee28223413f557e680753445bf11d4e9bc1b4b1532a5eed0b9928c0c5d4015a8b5111b527a98dfcd55650d933d3f558a6eae1646986e175805a816aba31c1b25ca74382ee55635d34365f5ebbbcafdd4d7f27408057bf2c6f0b090b89131bc225bef788ed9c0b97ca2d8b3f150916ce9e096f8d50600d10d827221693febf96bb40fd56e149204ef6c91e7a1383c4a093fda15fc3cb036c95b5c65c322bd8e8a04f3833dc04fceda7858cdd1b8f2a2df9db60ea809abaf5fea7424006272b861b0614cca71fe7eab918fb7fc746f354012e01b1b16fc36fad0724a8e5ba741bdb76ffd752e706b3b1ee1574efd9227e0b4485bc68304a9f28969c85dec1e19ab71c76655167e42fd9439cb21c3df4a42300e8b3049c616add50bd47341fe4f687a3c13d8cb87a557d273a98788a6cc89d33d1eb6f94000dffbcbde1bcce4557841ba3fa0f356e639bb69f5787017527f93c394bc26cc13c29ce0f30b5d2640d4b7eee299cefe0e94a51872b4f8ced7cafb60fedc236f69743081ab766d8e99e0aa1b0b8d0c455fe8341cb3dbd802094ad01a4e6efa1419cd4887c98aee917e4ab26e9cdf6749f837febc101f57b117de09b00e801236e2bda999aff337249233e50b71012ec78c00f1ebb8edf9e85ae8d8e04cac02354a03637c2104e926eb75f6a42d0f47578a75d7bcac34a241cf1f66cff37295f4d659fe6dc9d98a0b4e6cb05ac97ff1a93ba269403fe85bb2b32b0a7e2b7f88026c021b00a783f2809bf64f84c4e35826d46951c73dbc0c484855a0b6f5e8dbb01d25e96986321977109ef0081fc3e2e087fa3cb6c0c57e40f4b3ef235dd5c48197e79d5ad5270d6a2278bde3831b82d36eb6051fb9347304bc6763f15b69f0ebb813e7b79f351370d0c4d8d0903534e60a297f19b7b19ce8bd53f6ab435622c1c4e3956f89d7caadff8ba4437e33a3c06f0f724eced60923977a4715a4bbe533a24190f6d43717cc0e2e0e14f66654e9ed1fef4c45dc907eefd953f09430d895c4239a7def1f3631f5bc3f1d5ad6e423a52d40a712ecb9eb039fc156e39b4d54bc2f533c8354b96c5a705714e4c9c78f47e8fe74e28755ad069058f3da69b0c932fd53dfc0316a24ed8b267a5e578ea0ca6fed5cdb17dcf0a701f821c99150f4e71a4e80d2cd3f6894e26b328573bd3647c258e9f14d8d61977f22fd2d6e01ab511ff680169b548549ed97d5703ee52bde1c0b87ccdfa1619339c93219a4d2b53b7cc06c8288707c5f475a031cb06c59fc848cf64a48adc608bd1bb5653c1b6a1997c7c5ce19112796104ff5f0318d29abc6feb1c2addd3725e9a108011b6e93acdcba2fb6639b5981bc6bedfc5ccbc20d2f753f8c2e7fa3c2b4d8ea02ef983bc55e4ae90ad69bbb18bb35ff9fc8f8ec4022472502250014538ea841e66dcf9a5a3356096201e1fb7473232664b876372d35d6670756bb4e1ec76014589543f1be25b3f29e3a83b72fffe77fd06753594c95ae0ad935a99b72390760237e9751039e7926492e9f2ce0d016e6324d4a4abcb31e70288b1b80434ab4bd180b5adbc6f8ed3800cd5469b15600e90254e6a39e1c3882e45e9091a3a5d3863e4026ca6f3865a7fdf7958988d73af1d1369068","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
