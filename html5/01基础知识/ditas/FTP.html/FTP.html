<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2725d09daffe19ef6209f5a756e9587c99df721459cab73dbf2278e09fbd7f3af0199c1c41f9f0d687058c85311d96390cc58be1c194a2050559a6aeb70f37fcfc7094cf0cbe0a8d01e2bf206d273b54d7372fcc9d61968abebafd88891d8bfdad77c4a4e6ca56da4f745308fdc904e4dc2915636ec9d6e592a149f7dfbb8a08148ed97d9967bd44e6944e9b58f2efaa37aba322e2303dec9c192ac492cffe13edfded62a744d665fb90d5198689b4229aa92d24c1a33dd9a41e85efb602c6dbf229a78da4a2d397fc89f456e00d05b6db1d75c9fd484bd052fa27f924155c431847231d2d71d83e9d4420af0df6c7e647aa7d7e79275fcd41addce8125320725bd8bf1874bfca46f70e3d90e3efb9440e4ec4a68fc4ca5674dec71b26add3aa2e6fa6617e2c255988bcac0b3c4e05a6cd5f1d7683fe909bbc1e3fd090b1c1845a898123b062e3270732f6511f74a1b35054bf11d7b59c1289fdb98e7718e738fdf84514d043896e58255d412558a9b86fa236c6f64500434e077c65197c7dbf78ce7ce865bb024bedd4b1b4aa42b59cc77a0e61b35b9d89c89520b755a4dbb44f97b80b38b86681431cd41cea88b79b87dbc27bf58df094d299711ce8a6827830d422b17d698b6c72af44b44fcac683874b6fe1ca9bdf38d29a130d0a3660725b367b145e2175b4b91803247ddf2f2286905c4838dbf0073cf3345344f56bbd76c0f0dc5eb6c273d99d3897c34bd710d73f4b242d6ba6ae420739cd03f7415b6dcbb531fa95b8145bc466aae0b66d8f3d3469023b2f0539d3b890774582f26fedb2178de7f036b5c53449dfb69f55a97cbb8490a7a39039a9bb5f4c5bcec2d0112471f2cbbf496e1deea8c3fca1a2d75ea69ba169dab767ca5663d1fcd33822791071b0ee52a4af9e89d7252c255bb4772e6030f0b240a3107d3b1eda12c9abf0bf184f60dee568242a2c71815583c34fca6b467e1cb72dd0dffaeb171fbad78217e0254129b75ccea1c72ffedee002f187dbd76ca725e0800f596e43d0340249acd01589f27a5a2d9053802a3f4514967c85164f5ef33a60c959e39be5f6cba42fe778e8f823fcb630f66519a9ca3377b8bc98bb8f3c1e444dd9464f8ca1fa523a16809f8db40f90cb6a1b65297dba7bbb0e2a346427d0983b80d4bb26940329b3d83b67d75c69b09825f6a61b00414d1c70d139d7091552c4f863937262d3d9fe8d83a3d1cb8cb98111a2fb38ada08c65f189f785bbba6a03dd4dd15751ce33395a15fd7d26beb50baa50f8deaaf4776f86efbb3402e44583973fab3405abfde55f70e25dd5cb7e80dafebc246bbbd70437a405c253f3dcf159ab49d9347b6ba855fd8bd331e9cae289192eec0ba8ad9174de5d0767dd2d3515d7d9417e02d43fa7f6f0943d28ad65beb303b6471846961fccfb3a4df1968f50fa928e3b3d70e48cc106ec30145c7d2e6643f40240e9e0e4c9f3921bf403d2bc9025f00e8093a9aa33596e7c6fb1d7b0fec87bc8b1060d5862460f1b445b4728e0d59a1879dae0b592f9ea267d4ed378ea4f8d6071822fb367bc2f5a3befe13b9cc89a69365b6e8cd37dcacec36be87b93e582272a584db46455356e03460cbfc120ea637e8ecc7278fddb635420a4c1b46c30635c6f4fc15c95c31b610d87f01509c68821a3019a7e652744b86825107e70f93de4362a1d0edd73f7a48ee49fef4423142db08a88d1725a1482cb01a5ebc0e8b9b5f39f1a6ce2f8c80610f0ce827f1ab9bb3b554a54d78879dad440f39c7bead81aba9c9c65bc6714da970ac37d073a50cb78c82eb821754533da2f847a234ed6afc8b30e03c0f5309636d1ce813395a0c163d301aa300084a0f9eb9faeaa54145734e0ade2d8dee09ab947947d625778431769ffcef76e3c1b5a6e852511dad57cc2cd3b3c1aaf6e9f2ca14487dd089aa454bbbff52b7fa3aa52bc56790d1f6d94dc3641fab59007e0521fe75c3a9e567cb97340c11f9de16a8943d498ab293637c5e40a021c4b7eb208427d313dc90ae8b4d8447f5f2be7e124aa12a26d791657fefc36fc59378d2d0c873e4fc8be492e2e45f1c7f3d2c61408dde444f6bfaee4b277dc8bac9e5993030e2c684905a0eed07229e6046e38f01382e173893fa44f5479d5a53c9e334ec512c9bcd8c44d4638d25a0f24796361b648464ee5681f613309616a007ef4cc873d9776fe314bd81ddf00af5bca78ca18f5f52c8dcc51cbad08a6699b5ead30f51edef36561037fc6549f477368f735dabe34ed1f140821fc5f805c7af846a0a43e48ea2a709e4d071d88665a2b9bc87bc8e5a918800f5d0443646ab643e07ebaefea3a5863fa4f0018a68ee6e7fc7507670d174d9a38d349c100072033a3be85bbdc7e34e55e8fe0890c81387a18a1826aa54f6b40e0589c7c1b1aa37928a03f1a91afaad48a7a2f0663554d783c06663589194f1cb2a75e58e85b470e8c133f6090c5d416b2e518588bd099bed79f94964e4189dee8ecb4bf5f758aee5777c6aeaef147e36fffafa9396531fa9ecffe0d06ce4858891d7b510de85b5dc5309604c845d4253b6f7b10bb969d81518ec4007d86b3dd295ab25d772d98af18e5eb5306def6444b1f0e8d8096182b0675454fbb72c18cddc2858ab6e7c8a63e288e2572c1d0849e9c375835da58b7fb8967c06846a1ca3b41226afe356537a6d36e4e29ede238daa883b41b44fb9ecbd948c2653221b808200c41ccf2f3ef8e2c4da29eb43d3b8db69284e62c1b0140e596bf2e87080ed938db4c5e44b5ac3b70ca86ec2d461185baf19dbcc17b3853767593183cde9acbfcb0ee91e16ff244d372e7b2f6073c832ced349411a087de3a5de4db237967477494553a721ac5039adaf1273242833b9c5a574cdd38017c5286daa4756c23c17342c6a41ecc4e404d0a99db68911e5cb93ba9b08ddc601c677d7d0c46c68a83b51faaa3d068d2e8907b656ead48afbcc529a94529eb6ea610cb21a9d17260ee8ae27dc4e6338da9da237ccd9402925df982e2a046d4201a9099106f8140c54242a6d768773509c6f57a8d3091d8577a1ba3be7e053529b63379516ae6371bcf6dd4db995167fa415a62b103dc8ee276f8d2659aad110275702e57b17937bd915bf2ba112d3e3a387700889487c85049069d0a7968b8c96ff22c84802037a6c927f4a2f99c16c0baf6aaaec6cf52d317f5672d778c65e099120addde78cc92d683dd6a10e80b0b9965aae3fc7e55916136bc0924b215edab13ace5ae1def286e6770de48a9fbcacb3f20d5a15329c6a1bca1107aaa547790e20ac44fe21dd6545093d9a3e3371276c6107017d6a6e552347836c35a6ab0ce7b3eacedec260ffe7cdb9c00cf267f8b5079999f8d3e9f669db63273f4a6ebe397c285c991d478e89a69afbc5f09153b01ff6071fc57d926cbfd135680a02706fb354c0a5a832bb41947913a5410b930b67892fe66e67ac37358feb0738796424ba7451f171893804616e710316dca53f0d268f8bef1770b1a7a07fb67ce3fa4c3e6a97aeecfc424eee206b93826830c36c3f71d66a4a4c424c35b83d41dd85fc704942e837d8d0d7242e329ad9ad4122afd875ade697f7b39b97763baf2a9cb845f08a58f20e9f40475b57893d87700bfdbeb8ff80575378976e0f81c8eddcad907047713006f4477eec07c202343328337b0df5f278d4caf889ac327f44703db4a2a2b033df22b8a92093122d1141c0dc6b57c4803198f7cb4dfcfaec160ccb764b000d1b51816e7c26b61ae3d8c6ab17d4ad09647cfa4650d4deb31085536af955b46a7495eea3ebe014b64dc2927c13d690a60f830861a123288467d68b59b1cfd67c01eec2870be24d36bdbdec7407455d9114c9fc91d731113f9756d773b8f64867b7b7918a88f5c8f7f82b1b112d29aef75c07b2e3e9b69cb6cc238efa1543707083998652c706c090251cb12f470b962f29cf2bb2885d2f2607000b20a3383d5468104b31018ac3c4e5304e3549d750865254ca88dbd8f36419ee99c14d088c1ba04df1c8c627dd7646948715d6f20b8cece95f26415b778b91689e7f30527ea17cc51a86cf50f8ff3e65737ca3563a502a0ec32a929b8f75981fb5d01ed52f8f1c279bbfeb41d6e836b6bf01d7feb485567726fcb753c998c6f15ebf6813eeb8116d82edecf749cbd56a4f61c2c89fc068e7fe75aa97d60c864fbbe37dcbee18cfdc5fbcb22944961b07213b36d63074ce4ffdc4ed4ce94ecc83db5df665ff4367de902822aaf6dc50f490a007ab76a7bca86e3d831e1db6461bdb7a20c2d3ee2e5a0548cc1e7e9f9d02c97857e3da3734bd30be89b2b71780b846ffdbccec247e6099e6203f7eb9f8ef124a5fb3247327f2cf6f99c9eb2b5855ce8cbfdfbf924216c03db74c0424a0fe471e8a92f6bf2658b0ff2926494a0e49f347839e217137a972a800e4596ddb70d0ab3ee5391d6c5b40b8281c1cff95d243ed0c655f263d6b906b4809ee71266f287a42d985673321df0d4a68c4bd2d6854782a4ea95f5fe49f039530ff29cb72c0a48e6c4105c2dbc501625c161f2e1daa82dedd8a629f07f8e2c6a223bfc6eb998df8f44a645be113536c939cc1209dbe1adf663e35cbc7d49ba2a3aded17550b2878b4da6fd58ef1cf6d1b4efa79f4212594d7b540ad2a3fed5781f02190885788d4d6125027f888f47568776cb0bb69aba874c1ed012a558476a6611c425be65197c7f4feadbd33105ff0c1137f90431562b81e02fe6c1d2f39bcb02966188706d60a9eb6ecb825747f01fb9411545bb37ee6aa12099b839796c69495de9684194c87850c31eaa65941e8bdcfd64f21d631c40dc4f8c399093a3191f4cbd453a07f3e6314fc1612ba58066605b1806a85af3f27e7e4457f2814ce0df54472b883d1c74b87b994bb4d7300f0848ae31fc70de78b037c5b801a9a21fefe160d8462888257a4711d83679e4088e7355d17cdda187e22b6fb3bf052a3e4f46576eb6c77752b26af42fc1934caa561bb0e8e3fa0bbc6cc34014079d03eb49c6f75fa6c1dc6887649adb17baeabb6db9e3e92210358267cf0f28068b1b371130872e9ee5b36ea3157689fdcbc5eb74a9251100b96f608d74b54f55f091f5e10c1868c14104ca12f0ff94743d155d83fe1f41d506e6d7bae8759b51978b9f3305a92d70bdcb6e314b15ca8a256d0a15d8c25bbd7567efb7cf63abca1bc6b12282eefff7427566fa1e4bc086057ac01b7f5ecbc33d2b28015f3effe19e935cb8aaaf409421f3d225acaf5cd12c2fb0365f654c46a77a3d989a551f341f49f0de925024201ca09ea49aa6c4c2ab3ae534fdc75652042b86079f98a686ee268c2533e637badfd746bb3ca3e7591bf88b1257d8b4d9683cd7370d96fc3fbe8d1b0f88cae8670ad5fe7e01cfd6f6228e71a73a1ef0af77c8c052478646f7a7ac3d1c44b4f348c9dba6bfbbbe5384e0eb3f123b9ba541113f4fbbfdcbad7f23dfcf11ac01169ff4214248fc0a6f7718f94ff420c254f5b8b9f2dbf9b36cf8a25c23a50a9b2f85baf51c5f77d437bcad7385e89581a312b08478fed0c9fa74cfa4ee79d90ee587b0d764c8315ed64147d7ab50f3d227653168244e9a4e69feefd4ee6863e1ea6ae296340ee35848d33ecb3c8f35752c8a24e513547e9034871fb88efb338bf41ccfa0ff42fba3811ebe5151a7127fd560232113476c1ac905a516896c61aabc65d27da065fb603d2dcf700d607b401e373e2a5676dc1a8e920ff88cfac9f6efb5b4045c007308f9e08f69d0b26f098706c4a3e716e8cdc84af333cc3c48a277c085694054a13132f6a81346eee9e2cfb2e64fadafbd8b1368b63d1b6f905b9c1de74f2c09db0ba9fa37c43f6808a96d1b7a26d166adcd4ef50f1199a1b6947100075423b368b04d643213bc342e6f90092110f404cb419f6f5aa8ffba20f45df813afde1577539a85a8228fb5bdd2c90a1643b7bcf082288473461387351ab765f055e46d78abd6724275e0405779e84b7b66c56c3566182ca64b2646fc9ba8cb98d077802eecc5a45b3c9b57fcb7494c1f9dc2f13ba0c2d80702ee519755c26f2d882f95f82395b3f586b2530d7b9fd0b94b60671ff74f9776d4697fe898c80668512d57f40120b02ad65e618859ce76cb29cb940b7b525c49655359aa2343a4838b98116e0b0b740e96fa43a3750da14bb5c3803665bf21f1c086f1b1a5fc45c9d677ec9748fe6407f001f8000f25e11e0325523082ca64532f45f2ccc818259cedd57246981d5803f375ce39d0f27474dbfe3e44bde6511e6f47315827d3a9f5ea66eae8001f4083f1753ac02a4c5942d38988d0d206d567f66d51162cdfc74c8afd4d9de7cce4cb5bd69fe4cfe78ef46347da1c67ac482a34f256c0cdd4f24530d8fbc4457b3517a96439cfb3f766246f926faa9690e3979dbb291965a57422ab74b471609b8872f5c839230fd3bbb869f97fbf3222e187bab89c0bd424e34eee383682a539c601236eb446ca626e8f7c8adced8d6d4f7eaa3884f7ddbf4031132320471e36e387009a3e28ed8271517713281d84ae76b564aefb042498d0185e617630be5ea215745ab5f58084b03232d281017a456346a96d6299bc3734b600be7e5394845587c51968b965b233e042422bc80d696752cf606bfeb8644842538872928551c7ab4b0e4824c7878e4308997bbba97c17c00c3f52317c04c6c6bc9677487c801af57c5306f295985c57d71af3dd30023362fab097d156f8ca7deedad7394b79e5c004cb6ac67ee051d94868b62ed8572eb2f95293b5a28aa26dbd58989f98cab6ed2efec327b24072513851b20ce215119841be7250bac5462fdfead70870db248dfe6272a07166b236b8209dd9142ef375ac373d533cc2a7764de27d11277f1853af5b2131a7b50d97c13a805d9831960a6939d1fe041d46c3f7cdbefa904bd9d74591449681c6109695c745673dd732b2b961174a71265c50d585858c9a4307aa4aff5dae9e2491f191b906591c72f657df8e4189f140dac6896edb1aeba124cc3647c42d0002c7ed8ccd016463ae04c5b115c88d4a362308efc16d0b470c2d8231f59c7c595ddf84758d3d97866bc88c8014597af32eb43680a5b8a3d9f603f711fb86360c3de19eb559731b45df6fb3acad96e86832eb8b69239f6eb3cccc05e31dfa6a8e51edaf00121b4fffc90ba1ccbd82d65dbf02ef64a5b413b2562d55beb78bf3a4ce1ac0494b58ed0589f357fda9b6893e06ab6406c454dc1585b260aa1156f3c1ecc202ee33dfde48200511165c3325d75a315954497f15880ef8c5d6ab17f4abf3e65a13e16cf1098a9a7bab171153a9aee96339835190a20d8a0dbf45c724f381ccd06789bb3a1e7bc3cfbc72ed4765ab63226452b544279474b84983e6cc87bd4353662a4008b6de8377f1f563605fc0582b115bf8a88b67e7c9461e35268add548b7244bfd4cf9f223edc1b206880b3938e9096377ee33d45c5b861e3c906aa430fa6b8d8be741b2837ea943c15cb2e15edae15b6313768d34e41933377f7161023de00eaafd60a8f4d4a1d5f4588a1158a6742f38f86b929ab2f65d2ce830b5fb5afb2a667eb9debc789ceeafc244fa1c001ede69d71dbeb737212dc55c413c9ef5caee4a6acf1e0c765a790c3ee73d06375815c3274e692c73cb059a62337c4382215c5092bb88132b3a1798bf670df9b3fce4243bee89ecab3d1019cf1cda52b2c6707dd0752c7b489d8cd78c8b7733c2d0bdd035811b4355c8c216b115bb058e5d506ff79fdf0e809496d9b2d90efc0509ff75de9cd0f3b6b17f617bc8859c0b9ac61c82c4cc60424f13da54d513bfc0aaaaa9247c25ab01c92077a8d4e8450a3c96e4a94fbf575ce788f4d21d46629f61bcb1cc205f7bd4db015fba28238cfe2c1597943d8fb4b7a4de2312e198bc921781a6cd89cbaf29538510a119c2884116f4efc6afa47bfc6a4023fa545fcb2f542642a8f57286b72e544b6e59ea2ff898542aab24b7207451ca6b0012057b6b38c5976ee22c3375136de284ac67994d229657c75c058a49e6ef195a5dfb9d998fe38a21b0b3b27eec4485ec23f766f4db711564f30b4d931189a54effd99a2efdd5b5e480179de827277af321c4e1a4d586ecd8678846cd04813ece944f0491edf19cda817752699bc968669d703b1ad40e06d745d7d15a9d7d5641364c4e13fa7e84f5455b1b359841bd4c9477abe31254688e7cbd01dfd05a1f5d1ad4ac6d8cddbe231687bb224c1afdcb34d87fd255e4b151130a68815136f2d861acd6b03e0b3ff8448af54b213e58cbf50542428a68f1f4241e2a95fbf8dbd0e8d7aaf2789414dc0b3a7e313a53191dc9e38ea316f33dd43f763682e373e96f658102b4936365141618db0a26f9f351494f90f98e61f80c0680ba67e21e299d166d8629e39eff225ccf6cd1969021b931a07ba7c66b9f7e8cbbb8a6d47bfb6e008f8c1701a3b8221b1f25db082814dd469b95049c4afd0cb650db68296a2ab3b91a0dd49285ff77cbdf59a7d6d16f43822072359395f5b932b188d6dc905b5c0aa997871c281819ad9499e7118fb026f6ccc8ad346fdee0561aa2a2694f56902dd8b1036123f4dbafd1cdd624ec7aab73904bea2d389ba4a7a74a4b9c180dd2bc6d84579cd94178c64f5fad0cc0dcae8ea861762a551f52fb8b3de2c1d5bfc3ec9fd8f61f973918b1d40bbaa340331da01c7007d8d495d185a38794e25bd609d0cd636229e0dbf2d4a584c31b255d7e1cf1a2873206ae962305ff1bf434849a43c9e62a72a3008e96ea3d674b0acaff0ae7774f06159a63574d1e912dd7a2edb5e19093724e50cbc866ad396572b97924e7d143ddedaa24edb1248db836ed80b385464e499ac376e2ad8a4bf46c7933758d7d6aeef5a204a125073851b525446c6b2e292697da8d5b5be5b8c91694c6d10fa9574a0906e8589f41a20e62024afb03e5f65d9ac47495a028e4916ae8d2d186055f712ada3e591162ceca96e6d89f4c730fb072e89f502b60abcbae5d024c8fbfc4242e5474005cb1f4c90fea680335e98e7fee6388702b5f723ac2b686bbc1c089ed402a963838302f5d7853d2142567d2b13856765aacb5f2c08151a10719d5ff5b98967700f27bc7e0af6d1706c9259f56b368bb212a9d018fcbac040e96b1584c912378a7b2b1b06da01a2a9a19117a83b8b7f91661b9fdf4a7d8e73db5e73022180a3bf5f79aaf6565f36def9ca9d4488c0d7c115d4d789750bd33be10ea51ce7edea1a8d1c2310a19dcf9c66f43c74a42b529c1e505040b9850589d75890b7b3094b473b7875d3681af301d836ee39d7466e31df819f7bc4ea312b576a538aa00ca2dc9221022b0fefe06fa16076259d7baf852152deaacfce450121d31e913b0ab0a1e794681c17a02865ee397521189507f8f5038e0d59405a37746966e959eefb70165f5767152459f1205cf78fb1f404d330cce7b54dba0d9c04752e3dd865830528ff10e5331128470d4f37f5bb62f6e7befa04f74892332f5c2f40cd47b7e609407e6f38afa14ef1114328c68416ca6e82d715581193d6d259d5b5ee64b3eca8665a0cec8dd3c4370f1adcc544dc827a5e5e094d89639d6f2f16ba279becc70d8a1144fe4cb541a108a1c1c39fe66c05a7d82cb2b86227bc31e12fd32e797fb57986ec35e80aed84238ea016626b26ce4c6bf53af5621b4fd661bd23d79f0f423e988cd703fff55181b7e0515b32fb72233e879f0d558157086d7b90cca16aa72ddb7a48f86f82224f4fb9af22bdcea9b48b4c00923ea4b9af59bac5e1855c9a7228093319430106b5f9106ed23ba7c17ba988b20e823ca6aef79b18077091c92eb3c1aac9558c6a1cc829737c455b8de648a12e2ebb897d65bba2327b044532e8b3cc2cad2d4cd9423f13fcc912b9a024e1c8b07f7b45845bfe4ec4403cadf5d545476fe01f211bfc668992902616efa2a185c6c8dd83a6a8ae7b128145ab88d464e3e6ef1b5d0001c8f679e00a42bba45410a3d9ecbd320414f080bf93eba95319a06ab1f4a3626f9fc0d6366d632187f3016807d59073d1fa18914a162bee36c691235fdec2a4fe1b45f41867cd11e104cba8e3a1666a883fad69df4b00ac94438de3db82d95e196554e94b0d740f1b5beb65157b8ea6e59ba25c4b0331af870f12082db3551a4be516b344126175a1e59b2c7d93cb3a1f29bc886319a68c35d7c60cb1c8d0514031f8205dd8183cb22a4e4754a19bcfcc911f4076665d079b903937695c181be8424133445cfbb12b5ecc22391f9ee2ef6758dbccc99b84ab07157250373a0378abfeb6a17c5859a2a3360ddd0dc18d3f4460db8572df20bbc3cf15fff13554efe3cb7d3b4f41ce22468d30ff80dfb60414d2f2cd55e8e17d78313504e8c73550eeb97608e5025302c3dfd9e735180164dcf0d5a283d5e20554376f49eb2dbad0d8e5d39d9d7a85d898b19df2d4f69055ed4090889e86972730cfa8b1df25a69b6079902973155242e1624f7113bb6cce4fcc8fa593b8988edb15e2b837ee3eb32061ab7bf6ef373e321af0840df42632ac64811289a43d3c27f7683338a57456ac71a558932551aa0af94a0d06be84c5961f5b97dca3c2d789697682c6177248a891486e0e0f049ba99d941f57c5292180a8d953704f9f3eb7be6ed4d89e6d41119792924301b0a763067e3546a764d1d0fe61dab382df96f6f58cde7830c9004bed46bff08a2ae7cc714e279a5bf6113b6677bad9d375a1e5cbd93228ff9041d1e93fadea8935e6c28671017a66312d27784c759847dc86504c30bd9949a9a50bc907809bef3c711f1cb7267082ed8a79f02269bf3bafa5a346a6446238684ef75834d94c29d1bf0e4d0f5a9574827cf201247f5b6b549312060a79c675f6083bc8d47656253c10ab6b358152e3424a39032c4549e56b5737b8b9815ee457afd213c2f2d2c86989805fe5697278881d7f413868d19ec8cb8e2af1d5438ca3ca6e497b52615063b272593734566166791f59729b2065bbb9472cce165a134d6f03696b3789e74fe590ce8f8050053cf3db38a74fcd4f5eb015558885fa4c88d23293235d35273f7ff7e0b88ca6712dfa200c702ba508a4c793f222329e6f10325b6fca3f3e7dd47fe32aabc3e8c9dbb3fa8882f2181124952585b96df7955e746466da25b0921d0a6e71a7fd9793b66bd6b40dc224b8a38803f580f8c04c07557ae765c9a7508d3b25d07a4b8ed155c9d88dc4da26f1cb5cbdd17d469cb75e31e86b45e2663ffbd6e81c6251c1b3fdfb0976aadefece36fb89a72dfde302928b222e591dc0de4c8653b0b9a02adf6ec6722b3c4b2465a4cdd89bab14852a36c23d1ab6f13bdbf2ed6a3d162ba31ad8a0540b399c83cb868cd3beb0a61108fbe122d9764f160b2f6f78a9f07a3d0d73549813186e0324496a907e3ea680b5a1ea5b5b18c5837595bc8b996907847f2f8b81f363ef10eec431c492a8909cee29343b8403d434ea2ab1c93dae266acccf56a11ca1e32bf9351ff8e4be6b3494256fdd31e62de9bf0ab14d263328a61322a0ed63bce3ff5963759b9a6626bec7d7b6f42e2116f454ebb94188bd61e9305f9cceae5d46020173b021200bb631b68728f46564792c064f1c3b4749087a24117c810a79685c3c4498e1d3a7ba9b79d9ad55c6681c7b3696d86cecfa871743f1d6b8de92c0b4ee45eb447bd6f1db2e12bbf61c5cb354918e7ccd62905da065ab6b501c779a661a352532b5d64d1beaa9a9e3b61334ff892c92f8fb0bf0d9193a834ab6085499d971c458c9a8b3bf0533b782210c4400c746d192ed337cd6632e43877848d9a66a63ced516488a38be6ec79bba7c43bd101472c2b9dc8ebd8355e7185af229a4b50c6bb6acb10f6f58a97ba2303047b0c94479fb8e7a7267c3982101b2f6ecc221c1afb8923c79c1626ff25b37228293cbfbf309357f1a8433781986fd91f26977557e9a1340ad7b42e63470ddd6b4c8136057f176be98f94e8489788359bf8ebca6682fa2a63acd0283649d7cf0a24689d19a3769cefcf338d7d88dc81b92a708bb1a4d068f5e4e80dee1f3ff7873498f1598bd2716d1109feb3fabbeb74ac73cd6e5b0fcc004db882a9069267a838dd1377b004a80749f6c28a901262d995a3fc33941f4e88a570a819b7b4de53aef1bb69367c73a592cb950d6d9af24af32860d7cb53af9aa973325446adb850c1e832a5257932e9cded4493f50afbfd06d41ce818167aa8b780b12dbf317d20c7f7c67402c7519570d99899726ae79c8b501b029acbc7bdf2c094bb6a666673b6fb1d6d52f6717b1f21f9aa0bbc6db3f269b6b421eb9a547d097bb8b8b05e2e84d9821fff6bd1d9ad056e673f206638635b07e3119d73e7a29e76866657d1bffddd79f6dd7af6abcd1d7bc3f0aead3579359521ca8bb09a90e5638cc3930f8adea303cb932d5d82739c35bcea4776b55d18eb24f0386541b19ed956961909ee9a7ba91375e2cfdd102c738011a48126466a4e79efc35d3c0ca65d813b4e99934eab98eb45538d7cca3734982111fe2112957142e4b859619e7ad2d5e5c82695064c87a521440610e30d8aa6e459932124935c115152fe345df9b3e940e778be70960b4ea19d1e41923d0a6ff21c84bf5011e59321b1d6d88baf3b381a643d618df38ea4e6faeede61be0a7c44d8dc9262ea05e3cfc649e13bda7053800b6e11959dc5558c6475b46fe18cacdcf3b5b8e5906cea7aeb51920372a1f7be7840d5ceb445785f44062e6b6290165a76d699a925251d613c5aef3d650070a33456f9db32c1233c3359ca111dc7dc8c067db8c01cad15eca67b69bf7340f3363c0b53ece3c8a91286d22a2b2ce00edeab393dcd919a70ac1185da7eb637b7d276514ee57692fa41011efc1ba5efe39a62332cf30954ae4a3089f3394e8344f8ff905a14294c033ec035311a209aae0f419e0ba13b226971c03b1a3e416eb52c506939476a276f77e269a0cf0922c56d282d1b9b60f151f8af32604d39fea9018f5a8e3ff016deb21698001e56ad4648993d8548684823316b3a4afecf7fe0253e43862d92d18e0946621bf441f8d9551ff0bd27af6fcbacc088de3a45a6e5004b4a9229fef9a9ee31226006a3a8ec65d53e39d466a8689492a31ce8a99abe57d870bb180fb3059e51ad535316872fa58ad61832e52c3ba61e242883f772cc5e22bbec93eff867dc1d5a586fd5f4102309977d6bcc7eb28f57dd6ed2b20894d42f787803ee47fa01376ed469786772a0f512ced591f005f2658bf4d74c6d34e10451a5919e07b306fae1500108ca75bcce842aa8ac13444a5dc60ec7d0439f17a09de8449535c0d1c6699976abc24f01f07b9f80d82b160a14050a0c258796e22fb6454d9a55203c939b73516332d63a5c28f5e863b89b9059dcb06184ed2c9015fe51c01f77bcbfd70276cd72790b01f3740ea55d7583ae0746f5247476f1301a61ceda70652b2bdbe9e738507db19ad5060d4e475c59f7438cd54136646c7a32479ee708ee5a7cf1b42ad6a59d534397d95bfe9ed1801e3dc10899cbdeff2ad79c32e95959febf410f9a40751eb256d39e7bc3530cac5a82fb9c6dbcf6db3c1cc77ec603e8424eadb3b2a1a808f06ecef98fb644b00f4d4d3e8a6a503e5799b8586ce6b64d3c0bcfa59cbcace5d39235992cd0095f16c6c471a355ee239b0f122f81f6339c13a1ddc7c3d54a0293db886a2e52ff441ca19977ff8e747bf7f9cb4c2c46b90fe9993db837349c0aff682df5c8bf321fb782800a6c354d7c7d841e9d583df2502a1b555b2d063b9b1d65bb65aa1b9a746f3b08e72a32e60e2249967e307f388f971efdd5567d37a04bb4d688f786db6bb789772ff1937623091b6feff5d675831fe64655a4d8e60890f7f4e1f9b6be87f37bf1143de24223f05221996c99306acb24f37c884c5097abee035d0d548d0c56d6108bcb4c2e327c94bb80eb6a4a8f1812523e7697aa8004e230401c28c489a8e55992b79faa42d2231e33e80c49e15fbc126f9e92bb85f57394e089b8c5f8bbfa65f14220b49703d5db761e7fb465750d569d700364b7465aaef853cafb4b7ebeeb1e9225f9c0cf80ba5076d43bea888926078e1673839cca951fbb81753a5d3a980e7e6cebd77827e506eb1085b7bc23d696f9daef5c23fd23b95ca01bf78f74e035eca6d6135ceeee136b00bcce49b460cbccfa22e284e544f5d51667b31f029f669e2d7f046f7de98ef236ee529c70eb442444509e45bbb13e268ea8a657d6a974901fa0e7fd881b06003cccc9096200c16abdd6771194324b3e15193db21213c8bb57ba5c40854a262e1b4771c0901ea7a3bb66052ce1d0ab62b289aead82ef34fed780048a521c638c76c92e92fac981f7f9d75324332830e8651143166e5cad7c2cce42189a6e5fa2a533de182b8c681c3c240c5995a9525f7ee076c13538dc44f565292f8b5dfa98096f7ef641047757686414d30b06ba41b7b92c12443841972cdd05fabef2faf487654495520d3a1e674f4df738fe4e73df83a71ab7bb6a99dca52526fc3ea8eeb0b634c511b5886979ad18aeab5d022aded0a082cb91a0a09155a25cf5d111b6704631eefd09e5bfae7e4cd29477250c4dea8ef170d3431c3a05fff828ff1339a9b313ee121c8a6027f2d41ae10716a39d09ea1de70f7c99584f26ed864498c025b3e8c1f61e446c5ee569fc3b803799528c01bfda9139e96d4f4da105867cbc85ff0418b9f53b2caa903569a5767267262757a041ad265daf443464062b3d713c2482ed2816e28ddd8a860684ca3eba4efc961864bc1ffdea7d2ead540ed0752a531e3c82a17293b7f96e23847e2dd127cf939ffddcf12b62376346f0b0194d2c3347a06eaa665ee37b41cc93eaa888604b6be13af243b9dc7a10f0e7b20f0b43b3d499970316361cb225df44ead0b06b9a1acba0d08d6f43a89d436048c33eaed3a14439770582fb47a65b547459233809745fbf71f10739dab63026d1c06d006d56e2e8a91ef3a77a5237fad2905889da30fc89702a8eaae7bf3841ed5e447e3df38509041521d7f0e25b37ef419b68b1422f915222e9e648160cd95d57eb37b850bb6447ac9a390a12c6634234ddb0eef651970468c964fd4d30846366761ae76433a920fad1a333c43baad4d3c6ff4ae9d30a02a702e97f376d320be2c99050530638fd964988221b82963c2399e56d5aea608b7e33761400e000bd48878749463159d6a014a7ce10bf43346bbdf96383af396ce7da592f753ad86f9b2151a4728b9c002301fb070c1e4bf90154f76209caa50cf7d8673718f08d0ab9e52940d87578b24d6d02ebd23fed7e43d9141a185fc4da134269be90d32e6510942f327bf223eba925d15018db6b2b9ce0c399b23088fb00894b7350510b9ca122a19823b46bc486bbd14822270051875f1eb6924ad298409b6cc9b90ae3c2fe0a1ee7cd024049da41798b93d09cc8118bff9c164cd5349aed3ae7e0cb021ff408ebb73ac4655c59b224a27863d2ba8c5917e59edd317a5e7daf89954f921c9d4cbea115ee18fe080e829a02339e6cb550c8823d64dbde2a5ddcc1d1f3a04a91c8acd345c916c060833a4366f12056e0da6426db44a874a7aadade28411c651c1864499063fd8486af7e3727de240c1675609db485e4bfd1f78ffb8bf1bbc00bea150e421eb8413db4d21b1d459e939be23203053535fcc9276c992172d8382e788d3c6d4cc15eb2bc4075bc8b9c4b8e6bd813ab6583a82462d4396e8e3c867dc60eb338497e35660685bb1b730216a00e78c44341b1ba54e0b93aaff1c78461d86548e6679c72ed5d32911b70b1392202251283756afc094339916ab74ac26cd1a754db1a33d323a63778521259045bc88ac52772ae83fb463fc66d0f1e09de04f3375e7d2302fadbb79a72af3fc864561ff37f9127948c64768b77d864432db9405c713584c3d70b0d17c44c5a7bbbcdfec9a045ad1d2c3118bb9a623997c81553e0723d2e251d24282fb976a5de1b9e00df053f0dd07f5c02768cd30455d571ca161e75a2f543469d0e8ae3a2f50d9bd15ab2a6e86b31df1c83b20176065ca98af0f8fdb1aa6fe9ae59760166e7a1623e2fb2a41d0732447e2154e25b605f0097383ce93ec10e54eeb58d4907e396c0d21061e93b28855e3d69fd9480ce40f62a6b2ced8c695040eeac9f757d9d5d094c8d256148dcdc9be1ffa01608388e921bf552985e4f3375e03bced4e4d2b7af70eab6e74047588c0c6f158f8ad893b6904849f5373441f74be4700ae89ee78e5e1b35e9f42a6de2f4d6570273857da7488466a072b5b07df6c780577f3758a2f23bd4e318c143a72835924017e4007c8a14fe2a3c68385cc1e12f9ff59fa1c5b8667b42ed439cde1dfe7a0334d6ea93bdafbc38859945f48f3b03ef7441a5b3d4e95d9c1c5d87964b9094c14dc8025abc844697bb16a31d74f19a076c007ff00bb98127504446b2c95967a0be019449f32b814979ae4222323f9c510a42779893dfe390f7e0c111b9560e76dcfcc7d6e42e3a73984b57d7edb957cfe434d922a1cdf4a1f432cb57518c6739aa61e3d2cc0eae98ec9101d2422d6b211193cd4322a566c66a60d8f4592b23cae6b5966e4aae623fcdd00664a6b885c5996d17d2414374219c958a4e495b3736513cfb8d7cf80f330b2e5bd5f27ff66f54296c8f1c070d26171b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
