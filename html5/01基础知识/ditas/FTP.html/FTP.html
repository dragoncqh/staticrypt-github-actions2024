<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb633e7555a639b5819669b6e72e8b487dca81a9e37fffd657f40adfc0303381834c74596ac4ad2ba94f3dca1131d7d4983eda8bf8c1ce113b1b8d8a94a4f1251cd710e4e074b8698c974851f6ca2059b6ef96518297611a788856d6d58cf95b36ee69af97bd66da0ce6efec7d2a5e2fccbba1d4b7dfe2509e156e39408aa7556af0e3af26ca8560b2ced942b4a7cff63321c23247dfb329586d35dc826a608b41d82907f3fc54dca99f98be5f5d0044de0a66ca8194d95a86fc66dd934a4bc5328b59c581c7a64b7bab78e982175dba94d698817ea41dca08a2e8a7a63000118600044a661f3a1526d73ac21553273edbde0b066a4366dde7e1181de8632f79edbb5c3ff6edfe458bdca3672aae9285da915dbc168d0cee597c4282d5a79447fb245a5b19a3cc94b40713678ef7866fb914b16607c555f30c7eb941007818b6053db39690c61254fb6cf583ff7022307cd76fa4ae231cf9dc6c0907a41be8b1d03a272e5ad40310978e6f0b19df81d45cf71814d5c422212a0ccb6d9a6a51defca762b73404bee74458bddcb019424c76f971f14ab822d6aad051fbc9fe50a95df1bcc5783196e06713db72167a9163ef9826e238fc67b1e008e752e1c454c5d57ea94d1527c3a668f78b828170479703debe69d7feec54786d4f2d5d55aa3592fa16ec7c0e2700f358106b8918f3fb673fbc7ccedebf2d0c1fc1599cab06ed7b5cbf5bcaeb03a9d43f4b361dfda713fc78224b00688b5e4badc18f80c85061e10c223a8196c0cba9042bee8632273b357ae1513efcdf14860dd7ad42966fb13ef81268af2a29da6cb0554cd91a9cccd2a78896555e8cf815154fcb2a69365922bb553e025e4b9bea2a60915d412dd876a85fc266c262cd0ad6917876e246afea6eeb14f9609a155b97477e011802b59e67d159d4c244ec315ebf9dcb6e24d2bd7a9538c5ce0060926f84ad333563e7ac3ae815afbd94db20da864a2e589afd33117f22281fb4db17062dc4814841c19ed5a26d37310373b65536ed947b7f7cf614844620ac464e15dc031097ece417fa1ddfdf2bf71c1e3962aa1c35492e3d60ec6f6a30b42ae7e55cfb6739eebd749254ef727a764267e34ef321ccc8561436239dc52d44e64b13f2663663b83e280ab95bb00e22798ebf5b199f24dfcbfe8560e7f3a4430ba1b06b26db5d9f102d2dbf4c80d32c6b573470ef20b9b3e48c2b74681e151481aefeac07589925279fe160e669e8b4b7999f42adb46d8c79f76a4ea43ce716c8dd9ed0ffc0354415e7334c1b9c27700cab48d97988f4b2461ba626b4471973da2dff6b7531594f008d924d9d4487efabb9d5a2bf314e0a518cf79fae3a68191007da75d8d39c41860a263cbbb305ae16d99bc1c78bc5739f9974ddfd6c32648e2834cc24282c5ae6076ae8296250faa5128c682bb1fbb9bab064ec6147ef475b83a1ffb8f9b728b984dcc96569a3547efd084fa616803c7ee7dc3b76c64aba6da7a50078bf3246744f7f2d959083f8aedfaa007aab73071d71f9fef22aea062501ca352764c67523ab4656a3f9706d56450ee72005da8404b7895eb9d3c3279afc0be89abfe2668024865a5b19f04b969058def0c582dae4ef417361fe124a0adea29907b7223cee312b56550013e5c81430432711c1070c070be5609fb4fc8085c42eb0d5af90887cc0fadb0ce8424eeb6aab0039f4046304e84277864a0e6753bfc2f6fbbad2a7466d62b03a4e3d3d350f37faa616650d392bf3dd3df299501292c2e5bfc7226fd5bd87a1720949b8dc9fab1de3f216a0d83a93b65357957ce8570bef74789d1e6389a679e2b6f278a470029b10f18b343d0a738bd7d519bfd1c8267ffcafbc557149b7d756cd606c6266d4cbadbf8d3c6277afe392fa5c39e403de7f6e21a9fdfa93b3d7bb52969890d746dbc05a9c3cc6eddb91095dab488329b4c816f4c0e50d7ed11b0e3c754bed3e3adac0855c07b5ff5695e1a28f7ed495739b06d382d0826cd8c721acf0b1f0a0b42d4dc52d0fb11aaf76641583c082de212c2fabfe57f5723f125c9d306bce54f674339c6b579708841d66a23ab98bcfa3fd90bbba254f9f4e5bca930dc666d4b5e4b92958b2c8176bfcbd4a6b8963aecf54307833a392f54b7b4bb2662ac24f42ce573e0796d9d2bfaa3f0e4cf8b52a5392d10f76eb3f05a91e37a755d63573d5b363c8ebdc9336d3443fe661420aad2e44ac51408c3425fe5aa80aa30b985ba8b1f271c6065c3e489f3d415b528899210f3c3b761d1da4cb4d0c86af9beef8de4e1cdd0d5b182b3b7817feb8f55b9def22ee3c396a46132509b62433999ad2ca779e3ec48e6a49eaf44dce855e6682f78bc9d329af74452dc49150a4601a811549f29c17f53b629b7b0f62950a2bed19b851249267b9ba7d7deeb5e134c4818a6462ce921d74852dd355d7a8ffde8b016a5f0866ab19b29dbb0a2b537d3298148b85efe2976090550d66edefebab4285998732f63543df32184d15cb94363bdb2485b3f3f3625c8b2ee24d8d58a1a9f362c549ef9cb9d48da3e8b93423547565ae412b0049c0155a06185ae5ffacdf73edb09d331ec20d224345800d4f72105b26476918e35cc40bb74886b3526c04fd0d26f466ffeefc447402fc337012fdc6d5695eb4205dd3f3ca351d3ec493b271ddb2dd90a28cd66c1dcbef815bdb42b88e77b0723aab1fba9316773a3473ed1c6758fe72279ec213ebad22a0df77e7aa9aa812324a07ba5f0f41e0ce19e19e2ad74dd6ea89d5df4c86c83b7464c291d254f3e898e8c33ad10ed5fa02727df632be5e6d87eed17653dc6ed27e4cdebb7b074ea1de427ea07aad119cdadec77430e2ee6a834da15255f7a1a31caa262510e3571ed1cda3b293c0ed1847c6da2ede150f2d283b2173bea404b7e7293485dd59e5adb82446332f1162d14273d194b0213c0d33a0b7f1b84beacac8c387f4be2a7641857f5c2a2417f1a56c363799572e0d87c8f6a10b01aea2dafa15669ef60679bf4b3b93ffd4ad8b841c98b9b42495a8e1fa28734ee8069be540ed52af3e579bfaa29a70b33525bdc06426f42dd6cb33b58292dd5df0f35019ebd68b3a533b229d657fbd98480e0f37f49fba8b411e9a1adf7551ad82af9f43031956729698875806dd1b98821ab847bd08470a5992d007fc434bb9894ed9af8bfa728b15bc79a74f3470cc22a2743a5f814dd6335ca704554478309d5c86444508543ec6cb3c46f4d04abbbbbb5ee8dab9a8047ebb8cfb0d4ccb067715fcf5fb01baa3b4cecb7acf54b941d5ab0c86e33a672b29e889f64cf9c32a65993d33ed7e30b83ed3b6db67f9f2e0b527f9eb1c31358ff1d1593b67a0a4490bb8cddc40adbe2d295933290fd5b87eabf0a749495f7710017e3a08ac8dff0abb86b99b94dd2b035c5f40fc739e60a7d2db78171e0946aa28ec7421be63d1608a5b241e86fb054a91b24801912779491e7b5d667e0ef5e9502ff9d4888f41fdbd01a63e267c9ed1cf649e1456ad3180fbdf2a2071152ca45e55526b1499f6a7c224badcfdf890e5755a4f87dcfd7ccab7a22110a1753ef0d92de6f87fc1194a1563892f0bc09cc2a44ae6b5bddaa9dc339504a794f86a960e8a3f48a9801ed4dcce8177a85c64b9953b6b9f1d6c9dcc45a811e55f2cd1c880871229244651d295148f93a19d3db9ad485f31d319113fccf3604ded3cc9f7641013ce4c2e5dff84dbbfa25ce1c025a9ef0a74d5d11249dcf4ca925ef0979a8f75184458900792a8ed45f8238b8d5256ba005100855e6b73fcee4e29023329111fa2746eff88733745dc9e8813a45d62ac90137fc6f597574d714d6290637800d766acdc71cfd8541f4d8273ee4a3596a0542c6a84cd591ff2ef25d0cbe564b9c6af378fb52d44426b7e46bb122478778804451d2d1c39785f8e6db3102b53f843cadd885fc00e95f9b317b25a0734fd81f9e8510b6adcfd1e44f552b4fb16e02815cff2fd97f0da5c2546b84ac8ba0905c6d78e2de77d39f381d70ed5b3ddddb8030a1b36cd5911d6b3b44ee9ddc53cb5419b89b7ba92fb0e61421658b6d825a31c9a094013f268328e81de5eadb4b79f42119740e3a0af7f67782c43d61bbf2ad4861e387784a90d6fdf73097dd6f8bb0da91a7c0ad7bce1a6e00403064cd06a86b9d5544e45c6ff490aec77986b1cd2cdd1d48f5a1257168dc80f4d507f9de5b105cded73e56f64192002d5c76147885129a86fc24e6fe3543412d50b169094591f3254e5c0f3a9ca9bfe056ba58c49f975176553a12a09789a78331bcfb0e8f0ca018ce796b369ef424ead639fa7dc9084ed4416d573297200920b09032331dfb50eca22c9de744dc5790eaad7d60174ddb73c30aeaba7d414eefb634e0369d36348897cf45ea8e7d67986cf8dd4574b9555e6b731e814ab8818b67b87ba908bb8978d19d9a0ca6c48e796af7dc099410118d4853c341f9da19d7523c1b6569fc7bf0b0d197ae8fdcea8d39684f49ad6ef82fbe927e3ccfb32d55e5ebbf890ce50e75d92cb2b0c8b7ddd901eca30ef47c1d377d6306f70875f1730315bcc6158c9e4c2a4573a9369c4b21d12769feadfc65cf8e63fe150320af28b01b3d2bf814714f458331e51b133c86a813fc97a10fec41ea67963a1f4034b5d02a56328baffb932bb4fa7590c244cc300d96e05491cef3812f1a85673c6d2a5173902763114ffe20b914e3e8d9e742c755935afa8142d75ed3ba706d9d47d094a768d92b851b6fcd415d54d80c3f67b299ae4384409600bf51aabd3db267f637f50ae2de16f7ef7e6a34c7d5a5a7f79bbec1a429ef00bbbbdbf47897d21d8768c35f2a2e88029c312e98b92a72a6b3f87a1b2abfda20310b66a4e57ac0cf0e475ac0fa894a7c076fbf2883389dafed571020cc6e35b678d6f069a6fc9709406bef1a35c95e154407205e88416693753e34c0f2fd4c22602fd91c320b2bcfe314b9f24e9029b16db87fbd6e11968a2277543315c4294969088e4518bc1b9af2918328e50ba5daf190c35da033cde9af11f29b16b5f737adee54a353407e6a158d72bd18517e256ff6b0740ba5a0874b3ea6865d981581bbd7e7d864b9911c99db96147c1256c4dfaff163d4a76e351ee32ebeeb8f0ddd24cef06b229507a35773322afeee76436cc64fa1eaa177e6fe3b9098533c8130d25f66c736f7555be1f1e2404635f5491c6ab008da99a10cd8307cb85dfb0612ee412f4a15f953a79ba9cc372cb8daaa81dc592423ab5d40bd3c0ec6ecfecb033dc43d48e5326c4c58a1024a67a7c0f6e295b0cf9be80e633ad1ace96f6d13e8da92caed8268512923ba154fe374669f0a83344fc5857e799304e40682847f25339685c1815eb7fa4ec6f674a0d450d12edfc83fc3af33e9d985e107a059ca273044c10e19269caade33a9d716324e767b7d866bc0844f1c324fa81666853226e63d26f0cacc0b99ef0e85ace275e4be1e3debfa08c2bc30c38e0bdc35873933454135bc1083e56ec3650f5197fdab64961f17a0f844bf0c1b450842450e57486213dfcfd999049b29a94dd4aba0aad7a43eda9e8a09afa76e8d5d55a3177c413b714dd0806e0c2bdb7d6cfbaaa33211fdac6444112a6cd2dad136171a90370a0c83c38a118c89eb0238b09a0cef77ca1eff0f50064475b557b0d57150b6efa1357691d7d4d854ebc3b0defb9c36d960ab92f0067cd4628887406032dfa27e0e54eed1aafb4ddd4ace562964c9a8d9d0483fc1b221be3c36651aefcb01469191996aa7b0cef63e5438c785bece334a012dcb310d36c6e647c5365120ec849f39bc16705eedb433046d87b9ca5f6e153ab5900ccbc80d95eee6391c9176a7d9de24831c73bea27dd39f4fef7fa94a6e51a9c1d6e407fa01ba66f0e29c2402d34719892b0874599faff9161522aa8d6f8a8385fc4cce6b3d2abbaa629b9c8c4b22471a9bef31ef29edccfaafeadfcbf8441a707bd5e4167fe37ac05d4d13a49c9e067151e69ad6355894f6cc0d9f992f1d1334a76c34ffb761eb58bf6bb5e16d7405b756ad195ce63e165df8b13ae986db82da06ad88176b49279b3d1e0adc8cb4e003e159a24d72f7ac1059ab1c6795ec08bee05804d63ce86b5af7782b0c7c2e83e45ccbe1d3dfb2b1106a01d66b9abf9cd357f7afd28fb352c0510d0678b98e956e5d037c6fc6ca145976bb28b4e39213e2bb225f12b98537f6704e527c357f517f6ea97d756872a2003b0722f1932374176a00eed20b86e2459eb4c9b1916d77a82e2735e2899bbde6a4ce14cfbdfa7f5339a22c043c8952f148a00bbee6f7f2c530c784242939d1e51bee609cca66afc805ae10d6bf8b84a3289f7a93b99fb988cfe92fd9b491642cb0e56444e3c38c430da1de4d7d88d80f5df88818f0ad5180dafcbe8929a128e70bd7ea964c4f7363a28aa30ed37aa47bae56799c1ac5bc4efc8ea0bcd4011df72fbb26c8fe1f9a8c98eff444a4af0b876cb61958240ab3fd948c48a836d553c4b56821a144ed6b588ec36da58fd3dccd60b681cd255d7198d818a24a5532b7282f0814f182ddc41671511b2c717a096ba1e9f5285e6329c62fa6d3c5d76c4e75d2a7b2917af236aa5ab836ee6b82ee4f5dc9708d60598ec38e43d88e3cb348b97ad30c48d0b7516545f70464358d8213c64dc8e4444cb6c0cea62d41c6080458c2e6d760478945e3170364df3cb210c815fd03e4dbd7c91769c53c53824cae2f7551de2984525fc2f20822167f2fda73ba62475b45dc9333ab01a4d903ce96f529d27ddbd48f58a6ff049d5bfaef3effb891a8c54db55020224e0328d550552eb8c0eac08b90c56fed97126f319cb8ff99d3a63cdb950a7823d6477fafc3e1eede1976e64b3b54e1e43d0c7c7fc7ca4d4d251de723e8966fe744cf16ee631651d221ae4c0e22520588ef9410ae98c077f0ec76b0b03e132a14e483b37056beb5acf224c4347e9b467ea38fdb167736fb0440c5187c64faf197ec71e1e00d9cea8a6e7ac2eca97ee0fb2b9671b2736109f47472ab4face2897372d0a08275498fe02ec68d73fa54da8b0ff66f548b0c41075b0341ceb48e6a6219f299261dd771ce84e258cc815748ad485a4f01478aeddda2fa23fa97123bafdc70458afdc0a0e0de2dc9803373e0cd3aa9707f4c004422d0fbd7451a7c02a9413968ac609698d718140dc16dda91e8655cb755a75bbeb5e1f0a6747f1fed78da919968f2db0f52122742eedd42da92bfcd1f89953f96348c83cade0764fdcf2c3f521888e44ff720bbec705c192f12249e7d661b1e5d370da4b23e84f46d67d97bdda867809824640a5c91998657647df362cca27c6ad6483d2c33bd9c648fd28798075428a94f8c788bb733170c5e25f27c0094e309201d1b55e5af83627f55bccb023b832f92829aeb9b7099a14c26bc336c0256bb4ee3839c742cb9d994b568384bad6a42e33f428f079e7b753a5bc4093a4c0564913629d679cb16156dcc3cdd36d3dda0eecafd065597ad79cbbaa1f5fecede315b91ee726dc2858ffd6b6481b4589eaf725530993c3954b3b3d89b365ddda8aecb30f9b981f93c4d2b52b637afbddc9a1ad02d96423d99c110a63356c3cd3f05a900bab04258036a276197eb2a54deb24864d595dbc7319b7e26634d39bf4f22d587ee379f30d20c61df16747a103380cb2fbc0a38dddf6d5fa3c30ee32c6cc99989d5c363e7e442450e221a4c0050e0d0ec4ca2c2916144fc8f26f767a904a9d037f0633c6911be2bf1de774bb4b2909b5bd3b1ce490a5e2de11c625f92dbdbbb86b075dc4a5b31dd96bad68b6760683c250610fb98eebe1da0d247e2cc3d270a06d8e9219501cb2a45a18d59c2a214589761ae81e745ce9c011c65a73e561b5d5c8f2f113c3f70ae4a5198e2339a76fde65dfe144736e0161ee0324f98202eaf184570e08452ccf9e293423b5b55054aa71c9eb639f6a200510ba837a27a96ebf44fd26146894f8d9997f588e1d3dd65f92a9eac12cbc7a6ce26aecd880cf35d7d9a52d9a221557b408e20612d7d1e5cdaa243f84847fe84da1a1b14448c25077ffa24986a8a6d6a8af61b18b612fed5d53f0e8821beacff2d26cb7cc450d351935f74cd4789b3f24d5efeadcfd753a33d1fd97bc13992d7f876c69a4bbb7798c154bd538f2b70d804dc062bb38a44e05489b2b31cdd3f26c97019740f9f7af1e4bf7795d8ac307c2c06a4ca0712f96153f87be3ff653cd79deaec09d3a01a78ffcb421b69027b9519e3af8f683d6dbf31f49a5d1f336573dc6547fa4b5d6e132a879a4636dc667f92ab08b3a2c4318f3ef868100739312f4a466c39aa13aa322bafaa1fd3be597e9a9e9f737279f81f9c53d181a766d919c96c4e3a7565881ad6724630e5bb8f8839e79633685692501c67be38785dfa4afb8f4039c67441aea4006ce88d56bbae6467dbbce3a92c16078cd149ab3666c5126f221486784ed17ce97859ca4c5478be9312fd9eebabf1150938dca91706807ab75a94980c08bb5184f2ecd07b40cedabfe4fec651558cad54588289c3fd4384547c06811689c307afa97fe301e93876bccc3fc1736c8e4b4f5d44543075e3a182cb9e4e5d0567d01ac1f536cd7b626a914c057c1350307d4bf9e6bbb3b974707c4c812f96e3f96ff492a7faa122507e04524980c306f4443a41eb08f24d14535c2e1797ad94ca6d91d8b2f1868b4124118a0df12430128891838bc40278b5ad1a2c0c9c764efb7c8f30f1099b07b4e990a8b1342ce43d569ff3e6de7e2ccfd6bbd2fbdd6bec07353c60486ddab7b5e5f72fd55e2fac1271350df50438d117c1752d51bbe86f3e2b89cb47e2cdd62f0f3d9bc2fa9191884c5f428c9af2805c6b4b6c5b33d71a5d89d00dcb29a357ea327919f023c00abcff16070e6b02ec83c39c66ba46a716bc645d21cac1e6cbd0c913436064d372f80b6aea902420d5b083ca84cb2dcb5873553d0c004d755cb372b14e41ffd97464e10fb80d2f0f985957126116928554e0f0a5ac2c4aae070a995e960aab0dd9d192b60fff7955d5f40b18d30dbc84d22ae7f23251862217b73974a1786f6ee3f5b0e6e793e56005a5d14bef54b41a73d34fab2202829ce6ce68791d0028c3bf062f34c78863309693d0985400cb15e72e7119f3499e3bb0807da6b34e14905bec8f189f2dd64c930b7f7fbfa17f4263a9d8e0622ed1f0f054bf4da64d8c784a5cb017ad83176efad6f84bf61c54ee93742594b22bbb286a448e59eeb49360cabc106d3eebec7cb66b2f68a96a7a7d79e405c21932ac9e3ec0aa3189e91bc150798a01e662b9f898ad2279417b3c87a329e4208287481c5f0a49d802d3b9c0a487324ea3482e5d90c2ba8643d8df62a82b440489e89f52bc8d94f62c5e9655724613747f5ac953e648782263210c3ad294918b9342b65b93bbf7f8ccaaaad3d368c2f2007ae312806f27b6fff04f1eb58c1743f01a6da885986cd342e7e930d25a4dbf962ec160499155fc1df40be480eb7dca831e6df5dd05c4b82b75b647fc3486ef76a6486f5cff0bfbe72d280090995a79728313f089746fa68f8d5f203d8c55294addd70fc83c91af89da039b963b90fd759f8112ac45155dd3a8a08297a17a88c8de4f045d83fe38ad0e9795fbbe6b34a03f87daeaee2bf7c2bc970108d69dd04d08ef38b4c41ed6e96e50bf30ba41309e11d1c36149c25e8764bd46f83b2d1eb935686df6a060d83cfc807cb2ddeeedeaba287d759c5069ac3143c6aa0de7126eca2ae4cb95a7bb8449be88d70a87a96cd5ce9dab6f16d8402edd6f40dbc2f34fe949cbc51460e2b5bb142b995d58e0ac7dd1af109f792bcf803636fe66700066f5a0755d2c6e8b3c2b0068ded708443767595ecc8a13332aecdc1249445f6782339a48867501ed6676a8adea52aa90f3ccdc55600850d66d96d7ce4ea3dad66232ab82ac87f2784796616b92ef5bf8b4e15f3f167faa3fbc6c862d1a4b1b1ed691ce022043d22033c8433b95ba0f4ac728569bd5627fe4c43be5e9760a0ccd95c08c7605ce8dbc7bbc67e0d68669bff513ee490fed3120a332b0e23ad2f6c50116aee5306993ce37736f38af10e57c508696c3ade225c2b970fee00de52c9ea6f958331d5b3c5c19d3127a4e167aef57ebcb97bac987270f8b9c6bfbf8f9f24427e6adc08c3a9ff5f799f70719ab3cf13515677da1acbb26115c86eca37a4a21d9dbfd8ccaca3a5dbb797378795e167e7f964b42c87510bd72492b7b2ae3629e9a1d92223bad7d016a6c61b98d65342caf3190fe481fb3d6a57f7894f4b7e3047a421a64d23a42e630c8541592446b38de4b603b95e7f6ddaff57b962ea35dd0f3d3316639d00d010f82327cbc3d631eb36f3d57edaa643dd22a5842053c17884a63330b623489e90d3286b74466dd555d543162d3eff69f8e81f79d700b5329c9e1dbc5938affd30f988b4474a173310ed0cc504bad70c7f1debb9ab101957588ba787d5741f7b4785603efc664ef718cb6a03787938592ddd2930ef3a10aec025ebebd05b03a8a11b4755d4aa1f1219ef1b6c73a5a7c48030dbb586798a984ed8b214efc762d7abf7e2055d70438b8d85b875fa9d2e5fad45a4aabac11c7188c66c18ea039537dd4c3c0b63b61d5bcd61371f2d6c80d2ee65f813df38c03066948343ff5902322f8935bb7bb35a6b5aa8c79d8ac79e50de3acd7f9a70ca19804d036540cbe528dce0049ccdd5056d6c93173c4047f47b2acd23ef12973abcd21670a7a0431e175d68035399ff2edd87db314a11ae1b07c9aa8a68848da5ecd67f867580c13558131b86ff238e4725f123c4303da24a8b6a4d1ba5be85abaff91d44a046e8631fddd9ef5de813249d66dbd7da6d707e453e2ad7faa47f57c7177c112084cd284bbf92b11d1eca94e6781d9f1666e056ac13a3f10582119d336a9fa4944debf2591152c544860b51a9cf24532afb9be3d137d0736be18fa8bd1a99e6724b802804424ff1f5de178fa6fec3214ff5a70ee0f410f40b9980a076e867a1c0e19a8b5aa5315292258c68bb995b3b3bb38c3c5525f579bd6a09b4ad0078409c34c979bfab83a5f3c9f2ce59fdf7762bc147426d98e3ad071724dd17e03ae75618e884353f0ea0e72136516973206adfa27aaab20110026c05b5f04df996a9c9c941557a72934e7d7f544be21c3f578f2ca4bafd57b4dca8ef2e963a33857e5a534c20d76cbf0eadbe7d963b73438d18eecd12e9ef4a0057e340d2588954350a6b62b45ad5d425cb81ca386a695012338031f96d00a8432430b28d301b693ac35ab47c5e73ba5c13ee71978add44149be7662893856c034006f0a840a7d15bd0acee444509480ae8d0e642af5f2f2b4e7193a9e855284dae0485f86c541f3b48b7c131c1417d4142412ef587ec71d0f8f15be1b495d56335ab49132d3480f2c2b928e5a5f2de17a2be648935b8bfcd4ce437351fa2aa770a04150b5742c1c6eae62ca5c25f720f53939495b81a8722e9803330109bdb2fbaea0a2e7bbe5df620af7921240f640d4d1af732d49753ccfa614c6d6e14e03654dc67013dfeeb34cb653d2ae95bb8613a07c29667aa3ca780a6d88677678cd4bdbf5b6b7b51e657a608c6d4fe9d4990c1dbce027cdf6821e8ea57de74b6476442561a5b0fb096d7eb69b2e9de5d844e1ec3ff9a970962b46a651a2b0a6d305b144cb05768dbde4eb8c63ee29d3e1918fd180e6686b8890d1570854656b0ce68e3bde31e01d584b2f8ea866df37e96e54d7f3369b490aed7e3788856bb2a436aeecf10bdb5c03edbe147a4b73f61e4d8adfd12a8055b25ad6575c63832567394487146c2f46625b2f60abf1a3b4f6ff35d85463676a7f47062b72b0e3b7f4ed9a89bb8d8482b8203c2c98601161e1f6fb063ae3546d2acadf9de316afb48a6bd8c85e8067db33d6b9820a09c47ac92f98585976f93dc6094559b330df248399548796dcd70b3c90c1022703b351117daca656ba35bc1e422a442c47a194627af4e1d21b3f45421b4051a30652efc8a2a731ff8bd3e41f089784fde6464dddc5c84bbbe98e306932ebecf6d22b0c94675c07e0c3a7220c4caeacb41c34ebaf4577f2c8e20e26e2cc5715fef66b6d3414f38a60209328ca9048985d86e82c0bc046d5aba6ac5070a494bca3f50ca6124e340354755bdd33f8bfd34061034860d21b6e43cf8fb7d925f74b5456eb55901b7162786b164c840a4a90c908cd6bba507d9a65c147c988fb0b22dded2224811338e3d9c753fda202d51adc68f187388673f6aeb5f91a39837d82d7f8f3a6a413faa2f20610bf6a79eb657a857246c71d6d378d6a02d3ffd397beb110193c819538931f95e4305f9bf79a72320558e92a329c953b6ed08c4602740cbd916b476c701e5a14b5562eb04a91159d0e36d8022b9ffa3159991b173beddd18047e136e96a9dbc0fc347c0f10c568ae176dc3b23270044828e1f1b401e522d16891985868eb98ff96f8504b2bfcf875ff7712be73d6c5161bd6fed3791171869b9ef0ea9e2c92eabe6171732307425de0f3690dd71bf4e3ce1b846d7a26c1842f10167f4ac6a6b23f571d9f70b22cc059e322f914b0ed83e64e74f57a6c994714e69622dfbb46d6ddd9a2f799bc5af2e47db16480b921cb7605c88cbe4e2a33e5dc991b6e3cd09266647edf2efb165939d1aedb4a9c9d98337623fa3813963e51b65463dff59643849cef1956585aa687df93576b1a4d566b4270fae5ee93af97fcdcd66d8b6a059419b4cf8bf3dcec358c562b0a96d8caa6ee0100ceff74360409f662cefe09b39f65c2ccb2dba6718554f3378831d3e02fe1448a7036a70f316e48ecfee16d79af327cfe71d020e47d3c572346f7fa3a2ea837fe0e9457cc7703551e213503c7d4e68be0b5fffe42125412142d0bc50a8e503701051ea759374ef06502dde467f663de9a9fb9056af0633782af6fd954c2052129ddfce7fd7a474de365edabcac02e34241866dab08d390ad3d185ac46a8386308f1d95892db56501d34c8916646d0835f94e830e84063bd8caa0efb8f20304f4a1d8a86926d15647482337ad4dae382b48ccdacea7ca07ca8c847dace5e1475394fd30740c26bff08c666fa0c7265750e4c2f0972677ad8f379b943cbb51a2f8d7e1cef92783bbf63472d3180fff7aa3d45013a82dd3d72b0dd33ac637d02876d2c68135f347adaa74949b8001859517435720472678b703db25f8515d96abf712ddc72c91c11a04379b3d44edd7c5ada7b56d46a89c7dab5f64802011ed5429b2011ad8c56b30b30603ab2856e278cf44355369ecf1efb8f900f0b4b5116fa90ba7c8ec49eb3d57c6875756ff6c41afddb6648f5f4fd48813a90fc683c812d9c61e5767151bced771414478ee309aed27e858dcfcf807994c758540315a397f80cedc02e971b941c45d500b9607a7d859466f3ff3e9d9235f3428144ee23ab02697cad2ded5fc2c5d5a95638e06e403a7995f5e019061247bd758ffd106c5958c7397e3d26d95cc3f4f0385e2aa79f4858bbaeb2b451468f4757a42eb12d3c138b77c8e2a665d945dc7a7418098aac7f5b0f9e8c25025d282f874e31590abaa0ad94a08c7706a22664864505603968dcf7ea2b11f8576b29a4510ff5fbc286a7927672397758007e0fa3b83be142e90d423281719a29b6dce22e27fbbf9c5d55087a2cdc34ae4b402eb0e7aca990ed4f22bf416954b07f377e53985a823e7d9d52034cddec9c1a28e3a3303c3a3914630167ed9c075cbe254091d7c033a5749f850728227ebe964cccb909e4c59a53a8b9be60b687c3d9b9e3190afb8582768062f375107f19dc45ca4df38c055b8583b8a6887725bd9c80635c0cd5208c1cada1ac3978854ff548a67bee77c6abdc53bc92349e74457aa6fed219a8ea70cd6dcf0d5f969e26be2f7b772f39ba5dd7db2aa6ea73180c3a42555bd6d02179e16d66f9066011874ae1ae3600712674b80f4f347cc3b9260182cdf8dea8555312a402a0b1fa9260e27fd333165bead7abc6ab0130b0919222b742450f0817e94c893a869de9507ac6ac5c43a58522272fe5f5767fbcac806607c074dfa9fe4a5263b883704a460ce94bdf1501c5cbc8eb918f2f3ea8df4f42c67d37d482a900af36d04d0ea04c0723217258f3e3e09276e8877c3f48ca40e037be3d55ec539ed1f277e33e5d002d181320f70cb61f45674d73d66a0aba8d284b2f32ec9e3e03b1e8eb565572c2d404e58c00af67c95a29873d81a2777ace05b68e80a4336a25df0eb997f6133d4925a03a66f1b6595c3988f8ce2deda398f365e3f374ef6f20ba658175afea5559937e8e70eb95ff1881d63ec617c3672bd2e682fbaa82cfdea303dc5423962d045df564aa5cfcbed2e7f4829450d4ba67942077c5bcdf9d3db7e6d986d9e94b8fcb6b204c70f5bb117125369171b71c356bc94678b13bffd86d2e0dbab6d49c60f6ee7599eb970cd424367ffcd05a3580bb07214f87655af8b4b3ff235b5933f2975769d5ef5a3fd77541179e9856f786cf2f22d5a7322f19558796297e725913152f0a47baabcfe9974fd6520d770c0e71cbc664b4510f84a607baeddb34041fa9d9ed08e5b314dff8d314441f9483c499e4e7b88b6c4ea60a67795b2ff397682e40c731be904a5e9a0d5c145049132df8862bf52b887dc28e3caea0be3157350f9aecb1ffe004a225830253e4f819714157f1d6f102ad5b30580a6e68a5176e925faf32a77dbcebc1612b4551d6015297a83c252d1ca10cbec943d62850d3ccdd8abbc5f690a23e0198c74a63a870847a2392a063c1435d7652d9a9457efad67e48d4620b82c6eadbc2531df2a28c6cf386720e8cde37b499c391c255816e8ec479cb65f3ad58871bdba3681410c76ce76c6112361137f5398a56adf121bc3793c225476fbca2dce22a32078c35f04391ea4130d2cd3b60416b96e9ce33f7c996fbec19b546225a449020f5d395b0044aaf6284f27a3ecbfcfb42650cb66eb529ef68e3b6522dfb822eb07d17f8da38c8829068d5ee4d23dd3c7f444af770b282b8f613d424d52cf99852ee49ed8c6d25938009aa49071d75a67b82fcd1c85720ce5fbd58db621231b3d8469aa4eae809e4b11a83dec511864325ea29fefc47f5ac3aeb1ec897d8446078edca06fb802d40330e9b1aede50e96a1934c75960e4c10ce54e0bb407e74558660e3e0f8d3226ed5e53eb0caa85dc8d24e9beed8ba9574afe191285cc9bc8834289b5c663d2f3a7468fae1aa7b87bd80b7eb4e3a724c9bb6be9dbe3e1addef40b9ea9ebaa688374113c90bac466afe3d48c4cfd7868f45b41d0680a6b4b99abaa2c1b729a856511122857a6787fc1d45aec08397960553e32ea7fe0597d46c630cf7e27124a4fe7e8c8bc3f2aba9e27ab5ba8d8af7fefae154e73c58d816e586b84e1a84de26a54f4cb850c56b0f5867d2603a51155ff370aa3e93837cc8b6e8715f4b7d1ca3c531992f7eaf5ea185db4255cf9b161e2e6f2c3b2e37a464a92dafa0473356bd3c84a2930aa522a63b8b66b05310901fff0ab2b8c1ac39ed6f65c62ebbaff50216647648cf3033fc3e0fb207ecfb1214dbe7343b44c5ad0bba8584dc2568ffc20b776c798fc72fcad9536426bef9c94c27a5288ff2a3230d35b25515cfcc6a37a86aad6c71522442119c55795a8f83dece4908f54a61fb5800287b2dc591192865559ba67b2e628655f42b4df6e6cda535c5e621fd80d480b92a126ef6c5070db3b80950da970b5a9a4aafdb6d66b500aa9af3118cd8c90f199b83566d0fee6a7ae0e8dfe7a03ab581f41fbec92ee9b393d3efa5e32862660ea816723d51cc34118e63958fec3b479abe52e72c03eee96e6c0d27d2a47f13b2220245e5a5927b3da7dd06afdf018a57a5f6eff17fc07c38b97226282b298aadc64c5a6fc3a554bf4cf457a80ca9df7c34b4a588aec27c1b69586fbf2d60d3fa699f86fae8f010e789747e1983e43e418b30fd131a77da859a085b8007970564aa95662c14ec4e55274a973e5f9e50b28ad2192bd3630e7fb212613825252bcadb9a2ba51c4ba4ae4deac1ee8632ee8b83de1e8cc4dc4abfae1bd216132d94029c4065705afc1fe652deeb1bec04f86664b61c236c9f842f77b3ef7503bc90dde8aa354f2bc6b18c7446c04ca0ac20b4bc653a6c229d950b2c1affeb2d3edaddd7b8ade6a3ccf1737a164502a1f10fdb49acd3c0b44989b3ecb92013849e5517daf694ebf338e8a501887181c87ff1aeb81b2b1fa86febaea0e6f3b3e0348360d443db38191dcab234458fd109c8ae56e0f7c0129951f649185bce1db81bb5a58f91c7648da1e83973666852416dc22a72a1a74b8a192b3c9722e2ec7451df5b767973d6c13b01c979d563c4f24bd36bae40831723060b1824f9c427851e10bf597e2e144933e8680a4e2adb8b3abad3a2ecc681e977022c9b604090edca57bc237a2aba0524433d7f7e1a80ab0892b1afa2f9d139b9de7dbc8ae762d0ddd1dd8b917a0d221f2357107fd2cd8831fd77f155b8e3bdc9d63a8d705befabebbc701d6161e224381cf026059aba1169befc1c41457a0ddb675c229a191d437dfd4374752b3318d4e87e750ac381d781d048b3e9f74d84623380fec936d683c09e1b7fefe65a915cd90f231c858b65a37d89fc2df13b124b0aa2203e9e26107f99d6d10b4baaca0fd601d4224d6681f906060ae57","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
