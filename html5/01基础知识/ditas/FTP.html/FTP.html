<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"faf2eaeabe6e2db8acc33c65ac78164f43cd81d7fb2de9ee179b9ee9d7ded8a12470462097c6834f4b61a6519dd8701885019a038256f86fca531298dc97973000aac6bd720232e5ab3a3c65aae17a81ef62fc19f57953ca46b1043e05b41656f8c6a9a2e587a849950634a3315f37df2794ce775adc127e72f754c87e42c423c4a6a8d4c0116a44f84cbe3db27e0f2e49f9e92a670cd77fdd91dbac0fd605dd381cda0ab84f30f7a6cdcef5f6d1f1d2113a96447fd421184ccbe8315ef9e93a4bf7315b9db9b5b549c8368031c4d8133075fc531780ad15e3b693eab9b56568257df96942d59c49f94b7673a71cc99992b7d4c90b8cc0e86cabbee1bfeb292669703e4695760e5076f6b942470d0b1c6a1f0aeadd6aca3d488538020215771efb7b83ebb1c26b8d042826722e27d0673171b468cf4bd75650af74364b5a2bd17c3c129ed86b7d011c4be9a499d3d8f7ff44b548ee77ab3fd97dffe05f4c69582a659ab99c5acc4ccb2c33e4d652b71a74a54183888c3cce2ed924ce0555ef6a9f186019e24eea017e62a8c33106d4778886e85a58cd0326865240153443b2e671a4a48377ce55a1b328b94fbcdb1da9cce6acab4767cc0aa93516b05e5cf02eeb732d23cfaa3dd0006e540f882f1779cfbd1ec0b4648505290aeea049d650e0262f83205dcfa0921e988967400c99461653773bdf644ab2d647f9bf12d3fa4a7e97c31197a450a09eb9257590680272d5c5f5c047d89a77e74556be4f169db86a25f307c3ac66c2403ac5a0ddae03eea69a34c9c0b34f1aa0c42dcf2df90cd5738f55a6b281a6f67861de4c9e6732704952ceed3e42af6a6e62165c890e660df600ff508530c9b60e72e8043ab57103a360c179093a77016ef8fdbc255bd7d186a8a2d4c08f55ebc2c0c53004e82693ed41a8a510880f8990a1bde18d2b41d5d8fa7123983d97c0af0f71eb064bc5d3116431ea6ee6b9eb02163f2936ff3cb7df6fc718a30b5197f3196b86d4f6db33793e0e736d72d266f70413afd48be446b7428ae96d6b1ddf04476274b41c008ecd4e2fd2f009f8e767c734522f7831b83893e9e323f97a397e044aa78baaba173520ea0b7a1c0651855fdb15df52990d8b970b5bb46a7f6ae5e4ee83eb4b2799ec4040e2324c796d173178cb02b03ac710059dd64ad0f41d5c5974dedf1a53f48d4c95559a2f30456d97939b4f2a78bd86345e359f3a9c13d1705709444f0a62d7cc30cefdc9691329047ddb00c9e34babfc334e75fb4c9d2e09fb49936ff6495a493ab5d9b44c41f3a23994c610cc55ab1511a0c19fc3d6e89ca7bbda1ea9b4929ca1716769fa1609fb930a382438b9fbd5984bece6622206ec24546f7deb6e79c30171687417aa6566870a107106985bb77821efa7870a4c2ff7d508914ea8810fafb9b359d3a88e240736a40169de8fc982dd9f93007563957ebd56ff4cf1b35f104571d902ed6fb9ef332ff0597e4ae6decb0e2430a158876b2ab6ece6e4a4359ca3b79d95dd33d5e80782b177e99b8bca73f4c33ce0290802ec7fd8d9fbfece5160d216b19abf952ad6f8792685b92282debd66a6a2dbac9ab6baccbcb17e89bfc714d8e14eefed76b4d7d487dfd2aa519219b2f57c7b319543883f4b806a173f09393ce0bc37e50d26859b495730b10cd38fd8b0a3c110a8d92354b6a028c1d3a215b0d8c329a93573ea90f896eb3d730e3b207667ce1b4afcbc2e6758e01df008c7fea7e67df678c9038664813f0154d30fa5cf9a4a1c78bb5a08237e78bb9c042b5ffa728968e3a6a152adb7678767369f864593b12cebd4ae31d384975576009d102ab3c397c59ec19d1d1999a65fa3a9ca5cfb872b7edcab4bc1cf77702201060dcaf3a0e806ae35e8d617df4cc7fb45e0f4a8e243896d578b4bda486855fa87558a68b9c3959290150bff143dbc8f9f16ad636c27f5d853e1ccd20375b11218758421e19d50a7ffaab52c023dbb958dbf57b1c72af614e5c9e8c3a793a30fc1a06b6db45163e607f49cf373b093dbe211a1a0faad293ef6516c5cbedf68b3f697c60e8ac894831bb6d6c79635630ce6eb7f388ecab3887c2738570812666b83718f0793ef3aa4f0b8e304a2dc163a415121e0e5be263640593d89d83ffacf4eb3c69f0f6beea829641dc3e7e6c5c31981f5f7e941fdba135c01e46c7260efe6e5c3c90e124d3fbd4e4ba14f26a0b4f5919fbff17c57606f43d20d29b2ef47f314f75113810cc8c156ea0d3629cc6139dbda1181c7ecd1200035c0423f0f2dc6651dafb7f3a34480c90541ddcbfd130012a5ad84bbf46149b810581f18011bb98e1a97af95a40ba1993e85f105c4c7e97bc2f5b1799794caf655e160debf839dc5cb91f7ab66c146cdfc3040706eb8b07c367a46ac7732966522c6bd5a6a1765d42b480e3499376e2f9485bb257085568bb2a531f4d1b62c61313949a90deeb39c13dc8030f1fd36b7eef4be221a4237cb138a18f47dd384593fbb25f2b615cb38bb97a7ab66dc535fb06077364e953ca2fed837ec797e0be1a51fb39191da60491b6504e4cb33c4dffe61760db55a1d6f7dc29683e29f44fe2cbffb23c99f075519b4f30119009f832c424c04b3a5f878928276c4a82360bb3892228d3bbe5ad8fad82b37fef394cf3da73e65add38bae53cacb9aa209abfa15555fb08e593dffbb232f6a31e6a4db9a780dfdd63ab3bfacf91dc2934da12d6fa66378dc974d8db9a8f64cf06f5f0d5a2e9f9a21c45ec9b73ad394d97b0e5071012dc0d098a938be30e673cf0dca9c34aff418693c5e962f015f6ead338882abf6e5464383ac1b6b804296d849f8daf9c89582c98c620ae5f32974960d8cfbe3258d31488865e7d9b40a0337c41fb51c62bc99ef34865cb376a81fa4c4acad4966eafaf0c496d143e8cedaf7b6b59aebb9f5b2f7d7db3077b57fd76bf2fa84cf7fcaf2e1f6e62d789a89ab7b9bfc5bd94203f92f22bfcb4e421877ddddfa11c05f4484259ade5c60c2a834e6db4af190f66a3bc0e6233abd40d6390097553874ddea21e40419f84075e7165d250314ad52725946e542669d31fb9814a6361ac41368c702434788f1c360e054b2d9965d0f9e2abab6c11761db89964679ee0cdf5aba6dc04a40a73df0ce08a23545b51b8798c3cd73e876997ca68d41ca86a22a67592363b9a7280fccfa61c0220723764c71e7166598295253df8e552d53f8501502790e2ebdec5526594cf7189904127ed1577bead3315364c7197f865437c58525b35c7979a57818b01fcff4888d7150d038d0438d1f334a834d075644d074d7b4b3a4fcae2d14f8b483f29324277287300c3f256683ff92759f4a8d8c66cc631a1f5220e32763c39854f28cf0bb4971de771620d73dd83aaa1e948807b38a455521363a3b58e43c2a8f7325a3b8c48841b4478b60fd5db9523fd53d9a6c359328b76d90aa11f360243a35a46fc88dc54eb55abdfbcd0bbd358cf9c29695c0de1487bfbba1f2ebdb77ef2dc15a13c84fa69f604d793ca5101797c907f26faef341799e857eac6dd7eebe7ba3c4cd2cffa32cf3cb0ea864b1c8e91451937aa7428e227ad59ea8861c8f128402163d67b9119f2295a777ca49da6613b6cb3dc73a38cef9f73fc3e9f81e6691f6aa1b1d395aa06c66dea239f213c7162dea451a0f5e11be25e0b83ec4d558e0d5c899752e5347953c09b3934914a8952940af39ab0ae6f1795419f3d473e41f34cba861de90773b995c5660154c5c91faad53611a256e03d608c735a249f32299351482861b25c92ab19e545860fd5c3ff4b0ce40e245993fae49cab22d88769bbcf220f49299de359665ca84c1a15d9d1dd6dabfa8616c8ca6372271b75f074026b9f22b783b5bb64e1955e8f84134e9f66a9be61754cae3737c20c641b703f3df41daca367ab496b7409a49aa8c98a8a05576b1596c9573761e8fd748e01497745dda1c6c5a76bf17d78c5c67f8d427080339ef7b019b0071b88a76c40f07f660be691f41cab31823b75b77540d89ec969304d29e952aa88689bbe665ae4faada8099af11ed1ec8e6f7770b9c1830f0b5389503465d35abf7508db05a005ef392da5b2d5b48d5a38705b7adae8b9224e0a1b343ef86dd0a6ebf9413c9d9ec37f8c103e7e8ac0b6bd7479f0477ab879973415912ad9a1cf53c859fd1f72adcc9f492f556b8f2fde26f60f09e298c0495d2c1600040521884f408342385003d62564d43005908e3b8fe02c4abfe886a7ea84d6d53822d759f0c019d442b9d76b3bd5ec2ef1a5c4ed87c4c78212bae4571edf01cc34505cb9faf9a72cc6e5449918bb17fbd159dfabad497ad459a57d853559d4facf1725234f2ef7e442dbc0b0008ba8c78d8f86c4d0f286068f8aef272e0bcaee1542901474c477993b03ab6f3b055541f06b4f2c936d5ef0cac40e9d7677996ea3c30a6d0d2f2549207bcfc19eab73051d93a07ffca9f34ae8aae31a08d313c7b58f3e9b95ac6e1b77f8afa463cc9c06ffa090d6c92ce6c8eb6af9bae0d4d5719613165f21f0d45ba8d5bcac7717dee35f1840aa4830ce43a0798c830d28adebc18e345b451ad05058386de2b57bcffc48af90c6af277e88b28584ffa875850bd232a9067c060eee25b89d437f34422377ba956eecd652cdfb5a5b251ba97c1f9f66af5935503b69a78b1a4d0dad1ce818799cecdd70b6cc47e47398218c54039dcc8c550946a985f01a0b710c4a15376776201034653e8967861e2bfe783d913e0d6401af4627dfa5c0ecba22db953d97d285ce3b2f72c18d7f5bed0eb7f8214fa621d43be451faf8f3850db44f34e182530e7958fef10283e1dfab5680a82a179f0ff8044e484ee0bb97bc1bd1aeaf5735607b1c137879da251e87147373f44c029a340dab080b89cf777e628b27d4d2df00c53c4c5b62d4a1c2a6e4a3f4d5d98ce4dcc1ecd39dce6f955db42e2847f8b89cdc6a576061b1e470ac03e5342008a8f8f743f051ba270956e9b80cdc0c32828de7b8b4dc8428d0b41fc9d997e4b6fa90a0471bdfd86d001d126c671d0b91f5588a68f0f06374211edca7ee070710b58a75b066fd049e5bbdce1d05188f9149873b24b3ee0a36755b2bdd9dfee6adb36f50d589c42900699968908cde09fb2c61a39c3924f7179d25edd2b9f85b4de9603dcd3ba207022ca744c2901a84f2c3937f663065c29ef6cb40400706a6b01422a00d95c936bce06746109a54cf39ed4c202065cb2ca1d8d1cbc5cf88c0240926970946e7d4e7d5ae07990ad2584b8b5759e01851150d38f89821df463c9ceb2a664bb405b6f3ad15435e419b41efc88e8010dfc78ce4e2e2069be08b02d7e4e54ca4aa9fa5e5404581618dcb22e50bb218cb76004564cc1556394640d18a137fd88fd891cba4ce10483f465d811e3760975dd6ec9404aba7eefadc47bd705c18683487c86e58fb41bb681fb1a2961592f0b03c7174ded76c728481038548bf145fcb0dfa677e2a2640df18ee1d3ac889e91e8317f0135eddf22e6e27e165993608c1d7871797e8b945863c3bd35d7894261670953dc8db045dbaaac0603d4faadecd693ccdf96a5c5c19bd3dcf2b5ed2661662ac9b984b6e5678e2e4460414d2d74c401ac9ac3f4206d893d6fa2d3ddde9b1a64055c0507dafe6b46682fbdb7c146731ca0200e97019851f6d5465a9b420bf08f1e2b914549516ebea62252403dd4bb69b9c5e9b1b669c135c6618942a2335dbc48caa0b596bda56cda1e0711729b511d390a59fdafe4e917c4051afd683f64ef4af0f92a20308e06d290d8fc4851b67cbfe032e5b0653647fe1a022f7f46108f748c198583e71813fa40fe1d696afd7533b90bb7d824ab1782f1f53b5d88c4c48ee4f0ed63547d92a603c3fd639ef006312a13bfd295fd7fda4000f7642cac53789cfbb2693c553e93eaaef1492ba28f57c7438d9ee151851f06c55c1485efdfa63fc224cab3cb74808e4a44efc22d30ccb7856a6e84f54d9f277ad03e9e201eda77c155bbbfce55a587992442c7c29d8d176b7cfdf90a0bcf292b17a5e68e33ee8fc9ed4f2fbfd9887ecf6b9d3aaae054f6223769428664848467817237465e8aceea3a7ab033e2b12f9d62a0c61f5baeae5905624fc6f4578b93fdd833197941bdf7f4abc0517d9dfe577d45d87513fe042974712ef6d0f990583977c8190921ae306896ee03e1de880999da07c4cd9d9a8baaed3591ff2cf52dd6d60c617a53590a6113d7c7814fc667fd7d89e6cb899964be213570b6055105217ee6cf093a2c70338a3d89d5d0715667e3b588b71da9145aa017bd9055ce67d3b6f6c69bfc037981ee93f498c4c2f062d1129b6830977d53100756bcaf8671aa1f044597b010c512657a348ad937057656782240ed65f6466b751e569a31a7edab892d246299fb8fb33d638a2f127a8e65447bbd10d85ae50d36d2b9d6752f6b77c407c246290228ecc2333f9aa52d73d2e6a7466a48a71b4c74464b747696921976aff5162a80e7de0a7a79af2b8170ecf4357ce7deff083b82dcaf7ab4d83122450141c7c04da492e1a34922b66339cdfc9f5408d6ff4fd0d05043fa112ef7f1c8266de752cf515e283db3c0749dd5d77ee71cfdbd7b0b9a97280643417b752f671831bf28daa1567015cf42442af4336b6b63b3ab27cd67ea25c436570df0944728a4c12bcb62cbedbe32adf7bf63ac2a761b9ffedd4c480cb5d0fe777a0716b47d3b36fe02c2d001988a47151395a15754c93a5001dd9a549ff05f2bbab1582598170d73ac1ce142c8b18db97fd7b1ec2b9dd88d2c8f1fa9ec1c3bb9e939e2108b094258b6abdda3742c9161fc12e1b01fc561b3ecda66a93117a5710b434d0ce5cf3ca906ea7d3b1e0028e9ae58cadf3aa49cf5c57480a8e8a7b4932d2925761646550b920b70db9700a018338eaa1a761307a7715228cae4c9fbe4fdc88a828ce9553fff4e29e37ad4b05911ba182c7040a28f278fe16db8418f2adc4e02b8183556698d0efac9cd495b03e0141ec0bacfcf27e5209bd0bbf3d5200d16ae94f72a7fbf057591981f911fb8fd7bde2b0de1fdc3407f0769c571cafa8f5dee7cee74c88a3adf5f918e7b238ff31bce642c7c05d1f934bdf5948fe5168eaeb4d65b2684442a9d93671efbc551df0abe4b6eee074a5694a3e2ab6245b200918706a77a0f9f78d98610d762069f35cbadda95a5cbb79aa830a76f93ea5f5c8298ce19038b4b4b4cd5715d8fa6df12439894b38e46f689149cac831ef7be0ddde5010b877259936b0019f4b03816af23f6c286790ae81ee2c7268cfecfcd09ec1f48620d42d41e4b3c8df62a593fdade3c7e775046edd620cf6c5dd3f19d403e7c6ff1e0d5906d9e7d9ec12d82e937118f100d3cc64356b98ba3708d2d8f69741b538b235b964e9586e01c70b3b6d4349d1eb7204aa376732cac12132ab0045c092bdcde6bba6133f8abc3bb4a6bfcfc96abb1ef88a0edb6b80a3fa76c69149b1b12c0c9ea4e10cef69ea9c577152505fb440c055bfb37433dcaa60310351df0b68f9ac6c83d8265a0d8c221fe12ff19566c65c4653790a0ef8b6eb53e7c8f26b8b41ff7b862d47f4ad0192f8b49e1d0a71b761e97b32e981cd992bfa561ed55302591ff222f41ba51ac0ba87b7e802fc6f2fb01dc621b386f0a07bab2133e1ff68091bf9aabaea75c25b2fe6f46f67112676235c73fb40ba189fbfbc0efeaa92dc78bd129aeb39e9ac36d071be157aa31b9a65cea23589a7306c3848581ba9bb7600e4c960381a8f666206914234479e2855ade82014656743179bd74b648db4a0b3e57573e68c64aa1200083a1ce2a6ae2b686fcacf71a31c6f5c640bd93727de08367ac23d5d08158ea8b8dd117b5609e95298255eb602f86300d78f01becf792422760791a6e1265abf4503cd537dca082fa18293141a11baf594029ce0e7d25098d978f49d8513e4de7d336fb4950c6c6b0707f60d7a2a9f0989d011c5358757ecb430c5903f780d03700fcca400c3f79494def1a432341de15259c68be700ff5b2d6ecf8d385e537e75067b39f13210bf988195ae5bea2296d372b81728605bace572a603e9dbb23e60c26bd06456fd271bdcb955afaf4278eafa21bfcf64979116dce201d77aa8ba925b46a4e520ebf3971da0034ea0e5dbc5d5efbf86c3c3fbbea445f4345bb3cda313eab970be84d0b2397660b66f1457d3b99f1e1ec074bb1686de2f616c01d1effbec30776f265ea412f1dbb0916af9a746e5a1c0d20346ef8afc4ef66d5c6853b6bfa7514153da43746bd0160e039e3594915316f5c07c31a151c9a99972161ac5d39f907fa45f6eb55bdcf8727ddd1ee49dd85e22afec07c40b7fc49cb0cab1d8ed343648402bea2741f189625e52dcb0a65d14e3e5086413e5c3bb00eeb143330f9671f8bac7164cc1e12aba0d4b74e064c416b5d31b8dd9ac0380c89960156f0156a48139f8981c266b2bff6ee1cc45b323cd3550a1d08664f24f6127f84b98b5ca1e93b70fdf695d6dd6d3638c72d60351a54df58a4d19a2b928d71a51623bc8f18eeb7056ad463cf6816ce990a692dd5ba377318141f25b3e4032bf06d615341cb18f2f626d9823f080a566ad78886fe6579b090e1a02cef857213646173a5b54dba5eedef52b8eed7703ec3935f27cf275bae76fb6f9d6b2adb45987b1f99ab349c391881cb0f00a92f7cca82cd02bdd91150fbc3e81f3f72a32878c8b6c1b7bb4236ddbed90635f6ede0a3cb92e4cfd215a94a8012d4af7812f5606428f9385f13ecc8510d9c052e57b7c30fc8f35b69bd676c31be4f1e4ead1faed3cffd9450b874a1c5952c3403a25ff666166a0f65106162341a663e59841f46dee0e00a92340f4f9db422fa2602e8f7b3a2fa9fe16f2cd1cba734ccb1ce3f8ceecf84ca654cead260109326435a207dc57cd38b0c64b5ea5418d205d73c646f75fffbff4d13ee051e39276af16a9feace38201bfdb7fa7aebe39d6b16f16f9634208571ef2648313e48b8c081f49a0029a333a3702d557638c00b862847be8c2a71daf2f6d98d47a8022c71b90efec91505bfeae36e84864e4d1b0aafb851cc89e69f573da400ea2080bcacefd7c09e0dcbffb42b5be4a2df35ac988b492dd28feddd61239146ce361254995d8391ac66495b4839ff58550f0b0fe930224d8ee4e83c34cca834730ad4dc8cd2af4324f08c6956ee4a8e81eac115df0bf8b905fe511787150e212e75dcf8181592c3b0868140ee59270a05c2e8e223fcba523a7a22da0758c580ed0668d0f01ed5cfdb658bb4729c11e03a22c1b3e985a6612b6588a96b552ba8477b9e8472d43c8ad0609b8569615043cfdca08435bdb83108360bca4177b83ef1db2676d31bcfde36437d798776e44cdd0bbb2f8a16fbc8a168517e6411b2113e2cf65fdc54bf6958e81a4bea9ccc7aa47c2acca0b8d4885c951cc8c244528dc06c51610684f2d789a2bf5fc14ac6419ad52e038531cf3e7a3e409a39aada0088f5901c5fb746cc33dde3adb3a133fca62e4d5fccd113d6ec8c819797519a862c00160406814907c1314a55a2dc50844da40c5c829b771a83bd6d01073f222469f2a3ea2d2881239649f6662333a5a137dfdfe6f64bcd85cd9be9bba8b31d8c83b0755960b6dd8035899b351cfd919be77e5e6c17280760a4aa584e279532190978738187a6c303170acbbab5c8a683d7cbf226394b05d7e91f331f8d849a7605597c082bb644578cdf98a0a996f1109946c4b3b8c00116a6b4bc89419e0356c582d72ab187ffc4bd51108d11f79990667d249d1c6f25a607ddf5b4b634ec7a696597bc357a3e0581d903116adc617e7d66a209b4c1604693a358a9022a52222c368e06dc5dbdafc445db568623642ff3a87899d97b013ec9f743475afbdec2f7141145504097358e1b632e89afc90a3bfdcbc2391d48ce6174596e8c2bbfb7e279a42ea66383886ed76234b8be56fef4f21bd81031aee909239cd5304e7bf8c7ddb5860a2e9f2115b394c1c488698ad36da336773fc1c822da32e68f39bea2bfc6064159d49cb5506912999cc19974292e52c4a3c19f45c1214b3c75701ce508fb0f171cdd0ba23e3a603ec5ee0fc440964ac605d0dfb076e2a465d9a20abdd6bfe47fa840bc069eac50de0f56d537a8ab4262844396582cb606a7aabc2d68516045c802614a72f69095dd5ac4c95430e6ed08a0a042d947194ddf8d1ccf1d57b4a0186d3a9e8084f4e92a77d06361e2f3de91ea358b11434580a32154578bcdab8f9451b646e3f79408fea8e111bc799b758bad534a4e6a0980531a27f111796da1f273c46db805086f2d13e758e6f29ebf875da775d6ed9bc1978c19c5b42f71f226dc1da31cc76034c813751527a44b2c3d0b1b12ae5ebda4a560beb266f7019da35508c8f39af937bc7e7b69e5d12e880c2c8c6ea0da127871f4206ce710faad87080d4b8bfdbf398fdb637ece6ead941080813d54286f8ef03d54a35610d4e8752fb105babf164e011c15881ca56841d366e17dab9338b813de3ac0c1073f25929597ad4ca73b6a769becf5c5a5d42a77d642fea16eef522604312c013e87532bbeb9aeef2ca917ca9e7c5b6ed21ed086ae8537bafe5d7d7f284aee971c80b16ef5443c36b069e1959adb85a59b388fbd6544103e24f99c277e627cb9a54e1a41e7e34207e9c77b48e3960e78baffa3d056c5acb34c46188e579835a783120a5de35f37be08d046bbb595ee9f19329704c7ef7d8519b6e75ea1a1ce23caa079a2e215eafa924507b7b10fb8106fb233251e6e20abe025deaf15966e41624593e1ed0e669da630068a2938d0938129e274499cd4ff637cbc417413dd952feb97dbd613d220aef598f7c23f597d432a8f3a5a9438b45b9e622a75005571f7630a4f72669c929ed41c24b09e432a78b42b2398d7bf2764a0cae6e7d455fedce731096f16e5df31dc0b9f528ba0ae0627eb05cbb196b24ab8cb7c214c488397ea78ac59b0bf484af30ffe5bc523b1a57e2ad4775fbfaf9afb5f1f3800a61dbe2adbb6682930ea074c4e29fbd99d6ff7a1e70bcc14f21d0d20a00a4a5726269862dd244c7bf12dc197b68bbac5c9bfeb9da1e2b430411d2698021ca3aae429e89fd1e98ba5c1749942974129509749107482b5238e3c54684f7651151a100ee414a47d446b4bb6fb7276b0e0c0f5f42f5341e578f188582d5d6916e689287b97db06eb73077340d200379cfad1196aa9950321476ab6c5e1181f503782777cd7b6572f40d37a775000916f0ae4038bbc40393ba14d33402831e20946f9ee1ae58c9a86dba528623ab6f54b39f7f1bdee8f8483bf83fce7c93851e99b6197d5530cdf980a041e856d773a1f3c81660f7765582a21db8203a1d7309db9959f787d1c07bf11d1acb87f86f3ff975a8a8d934a89f767be5f347e09ecd1cb10e57833af610fcf2fa3182630ae5651f8e2c405fc46e555a508bd50b6fdc3c35e4fd42150a4f372a3758bd5e626ac39d620e446df5af6fadb58916fbf9f5eb2e079892b75247ea0f317075d9a238e334d83a7184f963e2f02dac1f3727575017051aa0621dc2e90b5aa0e278634854c20c35b6b00a78c71fc3597e57603d16f6ef45b06024ace29eb34a06ad513bf4d7b37959be4fcd299e846094a3a9b50c35a5d286e9b4e51e95eada1be6a09224017fc694300edc3344daf47ec0e3e5dfc62377c27f41a18c394033efd86fea4b4ab6a4598e85487d8adf65dae926e9634f3bf544574c8da0eef3fd7c7dfebc6bf9f4f7ca73f1fae36cce0caa0a95b239ab8f3780876f0087adf36b2de89e44ef406f4952ba96c853294652a6147c086b34848d4d8b26787017575e50f34da7691e8861178dd0afbd445e542048d857d1837b71c65a557adfbf7f8ca03fb9d50cd7403ea2858939cbbe7ac537f30e9d3ee516479e448d33c7913e3569ee31dfd2cb587de7702907c62dfe87e1729ab71046f098899988b6ef8283ee8696e3386d7ceaf5299b2a6c1db4d65e3e73601fbf89eda6cba4bf2e66f0c182837d8860576fe950aaa93a38c9ada1be5a9da75919c5c17444ac45142a5f511b73f4481b5ae81d9ff8f6ae4daf26f081f20b63dd094da1fd7a18aa95f1791b58a78e920c00806971376dbdea2526d503d58ee2f1aa8f572d90aebb5280894e757ed9b87d386e1c18e56211c7d88fb3fa45c51aac5aa4fc5d7c3267baff9baa9c5ddd6f46e671d7a79e06815615e3898102c4abc3bc24bb25c979a02e228558a2f31fc0cc4dfa63d2b49c30b3f5e107102299a67a130b2d9047eceefb21da6fced258505c768a72dfd9adc739294ee954e393bec614e0d6ef9a439b54477457af124b6edaf6d13ef00fb43f81f8bb2e5cabd84cfb0daf3ebdb844940e17acfba3d31f3ebf672a5084c4983ff86bc5411692fee42821a18d9e88b9de3397defb324c08224373189e688f8d1ba786cffad79c09f993a18b73e2532a4a2e580f35d7bd20ab899ac03fffbc4b2ac64bbf8424c8cf292a0deb17e10dad009b42d979f175d3f9cacf5f123152699e40edd7fc0c40e0398eb29d5a7fc55a20a16cba49d748e29008c09b21d903d39a8640786f9233a7d6485f2724b931d035513e50cd07da16990417bb3ad5ee4532438b62438f0555313b61f6a13767c8a725e929f402d528681b02658c649a97874059d3ec37736a85b7fe7cbc4148f3b3ae5cf66524d7f0ff164febe8ba1a03df2018355da58c910ee001c32e1e67b8bba116b0aefdfe0072ddf1449834db9b3b89024c45746594ac037b56c76620656fcc4a27c94e3210b9a26252c2586f449b571f3872e9d24d3d21a1abe0124cf74846f3414fe5be01cfe141f098413f4b65d9ec64233f3f291fcc1834ea3c9adfece4df6f14b2695792d72131c4f3ac3edd307de7646b38707fd850a84daec96c141e55932d4d98b312bf9867be30c1a7e58c8e8a1b9d036d57539b101c6e8e1ce3770e960becb44c3362fe5ac0beda8c2f8a94931aa7c00337347fc15a8bb6774e942260abe21bfff46e28fd31daa30a0a4f6edbedbe811268783cc2ef0d1c6391a709b5c6b6f111cab38fa792bae00c0d869d37a739c5568346678078f8557e5713214e803b85857c90c9267fcf2fc1dad9919f5aa00c114502f0bfca43fe7d2cde4d54668461ca29b8c63b9fbc555be0cba58ce0d3cfc85e964c807b24d52502992a2e42b34d0be8240220daf085d2d1c1276b8bc6ec3b4906618159f3e4c1e69e90b67cb330444fc49709ad4fd0b93aca08777273ed208f3393a28e76a97959452acb3906386e4d81815fb155510c35ec6c5a799a4510b29a9eadb2856fad1e2f82fd00f465b517e5f3bb59925c16a67ca0ff9814cc99425ea597108396bf92baf050cba5630012a8aecd65774c1441d09bbf0ced8752c2aa672fec56dcc27d3ac6b38d5551ee6d3e7b783ef4e6da5eaea9e56a913ae98990a6932d51db8cfad1c0d901747a625fb92c2d5b17453266004a42a41e90015ccb82b12f23bb2bc31e60c7c069e84d2780e056c789daedb6f735ab1fb5796e6546059bcc62d01ff0729f41ab04a1c9da2f529d50e924c1c6c3788a2936f5d375476428ad11111771e9f1c090fe53f8e1cb5781f813d36eab029da1f15ce4587576606d7131845627cb429c6717db962099d9d5f0dd83cf97ae94e8826563896d1e329395f6803cb33b6c19de44e58bbe15438bdf242777b173e8bae336166009037ee2c1f6ebf478ae84e6d361f7a9bf6d963afcf47cde9fa6168eba45213a58337e5c1ba22997044830850f86d03b3d1ccf82aa50fb5b3e5b2f123b9c0aa833a70b5f0416236193c1eff1c0da03ed8fed087e87352f462cf910bf1926a8ca766aae97bf0a38c6821349b91aefef05a492c2e4010305d74e4aeee97b08492b0b3bfccad19c37b012e5781c3c4843696185343c4f39be10cd5aca64662a26d9b22a4018ce75dc16d28e7a87e7b3b81d2782839db49dc0ba2602ea00cfd931a2b02ee15924cd66a95550e2bdf4b2846b7c2645655b9e28c91073503f2493b817fc08a65941b02934fa2fadcd656187582b176a1024b40f4aeebfcce5d88824f8b1fe057dc3c506b61926a83e14eced6f116b3a801c1492acf510124b27602633c402ea64446fe7908348ddde2e02c2f4cd5b76a3cd182299783d8f074cdc7c85350e236094175be3e53e842404393d6075f418fcc20b5d370f63095b26a6b12ab903efee7441bee830b82797d4cba2a4f312ce204728c73c9388ed415e68858f4253738729c93b0dd9f52ddee3477cb625e0c7a4bde10fc034172636c704ea023cfc6c0c1c4cace149b6774dbd23cc918d94acc359bc6c2c64311547dfa7b76c70a8d87a489b2fa322a2052db4c08c574ce6247861982bc9f4e928b2dd8206cdb4bae1fda3e2016bd175e5d28ac3403d2eaf4e02cf98d22cb0ce23a12a7db85225e766a5921ee412eae2537a614288001a12bbf65d3a9d9295553845e51d8c7db55d62bcff4c3e90c62d95ac648578348f8659bbae24de83ad269151060227a8f80f3a2d0ec64c85a8802100a595254b4c80df6e31411e43bdd47a385faabf275232bad96a0444104f557ed348afe15e0022f84b17df726101a8013bf703af5763246ac76831b348a92146c0c54eb5289e1e7f326bd5d873ca37e04d82359254c51ca2b6689206376caaf891ac95dabf5d189613588e01d2816865b369ebf25b1f82e461ee283f7e3f43395de4a6ac94a34a207cfd09614090c517bf207070c2a08e479c3aba310462111a8ea738efc016583a09bffde16da6b4b7a180e334dbdf6e1cfd344d9cd45cb8e8fcbc080eb05c8c8fc542f0a463af7878bd842751968a0c964c50bb7e7f077a022b93dae662946c0a8b6c5006715e6ab006a61cb84e5893eb42665eb1abc326cdd3ff79153c8342ba61b392de3d0d23e07dcc9b04f74342a931c794c204fcad1462d7c5797daff56f5f6bef3f6a1cf63b3ab9a5badab75e6549a06c7ed5cebcdd28dcf8ad14d884ca9f8029bd81957adf3ede01a01100d51d6bb03630616f0cefea2d1a0c2bbb54fa6dbb6af2f5ef0b95d139b8fc4ae1904e4bed81c49d427a5a94dc5d12d9b0a1e684c0eeac4c6d2df9a5c508ffecc026975ae3e9a2d4afd156ef0678dc0939d79dbf4f6b9b855dadba7a06f8a3381fb2ee1849d7e7190a960bdd9cafc615a9d916e3a776d6755a0b711c42f9f2740e5bf5fe59eed6cb18428922a16017926e51bbf7fce365763f8adcb91b77854be37b125994e129acd5ef31566d37084eba84bc78862940480349fc130f7d12f1e2dd31240a6c82b4da18073a2ed623608bd30fac02e81e5f06e9cd178bf39acb97e3ea92b0b4060aea6bdad864a2380b31cf25912b6d872f78f6ae6a0e5acb4973e08a79d60be2af351146cb12cf25e4f46b9c9b3bb701c7d793df2c7392451d52ac4d73b2cb37db2870ece765ea546602c32debbdd7b5bceac754c149440dc145fb9e92d5431edb950ce541e44e93083a94431bb780eafa23be23f84eeea5b0eab52d3fac90afa47b020628bd35690829c66289863507e4ed6174dd7be6c2c093da49ee407b7863ac2837a9ef1402c989ad4f86b3dd38fb89a8fbbe18d6d8615b69cd93377bf5f7350412b3e463d92106bc167d17cc76e5ac8957a27ea38fa9fe4b10f3cd6a3b254a5a3fec359f4c278f967c00a4df2905511402c97e32f0cf8ee52be9133903183940697f6ec71699bbd5ce5253a5952ec233f731d2b2a2f8a1fab9d0354bde6b395cbd710885e1efec22f0d81a6c2b05bf3d34f65be7b550772b5e6f67055b44cb46e01591e9c8c7c70bc3bbd9ab31697c5bfb111c798169089f58251dfcca48855a0ca5446266c5191e1f210f5662c404e3987d4a3b06802c92278a5c284364f72c37bfdb3b219ea6d47a277cf3d61551524657b10c0a6c132ce4c66c27f652a9e5e62aef66436ea4f432c7bb781e1846033ecb69613ca062413ebc208b4881b205c34d45d842dd31e783d67c5532945111cea0f0632a07afe3eb432100eeb1845addfc20435b70631de5f4f53da0f6348a0b7983ff0cf380ae14e824cd304b6c8611f4ac55b9b6fabbe70508ccd2ae7f6a4887fc0755478dd47222150d7d6397bfa9d08c88dc44329a823601621d613c313baa2462c13971f9584fbc5abff4dc20567662ff62e956c7eb2fbba6a97ac2693d0b80491da6d20f0aa67e1dc488ffea8bd642db91bc79c48827c5e598decd16d91bd55eeb05485479d51ef9400ff3381e118962525616892df88dab339c332f3b4e19869934d7fcb5f56219452a69a629dda32f4901c4c2ad6e497b22ea9fef14689baf46fe1aa2d172449fb7ee2beb7d9a1f5d3f72c323fa7ebd07386865aa6f45cc1a8b211040c8acfcb6c772e4a03aa1ec1f20e1007bc868b7ecf69e72390aec0e2b31d53ac549369ad03da9ad6a08c69a24191d69ae6e871aeca1102dcd5ae53244f9aad005953ea174522a2976f3e286cf92b1f3552284df94c1114757f80df5bc2020650e48766fb305996226877a5baaecfbac62da1941a5a50d2f0c48cfaf988de1c85f66d7886a20a9c63d3e7d93d2eb6e6f1245f345436599d6c130ae2dba0f29140af1855d41ba7d30f5525603e0641e491742d97a4820fe2aa5fec327245285830556a6bcb303b75fcbe949b58345e0874d348aed8780699b3a85a8ff1b75f3f1f31","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
