<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0818f728eb94fa3469c84c6c3cf6a6c5871b4dced0af0e4b6eccdc6119a864af6243bf5b2aadc61a42e7ce0baef1a642620e83bc8626125a1ae81316b2a43b5e4a822395ff28d3da40e26321ea811bf2bba00d0befb0c8c76a3011458c7c99c71cd81616053d66edb681d308df54c5fbe504e726f806459d1b64f00e5403df5cee89abf09a9d829a0df9f07eb40a052ae5d7cb23e905244f0b2b656d28b952a9bbd275824a5d63ad15f8ddac9115d0b4118b69c1cb3ff1d8e4ffe87fe2b8a546903d3675159208d6dad88ece5fc8a697283b6805a22d1906d196a33e2003879194c093ffc1b9d8c5cdc3101f29ffa91fd90c4ecbd5250aee445590c783ba4cb7650a60dd26b36ada8071705d08480f54a1cc4feba60d5abe2d3065a658185d50db90bb6a7991dc6bac0fbc7d8b57bbc2be8438fadf82c739ab70cd07372fcb128e10ef56f5d23a3a3b4bb42d77f3ad53656a9f94ac5d60fda140327076a8e857c758c9d6634ba997f16259bd20b601641e5a4d902d04d31a8f0428c048eda8270f08291543ca5adc4a71dd7b5cf3a9670c6b758b8afc7bcd8dee476cdc7a62ac1c677836c58b1322decca121f166c87e7ae6476af846d2462af4fc6b104662a4de5b99635c2e5d3703d0cf6458a40def3f1acf103a0977a84c1d4af979baa1ffa9d1dc572b5af8902f0b1d9aec73a609d33b1bbde9e0e6943fc1e1c0be07c429c5205ab7a8b0c33fac7e139dd986780bf79a9cf5645cfcbf8391e972ad472d0c63c4bc6e7ca8aadb6fa6321d5b83fea883424c26dd2e170621e1a6952f454090575e791e5943830bd22339bccf8eb870417f422614e13d90486e8b8a83a2677b5f9a0f49d1fa7bd6a736d9967dca2df9f61c895686758621b9c8b1f4176d213ad7d6fee2e00ad9157429ef217cbd53680d9f896dec4aaf6b93cb56f3bb4da03430f3f5df69233652eb79e105c2b0193af13218dc0bd37e7cf6d0e8ef1d41d5c717a8dbcdb39d35f33385ed75f010f9b019f77a893f7af832cb206ed30d0f49d85c20616838bb48548e821092c08e9993b478633fc554163fd9d5e14a8d94f438f4250bb108a7b6f8e9898d54fa68be025720f4aba8319dd7b779e85138518e179adb8a70febdda1490e4444fbf68af1fb567a4deb3da3b33eaa2d61de847fcc97e39e284bf494638f314ab04fdda296a6208e6f600bc51d07d20480868444fe29d24c9cf9c5b2bc614acb417b5f4e07bf3cfe7ef4aac6bf1225ae6bceaabbcfc42382b05d1d6e5a050157f667682b7e30aaac9854ecaa51be2014a00dd459877f9fd45dc53270991e5328b6ae9a93979234dda3d54077b9d44fd8f84056ca529a284d482f78f93d7fc54e7dc24c644398e7c6f786e3b786a32f3f0839a33ceae258d0bc7dc9ba35b2213282d8c45e7c371970ddab7276893146335bceb332d2e1cfa74231a17e08a76731129b246a27b2d2c7a6398b76b703637a553507c001f05cf647f332e3684abf05a22a412a64998c3263648ba4653a1eba316aa4334ce37d357d668068df9d660585f559d4fa861a5074dae9c03eef31bae22296111fc0ab9d9d248e621fbf8eba01a1be54a268047dbbe3f3a616f04bd9173adc18bc0fd9de02f945b257da6a29f8bb735bde93264952535c07094357115126631fa8bb7ab8ed45495ee82cd625786a8399a92ac9b124635ddd8d9322c6668c24d9ba5e1866584227b0763ece47a6818c7ee2b45c1733612cfc268945f3a192c06648c2d9c01d7254c9c9ed629a447dbfccfdbb6bf67c9b3d741b0c2098e14e512a6bd38898c469f22d1feb9da3c31dc95b7ae4e8b04bda74647b620ba9447717cf2878a886d6e681ec4f4da3e5fed8c6dd12393d2de69edf706c3f1c5de34509aad4e0dbf78a2e69c3d1f42776be651a0499077f18b86fbbccf4588934e3827a63275598a97b5a34240843b728109c572bc465c50124fc822c5a9f4307235dcfdd375ec3f65e710074d07566dbeda383082ec53ea595e2cc1a9754889abd43c27c3b8202f18fe0bfcdb065134485ae09c609172dbd770a8233c93600533572c9db08b660e20c5f28dc038942fa913757ddc665a953a57bbd519f36b21df13a8eb3525bfb463c8c2ebcc7bcb1940aa075bab57cabc04d16edbdb8cd346bdbe3d9cde3b585358730302ae83aa13ccb211387496a419e99fe43c98f3ed579e1b3c3c908ea72afd05b09c8050c8bdc01c52205b3fcaf5d4e6b4137a8ab8fb874b66d2676a3d91fd6f1c9c5d45b4b59c42b89d4df53fb2fa9a1d5c355b579ab158776821821f63f2f11bbd512bbaabbd6ecb1bed22eb4e9dc1e4c3a14a484c27dfeab02dd2c5e1fbc24ec709249a57c85a0d74b769ed58bfdb769e6ea2815e2cf87f0c45c87468fdbca9f00b09383a6452402aa0e9fa32e89f5a7bbd99d29e182a6ddbef8dcef7e396538fcf00a0bbbeba5a2ec52a03ad622b1b2341bc8427f95771e4482f06b815be40b995259fcf78b1f0e07e9cadaabd1fcd461d1147f1fc943b7a6c7acb0afed261b1f1f2fd26e40487161e1043f72908478d1eb28cb01f12fd456b5ce5cd5604971b42edd8634cb3a551773a10a87cc684409ecb4cbdfda0cb4762f541a11202e1459289ad5e34f2b511682cc091d49f148eee4b83651e3038b9ee56e50a444dad6814e720f7bd692d3cfa169392e4b06c56c079cf95b52af03c1fd22cc295dc24203ac10071be19817ff61d21b3fe2d04d5e2cf200baf68e06835168f5da28b658c3a9c04dae8b39f377077d65c41170e11e044967f3d7be433733e0f46ab28a3b0383d6b71d26a8ebd102f8bc156dec03c2699d5f20141a6250c4381f9414d14d96ff75715c9ce94d71e85fbd88af1b84a34827ec709428d77a00ee5485474e556bdcaea903c9193fd52e2c08f9d6a91838f27ae22ee83147f5cba2210ec1a488f4826c38d7fa978e4ba6c9abe27ef8b29f4b25fc94fbd9277b82126179327fecc0cab715dfd334c448996cd125fdff923ebb9756a3737b6e24af87edd80855603f216253088a061a594b195c8e1f648731265581d797f0fbbe221565cf6fc2d2a750a78089d324ccdb64423992aa46117cb565fe673ae24fd74b24a1facb3db444062415b503a9250dbb3a730f1530e373df2af21eb5e169fc02246f2f4349627f89c29c6e6439ebe83b766065774ac59b159d62999af323e396eb23a3d3dbce62fb00529a775a6f94f90d4f4e95cf0fc32206a8749802e5c43f58475c493c7a82d8e69e1323fbabe358f01d9d560e0a2f303ae8c3738f4374b37968f3301cc1be88b1c5d7430dc484cf8abbc38784150bb07b25ad302d10b2614e21b26eb81591a76532f5e561cd26028e719187c07217c0a2070d0be4af77c7a95e126a3971def5954090a36e5fc5b32fb37d21ea6b59e21e4a3e367ef4ec87db0c6931982e679d4c96d6e2ee30bf56fe20d6d0b13088c2a8f82a030957934c8059db8b895d1e0de42c4d49b6e546f3d4b54cb67d36b715155d76edfd3919d014c802e444a4f107ee96dc9ea3475ae2e7dad4e912fe1e08905b5604cf1fb6c66a61411758389fb0b9a345f5e1e8371a6317dc803a1e941a9987a6b7dba4bd660ccaa9dc527623c3545e457730e0e5ec76a042306d0ee52e5fa22a0813bd3cf8eaa77224e5e00e28855b617d14f69048c3e46cccc04d7618567b47921e777df935736361e034e875b2490c7df9502fbae29f0f98c5793af4334cdc408eecfd964a7caab09903f5b11f4cd19ad0eb326af2365dd234ca0253aa7dfd480076c7ca53f86f2a16b471250b87d3eb36b6de052ee8be23e41fd8170434adb98964d90b4006dd98cee1ebab303ff677c8a3b9e2157dc2948a4f6575106d4a71274e0ade9105fd53adaee3519262315546a4c36b6e08824ffc10fa1980ebfc748d5858bbb9eaa271d056f39bbe9eb221de2bd6e570180f38c3b054babf967f1d16482477730dbd69fac77fbbb4da346f0ea42f1a4d76819eae36bb2e20de7955a260b695028ce0bc6276082808d9000e1e7c844d5707dd97f729b13e4fe6fe577bf76da0f1ca686da0461d46e4ecd393793fda0d74d1767a3328a36c96306cac0a6e1f31f6e3ae952849dbabd0c3157c8e997df3415650ad0e449ef2696b7ca08f3e6da631e7ec2da4efd8e0ed18ac7281cd98baa3e7c2e83c0124f31d496fc0d601c01f372e92242f0116b105a51f0286108c910076e2ceee68120a9002e4895ef1c44d42805e478a911905c8424633523813d303a1bc74833d5b5292159ec6daa5205af51960329bfdd6d295669d775f5e802e44b5caaeedcc36c27df47e75c5756609fa99216c00739e667f71ab036d8c7c48ec60d35f086a77809e4c3b6bd6c8028000932a1a03760660d537c184a2b7461dc6d677fb9d0684a4cc491ce5cabfebdb623004a60e97e4581f22e4c1a603b5e461509c49df34d035dacebe0978a0218eab15e86712717382b397fb385b30249eeaae6aec408c211454793d7563c9fdd0dc1ba4c4efef6619b20192acb6f95149734a5637cdaf65440aa82c2a1fc3984fe6ee95cd1213d4ad3ae1e0ac0f6878190cc26fc31964cd22dd91f8b6317e597cad6fe9dab4aee1f9597349c0e79ab54cb2b7268e7797cad0f953499d39f1ecd4d3352b96b1d3e885dd3f73570af1d73ccc7dda23eb7c90677be432084735d3dfc5736866bcc783342327c2fb5786773e44344e886c94ba0fc18b4acb10ce37f3426788451ea8948f1bc5f979d01951f9bd92d15ec3257848eb1c2dc85ebcdc237eed2fb0192a2e414e0f682530e3430b1e833eb68057191e4a6e9d66e05b9edaf521c4fec2526de7b97771afefef7420a80afbdba3790e412844467f14688eedd771af26b8038e2291651ead807594ed55b315997603f84e1a4eeb66af146e8ec93ef9b9648fa42dc7eab1159f2195927a6e1cc27419b59509ca53a73d875850267b522e4e2fb44e37289667ef98f8e9ff39fcba4b645918d70202a12cff91bb2174cb67ad1effa97e5635ece0027c9976bf347cf68c2cc06db190d2828edf313348d2c6b76455bc45095baa895f39e2d4fc341c718844c444108992b030cc755fb1ad8010496b5e719c5a25c5f46a830f85175687e115e696853f190d22767b810e63b19a5a777fa3ae9c79c2c970327406a03b31e6562439671965264bda585206007c908ef987538b29f34500ba9f8194f187e5453d8cabfb0256cdc223a8ab0a61b52c6c18846827b903f89c60a31de38687f17c5cb510b4bff72c4c18edb7cd681a717efb377a5f20cefd560b7db59ddf08b6affea48e098f2373ebb7b4ab0edcd3cfb7b0b652617dd39dc887dbe298c1f0025962ea2bd6ab614df4f3a16c19e2a15c423a53451c09f00e9d47b74a26df609ba5a4d2a9f9affd0e5bea4fa6baa116d7726393fe707f4f19d3d693b15c975548b0fdec1fe2f8f7190539f180e94465e92e0412c8157f214d727c2ef42a0b31918a4ccc01e539b182fa12df30dc3aefcbe5a41ed11689ae829910f75ab55280a38d18344c8688e61bafd5aca77d980b25b3f1127fbe44f7d717c94aaee15f63a64c3ec8de2c64f01d901ed0442324ced6668b3c8eb7cd0f7c672d72e604dc76449fbdc337965687e4fe6d170514b349f4063bb75ae039adf818ccb8ccf9f7f915c6a5d88adeec67b6122e68eb99658b62177cb2251fa388cfc3a8ad70d03fe43aafa243f0153ccc80f85e2f9f2dea593445f8e1f9c0568a9edeabc801b73c872f85bc5c5aa00ab03b896c76a2618ab915790829fc2e8220103aa3962069ec7a7945cac4794bf1fff3b3d40cc48206734dfc282081def06f4b671147df92c7d20bd5c1642da9dd7d8195589cd45577b00435772c178713795865b715bda535d3d4fc1b22cfdf4a3b4223d60bc517df85341b4a8d689401f58f5343e0d6a9b68fb0be666ff6e343109b9f4865ae2d6a3a03849cd08453d9d92fc6ceff5d4d4095f797046d3f1492cd5551bc616bd9e6c9794bc92ff0eec9ff3ebbd5f4b954d536dd8ffc4f237595781291667c18ea791d4b306a8c8e2492dafc2ea3dc246129201618eefa1d958acfbdccbbd8b276c69d69b3e5ea20ebf60124390c13529b7a56dd9f7fe5a5c5dc9e2ae5ae244b02e5d17379868ebff3fea3b4eb94fdfb2046c3fe44566e4f967eb7b374d9c13e70da4404b5b2631edb8977315ff4a0789c7327a02350789834c3dd9fad2258b54565a9dbbe397dae6f4f0b5e0c99684a7a3dc75cc9837519992cbc7431d8225d40e40b767a542b77da0ad150a46b50a655c9bbfbbea55f42bc8b4dfe3047e891eece1a661d40df6604b3ac0714d284900b7c4071b7b8bfafa982d4d60c1641dd1b43619cc5498b3b808320cb8f4723f8759c04026c723a89cad645859e8c7381628f5aab1cf8fc8c7fe7731ebc4960675340205a6e107f467ac90e1a4d14079aec6a6b9e6f6ca8476d70bdba2bace0353832ef35553a542f8c4173ea81d55e0b959f5b3015e6b533aa151e1118db13bfe79c5e5b48b3c95aaa5e7f311d38ca40cd60d8df680e9c9cbd96e22a07098411047df6bae7a15614f613122d60100f0e9a9d45b3a61c8e8b8d99859efa0a47155a70eb164711c1c91682ec34ed992b7f1c850565456343494b802b938d9e60747d58711042d072cad03a7993abe938f02568517bfe37ddb7b9e4eb986e16ea4042cdb02f16f82496610ac8bd7e133eb816a5a3e0a048d8173e1fdcdbbe5b0d08eaeff0d1b858685f766c8dfe7bf86d296ce645de3f642ea2105ee0f3ba125fd7f23e78ab7b7dd963b9969050dbfb22a293d2629d97d0b5ae6347b2499c0f89b45203c7a3beee0ab46e47de9c9a48f239283ecb3b231c48187d15613710e14405c4353bfb83f47bde776c753bc37aa8c65e2b65e32affbd022d1be3d8869cdee38756ae48a2b096bb9c6bb9b74c1bc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
