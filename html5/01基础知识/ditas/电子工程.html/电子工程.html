<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cefcbe9b5b9bdb619243b643dec75671b1dfa05c2ccf74ecbbf30afdb673ccadf4e1e4ad95c74e65974954b1e467e49892b4387d3c18982ba642483eb2ce8a98d92a8129c6e37f91991d2762b65258da0915ec99b1e6910235e5ff4b5c2edfd83bac353a271e0e037efa71a347180e31532dfd71976a7abed35b1ddc70b6afda41fcf3b03d31eda084ba2250af45abef24ff6e0b1a3a72a8319ae5099049689123eda3d957ac64c12a9366861599e043ea3c5fad1890e70a3ff9380023cc24be670d53743f719e119120198575ffd1d5fe6ead9dbc139065a959f40fa021e9391c72b086bd2ba38938aee47a34df5d27e22a7163ce43bec2d51042113856a2e8503feade3b5bcaa18710ab33dfd5b68a7ae2b765324e648c168644cbbed4e1c002d89826875c094e274688a2a5c2cbb5a21f2e1b3d4facd1ca1d50191c68850226f0c730ff7945fdb1cf44a5d5534332587d8db8cbbd2c8269ce4ebd88521104cd7038f2eb9b5cd744ba5423ab95f4d2b5f4b0e231ec59f047a296e7a8ddfb21d732191e37f93a5eec57b8a453a3dd613b2d08f92b050ccff437bb2d912b787cf7b009b0110bb48580aec11a0ef3fc98344859c738d933a70e71c147749d547543fcd7582637c685d9684f179b7f9f31be75f0adf91a62e4a7a20408b36a9ac6edfb94ed85b7a882c463dbc7668cb7734cce52e1a07bcc07b56c6d7c2733c8a666fd5166e616a6dfc07ab4b941b59fe38610653f9398361377adec4f8fa98c2a5e8f813c33273b5d2c3e1fff983ee303fd8b4cec7e0f5d5b3684ab753a5cd671bfa59d7908bc353d2e207ac91c1a7d1242e95d87743e2c0420f8b6dc7827abc7655cf1c4ceb14a11c45cd0b1853c8fc38a063906742bb0caaec0e3c3c207f68ba072e1a300724f595ed16a5624e18fbd5e923df200c42b6423f26db1019b6aa5809234cb07d23717d3abce94f7b5ed32cfb93470c71a4b30b1695a8b36edcc90d2ac239691944c6bd35fb5806499b2a9da1fcbe79b537837ce79be13a3366b02bb20b06a5fe5d553c5f9420dc2d9e0b3921414e6714860715d2386ebd897f5aa05c8307bd9564da8fbe99a983d5396c6bb8ea497e17b6e8bec6ece50332e5773d98a602e63e4f06f5009643f42ee233b1c7064d068736d8a9e558f9e141683057a531bebe89e16e886f9544b6b06c14e007b573745b45950c81f6a4cd1d67ab98a26402387c6b49d66be59fd4ef9ca8b18da0f4f93d965c64eb2228f4035755012e11525bfe4f1c8072ca1cc3d1d0789dd94351a3dea648262c8131dd5af623ef9b8640c32d47e12a502d6e0fefdbf001ff0fd6199216e97387c089e9107e04a61f9115b0325587204e43733c6c451aa8fb80586e4969bf86a021e80d8c47e7436e0d2b2fd0d6e94f1238d3590768269d66da19af677b684927b2a62a90c1f84b9a0ef3af8d2ccd88e74e8e2f62ba191e1d6c239cd46f2abaf0f4c2955fd9bd4e0f78a0a10318cdca15fa515e9979f44be955483d950126a0716ee0b3955dad8add3ff559dc2defaa02dc56e82bcdc92f4376e74f8be0c150458e7da8892684e9129a5fab4f091961261ade0e4b0a6bc2d0d8092edbb061a91de8e2f9c2de8de6aadfc7582f2421a151b4aef9a2e1c9c0a9e3303d24f920c83e01bd752f5e7f67bbb24a5ef46bf7172e3af735514550555888b04de46969fc602890e812fbed9b91d23090130d0b4c093c85277f66987781963e879eb05c3c74be4e88fb17dee0edf2dbafc1adc59c71eccc4461e71f1da79885ae137abf4d5bafed22a644b5fffcc41b497e1686a0864c0d6ce6cd5dcf961a0ef511cbec255ebd0278aca03de77f579ac1a3805d4f1bb47c5a5b9dde70e59531d956e9505ad5ec21e61005f7c2b0811fa943455bedd3211aaf328ce0f548b2aa74f32c4bb572723b69e04b787087b8e4643c4d97881c22d97b93d93263992c616aade17cc0cb372375a553fa29e3f287085c907523511de7dcb47af3ae0b48c2c39fe7b81e6ba6e5fa1094e7526f0cd59732563c4b5e62a6981221fb84724fb4186e063131406a10e8849dc6f2bad91b110ab519df5d1a3d494fe65f1ad06a2c8ad84f3cd9b03278e97ee5d6d14ca54a68d8928937ee5a6c380b89f8389db0d7a8474a255a07a7d74f766c2584002ab91533edb53bdc036d733e08508fe606e77c7456466bd0f9243369584fb706d0a826f06a913a63fbfcd096a3bd3b0deca92dc13c08bf6e20c38537d98e3084a5a5f12965a365ed3947732c746a28556bbe623c30c4beac364036055862801156c56c729499216546a4fbba23a42bdfaca22535a154259c6f7607fe0a5c35d8adfe49d4cc77f9a5d03b1697ff2b1b93694f1796ce35cf37e661d50f838db54bf5509a3f7b174afd5dcfdfdbc54d843236af00783cd00d753f1ad8534dc1510714ae4d745ac0a5574779cb18f88917eb08a6aa1f767cbc5ba2aa0cc616a589085256e13a47ac6b2b6d7e2fd38597485f33347bca28266101642a8a5af7bda10838dbbeb5354dac38d8a4dc2d496b4c86719ee2a28176ecf1768189f9e721fef15b81805f7f540e3ede4898cbb641f887615b30b02af8f83fc3f26efc0e5a18b6345315fa1f9d6c84342416b44fb3ce37ca6df22f64f1b48d4d55956f30d11de7ebd41b3f0589eb175b13ec698faf147455bf5215d1422c88b35fd3109d4199c68c4a4604bf0d8ae8eb8f5dae56365e949e706c947340fcdfed1c536644a1adea144b23fa05bb88d07492ec7f590724df876f88cc328cc26158b06dc138acd2614eae21063e09de43780142a845f39239add5cec6f8791a71958d2ac3816cc8cbed1b43577d7bc341c6172091bd3bb3fa862e15ebe0f0b00f73931105f161a49feb8fcf62fec56c27c8708c9dfd46bd5505d3e2db5fd3ae0d6dcc2ec2cd20d77b85dbbe315e6fd8664f70249e19680b6a59582b86e9d8e318437be35918153cef150e82033f8d201e5040671cc5c0142b41d3439e7e3252702f141f15991a248ef587e4962264370840d06efc3b5c912b40efb9c60631dd76394f577705596f393d67ff1fa9df636ef0cd7db46b62e13fe087caeaf34da449824e377b5070d7883cd72ca3705ec859be8f5cdfa404e7f54808b46fd28fc9d15562e45db4709bf181a68df8a63a5457054aa5e5fb87da73561e700ef34d35ab05c38c7fa61f933f76fd577731930ddd4c54676ed1ab471c026b07488729c872e849892d8a8332b1e7567db60b94ca019ce47e7ef1e866f99d8b42ee18fd30376f83438b8cf8db73d953e278a2a3f3274c3b5c8fcfb5db1becd48b56cf8562cb899214f708882caedb3ec22abf16f8e62ccf612eebc510e0a42bd6af681027177d8b1e4b83662b729b0ea40d7607e56eeabed89abd34420c1ceb0aa879d8afb2905a9da1de826be603c29762b0efe5a9fdf0cfec16d47ea5d0b2bca8fb43fd0f7fccf7e31fa94e1e5fa7097b1778d6375bba816abd8b88aa0a7ec2d4ad9aebf7e6b462ec481aaa6df4ac6f76558ed1214b80300d9ab90d94ad3128f58beef9ff817d921579c8a02dd2fc04280422f47da5019d9e42077c566ce2cd9ec257055371b5dd303182eff540c1f07d7a3bce05402aa129012937ce57a31bfda157538af7c07b470f89477e6a1bae9568ae1dfdb7d4ae32db219d26d5ac059741537f7b34b4fd71451090c15236de244c28dce1c4b71325448506b6214fbbf0114eeac7bb9808b7c83479892ba767b9c059d27c5a8b93574926734075beb85de0675c958e485d97b080dc447050f93cf8c42506a7dc4bf3da7e983d2d2a8814b8b516400a66af8feb774d4599fa0cb72d1343b70c10964b2c340e9aed9083f196141a42989501efc6f6498a56f50d105e3fd60b1d1501067faaa5204539962f3d4209016b7a3e29f3a84fc6d7346e5b3afb52d1a22d9009c910c8595572828010311e8e1b2b1693ec16380c4a47cb2d410e419187df51bab5e7f4e9a9203649246a72d74a3b1445ac9cd0ac1aa111aa58d135621f1bb34413ba08428497ed4c61b9c6ec86b56ac5e731feed13b82c0975a08b10914c8eec6026d6e7bbec96be2e436229af159ec5117fea74beb73a9252674d377a265b517541415f43eb62c6938e79dd32a41b4e017f21311a5651b6278af1bc978723aca1db400c2f960a8e4db6ed3aeacbda76d9ae81496b6e70c846678c4062f774fc4831ccc0cdfc1598fd2a5f8076e89d668a8a6fa43726d69143de5baba6737af005c2ca0438a8cce6466a3a968500f7f14e5675f624a733bd9c9513df6c4d070c216a8883ea82c4edea219ff7af09fe5d29c615cd75d9bb0dd213b3e12622c3ded6cc85a733c48c2cfbff5d5cefb54f38588300ef704988ef08dabecc296fa108394f10695f1201d20dcbfce3e79cc79ce52442bfe385e20be9a61643564ec0b5b1fcee100c54117811babc46aa737d6581c0aa0824d58fef3f57897befe788c2060063ff904de36dbf750f462737ac2cff35ec7af306b98e9c5f1e5d65f4ed98bd093791be18877dcb9f6c27b249c901055671dfef0704a5808f55c350bd8b7b3d45633017436015ce47e79958e1fbe03d0dbcc9bf4dbd8a167e6ecda4cf20ba7c50936c2be8c92fdf391737579b13036a240b931ccf0270d4081bbec1e68dfcff961bbc80755a26f0231128fdb67f25259a607eaeb98d1c03a59bcc4358725713f474647afe357c3eddd6105a783400ae3b4bab0a6e8216ec3d8ce9bfdd0a2a94fa15b220c816180dfd3ff4b0703efb0ae56ed0e86bc57e0d918c56af24f8c0eb464960f67475c25b433b5e244832cca867e55c4bf5d432030b4633a6ce28bbabe31fd8bf38c988613eaeafc07558968612d69d93d5f1812084ac3d4525a535460a67653ad639e7bd7e25191999384afb35aa7fa5873a63353f2823dd583398d65a6ad03c541e61cdc3e6e6e19346dfe227441185e797436d10a3aa82e5dc9c675d81cafffaaaac18e8877a4eeab43923c48a4c6464d9ebae1e3eec9fd355152e5517b4c15f869f61158644c55b06137b81d52fcb27727a8aa50314dcf1f730559e727e37760d90c3b022eaa08e82d97416e732c8e0988736cf1a282bf2af2593a2d1ca70938c1106b9dfa0850e93595cf24eb81a1b667584bc99925c84b6b0dc84b3ea5f674ef62cc715afe0946fdc18a7321ac054cadea3eebc3e7699123dbd35d91fd5b6488299e93d8254bdce34c11dae8c1827c041d69504c71d37e5a5176683d753a4dea40de2ecc5c30ebbf5fc45731d21779c264b698ba4d42125ed615170d52d6a658224c4101562d731e0dc6bacc180312112814dc095166bc0f8f5db874bdb5ce4fc43f6d4dac8eb5b61902fc84f40122c03474dbc15dbdb7d8ac9d618f8a597f285f2778880304e79b7cdf2beb57f02904b48dee581d799cde897070c7d557365ce2c93a6bfa1bfac77c40690748ade300d6ecac0054d16e0b715fe52118a2baf7348d088ba8c9652faf663a39d5a2675a12cff8e1bfb4b929e0bad298da04c7a96d52c053af7fa4d3b9fdd15f46505af8a151fa16400b172c0d4e911dfc87b2f46fbe22950c8719ac34c5f2e0742dc64531177c02dcd2a936bcc508216041667723b03a2a8a016c9532a66fbc466be1442a890dc1bffa1755602e49379c3b44237d8f06027bb08e474031bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
