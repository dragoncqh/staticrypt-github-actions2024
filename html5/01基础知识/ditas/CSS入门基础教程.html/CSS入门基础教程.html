<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2726e6a916b3bcd53751b5b5e2638d1d68215ba3089ee47402f45bc6cd9f2b1c265af4e603eb2a8d4563c380a791adca05829c7dfcdb9291181ea40637768eb905adcdc2951129af0cecaa25b8decc6e4a035adc3a3c0e0f22509627b16ab550c43c87041eb6665bead0dc50e0130ee8e941b2d9269c1ad05f99b11e0b5d7a949c4dba1ac84f73eaac548229b8f7d09bd86c2c759d1804afef1e1048f8d02872779a1561155b33ffe5a53e606816ea68dcb185230eaecc7d83f2905ac07b890532c633d1fd387f58a0145608d4be4b034b742cd45ddc3d0089e97c9e3c5bda993186858cfcf6ebc35b92777de5906440bcab728e30de88162665ddd1b7cb0029fa5872a0f8b2b5fbe84ce70df7f8a07e5aa105458fb6669d5cd857ea82c7005dace585a2803b98b3977106d02f669c811b504228f1e7b72694c3f0152a6b445bad5d32c859ec02e7ca9ed8b8c9ca9f08cedcf836c9a058dfe9b20b95344a386cde98b56d10ec2595d9ef8aa0fb99cc77a0772390ee547c2885b0ea5012dbaa6bd73686ebe963340eacf9c33b07ee2bd312f42c72990363d2747dfcecbd000ab2f554e06ee0b1de0b44b324e3e3086c376c91520cc1973ef27a2241a347cf4a246daae1cef8464bc9b2ee000038224f4eb58de679f63282c7140b23bdcb769620d547785ef920aa83e45d87633aeb9277d2315a944603c14e402aef987075e6ade73f359c18388ccd2fb480c6ff28d9b4887309b3b09018f7047c9a8a58f0ab51c17b104c622e7aba3c57c843732d1b3e7a23a28187059213eff1b8ba74292c2b239089aa1eace7217fee2a1f43c7aea7d9167dc31bcaf670bd36ae1987c880e0224576885141c0ab6282fec54e0d424f7665498ee6241a3e421bb2790647e6c0f02dda4c5d1c3a2e2a7577ee2cf10421eeb1946f08f1f39f86754ffa68e4a83a1ce20859e11949d3ace63dc53480526a0858a9cd79a1046318803e96de82584cc2d96ce468894da18e883a894feb91ba53bcc89e0cfc0b677b4a3c5dd4c41b89fd7da0ba973dfa299e054a0324bd573056c457347719e0fe84b52e72f09b6da5e0f63581e2d48062804defac3aa647c67a6cd136ce0d6c94fbf4ff411224b0117867e030d4714e2f9e650827ca7f0edf97fbb478f6d3cb0d4369bd4ccaac28522a9c6d778ed034ca4023273965c8907a92931b5cd0b406bce1bd0633c92df1e2b3067269215dd82c040c0647bfc9c7fbfe728a9c278d0a6e34b1d33a606fe48c3c31a4c7aa80f3ece3c131c2ff0f224f931552eb49f7b8fb2e3b748c3205a9ff50c301ae1f26ab1188d9d5671ea202fa900c87c6162ac95c6a0bb5ba5749d98086aa47afe3c7030a13ea4e0190950d62c6a8bf1e5b1700c5a5df2a9a455215f85201b806efce19cf343e8b92fea2b05df935276fb905d366151722a06bdf1b3a514438eb43c9afbd12e8f17cf5b29f08856102a39380bc1f7340a5765b2e149e751a05beb2eea8d92204fbac3394726924913a0d718d32464301be2b4e5313b82d4d4e6d8224fa058f931e82cc149d09c2c8860c56410ed1953c30c97ecf5796682089fbbfcb7332c9a000af74136c984888fa75109744a3ed633add62b732ef422ac12d7c929044c317d46355fd3ca3d6fc2aa6c64f0516b1b0bd8fc146d751fa583882aaf8c982e3ec4fa669c6341d993716eca27b76abafba73e5ad584a083c8f22353a8ab7bec574c563203b5ae09c536f8a88835abe538da540a1bbf140c8003b46300b1e0b5b33d5c1f49d8302977b4219cd7029c75df4f84f26e649b8ad8f049349161c79945c365b9a1d70c36a28d40b89bdced4f7678e4e0716ac0b227224c510a94e1413f07ed4a3ff2473caf2d0cd143cb036723eae48be9bd8225ea6875f13d8809232dc0a1cfc4a4b1911c85f467061cab31d37959ad9b813fd78f130b4eab440ef6c24ba8abe466a02647df76db49a0e2c981db9f5bb853ae639f21d92839b4f9bd5956a0423666494f50180cfcbeb7590169fcb4b81551238915fb10acf3114861139c94876088e9174ce9672697e3257b0911fb7d11d84bf08273911a274520feb8220f3c6fb310efc0afc934859a9bdd6e703a4e527506fa01533b4575acaf6a06447b2dbd0d83f8eb8c8e1f8c801add1bc5b97303e69cc277e933604c4fb8d41d5b555e3ed9c0882bb4b0d725b0234c2b2c975c1ec2022424ef63644d9ed3beb27b08784da838d5046a60fe373531b2b984a1f2fd0fe3b465699560dad3a3517765625e43a21130f54e8e5c238c1a50dfc059d81adce1b1e7d59400e15ef47173fc3565695ca1b95edfe261652c7159d7ed9f0a7596b18d27b60aeac18de473c157add0b4556db01c4d4ecec7537c03e093f6f2d1a064622c2379cb3ef79b0b245417bb6d35825bd8786f87e8396e7cafa1b91bbf37e0e2692f99b0e46f627cb08ac2ce3a0abd98da3c1303b8c07b555fe90ba9d93c2cd3caa6fefc6f14b6b88dcd501e06d3fe403b42bd4d9f17f2f31f77a33e913e195fc779cca64d6e47802282d8ea43dbbfe24f658f1544485aca65ecc0b15dcbf1fd1060798f8cfd8f7b8d4557c19f95a43171b63bdd56286637a6e8c9c316f1ff351d2d8bea98d8afc4b73b3c8d3b8a39ebdefb69f7698a833a20d8c6a0e46a40fd67ed9243c55cc92eedf35960ea36c86a117224e2cbf3412af241006eeca2eba3d89f6f2014d43a6305f741c6599652d529a2543f0511bac82cf96aa8eb9007b1814c2816e9efb61a97090c8b0bc3b850bb5fcd5c7dabb041009b9e7b28c1a464fa6dc70073b620aed869cfe3749393804e0a1e046b48bb87fa4dc9632c813c11989cd0cdc0ae203c0a9e14fcfad85329b4194e583e85cf854c87d3cca89c4f015b6d1241a19265906b3c49628b12c257c52f5a073ee5945caa9483f34248da5b6d37e1df7472047ad5d155eb9965538e58be62560bfd7e4a580bf6eb34857858af39d28b0bc75b1571701fac8d654cadb9652ef58ec3d7a318f0769d2bd0eedc166f8f0d1ef484c60578f8d6e03c6ac3614359b18aa944dee296dcef76ac447f3862b41ed92e242eef08b8824183aa753deef9e8929b037b6e6dd071b8f5a4a45115328ecba119f6cf30f90edc42e48af06051249919f3b1e7a59dc1774dcfa03ad6c75a1c4b6156972a9976217a45cd8b48f8b55199f120010a0f859470148df6385fcb4c69bd95fdd3b7c6198003fefec93986b535af63f16ec165cd1236264659065c17b76d6eff1fa4630ca4b485dcac9dcb5cbece01c3822229e867fc082db8792d2da60b4c1e5725a4c77d6b00b3e3753166e673bb9d876c2e092cf93e9d5fa16993377b666f79b71054f81b99af39818b390eed5dd008c9b8391a28fbbcc8aa68456dfaf26cdd978cb10e6c1cfa6e3db9d22c6749768d9c29254cf91134b851ef6dcf5ecc3c3a32157d995df91c0d1e639b3d3219dff5fa997c499fc36b1570203327d28e78009ca6f28a5185696cb6a85204527b344d71d2c2d416612af7c2d8d115f6728fc0fd1980aa7f7fc9e7518a11e8df4bfda2039103dd09d8a70f4d7b38b4753df460ff9f1afa45c9b08a8b269264c2dd76605e6d57bb0fbc7e3ec0e429b5b99fd290c896f22610e2299af5959e4dbf6b9880c84fe5244f0990098aa65dbb58acf6d93f7fa14d70f873a89a222f48197ccfc55062fd2e87c73b10ecb9ca474865ad36b0a308a8ae0bd3e5671b9bd89cc92b5884c30c57d716d516c15d9af246b21dd0292c983134b004f170bf0b096c84b02b68f61d3c200efabebb1a8175bf5e8d143d36eff03a7d9aa8a44df4d05cd564cf743de5b3323a40d13f9fa3d1626d0b095f0b143634903a089bea8ccb0aa0b5d728103ced1db3c655d55d531d12567a3a7e117c3adb933f404805bbaa74513c2a8eaabfd59329a5bd3499de53ed9c28b428d2a9bb6de75e0cb362fab8a3dbff8be936a0e7cf550759c04e4d3220c4e3ffb95db4d2bc41f75a151926b2447bf19ab3571a3591617675a470a66bbfbe773f05fce5afaca1bebcf148344d12497c79eb75a094eeb34d95947e4e8b8a1b2cecf08cbe3e878a3384531186bff428282e489a01528a77fe9fbf7aafe43e279061c91c13ad7f2210bdc27b825c02089405bf6bfedbc17df0315805fe7ee3c8de568d71632c132557d0ce628fab118b790daef0a844245ad75d1f8f7dfe50b260579cad4577fb0318ec06b0ec716a3076e738610fc4abc17495ec057fa6be263c54ece642e71aeca0fb786e41e0c5513e3807168463bb9e05732601299ea11beeeca90cfce76d88e2b14bb6087eaa18d53d8bb14c0d721a99850f161ae59c01916aa9973714b4b5269e585e981d5186567b673d8842fcfe76024b1bc49a6074766ed96d13c0fc6d3a65e15a420d28323d0c0ff57a08e147593b347f14615153c10a1e1ecde5f6229402785e5be1b89b5a5996a67a552b8bdb14339c8ac0b7eaa8ac47d526bd3032becb3ff37a399f77e56eac289438e7d06ab85b508d487facc4557b1b411f93a2507b7986f1504f59b9791162bdcc4d47a29e9a243aadae5150586414bc43b3937562b1e0eaf3693af91a11d6bd4e7557fd43897503ab2ccc8e9e4032bb83b3d35e7e45640bd5033f2efdbdd617225b3968d2975d8fd98591caeebce188ac1958eccc1587fc6459d5883b6b977f907f36e3df1662cf0b24a257a0358888e5e1428c8dd20bea0d7e1b2e7142dec994bc9d1cac7a1fd2123486e6952203fdf032e3a019689ce2ec75709f9c7e5055b0f995a1b787782dc2c230d42ab107f782acf9695bb509f6c08c58c0cc8ea36dcd58f1c7508234dede5eca848609de1cf05cc0facfe5bdd3cfd1d0fa7133fef7edbbae9712f42ed5c500d971abdb35c520af54c73231cedfc5593ec59c4e6fd3b059dc57939ba5c363abecba2391689437cc47a48079c752bd6f1813d339b1f312df1b68b795b1772ebd64d097d663ba99e82e437ed7a75e1cfb11e61c84f46379923c85d3382c8a3d5cd2bf4a240f72b468309876add6f7a5823cd4c9da148512a86f6a5ab38e6f58f5dca1314a872e903ca7f499fc6d0ca6d34acd611a7fca30698facd65fb2679a0a79697d77214128602cd86c259f85edf557b1d193aa3bf03790c8478a1e49485b4de686b4ceec207cd37a510472ddb13b4244901b48c8c473d29e6d7aad96ea3267fad34ff064960df693b79539fc914c5e82d7ec912a0a1c86040ce574fab623828732754a67ba8355c5d541e36f55269b622ee115af2b1b037eabfa43f012bcfc1a9387b4340e3a14c95155fc0183197a1bb9618f55ed4612d3fe621c7cf84b5ec425c595b05cee4d3394eec9d3a20597aeae5689b16d49618fac6019b06a1d290288f12286b5a6c4709f3c7bfc210053b9e78c2d0a4d46e914407b2da0acb11519b369bc9dad7ca7645ac4830e63aa9234aae04c78b1cd7b800416b4724a26b7942253314a7d4a660becac6cfdf894bb413219db967d26e9a19fedb35234382e6e78724f3f25b0afdfba28433ffab7b331ee16d79be79c87c2160d2c7809bfcea6892842158a2a9b3930df74a88eda84ab64a58375453b8546bc9b676cfbcfe8a30e6f6e95a7ef9640988d8179806402377bbdeb08f7069e4efbb667938e6523ecf6dfe5aadb16b40dcf50023780deb87bf51158f9e78cc9a64e63cbece9bc1edd257b2d306328623631f962ef73d3cfaa6f1d66939066cbb04aeeb5c1c224234e1e565e615d736768fef4c2c5b174fe5daca3f4c0abf78279641a743cd8b8e42736221a2f517f457abdc5c6e0d5067a240c5932724bd36b2a0def796f65b271cb9cb9862c56de5140442ef2cba38919758d8d62581be02ea31fd8693d41c420d79deac3cdc5de828671b33c9b634d89f5859b9a604587b64d46c73326c40e63f778214083a86ce0915bd205c05f2f4dd5bb450ce10ed85eb597aee1f37822e415117f814e7ebf9e612d73ba4f24dfdb2684b9f40daf61075ac3047e1181cfdc56c7939937c09694c01b3ce5bb7ca5c3df31fe91ecb7821a9e114a83c1eb358ea3042cc6863654c62061272698da96f6d379c5c7a5a833bdec67eb85a9a10bd483b5d9d6197fa611028a4124c743387f0b55e9d299548164416b280c472813693a1428c7d94a969e8fee9cecef45d1551fb89ba9e9525f36e9153996c1b82153c575304bd5e5b0b33e5a056ae365c1df74a1fd80ad21fdcc9511819628925a47f5ab028af1a21867fb2d6ec7c23f208a8e42805e3314e7382d66d409f689d50cccb5529879cf4b59972f53aa9116c063d4e21e98ac896ab0a929948056f35c4f0708e63551406d42aaa04b2cc03d37eedaf4635b1449017ccafacee31b36f8492fb6d5951ea3f085714469766f977472c9153852f20aa19e5ab70fbe469f833ea559ac55bfd95c1ea2e362ac9a44f51b16feb1e182386301bfdfd97e081c2f63ebaffd2279c5eb5879acf884763a3b8c69156169d146b6fc4987c89b152c10e6e2bc245f4d8b10b55ed2e6c1785485d3773c9cbeeb14092fd1ed7e9258d73e0ad6a2d227f043888729a3678353ca3f10b5d5dc7f3eb2efb80b9ffdd0cddb649d9bf7d9472e9b9db748f38df89d8b7f55b51b1e94b2c42fe333633f2e96601d8bafe4ea3dc73d04fcce1589c95de60112d1f6735061e5439f82f745a10dc8212f99dad59750ddd636e3ec1f4f1800dd8e5ee9c842fc9aa4ee2dc19ef25ea503092e24fdb5043dc6ea2af79f326443564f6c0af2dbeb1cc5bd982dddc10e191caa4d1671db3662a4c7085cb03d1e276263bf87be7c7c902873f15246d3578418c0393f10a775854b332221e33ddbc98bd14360d23ea01b4560c7293b2130db46fb56c6e253eb42d579d6f2ba8210da08543ae14e29b59f1b1d8b98d2b930fc5ae9701ec627d452143bd161ad99121ed10a2bd871d26406c33a8711bd965c52328982735894e860ce3afbf40e36a2396035c2734c5a1a68e299be440a57e8180c4d6bee4af8767e68e6a3e74502f055b28a22eb09ff292e812082ad15011d121c5bd69864ee1015015b09a95ebaed8d283e06ea2cf5ff951b0c3340de58b5fbff169385a51ed17a312b7ab42d6d29e335b8cf19e2be4e6f4743010d5825f4d205e2e4b548f4efd6d135676ef67da2dd809effb21e26ff52019a8134e40bfe39205bfb5b380a9ae20180632cc06903f4c6d87a355acabcb5cf336728c8c995d8cbc0b79128dc5effe4bb5b7d3786e3182e5111ddfa9e425b6942883edf493eeb977fb50388f97042fef6ec99191a95086fbdd939bc73e07927c3091e05f0472150c7d47e387ebe5f96b87a779c08742083a2dced3d4a036373edab4ccc57dde2cfb4d5b0070148c8c4edb7b4b0dfd61f08e562ecfd7178264b9c8303f9ecbd28707b7d8bfa6b850fd5dae8e0a5548609379cc607bd0bc32641e7c1b889a38d5c164a06a5d9b691fa1d4a7a84f279ec79fcc0da7275791adc74c41a9e35ea33e783c64d05430fcafd16c27c0405739ab115099e6d31c791482533449b9810aa2252c2a9c36561c8731004d60d339366575f936fa7fb7179b9abb687ccfad200e0f34311ed5dd7034ae29b68eb1d879cb5f14a422405e3d383cc10f19c787055e850c20e84447cd28ee443766a18aceda9bbe5860283ec57d63f2db9094d3ee168bc596efb49d7a74cf988b9c04ecb4e2345ffa167eab9eda3c0cf099384c3d7a1e75dc3c8c9fb8a46c976e0e3a36d0a4285d6070b248fc3c7d773861b503449feea59c922a87c528ddffa3578da49c6dab4d60a19c3576de2009fd637a2741d671b2121582db241a77c8db5031a6d90ca839e3fafe49717c2dd63dc261fd91548f14c8445deb78bb5c38cd54f7e54fa9cfd9aae7ea3e87345c1925d683d162f7bd9c163afc5a8f4ce74d18e4ee54300f3eca34b5d7083728f7c21144484449a82b61fcf451a24297eefea65bcb45bc4099df26777aac5a0370286f861e6606c268c7a28f6716d6059786d6e3fb5dcbea80af1982a33184337b768aa85524266502f1a6aaed5d7bd55dacb6dc99561f083841b83a3ce72d2477ec8a5fb4208032d62aabaadf2c723fb821c080681181663a2cbc494035afdf9ac62109190637978d1c338f0a571027c609f0cd06b8bc8f4314f84cac56a96279111eebc7790b3d34cafc7c35aeba5602fbdaa03a21a1bc88b2ccebdd0e3d6027a44b2ec0ff3f964d09c25b4a4250b2a108ac80628aedb0880e652ed6c4fce9475d177993194892da5e9f6b1517a2ffb37d9c2e771b13b0a3b635fb3e0d7b010240dcbc94c4743bf548061b08b615f2d0a83c66c26da2994d3344014b3bcf1e279075e03285e2427f45789e9cdbe1a96ab8b07bdee13b8c660ca0745839d40bcacd86bb6e192c285b84ed438dd21baf763d52e735aea384892db291045cc1e1cc0956369550de0254042f2706d38cb9f50d276a4de1abfe824c96f4345de3aad79551cd2a4bdff15cdf85e31301e236a77401f013d8bf15dbf288353e78581c3da4c7fcf5a420f02f01d36615d336b60e547992daff3c3fbcf32048da6b7f9c7abb72cfebbf8ec9b68afbd9324d1f6246cf778ecd8a916045d1e2faafa731822873ed121b54d111b20036bb0d86ebd14a08a3b16db85981163f14369a09dbd1aef09ad378c1d724beec4a4f3d87d6b62a742d14c947c352e55ff3bedf304238951759de3b3740953570c5bf8e9947fa53e4c08dc260b565e5256bd26d51b0acb70c02969a409d9dafc37ddbf6a20d71975aba13c95ef11243d149c42398cb6102512a7651fc697ff5b77f48e5c330eed3deac393cf9cf80daad2ae82f53289e3029a2edac23c79fba3d4ea1432849a3a0cb028bdce49c50b1c172bba3a6c27cb3df6c1dedae29516b901e653ada7a0e0bba001017d2a4a0cba950c5ade1da5d940696b19ca5de76797d6f8f9083973b07d1a6817be78d2c13108d531f066369612eb6a1125cc93389ee0b9ede42839205356862593cc0d672b6b24aaa0e25367a12e9ff7c3c1bde4729b008b6a5207e3db4d0e30c5db4686a368b22340077d8127c20e76b1e82f7fb8be09358a3dac07ded631cb7d1332d3d5533494ed4718b103929804fde502915d030d50c8b415ea111c0ac748a3378d07bb9687b9abeb8600de17776f1e7c8da8f8ab13f9f4fd08f8ae08fbb5e43a721b842c7bb6bd6d9a9b7ae1882f48f65098bb7a2e9703b391e40343032573ec6ae5bb52d4d8d6b88ffd084a0af6abd942d66524f7d4a0fbd54d78d52393dea699bd3c2a9337b006c6c9d26324764668b155e309d695e367cba276fc456f11478870305e69749d505f621d38e437d15ca5e46ac63e219a8a3a62fc2b97e715c5501e0242f0e64e85b07f5579b5da3f67ce981f0590869a8ffffe585a6a22a22f76ee64b68cd9495595c07cddd335396cdeceaf17ea8ecd8d09869e0c75c7917f370fa1433750fb19ac1c7335d3798bc283c5c62e9144188c51a475846498e12fed1ce2fc03bbc2a06ee6dcf214f83ef5436ef78f1f81ee69eafd25961c6f001e81ee333a0832a9187abf1ed44a64ac899d363fb1c898906f030fd5a532093a15b4926c7bd1d4d8dba098400a44fc3c984c4566b2938102c79edabeea6b9cbe86ddfd2da8e48d8ba2f3ce472dc38eeec6f2eeda419cee0d23cb03022f9af7e9f7b5321a8b1a7a88f17e3728784917bfa31cd3f4cb09f1afa8c4a88678d88192a6edd792aacc5adbf796d9996e22151d3d4960184fcde785783be9801a7e813837e4413c09c6f24b74397c1fda10195417c1ad969c86232092a29b1d828505d15ce2407cc0813d9ed9e231ffd994375fc12772797529f969e99cbd2fc6d43c1e27ac2b3fa79baf6471da43ed88f560185e14441988fdf40f0adc6cc505e1a1caae19ee958d9e3685067a6f16564d60f21b4725cebd240e22c925a163dd6b7b95eafd137593e10dad33df8ea45e38f3f6298f5154a93ee0e9237c2c9054d6781cf6b19246e05abd85e51149c1e10109c830252e843bc4a0bfccc2b7e478a7dccf80468da8d19caf95f31497b74e77e6f1fcc9f0b72fda1906847c1299945fb72ef1502bf19cc3fb90a0446f8edede1f285fb147899deedd29653da52b2da4430326728a079e7c3dabb2210d72bb9cba2f5f3031cad9649c3a078ce3f148000d7c7f630cdcc4cd6f804668855541f58a6d39d5f0b05558d06f58c178d02b60dc4eedf570da92fbfc178bb673bb1e9262649f43884dc770f3cf9912fb9faaf1668ca5674e655704699055a9b663ba6d4fdb3bcf9f5ccd62d5dabeed020bff2bb14254170519594ba788618d0ca05517f97a2b2faa92c0093d8af4992fe049de8c0ff2046f4442d995e45cc8cee8d3def6022e43e942bbbe4de4095ed6bb7880a5d23e4e1609e82068a520e97cd23c836567fb91d342d4d0dcb99fbb444aa6f09f0b03f8c58041b95bc13fe1a4f5f49c264ffb05f5cf018b0c39c1892ab8e4089eb845d6ecd1a33db6e80d1a7b7a1923d5c0b791ea2b736db369d309351fbb01df82db3be7c64449884424941deb7105205622040fe15a53b4fc5ac43f93fa9c1d122fdd57df3c01895dd74be0de0fa89bdd87507a7a01f2e70fab0e8fe38d1f393888b72956e0308ccf69170d41a187c15c6795cc55f6620c881e5b0459bd985135e9edb8284f99c9c02787458377790c8a1cb450fd41d4d1ce3aeb8a683d51aa32a8122cf30e668d6bec834379d0e04d66e720fa9fc6a762d900700d8567f2880a1c3b971eaafb42aa094c98ad9eda6c37b6e207dcafa328b5ea83477b90b0de40856879ddadcd5ad3003115b32fab04b0642279930eec568bea40beddfe9c42c9f7b3f71b728214cf20594aed4c47632edcd31d473819136e287c32d9cb71b51dc40167204fba45bc4a0f64696a96fb06abd3ccc4bf3deb8d03deaa5c718fb2bd189ec9bf442c53677ac93e6409c48da32ecce5d05d447c87563b7b1fd1b67b1d4fc47cfaadcb7065332766ec2eef49bebbd620d3379ffba352a9314c0ffdb623d3211b028110bd6c0ccb2c605d9aa5e64488fd3e524e71362c130bc75f799ed57399bfe30d414068d234287a5769cb26de5b149ef2a295f259249fa286ae35683070a2bd429a06239566e3e8d413df7c7c1ce6f59d6007122c31242b27c1ccba6a7dc72d608d8e19d1b5a1c4fb4ce20b5816fcf44fcdf70a071f1bafacfadcc3375ac7d51163bf68f36f9e87e269a664b9178e125068a16274ef26157e980c9472f20d4c7405903f72abb5197c0aebe948674eb83d7a240cc2065b3ab91a587e0463b9944423ec3e46e14585c3f2ed77decbed273856e938b2d5899f02e8796ab69247e7c97d7609749482c14021ad8d033a3bf3b74e3d766cbc9ff2f5da32c7cd9fa4d164a9afb4052e7dc8770fa2c46277259938aeb4a741e81512c7d9898704e7e9fda16a2af966b3cc49bf7b78b2a8b09de74278df9b6d83fd3f1e4356d52171b484a16e1ede3a18ffd72ddf2763ab439b69bb8d0bffe164088af2d028c32b72cf43f29f3bfd6c932adb48021020cdcfe5e89daea97c6f2888f17140c91fe426acc942040f471ca3fc80ed17017642802854f766b3d192c137ca3308724aa296b2cf6720667fe7fab269ea059094abc95d93831a75cec11dc2efdb5508afd69208cb5c0d49cd09ec9e0343700334c276cf3fe78b5a97673eb811999cf40847d8853083316ff55b5c8051fb78f9164e4af509865dcc71dc2653f2199cebd9c1994a7d13356b141fde085a77b5e3768e6b9276cfb3b88add151c81771c5e9a9c8ff89974a6613d8cc1be91f9ac014bddd916918b642b4a87eebd52ac44c24f52c15ec705f90c6c1bb08ce9a96702fc5b660162bc50c346578984051306f658a8fa53be2dbf5eb67aad01ae9099a13bf26d818c504c17b6b40494b18a092caad31f820ad20c7dbdf4a54c3f28a13b0f2ac38a98ab32533b640f77d4c46c3367b18d4d4e91a1a03ec4dfc563cd73a11caef0ddf46f87744d7cb0c757cc9eccc96bf81c0d845b053f365a932b9df6e2d7bba60f63fcc5f189aeeed93e798b83210c2414e6879cea0bef95c8636e39fc444df608621ff437be27063581d0f47de15b5c80d65e34e109c560333834c75703c21ca114f4c083efc1546f674d30dc32869334f1340019d68b724c3cdc103abd1f6f021902341eb97ee38549cd60c272ef223bd0d62e873d79a1edccb5b4de165a86d14aa8c21a99ad288c9dd292d68094a2f9a180d2ecbe09c0825fc5d202dc0e568bc6e806058fc87507b0b38a7ee4217d509f9c09e77dec62cf6cfa5a714c9a519d208093e7bed0cb559b4e8acabc2310deeb4087cf10d01b91b05b51cbe6c976aaf1fb546745464106aa96e0bc8b3b81e0b079dc0c88f54e906f384957b2f8d7dd1b8079dc114203fc2d45a538e6d6cc94bf6f824407bafcf67ab951cc37ea81180e418725131afd72f56672d885a19ea554c7f3243e058ec867e87dafcf3123d0c1d880367f08b8f2322cc905769089737417566ccf2d6856929c43c266e71effd4d52eedd36024c5ee9eae09baca29e0039b6a459aa3ecd64bfae0e44b18e8ad364cf562650b442b06ac323d753b0be9ce958e5c58827aa9c9c3feeb0cb25d67012004f878dcfe4c4f71ec17a94fdb7c458d3930d3c1e8ebf32c1670b89030925a355c6ea841e5c675bdc77023f2f38c3a417fb148a24897bcc78f75dbceaab98a8e9a42011425f9dab2d729d8e69a27dbaf4512164cd31bd8947e4c6e8a9790411caaf856c684eec55091297da59ab16c310f92d7cebfa54625d3e6aca18b38b18f11fd9f1e7d42db806036f758098960e78a10582f79b7ffca49f35044c42985497af8208a9efeb8bb82d3e883b81a2d31cb36c132e0924b04c3a0a7f675322859ba539737fb78b5aa05d78dedff42fbf8043153349c0be62620fa22023edba26543a949d7bff2662daccb0940267c3e8ed52b2c6db22593147e73a39924fadcf0cb4e1d5e45ca86ac1ab1ab467105c32fbbb96b48406176d44f696e1b58ffc79a7b62ad25766969e7ae22d82215acba700b62d4c9b884fca027ce5fe0bc4cb38ec1e94c9c52f9512e4cbcf4fdd69a8b5088583ea5b3e47f749a99cb6465c930abef31fcc471fd2d3aa85d590faeb73873e7d73e315927790d2536760cf683088e5db7ae78a479a3c1e99c4a4acf25c7a76471cbca9f88e8d6f514b5b5eace986f40b98b0378ef86a24f8835c4df6556b93cedbf935c7197cf76d4104e64726c149ca9319c8a33fa6a08b814902383af9d420f9dd47611c00fc073fd0bfbb190f5ca238846cf933e6fa30857b479afaa3f6be76457a3ad48bd47499a9b582de8f9136adb67bb47d084fdb0d905d2968413f56f1aa7297bbbad9a5d1fe23cb382a0b068d1654468b27d0509e340398ad461dd765187cfeeeeea5bd0472e21419fbacd1cada16739b2a8f5851a506cc61427aea86b0bf4f4fb8feba8f9e955c335c3247dac05a391db25730d04b747fd3fc187133e3d873f6c6596543188a848d959d44497a6177af0b2dd9e3350fae976d9a4491630b090b55be182af00485c2589b70aeac82d479dc8960098012c94bf71ec5288bb2edf94680f7261e9f68aebc369228721d1638a8be9620df23b76da4987b1ed512a034f76130afceff03938207061dafdeb78a664d7b066cf6ac3fe263bebd12bcffcfdf3d5c6f55305bd64af453a6d97361e9fd661688858efd306f119c7ebd426ef348f4afe9988a35d0eb2261422d674f07bec02f88d7af0dd3354e9906b66e26070a29332838a27519b84ed4181dcabed10890fcd3b80fbe4bd0cf72507b9f1c50f762e793ae81c85497f3bff2ae080af03fd30545d1956d5561263e63ff5d1b1c7563efd99cffe71cae9897cca2a886b731f3aacb524aa7a50b90649dcb539b5fb36ab06b4cbc8b65b3d24069cd78e959bd1619b9e27bcd49cbf0a7151fd314a703f865c750046c68500ecf7d4429c9066adefe61635e19cea93b48a7aef49051a3d80930d4181f9bf9c947618d7f346d19ea55620c3ef7ad02a522d4c2aef23902511a0822202c5a14cfdd056f776f407873eeefa800c51857e481549f444ea4d6e0c0d3cabe2f796cc0e999b90e436f024bb7234c741c679577c7aa03e0e8f8460fc74caa5ce1e052ec1ee92cb3c75ef07ec3b0d80982d2bf979b90fa04fa56fc2ca18a4a1d448eafce523c4305fb50fa97be371b42160cbca119289e45a563a98ccfe2a291f88ec85d7879e57bb7b58bbbbaa9e3017d4359aaa9927b0f90a4747a31b45297705d5badc6dc5de32d8f95deb357ad9a84dadb6e8071789d20d0c95217e330ec971fa2d1e1c81296a97bbde168b14a1fe025fbc234454db7d9182de6b2791e50aa42ba03116d595ef62f26ab47980dbcd9efc99e195a1e1cfa35781d02003a8b7cb4127af14e4facc10e613a290712d9e47d924410b3a572c0585b1617b2aa5e1d2b480b65edbacf494c72d37314c42bf9c09582170d62d2f2c872c15bd71699d84d9282d82aad9d40354c0cfb58cc21f6afa329b2805c58c630e6b3685bc9b50736f8f1cfb61fc805eaa48799d6afface382068980adb50dfcfc39f63500c7005c07cad51115e160ab9651918704bb50d61f7e47214ebf57aaa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
