<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a84d67bd1244fd2066340951df90d8ce0b137aad6a1876dafe2ef00b53a2c8fe51a3a00f6ece08b643f26d333484be8ad26e308908e37b83e7dd04c206b022e93ce6c6c00a2bcc9648daf61d76fb10211b8c6a2a9f7c9d1e9783af713fd95d28519f0e4f7afa275b4114a3b30995647d0192cf2530d3a8085ce9eb965dcf099619763e4b2a9e895ea7966ecbc9082d2c0cb076ed891f6fb95a1b463d1cf2b460d762798e197f3a04465c3ed5cb10fb13823851f83337138af5841e0bae551c09996d954f4a88c0fdf524812f851c24e1745a7fc1d58aea088ff0adf0baf4cde132b61386b0a1c3af0ca6a5762ea7fb97ded4097fc63f9ebcfc4b8310a3d99791eabd512c02d733c6a31da7cdfc0b7526cb805256478c6d3fda77460421ced17180c1a2596a800ef5953bb4535d729f8426b93a8ea590404eb9f270394a86157f468b9de51a79d729918997f052720e1775cd4c9de3595c0de9527e6825add63548666037b98742bcc4dd87d63cdf4079c4f7599010d20de2c58e0cd96345926c586d8d8872365202dce9be38b3cdd8ad93af91e52c092685e7886826ffe1389126d69e8d87e2f9fdd034705cdccdbfdca79dc1d8d3ec2e8faf7a9427beb2b58517ea2dff1ff9555cbbe2f68731a1910874e1ff95b13dd28f816261db3a1f67d0f18ac64fbb8e6a7bad90878cd2ce971644b8a7d3f7a5315d9f0009813bc1adec48dd749d57c1c25802b37e0179c8e23aadcfd9f87166eddf6055469bc22751b51ef9b337c02536e516468eaa1d2ad5d54cbf1cb5cca94ac42221ef9be95710e7edfbef63b3a73e2ca06797124ca62d9739200b61a6075ab6de360f64f9042fd836f7b665dbc197939fcabbf997ab3a8125cb2c42a2528e5e60f981b9450e438aca5bca129914137b6c81f8889ba522352dccdc8c101a295370d1687128b6df1fb2885e586b7d4c90fc7137a44fdf3021cfb349014bb6521e2d88371ffc78422e803421e38a2d303d710f577085950bf953cbbd522cfbfed526ea5f16ccda4a5e3b6234281cf0c44233cc49da10b6b75b139404451d31248868ca35b71ff27f17838373354fdf9098cf75fb31d151583e39db2474ddcfb5da3a0f6fd63b7bb912169277f07a294f63a1d1681eadbb3aa1f3669e638a5a561332271adced94ed8d9b49331df639b1034f7617748e6e8ae451dd5e9b238bba7e5ded901b2a76ccaff3a672f50e506f3ae832ea0f58d62fa9686135975c110cef35e809393b3993ebefa4cc32ab7ee24646b3f8f88f1799a8e7d496294a860c0c5f173f34c540455d429968509c0d4a0c250b3c0188a5b91c993f762415f2c8909957993f4e58883016d2efc848c88f36f8d29de2ff32137aa18f967140187e0ac65f5eded950b349db80fd048951aa04119d3761aa40cfb5480728cdf8e0242e6488d179bd1c5884eb45bc90f7f5afc06b68971478f3f3be12ee9eff676867b6bfbb6f645b1cfd0a8862845e9a3158b3033dc9cd0c2d3bdf2c628d63d17e84939c9e45e401cd06d1bdc74d7c576c86684e3543ef276191a89ad5a2eb9e811ff084bff8265d8393332cb48f3c510d4fb11b74bd7c6309812953b469ccbc473bb68c7100b5b37f21bebb6255190949090126c78330f44a851fea3564ed7ebb334a4ec4b32ca9a10cde6982803292e2e39695daeb57987d132455d902982734e07ce19dbf56e69728110e538400e7638bfee438a7c33e650c657a4381a62e2e1fe0dbbc76672212d822b2903cb039d557b47e315f5de417aad536882be3b2a94c52cd10656e378cb8052aaf5da0ad11598f3fc8b23f6f758c4871be24f9b8facf9dba6c1ac217fdea8f64b4dfa51209195288d2c33f2d8bfc5ce4968c70899297bb7942d8b1bfbd198999d3a5497074e93020f662542f2d3fec8ee17875dda7e5ac4be4d34c2558be92fdcaec172858152c26c4f989485b89ff5b8231c1b068128b455fc056ccd26b9265c611d3c4dba4bfeec4ed6262c48f537823063eca40323b2415d0746a57bfafb6e2ef3195123760f3a1fb30e53fb8614590359675a2c7afaef8c7cd3d816068c89c18131e365d20969df9376866c6857d61925b5ddc1f7e83268edb76807cec91a0fd3155332b3f0326ad0302c9b070d5f4171fda980cbbd496291f7d52712d1dc9cab9f8e8da9cf6f54a5a564ed720d974149a6d4083e733dcbb090107d3031735ee826dd2d0290ebb2daade83e75a6292c6cf6e4156a30f27f240cccb9e3216f20a47945e6ee8610e1affc7a979f62376ab2d62e0f862d0084aadc2af06313b56a44cf1c433c5fc84fa8ef7c73bc509587096eb5024f60c16fb9a44d5296e31e05a194f4bf51d72a22aaa34c0011b249681788036d51ae019a07eabe8ca0aa4d4a19965c224a69fecdb5cbb34ebf8325153d5bfbd15603d660c2b5298120aa424f552b1ed6f71b2e370fb338db8ab89771cb5e7888ff3920478cdccca248e2e927931d617e5d115c74954b7532a29cfd23640e701897d8a0ecc52c8e58901fce56ba7d160222437d3f9f8211f19307e876bf630cde96a929d9e2a4eb260f56106dbd84f359e16c4647737bab3a266cae8e4fc945ee69c6ddc1d8f4a76f9ae36935ab3e169bc79ab761042da23498b301eb733641992210468caafd5a78527d23e18afce095a589e4c8530759d4e76352a8d735dfb3456e3e72f52ee2e62ff316988f33ca1418764e5b56188af465fb411881d7efe06bac3b824bd05392be7839039cb7114d0f9ca0aaa4b61705efc86c6ecceefd5e9854eafd95c74b0a7114959b410883e4906cacc0d2312716c48c4e1f32ec3c9387d19763594bcffd4adcecdb5a4ee016b6160d53f37d585740b0d4190f97fdfa278260c4f690cf3e84099ed2da94f74bc32ad8e119722400e3c04fb335ee6121cf8e29743070e1b7fb29dfa2282260b424231192d7380a3dff3854aa9435d7bcefbea1dae0c4997bcdd7dccf08c433e7b8b66b74b021666615fd7deb6ad5f45e2f9a4dd09a7ee392d89daa0d3efbbbe02117aeee6480f75beee4f0513f5aff2eba4402508e05c18299476c5a8ff1c9df3f5425ccfc992ba92cbc0cc44ecdc383c3fbdbe1484817cd89c6d05976729e8b0116f72aa10d9a623bc92124730c8a9b9f27731ffb7d4ac307a75686be4ff0f5d60f459ca9ac2e5d7950e2025336e9aec101681684eb00839b19e8bc08dee37e94a8d57b0ba64f77a3be3ce8865a8c8a6e1cad39c985b2617d0e594722037ffecf594eb3a510d293e47809b27b432763b7cf6c87ef64fbd6f09ac1dc2ce56c124505ec406c757ab9538b084b26c7658bc1957850d190450494f11f831123210f2fbd8015c0cf94e51e11dda39acdd6ead1c8bb147c2598caa8899fe20113b2e5906f347bd688f456fe97b80047822c45c44938e9c4b160e088d0022c42625a9fcc5dcd8181ae0169830f3f9a73a0a8135ad601dcd7e68fbd94edcc906c60e56e9131e0a0fe02eef018d05a9ca41439bcb0b6904175cf54553527047e5d4e261a480a81718982950a1b73c6414149deb1d92e9fd1fead9c8941a1efa8179ccd8ab7dfac4450759c3862cdd86a2ba11faec60bc41d1a32601bb34bc9b437d3cfa376427e386db19f9e51054019acb41e5e7b1de38130286bc1cc53ba34eb408c0e293dca8b4bc980d60b6d9c6711049e3663a51375ed6d1214883506b5ecf1826f49c4134e7de3315766a32ad01bd701daec69f10725221ebf665f458b457e09e9921490cdb18c813c78b0f01c2ea50b13738d8717303f275358c2fdf0799861cc020058ca3dec91ae2ef259b60222680ead7e8677857a447d2b747fe8f9db86c0739757fcfde77e8434e3e8855283127e120914c39987f9457e0ce9b14be4ad35f5ca430941356773a32ac25bde7dd42436548a3cf2fbfc5bdcd438007be642dfc74a71460a59388e2e0cc99e184ec1fefefb36455e0b838153e44fb94613b57df13e9c8a692528539d49ed2b4408b2e11a2bd7aca078309fb366bd7f7ffd38a16ee3936f8c7d5e5b50632e8e65e49dd617421ce21499fb88a5faddf92493d4307573d4d0751f934851d701f8d3eb405dbe9196a273e6d07c4997bea1696ab60bc74699b6f5020b26cbfd7bb97c69861bd22034ecaa2796207ee6545ffe2d539d37bb2436f389638121b0e716eee8e4e05b2da70e34ef100f37b0bf23a558cfd1b03bfdb25656d3dab841606a746cdd834249b25a50a6b380e97749f7c33394e92aad7f5106b6969d6b6afcf9da63814e3738057d59de06a9cfbcc822ead2c9901329988983f699d4ff9c23262e9f03c284498a12e730ba0c92ec5bd92a27678436095689560d57efb88e9224869248fcac4a5fc9cd2b2c623987672859b1dd10a284f28987e18b478779b74b7c428de646695fe0edc11c1bc34f84af7264e0e3214063e8669990000653b3d2ec64b832d8afbce08aec1d05f8afa7f91a4d1136e4d3693def42850a85dce24a7c0777b9e1b7dba6d352d52d1b05c8a7c7b246d4a7b708f806f9c5feb2a67037f4cb22477055b7960c15bc1cc7e3843db5ec9694b2734ead73af1b73c97441ceb35f1d15ed43268915c857c1aa52d0edd161d24cd691c45b39dec05ea9ab628e5e2ba294efc513e8d5194817e14cde4b3cfeb8f6fd9f9648a71f0aae0bdcc85aa7b3f421d9fb1b5de248e17e32cb8ecee1b70e54a14b4c14ee2222073e54282a964de62f81b0e0c41c722075bbb8fc7b0344cd43b59278fe7dad5e5e7da3da76b2e3a5a93fab22c9fc4a0310b9a771b938936153bfc7ba375671934db4cce42d8f077590b6070ea4e514d35613710f04a641e683a01d2f9d87ecb987dce88f638733a4220db7fb7b40cf1bff352d4c53382ea87ac15d2e66a57daa6ba100ac31f08ac8ef8e3566888fa00d28167da2520d20b4d080ed4ac5d9043df5cbb57b27826d52a519becdf175a68ade8b747835848b094f1d2a7fa65e1da5d3e1851292e4ee583a8750079a16c5c61114c90aad0cb5f578b59dd7d445c0b919ece4e76b91d04c25ca059ac72843d64adfe1e96afeeab8728b49c3989c4750a8efb812e9c02fbd9a23c7905f9eea257e6416d0bef1e4ae46509e89b13bd14c62d38350831056a3463fdab376c6095e7db4b9a047a56827363a209ff8c60bd4730eb1fdb3de0d7e0b46659af7b96298610fb39bca3994e6b5291b8f73b6bbe6d623114f4f5708b51c7079d8f1876661f019d46cb8b3df9d7318db915b3efc5dfb706b4af638ea0a8d9d1d297a675f6f6a183cc0f8459e5b5f9fcde9d4a2caf51a2471c1ee6a829c44406b94edf55a9ba1fa405fff6751a90e28522e5a2329218687db67a4c1e9bfb0a63852950c8c22c33c2005cc8536337c67576558818bce5e7d15bef3049a23ef998d9b02c89878c107c7d1af3d00d2a5f87e6f3e1a1cbfc37111b520080effb5b5b441a907570e6fd77a6ad5908e54bb22a0145a4ce61b2008238df039c1893f72dffdcd79e1058e0e82935a24cdfef2988f9a58f9acf37cd8c262b2760472ae39c835d6a936bd84bde29183bcfad9087409ba8813812fb7ca99e7e041e5fcf8b299e9554abc8036ac0216b4508b36a0d149a0b69bcca78032db536d95849f47995be03925abce8f6927388adb08229b605734f0f9ba60fd49e048f86ecb5abf6b1531463a3ca73305cbc556b828b7bdf086acf0b0bef0a3662bef8afb245eb58b052ca3c3cdfe9f368fefda5f6eaaea279680441e85f0f695b02a9affb1df4b66ec219a7b0e5a19cd24ee8a35959fc4cc0bbaa2ab6600a01e04241c090ab53968f565bfc584b3cad71811868044651613c8b365c8628d67ab4998be97e1b1bfb587d995cf1690609c5f0c2be295651f6322eff2c34e7fe0e8a00ab0f8c7626e33908cd585a405bacb55666a68888ee58ed81bcfff99e9796fd1a0bc188838a0d224803ac067601bb52d3d28ed1534daf76f5e28639caead213eb347518fd9527c4c969a453ec235b2a2c9d2115f6cb39f64d71b7e29038b7142ff202041d5895ab07a917f9740da6a60ce489030789028e0c76dda9888a0c3aca8dc0ca1e00236289985ec805f8130296ef791da32007b7275be30448841f5c0598655d8ed5717961891f9bc38ff222bcad57b3b443c2607ec8fc551ecce511a08c6f705b1576604a1fdda7cc4638f5bb38b930ab435f1b830b8516c1bead5e8f5625d4b8a10731c2be27bde912d7d5732058f813d379943d002fa55eec2790257509d53104c07d877068279f62671f5d4972f573a69673131ccd8729e267895889f39f720ba851c9c1393c31ca3e5b6c350a55ae8078aeb06c9e337b95ed2251742a6b2c3ee6106ba747e44b0745922470b9dc39a80f84582a305c7503f17448c96c4929408871dc03df52ff7be648ffd7f3b4b8f3f3397f089151666e6a76adcc6a147208cbdcda047b8a9b2840cd5a90416073caee612107be8cdea8eabc1c484e32507d452f178c61b5a492a014d4980f993d07a2960f11d29821dea8e0d4ec6ec64bba68f83c6a6744a39d19eca202c9f70d730a8750b7913da37feba34f732908fd8e1e0317deaf1110a03c188a6836c0356b9581497bc54e0b874a3f95c95b75a745d8f2a55b3562e994edad98086b08422a8c3dfc9dd9baee77241dce2f5d5a6451bd603f7c6d5a7f2d8d2f4650a84a1df22e77fba5fe2d2a2e3de7ebf0f3046a75598a452e2998a9ba0c1f5f96c1512b621fca75d032cc64a6e29983611c7955e742962978e58d06ad8a212bbf6b1c544a89b43dde26eb3619b58ef3c0753d6eadcd40c0d5c895ebcd449d6edf7d1397d81b27e656089c92f3604fecb973fd83e08c62d28fe1c3f26dedd3ab9b8aa8ba34243e4a24b8cd6dbb76191d6f618de18347ad8469772eb5cfd4155405707250bb1cc4a8bba495142b66198902780bc76d15470efab0385d9c11f16c3b04bc7f08e1abe11cab369c604a44b093a669bafb871ffeb3fc1413df5566205f8939b91f71b6a53f176cb41f4fca3b455fcb3422bf1349931217375016f1173c8a198fc2463c0ceaba98615f7dd2b7f3446aa373a9baa2fdfd09c0071deb708bf3cae92f92ceacd662cbccd38e31f74884de726de5b29202f27bf1e26a275f653dcd4323cc24f5e3b196ab92f283b4dafdfd079efc8d6105f7019af2cf508b3967ae6df55376b11bba056716070344777f9e6b77fc3c492e427579595943917ed00062d12fba8803accf17cd795db27a71189b307fa5561e4a00afda5e354e899d58b0c9dde8b2305f5b92807384888d594775381a5ce3ffc5f14da06ef1f2efa838465835fc6b9f804690c7d6dfcc83dbe21af6afa63882a3c0fe272f19c43706ba6d43e4cdece70f22c0bcc9be7edf236b5a92a078d60160b7d80a8e75256d6d42fdc11119610ae6d6169dba5b941621c74547830cb24c6266356b602756d98036c8a08105f6a0e79bc73e5c0515ae43cba7fa1ace6facb3afc48bf2513d1ab32255667edbacc17f2984c0017f563977c1ce265b7a97733c678b6ac5d7d3508d5d73e4e547beb1d61df54c32dcd682d1cc041500a6c6e5144ec3e0b84d71515b9315a4380cd71665eb7a27d7f314e0d69e0a98e0475f5c3ca5460e421c8c2befadb43b1968833e8b7fef6ba260fdb6b19aeaab6dcaf4449e9ca605f94c9f0350cbff6e85b74407f9c92e3bd8eb9beb9a298d96030f5eb8ad17a97a78755aed77dd462b848194040fd3ab58aa7c06739e2496b4dbde1fbd2082bc69ae7a97372ab94a42bd46bf11adf911a9d9327ae47414d733a395812d76a78f1feb4476d91f8deab03a17d891dbe9c37acc428c52340bf6b8d31935b4c72b4b14d343ff35ad1e325ed68027d95da5fa63c75d477d3b1b0c7da66eb158191b1c3f889ea810c4e26e1d86eb0afe8bb87b53d0a8ac8a8dc966ad2c1680c3c9a1554f2bf9eb5d5c16b61b732201ec9704f0ca7059bf3fec19ccb85919f4b54632a94e5d48e4e336778575fa3f42d7bfd3a309bae7865c2140931719bc3abec7de60cbfa9484b5d32a5d8c2d3a28ffa5ec95efc40a506907aab34a000365f96b973f4bce62a3fcb3aec793fee31f575d6ab6c3d8c4b9ee7fd938dedbd80a13d1c8330a8aa5c758bacd91d2cccb9bdcda14351081163f667d289323e0229b736450e719939458a9f2a9396e9283cb92fe44213f207032fef2db3d4b06e00e8244ab3fa424b28dae33bf6db501cf2bf51b5bc69419419248040079d22fd46eec02dd9f1dcf1edf9c50c5987f0c7d5834646efa3ea48d6d0a0a1f30955acef02bb410b7a723da1e7f34cc7aa6f337694fb6fa456575b984a994ef5d0bbd0da9d5cd6f3a498cfb37c9472b848aff6ec2236bed57513fa9fd4ac869ef2a338274df51711952d7755c45e1080a6fa13ebb4f7ae0d13960c72d04812b3c8e35f8418621c5108bfab62b77bfb33f5615738d264aeac4cab3e8a2796838d4dfbf9774526b17bddeb2d9117642d6b6ace1b20ed116206b534475ecc724ebc5df217988519543f886182d5f673b770178c155f61b54894ddcd20b9daa44e0ebeaa72ef672bc5b3b8be0058f35a59be961faaddb781ace03bf6201d6848b3618620b0847eae42ff500dae3fd20eaf1d8eb3033bacbd7af1499b9827bc99e1b4708393bbf88844ce1de93a5d9f2c74baf7a628f928cbcabff5c9504baf3d3e393882b7e68c4d16920bcfc43863e3a35f054e113d6d98f6ab8af555fc1b95f24ad7c092857e9858c72de34ee0ac8c5d46bd8b37490a718d4ce935332d044365dd5db6f27967b164be1fe113d744bb53fa67c3953ab5fd35060300d64da9800e9b480b4b11ab715ffa00a0e942030aa6ee2b54179503a71249b59598ccee4eb21481c68eb3560f3ba0f1b46593ffaa669a04f19815181a865a6f90dd8375cd1593bbf942c7095d7191a35f7aa650604acc2eaf62e39523aa894bc7b1c3bc4f3c97569ab81bdfa24dd6579a1648e5a7ff1582ac22a8a38ea593ebba764445a4be8d90c19b8d6e99c6cbd883af1863466e4668929a20b7babb75b44634561e404bac5879bf8f8107cc9854f1c9f1fdf1635444e79b5e78d2ce0ac160ebc796da4d6bc5f125beca43e5c123ad5713e2e9379d30014f5fe5e207b1af15b79f8df6825b1e84bb5dabf091048fb42e05d3ade267678a50e4906dd3c7a1f3055923ecdd51632a9f5186d3ee7a5354b0dd1d7cd2d8e6c15c27508bfcfe265f133504675de1dfb720472408d34ca99a8f4fe64f648032b10ef27b3971617c39156e28bff7619ab87ad7f3348e7b71cf7a2933dfdeeeff8f0d984c00162d6a87d20c75e7da89bb9929975e3ca01d682eeb64d19f2a2f128856f03abded5028fcb925bc613f3b2548922c14380a0a7956c4e393a6468431dbc08e1b3c622cc9fe6073a04cd84fb802faee3ce05b4dc140c49d095631d85bb26821c4243a76a165f100c658a6866b15ac083036a97b30370aa3b9a022d6d01ee78b668f1c845f27c2c9270c70b308667e17605299c0619e345858d99af6b0923af80d220de52bd6fe28a1b65ec022d4dbe22195738d995e3d40312bf5e0ca1061a0a5efb29276dc21285d604fd2b138fd7c7e2feb95c449f29a04aad2b9a597288fd227a9ab2c8099c9d4a360f7c80893f111b1006baffe0841822eb2c35332f2c9c9cc8401ef53d63ca86ed45c6767a0255c4e4b08bcf1c981daa1c25871dc4f5476c9784a041c011d62136409cf61f5f617bf8f297873ca9760fc0472e3ca1f3c8af28bce48689c4a37c7e781f679529040e1798df87af1523f1d7467d80295dec829bced5e79dcbd56c23d5e27f3fb8a08b1573f9f9e1846765ca4ee6e15f9464d1acef3959586b44b1098507b081027ea041424a8919af7b17996c7765f594762f21cf94f3751f25334a83d1e8c715274ec90f2d53ff18e146f9621c65e2bacac5fa1eebe3812cdfd1ddd2810faddfeb7b96923aad4436567655512c7f45366719cec2498dbab486bcd4a917fa3916a4a1330ff51efde8a3b0930065ec11d7b37c1d92c44800ea3fe75f51c1724410ad0a50317927ac6446c92519c3cd9b5d4e524d49e93765ddbaa93943be674188077244411154d49f57fb58f4b51fa64a7f489023644f5b491948abc1681f10d490563fb48749541a8b7bbe8ed609f5572bca8cc069b62ac7dbdf00261acd72110555878040e6e733a1f4b663faf5f79a0468e1567261b6a6ed882920a8cd706f18cc7c5d1bf9fe8254e1dce9733f2e026b200719e8127328affaddd6454b78709207ae5aad308de3cea2da9e3a988d17b9eda953c3a4149259aa0d4261679fc3f1a2a0275aabb20f63457fe9512f74a0231e581775f81ce28169c316f851b5214a9317189bda3d4d3d7e2be6d5cb291dde54c71751a6a6ac71bad81d00e07b10e0aaf9d1774e152564079de378c5f4d2ef1dd623f0582d46635bdfaa5b206a4a7f346ea3d60a8b1363cf2826ead98f24f36dba06e8d7c6f0dc6af0df3394862db18f00bd3aef8f305ed952b80cf5bc33e9ddbcf05ce8cae23297ffd8ea73d177a2590cf10e6ebdd0c91a12c36f87f65d234acfbee5496e9982ceaa7f1dc2336bb4dc8efbf3f905859a23c8c8b3c2346344e1065ca2d80d026eafa1d539cea8c74173ec0e38d72e786f0ecd0244f0b816b2ba99a2511b6774108f07130e22849857a5e6409285df665590d9a37804e1fe8ca96ed3dd4853e153070542275c740c7c3f977b2b1207c0fc1f7d9792696b8fc8080147e34cf9bb05a0b3971fea8b1c1ac7fdb20fa1cf18ab363ba5b00e0a1efbc7f997010d231d6819427302c2b9a3a4ce751208739424a831e729ace32cdbfd056afe63674aa5dc4f32827551fde4a73a312ce2f9aad06a17310eab95edd954116d8a42dc949ea5b34a44e82910dd78539ff9f536ee0aad1791d01b426310622aa3dddce35b930b2fa249085d8f99e4524ca420d4a1c436d1cf54b01eb3da424132b4042828ee3db488290707b295a1e5886bf671c6a4cb8c3184df9965e06f470681dadd56b472093d588da11caeaaededa08d075b5c3d131c355cd812c4a67573b1a973133579c0919bd4e343ad12131c31802ac2f969dfc719ab7a446ed68195e544cc2e3ff59802890baaa98c42f3177ba11a2234179448fa08fe7dbec7f47aaf8d9f7c3a31a6b191238c8836d707031b6398760ac54a0ac66a5694c75ee1928cf38de43eb63eec378e539ba8b0ce3fb75a3fb1c8dca710f483c9dbdc499bcf835101e5392864c70e2596480da980cb00c75a448a4da13317cca8dc916af7401aee30e7bc4f0e5b7bab3a2b485649a627eec62ab7396df5ce76ca528cb827a70dc6cd3f529f5c4fbc4b57e0ae353b5613f1f3974d89545eb38c08736370d0ad6118ab1696b92dfbe5fa1512a86dd9a536d60658a7f1f7474037498d2c922c69f0a99c8268ebacc2b51673ec7cbb085c97af146dd29be84b1e68c20c53478c4fdba3259d5a38c12e05a582ed5a1a18e5ca1da9908b6eba75923f7de73bc3887b1b0cc96bcf50659ff22ee89b43b47eeab364ab15f7a8114c24932f5173bc8086af3647c1fd4009fd0d2e81b6fe1d7960f2d26f6940eb333803a40e18b64950a62e5451803f398bd675c91c04b80a87e3e72373f6a320e922c7678c816d602968b82e43f6a8495cff8d06fe94a7fe8c0c51f0f64c48c68b06b9c40f02514f33d6dad1cc78a9d5bd38472ea0e6d4c6308fe2f1cd65b87de94c4180f1362823160225f720314df9eb781ab9b41253af7d90393a0025b290f39ec288bdb84a8d277f9d7ee1b04166abdf2b74e558967f87923c1ce731f1d82ac6a783dd9397de4e7994ec4d2bb6394bd06549d32c328933bbcb5d2fe81984ffdb92a156d73c70d63dca0f4a5d72d345ea104c4dc2581dba093cb09773ca82719f2bd60c941f44ce14574f64fbc43fec957382d8658b8c1d88623ef9878678a8de53c6d8c90491c87505b1c02d901fc84e75fe0937c9e597b62f52d779034e983ab84476c1f8420c9cadf7315c02d2ae6f445aca4e0e04190622ca496edc6148224a6404bfca6ec688d44383810e609c4aa14060b05126f5eaa7ce313ef0d184472bb42e435ffeda0928007f36dfebaba7ceb25ce5e633f6b972f00f4fcbee307d0bd1d2ff336aa0bedf99b1178434c06a4923777faebe601b27dc6f085c9872e5f206203c628ec35cfe805c0202430a7c0fd7298ddaad7cd6f097b3ea4d16b5bc3cb04eb29d11ac2128e416d7a2ee835a874df080cf667c1d6229002366203a378c6476654c43896b6c70bdbb0916ff0f1e9b368851c5dc9cd95396e3c505fc8a1b1b1d9f166dcb8b617b75587cde84c6a2bb9a03b70b0c04e77938b2b14ef58c1bec8d10a78dd6b5f5863fe45e2d2efcc85b69d1235fe02e7c8e3d580e3e50bcde00076653ecb53aa0f45d31547cbe2a3b5f4ed815f0c65e237791134a7e5916b8ac8b2ca826c957e3f459fa178ad29e67725029210c527624e6144e91a83563ff9128dc1f4bd52979c3dbc9667a52d1c41b343b6e8358dcab16a18cda40536a45f5812b6e310d473cd52a95184972ee8f45584966b0b738fc9e25dfb5abb6e117d3691a741e978aa7a2dfd24cc47b757197d6ea2fcbae98de5cc70dc7eb24fe101cf88d0653276b3d883359f290476c6d9e7f510884b3c98a5aa6626d5fd7f93bdc896d7b7597d2a2bc734946bac77085f35d3ddb162d4c059358d0f1093f2719c36442b27018b036c32d179795dc7457a4854766fe2b8486cebeece1b3e30b7ba2c637227cb893abe39f9638e3a6447b2d972b281980025bae0c5bd410c33bd15d691c1d546fc614f7ef736cfe0454efed1b116394bd7822fa19826e49bc1f1a94cafe57166977a9d59019054e1ac501c54354d9cda78ee4ecca8bedb1291030f38803b784760f7eb54fb36a047a000065c9291ebd54fee4d4fd2dff1d2c495a4f577b085d489de3916bda81199109d312d1372f3b7d222ee0c4889280ae48180cbffc0c602e7ee2b59ebb20a1e8311df91a0b30d5239f8fb7a3050874ae5bb2876aef5bbad8874736d2593c376a936578549e8df3e2750b6b1b795c173bc14efc1823988f23d034a6e7e92677504a5ce7346d94f10b7e42ef137a18d6f1e8aca994f35750d90205d59301b4450b278aa662f2c51deaee9557c85ea02fb33aabed7268bff2f75e853c55c316db6c1fde3c7560b0aa7458024de3350829f5c7ccae53c241ced62c70dff1e7fcc2939a5868728c41a729d6b3f7137403a968e9974319058c00ffcbd7981ee49a19cfdcd32c0e27511fe8bacefe18e6ba9d9c0e3f1e630a82bc80ca7ff6046ebd31824dfe036a569852aae1864a940e6ec87ca0f49df509bcfa34ff6de16b1b865ba8cca686bcb9a75f33bdb87a7ae1835d6084c8dd166366f6b768618b2187dbcab098f0ca80cbb2e0be8677db0fa55b875adbbbbc849deaefdc959dd3bf6ff317f9887c719e8e249cd397410e2992707d770bd22ee324604c21ae495ab90d7beda556a8181a8a5760d1d1a699ab105c102a644ab549d92c5aa57420284b8a1a1851c0b9778849bbe7decd1e6eb575b0cf7cc68b18fcfd3dc1d3bcd344f825f7d917f3be041e6085903cb8188c973e9c53e5103c2bc10eb4133a0bd16d414c27efc694d4f61d45c2131e6cf01da36d3f1cc838b925bb5d27f56930e5ddaf0ca13e6a5fdd94129c3186fd9e438d4b6ec67cb8ec272f2e3727f72f3c2ebe4328cce3f3be2b12756d07be93d305357ba2bd97ca7ec41554e1fc454d28e415cb2b06bc5f707bf4413f9f3d307ad06f9fa7fcf294c777551b7315a2e090cb8be8b1f92548229e1366e1286dd7c934496a9a29399d4fee1edaf108456a977dca0044d1edd99648825712c1888733aa17c8dee388d379d1e94f3da8498c3d5ae84b285b60d6999293b26e144123b9c66b070c38c2ea0fc8037e07350ced12877dd823c2f74da3cc501c10719df506f9b1d27d37886f2e4bf6df3b6e0a038cdb484c9cf6de7191033e84666c3cdaaa84bfe22a1f66fab8865398a0d8cc0dcab974d28d2b984ddf6d4029d75af7f08e808baa5d07c2e51f00c71005835b91ee2b8e805c1a3a126f74071e8d792a66cbca9f2b2d68f02f66b9c0d18d9f4ab939c038321a13e68946a2e54fdfcc9eeb66514759c62ed83b2fea09f186b4921ce3c4b5938fce70e4d83c9e5450d12f826c361a089f9b27f79e5d006cca234ad81010aec52ec6c248f7dffcee21d8fcc7e0d5a858ce14114c12a934573f8775910f904903248cd6d9ceb7c8e0d093ed116145dae4d891ef23cb6f603d11406eb4c3b89b61a64bbf03b4ae7fbadb907c49304d80f4db8d267e789d0b96874e9fc9cb33b2cb925718ef44880163b5a4bc8e229700bdcace30892f1726a1e1599ab0daab4802566b943a6a009becd8700bb2da25f181917c20c6e304fd8701ccb96d0e6bc38d63794681dba1fcabde339631f591b3797e08afbb4254dd4ef68fdadcc14830be59d740e0ddc936f40b998b442081e741082addfa264c286a6844e52e1f78bc72d9dd29e3ffa66beeb0b7c0eb8c4cb6ece2caa27fa059b9932e56f6a3b9aac2320b5489088a172e691ea0bb7371aafe0331c99b1bcb1b03bfd26532c90956301d53df0a0653a9bf004e2e18df45b4f09cb326","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
