<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14edbda0ba719093b5b41cffb020d88142c8cdc4dadb44fd2190abe389aa2d6f6b0adb4295b91b433aa440c2e9e25c871d89b39a2dc56de32e1e6f8fbccbc7cb2340e1cb02c2189badb965c665c2199c5102009e758f80e525a336cbadbee444249e6475a46ee58b9caa4a1745b73e2be00f22d0cde284338977505d8c309c5da3d1eff6e7169d31cd1b278a341147c1501cfaa038662e3fa905be3531f8a01d50ac637969d6213468bc6c853d916688eace360a44c8a9ee27e32bd2e59f2760ac63af55fc8bdcff0394eddfa3f25cdbe0cb697f55a15ab685507df477e29bed98b2bb3a3e5c4413d4a7eca3c5cb00850928a653dcbf52d17b4a970e11565cde25d9013a92257f2534682ad2b657e0a7889bc0c1e944ffef8ce096aeee80be7a29fdae16db0056f696481de85bbd99424a967b8535357d23dbcead5d25a04f4ec2aae114aced3614309bf558c3d4b9fc6aa362253d625e773b37c3875a0e65c6581be1df5128c1fad7732dd3dfa61de9da202f8ccbc2b7210ab2067f0a80b6b07602a73d54b473ccbfacabc232b14b53187d928f04c04c1569c90eb5942f01db40c5639c1a37d222b1665ebead02683915800654892ac71069d8781d452926ab2723fbe39ff01d804ef77c026ffdf31b5e4c74dad723b4dc4ecf77b0892c9209beabfa311bf60b44d6a53be44ba2b01135c384bc3ee03abee549be290a6f33aace735cdfe7e921c20ecbc805a3f82166ef11a566c99ed9ebfc7b225e304de4d924bef0f85133eaecb193f1d03753b2c52461b5cc0bf9c76aba617a15fa086012d82a50aaa49716d94c835cfb7b7cf64a059aeaee57e9415a66164d15723e4dba4a3a15624c7f75dafcbdbc5d006f39cfc17adbaab3072d122fd52f708959c2a6037ceff5e95e878da97291d5a27ea1d608f67382d7954ac6a77d8dbda988d5cbad28deb28900e1222d25e9f4b1557f2446f7632952aa624985a807ee0a65a19621a3840c10ae617c78b69795a1198de93bad69d9d242e423e267c824979b9f89df3dbea409d3b6c00fc4d678b7cffa7f0e8b21fee34f08b9696740195bc278d5ed417236cec723109d766eaaf1adfeaad60de862434b507134e70c2254c59fc436707cb8ee8759b3f7843b01eff986e01aff0e821428faea28640644606ac346b71943eceaeff5baf5e9c0ab62f2b50533afedb7b9f6adb29008a3b4f5c55955331d3f2b3f23ef16942d295b6baa2e0c1f522748a7176db929c7f0b284c48b71fa65e354badb6a60e694590121649986410cecf5f9e08ded67f034b9b2617d981747e361129eaef4f06159d7a1a1be24fa1d0d343e2117d4d5af926ac732e407e8e51671d9a2d681ed6415ab5f09be312ad27f210bb3ed18e96ded57805ee691653bb2ec0c714bb84c77f5977111f796fb44a52d72058f23a53a64b620a74d4a58300473a20e59173d2f1be0847c14eddf86181fb3dbff17d995624525339a122583e1e84378ad68505e6dbae6942e4905a0885bc3d26da7a817de58a20122096a006c00c65c7b67b4621fe97c6fa04e7fd1b7d652b2904bdb42eed034f53faa2c2ec530f9b716745de4fb7cd3a11489cf35a17605a8ce0ed0306a5b665f8580e9c10828573f7dcf5876fe5275966b872078defd9d4c629bc099b4de2af0fd32eb720747a1a0e185df82d4fc02d2b4c9afc77d35cd3d0e0797f95b17a61766f0643172fb418d708235fad27168ab81b293998bcb48e1f350c8fa5869db5075c5b02203455257df22f5417839db62700eccb2b7425ebb80487e5a34f73723194d813dd8a30a94b749f0c7f4a47c9d6f7dec40bad4bb22a7d91ac51f8c6b78c2ca178db044d6cd0fd60c924c19a5de3e3508603656064cc7ef013e631fba742b730ba67c0bf5d5290114916d3989b6601096b118c732dca6054a795fb46b8d6d7b060d093931beed6059a578d4d29a6daa9ab4a85fa520bdf19ce635af2b7f62026dfd1c16440af26a81d1e7b80664e87e139e329535e038442d7aa63def08970285fe396e37dbb9d61e9c2f214258baf25337a963ebc16020f0b49c8eeb40d0fe35de68f148836a40ab3426982ce64dcaefeab6f625d1ac935d748a032ee9f31a5079a3228feac7c50054c8f1c1bdecda5013f4cc654a08c48fd167d463c084f264897164422be7c81bcd9285379f15123f1f0146ff865d071ca9a51f3546028aeb08cd9a200d6cb4f5093378338979e78d0f32beee3c41942fbefee79441fdee3eb482cea247c8973f663eab8a08a3172bda5c2ece766f4ea5578ae5bf5764fbacae66b8e433fc6606f15cb5ab4aea0fc288503bff27624e9115b605762b79906ab80d64aba03cef8cc2899901ad2a18ae68ffa408f576da417b36c48cab119aaa31d5c14afba461bfe897e5f04afadc6054c0b0ae17df3b26a17feca57b9389bf09926ca902f8569bf8cde7723ea292c55a15a7a44502ef4149cedc8194f6616da559dbacb91cd71e71599a039bf909df29b133ce42931cd4dddd7fe50a837df2faf05f426ade05fb2fe5ab38f004529d2b471f97ebd9ed94f1ae81b0c0487d4ab5df63482dd7ac6cfa3f9204287354b6264a72e2552d8fe226ea5f18edf94ee1f40289a0dca5f567f8bc65a1cdb9ddb4ef3c3f0d594accf69d46f705da7903438f3ebcd14efd6a01274c1f8850022c4092dc6ba05a2a0090ab860951146fad548d58fb5b2d2fec5cebea9b50ca48d391cafce967473a523c9ddfd5900018d0c6a438c98601c302733a4e75a99407249e0df1675ea6f36c1495297a27e4b7fc757948d231786d673378ab5ed66edaa81334293547ca55a7251a193c0b28037cb29f65f608eb946ba0cc418e69865a1b71860760e8975e10ee1a3700953215975be4f61c6ec9f2cf487e65d5fb770e62f3f3fdbfe4919a651f67a434601d8d8080a346537581cad85b6a6569f000bef64c96ae9aff2ff064786caab89e0c4a3366b35ac0450c3a35ce366c6bad6378dbe3b93d95ec1419f9c7a0ae8255191c02f17674f751f025766a0458e4153924c4eed55ce87e5e3a7ae5cfe5e5b856355a03abadc264e54ac9ecc866c3b4b0cbb816eea584cdcc99c5b5172f5b13ea8694789b9cdda948d4e8d31cdd022e8ca355b3910ae22c16118b41765de8a7e81a033fdebd12ffd394d6214440c07c38c792f66b7ad6bdee0243d6cbbb1d4c04d507bf072ff3087e376b1af98ec0b104885bc175bd855c62c00de75aab9a1d53dcc6af1010c08cbfd58ed046cf41e55e0dad33d581700b1e9cd8820c0430a1ff952f177470c2fb1280c422d1f2a0b1493e5589344bca98dbf87efc8e466a8d8e453fd32ac3fb5a88e141cf638e42f13da55dcbef3c1c396316822a4614af393d212a1c8fe79febfadf931b87586934d3dbe59f9aa304282af16ed3fbf564132b9333fe2ede7c9173ca8a0a3a6ddab821aea0d5f0fe0ef6a390bda8c0e173ef4cc65bdd2b218c4ccd905d3541ee1beea824d09fbf3b5c80f7e5968a612256f33930bd99f81ced499a71da139d50b3ed067e8b50067fd58bb046abc0399310e8d6195ecab507d500b760e407d5c546d3937d4503da65ad756df0baa12de3c51b25b6e557ca1a7bb2ada85444a2e2666355a84e299815952601d709eaf21c992fe807fb80ee0250c7291229204c65c748992093193ee0e3c882fc6c740539df4c4cf325880d5aeab21533524c7ec99659f91985eab0602d35542deba491f3394d2ae3e4dd449b3a7d5292a9f0404e33efdcdf104bd38600479c12191286cb3848ad75bc7b43c50197de08626ac32ffe33d20f5a97dbb5279def63e1d9f665a5ea9ab7ffddb7f4fe8191baa6c488291f32780ff48e718c2d7c2172c47bf5ebb39d1ef70ac0297b4cdb38a50fa01931971b261404b1d0515063da393155ddca76867ed6a76d7e23caa52281dcad22bb32f1223d97210c5641343180c3b7254c0aad183b125144c92e4b162cc316e89dd98ab2355a69872ab09861ca9e9697d8e7a5508717c9c501864a2dd2da8dfd62739d7baa99fedb3e2767566e3362874a2eca4015f75af1c4b112b578253fc636779a2995d83f280bd1f19ad35cff3f768d15fe6c929b100304216f9f471ccd580bb336e7d15b8e897d16f20b3a33a88dd369e58cbf061191dc7bc7eae15e79f385d98a7ac06401adbde23e62e8b802a0b9c5bd64e88eff2c3d669fcc6c19d8cde08a0478f0c692a45b98b6d55841013206eb7a7e1b0808b8a40fc8503a5f9c7beb249fec752099bd062ab8c4742f837d889d163e1c8476da603d69dd53c152569360f569a67b6c3367bd541f3742d7f1e9d544e8a62a99e8c4b3e01ece70d2ce8f32bc8e0f64b449b59f812db77feeefc2da1f73a67d984d6aaa15ffabd80ac3bff11e5c266793e9d187c368fefefcaeb898100c9c0cacd80498fdc55098630ad07e0035a0b19a387c11fba33f9c81ba7a752bed53c2ca0c9eaa3aa6e5d41e562b8dec18bb84fd83c7d42c9353b65c8fd6728e2205abe7a3cd71cdb77af64f45ee93d5c5bdd41a05a060f402de51a16591459a16071ee8411acdc40523177ef714033d6bd4161471d175f9ed87474fb54375a23156166b3feed851a72c15fc4d1ba5f51c07454a06f4e6fe8b436b4558a4ed40497de34631e0fd16c98c2636cd074f6cc3daf5ca3860f6b0b07b5cee363f435de5bf86cf0ab76eac8900745fee86e661a8e1dc87a21a40dfdce965028007a6a2df6fd1ca6194cbdbc87392df9c12e760274362bacbcd3cdf31f5f2d1f27a95ae7cd076e1879ac5f5a0ff5d5b1da2b21470d77dcf6302862094af39db1e20ca4893b1551d226846511b4ce02afcafcddc637e8ec2e24db4960f575fd743365dfad5c83c8101cee01e718990899a45fe325254a294ced9cf153a5592bf403b55c78c9cc5b368d81cdd1417452fe9343f07d5835f0cdea1e3c7c01087a7713b6d9327db6d95c0d667e45d6914d5d679ca1ea6a4f88fbd865951962896e0fb54e0ed3754a01ae1747d4a37df63b7f2104fc68debb6956090c0fac7afba7c60130b97b1d066e730bcac4ff1fba70177ea5d83cfa282abb51feab2d7bf445e1729831592a6ad271c10ab4619d97a4e9dba7a7a98c7667e5e203106e967fad46579726b5ce584117282ad95636c4e5a500529b13d5da0a656d8dac0c1a4987f7a5137127c74fa8b6b7c2f16c7c2d42749e8b7e9d663b1992c0d469a8549ea6cc445fd7d0ef236694188442c6e6f37741bd0d124b522917786b717487eb3661f71603b4c8648458d9b1b73dcdc35f5acc1f248069f7fb049e069164bbbaf5993f1b2a08fa6d3741386e726c3e39de29bd1ec9b34f80a0bdd0a6d6976cdbd039fb75d0c2a8f533bcc4a07ed6703109dd8954ee22dd01a5afda39fe1feaed15b474922c52853c329662db00bc098d85c7fce3d8370eb5b8c3d83413335f75ef60ea600e7a4d1f9217f99f258b14ff6855fbe749e32dfda9928f4a5ea3d6fb065da696b4ca715d12177fcfe630b3767c20cd458203b21ab198fb80e79a870b1f7bce37b3a343b27abee8219469815c08422f870f13244a6bf43bc308427102ce8617352f5fee92c39e0da5a136fe5379fa78520f82a4ea1aec6ecc884bc8ac68cc2283ab806b371e8932bc572801c18b6b8610029918031ace489c5afccd126b1d19f4d7787599b0ea63661103faf048ddcc0e668beaf83a5e5bd09cd26e3711c57fa0cbb17f09e6af1000883c33f0d54f13ded1cbfb21831671baba80477774a868c9c8cb3536bc84240ea0d795edce16dd158bd6987e69e77bfdb792db44ff33493f0b42766adc9c3f81c55c8f090fabb17e3ebd38eed456ce2a7fa7ef56a5bc193b1bcee459a1ce2597bb80287e5f79ad6a22f01aabb28d98a612fbe4e98083fde4cd3e1dddff68bc333975822dde38bf19d4d4171acd70fb14e456aeab53b9ead8d7f2b46cb68e59d56490a5f95ac4f65c3ef494a9f4bdce9933a80ec359e423471181e97181875e9e482e19f6654bbd696bea325120f16f69a8154e74a983a1bb08c4176a00f7fea24dc9d4ca80997e55c7056b05007ffdb1a6bf5eee908d59715202113acd274e376c151b31f4c55a4256fe1fae1bc0eab7f71964bbce80644ef3464d153117b3180b16bb262ab0732c52118999f0a23f8d9663ef932248e87f600f8f9f3a4d30a4edb54bc350f4bc9025e988e539effcfdb43a7fd0709d1d1abfd9ad86d80a0db5a3d68cf829ec8c0b0e8db81da029d5861da391827b8146a44ec431ab2fc591341327c4c084503c2070e70e61dadfa876de9754136b45d76206e8391db39487a04eed6feac54dbfc5792743d55c798c7d0f1c719ad80ea944a5d5c37f4f4b6633b87f238907785f2a5701f4333d7efc111f966783974cecb8363a9cc2d9f4a7ce958ddb234dd94dbc33432faf0d4e8446fa60c04b6ea8e89b456f3d8659c5a1819da70237064ad02118e08ca9bb9d39d6e4153c379dfb6eae8095b7075e471ce74992590f136cdef07082461fc6cd51baa91420eb478c435abb2ef102a97b6a5ff32766d9339ee44b922e9ea81d3d4f6198ef093454dd8488c9be5aa3bfd011625740f3a3145378a451a613c46c40d86c2c56d28c15a3b5e829e999a226a6bdf4dc575c5d567800839aec9951d957a129cbe01dcef236c45b3f0d730543270c4393c1f0ccda469f61dd1ddb332b71bdbd8410d0aa1545252f2a144aaeb4baac5e932c0a79175764948ea8ef2bbab10a30adf3a5666d9df6630938fc5becd3ed8a515b79700b5ce2a86565e13d420bc05c4df8a1a01fda4d94c743c571c29b92a3fdc36567a95b2f4a56fb9f6031dce69d4dba5ecd37b81c9e0c906cb62cc1c1fc0f18b594ad06697aeed92c1a0bedf6e87a5f9a8bc565d3af5fa486aa1d047c61a25fae7e5e328dd2215461cce720d75808feb6e414463a17c45f45d0406ec1a88ed3ab0c038d583c1d00a71ef4a8adcd841891fd7aae12c4f231286d1e186293f886e84ba3b53c041263c04f1feea2ff9b33e82168891c03b317648d8061a1c8978a97f392d43d2131a9d2f51da6bc4006d05e1153b1564ff8f4e4ff9841bf6de7f9314cc731474a52f6ea6e8569360ad0f45770b12457d8b9f3ccbf53a33143ca18220523d22f3271f759a18c6deea8156d26a45f7fa7346cf1dbe27c8aa33208ffa2f2bdc40da8733720bf648726aeef98a787fe4c1480eebd191c19519a7b5add99f054d7fb9e190e0bdc5bb5d41e5076e675a3209239e6015f50b4ad9eaa2604570ea45c7112f7a12fefd686f6d17e2a731a27a6e6101a0d3635170222908d968c81be726253ddc2fd13925602fbdec07f9f76f6801838bc54e4ed974d807ae10397cf467defec3ffb74f4f5e68bb5e4577e713138c07cdfac34813b652fbac378c99aaa1511c93b7f3901e5d20818cca66179410b8986be0514ab05a8f286dfcdddbd0b029d279bc1acb55fbc22c0ae719404cde9718326912dc0f4e4c5bf9e36daf60a70e5dfc52299513a6c0047bda5e485d001f6f7c5e8a3d50202334c2d8e6787b74492a41e7fbf971fafd58b5564dbe8afe60ce6753e7e4a2434af8cc71e3fb18ec8a6cd99ef6b191fa9c5c15390942e12c8a53e2114d9d69c69d7ca5582c9620a593ad00b1113fc6c87d7a8e0c7b59d2c9ab88f769a692c79b8688b568c73d21cfcd5b0b0d908a4e044ccf407116a0c96f1a3b858a7d9df210d169cd7a4d4ad85bb51c8fd0fe14411cd06f06e94766502b24209eafaee59b3e4690c36feca54b0291267cde82bde0aaf99ef5d2643912862c36264f288c8e3b3980c0bf0a458cd538380f747fdf34a4ce5b2281c9a9184b369c78900cec4adc29a84ce68007f6ae730eeb1edef8f09b40ffd0ee2ab2dc0a138fa31bb23178442d15367212ae99f37dae7ac3f1c8abb895feb63ef911d714682a37170e55c8868b362910460082ac7ede26b5433c5abb27c13a85296945faff5a2d0afdc15a0469d7580fbc0559227651e2fe89030954866cfe63f3f5a146843988b8377fbc37284d43f82e5c4a9b6c7b45c8ab2431460dde566dfff6cf349c744d3c0f0be8e4405567bbf1153af769a2afef1476139a20f26da9a6cefc3c5945821d5fe7388f8f5bd4a9c7e8151568764213dfd11a53db8c54f423d69a0eb5d17fc2cdd9531c4aef8dd1729609106edbfd7e2273d222143af015714e87312b9eb0b02fb122a1a1845a2e4f3cdd139988c80d80408cad6df709e3c6ff36f037d9d7688393428c19dfdc9da8dae5aca60bb85ea6563809339d01daf3565d77c3e24ec5fe608c44c415ce95192c41185b1cd62cda588f047c6a55c95aeb53865024bb7e0ac7ce6a5a21cd590d56b572a2054145cbccedc4286b5c263de273f5957b52117127c1fe8d205139f972bd924f376de31f67698d9b109348b8641ff8ffcb8882be8ecadd6559ee70f9e63564e8e6b4bf6250a09d3e892998093388b5dd29a9b681549347c8060c605ecf5053833332c96a9bd56bc3e712aa4a699dcde8f9a06017b43a27ed514f19a5d8719ffc55ec5984d7c4d03038e794b61566a8f22cf74407dd9ee8986c5552fe8984f83e711cc3a7f761217ef0fb7f2040131f9382c9440c423f3e3e63a8bc9877bbc57d644e7569a824b74b869b8f492cc5ea15c47486d85eaa686bfe98b3ac5ff3be988f3e5fd4251ae5922b179f2011480d8b7a400e25137245c44429499c4a4ee3f56d4c73fc89507ee1e7c8f9f773570c35c7daf64db473e008b45640d89b0d877bf8fd8082dc779c9a0f8cbf8f88d5c64054d372834bbfee7e74b170566f1156cceee17583db458b39bdcfa9a0fe098a233af7c9fa3707362229ed9c218ab90a1d0d0fbb2712b270ec2449438720ec0a256be8bcd0f62e4681e746be3d86fbd7bc11a4c3d2d6f5be6c1a8d42b038f2de2bb92a3286f41e646d796252d5f576509aa991780d9ffbbe0d32063b20aa9738b392bd583185c58640ad0da7920a6b4698bb31568bfc695986837c7709b8a0418f3e76b75590ccae18e1a1d499d8c5af83c7f45ca6aab4add309c3db1066a99a981383749eb9a17eae79e861343b10b4114f1494921269aa2d09a8f1a43aa08b2e5459a7928aa1b13d841746d0343d4fbaacded528ced34e41991427fc9fe5bdb366bd94e28f4d7f548cfc7440fcd814643c54190e6f2ae87b6f9b2d0ca93a1717b41c8abd52d689f130509b927a9372c4c8204ed4fe0ea16ceaa4c98f1438d90bf63b8b72ddb42c51603cfd66695b5e5ae1f75f535b704e87b4e121b5c4e856fb439e5a8246d18ab7063b94185f3142631b41c15f4f8ea6161f83ab28c07dee2f0ff07202f923d0477d0ed9b77e89c0fe3597e5ccdc01aa30d10c18f60d9da5f0006b7523787f15788e739a200bc32dda65eb00a2dce8f1fb67042235b4d51905c9ab91a461b0bc6358aa629e0e88949864017edb11cc34d61d0bc0d49c7af7678abc9860ecabc5c5b6b57b40e13a0374f8f094376cb3c5e0d4625e0e45e7423f4bc505a86138af87fe6e6d305a61815c10b3dc904742e9313d5e026f1c826ff285549448aff35acbbbdca88082375007f8ef2f52c1358617cceaa5c264ee6ea736fbbed87f0469730de4767d968a23d8ed6bfc5d4dbc232fb1c7deeebc93b4736e2bdca1f9c2e75c08f5096afb16a65e8a2691aafb5f11f9233e82eb27aba6dcc47fd75dff7d3e7cd238628fbcc08c9c7809ae1ab81e84106a2ef8c3376e2072471a400091c855b03564d22310d6516083fa07d5a249bbdfc6bc0e3df1ca58cb1bd2b7460ec933be6c60803f6dce965a4ffdcc0b4b2e776f9c9fb1dd1d2267d62c97f3f386e222652800a03bf590276206022b0069dbf17d678ca6d76fa6d48a256311b9680cc687f50b0a0032f2960b0e8f8847dda6362889a4c6c6a4507bb5ce5c4c1e411a3f35712afedc1b37b4ed1ec52dadad57926092a87ba673333c74f87f00639660fcfbee8df66e0d943cc3301734b4f912a7f3213c9956eca9fac79073e1d0ca3444f1e3ddafaa295d1dd4eeba4054dce4fe5699b1ceeffdc11fc53de1663ba0f2f6e89f18cb406462045536501a45e3bd503e885dcab49d910198f3915e1b5ab311b1fbbe94e63d39e6d3cb2ef170606c59503fb25d143be7731238dd5d0b3c8b262d8b910f0ae39f14ada9051cd4b1ffba066d92e69ef3f3d46facfa2ce3573e19be3d1c2e510eabe672eaebd6152acfdcd8b6ef1323fa2c3e7854b2908ee73f9fe6d4f35d22978b3bcaa4c7c97d5b6c97f36f5690b172516c6485c09d729643b96f8bbd69af43153c724fff2404dba9629f7330e489278736a253492faf115e381401ac5c9f177cf8c9993a4256c4694f6ca01a30ccdcb8bfe76628c8b70168f7b2470618a26ea5035ca9f3ca21d4e655e497a26ce531f07fd4b797d70a09fca7cb55ce2c75d870c9b45502e4928607d6b6936c12bacf0be33b35ce282c42af84b2672c07d91f63266c788bf1e7621a826dc591ea98d203433a76f8024fbdd954cc97ed8168addb57ea69572960a53b0dd852dd9faa7f3b445ebad6e4e515859ec17399ed3a5ab22f9737fdfee99721780a1eab8157d6db2708847deddde2d3540a687ed63d091ba08f882a62c53f89ba3e45a4bac88de50bfdc25a41633f233eaf0742b56c97e1ac7688ead50dc7cabe5a57c83bd717eee563c1b1cb6fe854e9698e10ef3acf7727b892c1ad886319923f080ebb5b9824bf43c4b31585532ea21495c1ea70a65de0b1f74eefd7ce330843ad98bb097ac38df38be2c79691cc76bc1bcd5ae5cd0f334186be372771c79830bd944e847dfe8476ee6d02b035befe328b803e1fc31f0675805c2b501737b9e3623916778f45e01e4625efe17f51dfb1505f2058c3828d9d591a4a454b69aa24435664543aa1f4dd9f91d9de63de3b00e281fdecb4996d2f65eb9cf5a612b9322d68e96d00ae405a18c3b9cdc0aea11f0c9f81bbf53a8faadd4c0d03cd8213f7891f8e1eaa4657c5dc3bed610084257ab2e3e730b912602ba6d5f3bba216ea78a028c169f6d0fba1de40d3425284e80e9f96cc9e2706b0a708af7e964485c9a8f8e0b5eb39376eab2aabff4f6ee776d522531af85633a5f1d3dd0131407811c3eb97da34d01642c7952115d06fa6c1fb37922d13589fa70b9a0722fc9a45651b2b10f049c9f3949a86110f7a92372db3cc44442707e78811cc098ca1d45bbd5d63f1e3d4ae0e5758fbb2673b9a5ae51efb56dadc8877ab8f572b1f8154c49d03bfa84992918e38ff60690e82a573a8f94e885aaec198643e894544ec70caeda9409682558c99ea71109f12cdfd19dc81f323a5243e122e1edf8b021f769a518eaacd8b80918042ec539b52a7a481cbb17ef1e8fc72b45af052faca41b22102b5d37605dfece16e4e2228ef05dbf37b4a43b2290142f6766e12a8c4bd41e4338b5a7ee8221382316de998bb103f1d49898a66b18a6eb75ad4da2cc166df78d38d88e82fc86e3a6f902964bad59d565ae0909987124b5d1d61cf0f3802268e86e2d2b883a36808d39b830934f4f4c51f1683b362f8c255db007cf7c3fca58ebbdd8d89a1232ef39902aeb215cb681665c27b0637b1cd16e23ff34e2f11bec740d5f135039c1590a00dcec1842ca1543bd14483d2ae86bfff9b2c54671ee7e4ce91a1849f13e68f6db0041d9a6c48ad196718f2b8472a64f1bf77bb66b9ee16c356ec3a93902a449e4177056fbb16b5e3f0490df5855a8ae7dca0c3114cf6f19bf761680360b0686fd2d2e57fe330c1e335f3766ac31176ddaf8b019ecb62abbc1543460bf22226e1200c6397bad1b5e5805f8bc8faf818f9e044c15b1bad518d6c24ef5195da339298aa769f03939dc03d6ade7e8f62d255ccf543765859dca28ffe647e20ca995232f6035680ab881f54b8bf39debf5307d95443d0ed8a5fb9567535c16cf7237acc916c2719ee64e44180457ab371b42a9bc4453c6013cdae8f809f0b9cec6577c9d62cf23e42360b89ae95089ce5dcf4b4da05528bbc7d38fd9952195b7f928a116271354a62c0a801e06b39ec07562d499fe1dd53c9c76070cb77f6aab245df23ecca7247f5f16b7f159504b1225f9de64ab9193b2d1035da81f4f14d14044701c67b5136ca5980c82b7a21558f382c6468d4b75e2561aa2a59d3b974e89ef3bb192aa63576f61c889c7025c2141a9bf636fa1e727bf3bef81650215a5d1db4b5edc8a4d5fd4e7e174baa9bd0fe62663ae19f8e34bbd197d2ed15bcafe24e5df106dc14004f53c82903f1b8fa928b67c693e8cc8e9b090228e43a64b7d3ed16947d3e66986f60016c4bc81ab531ef36bf605352276bb5505103de240ccfadf80934cd340a5803b6d0dbad0558b887cee572d4fd08027c6945e2c095ad444e00318a9d390ea66f5c208c281d457e1ae265bc93dc852e52e0d2fef6445639607d5429bb675f58f3d34cb46d0934c8063d0baed988015679d106b9979a1fd49fe4c75f9ffda98da6320adfb84a7e64d5aeec279ba723e08f966911193a4b664b1aecfbcccd45b625e20f4f472e9e78c81b6805b8e59978691340ed985a187380049c86fbc4d3c45dfd2e0092f6d1b1359b304287293df5e04b18fde65b25a9a005a82337df46ba296314db341a8ff9eeb9dbca191d72c1ccddb6c38aad679f5619c948aca9990fe612850403ab4370dbfc7a631d910ff44047afeba339a0567766ae4f5ab7152cf50f947823ca101f6c1812707f4ed2faee411e9508774ee3a03567e3b9c5a08dcec02604df58aaa5962cef09e671b6225ca7067044d066a66c483c43c862f70db735580c012e7a2aff59738b9c1c32d09dac2659c3688d7305ff21aeace462988e7cd2749fe43515898a4958ac123276f67be71ef2dfb0c84f639a4580cc3beab9d8ecf305ef72a150506de0865fbec7bb67aeed590759e0c64445dc2321e15753eaa1c171bb69658dc375e7ffe518c617e3a583e1d6c6d7fb915df9d8d62858cde2e6bd78cfda13a2be4fb595dd8c1e65c11ead5ddd0037cf1e1a4062a2334a214c8c099b87986a598449bdf1a5dea03167760a105d981ca0b473286fa5d2fe916020759eaa595a9383864aad0cfc87f60aad8f2cda431c2b2c3ae8a9df95706b68d675f536520f7191e448d8da4bfd530b83abfdeafbddb6536202956ae42594e0b18e340822f50caffb939e1c6399672b017858a425da69f7f95321aec27d21b23b2507152b2dbec997ef463e832246d657c35fcc4ff4bca4072a3af9a84d2b819f27f49081e00fed2ec43dc249f279f4b4d17a2c1cafd8d8fbf4a54021c88506192eb60e4a9792760ba952ad28212b17c8edd4b78bcad7452220bd325f074c0078f08a0587d78243da414c7273ec136c3fe8db6c42dd02faec32fb5d54ee3145bb70e9f87df7a1d3aaee809a27082aa561e5d5839dd98110e7775ef98374cf75f99e191e8dd2549f38c7c29442e71a01bb73059705fb2de44d424a2bec70e7a2601bfbab85d3ccb064bd27bd5426a584838da1f0937935b45887718530fa500a50cf66e64511270296a9359cdb7a1e02a5657974a98e303e1d537111f329a3e2d682d5992dc8aa5a6210b64826c1f7d36b21281cf4c2a28737614f862ef6537e6b377c2eeb7a60403e44334ca2a8967eca15a9d8c33a5500b1e122a5a65e2b2814e4cdc8b1d5813f77fca95a66ddb8c211c564f7cb95a98a04565d396fe70398a5ad3dd63eeb06dfffb738eb9ffc89c6b92ae7131b2d8627780273b12aefbc7bb5508b2d8cdfb432c97be66049e6303c5d38ea7b895f9d8c16bb3ab31548bf936fbf518c47705f9da420368cb66b476a72d107960c777ae01f9ed4737f3b2e8b79276b4bd95c168c0836b3ae40e0db4820e8230c0ea79fcffd5b74daaa1a249144db2f8e8aa48fbf86660fc21249598b2e05236bb0c9cb643f572db356108db6c9d9e553b8dee3d065276799b74dfb816d0b3eed681c130ec72892dd111e175425edacc005fe226f1614bda0888acf1768f6f89d9619d123a9fefec9104f8f353ae4f6a836a55759e19ede47e53e0faafad0fa456b72eaa515ed1f66a5d0ea16ab07843c9d2e2d2276847a6768c78ff4c858a1643cd46a8a6d6b4c287f7a810db77efc4cdbdeca4e9e7af5a3f0cb1c3c1b867d0ad8338a0e78561ddc0983ce7b9e3a83699502da69f175a9ad0eca4d0614c140acaabdbc65ce49a6e58a50370e4744614c2a52e8b5ba8ada307a32bbb06b8a351457939f8a2098cbe0585efb13a20169fb99a2eb67f27983a65c6995367b4781100bfeec471fd3868fe0f483eb778bd7e3d25c0853c3c07d9eefe9bf44eaf8b5bc873e865a93fecc915165c5a1074cb35dfce2a5a648f0053c1cb7735cb367316f770579bb962fdae5f03f5b0041520b145b9b1c1409ccb54b3a3622b8661e248682ff42a731c2a677c0f222107f8e269a4e73ec21b0249af95562a85793fa2880615ada4d796c28bdbee002fcb2fbf8ed0d0bca093446e3164d253e7423e8ab28c5560ae7ec9b09122dcdc317d79029bdc80f4bc851124d940a24812feb08d1e8c10c7b8df7bef69bd15f060e6d4a092627242cc2e9a68349d9085be05969c925f9c7fc1ad115885ee14ff9b1a46f5a8f05f0f853125b3271bb2edd349ed06ac08242a4bb05e06fae318a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
