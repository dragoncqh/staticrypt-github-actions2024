<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58061875edfd832e277497a48f3bbf3d19fb495cc48c137ad8275d1876c74ef50b298e71406222ce978366df1a2b3e8239f545e555ed6022a5b2e1bab9ce0a5e4deecffc1ac15cd3c5a1f81258d22c16250fd61565dbf92a53edb98449721c7cee402fb90bbdb485eb6b7aa1538a866c40ff3210bfed182ec7031fe6ef628564a901b6b0a790d19d8eb1abb024f9833a1b29cdf045b0f2192b10cd5dc8ce94ba1fc061daf12cba6dda5f14429a13448ceee3abdc453a59825dbfd4c6224682b3de7cbfe5dafb1ea23b4fa8fc471344bffad889a9a3e4730ac3341bd2318dade69ad268e4ee75e7feb69218db76037cbd128ae06c2bf25f1be068d9f809c294b9c3d4a485ca73938d6869fbb9c250cf2aa44b0543886a407fbeb198655b5eb26db44ea57281c9c91c1d110c3c8fbbd15382cc789db08e6e9239663dda57d1871643c4abcaf515a12bcc0b5d298283abf43019762f1234d724e0f01f2b6d71335959e71eca696b7b1c0748c53c6f88337f56f3c17260fb22eddf7fae4d66602ae928fa48ca516e30033f87803442a1965334393b1248db8a6896b06934fea575284ea85a1630ccac43be1b46bd8eb5aa7d9b6f7f6a2e09876001d92dd3afb099ac192f343f1af02d016b99dca2c3aa56bd452cf6951189086d8ad15cbbe4c39571f7ace97f69ce2f6936d3735898003c9210e0d596aaa5ae7e09e71748c3058bfa8e47fecd71e7db7f7105940172ca8ff7333f6efbf1aa230150fb569a25c530ce4eb49488aced2d152162d1881cbc9f507b53f3830a609aca33d72d24175d978374e6c359e9d349f2cadb62162a278665f9390a8cb315544a9fca43e3590217654d85d298b9c37dbe3876130a1beaca8adde8abf24806c48adf5c16f15a7801767c601a20b15d1ba840ccac02e66d579c2cda1a04fb548abc8c4a412f678bc862f61fa7449d75108b40341ca47e37bf7cf8a9aa6c0fb427f6184b631aab3e59524b3df9fbe2cb2c261e55389a52af61e5b0164b56f9f57491a7f50a075f1173974e7965bb21b6d93f21e1bb46ba6ca69ee8851b8d58888b3863e6262aac9b09d6c517acfcd77b5d8428b213573e0fbbaefafab7c4f6c698b6e49d926dadc83fbfc5c20bf6198490089fa33e47d0c6244fdac7d4fc731e263acba84ddd8bbb1bfc69940d533bb3ce8ff4e13ee62e0e3cea9bf80a0313786123c8f2abb2303bba8726c769801b2c1e2b9069543090513d4e875590bd08f18d63da2af64730425d531f7739566bf63902225bcd7ff673afbb9aeba26826ab45ea53d0e0afd0d136981832fa19179105fccc70cfff7ff51b9d5155c0de193254cca88be169c96ae02a796650769e225461b58edc5ddeb40ded2f82b4ad7f7018afe8f786edb6a4aba0a2a44bc47f303605cea9f7faffde59db11cd5b58d6b4e72b2ed51666172e9fad81f0c3fc981c634069967c69734ba52e76df88c9596cfa208f75ce74bf58a6611dd8dfa0298f17c0de4564eb90d3e0a6c30ea2992a8d571be8e24b1ae97c78f3833f59dd7a5c6d0a2bd5c38e28fa23e4e9173906b588631f116b3ae88af27823fbce8747a4465b9daf61262c0fb11ec7bd1aceaa898301432c83db2fba49afb6c2187841ec390a2485f91055392401e97cd89e4f29668da287252998c41d5d6ef5fa099f6ec32e03f04c27b9b10f5e8c96c38465c9a6d455c88895ae7fbe7c0cce64758a9a7c18c743222134a5a181c37f186667be38a2231f90aa468f018c3c57d8e9ca4c952d354d0f23ef5558f2d33acbffdb933d3b373ea45fee7901db3125e6c3699e295af76e4f6b7b258d867c010688e17e1139243fc48101e33787a558bc13346024076ff62c2d4289968756ce07f7c42b0ef44074933e325bbb90274622ad6f576408b0f29c4fe4ba1bf62bf8700a6b352c3616c4f93074154f8004d3df8e131a8e69408edac66686347d77704dab39da92699f0ce77c52dc8d51f33ada3f6d84eb24072ca9c0efb46aaee2f8487ada4db2e5f521774023a2a8ab5bc1a08f2b2e9d988e7ca6596827f2ae3036ebab3c7331962a0dc2912bfc16f522e9f3bc4f467183c306f226de309c3afdb991f9fc47f5d46e92d9528d060ec412ec5688e6768b56343f5205f23036fb567d5d66b7b736b09c6bda10bdcb7a0f7421a8a47a5f0d2dc8593f5e15c3a4ff91de6d1e5f1f0794693f10c7e62c4e7f1bfaae5f087f2cf50383f359a986539c5c46a348a6130c65db97ea53b7465b320c0fef161f559b1747aaba291447fb0966cada64e79b0dd5a5ab05ecd300d009ab73e49877fb98d9c16ac3ab0d5ed7f21f9c2cf63d7a68b68a93818a14ec55d93dfb35d953c6e05e30618aebaae906176d5821ec6cde1e5b1a274b561d776198f90302172e872c3ad34de1566c9b1a154904f914af030bd24e3d09f90c0a84aa9412b22cc5f4863d0fafe5849e592016c409cbf7390c1aa65e80c55b69bc40bffa997079a8478e84c7f4cae96b3430cd560f6879008b751a35263e2fb46724e4234c62440b8da8249fb7d91cf61c37123d58328448b1dd82d92bdd317653597544144c55bf8af2c7e5f7ff68fdf24b0cf9045da87e801103349d5164b928bf8ba7c0839492306f6fb41eab9a8253d34e26c130dd07a2525050f55e968f821accbbd542732874f5d3b1c43e90e45f7f6f851e726656a988906acf2291d5f07b227d82fd84fca9788732dc7758372bdc12e1a70e546cf90408695605d5934481f423ce544ecf1c72e967fa8ab73f2b27bfe19b246f2a8f34ebd167775ea393f1dbdfcfd2a8b8017550d6bb708c69930fb1e2b5f55ce559431f3142c0771b5aacce78e28f036135c55968000e52b2d6f6b4debcb29bf2ac2d56abcaf658ba96df1d4db5d2dbcec2f7fe0af8d0e18e5f304a6661ebfc0e0aaad313d26eacd45366ee81f11d81cc549a72975a6b9fd5e5916c118afda9bc28a1c592a84f64d15bd5f1e08d8e89cecde708a648aa90b5e6462e25e09c1270d34a0a13ff7d3958f0950a6dca59c2757462463205be1d90c60f888b93247b6b3485b3ab24cdd50676625d8d5ec43f5609f10cc6c8154256e0453db350e41dc276ef2d6c4609c5d04c33e23a0caf274721f35e721fbbd7a983bce57b0548e32307d325d20f15e2d22bf382771803cc04dde1f2780f5c624c720e24a751046752e9fbdbcbf449bb101f7110e23eae4090ddc73b0c571027bd36061603222e525a13a7562e3620285e74cf9bee1ac5d9c98214273e07b679c6062cf750e5edca82538e8efb8689d3985efc16a279194d279d6eedd4979018a75f8fe1fdc6244d81d288dc554234a919f111aef91393c25f8afe02007ec9cade94e846df72e75aef83d2d5d962f435f3626fb70b0b2b43fd6d1ad2221bf599b4d22d3e67dd7c6f69f9f7ae58c30134dc3a52368d638161cb5f9174a75927bb334d8d5505b313f906c17bc2abb356ff36c285156575bbcb492f2e3de7dffb5c252334019c39b6c191961e3acb73c5ec5ec73d9ab68576904220e597811e4ef96960431b51901aff1bdf0cd117bf33b278ac2fe583f384050fc387283ab23ba30d8010991670aaedc10a92791c08dea73ece96391ca0519b35963e949afc86fa6e83199ebe0a82600d5b884c587c1fe0eef1d68ba521bff6be175844d5506d83bac0f5ca7d4fb686974c03219af586a1cec67b0ed05cb889cb27711b825a2e093be7deeae93adaf76e59f5e49cfa2536958709e77517b7e300d597ed0ac1779f669ffc423291db26a3305e5cdc7a594f40ddb1bdce056c24f51e2995e852f9fbc6df5ca96e670c2f7a7c1467d7592f89a6dae4f2d1693f4359456513c5ea02c3af4f9ea827da5908243a8718679bc9755045a5420bc04c6e147d4b84f021f513243d3591ca7b22a5292cae1daab2a57409dce9329978e67f215c37fd9a64fc881737ded5321ded8ee597dea76fd90ead90d14ad4ad5e05bf570d8df38170304462c00c1f3871023e5b2f867915ef5395caa0c328d1be61b879708765cf4d70d49b4a5ee73c93ce353653c6e3fac401e9d54c5aeaad3fce78b9ccb3a2e1f17c5bbd756803cb5ea2bf3b526de9b9a6dd8f91036b4778440ff4c4ff7a1599de8fa29cb19a09bbf3f2931943c9b9f9155c15d81da04c66beea54de9500d05a745ff1a823071228529f625e98b041ad37fcd0d9c5beb94a13ec3eb5e22d958bcb492b5ad7702b45a26ad86d151f80f93d2361df22dc2b3e1b5111d73b6e4b3fede3784757d535dffb58aba542074df91c0a640970ef25870eeba3df39fce39515b6fdfc4791889f687fe6a0bee9e24838c2437f16441e979ee38d871d42812f23389f7bbc7a6582c79390bbcddef7f54874474e487199ed2238de2f6b462d70b48cb5c6a26777676eeaa0ed280a7f816f6ffa4b2b94d1a08a8735bf5f8d88ee33c2865dbd287e156977cbe9f6ae7149f85eb88495ffeebb06db1ef8d7f85288bbe0c3b38738dd29969da8d5cb8bec052fdb42eaeaeebbf6a47bdce8bef0d9ab2e6ef9ce553bbecc7be49277eca1c3801803b73e4e0898fc37dc669a38be668cc69a4daba392d8e976fb2cc0527455a121761e76bf37449cb719581dd312d5203ce82befca1f2647edd3fa8737c89f404895987d45b2de464056fe6824c7ed2bdbc6809d7a1550ee836f20168d4588d76a353372ac6b9bd998803961401fedfbb24b18a070334e0c1a28b33b286046fe9debab5de3a46ee6611d8f3b189a7d7b0efe2b724563e1640b457caead7dc11a56f3641f624d4736594764fb8d38a3b4f5a94ad815822843cfb30e321fd137605c62c4d77005a6e2b62894c57851a88b6cf837f8c714bf0358cd498db2907aca17ec55b07932efc31b2f4d3a92b4a90d5e0a46c71a2fb9909ed114002676ad9c9dedc1386769e489239e39fcbb392b2485345e9338d1c09a31caa424b01c629dac4c845a89bf5c130ad30319f746ad80b5df569b1bcde6cdeeb678a7de26a67a42682bed4957a5a74cf1c9f9c19c624f98af849ff441d799472857fc637c3a1135b289d3a5b36141503bf98672ed887b23b253d4b748e7268af2942b9be2fa9040919f955dcb0ad276f36d0081fcf39208088b9340ac74bf2c23ec232fd92b5219db305aaec45c6a714d5518f65bb59e12b08809051a8e89b9100c9ea1dc3243f645456ef5fc58a580b68eaaff6035b022c65d788bfeeaa6d6d1174d59148de9e4c5e5402a12b02ef25e4c23d31349d0cd83f63e1b360cc54ef2002e5c278310c23a5d9fc211832366c0cf7883ab9b80814c00d509a6d6c384a35b48cfde4abaf197e3cfa4145e77b9d164d94bea414b26a208d56c11fc99a4b078e1967164b51f533f73fbe709409c7612cb24bda8ceed30ef215ae27f8b6b1735654abdbacb66b3485a85d40df5436e1ae0be5d4df71c42e2def5f5449c24dfab6182e317b0f3649fd3adde20c8d77f2397e5c903d70fe535e9869e6ff66e1a3cee5b69060b29f241a825291ffda8d99343d97b8f5bec2d569caef472c412201b3ccb68109badd053a0721b19be6b70ce75181423c0bb837816f927279dcf47939c81691beab461f5b92deb8b73880f711a219f80803df860bdde7256e7f83a6b0dea91c5f32dd44cdab3b5767437c807474961443b62c64d236c9875d416bdf90d6c27ff8bbaf09b8d5884ce8f21c71acd6460da15582ac719efba831921151e4ce0d86976fadea9ce70fd7faa4ec8df55f2dfdff7238fb157183f552f950fe3276313474f340f12b75fe28a7fb3c1c2ebb021e0fe43467eb0ab1e9039d0ff0ad56a017fef55167248a59a4b5e6104ef3c48b53d757bd4d635eb0b2256dd5b9149e19d5ee23a92d6b38e93d01a59d0184b74bb9906d57e529b0ae1d6c248082ff3004512136bf7641658f25c2bc7e615ce328e2b45131b5969ce4b831afe805c65b7b192bdb939ad2b2e8d0ab137cadb6434f12e07c2cf5172bb66cee166b72e2e0fd233459ddb2ff5ee97ed9ceb15424f943166b51a0383c828b280627dbc8337b03e428cf7d2e2db99345498f9ee90a30610fa3bf516f4e727ac39ceb2a241aeceb923cd9758e23ff52659aed8b7210b67f1f84531bb2fb7a47d6ca00075d1544178f6c3c107ac890775091c2590bc46f4291ad256b14db32a68c264c0cb99c52c11a6b4322cbaa4b4e4a56ed2a2ac5fc8c49a0b446e836bb398ec6521c837bf5059ab6366f2e059e98f43a75657f39a8a86c6b88f98cd63df0ef4b552f0296fd8d07b3c95ebdc7d8771ecb5c5aecc62801ff928dc38ff04a56d3401421f1cd47807d938299519b00414ac1b1cbc4ae01eeba71ba0b72a34291d990e0d480f6845ec1971de9514aadb6f880140b759b0854d6dfc4664f6f04f064bba79a66f479c6516267421d9123df0ae3a2888bdd5a9c7f241f0253a1b478fa35dd813199f940054720eabe03b30e4fbecbb6f5b018eb9c87d703dc1d4f44a29cc0de72ba0fd1b59f76500d75f79ae4a78b26f4a02daffdd70544b7a082ed894132e41f4817650b6bb5b0c5022095da7a806a606bb156d574a443b1328650b376116e2e54bebc14650e063ae63b84ad8f4de7561ef0db90f63b6dd47c6d7e1812eafed2530b949ac8af655cc178922922a2b04171d9dc6beb597e2b764f776d720b79adbcaa126d7f502996fcc3ef51bef52862ecbaac7551ef75f25c3dfbd5ab4219080a999864aa72e0495cb5474ed939520313af8f026f006fc0fbbd29cc261a8bff82c0f24c8f0bc3b5d334004e5e22f85a84fb0162666ed29e31e0eb6c654a3d612621cab3fad1914dbece03581b505aff87b2ab3806b9a86768c373d40b6ff77846abff902a48c332b54293845f96d947fb99728a39326e398786ff0059fd18703f37487aa532ce39469f92d20327ec87d2ca6a6233c25eee88160562a095f76d7314656d635fa9d7c55c1a80b9aea8e691f8345e4e7810665d877fa5e6a375306ed4134940ed252b89aad1ebd584d8e46d0555f221005859df8096afaf4a1efae0e3b74e165511a0a0fa15805066c45197f9c2f04aa3a5ad5fad6b797395c64a63e7a6b36020fae18d65f293959e7817c7997f8f9a7646e9db1a778cb2e765d070d6820a3ac1ae80d84e3b722806d1a2fc508e73330e0ef8e09e8afc32c915c4613fa3e55477e29f3157919a675e25b9af8e07f60a1564d7b34ac1a214cd7396d895d6f01e1fb99abfcbe6171b6226d0ce9fc84a06a773995a3a8f4a55172cb9cdd37439983f7fd89a7786a3e74489568c918a6fc5d2120c99e08a727106f6c93e9dc9f88224a1333cbe219e0bdc6c2fd39ce18ed0874d5b236dcd2e114ec00829e2b63a0523e444be69db4814398e9c2204e509fb08177a72c08cca8f17ab920624a0beea235faeb020e3ceed90afa96f855a0faa77c668040319d29b6065bcc071e7152c53c23194fd056ba12995a8e6ca2c05b542081ccede128e61683f6ec9546bdb9bbece24802453e69e607ff1d2d8ceb2792c82a9541b684fe321e25aae462efeecc6fbeaf6414b680ede13194a25766d3844bd1f649278c1f4622c05841087d44b05c2cb8dea420e3aa311c350d05005ebb72164f5d0b4db24b325d04adf5de1e46b4c5498fdc5c84dac23d6f51e484f8ee7b8627818eff966e7363c12e2d80af19a62c326ada04a968c943fd5067c3a7ddb54b9eeee01f8f5478317d97cb5908dd533ad874aefcd4b0bc6df643fca302c506325b7f706d8a0b6626f2138594e6cb5da68816d6b3cdc258c03503853af83c4783f45e218ba203d01576b516cf074e9248d5a93fe1aa371a769d50e81f79680b548e707f9e349fbac4b9909e5b66f8a91590311a53f92992ed062c3fc36392689906a7ef60de937875252d033ac0f0462b46e382f0bb98fb640d6fb4a5dc802fb7de0443a15f97f24783deb8cafbc0f0b763b7a0a2c3202b067713ce819dc2c2cc84020960365756765154c96dd1ad286efc2942ec51087a7603cdfc16da21848edf458c71a4a70ab374f9e76829c4fc3420918d0f8d5c71ef518869190f5ad16878aa5b06237b23e40b09f2f2cdac7e745fc23726004fb95a1cc7a0af339b1f809ec03baed9216ce77386c6c59cd13a9e0653f2988e4d0e3a2ace6b121ed32149165c0060ef1ce713b3ba5157baf29bfe50be65ace0b3da6c8bc663916c540ef7434ebbbdc0b482baf4aff9a9091e09a53b824092bc41a85b2c1dbf6fe78cec434d2c2e28761874cf29f568932c3c7685aadc5057e5d1e8db17a2e10c119312652fe088b031954e6dec3935d17e2b4d42fc4d1ab624b8002b94991715316476535fbc0a118f801c1ebbaea2aa335d38d3a508a497c0b06497cfbb85c696dd26260cc933b5efca2a4ff2a0d48b93aef5b2b88aa51f8c5357ac9c8159bf738b1f280df9a4103fb0806ce5f087ce9e6d75632d86f325e74d6d334d419014ad60b2a00a1e519a5224768b7eb361520a917db094d319b969c17b8c2a5366587ed3775cdf7001f1ab9335c06d57c3e03c57d903573dfbda48a7c3999c5e0fc26a9447ae16a7de2e96d0a6d56c424dc19656eb83cd3f0c1e54e01a629d931c9342ea2891ccdb35da47552f9f1d1ac93decc9c48d719d3d736ecd55b2163372d8e61e4dc9c769f1ca536a73ca59988512ea002babccca03584a7feb3b359e63ae8431f60c0633380eb111a71e3b5d2bb45354d35218dc6f2421ba1f180835f2070c775756fa1694336a1baa209b1e02ed41f68099d6780d4913ea21da95eaffa62b048ec91486245b0301c87348b990853a776fd6b4cbb532178bc1b11a6f633d59aee6b246ae1068d5438aa8dc62e8c99088bfca96af2221299e0d2b2895c982ef19ccac16a051b950e6e9877ab535b6cbc333dad976a9ae8991e682e16a5b59623fb85886f457e4fa5c0cbce83e93c97cc01970408b1eef3e8db0a72489173f0fe9c8293fd4ad127a0292cffbcbeee42000bd5265c7a9ba3310df1cd08c2a2c52b015427b7aa3ecdbb8ad607fadbe68869def66cc80ecfbae78c908b8a02dfd566833fed286831fc601c1ad58a41c460e7d6340299279e8b522a19981e1de7936210440c39519db3ad73ff1dedeceecec19e1482b340f8b655b9e856d6888f297e164c8dbcdf49bca1456f9bfb61d00a6aae2d392ca8475ae4b986e3887aa9ce4660decc37d30be0a0c3bbd20a649a4cb7d355f225fbb8f89c7fa448d46ed94bb0aae34245e389f3d2011991b3309241b340f4b6ca4608508aac03a0c80ebc5a7dd3277b2186877df776a796ea989d4cfc1407e7e71f1babd8066a19aeee46d2fa566ad1adcd1106ea314390cbc1bbadf1aa0331f3998e90aaa7d30a461c0df8db2f74a81b0438c2c2d96b7a55c9fc659d930fea69f83bc0ac1d2cce05fe2bf9e251170c0f7fe4001e1483f635062568c8fe304f83b7140e8aae1eb1fabe0c546d28a585b91b71f81b441103bf2941e8e90bb02cb81b72531ba50ca018246efe1ae52bb5db466f437f11ad7e9a4c75a307ec0b0c12c9306a2acf1f0683f9c84a7e3bc6e88075921f6cb2ae28236d449a1bd2346c77b38bd677779e3b4cf396ec2140f24ab87d25ab8e0854d95b84c43196426a1c131e541f62ca375fce3b5d0202ed39ce550911be43b358f83f59c59e061b11d7132181f1d0f6f522e3297b34e280870b790452afa1d0794027db99f05532ea463a0a82528c25461da5a0a429f0628f568de5be8fc0067dd64d5ca386a2278ae9c0464d2500279465f21660c269c0406fc6d1852654c28441aeed2fe7245f1d98f921f202288ec3077b7b68ee30fe6085b3feb3899d6393ab39be24b21a9c130316340f52fe1b40a1f09db8b97d8b24da2da87db47b207fd68055ac251a34b76fda7ddeed538cc8659050e8a607c91a752be2b6a390c23d411c6ecfebe93f274d38f2e59b4304d1f6cfc71c663cbff03c2c27758a64240422fc5bd475070695d39e59f341a4f27bb1458356b3f2387a48a3dac1d3cda3d2780b654c9e3e629d916a7af68caae7b3dd120b84ecf24dca3e951cda83fa17a59bb8f475f87042838ab5c0188cb64f12ffa2f9c67d10c92383b238eb32d311292d1a9d55dbb7d8959cc4220f29d5a83b91cbb35f75afdcd3fff971c5fa7a747183cc00a2d22a4a987a1d9025582c5e063c828bb02786db401278f45f9a6f54743cce9d1cb699e60050d76a08cb9be4b34b908711a404cf21072fffa212ab2f0f5a3f81a3dc60d2e7edba37553959edbcc8ad5986df5d5f8f7980131a140451307a2f2bb7839df48101fa19d0227866aed2897645828a43d09e2d4a000d7cbccb05978691eeb3dcdbdfa8c338fd4efe1a39bb59b264bebda130d45d7dea012e8e45a107b1e3aff6c797be10c63a8eedcccf7caf3a2e96a650aabf859c356d43faf3f55fcf9a4469fb7618f4f1eb4469d704f82594d1557b027baa13c1108851eedb21de71125b04d6831c2af368487d25b660654e2c2af043e0502091901c2393376cfff5a10f97f22beb66358b2f5b6279c8c643e0adecdde0876e6980b111066914b2192f5e395cbaa574338b6e970df7a1ef952bc60b8bf3a022e0af8b3c46d8ef27c3ba7d249d72655f90fa7ce5b78f2e4c8be19e1aa165413cf812b15dc5536070774cfcbda42f9bb8e0f612d6c299ee2f77f5bff0ff040e6876231ccdd4f9775b1def8652b1184865b0bd5a767c70e34ef7fc295fbc690c8045e69484060bbe539efd5bb8531b7508dd249192b7057fcf47be1e28e1a4cc8dd924100dcd49a0f52a9210d3e0aeea50babf0b36b6c7841dacdc63304bbf042b2a2e29ea01aac3afa1c3f3aff57205f0f9b2d9df7c7a4972810f433cd686980a997f71c350d47c1ad95d3697a738e6e5612621ace132fffa3c6582421a7da7ea2efa8a9debf2a5e23e20bbd7db5b5a7630e61b8b8a10e4411552f2949735b22586a19c78bb799dda7ec9ed5abb5e082ba8f9310787533cdf38eaa029b5c94b4ee0620b2d2ce0115be00ca515067237ced624e40331e4e8b6a6b60ec3101209fad3226ebee9b2656d8dbe0648a5461b2bcd68a575bd639d035f2494f29f742741dd857b652a96702c52d26ebee687795e47f3ac433c944f4f5cf9f79868d0fb253374761a186bf203ab469c5d33f851444b9669211e08faf3353e92d532d1153f7753f0d6ca7e4925a59886532bc093c8cdf1ca0932d90ec5f74c3c7fbf31b7fbede69b610551a5e7710737df31e4d8a770d6670d7680305a8c16ba0a80b7af5f3a6298ef721dc984e14f611d27e010e375914aed63b026cb040f0774b53e914d29a2340e270ec0468424270b874bcbee5dd93955dbbd51420be95a894f355c05b1bc804d94c6d16306c41884f1ce333f541f54b6c77413f464df1a4a4b8622bdb0a778299adfb89fec0fa6bfc3dc4b142412477cdeaa96743905e0c6c6f0b66de819c7881cec0a2f74d0dcc063c3096ddd60edf77c32131915e4ba0dadaf46bbee5ac505d6100b7dc5c1e485e8723faf3c830f7797004da1633674fda07a84c0087072d38b3a7817132796466f7a51e0ea266344dda40c9cc789c1ccd38db30c08ea39d28dfa9987331c0e0ac22af0217156619365489eb4646eaf28e3d7116fe8acc487b68e7966ff06a6377673a2e804ee87caecfa6d16fd8d726c00ba411c40b006ce7c754697fc59deb8b97abcb1fdd416605ad85217b736dec07d8082b26e961113af7a455c9add54a46abf659cc7d671e0f4b792b6fbfc78ae040fafdccd7a8d6ad67cbd64e0ac0f43d537c0929eb344f993952695936310ef206f66027439677e8937522d496690072d9da68c215af4377c0ddd165fc0c18c9c3893b3a34499bc4e1dd7969dc61528d4bc5164f52d4360cf45adf6096cb788deb70eea62ad66217068f5b0cebae7cfcb252738536f8532010bcef6ef53e2b140365f9f4338244c6266b435d1ef8acd82d5ad3c92d596b56c8506f7522308fa53490e6176cef8d1c77c1c9e3fe68e92e93d2b04d6bde180040d2b8b16e636875637c6aad7627c7869fc606117e4686b9cffe22870b00f5a00d1f8e7f224b2448618dc485e3207d984a9a5c040e9386cdb158945ba035f34ff49a1ed2454840038e539594c7e11afbc6ccf92400ae89db7b1de7319d0f77edeea8c8198603df865f1a76756626ec14e77a167b4a2a4bdda68dfb7b5801a344dc6bbc37937f43f7005342e5adababae9d474f6e65ad6e41f0ef5a6e55b779d798b6d12dad631020fe1a42fc265d3e2d86bc4a79c7d7d6a6c0f125f40bad9573d84949f26cdd7899ab99d2cdc122933fe8871491d4bc50395d2dbc5e590e3a26bbe7040dc3609ef5cb3007317777202ffe9a681a0bc7f419713788c702520c9a751d3b20752accd9910de203c54ef7bae3650f99cf8dfb2757c6f9e20252c28d96a98bbb1f6eefc7ab1b6fb7f8cf2a3579d2d38b2208e279c248f532bbc78255e19597a35ec45bbf32aba6a42438615867604ac82bc99a17c4d5a61b7e4f4b3ed1b290b9d2203589fdfd4e8a774b75865185320b1743c98c4028bf5c071e435a637075f062caff22414e544dc85b118260091f41fc86e2cfed786693ed8bcee052c9c2fcfb29398b4e3862084006752d7862a4eed4f9752f580d1ab5838571607077adfc7d9f21475c501df6094e20f826f85a8ccbf6bf689ca80d825070c25f0a22372248e75a11288f0cc6c71e8c3446048c636afe1f30f7ead1cd1615d34be0df8e09b5a59918126f336198d4c9306e47d9469380e09248ebb2c789c647c96aa16e46e6b41b39d05a22880a72de9fc0fb82c933a4ed2a2791c781e72d3e261d47f6afe9d3c726eac97029bf512f912d0e45c2cd03aa72b90a34b5d0d28949419d7fc32b50cce9e84533b21861b680b12fbc88175433bea6e336a6039c5f9789de7673324d215eed9fa7a68092d4597e7056b111ddfb542a22e21999f781dec3a811e19cb5eac12c63f2bc43edaa74552414e5d16f7b684ceec52445dc72723a82a806bfb7d35fc4c8ec18b577aa3a86dc26a0cdb9f3e559b97e9ca9ab309d33df17089894de7b85063ec43b08265833f2c19711dd43fad374da520fc6606c421f77acab039f52dc97d091e43cddfacd9ab7792c6a78e348824aef983c5c5b8c4af0f3f184a0b71ea417969a8b27ec9de30e56e246a3c25a94ad6c17c838d1662ade9dfec8e4a84974ba1c2f08c8c26716ea2093eda5775f7c7f0dec2f300eeed49a95064d40fbf7af6f4bbe5ad129521763dbf2a9d6b536a8867043e602b80cac135cc8892258fc58a3f6f5e5ba600c3a78d3132d822e1767caf616723d9bb03ebdd5d78a7c5ae5c8ce7f2d8047a6416d8ab07bace0b79bf1710b69b7d05e7c8d809b639887554a4375df31499defdbb87f9793e968968c6e87028be32631063ce04fae614d7cfdda12096a0ca58999f0fa2b4b6b6a770fcc7418f11b4ec699a9e09f1f30ce98b787ca83e9aafe0a50a7bc9abf5c80b58dc7a1d1f50d24f2e1d4dad51153584b258f2680bf13383a1923372a669d08920f3baf9673afe957bfb2de37acafb1bcb1fb2e4e0abaf069abc13b1d188b7b047538c22c70af668df2e3d64e34b55e180b3c4ab88b20ee21343fa12f7d9513ebe394db8cb4746533afab6f98e31564106d10e05cfddd61f6532063a4f6b94779b56bf354bb445d2f3a89c66c2347628744cd2d69dd8994ee5481c82407518acf63b2b6c3fbecf18bfa27df549ea54f06b9d50b2cc833fdbfe9f4ae47210932b979a80f86bbf7fe2a2fdc5ec7369a7e74da3dbd58e3e148c019ed22f2c5e541e9628aa3f1fb3ced358cebff8ab2541d26ab038c7cb9e11b10da78fb5fc97834bae7d01f3281a01861f4f7e4bf208da6b367b35bec4c535d58cf85acfb8b78ed4f3c1d803855a895f2219fb399f49cbb9053bb8b5b1fcfe8cea13950011cf497060ee8df9bcad683e725520a9d9db5c8b1c68f5cd65b9c4cce2aef949e1b14fb925ba4db69435bb92fe4c11d8396b1b170179c050bc5e113e7de8192c31a58401a21e669da44f6a261d9bc13e0bbaa71b715f0be7d6733f59a0610de7b0182725dab837b3e611991c7b349c6e8c3ea893ab2f1deac056b822ea70260bb75bfeb4c0c9ff2dc765694818741811c06e5a210406cd7623a6b6cae7b841390782553fa82e551defe0e9697dbd1693ddc48fd5d4d701193ba8d92249c511d13ef3dca0baf308a78e147d0dedd49aed57acd36850d0235983951f8ee0b3c38d1d94c45d4e86aa895ea4254c83690fd8ade0dd180a5ade0d0a395dda4767dbf59a86836ee27551231a40d411f3802288f5ca2794ae13ddab8dc816898314e8e1922e01d2311208aff3746a49aceefccfa4cad6a6c1e0fc92dd75fb4164878d067627537a06a4b6a8fd1e0910c332e93ddcec126b1489b075cd44b4122080dda71c532099b28272905fe57a75a480b1cb4034d430b2d2248bd871034075f296da3f378b16550fe1b5aeb73815e3b5cf30e9099b3145a395d66cd2226d2866bf162cdd6e441bcb6a4fe9dfbeae66a10096c21aac433a7da3668e2067bd9bab0552c2c03dd872555c786ec96dba420c321caf813f12b06afd9751b19d24e13b0e6357d4be8899afb07837c64cdb00dc65746d200443c1a5e16f367917b974bd726f1ee966ee0ee36d37698dbb1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
