<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1837aed4576073d242c25661c8afe29260159777bce6bfb6203a04100437313b435212f176a328e3872e49b9bd6a0511f6249871fa7cfbbe37d97f1c6abf347bfa68f2f3682aee7c620daad7790de3aade85949cb59a8424670f30b8f70dd0db41592c887348b8a8e0ae49c2b9a924e0dc0c266dbb974b554b68fbbfd19f7b35d34a793d14f681d59f96a33a060a0a6a4e866b244181586bcf6ad53de9e343ab3ab38ea72a61f58c5e6a977874e0e556db2d28b2e3c96b2836169243cd1c64c61cdd6de9c16718d405ee255a03627d2da3f98f5dc794fc9e2afa40ee398b2c9befc7f42e0c3b20386dcc098a29ee27172aa7edef8bb5e1a6bd747af8be763236b5c9315a43f9c2474b91a0bf73396b3970ec402ee97ba0f8cae11977281482e79a9a1a12c416c9b53acc05e552a90c2ffa6a7020a04fe6028544881b14d0ceb08880b68a8af4715c3c98eee40900cd11b050904594fa033150be0520cb88206a5e98f57e6a53fc549bc53e53e6f17f7770fa5892db824f8733795c423b436f838be3e29f319ad8482b5e2bd28a003c8aa9cea2f086227387f703b65bdfaa21e65984cf302e69119cfd6c3496319b4b753586254bca70429562547b5b44945bc1ae98318cc22b0c367d388bc63aebc6c37b7ebb4247b9a2da80b6ea4db04ae41317e455c6b0ed902231252f25204191646c5db4d8dedc811e60b63d71c2840b5743d4fbfea2a8c5aeb1e4229fd15676f9ff6d47f1191b713abaf2357b4dec5df3c0b39c2b205efc9cfc978ff796bd56e7a8e5b0094c94e59cebdfd2e31e389ab70205ca20e37543461918ec4a2692a8f2f0de6849c758d083d13d09c875d7409c3da76bfa550c433529a5df460546fe9e0b020c616193459e1a0f4862d0f4be912c8b2800178d6a152830e43398756497fba1cd69a606550e95395bd03665686cdf28201bc7b09c16a6c8e3ad9ea5f3cb4ba29254cd867bfbe2e410bf0d9d2b3fd1b8c16797b9076cf7de1bc62a57e5e97a49dc311ba178689d64763405636599e53b00ef8bc3670242ce66c4a001b30e1b6b1bf5e72631528df3a095a881f45dd6f43bc787702bfcfceffcaf72ab30620d6a733784f3ce6325b36c51f602b39eb7da1a3811861339cb0223bb82861d4c9fa80f197ae5e4c5b8267d00bb0a68f2557f8a60bf29e30abe341bae6a01bbe6b54ed7879d0e85e94ac65e35a5ef3e538b8fb728412f13f4f9e575d23f4beea65e2d25f1de72e38e1965f3ab1a8521b1883acbba9b7129e3ebc152f83425c0c009fa875430217c51044ba5b6a97d6904c32a303faa64b2fe1bfbad03eb135e01a1554dda747212bc1c8a47d7a67c74b90a6a6bb96e8d4c734aa96f0042289179a66d485309f8646e1189f8fceb093cd839d13277919427762b14e0ab7b5857aa5299f7fa249d269b4843c835b9609ef3e70e4b7ec8159bc82fe4f335f977028fc9e7ae28e6b5063d551762b5813c02908367cbe20b7bbe29b1a4d84f587bc87ce5e33a726a253b39ee2882024066b98c17e1389a0ca2b7441902494b68ee9f48336129e0b0b5df03a08358652b717a923625459c05ab472652722d5e5000471e2bdf10b33250ddc980687fa1390f2985e299d8018eaec5357b209780a1e88c29d6ddd6b6a91e76a5425f52bb79cdf3fccf605df98cb654cd99ecbe17539028c3e56391205d8024ffd2560ce6bc072bf2891d0cbda5e1d8fe5f1f3ff7425412df60012f8b97e7ad4177d1b4a7a82ca6d85e406f434089bd1e53150f8edc5d11ce28e6996627af580af0b25ec88c2525ada37f300f0a3d183755ecaef71292431ae8f7a5bcd968c416bf34e248339ff9a171df74e85535ecb2a54ab74299f279cf455f796b23973740916914a68f3326f2a72bf3705aad77625b3a330464242b1cebecf3e6383df10273ec90b3d8278bb4830cc86db7d05988c99072d40e6d5f7ac23f14167f75e75b30f4f8d93226416ca6cade3bc843c1c8057cb1b7c57aa9a00ff4496a8c093d5a761de9eb69b963ab92d1fe009e8d97e34a3414c2bb385e212bcf577bd2f4751a9304369f7782fd541cd2271957994a33556111f60240c33f606b624d2371fb8844fe9e6be36b5a0eb6d67d6734d34f83c53d69e6404d4493116b139e3489669b94932675bc825a9b38919a9449bf84b8f896b23b771c0c492c249d8b84e1155c653bf2e9cb6805b8d96933dfe5cdc8a7ea572dfd6b24fc26d5219486263db983756b814d763253fb591feda6dfb6d74c601a1c0cedd708b1def5b26b91329ea5e665a39d783595af8555752811535d1d2e7bad3a5ae5a6471d0efae685d3bdfe59f776c4fe7bb767ca08a1006fafab6c6d7a6bc71a9ef689c724b5539e395f303ee6f796fc7024ce67bb6b9fd9606077b2e212606500c94588b858310ffafe41c526f58af0e5d3f5c32953574f2908f9bf32cc8cda81dbe7d900b2959a6ffd97adb56531ea56a0eb0c15d623d188cf29dcdd3472448889446460c2205d2efeb690d1b525695c10988e78e33aa1aa1541f8af105038c669ff9279256a1076a6887ab0c3056c2f00ebaf0acf09ba000f98105dfa915f96b3e858b6aea35e112654139883426203bf4aaf24b0e4aaa1a49d78b31bb9c13139960bafe92b0c77be699d7cf654dd366ea649fd8b2c56e5efdc005ac170ff03937a4918654ea46983a066c0de5e6a84e0e4bb63fe2276949dd9f33697485c56d8fd99df85c43a261706da003be53b1f99aae0de5ec127f9681045d3e35f2d0df745a715adc373e18ec7af8cf9a3a1a6c2f6c89a3b590e2194284337969629aa0e2565b8480f0de572feebff37eddc1a62be014a88df577b20309b1535c8223558bee963fc68d4adbc7491cc71c65aa8306250a7beeb33cae6c3b05e0884b76993b62191fb1d5a96b717fb2ad8c79fe5a754faf7aba0473cbd9e36ffdc0f98b23ae73755c17a39a8763ea5ffb4e87b101fceb9ca381942ed8d7783b141bd12c6b9712499fe41cb77dc03c6b4a7d76b5003cd921dc1ab9401bfd314a9adc95abf8f80aead888d04921888c6cb22ffbf88c2b05aa7d550f24c5833d28ade67ee695c2d4bb42b3ca6cc53a781ee9bcc06b1b2c69cbeee084bb29704a6d6b63e3ccf1a7dc5abaf13eff02eee6fbedc4ea9c19939c358f31e04a5c6f2ca9a5f94c6daa88ef82bd6f588c014c346e89dad41ce2718bc0403db4c3825799e51ff3610b83a74b9a5ae86b6e68e77bc146723d8ef2067a5ec12fc27b277c5ca90f7f3e71dda421d5a098aee25d441f8ec5647ce9151e4354f8d3f40f8c65da4a77d1f85f5e4a2c2d8ee4c7730a3f49a1adc10f3cb40ecd7abb378e2caa1eec6c2e7a4e6c01f5a6c1e296ebf9bc7183e62e7a6e8858e5d9ad5e718f29c623bece93c8ab0e35b274f3705ccf86143a6286fee86ee9255516ff7112b35b5ab475f3b534f031ebae564bd1668ec2f3c2bbf05cdd51d99c0e4dab1e2543094db1be49404a5717cd7dbfd09a70408b9fbccd0a2deea51926977ad8b3bc0c606926e9956d47300278bacedaabd3162486fb0babd9e798b61d15a2e5550f1f454c2f03ff3394d0fc88961ef4e16e29a83b06e6faa0c4bc4651e207471499f3f7bdebf3a6ad737566160bf034c182403dfa98870a1042ec633673c983a5c5814c724bb571081b83768be0636cc682b4e900d183cb076bb0ba973bf4f2eea97367db919b7d9aaa102db9c4c5533885a96c4993e6e922aed2ffad4d7b765061d345fafa69001741e67f0a4bed6651e6c54e387190e3952d96b7ca16acb3dd5332dd24c3343a004f49d28ebe6ac92d390f163599cb75ce81e694cc261c85d61993b26d3f70ff493f377e2a2962adb6b32eb21e218cbca36c8d6f4e8c73bc2ccbe1c32f26580c3566a8d095c5d18394226f659ef705c0a080b9f7cd21f528d8f54138065bce71e8452d882dce88c8be1535090bb812edfe02728b73abac69c185ace20f4961bdd5fa8511bf1d4fad7b3f5f68ecd664eb7e88357ddc7189ca0d353a8df53e366777fc07b7160d651ca3d2de1beb60e693d7168c2a8bf742be3dfcd3e5986e7b43c9ec0cf1cbb124ef849cec5727058dd06e033b9f9af3fe88841cc47b015d30936a7765b9029ccfbbf285b212d4657e4716b6653e533ec76adf1740560d6ee8a5b7b595f9e42448ec49d96c4314cba58296c8031f8e256a72f79f6654f5b9e7c4d2789e40f6170094ed82b963d81cd76bc2f2206271cfd062c5ef630bff949fc50d25d98babe02a79e3fd76772b2127a858a4314d1373cbd492dfc5b9a36eec1db668596d1fc73a08502f3e973344c8808da88cfbed5b6b24139b5d70709172cf2a65d40917717849510a737345819fd902cdc428c644d5b6037c3ae9adadde340d526af2d247a582a13957ac0cb0642ea8fabc8fd99c179cd972e7f018ae3453d41e13ae128753bf48873478e852536bce289c2f0cad59d959cb9d30ad79efba9625c52e098ed37ec1f0dc72c7e62131ba96ab2fbc3f9a970595de6795de876165ee689199ef589537b9babd0fe673d4fed9f529120e5eeb53d1c057488c34d1d8f2c88217c97fa6566e355b7df5f70fb823ca2b0717d677e24193ded16122ee310fb7eb8c88c3e7cd40a81c0374d3eab0f193ee3ee8bb6e0e4d5a6a625d9e488bc666e02790bb26ab05531a0e72e49f3631ab67a623d9f12d08bbdc7389792ce02788ce2168fa2eed509a9114ee8f63df4cadf5fc83b19e15a3d37ce5da17d9dd92bddba59e48f9362cda724f620400fba664c8b9b6fc4f31ab7fbc7f64e0c926c117debdd4c688669f9bf2ca19cc31c3d9dcf2c2f6c4c39b0148c575b0fcfcf7d3aded5919e690fd412f044185c0fc469b04c68356f3bc431bb942198f8c0e167040a6113184afa6049d24d16156f9cdb2491930bded678b671eb5d86d07942929e274d68a80c53e1de772f4191122c9c7e605eb42e6037a88f6181a7276ce7a07e2a7c4454e357af2d56cd68b5cceffba8279b45fb750acac6d7a25e5da7da6e921a89f6495f68e9b8a1cf35f4ef4d8c4bc38ab543fd37b1f55d2392688ffb69c051453103678e52bf9aa2abf6f6cd782b9ead1089492bc808578937b296611f38d58798a2e49f38d25ef115012858e083432c05c8d4fca6ac6419a509cde005b6049d35b9cc09155d58fa22f46c5879fcabaf9cd63cde3d8f236325051e3e8d9cb9bb4d81a0b25850e67134304490461eabf765644ee524d1ec9b754eac3be0df90f24d7606c506dc163b25643c0ce0bc77b3de2be23dd11d5567960d9c1e435e4ac275ceb39cf8c70cafd53ddc2cd4e37f24bad143da8155af69164f167bee65f2f50cee621deed3931d10b094c66f73d565c2797600d1a7de69e98b8311159e43e8bba1c0e22d8c9469639c4e345b49f68680bb8a8748a046b99f3ede37ce5bb2fc5964abc1095f7f838a8703527bbcd43abd9ebc39cddc4ca9029e79a8a1d48dd68d23e361ebfdb04b309c034493a4d98f39c09c1aae9782d2e0081d084933632e919dc006c50077e0bd2336688030305baa25b380cb96c9e2c26a97a907307934be8c1bafe0d444f16e832a5488596726806e0bef51526b8822ec1a546a91c00cb1c5dd61c26dc8b207d5c90e8492ad0536f946ee990d2388a060534518ec6b800a426ef8134bcac43c9118927c7e4e96cbcc8802d7794b50bdb547b289c08c7602dae1c81ca01409e0fb0024528b6999201e268189564e2de2b3322759db306db3d6836d04786a8fffad5da2dc64091f0d98c8df0c603395f2f03fefb179ea13ee62f511009808118b3da0c1825a7eeb7833309b041bb4f8974f4cb1d8871d79297b6924069a2b602bf0ad99cc976c1f6b1f2e47de78892265a77881675faec843054af8e9d12568291faec1977abd59f91539bb2017816773ffa09023c59b3b00db10d07f68a5cd8d1bb7f97e95447209cc6c0795d04b97402f19a70a4d825900786f240f4672912330869ce8c483c3902e7a0dbb48a161709c0932b0394e389371f88c5eb79014a44865b40920b69c4f8eb7b83b1106da840e81bc9d19e1be56361206c21c542776cedaf7a92cf9f16584063d578a10c78eb8a30fea2f715af4e91045359727d0c80a01a9a3f1e6f0404f430b58e20a6307d409d44f79b9c0b102d586775507cb647df8f2e644805f3608cb45eca789cc6d65999a8d679ea26f88e963f8d5efc20e47a0e14b1f4df14d77ccc1ecce9546301d20c9b657cf3a443508e3b90292737d39c56daf0e9827503ae7728ff2270c9365ecc6374464066bf2a48cd43b3ffbe965e68967e164f92084a0dccac0e65d29d95514a4be600a23de8f5c79806b7b257a756b1481817c46dde5e6d10234cd0b99525376422f2191d232ea2698a04ce7d0a98a18396e45c25decfc4668581c4679640a75f80af2b14911aef384083556a5874ab52c42091fdd9bd1037fd068fd04285f7e857513a20a14b1dd256ecd0aa9eea6176df1e1fa25ae222dd5d3847b99a822d828102441bd168875bb7132627c2bf23f2096a124378408065cdee5f2eaa0181e0e93e82e4471418a28b497fee35592c0b9ab4c67a75b8c5c21e3d9633fceeb3f9e747d881d78e7df36e5b27a3df68dee435245cf7743572db054b5454ad54a6af29e972b260eb1a845670b39b72f1c3a2e45f73b7e91f519fa4f9675c7c65263bfe1ed62cd3655b521801694dfc8b346a7732ece4c6ee7318b5fbee100de5ef343a1d16846d63c8627bf8a83076825328db846dd81219275876ac80507d53a2f845c65fb7d41758c1192d5392d9df48b379a66ece204a51dcbd01817e392a1efb612e892bfd42bf29bcc2faee7fe2f4e04ebe91bba3db9f398a9ee06488caa69d1de4ac4e2b0c0a323bd775be69b833db2d06363e2262e12129e612a40a3d030f9ce4039cd1be1cdb67f96fce1a9f7eb5bf067b0fdb84fbeccda8c3566eac1fc3db314dc8c341f01f5484df2361d143195d108d035f4dddd5edc6a6abfb3210dd5ee67f9629ad407e84265288bcda6890e490ecf621976012462e9585588969146d9139e954618c5328657f8cc2fc6ad64f9924683fc2696c68c072ce4fe1323cf797ec6649c586f71533ff22c7208b44bc676f01854b9844787e0d99ee12b8a180f2421c60f49b47cb72dc18640296fcd15a0777b557a2fd50aa459d348f55541a6a3b0607f43e1359850e3c2292ad12809ec0f99f811aab7dc0226aad2e654c64d2145f9c75bd5cdd6d4743a09b9635a43105788091e912b1a4d77f4de3c556b986d41aa7e1711dd0a0507da729cdd14f13d180d31a1e8ac598648288eed445105b5674207de64a48060b5af0af43dd412b4d31dc855f94916a61cfccab9bd58a6d237610e43b237872b9bc0879bb6c22e9740540744c8b69b10dc20ff064036a71dc060cbd036b807adbcc06d50ece67a8ef8003a76ba0030ad426a0f46ec06a6ef890eacd7aecba3ed507958dc91fab046e238ce394bd9312f4ca747e735570f6bd8f762fac5a70cf2f97fe8dbe02138bb828d0c0240961b98e5aa2590688b423e0596d8a49d0811974cac2e9ccc27f55b670750619c7e6fa097c837372585195a88f77b43ac31be9f4e323039125ec16fdaf77d4973655c9effa9400f8c8dc03fa1139e14a2e8ff26c2c9cdfaa94977a4e1228827393553c84caf06d9419a516b108466652cd6574c224562768d1ad1a21cc4326bcfa496e9724723014fb297b0485248f504e3ee9e2e65a91d37c1cea1573ffe92a6fa11f33c88479ddf5140ca006d76c710a83e173593c66a9a825b2af39b63edcad671c7895a52c091e75b468cf5c50c15099045dfb83bd650c62e0cd85b6b48e90ad86dca5e1e0d80bc105d501176d88f60eadc822d7bf18caa3f316206fc5d4903b0f4901fc79612b51203ccb253477ea49945d0835b6cbcaa93f27d19566e7bed3fbb30c9d104146bbb81a22a3e987ba297b6aa1173404c7c50d36798e25a374acc3ddf1eca56ae1146e5d153b0fe13aab6ef6032a57039ddef79184bfe93348882d78edcda9d66533989a801bc17c493f822b1a1480c4676cdbb5bfa2d91cf537e02bb00b2cce37a44f0c58f765a63aa20422841f86c4ce0982e8b77a9ad8431c2cade9b96e4a1ae44a33ccf74985bde493fe4511050dd4700f6b6136166865aa7451523cc8e00778e9da4cf1f911cd355175e5d6669d3a9cd65034341f216ed97e78abdc7af3881cebdaeb996956b510d7cac3784c1e47497a8790483c3ad8b3a3b8e1c5056797cc09e6d776ee14a9bfc7911f2d94e692fedd9e907091d543079f3b270378c36b0a7ffa90f29e77cf81ac0618b07178297a08ab315cb565c36004aae90843b7a49a15c7a26ec012d5e53fec4964e201e0ff581626aec1b9ee641ea662312e6a87eba2ec76e3f0cf9605c909de91c832103b556ebb427d65bc22a944fc389862b2d8e43e0687eaa3786c1a51dd4bd04a97c717868f018d60ac987ac339420ca0a850e3bbc80e20563876c8d9cd8161ea291028baddd7f0f90dcd737dedf3121715c316fafbc7c298a10700f0e361bed167df0ee696dcfc956324aedea81323b31eae64409a995667d5781c941423752eb390a990aeb62d329454ed0dd3951056189c45039272ae1c3e98fb7a5b477f89bf05394d44e95b78ab27747d842f4294a0c7bc0b38cdd055aad85d8ef4a2a9991695bc798febb011138d5220a2a2cb24eddc071bf43eb8b4a230d8f763b02d24fe2d363602694fee0ccf67287f99a85419a4128d9a850974f3a88da1286597cfcc5fd2210f9ad867826c92f83b0f4e32fe3552585aa9093ba61e9d2e15ae7c63cedf95201a5591308d3789a3317cabf0ba580a0b7f9c5a5a1add1c10d0ca6ead724d97164a14e5f1f79b3e8c723cf85e4cb8f2c0e6d0f1780b97d51914967ea26b6aff16203c0ad1d3725e62a4a3db9a6b68d19528e10712b12f6e8e0e5ee01d26d7ade5986abcc914bdf706cf3065170e35e56413adaaf81459ec9515ffd71c308869e68fe061050d2062afec45a500f6ce0b21ba86ab0a14346a6818f88d7e59fd176a5ec2331943a12ba14d480395be371e7659a8edac0fa483f0b4558230cf0d5c25813d2660b66df751859d4b52add56f1c82035ccf5d0c4383c2690037008c2ae11c475f1448ce25998f5153597fbb221aee1a30d52ca5b03a8a425d58b34dc20f1f003256a0e8c2d21aa6e1ba0c5750131b73c8e3bc43e363fad4647732677016035ac60fcde0fc05ec7d13950e7103526b79a3b86140026d4e3c1fb2039ec5f22434dc8edb31ba6b49a49b2ecf1cd227659a8d869b958aa99ad7aff0ff0b0f490125f2845d9e2c51f4d1fa0349b94a0463d5c60f598ced1cf75c08aee4fae48370b444e940c1e35c9422cd8f106c52a5b1ececbe6067a8f1761017f35342160c06ed1778d538defcbe2d080c43e3eb56e01867d131e470b01e3192e578292768d365feef0d1457804dae8bc13c5c2d6e806ba515caa24df17b330cf4720eeec9d5d4906b57c1db429383d724932f633a3a36b8148c8e563f4a4c45603f57b0df2448b358b1da81713a5f2be09de3e33e383a58581f368c36c3c42e85e378219023a9317fe3a7b14a847675575a485f031ad603d210ae81dfb6b90be6e598cf92594da2730d4c3b2639fe34fa598d8595b1ab415e5b18fcac934a82cd4506ac9f7aa66bc76038e33673c9001656d2908b0a78261f3a2b0cbfad86ca42a090aae41e117774ba643c87b2e70600b1d40c71d4ede41b44facc5dd25502f21fb66473fc2f12cc0871c74b4651a090ab629d2d66980a70262b48c582d67d0ca2a26dc706191efedf16814059bf23dd0f03ecf90b0f88df3392b74d9cfbce9806d0814b8c6b152d76fa6e1979ea71b526522e348bec7663d3f1d0b4121c2b8aaee18fb18ea4c6de9b4576302594347fc9a744f75aec5e2b75744bf2d278d04ef5676d8699d42dcdee3c3f513a581df27b9a0cc5c4876ddefd95063123a82d3772269895f262850787c6fc0a33e87621cb08b3659524dacccaebaf8f0c61c59e18515f78fe4a9da435f54958b63debcd7918776df4e5aa156c6f3613e12971bd46719fb55dd6c6cafc8cbb16cfd2aa41ccb621915cda122981233d99edc561578755b3ff18b0039a6c5c4a6e737494890a2b4e22de1329f5a6cb5012be4ded6c3e566d0fe8a5abe7640995785444952e099d27159dd6657e93f4d27e749234999742e2fa7fd06a149bf9c6a3af432fab1dd78b535f171b4102ffe3fc74352fd6e2357fa27278aaebad675acb8d0594d5b6d14a5b707934aa5d60be4e50be682de3bf2f9ecaace5e585df36881c4d729a9861b3a4a84718ee1603d7e48e4a59e35b60a880a073f6539b42706a517291012128bc82479759a9d506b0e96bbf90d8368a83abf5acd8d830b9fad60e962d9ec927d2949f98b9f2e98af9214378320fb5474e20aeb0a37a83c536c7da44e35b6ce0a92efff2cab91baebbaea3c80ceb3a3919720639a0796edf5733a9a400aaf3b35d7cd81fed111c8c4f1172404c52098852797fca58552e85c9c2bcc16e33cf782c355f21e6cae869d7dabdf6f84e368c40cff7e62d73ccd9ff53bc2d2c12443928c34dad17c3bebd3a7f0bbf01aaedb12770c7999b7b10211491023f7a3ffe433cf4a4a101cea4361d3260e887d746d92c883d41aa4558c4774626964add862f32cef1d172482e8be03a2d8e5cf9383e36597ee4a42dce477cfae0c07c4e14a42f5ad1922c9758047f7205defc19796a1e8365749ca85d9264f4ed989203d6f5972139d8dc242f6bcaa909e63ff0b3a8a3308f537178ef83e6c69aa56239894ccb0180982bac27140b4ee259d25f35cbd22ee62d49cd68a4a3bdf14d94414abfdbc352e268f1bae818714c1ce47f48520d08f97007272d7258afb73f637589e9852647e4dba6966b134460972c69115ce6c6d43f3a67e4eadcf8d33aa41b877cf993e7be126951ccd5c4fee322dfc9905b5b9c7ceb28910ac4b565a7b78dd13ccc3eec24efe1cd360eecf5b7da171ad30000f9383b99acd8914454e4898432e880eb98df68fc4296dcbcc05f5a5c7fd62ce56bfc7d9b57d5bb1fc759086d39d8c0a312d3bfcf808000d759934471c347d0fd11aaea4d12c4925b46e55d84fa72df6633167dbb45bb948270677507e1321fa8ccb917b74cc140d162a4a7fea0ada8d235aeed73d27f5eab5759a1c926682798c62298d3747ed5653bbd36a1f4e9ec49d2e532c795cac5e7789b19b3053b56b0046236127717240047a22d689c724e4867a5f009a7f044068219aca2cd18616540d33ae3241aa88afb9cdc8fe0618dc1ce50ee88b5a056e1f7a8ae9be72114c450e5451b72ed86627de0b59d8f7dca8a8996c1cb9663818114d3b9fef4130fa8e177149d17b57a69e3cdaf115d54502c50b26e111d0d2434e1a43465da4ec6d00eaf1143c833c6ed4239888f9f50dfc876681c93376cd80ece7fa49f5401b2da099bf84a895824bad5991f70b3b9f84365590e9eb8638d479545b1ecb8215588ee9927fae1fd19d6bc60150547e50ad50cab9656bc35133e9290786555e759c979bafb432caa8fdb4f14d5f7126baf607cf3b3efd079b81530612c6df75b6e325645d9a1933834bead9c7995588d9c26bc97434407db30045c409848ce06252bbb501d83b0279fd9e4dbac1231b561923c6529ef919f45f06a6136fb6f510181a5bf405d879478854b5cdd78fd6bc0c85555497583a9b8266122bd0de11efab63880498474b8420649ffa4e2b3ac5c590d586b9858c89d9c1ac86cbe47c79aacb5d4cabda34e2559970a6948a932a85817607779a140115a5e92376b632428e756ca4078e412c4a68b3d1457d41d339a1515d33fccd9a270b87aeaa17c964423abf78c7eb963c554bced217f61ed43d15e570fcb193c593895016f14d423336e9890f9c83492bee00d2b6c557f4b7be5b05f6c623b9558d2d983fb1c81503bd5582903a16016c6e64e2ecb541646f85afe61562c7387dd34744a7e952876dfd7c142a51b53b6eb330baf560ad87250466c675c9981311ff25b3e5527a051f61516d00c5897bcd06cf339e77315fab09beae55f4f615e1e097905d32809ec2a83ba432fd0dd9cc03b61ab587559efbce6efcab04f9fa4933a5472946f52e6e09825606b507ab6b5d466f8a1de68b77cbe65dc825f28249e3bf24179ba2ccb8245fe6ea7cfbf76c805aec1823be5af7f7fa42725fb3b1ec05c10823ac6537f730d8845024f3336498578de457b90a103160de42a1d57ae4bfb27e5989fb410292f8ca458a896040e15a4f362a4815a1a3f192ff5f18f44be3cef3a567ae3b28036a60d34e8d398638c40cc2a475c61253589447b9fa6b9ff356c3cf13181c4b6d6a1c55d7c026152a969f0a57d15d9d342a62320456d85960c645090f0f68382b12af6ebb8ce3fbb94ab0b8f1286cc2d14fd50a190bcdbcdcdfe9ba647369d89f35066da207f47af9877f501ed17527142a43dbedefe10eaf838465f51f50bc558079cf67fa15cfcfbc853502047813aab2a26cc080ace5788c8aabf38da56aa7a29eb2b5d177fa8e70e0729bdd60e193dcc672debd0535e6128513c986b398b66c05b79741a73ece3e73f0453d0881e5ed762252d66b7ac117809c7e1e661d2445cbb5c3efacc63c68121e28e1101310bc21c8acff87532b919e3cab7fd12a2c6881d6acc17a7b8716a6c724df0898308de54f1bb68101f875ad807209312ab1f2760053049db220be456a8361808b02697a6c087bdf10b5d462a80895e539ef481cc88551d0f2784251ba2f98e5fd6ef144e39e671fce13e5bdd96d5410eeb41a051e787cc06b195bf80ab051d9104b0b5ffa0de7a03b5b797bcf141c9d8defaf686567dd0d624d26940c30a20cbb230ef6fd74b29620e11f209cadd448d413a272bbf6bbe96f865f9c8490d7db19a3c7dc211715d77bf9cdf6b06cca81c8e933f6be48d955739a5cab805842547eaa5ca301f0d360f5b27dfa4c1147cef41d968871366444b72b33f389e398a4183db41d3f3fa2a780d3f67dac17fcf9ee75882699834d46b3eef8b0c8960e81c3fc19a42df96b9e1da076442abdac93098ff4b51b3a52d32ec18767fb5ba55b6513b995404e9809cd3100c97a82dfc8865e916688ebd549df26be85a58c2ec7aef31b149ab12c87856e39343ede0412a56b81246b5362ed364b804cefab1c250072915212f40a8970629a35294a3a7b8b99514e9c9849dc60851cef28baeb3fe6971a4fa5dd076fbd1352791e2e8a31f5cf16ba7e6fb924f22c740ade04a57473afe3c228858d7efe8b0a4eaa2e5050a90c4ae3f57fe85f0f3005dca4115837426216fb8dea9571534be4af8e1204c1a0494fdd888488fb5eea62e83133611af2396b6232c615f65332444dc5b0d6959b2b6c1fb3c57bf4b8d80b56c0df9d7d99be12b3afd1b8ea947b01db1eeb98f23634cae9063cbdf89ac295b0d54393b0ad675750ff68b68842dfe004765ef27719122da2b4410496c20d5a066f2d1bef87891a67229696d1b041b55e087102a764b8a3a0011dad450d790f46dd544e1d73e2ce2535585d80f5af6d674cf315dad3436346a6a998c68d5e61ce328596f74cd4d638c215ed3aae0f32854edd629e231324fdeae32ad8cc4ee7d8a0f13e1168cf1d4ccbdaaa5f9b5318ccecb96c3c718a5da7b4d3de5a575818225cd3ee5116510b71af17b41aefd7dff2bf6619b4a7322285158d4a2c7c91e77091dcfcda2a492af18386ce5d2b72c650e801b031604f2d697e4a88c5e7b869ad13fac9a1c6f6c7df03f01d6f82a592338ccc85cee5a89651714da4708d407dbf20499ba48ea28b1edf78d3e655bc1fd30ef5f1eb9393c0c352f0b6d7db19def6b7d0b27d231c205f3f98673e31f0eb3d6df10770ee6c0ed424ac7f87a10f90c36fd4004de3889cc44f43c4ec7483674fab53a504a87c7c86336ccbc0f7f9a9d0e3af38d494351a7da8fa7b2e3531901e655c46aeb332441cd8de5b16b896d70a83d792816fc99bdbb5d476053d6ec4aac2387ff37f732fc6e724c61f0dc21e40d9278929b256c52b8a7e8476d7689fe31a0029e58e08d71b0781423952753f1e8f3daf359e7dca61da13939eba3daa576fe1c30f58a242c3dcfdda9d69552bb0ce503907dc524be7688634cab7cdb2889b2f68e36010d154a70b6af44d35b270b772542b56d221166505b98c9129569d95526ea787b46e275410d5a50cc04c3c3543fe3ba5eaf181639cb1a5eb8bd2282f90f493a8e35cda797865f9ff911482d3b6af4432810b9d05d0023d38f6db6fe1774f83d1a824aabdfa89363f9e83bcdbce347dd3d578bfd2a7c958961c2cbf160399bae090f83b255d00d0144f2fb8cbd3da220f0556723e6afc86f6eddf23c016c404bdeb5ef2f21ebf40c853c31f85fad987a300a3254960e4b5edd8b76d1718a71215dc58643cd9ee845f7b609bc6fd8f8bed5646c640d0ad9e62ed815f401a462bcb752f843e8b0cbc06b6b21700c3abfc84589ef159922d94928608142c83636a2d8c7f193cc8faf62bcbf11ab58ed3074585252c757b482c87c9027b723be3c431a4afbb83cec3ac857b7b849b86aa3546c87d0b5e23a6df522234a6ff8eaf9e156f9295","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
