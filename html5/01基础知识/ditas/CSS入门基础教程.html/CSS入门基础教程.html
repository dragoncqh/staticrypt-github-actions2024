<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7439e5da5dea0776283bc8f28844c99fa776d899a0c7cdc036ecb6cde6ed91301ff2f5fd63334fcb4339534033539ccb1d22ad01a78a81ad4724dc9e970382b859c6dd137430881b82d8e6b8612df05a07c70fcbe276c3005cc42769bcea6e20740a48757d3c5f9ed338370aacb784f62d1ea0687401782f517688e5b33ff809b4d05a62bbc894780d167c69ae78c25882764ee48c93a09caec19049fc871bd7abd50d787e1fa479e61dd097fa9f403f0bfa23650bdfe0ca1900c817aceda3c7c4764dd82d6676e5e20a92121feb6997d07c5f3524efa8368d5ba1ba340b490a50028c67914cd5b80f3e5ef503bc31202c127bf1b034f14b116e905f952eb43e78d6dd9beed0e16cfbb766d19de73e0c40806807abc1c7f31eb50d3c0745b4213c00c83839a4634070b463916e7e357530ae624b025305ba0ac905a80fcd6faa0ae8bc059058712f703433cd3695e612abcfb0ef22b17d1578952501407cfbc0c2718d160945a408034f1956ae1977fdd24f0b6c5d6dd32b47932a68ad8979ae18cb4be47e02d2e64d6812e6a9c4095dcb89faac3794bdff9a578221f697356d3af35579355c9f9d677f2d579e6daa842c6c30c5b37f57cb1ce2f19760a6a4201eb280cfeec46a11a8ac5bf28bcb0612b1f5694e57bfbcdfb13186cd61a50c74b0cf327aa0593924dd51df52900699c813f39e2d555e029873507aaf973cb7f73e4a5e3d3b1451704d7c62002c4f33959ed9a95578a871b1a7faf596a9d031590246a4a3d6fe15116d8c7f162fbd185c827388555a8cad2704ed36e14bb414bff6da743e322159e08b50d2eb67b7de79a6793b5ce7601ee17d3c9824e0ee8e06263fdc71aebe90934b7405d0eaeeb398b6a878a9f1200e7553631af6f46605a149849f56778adff811046654f4515772fd595a5289a3d9e2c9f231c4440072ab750e3d81f0d15784d60446306896871411b5b8a8b16bc57143a61cb6c61f3fa40d48f2b0ac7f057fa98eab29e9a54e128b1821462da1ea03a5de9b2d1a4b4a803d4950d7820199fd0e0e613f53ffc0d1a6fbb0bf8ee521c9141bf5d9f9a9f524e572fff60cdef820c8b485ef88fd47d81282b3f7453b65cc32db859245c58bd46bd63456052536e98a76348371313e12af8f6271001fb7d9f3bf58d9d36f84c6a740318d57977fa2d584bc139258fe3755f5e69fe02ccc0f6bc9f81e12f278487459cbc770715b85df5464416ac60a346344b9cfad0e18fa78d3ce906064502ba2f4a5cd2ee2128c4577719d840f4c9f0b99165aa6ccf14a0c59a5884c1a018bfe776db3b69f9176cbd82308e7d88086bead97b190d1c0929ef61740c1937cb364b16ccc41ebbf283b30a0b876e4d4ea17f33fc350cdc6275299cd0e5a6ff4d35e8930caba7011c1fe2289357e3b20d2dc3c342890eb5aa9b54de2523070ee63306018aff47985b1fdf79c2a44071973bd5bae47da795400721dca0b3ba923af1b2118b2b57b7e0d3a8ebb956ee387cf458d1aeaac8264daff0dc582e8fa7f2d494e2a2985a7a7d0dc0c1c95f18b562f6d3a30addc2c2a70bb0eb061f2daaffe2a15434fecd1c8662b5381dc8fcf120b53c7a3c043f8f13d2861053b0e54f28c43a19d1c8ce3a82ce652102a989bd4805a9cabcd16241e578ccc83af2c3659009d13e4f96fb68ae1ccb16f18de23aaff78d2b4f9994b4df4338c09ea7b359736123d8a4297e4ef17754b90040dc46051f02b949808f63a928b49031522ce3f93b573cfaf5bb2163418565c5ed14010a7f17862ef9bf97fa7d29f6ba02d136834f164c96adf642a7a9eb2d3378b58391b5a8c4ddc87ee7d9392e64f6c17ca6905c26da776474f9b55c1e6ebc56dd637da763d4b3815b419872a4a16d347e6502ca14663ccc70e0ee94d2c1149dc37fc2565c1e540209d3165fd2e9a61aa88dd00faf6ca40f39dc52dbc72d86c6344e6126afef1486a9f61c61a25fed17aeae36b2bdb991571db7f19721e89410703c9be89ce7cb8639b0310e0662f4e25f69d5a1d3869ffb6160d4eb999007e285cefc1c4ad02cabf4e81b56f3f67b166ac79b317947f9894e0b71d43ec79ec66ed624ec09ab416ec6130e6b455219d657e20f7228b7a03dff6eda35dde1a973a5db45a3132f2fdd71227b0161290fc7bd5d7599978d55c2a6ec8fedb8b6b0ea3cd2004f3679fc15abb756d67630e0f60ced363f61448cce094f03d94379c82000759f65416a6d3ad634370648f85052751f2104d4f04f30da9d8bce42e751504993ab37c70975e9e2a14259d279aeb3c9b6746705c44eab429c84021ac07579ba49dc3db813a6a02cf32094095ed5f444758d772257a4955027e9e215719ebb16d3598598d82520a9d31a94a110281886ffacf90dc77313417e76049cbc9ddb09198202c1dfb600e45d1dc4dc626eeeef2a0c96023852791882a2401447b58310d2400a8a50b84fe0437364fa1b9c4ffe98b1a281a4f7a51898d73b89b36fcaca5dfd33e5682f5270fde75554dbcd0878d790719a21a8ef9f60c9e86aa22308e5abb06e1ac599f2f8eef31c969cf5979764586cf092f2ea730e8c58c25eb07815ac06e52e06a9d3509c7675daba4e76eed9ad8bdb402e7f330c46b7d8dce3001d4e5d7a947f7aa96cfa8482da824b7df8103f95c88e95aa9f36edcfe483f8efd3db73a2181cb67755676e274ddf3ac8e89bbbe0829425a3309326fe46c51cd0a4e30ae48f24b6cf48e8435c857714c14c9bd32a00b89b9f5903d76b84869ce523d5b2f3acc269120019b7fc0179dcc8fd9a2d16713ba17f7104f09bf9f7b7255df3ceb8f95f796eed24aeedf876e1da5c968cfad252a4bd1b1aa56093f3989521688a3679deb747fdd37f8ae86cf2bd9c4acb08cd19deac4154c6c85be9888027c79b07c30b590b05d21c5e41b23586429f80685433bd66e6d7914abe6341eb56efa3f8bcea6e2570d2e58896e7c1a66797c098383cb925f71f920fcb47a6c6dd7899022f54b3562cb6522798ee41642ae56636b2296f19b061d05a30b16534ffbff0ba16631c6e2d521803522bda7049d0cb5cb04eeb8661852f54720d0ac10f4f4a3bfc2c4feb4510fd1b4016140fa2f9cb74db6479172e327585bd92f04f915d348c0f4ece7344e13b13b388a1f816a6eb4302dfd17fc7f29567be9892c8bcd89d6bca0c94034305fbc02264fe093d659b2f3611ff1fdf789d55a53665e18803084967f4cf3aadc83e999772c610fa06bf0e17e90ae00e8520aebe7b3d8fac02a6db9c76e6cc429162b980ac2104caad47ba3a32bf67d1b7a1175c0de8720c8ac2049a54103e1a79bd6d02f2ef7a2d80bc7788f15d0ca8263dff7eb6a6370b1c4062311fee6fed1e595536fe8384a5e2ba30ae0b49784f50d3ed7a9346b1810e53d06d08fe9b2d2e4ecfc765af49bf529ec3a2139937bc817e4fa82a287da28d53406eb3287ff5af6c47c3c30e767cd12a071f64535fbb4eeee51bef0bda5114ae62b13b503de4310903e47df4f80daddc2ac7690f7bbd9bf03d3b80c9a07c66083ccf547eca076a58cdfc9b42a1cdadcba7cbec4e5e35e9344889e7db506f710b7e7554ab0dc1f788d96791302c1220db62fc40c204fba6078776dc4119a015062557b6e564d387dbc5873f16943d9e6b576845e21d443ce67ee0aa5d00fe3d8d6d8c8f54d50bd3f4db9fa569f64978985d5d183913c501a492857f427b9053d838837b9d6981a5cfb296d969522fcd384c3e652ba5a7668527dd727b02d80bf91188a39194a8052c140c67ed9a8a4476e39e2c319f5d1228f59add704b83ee978edee78f60b7c88816709baaa58d4c8bd5c28f168f73c5adfcec1756ab977f63fb1fa6d6d2163efc9fce1a0b37c3a8fe442b28a1bc12f49f0f0c3955fcfbd712da309cb2ecc1aca9d7022614524bb2e08b1dd15cf2317181e886bbaea9fb83ee138085cd4b6f7d8dbcf15fcf0e58a0ac425e3eeff5c7d22dce585da35855442b7f8f1734d53ec7e19332f234848d31cc1c2d933b9eb3d6bd749847313d02ee862964ce3b4d1437e77d0be628626dba7b7903981657f7bccf31a4648e970c4bf64b83a2e1894bc1fbe39d245f77ac809791510b9d946a3cafdeec9818e27df8e9a880aff40e7131c724188233e19e02ac77c585b2c601868801edba6fbeafe948dd66351ae06680144228f5e8f7bfd182d7bc4235718791e2b7cad8f5ca629fe422322cd2ee96a61418a234547ac603e83c61e6435cd8403aa19e83b1cca40470d1a7e4bf2c0e06f9d94a64035585f76fcaefac12181557cea5971cb98d4c4fbc9ef56bf8db81f800706d482a9380d9ac590e75f26c7ec2155e11ac07bc5e5a2e551c3bdadc5bd9bf359518bfe7c0b13f903dbc1c20e02390dfb8173242eba2689f01c83320d62eaabe9ac5a88a1dfa1a22ad2c837cc7f1bc5a0cc8d9240b538a44dc1996cf6af52152b4b7337a97e152664c4cf8e347a8f36353bda6dd5fcd45019373fde678f6ec107ec36ff30dac80ef62bcecce3dc8ca82cd84edef8e1577d594764243a7acf71f9d9920a7e28e150615f6e8da9d3b5582e90f7012bf192af89124241633cf34855057c0b30310bc48c71c727691a149ac1395a7b7207454ca628ed909bb041a75d1cdfb83d3477c7fe5af8f5a6092e5f9cd1dddcfac1820fbabc5b59aa62766b965288ed46411064d06b7a96a9e5f158a6d62a8eceed4fadd871ea99ba68ef9b3d3f1a5ad0ce5f45795d08e6de4876452328958ce4ed23001d0c76f55c01a13755dd47808e96074ce4203f3f1ac03c68a60534bf891d5ad5f3aca770ab0955076101c912f3791da23a73277a09b01ff0659e69cc4a3fba63dbfe0acb5d9b8fe4ca71a5c2f2c1d70ec2b1e4acfc22ea423f65fe260cab39d2ec4f7896d9a260eff27722be327e86e50222218899cd97e97c9f2f439069840f728b475b5d3c078e1fa74670301a9e5d336661bf9f1c9130828f919883684733e199257e2a05290a5437fc049b0e02c5c5ed498857112be4598fe4f3e92eed33e7de6c52260b555c2f25e13bb0360e9c78535092e25dc5e9b919fb97280cb45ae4cacf6c035e308c1e0f9b8b2f4dff95496bb31841fb4c0b0e329fc7ffdd448ef7ce6defbb29d5f4432b5bbc372ba4eb385c9d4c5e9d3b791f97d55fb2362861d136d7fa04eef159ff770dbe42d57c4c067e066bb9ceeab04a137c540db91ab13244c21913de0df4f252566eacdcb44fb295b5f27a77404f7e4a9c9b21d23463faf501bb904885e8883abf41871a10b9f58d39026e1f217f3b913ffe1ef3a448856826c8ed80f73964525c170a202605a4cd0194f67c30d30c8d18b41680e76a6fe422bf4e79be60ec2de331214f56927a43b6c74b706dea20907863ca1fe2f3c6b1ba750cc4ab4cd98cec20925ead4829d829ac3dad221877f5d20fd0a909ee48c5a90083f85506c6e246198d13ddde84a7473dadaf0120834749b4dc4ae3728bb07a5a525215b946ef5d09d079c08ffca22ee1c25b6198f97a9ea62660067e497119d5bdd9465176bae41ac22912602c1dc525d0087a96d21fc1b5786b8622572e2b1f2b546a34598c9b53be1da76f3084d2c2eea1b9ab979b43a2739c9a556173351344c56400a5bc0da00846ce476a009a5b69cbd57acbce27404367254b0a28ae15f248ab677202614c24269016f75f32e889b69d7dc4e41b91b57666e6509d8501342d82a2c7cfaaf94e3f7c63b2b9071e3fc5fc91f230f5e671cec1866a322d9fc5a8a9315bbc753a87b8a25d4c736c5359e3509361bddf99ffff1c9aeee986efad34a92d871bf4cc3cff898aad6b1067c72665413cd19770770707e9480f49aa45eddc420f7eef94b42ee684367dc631a91742abcd0ffce449a322a1ad198cfbb147afc9bad3227b8951f21694bcabc309003b1e42cc8e0df2d00fd1556979d43b7c2b7588f480d6c075594d1e3c16211f9b32c495938a5afb4f94b8a89758fb7b4216ad1fb2acb9f6835dccc6011cdad46e9e4abadc52252ab399b80ef97a0abf89651b4f86826484b5fe74c6fb2e28725e3d501eb3c874101390b93b32979740e0f472df905b5d7a85895177fa0df6bce57c1bce6c4cfac4415d43f280edc99aa3b300c4d891caddb27217c3735f5072dcd0850292893a78c9d9e9b4d805efab7b5d4fe89677bf75fe98a26dd7e5138809bba6fe74d8f4a8b0c30c24a54adc053ef7b27a3c43b85c4b9fb214972819888cb650737bb55944f8dc7686412a748c3ae4e67d9507b4e8e4e9e2f36ad48a168e91502a0ce270b5ffaa179486536eb960af128d3663cfeac987079d2b818189573a4e3cb65c7919af1ff24e579b36f89487416d3528b6b050ec1c85f8417cf93c87eceab3c09b593ab355f296850a3b61d6727899cfdec7f17c284813db1f6842d5d3e90d37fc168bcc05d4d39caf301ce4d4f5c25ffed054f5506aba34ac92cc7f148e9fcd7165f99d0c2f1ebbe9e46a2a2afe70ed1bf6559df3518404f51bb239c48315d0e8b5180e3bd618efb98d6a7b947f7a41ae6f6a906581c880c75b3c46f8edcce8b965a0ab9dc5183cdd423ac9a9f0d24fa2b39ac17302659b642fd1fe907081ae3f8540dcc366e6903a3435df210ee99a5f8392952765f119c2cc7fd8336f6ff0552a8a3fa2b0aa8743b1387588fe9546de76b1759b967e5a45429a014b590a53a46277fc077c9e2744d885fc3e194e872c4ba81a277b469d040ba7e1c8fc9a6839e7fe4339ddf396fe7fbbb8f5b4e61eba4092e993b05bfcdb3fb43e86f2515620350ac72f194c4a1e3a4842f183b58faf33a4dc49713649d0f9ca2eac59655c9ceb07d1e739470b2a8a628f1ea21e0b5f513be05615d4b6bcedd810cac5f52a8f13c3eca39205c8ca595d269f300e7caa913b1e399edb8096852956089082d1076e171fd67a425da8a6a58a6d63d3d494c254d86b16e25395fd50dee0e2b84e8ec5e8595cd42c9703a82148b7d26e9393670f6e0ee554ccc3bf5d70d4f7facd0e39b42c22138ed378aec155a151362dcb8d8338371da9db8857ed2ec37ea56d7770a1c272c07201da5328ffcabd472456099937af2db79069faf47a32ad98e2cb6fbcd34d6e7fca99a4e64945ddfb7e2805546c94454ca9eb2925827084bbe1a4c22dc877e98edaea384893c276e071fab36c9d3df46f7f3646430fa0bf72923c893bd59b879fd6aa978582945f495dfc862c7f854a43d696a70af3fe1d5201e5ef5c7ad2e0fc3bacc692626cc77d6082739891b45e7930ae7ed32856309fc8e5fd7e3af69de1f0628541f6a4d738fc1b54a94525412c6caca76708a80c154416c909fac893129cfb397a18c0c520ed6280321c955f3fc177e6882d9036e2e401dcde0105fb66160260ead72de058bcfadb2292dfe804fe61a7f5b79e6129ce7aefa6aa014fd6de960cc311531a921553760b07c63882c68dd405ce824008184c3272bdcda52a0ec612a97531b61fdc64b0d86f6ea25e1c861e48d2f82e89d047a76bf4e8bdd01a2f3eaabea2dae92d71707731afda85ea9d69822f194dbab1feb4fafe08ddbcaf20e331eebc5bdf169d75ffebc4b7e2ec9a6993649a484270365f1e8fd9771bfc5d9b0f2785bed594868a7b0e843c14210fead455c54b6cd60bb3c753e003032b65b92094eab3b07e456e0972141000c5113c09d9b9031ff431b28331afe37e56dad16cf07bf54e856282cb1918a271807f156d226518ca62f887726f13f822d82a98b7edbd566121633925edcbeb7bb636783d9e5e55929560a9448d49990375121cb6e8c17dc758b9db9e56803442cf45b34deaf814b13ae0af16ebff7796bd790ca2ba8c30a6566ee2422509864c2a8255392f38affe62c0cfe5254a4d6751f9fe6e3e04dcf380d556369030210236fc1c032cc8927283fc8604e9cbdb7117cf9429dd261eeee1f8917ddec8bb81b3f7bd9b3bda17514d32d3fe40c44e432523c14ed08955f9a073cc8692c3be405778f6452af25f97efc218c2e973bd1ce369a681bf64ab9a1056304f89c31729298770da4d55d9c540301947056aec278dd03c08be46518e273c1be513909ef2754525c9db2780e9ae905324cf933d6d845806daea38a23d778d39b8d2bf364c56d89626342c03e722c05f3f582d94ab0a8df4a12212ada09b8295678cdfb0e577558207608d5b189581a50dac21d842387c8944a003b00a0526fd7a3f72337c63c20bdb3b4255d1d3c406bba4c1aaa52498dca4ceb9f8340a368bf37287709d86ee1ed06d0ecff0bf159110639363f6c25f3883e7c8c319282d80dede028ca19e18ffaffce1bfae64c7bbbf0c78fa826d69a1555616792f8b508f3adb0506f548c57dc4ea397e55aeb69ffd2e6ec628db722ce048b439ac56d80c54f551bdaa0aa2b2c8c8d1398f80b99d2a3374965d7d547f64606aadc78609abd90b18f6bc11d419c3894ade478d9e13f386ffbb10f0f47def196d493fb77323320b149b59db737336d94df9bd6dcd0e778701d011aeae1cf170baa9e8cc3ee58bb502d8658b5b7d887f81ea6ffb1b0d132e837ba46e86b8056f360a265999b69bf6027520944e34005ce8be8f6f6af77a545fa438f324fd8c0f034ced8cd5ede2e010f6202aa26525e8708a3bb430d5e08c4275383639f31fe1a881961c99123a257a2305b0177837f549c70f57740d1719cf58903bdae07765af9fa0e4c97e5296d5fe0e6bd0681e671bc61f0d59f30d0b3d9af38dadf91c3cda740bbad7569c421cd79d4759cd019983193e4d6d12022e2bfbb3e2b1db8dfd002161233f8295c1871c926665495b5b0d78b336c9ae1b8578b06f11fe9cbef47168cf68f713ec0952d669728e5387096fde053b4b4aaaa9d74bdbf88626cd8313614bd6e912da9bb7920bd5264c654b4a2b45e0fe5aca834a8c6646ce3655c8bafc41d06ae03bfd6ba88da288cbbc07ef9b5f27298885dff6ad3a71c5bd44bbe2406237d102f28f5b494e981cfefae14f66623b59f4f4015eb2be0205beba3bbd9f45ef3d450b1737a06a6bf21970f93c71f3391f9b0bb6d9a1c29cd452aac30b62aafc58b59541f549b8861b38e913faeb7400a0601d94aded7ac619128b381d28ae55411fed275640635ac0f9cfa448ffb05598938f79f9b12c347f123f2afd1ecf7c603365dfd12f7b14e5672d8e6c63fd6d313df616f6f716abf9c9181224b435efbb8a789a264ffbbfcecaf15a09a64fb5fbfef20ca1a5d9b7105e14d55cf68c24dd1258889148fea73d1c7a584ebd38aa8dd06d314855f1951b66929d34f486d80d294ff21279aca77590b0da219b359f1581fc8fed75a2573e43872c489b04ad814c847d80b7c3d232d1fdb5d7d171bb8656a128281b5195dcdd87b824bd0d3e35228c47e46b319274bf37d76b70445ab5b56ec5da1a096dbe7d19ff7511cd9ee02cf21dd06fe5c8a1ecadf1d9f36df7f7054481569a451c78da8b7c50a55d28360c056860020ce3ce55d1fe7c414914b14ec766171866679e0b6a69fc71ce24f230ce53164d8971cc9608d616b88cddb44840be30799ab4020627ff89302f3b143176796fbea519b459cd61c0a61238bb2f7c7bb31f726f8989ff6872af449f780cb068f2bd8f845073d7b0a1486b490838ae04d55aa82bb30b9e6e7564f1e481586920f251f236d78f33a90344018e74958c0b27b3d6e260f309a8973f28253c66f14cfa3b3b72f9967af488de3284bb756dab29ba32bb4d3bfc07d9fb7de1b5b258db167df05d6230af58127d55e59723e253ff48da8675fe499b94e7fd59efe7845583371addfe3021593958be48dd95111a83ea68ac063f6799849876bcb05de2d78c1ec9e8dcbcd0a1909e1c43b2a70dc994fe898b90ce28aa1cd5ecb6b676c5bd55214ea922798e64015a432dcf8514138c66be6400a3a24146a3a44532ac4b6026bd1155d052c628d8afbbdaa86a89875475c6c2297ef272df055d3a350990bb555cc2ed811dae5108ac38085c0982fc9996d56e001838fd339b26852f502f5635b0df2c99e454ef6b10d41d1b33214c7c1d05e6510432b27d370e733f710fc6ed36e6000b023f80ec8bb8c61fa8d18e3f9cc8bcc798565278bf1fda1233275583f966cdca60f3889af89ec6c4505289ac218334889f1d33d479d60930bf54e5705018b16f283282462dad737fb882f024c6e1776f91fdb6a781b56f8271005d2c6052baf1a2bdedda16267a7a6a2c32d00a5f75e1ef34dd2744b4e0e56ac17a96bdc64ac721a4d19ef50cb88560f0a0e764824603c4a69e6b4e1485c7d9e9d48208ea551cc154973c8d5135f75650b7179656c3bb9787674718ab66a0f97a4600e06531a548beaf48fd0d1cbc40a4ffe4b39244839b7b22a7d66ab03593106b34e686f0857fa41041f8626c30038541631db7507c86cf5c5f281cd0ec5e45de2d2c9a17c767f5bd988dc2f1b93de178fa8629482595a04442c90e753c8646d18b2e639b1d19f1873f5084a2f4ca47b6cfc3032f82919675ad1af99ea4534890e7b0cc1514ef0cfc0fae5612fdd071a81fdbfbb6686e1303e6f2bd85c79ead135ab9f54de36906c2f76e0cbcbac17b26da34d795e1cafdcd1bcb10277d9eab12d503bfe43eaaad8598e0bccb37fb36ccf509bcc92a0784d158af12e35d9253acb2cd3febc996fd2ea7a33ae5c96450f43fe84c3a3e8722b2a6047a00c8d76d304f7f8f9a6f1bde41c9fe1edb586b249edb56e2d2524a19a636f2cd9146f7f2048099433efa4909c382a4c46bac264cec7b88ed9be570ba07bf75fcc6242c19f1dc93cc1120dd5e8de26921d7357d60acc13ee7a46bccd05aa4ad9f989e203a837552a0464b6473ebf4bebe30d6bbb55ef737149b141286b6cdd9a13ceb94df12130493762bab6fdd2e3328f1e074d20ad938579e38c4eb295132c55ce93bde2484157d3713ef602a96eb884614e70c915ba07415a7d1b1baf4207c5d32e958c0efa8d9c4827e7742dd98d8118ce5b675f503aceb9a6666df75bd892a411d5dc14c3bc21bdb296ab1c3225c7f23f1bf7bfc542e9c3192c341b58ac23013f19e25d6e82f30d93377b5ee16fdf0ac5a6ab0f46471c2ab280f93c6f719c56bc625cdaa3986402e9ec4d72fb286fb0e1fe38f874535cddd90312e33dd9c4a867245f7de4c1fc5f2b84b8a5a3d065dbd3ba75bc59357d42f3d42cac750e67138803e5f81734e1828676bb4cedc3f16106f118ccb8fb167a5f47906061a2b2afd9973aa25678d85174495ad3341ecc7d2cbf3bc9629f78d7e39782b257ce7de4598c4d28a5ec0047be50053b0b319c89f01f3000bad2ad3d4705d0c37e99a6cddc55758b5f26e47d2e9372679e4514b98fd50de4ed2d8076030b98b8bf2eae91c48ed66b7efe60cb8bbdd8584b4a99f1607a073319ee9fa5a6fe814c4b050579777d28538a4eb877d5270511771bb3065015a1b2904863f5c16ee5e66fa2f49e7d559ee9e5ba41618e8c9312473ba23f4643683ae7ceb32e5d496b6594f0d0f6ee130dab50f903a9d45130265cd4b44035ac3cd5ec60c7e90aa986f21d5736495118abbb26a753e2b234c7a4a16fd375210a5b3df66c7205d0b226582ecb0acf628c417d8f9c47f65c62aceaf4c57c86b19ff46f879cff4898fbc3640eab9543ba7bb0e7c614a65f0b539e3e4216696e05c0a2fcc7c01e59c747d4b6d0866b9c7408f5c714e3587415e6a012a31f18909b3e99fa67299dadc8a90493b5d7da53bf778f3736312044197aac07419d481c74bbdf9eb6d05e191a6c075cc683a2931004c3aeef1f7c3c4257b893a921ae6462b5160d5cd54991c02bc79d3d749798a138887b7ff5a5b8801910c77d85bce58d08ce9ba09b024ddaf73215576233b423351cad470f31d1222203867ed236943def960b661f562c196c5e79b8ccae6c47c702871bb9439b74fb1e95e8e3386f0df6acfc4954e7ec90999e6b51de2d163ffd041d33af0846a13b2bee7dfecc1ef7fb3eff35af5243f204acc2e0b2352be260c913d0a52f674dc37ad4367c1de19bdd0a5b8585809f422400028fbec991a726242531a72a1799e5f144da95fdfb72c1e4e1565fad549de8228ba4b7195c8102f73c0498a534d4f09dc9a424fb0afb1de78f678f55a8c3858fa41cc032dd59a3fbc38e115f2217c03b5f02422ab4a550a8d4b7d488fd053036b769c6993d06ef13fccd937253d7e82c637e9af6bb9ef3119732d95f7946ea900ce1764b4943b69cc8008ffc13fd854c766b525ca8da82037a26dfac46fa678782a8e7cbaa529fa38ea136124e486aa500dba8f58481ccf24131d21e4abfaa9c5ddbc9b6773766101582c3f19f982fee02c49a76f17842dbcfce68a701463c7a1b617989a712175784787813802c38dbaed8b52e4561ecfba0ccf7a1490eb41c62b955ff863e78984419f279593b9943c0e2fd4b91411e2d05297e0655042f1f2483b36c65da265d2a28c6b91682c19d140caa03caabac33d842eea41d5d56ce41eac30c995afd8d85bfe2d41608fe62f36b9bbb6f2e65cc601f40d016183593ddaf1d370119f46b5babbcb86ddd28e496f3d19ba437a8522bb311749577e1e8fccf1dd5a53fcbe496c2ae9f016aa8aa60ff6f05fb37b9e6fd3c774541d39e697551f43fbf0b948d099e59ba273288307f41328201a2ce1103fe3173f1cabae3d01b1caf52223b65d272d112bce25e85ad925aacc0fc031cd19fdef785eec82e10fe9685ad2c8f64229539ef1622f40200d37ba889d3e56e1b45aa7c89a40a843d0b6f6c0cd408eb6a155a366c385f621e3a8d88a013ac7e268c60fbd91fc1396bc7a0fbe25bc00792a21ba8a7ca20815be1e8a14ab75cbaacfa4da37c6fb11ddd2c706be622c93d103511065463e75a071bed035913a5c7a9733cd3eb4b60cb73c419650e0243298af74978f6b3c6292a8308864f767bc9cfc7a04791834a0e96834a991bef08457fdee2faabb3dbf99e8e2946ed5ff754908be537340b5113e07755ef75ee420125dab3f83f70753f3ca72776f6dd7f156d0b836d89fb5c5ac44e1586e28e5e5c139b9002fb729a9e80182e75a721d5572bb4e407ca62ab1fa92efc50b5823dc2f88b0643d71fdcf8cf9efc0513bf35adfa123e4e002c6330f6209c1d293a07e51a1e19cf78a484291901e1009b9c82d2853ba5d2d537a5f5f93a3106f2e71afb25fe216814ede0ac709612a630ec7376961462a7259352ea8fb4ec8be6296a9e919b379e93dfadd72f645db708c0d1b92e0cc731d4dc33f1caff6253dfa10eaac31f05d0f0c38fb58e5b18c647afb99a8599b87f101b196d3239322fa4c2e8303203fc7520454a42e1586b74d733733523a9a85a6d36958c79d19eedb473e6db3ce4811f49a1600551a9c37b3a4ca0223ee7395f5b9a668699eac8820d8fc78f9aecced577cfd12750b307cfb721de912b1427edb8a00320b1d12a6495da5cb55f858511ea64232ecc0fa4462d0069830f0aec8d4d8060c962eeb91c8b258519aa6f78e8a5facce03c73a96059fdd487f1cb544167226a804ca6ab1945ffff49d8c74f14e35e938c0ad4e566290cee5263baa6127577696240cb2a1a0539e66ed4788c45b4bfc1420adebf188fc20d8a4297b113ad1713b55b3e15ba1869ef86baff9e970af01cc06dfd3d78aba59c264c32841de8b7ab25be1a743a6ed929047e77b7554a2906aec7dcc9693f543aaff1a473ea1abef79790880ac8807da9bd5e0ff0d3b1fd8fc0834be5597e0a20e12077de41fd760a27e63bc027a72c665785a68dbc8bf821806063de884895c3a5082d3bce4068c2250a86e1580f263746eb4523801aa4bd31182bade7ecd542d991d1e33769b9dcd00f40c497a9ebfb547cc0c409c46054f2344ea78868e68397b76a97f61445d204305445523990660dad68c5ea3c13b6fa9f419cbe6c45de5db702b6cd4136dc13186dc725814c235491534ab725f295bd15877863f45cfc6743790171f651eacc329e237383e6cdded9722d104f4915bcc46bb5c419316faeae16aaa1c3d465689100e576613b8e368d33dc890792fdf915274ea794d942deb24cbf4a3bf393a13ad27baf98990a9e9663dbd34a97c0a38d4868d713f5a976ae5781e580ea8c5ec90c0c856cf69b39c618b58941eef58c54b2d193561a52861d9aa1c6581eee7616dcbbc568720bec7cf72aad40662b8bc7366a9f998f5ce849f355b456f4fee317d3ef4685b113fc854b9ed103596d788a069b833018dfc049122b40e68860f8651e3877bc11ce6e78c8b475280debf9aa3ba570bfc8a3b355bc3a921e311cc7b1d2e606faf2da332edb9c533cc1077d2268a9d3758611c7e519efcf6176cf3e807045a657d91b9f935f19f673c2a6bb05994cd0402a9b932380c53b6db0caa5ee08d8e8bdae831a15b2a267dab205e4ce776279a63b28701c6b7214737c6106ce59a11c75f28dd77bfcf95a6eb48a43b192e9e8df272abac79a7e6255c244e6ca7b7208aa8e636a349935c75237024bfb403e661ee4e9c6272aa85004b6043f6c0da7ed7932eb4b30fad51f5824e9ac93ceb2a714f976538d001360a5437f9fa6125672c093ed58fbed23c5df61fc72ca7f4a9b3bfcf75ec24a1cd4ff68fb040c3c108464b04a83f47df04ebae0158453fec785f29b33e4d32e18da427d0458e4c1ca1e7f5098cf66e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
