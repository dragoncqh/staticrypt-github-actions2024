<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fadbc9cb2cdf6e6bfed324b12a5d3df43eed915a59fefd1f990bf27aab886b5ea2571b8cd45920a188fad0af162a4da3e4b5f59e5e3ae9e229861b34f9d1003a859cc2a8ed7a86da20a4ec145a099fdc9c7acb51a930705668be0b6e7371869cffbb27fbdf7701fe3f7bb4e8a566c565e07b980f46f8446f677efd34a88a2632f7f5e58074f0dd623d162c1027af0de8abdcaea4c0ba54c93421e8bd0dfd9218f4e6fc974cd99e4bc5bdd66317fdbeb9124910307561b13382210a4428da55cd8419f2601c62abbbe0c9881f3a7654b383d674880f53e6a883a0ff1237f69748d0f123b9131d9b84cd3401f24bdcf28c9dea2c4e8d19d24a6b5b0e83f1571a25e7d68b5db100ac872983c0aa16902b4286b44a2bcf3cb2fc0f2fe98f435ce5d423074a4a1e91793052be2f2ccacfedd116df3ebe0994184712c070edb4b7787b157100b4516759257e97e65b3c92de8045b76643c3dde2d4d622b911a4c31325fd4fd18ee1b4d76efdc7c4ca4671c2c83ae0c6f0e7d8e6df5251529fdaecb5640be1dd0cdc49243bb226d4c6839ddeed12cf45c23af0e3c37d8301d6992e77d25af0298e54d65d798601230a44ba2f65f3335401294c53f1bde3a5f4f078b15a8a451b91d0b27507e5eb5d40bef728633990124782695b2f8b4a84c3a057f1fc883684eaa6bdb0553b6aa5448fa34fcef9ad6a69e906cdbaf2b5d54867694957485b762d682fd85c724b20867d61e4cbdd93cb65fa74fb7edade68e944dac8dd7507b1b8fa8a346b6b3be01b747b6eca00741a50becb62af1ec5909daaecd97d2e99fb15ccba7aa7fe1b77304992339735b4e37dd67190c2d267f4cd6d84f7f7f22eea9e43ded55cde1a48a26f0dafbdab380776c67cb59610b8d1ed9c013772fa5ab96ffffe0077b0f18141e6111bd51a2e2fa5455d6d576b41655f083e5ce70aeeea922fad4f71b2932887e742902ef0643211195990383ade22e0b8ea8520e83f3b2ca10b84bf77128903007f37c871a69cb7fc31f092e91e5dda9bf3b953380f7efbb0c5108a224437df8599794cee9ab26ab46dc8710d4563fa90873300caf10eb56bc20a0abd1d73863eb53462c49717c5c039d111f86e843d74f76d7ec2ae00757a2f85fb8ba7821595644cb3cee64e90b262ff7f0138eda556276e8865673e8780ceff9ae5c885f57e67af8521e12fd6df43a1e8fad1968fd7afcef1a48d796a06af0a3f6efee166a29b1dfdf7f74d4127a64e53151adf48bb091ee29ff37e4e63ab0d0e43099dac26efcde280e109e6131e16a1ac3146fba1e89d60dac9ed067106eef06d931a74bded761c10f95f7111060efdd5131a209a16e94f8a82ca145014ff8ee2de51c0978b5664c68d493886e04128d5afa4b6a80f0762f359fac4f8992390a48c3b30e77ec7265dc3d19ef420123e0558ab9644aec60d99b132b66d83a2ca1ac077adeadce6101f23b18edadcc06e2e0af12e9ef504c00a998ef304327bb32fe754027ceb0f8e92721044066c010b044fb0496c98c8bb62227be7ae5cf8c532a8bb1b55280adaab0ef7236f1feae04e725345e330a5e0562379d52c2af5b84971043cf5d346b1c5ad55b9ca232cd006f61ded2b3b5ee95d279a861443b0afebf14e1fe6048d17c73c832bfaf023a388dfd56f1e1a9be4a6ae9777cfed4c68ccce108e152e0f0c2fa665634b998d6be9c98940b517f32e06115f654ecded006cf75ecf0c2dc029a2fc14ae8bade17af99f747f3e591e3a4e039473d5dc4bef8e5b187bd243e6a978bb01fabf1e69e9a7a02154d8126d33d2a9c3fe4c079449585c3e440019cfa97a6e3d2a850d92280165858eea6e352f197c7c95fbe4c5573cf8f179b11b1770be2db779113c5c46e2f212f9d7f3a9ce93feb4d409550a11bce7601eabdd1a3a40b20146ad8286f3f2ad5b4cf923438868bfa871f3a0a0b9b337d050d7b51e5d6d8212f17e3917ef7addc6f103193922c9ae43700376514d173791176e2acd07978609f3ca7e3bf0fb5b6f5f728deedbca599601ce89888ef85b2c683741496115d8b0de911b08ef2099e02007e761cb0d52760db9e020b45ca7ebd5b4beaa5cca72e8bfc301cd0eec14e2ee2e985bbd6943905e41ba1a4a885dd011a1475dfd6baace589ae34e6dcca8404bb63d990c20bbe4afbf88085f85d9b1b3757ecd030a53a651acc4a71cbca3c2658bab6286d6cdb6fc298ce113c83b44ff2e91cd026cf803416069a10683375c69fac7d074d5510cae48dbd6c56f3905adf421a4f97841d22ba5f527440d36b778bb5943daee63cd1cd9f614363ddc55cee8f9ea9c50e6d6cff1e41f27b4f8bdf6c4cff829162bb4b1a32a051c8b88e965dfd21b82db6f6167ba9adc08f31f81b06b462e543eb63e60e2b3d1a11177d050e32f4b84742df783fb488fa98418a7a6a971c704c511333ecb93bcad59ff8b26b696a6a33669aedae1a819695efd90c843df6bc68607cc4cad4f5932d6694c8ec9cfb05e771f7614469e3f9b13d21637f9274fa9b33b017605386e5d6619b3617d8a46638453a6a4b6edd53adee2690ad3247868f617f4e9d49860b9526bc6bd20fa4e5f0bb6e3d4917ce2ae4fc2eec0aa2a7902f248240d60ec52af158d3338726d8fb30b2058d993a3eea86ec0110c590c163588099892983aa0c047f7583ba58d81c1f50611b2c845a2cf4676206eb3ebdfc5bf4b9a14c0bcd46edf79eaa49827143ec1cd432a371b653b03222cb465f405631b7435e4f0f530fe8cd41f110eba578614c992feb8c3e53cedfd645046bd16e812fc981f91860cede670b5d9ac9a376f3ef0e95390c707f7ffe2f7781610c81422cbcafa363df602dd526018de027b8d3f624ddd72c0c9aee8d45149b75cf8ff4777a1e766f7bb65e8991a9e8e5073c736ac27dc28d54fb086424d6c29a51b6093dd8785ce0c28da47a4b54107c7233bd64bc0703d0aa42fcddf5fc9b2e07814a6823a4f4b1ba4d18b60886b57e987d9c7930d206b6b012e07b84517bfcfb1957dde6f7e1729e9a5712fd2df719fc18009ce525649aabce1bfff5b836671058855762510f39c7c526705b55500dc4178b121895c3e33458001bd4df0e93b26972ed49fed0cadd11e535947c27ab092f04a69a29bbf78fa459a885d3eccfd4a47f013a794a4292bdd71e7aa98e8d8a8f4173726d0eee41878ffad4aa50f96160f75d21a169a388d033e784507dc69912338873be3b2f6e392f969f85cb4fc121e0f5c1a24d3aa83e485fe01acc978aa2cf78306287ad2f2f0ae276fe4697a2526a8245c3816dc039452c5212447f2558f74c712c81fb7d878a493a9476937bbc9af0d859a035decb182e1ffad1d9367e0550b17aa51e86546cbd241f27c794cd62923dd30c869de3f56de9825f70b19e5bc90fb87aef856871b5cdef899137fcf963af1d23faf0b7b90b557e2cb8490c63540ea6c9d53398707a602bd84c0f42996ca1cb86d7c7df9cee371fe0b559fc9df53e1a35cfd2e59accf99672eecb9a2a5441895dbabdef89ae57dd53a87449b8d837fc9ec3a2886f62dc2cbe9029a1f820f120976997dfb07a6bd5ffe822bc68880ef08bd018bb8d3448a007df8371d3fff3c50061f8c1dba64534944a6c7acd25977126777d08dad8cb369921757e59007817fa1009655c68711eb29bd84099ecf68723f7332771cfa43f6f7fb8e474e2c07b673864db956ccfa3168220ad55376396b16000399a91d4212ca8f31d18c7b763eaa856a16ea0ecb9964f332468673276a36a776c6216ea495999e97757520eb76856abe0871decaa2531cd1d77c9a8b00258cf09401c9a6d9d2134e24c9f08272eec38c75a0471e6dff20304f48bf781196b654a15b5f2f93485cafb057f8a93d5dc6c62c6adb7c20e3270e77d42fee0c52a2a79c5703b8df68616b9e3b98fcd983ba1bfdc2ee8ec71c1dc31246ce10928cfadab5d650150ce91d88ced1a74734fd64aa1cc3e071583026a1b57cead1bde23165c365798bf11830f72c9cab0a7e2d61653c1271a6c3ae517fea2e2e8e8a8a3add530a66ba77cd32a0b01a7ea83cbb3cfc5452c4322062fa5cb50e46bff4f6b018cae7293d0ea08edd52967dcef63499660db897b147c3f6cb33f532e30844148e4780c2e247c187eebd962781e924a44d4a6c978434c05845538c0af381178362652c9ba6ebe9fb2e46e7278fa82d8f0be6d689ea492555cdeb62fa5db3a4d1db32870df6c94f4e1a2c11996e1ab1445f7cd520284404d20bca73b06f14769819af087523b9ee53cdf53314a643eb6b4c427ec03feac871937f1d0c2f087ed93e83e51db4888c9149901491bb834eac21d3b666579a91c3ad522f9d13c9b4d2bac7ab175184515fcbce0dd7de8702ff7317904871c8d8e5cca3b8a75e86abc316cf62e75bd6985be499f9543ac206dcf207e3d5f68e509181a4ee9d43e6b2fcdb76d2321f93936756177881e5cfc1a4f0d769518dfee723e217f65e2845539a0df6515b8c0a1df760eddfdc32910f537ff390ae0307146de936167d9478375687efd90ab96b2e609dc956ca8ba0af814ff04394bd676107a1e715264dc8506e6f38a6425b679242041b413504116acb5eb2659d85d9b4f22bf43124794768fc0141dbac628294e32658b401a22cafe877d0bd0bcacbaa6ea5e9dd56160212d71b58931328727ce89663f6d65bd3dfe3fcc01a3be3000fdcc9596991163fa0a25389c6842bea388b3e0267bb78dc49f35f69ff19debef7978303b866f62fe156bbe803a2d467f1f7a497d2ebf47ad47c12bdfbbb321b7c577f31cdbb669c851400507d84a58f061e516323c1407fb47764bee18c6e5f7f198b8b05a38b566695ee1f29687342f9efc8b738e3f93fc255ec14be77c8403bd7e9a228d7c92165885539facbf7efb64964c51bfae318b7c97d35318f863f7442caff29f5ef619d7a3d3609563eb1002586849cd81e7cea54a6fcca6be59bd8cef56053cd3169318bb4d25cbf0a9d7ca461311853569d468f56f86a2e3c501e3c07221a176ff31403717fa97e93fec17450d5bf27b3cf7f3a30485a022fcf2758ef5f530f344f59af14bdaa952d763333e6d8ea8018d7c91dc0cc7268d0b17839e9a28a8dc0e3726dba8041d56b775aea0836f76c7a41a1dfac545b879851ce6fe8f56b9cc6d26778613ac7311ab080f05573337c0953c9e41ce6f67d678a408bd4040693c6427be99b6244e8bac127ba52f4996c17519b887c636a462204597d17cd6fc0729dfd770ca6450f2812950e23cff59f76bab747a7862edfb944cdc8305a36c92599865b68e980ebf668fa67bc5738df47f343584b40353d0e62cef3c8cfed2cb1be20e0a70796ef14e08638cb575797b6740417c2e2e6da63b292d52ee3e7841d8c0480176c48c2d3b6bf8c7d077fa9df1b283a181bbd979f0ff192c9240caec4856a385bde214649b62706f19dbae64985a53074d7b51ac08fcb7f2bcf1988cb40ecc29bef9c2c4daf45a1ab2d3df6da350db0fd343e0097fc12206a04d291323a93990ac2123a4e6174b1b93afbb4e0a8267645281619f9111dbdf796fa5f3f7ea611a010dbcfc961c5c738ffa7d093b84a72ab893be5ab7e88df6e985922cb7c737354b2fa47b5f6db29683d4e205c624e81815e9fa9bf2d7b4e79f23371332ce19dba4a42e153bacf768666e64d4384d3eeab680e313a0181cff0f9b7270a254646494237e3eb9f5734fe3a4a39e4d7938e1e2a9a50ab6729f63e84083304ec1fa9d98d442c12d415b7228469b7e40c113250665d240e5c9fa729687040243a0a0fcf746e77b41dbb98da812a1ab4dc4d05ccfcddc9f7a76613007a787e6c63f9e55e154f713d5a7a6580359c48278b62c4b1a3cd095a36c33d4231d09ef4b9cd6dc8f37994b3733e070b55fcc46b435fda637b6a38cd2dfb30b3073e5f9749835cf8d6617d39b61ab269601e95b563d674916153ccd368d1ed8a13ce5648dc43240543fa92bc5e6be30fbd5bb9321b410b40302a3fac0261466aae22f766ed621b04a5ced00496d7619994f9315a294a49398d19039b983d4a142db779181cf4b756c30391b52504af533be640c6340477ec719fe1d307a89254e6d1681e06e433258d6b9308228ad11a9f6e5a7d961d481ed7216d9d63a0f93d3c71350af407c500631541db5671fd29eafef5b6c21928fec3ab0a0a72489a4cd0cbbc4f6130d726a57b669b262131b40ea20df646ea5887420d764112978be7456630b526bbb7b18ad1ad2caf3a22bde0cd6023b0bb6815434e57670801d540626359e6bd33a07a10b3cbe3c49727500f68c8df4e605ffc0e47690102b78a4f1af929965e3be289a7d19d392e44a2351426261515bd692aec95137f04c9190117bcf49cab3076931517cde75b23c3bc9e9c694f48ba10970787a95beab6a49245353707ed1f7c2c2031435cda19510fabe2dc50a110c75b51c1de039665265c9e83ff412cf391d35043b8ee61c6b0f403a237171c3c987dbcbd398e4cdfbcc1581789eb237e665277c9fbbb926adf843c393968c1f10ac6edeaa95ed718ac04d09c2477ebeb07f97962718a0477b4fe29d69bd6914b9d2443d48f80358cae36075ad23fab94be3ff5e0c8149b392f2d07c15742aac70a5d89511dd131c20897aecd2e0477bb1eceeab8a70a7628b4911c3a457e3f34878709d7a9ac94293bb618153d7b82b2a2afdbc72c42cc74d07c60751c76a92db9f4fb9dded44ec8ef1cddf58f8bd035fca28e65d70c3c5760b030ac3afe67aa0ba435f638ab1e63bb7aada37e2e635f69a65bfecdcb4bbd9700805a9efd4f34adbaa23645686203838909e17a85b4dbe9c7bb191414b46838b92bf85bfe8763f1a1405aefbc6f235c8651cb553cf93736c1d79c1aad55d5b2b70f1416eb8f0c2496570678520a69398a93870e4550149e61be9e702a65ac340b930031f9ea5748b95e4e747569ce5af32bb25e730c461114ef3251a96ab12b63a338171d8cdcc984b4648e79ba2c7ba8b5e372bfe65902240303b198a197079c03d04aa9b01fa0c63ebde81e2724cab0acd6aecdcb64742176f7657599bbf21601972d072f2a8a29c8371a4f6e352018ecf25f92bd40612fbf1253e1b2abb83ed3f7ff73d9f9b85af385a94c00db162b5c66b4b84a823ca3d9a0173a06bd91df0bc8643650f0e12e18896e405dcf73e4157d5df5402dddd7e13836458dd98b009f65576f28e031c1f34c9174dd0edcc21d897821de44d0b83df77168240701e32b3bd217dc0645b157a605ced463020014752e45acc6a87ce300f28f2a97d3dca1f9fc7a514b4c8624dda10b95cd721aa5c29357aa2cc6ed5d41978f5f9435114dd6a80a0934e31d37e159afa4c297fc3c275f8648099b6e1c3b64c7a28f9ee217a07d269a1820e212f399d4476f4fa954d72b6776c5b9d892a4dbb33d7f75c8b65c3d83be4fce8738b145a51674a3dd07aeb40de9f08ba0408b384c00c6a480a23b7ab033e716e077ddbab8f113d6c14f91b621695e55ac978e461576f557dead6f93c0f4a01294caa5d174c279f1d7ab7ce4d1ccedb21153a59e95de629ceac13cfb6d698b86b9c4addcd922e8f8c0d130fcda889c4cb89d26608daa36539bee1945d890f68149f949de079e5b40e72ddc1820d0ead7672dd7d16fdee30330ff8a7413cee2a9f11478b5fc841edd5973db5d70b3b2d217d92340f2d0a7ea6b198f90890133cad9fb20a79a677da125b065bd95fa665303ada44a0c422f867842963b52d7147c25a9ede907813397a191b32022fd9ef3f32a3daee980f73975ebf0b6f95091d1a274ccc0103a2834a6ace7167b3ae795ae88de546468779fa76fe30870d56105e041b3ad89a5c14d6181605fd74236c5f5002e6d599e9057d8a9f006cd10aebd21ff31e52ebb65f1c8a62f6cbd397182acd3315ce8585aa49e05e34921f0c652895aab009113e3f15baa3f4b59a026a44574d62bb5390a6480decd26a862af8858361086a8ff0ffda35fb89162147af26e9e6cbca062b7c7fd902ac6b10e41a54d1a41ae9c00f0a3ffb0be8392b76fcb2deba9eceef899a9619c773066b1b4ab5ffe1ad98dccd91c62b11290689477d96595b3d265a406b9348601bda7b539f6b3562391bba0e9a81b5e84422a79c5cd8201e0a1b61e5ef5d9f99ff93bd364f70596d206da3a10b6f7a0a3c1f03ec055bd3015f17af778e3c67bb05ba09aabcf701b46ef1492c0837305e4ab96065e226d4b2920e7c40c6bd5575fd4db1fec260e1805537f597ec5634b63a34d586c88bb37795c7bf5d43c34fb502c3c1fbfcc66ce83b5e6926b9ab80c4ab85ca6ab6320ad2fc12df39062b68b251fa6acb9b24210a2f8e9809dbadaa1a6f017e07c42378a8bc6a3a3d4660ad671444f67e6bfb76095cad9479bfd62fc681529d945727e90eb1b82de6f190da257e9047f5b7021c126a26833872eacbf77da26706b2f0922497d0482089dc8889b96bc5e3b08c61571af860b2f69fdb15c8d810f7ea568ee333326a0b7295bb18510ad2b08e05d7904d8c9eb19bd7e2dbed790787203da4d5e08af75aae616c9a215c3284b85a0ca01f1aabd84035424e66b8ddae5bded1a86dab77d4528fa5bd3c1aa32dabad348620ceb8dfa8d9749efd716ef456817c7e61c5ace9982fb573d43193d3064d108c9033eafc3a051db4036c38b7a2fb8a9d14cca9761e2483e1f8818e7b0b969a5dee47b6526bc7f24e0d8844cc7b695413624dadbf0f07ada8f5590d243676589518153f5d731fcb02d5d292b1f3d39e64ef4d03a1a066f7cd2dc011d424a9eaeaa6ddf8c1c76ffbae530888ace5505055c1243ba6066a8f4d768912938a2e057f0412df630940ab6f5afbf9f60c102d5e6896b41982ef55a4b76548493ea85612e2cddcfb07afbb26c447e5b5df27a1ec0525ea13255215c827006a8484a74cdab704af8efdeae38f441b9f0f56d583826ff78a5083beccd0ce419a2116e376852691446b486c1e08ad8ec78f1ec085cf1b57b12e35e65945c72edacabfc311fa13e7a379afa0797b960560e5a1c4762f8c04fecf948c55387f987fad2d09668c652c268944e736703a9f5b00abb3978be627c345c7b7b23db392b8fa13dca4c7b10e21529b609f4230a5e1c874765e62e44bf47516f138356de5f77617b444def978ace54812606fba28a6e873d7e8f310d60e280efe6119562949b331839bdd6838bcd2450831e4568f3013f584df497c7084df0f4aec324ba3b1070a39065d54ae9691ffa7d65e10d67a8518d186a2cae4167c9239516ea73291d85db01cee1a1821f4ecca0cce9c95157c0cc0654a979d4645a201883d572da620766f5671b2757e12e0293488f8768c7620e8aeb65cf340ebe8e9c3d1285b43048b2ddb6d3e83f47fc170d5ac05313f9243b673deb6906344cc9602683e1568ee90e7daae976c6b4c67a9d5bb6e119098670973eb9da8943e9066dc62ede626ffac9b283309f6b2d0b9caa5c4e3c6bdb0cedac69748ca5b7d0b8bf2194ece91a5791fa157fddb022e9a40c8c51a916767d32cec7204a61d246ea6d44e8e621abf174bc1b0fcdc59a1374d6f8c409160e172bbe9d986ecc17e114062037e34e87a60f1626782d220602a9572ce4e68e0255e47b5652013cb2ecc09b02ed7d4882e8a298ae38dfef418da5a2566d456863afa1d057f2b9c36a35f106516b3483ac20a2732ba9f2e17636dd2b65c51912c87cd4e1bb067dbdc677e1601d798c3abc59824b187005d539a8c3776b0d2f8e258f833455c54e37a7553278076331067621111cbdaafd0c113cc52086af8eb9242e80922d0a2365af7981efd3f0ea532250c3b0c239458d6986c3c82570d01b150b498d7a3e1d89067c07252717eefbd66f3d2719fdcd2641fcccc6cf7a043bde7446e5a50c2a81f0a7883b22e046732786f9283ac188b246836c2b94a1c364afa7a06886bf3379aaf0dbeffead82f7d294d1544ce51ebfd41e650407b0da362c34c736b7bc2055fb177dff797fb15d7591fb5490e53ef801d656c357e9f9ba901b79de9d24393d1a6979b3a69c4af3857d4148a22d1d29a306ecc0240494d41db30513fbcb259c7c30a7511035ae8a00eed0a353323ac0316ceeac7a0419364911043bb8943eeb0379fddc4c0f03317456898388af6941170dad758852cfe1686e56b8c2c7350996976dff06842cdb8ee597e266256ef6602a4f46e3602e29a90352f6e94334d4218520cb30e699fd6f02e84b9e8d19929892b96e09ffec589c766726c8161326661948f72f990af13309c3b77e4d7091aeeb3accac6cdfa0b63bf0846b6f42dd8a73f7f7304ad5bd2b006c5706c5c07695b5f9eea256c0b5f86de99bfa21b706bb1534152c2ab202531138daf03c456c5523b14e54d06e554d3f450835712156ce7a47e0ca4156949c9220c9b25d7fd6dce2698fa217dffb2c95c38a267eb832b377cbdfa03257afc9b64a787990ba1df1ffd2e104053a7029e1d6c454f2419da9755a7ef5e6a36db7bbff7227c0b7ed0a07154a31d04fdc3c593f5a823fb6d2164d5ee547c6e3914d6bc05776bf203347c9c662ac3e433a6dab21fb6d3cfda1c1288f6e463ab199f5c8d56b0cbece39b7d4cddb3dd6c6c97206cb638128d3fb813b5061b4662df358967a2c126de1702b66f786a2abe00450cb1013d848e46239bb98c70b84cb9fc0157334bcc6fc1c868aa295ef0c6217f5a1c1638eb593ea14e2960751c9e3702d42246cdac410952aa1a6cb745a5b67744f78906eec680a4437c787ebb20f4fc6d56d786227dc306fa436189e0e5375f7bdc119ed2f6b1a7574193e8b9e58bb6787f4f53e9ff03d92cd1398c761354bf216c702821d9b431fca9e4c1cd41110cdc9a18b7145a1d8fe0331806f99dc458d7ddbb2b020049bec61fd98daada180ee8955897e96fa936c64170a47a9c3a95827cb0ae68a0ef7ec42ea5aafcf8e2b6917b5a9f35562e36666341d3d1dbd670c27f846eb5e0d02ddee59cf87cccd3c68d3c55db25cd9955556ddee367f915af42e0220a429d674887e7daadf31b975acb6d24b40cd45192cfd47987389fd65318ad76d735fdd6ef38269f13f081e64d595b0c4b72aa156e595ad2713ad872463d51b397a2b41f0ed6cde95d372a6690a33e2dc95279266d776a56aef75f815e4d033bd93d6bf58c191683d4b263665d861230d603363328376e6cf16a0c70014ceaaf675bdb6679543502682834ada5def291774317c1e7217f8158d4efd23d6f289ce6bd61d971916054981bbd804ba4d0a9219d54c7aaeff5e2b5e87dfb9d4d3973addda3352e8f8b5b18e2cfee742c4b5966473deffa6bdf51230fa01d81ed4e414475eea1ebd5ab772bfdbe62ee8c2a7d4e6717043a7a60d1f21adfdceca951ecd424fd095b3c8d4e979832a50c19447ae0dde805a740bed774bf4f9829dcac2249a964e7d2f3470303092dba051958603fe024da21d8ac61fd68e571ac50070103ac24b2f3f2ec1d94315530f8dd69ca3b1ab9447b7fa02595158f4060a1fc5bdfb361cdd3bfa92542f2a051c6fdc4d031fa9fbab8852e5347702c25864ba102043ab671313a2a10bad262a12929bbadf13b63072e801ee577a43b5f6866559e35919da9d380e49f1bb8e85c8485a607a73130c81f9de2b1a4870ad4a03a21c8c9a633a025617facc247fb93cd7dc44c83c2eaea69783e40b5b4f1a58e8253579b36d7b1ef5a9020a81665b2cf3a043bc65a74cd2a002eff242613a401ca43ffe924781f9ac7112799946d9c850e12e3fb523cee8e1d4eed0b14470108eaadfbfbdfc7af288164605fbee8cb71c9cd99192f8541206f3b840d51e183556acb5806b517019d8b6d7a74787f66d7da5de426ab1e36de616ab168fc2ba6039ed668c1268c419347a2fac48f5d7b801eb4bc83b0c0d4f8b10b1c0ddf94d2a3de5b0b28d3cabc6039844c59f5a3b8e6840c0c4d30d235d53713176b88e0f8c743219dcd942118eddadf11ef1c6f8e822ed4aaf0a6dd86e619a34a4321bb15cb19309fe97c6d47e9632d405e8a377e30245d568f709ac5493dec9d71d2f7f8311da876d8879ce85bb1530eb9aeec4466000b730b706045b55ddb964452e4b810276968ba6bbd73c7366fb5a31297e5257e93c3fb6b59e5d681b0449883d7e779b0c79a654e37350a5718c262345ec99e803fa31d741b178ff6dabca46ab5427f85c9e96571fb5faddacc931e8128a9f579cada50958bf2d011f5967448a66606a1cef562fc4cae8eefefe755459215913e3be36a036d508f3ae59e4e86eeadeeec3d93b73cd0930fa76d554b4fd9d274037c1eab1c27b8156e23bce07c9f0603249f8362e655a8127317ddfc58ccf3468ede34026d0b73236e9160ea420cd4eaaa547a1223d8b0f151a450a79aba8690949e7fff5c1921aa159d5f6eaa68d36cc28b62a2df54431b4f7560f0dcf6a74dd4b48b92b59e134cc76ab80ddb26b2aa57990362141effc2cc71f9a290d90a7a5e54ed94838703d1968146617776220d44ca08bd5ef4c91ec022010ca1576b6905fa5a4909a063d4fc8bf68198d9dcd6e1fd123d8627280aa9a47ed16e46e7c772b3453ade8b143c300fa0c446b165b5152825e6364b311cfe0e48a548e01a4cbb9a821456a6df1b3169d387a9458e88ee2708d99abc44e744efe252183abb8bd5be7bb24c17f659dbdecca2673ea38fefe71ea12380c11db7dbcdaa294b9020f09ca446673691b2fbda8181612bf8592cd16b8125fea6c7968975da9021c460991ca09056e1c0f07c572f56c2eda6ed77c57de078b6ddf5fbae4892ec91669e13cd4ef9e9b6ed7e6306fc1a68b370ee8bb88590556719dbe2b53e7ed09075c1009456e529cc36209212df00a6bfb9d531d0d4656119f025e2d2b79584ffc3aceb8422b6879f39a39170c2c89c794e562af80611e9eb2193acb17919400b55ec5a298027e798bd242062b650add86a1e524a16d4a0eaccb74cda6ac6bc90006dd7be194f3d367e09f91f0d830fb3a675db99dd8859ead5028e3775f2b253c98eb88ad7b44c2d9a07578d35fa475a2d1a84f5303a4f4196ebf07f2b5d9401c37df70cd0b9fe642404b7fc76e8f3a1149239708f7c4eece44ee9a91d9fe84058f23fa9fbc88dc36c776ea1f49b25ad5f8b436f755df23cce7fa79e84a60a69ebb47d5df859994f07af6b34f8d48ebfb97e866b9cb9cbfefd6be193b56f6c2f2da204e0067126b6069cb5a89ddbcf7257f4f6f47b5a52ae300dce634576780b91f0ff4038aaecdedccf5fed3c0c17feafb8790c552ed9411e0c9b6f618c61f253f3a4dbbf210f91ad0face1f6626bf9d3eef47555c4803719d67543f3e914276ffaa146a3382ef4b1dc4ce090bae030a01e55e5f54db72454da51c088d72976a4e00031ce7692237c0e6fbb1e801a3b5e0e7210b29f048676666a754475396e18bc2d8bdcac89f5d6cec3d7cb7b55c76b499d67da7f45101cce23bc3c16505f90458d000388a1df3030bd6853ca0c2b2293ad33bd8bd2dc9932407cb5f3ca6f7cfa85b81dcac96a6a540ce077a341186ce6bb334de1bfa41e7984a1a752a0d8eed2ff3ec83d5814d60275f24e3a1dc7aa155a606dd1c83545e5c13afdad8c636b9e9f413b4ebdf5cbe1b949cc0b78aec13ebf2ac4603b319e17b9dad09525a1db032f1fd85081da899dfdf08ed3547dd15ed32bd0fc7d16322f1dd778b05be138c9aea4b0de8c34a854449419465ad787ee9932d3d5d9ec2d9203c3ec6ca379787fcc5af95915cbeb328c7d1c9bc6ca7b9139d29dfea8597ecc0d62090165ebda5d74902f5e3265c5ff90f814201c3c0d0724a4d4f9c74bc5ef808a58fbcede28cf2bed29c3e40a828ebaf10b0fc2c43bd626a8f1c89bfd762e0f7f47130c08c0a06c47d3b124459b79243c7bfde0ccdd552a02afe7c5a873453e84ccd9642aea51456388ef15303e8c3b7b4c9d1783b21f56001c26c5f3952bca47efae2ca026005aa4fb76f2449b9bfa084aa6ad034efe17fd6b6b0211dcd4c8cfdc472d2bf15555a44f3282c5ddb738e4907e295b7bbf9fdac681b33889233fb9eb554ff6253f2771a23c9051a5a650bfca17272982cc2da18d89d6b8ca65078aaaa25ab68d334d24f4e3e527b6fc91a1c04093b3a1d8f46063a104b83c36d357836fe2f98eaea7c6d6d3c211d6ec3bfc66b6acd63cb675b2f204785bf51386774c17b82f845dc62d8ab9a4eb04b5bbe7d6ec5afecc5a33a46909db0d361e6a47f7dc041eebd0ec24fdab89ea9fa386ba2f02618e103d9b160db6a2c3df1fb1526e029136487dd921bd08838a60bf3b570930d7a93fc8f988b1bc4c526c811e90510c6fdb7f9b589822fbef666eddec7125b318bd31897c2946ca4f2f613130df551b78d03ff46bdbd40239de1aa9e82ab7a40f515e10adf4ba27f3a283cb175db5bda610e08ac454a65f5927f97aa6887ad02dfc6caabb179485a371df06a1670ed897ec56d4bd868c855ec92432798bd4c7efe64dee4ef5bb7b3d1551dab7f32c34f7c0e3ede394250199fa76e4552bcc89b5a729462ff3f07ed3b3e5a32c70bc75ef1d77bacf3581e7bc2d8123ab9db83f891f191c9928e08bcbfd2c9422feb6488e9c55eba2a9c4dbfd6e10214033e09b4fe0ff4a8cfbf3ffb81d01d8ff192455d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
