<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7005df991964ed75659f7934ee1d594309a9dfd459893380c1c43e4b9f382f25b65c83f9ae1698e1afeb31fa43f8112044a99afb06aa2aeaa929c6a1e5c7d76fbaa1a9776b8e1057f0ed6e48c2a981c95faf378df13b94e3c2e2c8558d07b41bcaf874d8aa48437361598b407e752a355b260d1a954ca89d6d33167e72226dccd9e429d45724aad896715dbb64f8bbea5a750e885e45b3964737b15cf976cc1b4b1415dbd22af72aaf6e1573fa82d2fc14b9f5aeaaab0147ee114cbe682c4ab28f70894025df1f9224c8cc47e93728abd942ab7c4d013afee5826c471007a47feba389eca9dc592423df03c7a8b3af60a6ba029da17c95587ab5a34863a143ba595588fb743abc25f038ab01edff5fbb2f95cd9803a0b1d302124c40806bc31aa9e61e318fe82639ac3682cb58e1d5eb1f5fce8785bc3bf678e34d35b724b371f0a40fbc3638a5d7e2a646d60a5168320ac36d68993201a92e7e7ea62a94d8c361e5d686601e0dab1505673c878878634058450ea02a8aae4806679cfe2a88d066fbe37aa86fbf3c574450bfd68d5b88c599dfaa59cdcdc2619c0b447b96f8d0aeba0af41b18b8606bee522a5024a326c97ade1946e5749631b0c00062f500182b669a4467c35d203ec4441c2c6f67091d32437ee9e40f9e52de5bf938615a13eb8f2c87b88c5f70e58af99b12593fe848f814074bdb5c566c05eaa2ef4f606b0e82731f602cbebbba9952f241ae2c01be4cf0d7ae2c3fc1e6baf87876877489137297e7e0751789f52f3a2bb2a366cbd91b19a6d9c0902a134e9a683405e223ab6da65194ed016f73524428c238603725e9f1e9ca6bbde1bd2da591266188d062c9fa046722697382378e196da61dbdd9c9bfdba7c918131c7bebd63064a1aee688ffe2df53abd12d9e81a7875985dcdf4061025218036b6869c7e29e39cbe89a9e59f2493a80ae475762c85cbf4ea579ae49f0ec158a97901b08e7361c3004a9ea2c3bb241e248bbd9be5b1943f85c1ff8a6f82e4d4de1cca7d4f3b328c55c028fe36192536fd48557cff588d834be7f76159f6ba75124ad9744a72ad81f2fe9c4cc78defa7ee8fe49623d658075e5afbd896e02ea217230da936a7a8e7fb769769bb1ca022c19646ce066f81355ad15ad10e350324a250a8efdcdf65b87b1c10d2d3085fe44f9159c7b2a18fe0323261bcb9fe7132909824da2cfb4560cadc991389ee1f5553d3d3c078a488003b2fea85dbff345cde9582e8ba7a39f4c887e9f0975d12f288d69a8b23bd637c113ea0d7328f5c5885fa884756152426aaac049b749c533b2f3dd4cf3c6b071e17bf171a3845705d0ec1ac096355bdfda1afb8120e0b7c56ee3faac97e5e551ec2503f4df2c608c8f84beeb2afd2e0bb38272fd06d789ee542b5d3d785c7b228cbcd184ae5cc6e7ca07a87d49b56b20ca40a205caa582810b4da3d4bb071e07a706499c8be829e1d8e2fb8079000616e4a6b3b7fe8c6974ef83915eef0eb8a292d7eb9c0836d7bde8209514148e4f42866dbef063e1207ff137893d33d989c8b45949f9f1fcae2d8eeca990e1f00d24729e2b1eecfea912191e76da6545ca1941ec0b01878900ce2c59437ee3493da9366af46ff318b196d97f9539f04abfb34caf7cf33e45b111abea1a8d8f37d11e7f47706e7a725b552956e636a2471f535b254de290a24efd571a8bd7cb3ac2d010bc2cbb912ec37d6173f6805a308931c9c627b1cb57a176327d251cbfa7cbfc51b45376d3fa2ba72844f02e5ed2f004cdc00c273f5b02162b365b3d8c4b2b9edda5c54eed53fa0debd508ffa0bfe865c8ebe0f7dd4a26e935712efb983bec712987e251a9748c94e3ec569d431a0a3b85f91117970b1601e1f38fc280556fbc278b6ab9cd0b9b2a7899eb339cbdaabebacf3b51850976d76f7cb430668e48b853662ec78d74cc62961437ed7701dac3e813f3e8207950463552eec6c45066c1cbbb48322711342b0056779fd80130f09a3b098bac0e778d58d2394437034f40e1e054a241b746911282b7373ec83697ef0faea8ee592422700ee050557fca9ea69dad9cd05bbefc4dbc26a2102c44595aecba45e3a2b3f7b180ac9d2b99ddcc9a94f1cfd808f96c227f043334f3d90234db67f0d71be5d408ad2cc184dccc69b3a43d70c5b5fd3bd0000564c8862688669b0e905c6d946f6205535d5fb4b68e5743b510e167d165827037c28e5d59eea2a5ae7e1ba4b1b35302f937214de49b9ddd342dfb0567f7dd38f0fa1a8c4842c3bcb4abf3be227ccf791494a67c6c579bce1b803e4b5309bc1eeadabb8de688f287dfa9c0c7df8d4b512f503ac6a5e9e2af5d549d1d3ed88cedfc5ba43dfd435d9e4c5e4c26a1b0089d5241e4b40929ff103c2587669ce9706d4d7ad8d52a536da0adda4b2db78006e190032f5e433b5c4913631a618f884e77731fa2795c9d78b28229840831facd48d068736d6e0696e6ef6c065265661139189bcd1e1bf98c91762b458c1bc6e4fd296fdb52875efe5a9807e9c181f8213ab5435af29f43d2cd9bda06b2dd9dd7c8ab451fe307c69c33be37429c59dbded78df047fb3e0f32df771a39a5acdbd0863b5a0a5bba3ef5602aa369742ecccfde89f51a0c64a9d1806a29652f0203ebfc7be2b146a1fe4e61c196f6131b2a50be0c097a2f2feeea01da10633ab8476cf92d17bf7cf8086c4d4ab472332fd3b689cd47eabdb9a97f35ec8d7bb92c1493ecf89bb2b612dc547255300d7d8570a51a580794867546a1b4780d5392b28227edcef03619f64970ab23b306700c184ea7da435e833a94b022cd15ae249fb29cf9dd1f35bd72f585a1520756c152dbdede5eada1edc87742bf5c5b62f08d42b0b3b3ecc6114d257d7339354e4dcdb1acbe934a78615cd09ed4d18e27bc872840c2f6063773800e0c706bddc164767d0507da6aa43e1666b83c85806515715c84373d81627cfd1a3f303ce3a1c9580eee0852299f63d2050879e199dd2fc2e35b10f8e24ae2e4ae975cfc096894f316f9f58000940b6c2f33284abd52d6ecc8bd962cef9424f016a3e332907aba17d793dd55acefec607da6137d5b63bcd78bbeee1371417631c9a84fabde9c92df6992e96a73d492aa617796180bfb5e21d32178437649057b3d0f21b8d751e483a38df2cde7ba7c22dd8b389bcf68166e55a9425cd916446b43ec197e767c7e27193280ff148312828c54e0e22e7a5cc1d17b34ded087bdfcd0c27a2c115dd1f1d01727a543b6268f911ee22216bddcc9be6da00eb25dcfad172271f111a639a8cacac5d0281c1946d8fb6fa5afa038efb14044355213df1ec065b9aab6b9a449a92029f434368ccc9e9489039217a9d8c96e0eb156416fe18bf3b9bc7687d0dd615289a6d5dfc06a1afa3711f6356a600adfd9350f040008fadb38a7dcf9cd6a3990472d20a77fbe98305d899c84e8437382b7081295c39c44443e541e940477444066a1f8a6fb14b3be1f8629c4118bc214bac9cf7bdcdc6ea451165662f33e324562b45dfa234cefb8e874442f0a9f0a6b67d853b34709741dd8e18e0b78039a0b7f7e8b1b141ced89bde046316d510653d875c08078131d564b8a925879d654630190d1e63df3a94fb6fcb7cc3478272b91ddad17103c77205c1d68d8a02f31bdfd785f7599f2adedace40cd4a762255292e535742c32cf21ac2c0254b5e81846f4eef8cfcf91cb94d6db1ee45ac9f91546070fc54ad61861788d9fecd98f8753c79dffae5051116994eac37e67a7516d1b45047fd55fb334047b4dd4527861936f957dddedd287181d3215ad680fa8b19ddca00aee9047fff578ff0e51d328acc86b1c9f4ad4d77c60cf47bd6c28c652806c0b29d6c46ece6f9a22b99c90294f64645b50291694342a953f32b33a62d7a8d40ae2ab968fdbf957d3d7c1b7a9624de121b8e28fa35278dfd3905746d7f63b326c44131c94d7c8783eea89270f7d9457615ed2ddc9be6966223b094821cb8cd64c3d79058e4c3c40101f55dc38df951fad070252ee24f33cb5383957f50404d2b9a03e457d8dfcb0d4661d3d6c754e0c3a470e1dc2d411f6ce3bdf976540d218f63229e6995e5bc749495d5165b91c71869d83258bb491467af0edd7725564f8c746dad63cc89eac40d400629d96337574efab826ebd8e2b6b4ce1cc1e0f5218bcdd0dc9d21f5d4384eda1c2c11cac5eee3e7c89b0e3b9a0bfab306125687bad96108a3d4935aeb683b040aba975e1c5dcc6e56a90d9a5403e1be0921a46d9de486ea738f45a0484d9b4e0a49e4d1490c6ff865a112f0d9b9fe92a9c4c28d923fb1114cf62dc7205c8427a9130b47bc679077a9220e250520cc2a355153c9de181f11b85661cd78ba7eb80998ef7ac35e24c63f437be4db0608373a4d8814297f1d602c0492a358e583f13b226f5aa80b4f30f447b4a70ef1b47ebed1b790814aa488df86cdd6766939fe08e71b4a707ad1aad0c1d26b70d5917f96f5c30122a378ac71b2204ec4f80a4cb20ef197116e020b37fc30a78084458f963f149901544d6e944a390b15d9ac3fd67eb23e921e1c56fcd4cdcac638cbd054442ef2391da2f3d4f837b93c91a78a07c7a305c9aca581ad8a3387fe34f1b4b0f1befc9a9e9c8a232e71d89c880286059619989c5f1c4aee214189473e4a8cf834866f5b1fbbe8d9ef1f57a1b948d5b45f9d0952697fb7c69138af16103fc8916271f00a6342afdc6bd607f37684b91a51cf6068487b88d55351aba64a1282ffa5a0109e5a6d81ea948859d00f9d68d1a0b8451b8dd287cee3baee0d1ac6159f7f851c2ddb5e34262c7344ef368b10e2128ed3beb3218df95199d4c4ab52eed03c41049099bcce7cee76ed72bdeee39b1bda3318d654db6692117b50d0f7cf616b6a5736b94cb5a57a71ba2a200f2b38d8b9944fb421765803d93d64869d4d653624a097d3e8a282a591cbe387a016a91b8e4687ac092ccc9b590e88ecd3bc82ca4b752012879eff1340abbf98d11571eeb1f729e4b777e6e696ce7402010fe48aab33f86beb55dfddfc39c93f387c9bad4fa233ac36840984e9b3c72011f215c397d770b534100ffe7eb6e62dff85b1b4dd0d74d2e42597315c8f3176766bb7a3a5a2a372c605e3252e8f9fae588506490fc7fd97c2ebfe5adecf299739ba1aa0f5d7d35d0b86a3ab141aa73920e84fa7a70aef6f9abd8a0ce8db4cdd6b54a334c11daf6f15e34df462b284ba1cb252e2164867b290b2d980a3143c86d2335b51007ea54f7f3267942683c56f5bf810339bbaccc5cf45d7029dca27ad1712a752f79bf56fe3e213ac89e37edbc8101e53190ca7f3fbb011e768fa7febf8fcb6a063fdabdd7421cfe13ec774cc82c7ae7f3df32687eef77b867e82d08af0fafcf39e5096c35662be5700eb9da19b0e9fd2208d6d32a13dd46dba1f9a1da55a09a6c3d6b94919c5a305828613b5230543028c30e0fad6b74ea0ac8a7fed799730545eed6721b75e48a3ff9951b4bd8af742e644600b60e32e57adeda44d03690412055b282652d13a0a2dbca72be9f87921128dad0a63e3c33c05136e944c4694ce40c3a8029520c7b7fa7492c0964704728957d90daf71542e5d5e4f02de95062c11312ed60c4c20044b29bf84b847d5952d15e049008733c8d3ecd8461206982c1639e9c85794c362d31adf851273b87d4b7e2f7364cf595e466de40734ec4ef5d7a2e726a1e280f9f4ac9fd8ff972bda5dded2da15903e4aa4af6ba1282d86cac7ab3e22800745a5afc6ba1f0cb23549cee26e0b09c947078855f5b425232505fa2205cb3a16e962a282cbcd25c1dd07654ab478d3772233680f376b7d9cd23b4cac73b85296b2ec234dc41a24e1bece06a8f0a094266ac29a296fa9b3fad75ea79495f2044048429d2dc0363ea618773b73d802f644a6231fda75f4ef57694ce5b223508e11ccbdc9735376ec1d3a186bd6335b2dddba1b0e9217716853c65e6cfaa08cacedc970a44cf7754e311f56b52f301c6220524f3f31848cef8b063c252edf2b36a68dc71df4788c6e7aefc5480977597db03ec135b81520cd1f2d0de5fb32d14e07265c96b0027f92d82c64dd69abda10e84e416682b0c29d2674cd8dcc904ecb5a8527a75c0d11ee2f583578a70c803ab3bb8c5ba663884d9762905454ded1d760d3d6687c920288997590506e9a71bc5e7782d67e07a52739f12c21ebb86bb2c478ea7fe943e65827d106932e5f4474eabd825f76ed8065f62457a19582327868c0e423896ccaf7473d304aa72186557ba311ba8104a429fab76174bf141938b623af9712713164f7b40b61af57136f4094b719d710ef5e6e2ed9d5416d1f472a1dce1dea67164f57b82a728c51cfb6bcef57823b4ad3f489fdfed46bfeb4480576c9365b54d60470f556c4cd6bf058a2fb800ba3133c1cf564afc0eb0671c4513190c48b921a2d0a83407ba167601798aaa0991e3d181e46bb5d043b7106dda84ec663ae51347a449ad248470e9e9df5c44c51e7f0c78b9ff3ac40f6646a03a63160a78ef05a4078f79d8dd17a159a037656b0fecc1d1a36a71a18b2742d10108029bfe965e695c7262d62e012104db429c32569c450f652f2397011f8f5612781ae56ea99e55d729f1198d85528cb028325a2c4e12af89f0877ce3f02241868522d3d8890c8e82ea53a3a067c69b963f77d35df38b99ac05ae8a035728ad3f384d191aeb32e280e40cd246f05a8bcd25d21fd200703f8866d59c912cf87687f4f1b1d2b9ea42273fdc557475f4453486159eed77abd2c3daefee3f4409ddf44619674206035917659f30c46d6305ac0e27dfb0fb736cdfb35b1b5f6dd07aaff68daecac330f0e1afaa9d6fdcc6dd4ddfb5b9d55f33294c678a8a3117914c216f5164fd0c43b9f0dd8bad611617cd2415df2ba2319e2dfdf4d2d64e1e26c341e4e570463c27a8a527772dc9d751b57eaafdca9245268569290ce573b4c0c4ca89c05a632a810abff807b1b65e41436de0164d805abd4816de36f9c699aa919c8a71d3f3c5d4d1568b966e5cf23210f48a123f4d77871e0a4298b8af2758a52a3d6dd60fd8079c457e809289f758bf2a3998ca53fa503fddde27e2f24ebda91b4889cdc24c778fe1d013ef224932f48f7c195072a32cb64ef0c3463b196838772a5c585222b304601b101c71779c28311ed0b27c4dfbf0ffdd0e360ef0ff1137a047132b829c9cd8a648bda089ba7d69482fe3d4539de8a48ce3b0f1e39586c77c6504d908c5d9426341ac940e385edcaa10e8c898184f15fe68fd6c9b5731335f13e052a5745ea434739f0b5b063c4dfa7df9ac18ea2b81bdcfa0c4a879319d6fc6f1f52ea87949aa5982552bffceb0cb9a997a984df8e9a9f07c5a1e7da83c07b89d14fdcb7d2bef1e8071f5bc0e7875e4576fa38855f9dc3e840b39486d8ed2cb04438d241709a14b54769ae4e32bcce8b525a1567f628a7db4019852752c01122782240c92c119ff010dda4a3226d2b17f3ab3eb88afffaa3516056f7937aa7ffe65bdc9d6aa2eca50c1fb030346041f04f83c18168f691ca45d3f343c4323b8258002c52594fe085ba882cc3aaf4fe08d7df52007e9dea7016e0ff8f0e0c192f82e21c07d5c56400c76f2708050ca87029601b44f83699b89fe4bed2099d7cedafbe65c9e665303bc273e7990e18ba8076ded81b75f736b43156b1849379ec85a4d627af9d6e72b72deb4d2a283f51a2ae469f62b4f61e85e162d96fe6997e3e3e7a8217a1db0bee193bb5d3f24dd591201d6f3a913e1b9526d462a56b1f618884b285f9f4ed59fdd1326ad27aed719e6e2ddc5c9240c90dbafc178fbdb1e7e51df840c56bbdd3ca05abae04ff42cae3b81ad05d88aaca3ba48a17e6cf40222e648553a5543f9364ee2922c7b38df9e34a77f8801ff8d06d01b8511403d03cd57cac0a0f4c83376876029308e1136d5169ea473b47854e25a3f831adcfcd018568eda4b6ff7e23996f259a6ce8198963a8dae967de76ad5dbfff94acebfefe38270cc1288f4044e7264f56aa5a45d489e955b33a8f728a971001acc49620328b2df91fbd635ba1c8b9b7cb645bb44a6c44ddb9f1ce15bce6bdaec3252b90b9fe78127461f94840cf81a88d29dba9410799bbbc98de2e4928ef39c0ccecc6160b7c07e6253fd3def20f4a75b22200b3da09310286268a21d1d1a19aac5a146f53dbef60e076ee479a60ac38c4fb10bd3a25e027122da79206d3573119f159b41a2c27218d9e5c78ab79fc760c3410d6a0bbe7ba8dc9e92b4e64261c4510dac6977e8d32819e556d15af1beedd6d028d3398252c0f347841a890c097c9e1d7a0880aeaf7de97b2ff91fed56cd9476221b23d7e9fcc9226bc51cd5a05d5b4764c0f0d87e181dc70d09ccc8baa08b3e387b8ddaa7210754be4b4a86f074ae1eb4b7b2d10041b33b07a051f46d55c72fbf365c625b95f84d82ec2bfb8de649bf20de777f580fb470d4caeca18403de586af3ac3b0ff0837e66930de336070850276b5fb3f3a69d8cbb6a37edb7c7ad10438c118b95b9e2b8d0d111578ab8f323b50c340388277e8739c8f2abf0eb5177a1b08c7285c596830001296c1403457a6861713b86189f67428ff1cebfc1672bb495913051788c4a237c109c8f2f7d9551d74cf4cd022377a6027726b20d07119b8915626136ea4cbc57080078f9b07a2f78f896d695e39da8f09a769dbdd23e1ef297686bd1d1a4c37658e19cc7dec8d2d70617e907b88f15c67ad9f53f96646833db23d2fa8ae528dda5e5c883e46e024cbdfc72a46bb22446ac2fc7f244f1c9579070aac3e4841f698a73d05931ff0333c3d8b287a753db3cd892e5ca31ee79bb9d2af4261b33682a34b8927c227d9fb3a3357b285d617c2f32b57d1f554c8a121577b364de6436ce1c216a136ba22d6a5a4458fb1963756fdded7bb098af3b7a049a8ccec64138ca605291ddbc7c132877849efa072f09e03eb6a2aecd5fc1fb9c6bb58d4089afc1338aca8b265ece40f30661b23737988e1a56eeebf65d519fab9d8af97f6f66a1a3a717a2753ae647025a3bdb05aedddc2cdfe8ffcd2bb5d94b8a3381142cb442d6ab5c8b6ae5dfb0559edb3d28cc6226f3dcbe827e02b3d52fe54bd1a16972e52f6dac19bd9a77adba8cbc0ada4f140fa9f977076238cdfc93a3adff26abc536d52c3a3e326659d4eb49b20a4406a509e2bb050848aeaf2f648174e32c6edabcd4d6b7809e04a0807c04e4fe18ef6ea19b13edeee55551d87c5798020563ed6d94801ef40125f7db51573467bb2d96d14aea3e613cce9002c6ec4df458f777710c33ae63a76bd29caa9a0dc877bd422adde1e0f760398696f506b05be597d23dd75a7843b84be61ac9d7cf08f133d91146cd89dfc54b09b4bf5d63fcc7e827b8a936e6751a122089b52c8466fe4838ba1fb2d65a30bb48003da0ff1fb4e6b3f3a39c7a941ce340b5dcdb17f97e66526dab6c5621176e747110d33e81153e9484a45414fe518ec74fb4ca6796c49f14c575e1504491b0b0e6a0311480fc8d001efb858cd72d59e266e27ceb52c13badc20e787eed6c62fcd133425b8e6b1a2c1997538de3f8bdefc4d6a6032ad47fb175c9bdcc3dfe3f391aff3e14c6a8eb9e68f52e4f0866968811a98100f9671344cdf074cbdad74ede6488956eaea13c22247e351735989507263a23395ac32a78421e97c0b629c2f4157357ce5f1aa20d50c8fd7c0471531b6bdf4af3442b5c13d7f1e50831c6b4df227d0b537fbb7a4e21422f11307f4e23d516e64f642c82bd98f3239b9ba73212f1853574b80173bb4549a6a0d321076bea29d2358a1621a82c2831c087e4fa95244a6cf9e167575e75b4a65b17248d443a2c9b6d385920f94fef75aa6a46b6dffb9501ca6e2e710c253f8f97d7de6e02bbf4869e09b563d1790ad8787e3255a3cd4f71d1d3a4faf965393e0444f9e565e1cd3e439f9a0535b02194fd57ef63e1c6f810dc349b1cfddeb4e93ab4274f3d1054d91120ab72ddc88950495debe11302061b3db47dcbcb3637ba3a197ec6e1ccc0f81e7f6cf1947ee7faf3a5354a2ccb0b3a15252d098eb5ed28fad4f2206e6f45079f1f0cde7831ed1b605d4703adbb3329a85ad94d7f59eb584f7836da118922348a9c9c89045057b72950e8311e3bc117f9c876712245f4238debdf45a5614134aa1e1604e55066221a92885dc817a620d232d7b557f6f4d8b643b55eb8d5692d07ae345a47fd8d849979e2ea97fa218aefdc0fdf4420ec97ada2698ae28738f1928e61198001eb0ebdc1c42a890b2d139f45711f91ce9b5baa9099b3b6915b56fc24520c013fbd621b7b54ad4bb0456dbd97ace31b19aa204b883762c66d21d55b254fd8c64e04ca00f64a39f878895a4a108fc8c4607873a3bd74748c41df134454fc64b0c35a40f00e7a82fdeaa47bf9cfe5e1bfffbe1f6afc4a6c207e9558e5b7cd515cc2a2ea16126dd20dd922b93f4c81a56e50149cfdca63fda7894d12214eff2d3d08ac5742c70d9a55c0afa2bff9ce819905c6da612c797eb0957bdbb56535f69dd1df8970589afa6603df0d3d23afc56aab3aca7198e475b744756437b7e6e7ec5f60ba629bc3501926eda1ff51ed71660f5162b9292024b29630f7db0d38eb63fcd161b05d8d2a558a28314c6048151661ad941faefcd19514614a9e926293d896c25dafceb9f7ca95a0f42f29472a9b38dfd4f47d26cd0eb1b84d15d19487b76ecd3a183df44dd6770b1a1716f9743cb87ed5a0fb5412b4f58a14e507e7f8e92f61cb08eb143548f29ac5ba7b5def9ed4ec2a82da46ede711f7066b242dc9965a46dbe207a788059a7120a8f247cb6959180e8710e09e6fb8d70ec0b44a9ba17f07801dd4ae698cb0938f182aa5006b531d8d4f1ff50c01a01cb4af8d1c6b242d969e6e858d7fa875b589038ddda0eba1e5d5f6226f96febb67ebd604dd530b8a17041ead6adb835cc3b6355261e15a20f73037273e06ea1406ff1ebc216391ff86f3ddfaa39fc39ec67d14c90213eb537fae22f3213909bf688fc1a62a6be8282533ef98c21f1db66ea976ad314980ae76ae560f1d6a0e005ab773f1e8e97b60eca0d26299750bd4ac8631bed8f8d46245730817d7d3b16bae8bcb392950a4d48c427bb5379542e66143055063701b21e1452c6f54c75b36a67919f112829ae78af847031fb3eb2753bbc72a2695b163d89b9f00521bfd18ff6a425c0afcb1c75e229fe8b5c7ce30df5ff3ce427bce86e5d71c94316ff0034d3b785851676482ba700193f08a8e393aba2f827c2d6f06a996146c87ac6d7c71350cdab103c7f0499366f62347faf2d5fe4ee5936a304618f53f5b00e6185dd5fadb84c7a4b8f7f9a69caf90c069c44554df6a41d0580b29c2b01df6c0d897715f06f299cecc56262268d3f5c74f259064c283085a185e6516a02f0e24b59dd04cc91d4f626568cd5f809df88db4fdcebd5b08e3193e779e5ec5cd764de436acb15ec6b3ed9c89d55f777a4cf67620bf99ba32a564128ee0776cb67741a28e011d7fbce1c77a790e8f309d8e1e576abd3d2cca53c4e3362c81cebe2dea07876c3a97b6692ba9555fe698c989e9c888aacd133714513a46d8f4230cf7936e3a40f5c5d4168807382f445b392e413491c7084eec670c963d508148a8d47b9c5b8e8fe2c053c614d9811b334bacc52b03f612ad1755d14606381dcd45cffbbe19a4c5137b02f72c6a98bb7a4ae9780d155a881fc286ab936a21dae864c62d34f92c1e5c629d279f3587048fd12d0ab58c4eaffdc92dd5419ba074f2ee05755e66a246c5ebd79a8659ccada5b8b3ee133d9c0804c553a79981d713c434ea138bc62a8249f067c750633dbac18c3ff2e232b23a4e1232d1845274837d6808173cbdcdd049b11765bdec273f2ef8da11254a705abbf31997e6f3b1241ca43745b90487f0942d8c8efc404ba49d8fba9fb99dee4eb3849a77b3567c1b7262a0410bbc86039199ae17e6af1633f8681c79e21bc72bd7e3d8070f7232882660f40a8cb455cc80691de462ddf1af946e1e21df467c3302d6057b66709c0fd2c19fb359045ff9e74ff46bb802f3a7e4d1c56622e4560504cf72d1410c188bb0d1f7ce5bc70cae277c87b3b3fede5259ec472b093aa5814fee5ce435bdc1ff49e2dd40c50fc7ace1497f8d3c086c4aa85c7fb320e9cddacbb0ef38a3caf66c0840a4f086005217f0818112dab9a233e0ce8042c93e760d791b3fab2b976e5d0576009fdc2e5ecd79600aaec8e2db30ada994382e20a6ef370e409f64c02190b0c52c9eaac61cc1d39fd32f3a8266b3598b2fec3dcb1c39bad06bc8adbf1ad7d79af13c9290db91b65211335fcd3478088cbaef424d7659ba71df20637142746ae06192252a469c94c0a62c8b5dfc297f19812a407d9c8b1659adb7ed707ec050b664c045d37be9a5c65053267a667ef1315061c5d15be2a52b8b239efbdc283601d3ca06a908f7a86868e59548d60a5c64581efd9e73579a08963821cc4b5f1dc96ae756b2aaaa01805266c2b4c66c94485bc1a8531784cc43b6922fe76869cd1da1c236ade7591c205f2030d7af14c29da88c5c4a959af764c46a985860214b5d425a9863fdc9b18ee805f12c41b8763580106b74b776c96707df0325c2465a65ce801db0ae81539e62838e0fb28d20374f07580f8de9057514ca4ed882c8ffc32cfbfde71490101ba1e1f7bbaccd02a03367f3169227799b3ccd96bc3d392676a308a773b1b8aec233662873df580f8b198fffad888ea74e7451d220a28c903c8275210284094757ceae43465e9e40104afff8d56554fa05dae88a2b05a05aefb52e2ee4b910ed032b464f000727974cf8fba2b99f50dfe75ea0681566f9bb7eebbe0ec2ffc649580070621ae67bfc3e30a4c2c56052f6cdcbbc37bd379da3aadc3becbb8396f2f6ae2c44b7cc8b943ca0292ae932844474d7f42f94b4632eb4ea1e995789b2a41036881dd4905f42a52b381422c24ad5fac618ce0409db0bba2ff468df97844c22591eb37f19424b3b45bdb1bb20043aac9ddbb33de9dbf4e4baa2ef42951921104144a0fd145275b14ba0657adbddb96bbae98e455bf0deb2adf891048d86068616b4e2794213f6ea621e375d9880996d165c049a906a0024932d54d29b2b66f9f80466ffbb0a83609c3412980f85ed8639100c8515dbeb17ebad2f36185ce813d986156c8509fb1edf9f02a1fcc6e0d67cf282f0af330bfbc4d2aed49a0882229e2ef04d40776eb25fcd153e22492a887b0802c7e9187c01aeabd887be2a434bd7e5f2d24b5b997c2d94eaaee84aa9624ff3ec1eef94ecaa4183ac3d53bbad8a5e743ffde6071f46e0b8be1fc71ed90eb755bdecfd658eabc09a5e9b27946b73b225829a9615668176f65b792c2b4fab3d6d98e85369587d789ad18d5103224029dd4813f06e7e181748d8b48172aa3ced2cc2f72432e3349a2dcabee7708a2b79cc71a8b024c1b2ca211f1333da4afa8a96d1b1e9ae6b58ef75f493081672ba299040395d325a0745a2f4758c0bb2a9981b4647117951a7bde29765a010007969d72b5164c8970540c555a98f9eb847b39e2c3dfd86324a78277fe8380aa3d170acfea17dabbf2058ebba87e62fb0e6322825517dcea7ba447b97b1c9c065855119aaa07527d2e24d77931c8303b304da7719fe6124b2a0fc28fb765fecec475ab95d34cc9ac316a385ba1f7f466894d7b571c7145bb57379c07f757cdf36acc700b6b416f74ecd9903611a666613a07f94968cf6adfd343b6e48926f9373eb3977e388d3ed3ec9301e008bdbf81dd30208441c99b9fdf1aa7c93407e5032e9f0c9149fae1fcdc643c4c709facd8aa67bc8ba13e01b4022234f925fe03f844d9faa323ab981d35fbdcedfab95a6e0eea9cb989099bd7e4d10c0768d6f0f1da3ea5c85eb2cfb8048fcdc47837eee93d3906ae11a2aebe2d792a542a63627706e1dbff194fc979f4de2409f322a4d68888ec2f12ee761ce2ddcbb37376f7335d80187760ea4fcac98f082f048fa18f0f5f003120bd58f6282775430f546aa9d11672ac8f4a1dc56485832ba0cdf4cd2ff733670ed1ee3b9b04d4a5dccc771ca15f624ed4aa0f0fb72e5e9c385bbd10112b29b24742f6249b790b1f95ca9b0bf4070f0435fd817ab24c1671890695c4afd0f35035fa2bffad059fd6c51c36bce644603bf5e5eabf0a895c42acee3f2d038ad118a4a4e5d10fe4d431cfef598d69385c9345d84c4044f1c68f06735c00d86182677fbf5c003b1da86c372c1e861c67042da88b46f10e5dcc17fb9f4e1225e47516fb36cb1e317ec0e4074bd28bc1a375a2c5407352b157a0a8370f2326469d7408e14bfda95c51eef8fe6bd2595f700d1e24c0563e3f60da9e4f2d8d3f9079b0c80486816eb3147edbff20fab79ffb3220941de6eae323415681a5961e2c00e03fef37891ad205503ea9153cf23ba43621f00afca7661a71d24754200d30482a8d056f8b8ddffce5663e33bff845d4a22bbb946a65da453f5457664a71e57821e7f305237eca7e44eb8130c4907b8a776fdd59476fcf786d9b5362750ceaca6bbc82aa97dab49f1723a9edf790ff2538d8752a2975b5cebf7482dcdc5d63086c282219cee5077a2eee0a6a26c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
