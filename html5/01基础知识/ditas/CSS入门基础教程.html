<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8386fd9e96f1ac5c6d9b84ee8127be226de6d30d1f17f221901fc55fe41645e5505865a337888bd9e55a82260e6d8cd8468b53ebcadc577ca72ec39581eac12c653393e6d0afd83ca11f707d0f4ddbbe0735ff9fcf27bcc197fc33cc20f289559c52a906c09ae0368ce182e5f6e269d8aecde08ba21f5e03d126b77255ff99ee52c52b7ab0f2f9ea06e627b60abcdd1bdf35815986aaf4c6cfb973141f82763e1e5999734a2d16850d244629ea56a8b6d85655f438f17de7ed7ebe14e4204a8b8df3428f650a26131b1168dd9ac3a431c4a343d94834dd1d22abcab4d443df1a8fa2bca2181744a97a68f0e7821b18f891f39df95a5c11136ede995c8c2f0e52d9457de7b2da085a41a1dee3baf2be8b54aed912f3d9ad24dd1853cc89123bf5cf5e7cc66bc0e1d3c85ed08cc6e537d336df331a7a592024779af516cbcb92cae4d580d6697ea2ef6cd7a4f305d646c7a18b25b8e7600561568aade71bd4eceafa0ec0ca99aa2060dddc0d792a0e7e71675a35b491f2f369abf193e6a45156f6f8e50faf579d3e661200e5cc42f290c010e4b4bf6e0853033c25671ceb10eff5ac72c6c7803b293fc369aacbe6904e3f1e0b8a945daed766c4087e295a030acf741cc31cf7c3708f8d59ba31ee3e1f4512a17abd43cef74e18adcf4440fc377d0b56c04bfaceda0867c0a63d0a2cd02112fb3b0baae99c96135afe68269f281ae62fc812409e404ae4d172f550723e5743f51953ff22f8dad613a2d305d63b5eda7c1b5c3aa27c5e871f79a72a4e96b6b12cd5c49bc53eeb8fee59fb0de1151ca4bc90577d471697e206cce5aa35906c03ef8d995e872b51b72d7614722ce6ebf17ec96ea32bd0d447d4868256209a3ce06b28586eaec4911dbbbff5d62e514f66abb741d001443ea12c589aacff8157b0c855087fdb17fb63791636218c98e756744d73f2bea1ed1ba235d4e09f366957a6b726abea269af0024096c9f8134dea6b2ba37f40d82dfd24eccb780b9c559a1e963490e2aeb7523f0f0fc728306bd57ef69eb1a9ce7d502ec4d215de4b84b77e2504be0d9234c0217cbd03fb50422a9eaaa9452432b4e1ab69cfe7c50fb924f28fd172cdef59a9ee30f84589f07bcf8483f2c7615faa4e32efc6a6044ea49e4bcdec285af84df42f0f178f1d1c9b76377fd463256c94f453a1cd5f3521663f4e5d0750232a833d54d6dd1af22de90e8ef65937d07e9ef996e8c1201f5f3de507527a7976ecbaecf611c3d0298cf01ffc7880f73db8aed3d96bfc3f16a98497fa74606658372f90d1981d5461fff1c29b590cc3a0d9da3aa1a2448282b538d022ae368b006608ec05f65f04456c05b06b30dd490bca5667f3265511c1370c4894fa661d4c58c7c708fb47b9e95ec7f2f788489c0c62b9e837df905be831519451cd6c860137b449fe2238d7d0cddcfbd21d4e38253e2fb98c63a0a7fe5b08c88e9ccc09a49cfcb737c4751479ec0a84a708419c44406209f447931d370b786546a0f4f1a042a7e2e0253bd9d67692ee82871a4577b608f59702dceccdbc0f5f08c4138f48655829db8e9bc26134a822064223e87fe47e1e4f9a8491640e8b4bf05e3146e7e8df83111c03c072d02d6b5732522a6aaa1d0c3323b1de27ea4b4bdd3e9ed05dfc6bea449e128e02c3178c78781abcae82183499b988848ec899d803188dd540a15e33d48fcaf30c22fd205127bfd1171456c3c0b80dadc37d7d08fb1341c587f01bdb0852371f50e8cf4797d8338dadb16cf48155fe3c6c3cb3adf1fc3e0c215d92339a516722431310c965ab1d84c17d44b8cfd38353fcec2497886403e88748bc3302d891e0d565649a5def5d3fc3b769921c0651dc30ec5e70fc87f24157190aad7486386505201b11303215b8787851705b7a52fc4487b101a11183f5fdc66ac0f4db7987523a951649e090ca1e361f239c58bb92cbad861e9221e2a1ddbd6202d263c3e418009408c00cc4b24bcf12bac3fce1ac2dc8884edf5988ea0e9b4dd61970438941bace6eb0e0c876e30f80ed6769b619a78d1720ceed4f68096a366cd22126b1b860b8d6d268d25ddafc9f446b206219601278855e3be4f51a57130fa1ccee0f9b7b01aedb1875298897e2f7691b672e937dc1066e5abba73b55bc45ea71d5c86e485e5028c8aa5e46e7ce8d9a6d594e92dcbbe4a4f65eb9bb3c66736dfbb85f7aeed4f0a4bf0e5e88cb605ad0f68d34421173008feb02e41a8e908deca3d7d19da04410431aee63f2bf4b29fde39969cea805d052e4b1f71e6d584c935b708354e0b1a1344db1349284da848ff7dc1359c06ffbaf8e9b116a18526bcbe85108e31e6a25f2fec5c4be1ee8521c6ed2e2ed436e4b12b67e3c50e693836e9b3539d887d5e69ec8ea938b9bf1fd558fcc3bc985c26c1eb634495a41d919ef5a871467bac0b8c1fea5806719fbedac2f6461b89374b2f23ba702be916070344c0797f55e4a24f4a2a16222afa654d5eab337e5aa0a8b274209843dca60b08540f029696d5c39faeb24785e912afda52131ae40e082563b8a72a9f45e423f334cd1c77a25ef765a7417c2ebe775565826ebb37da12d0b16496aed2a5e8d0f5909581fe2c5a81499123306082710f50705bede006026364d7b8048da94d9e6b4b91777946f4747c1fc99f0c60d78f4efb1d7ea9b3395cb1ed726694c2e25d90e1937e439ff29a8da8728524f7417466d7a467594db3e75e70e4d06fa4f62b90b317d1a37c2cf092ff8e2b63085f2ea4f7d50e10e4c65462679105ddcdec7ba8a0714add458c7a9f23db032bc9221d61fb529731a054e7f525fccfd9483b406a9d1946d49157968d6b34b3ddcff9f138f690932dc34c5f9d9017cb573a666b59060c521b10fff361e6c4b18b8b68a39e0d7c47ba4653f35c523fa9cb975ba83867a42a4aaa5835fc6c905e9a967ce69f7bdae31bef458b139197432265dba308b8660ac5c37736410b2651b13f059c4f7ef2f1028868a8632d834c1138098daf700714087049a094bc1abcdd319ab3dbe46118939ad414060061cee7ce1895cdb6f32aa95b60e6e68876d9aa317f2eafe538209d003f94078934048e83ac68b83e2145e0a90ca5bfba984caebf76561d2aa513388230c1a21e164746ae5b597755f5f924e24eb71695b92c1410aac233aad0459cf30e12798574b964e9a76fba3293f0f46a52a6769201670024d35ea1b275a01100f07005ff648830fff04742016b65e76c362d893b45793b8688d29b0015dcd5b3d3f43080a914205a8bbb7a71680b8e66a805ee371498cb74924117371c2c6edaa1400d7fe5038ed8d52eec94da725b482799430e708427d4f243c8f0e7edf7a1a3dc99d5c4948f1554d2be28f9e0a8b59b134096f5ae695546794e7a32bead01fd6ccef62595ca3234d4562badd639bd374965cc74fca58a05a120993c0374b0fcd805e5821f8b672a6845e8262c5db880cf75efcba4a56ecf4d8a20e51291cb3e125f3a1dde7176fd32cd29fe4bac630f444011eb3ba6c2aa021818e7ebcd640d55fec3e9634ed4e01f960dc3b28348a7d851d95dc0624cdf924f0159fe5819ce0cc21613cd5827a904bc88c163f5fcf5a748f9c08bcf2eea3003d9217a9be7761b7466fac3cb56c4453db2db43a99c97f4bfbc7ab7ff59d00303b3b4d6dbfdf5e77cc60ecdcbc3902d5790291e450b6cfb4d62046d8e610abe6eb372552505b3884e28805dc37a2335ecd4c75418787437d9a39ce24c2ac21c4d6bebdfa6d74d197fd1d76bbe5415ef5a0465f7568528b2917f12c796b4fc41c9bb12df1a8d8c956773ba7016574747a83a6ea372841e8888691e0f08f14d003e8176868df4634e1c7337f45a9338555b9d0e296a1fa09400750f95dedce773a9b81ff5f9926b1e152f20d35cc7dc86bc691a34ad6c86ed5634e9436081490868d290273e5312acf9c4ebd12d099b2399bc58c227aefdf1974dd7e02929b9faa3fc675fc7df9d44b4a0e76646eaacc0de179abcb1437526223799f4382e8279397f5e3d04e071d5ad7085eb2899f890c7c2cc02906faab6d69253ddeac8b3baafe1708af4adb1ec06bcb8edbac974a6e32cd3ca7221c99391ee8426597f67f48fb5a0643bb47ce3ffe8664369e82dcd45e96cb50fb41997e9f3ad0644e6fac671fa9c95588bffa5431f441adb4dd2b522d17a884b6752ad09348cf65e5dc8a946f047a16e3d73a11a6f46e9fed81763152dafcdc429adead909ecd91f5915b495a89db771c32d478cca7f66dc829adc615a9e6512dd96e7767ded1a26acdbe55acfade3013806350d8d877aa93048b30da00a734e221265b8b6439f0cd948e5e9f8512760e4033d162297003b1621df021d25cd06de3ffe79bf61903f045a23e3deaf83dd5a2714bedb4c2112ea9b002210d1d3f169442cb8737ed3196877996d0422ebfcfcfb246952b15e5b2c2fee21d3ebd93865133387a690730b020cba8dd7cc2f5f07a249a2fdad6e9807df8332208c87405557aff40c8284f5a737b0101279ccdd31ba81430809d747003bef8e16e412fc5abc1741e0ba19112ddce5891341ff79dca797cd126742689c6545fd99fa1daafb9503f745529a8e5371dd23fa10a4dbfd494b3b8be7aac4887d997793d98f204fca0d3a9ebfad76498f2f8d5258b4cd37187a8006758f450ca8f29a42e2b29a347c676d058698b9e416f1e40da8443dec6eddffdc62ae13fdcafca6900ed86bf3b66c66907ad217e17972d399a8f20ef12bb61ff0321933e2c5d0784d3e23dcba06d92ffde9ef090c26aaaa29ba2c6eaf16ee805dc9c4717720662434573121f1c8df4f4bf57499ad939bdd9f72d205c9ccc238861a4369ed4a7edd0453629683284b5e09dcadd20e5afe91c036ba5a94ccab091213555ab30e750f2434f6f1d56be04e67af677bfb2f8eb17e31c250a4c816e30814a7445ae3ac2c1107b55e7b11cbaed6eb1211c7e8c9d827772da236c40bbc84e3ec0ebc8abec87b68dff58bd03f5d383f0a476eccbfefb2ab87d0672a4abf2a09ca359e6b3de36bed8ac77d975baada908a75a341ad32b00aa4fa04340613ca624382746f221371e10925e912213ca14e85c2096e8efdece3fee5b28ed9937ff1c9d35233febf5e584def6272548c54efe53e96d73dd8f487de39844abb48c5f1d10c21abf096a46815bc807d260726b5e0ed265ff1455510ff547c7486be9ee2cf5c4a2981bc779517f6638259cca27b051dd432b2143b89199158db86a3753a07de9e562e207c48120db40a11af9499ecee7a3429f1c5ab41fcf349dcc5972daeb9ab678c9e010746c20f4014814975e08ac0b3ddcd000cc87b96403772ad2858624ecd6d71b4a977d986d80c09cada3277e21e863f4aa6e7f679773c1f5a9b5db8a8bf363ddb25acf43d0a2e2ed044e59de33acf8bd276d459393a54f36fd89b68ad2f6db82288d87f1e1a10c98475e584d51c7d5df47ab80447d75ca0cc7827a9a0b8cf1c28753a01fbe71847c618c42143aa1fc9399a3d8605cbc64f013f93a05440a1d3406aac88390ecb8d5d0f9414ab013ac166a56bd61dfe820dec12a01971ef5a5418cdca373170eb3d82546580de4643e52158df572cdce096b6080b4212be4d027d9ee70ce83280dfc4d0cdacfd6970c26889035710226d1bcdb3ec76667474ca1121cb8b28e7679db45218e5b380429c884dfd114fb2b81dcf0df9aa53c965e8d51ee02b5e24d623feaf4df0b78ed23fea2828d35708add977d2e981fe7f4d023b1475e5fa117d8e355e5f16c4b340a3e1432f88926ab91e37d96b6bf640f0de462449a18e6c602ea1baae27c115cf7a3f76584f8d014541c2571bbba849a0dfc6648d9e3834ba2abb7a97713ec3f77e212e81b90dd379c5820ed0140c99040110ac88024d7244c1084b4a91163d20aa5087d4d0107e189d26784f79326143af51c4371c5e073f02d3cf1fbe71ebafb8b5c853daf1cdfd637181dcb428f494d207732f2ae709fed1b3979514e91759a371a429ae688ee468cd50c28f784e179425683b00e00aed472f41ea97ee0316b7d967d263ebdea5e216469973c00d07afb7a23f09d1e56882cb6f1fec89d8e8be3961add0dd2f6f43f9490f1fbb4fe955cdcb1cfac1570a4a06eb40ca610feeb1cefbf2b2e44a210f96ecb0da13cb3f40d3661b8f20fed5c8731e9de09387c0066c2dc349aabe5be93a8590dfa4478d6cfa6bb4eed6d2b736a828cb90c5a93465c859b953671eaa46f90b8d3b557c50293467bc7367cbced96069f0ea4f8530afe00452a70541905a6f941d67a83fe208d59b8a8ad9279ecb1a8ef418d0f09aaf4a3ed373fe6393b14cced3503a954afb97d2cf995f3f969e9dd35f70ec77777337cc316d075845f8aa6c595310193717087f7a52f8d7f0b5d31b1762edeabe04819cfa1d3f0535dc4e3817d498f0602da4d0c779946c61f7aedf7ebc2e22b40fa204486724dc3d2a3730dd6669519f215dac30422699c16dc175682bc7d9ee363f8c696065c4f249274fe54e2c7ecc608f2407c9a0e80075ec5676ca2b521eac248bbbca80a684165738711f18366e9158b28a8fbcb60015a10726b77dba421533005b93053c701e77f6dc0ee1312426989968a8ffec65b15caba5252ebffe1285f8b73d92e51d81d65a87ecc298259e8c668932dca348e9f7a173fb5083615bc4d5f21078a65ab42f79d56c17768b2652d8c034fb12bc3d22fd7e9ca8caf57b966dff376dd00b6273251d38f408792b848f94cc95bde3ff3fee5619fb41ef8120c7b74428c181b9c7c9d451a0a41af71d9f37df9d41be37a37f348abf526fd8ed8dad5502f10f87ed128d4a57000b3bde44be8783da41e0665fabbae08f9be4def110a6d3f748982a2e2836306e7eadf04baa4a08f8e7f08c4fd5b4666cc7862b3423f5366b88fdf178d343fda7a1adfbdb47b24b348c1c7555452b0ab283467e0d8895f09f2b233c45c382e9b92db42dca6d9db46766af6ecd99ee0b22cc5b5451dfd04c7042bb8e18d63fd0a77bc2fff08a83a43ba9c6decf197e606bc48502e5b4d12b6693ddbb0f8014c93401955c516f1b59fc74d11f0acbf1e770ba58197070cf81e3e44b54995a4a70c3fe6769376bdd528634824ab63f7e70c5f2b701ff5cf9303767efb62bee38699eb240de8d1d4625d7b97808a0f2a73122ad817255734ca3d94750b3bab99a6f7d81157a3b5e7a10c8528b50c64d79bbc335aae9dc0669aeb940859550aec6df24c5c8d74d2d8d2def680902203b103ebc17392b2e8d88ee3cee05856f48042a819cbfcb13021245a0d81c855d7707a3334ed6da2b0a6898a6f2df3312fb7d2e50e03d6d8ce048ce210d3802d1ddc2650a55e7d5584e67ddc2bcbe6f069d9ab727593db8573c3b963bf8a598ff6d0add3af52ea712616742cd2fcac9c8463bb4303f2ce92bb34e5fd99eb87bea6657f816f72c4d14031fce251083b363be714ae29851536e8e61249e11817ae6bf2c1f98852af7fdf4a3a5213c447ac754ff9a173a02eac83432d5b65c3b8a205f8329e7f3715972c72b611e358dd437389e0608a35d4aee790578b27582dd99eb48d8d585757be35f2b904514a421d4616f02e03cafd71a342547f0784eb72fff1c9cde5c9837ded3b167f10217ffb7ec4caa443c868f5e74066c2f8f2d4920f88ca5194ef4dca73369a94d9c221393e79751d865203f32944adf5e7b9d133484a3fa9a83d0ebcd20be4cb550d3f2adfbf495313622ab3232623fbb4d3465b71769149b6e7ffcdb5690fd801501f74bbae62c19fecbe8979166751c342e2a7747e12f04a0b270caa14d535d3bf55f98adb3584ed8beea9a0f0818ae44225a93b8eeb1d4578279415d27a21ee980fa27f1fd80626475b9eff9cbce7805e9dfb7e8013fbbf022871e9027edf5b2909ce8f7541fb0e85cdae5021af544ec4b8655d2c719ef37f7e060f2cea09b4bc41c791e92935f39818e25618f84e90b31f2b44f9fc109b18f2009142529ac5b1807edaf98d84d519f7c5fe723d0e54f3f8dea93a8d4de3c9c79b6ee0446d99f9d6685ceed5cd7848468d948de51de158c24f613811592cb36e0fc32921eafecaa508923e9e9695c5d3fb29026453be8292c8713aa9cde8876fb619d8911cf647abc521f645269d3c9df4bc083148c4667b07e50034d747389d3f31982175df18cf721a71e6a9729dad4055e3bbbecc4f2e6a1906f04421338bbe111bb75a26e7876448d775afcfaac876f98372850158e1a430404f2275760ca29664599bbec5106a5b02a03bb0536ce3d4933e18955ed82b2870457f5363e979cb397cab2a4eb381911f0be9369ed1ceb80d5ddacee9ed50169de495ba2308c0209ef416a7090985e0d4ab7fcd5e429f11b0ce9332bedfe108b426bcb1809765c5c4ffb461ac22362ddc73b05921c495be523aecec705f10d9408085395eb02b306926c05651484afabbafd21d1d3ae3ed4859e3c593c17704537db81716f464c3493a3a1311bc9ed616a51751ef110a444dddd3b55cb266b5f70ef1f25ec8cf95ceb7d1b80c7a620b35fa41d194eec5fb066172e4f85dee3f95e17045db00777966b7f2363661bb34dd25378eab2bae924f073b61daff89860bb9c89d4c5630cdf6e8d69e24f5c378c80987927ae449336aa4682dc720e1049689c0174d602a6b5795b2daa904a61f62732e90ee67c6fe8b25067f80074961179103faf2aedf0d0a9f38d44f0773043d17f73e8db397834884372283bb57edbaf32bb55328c4ee942f7a078989731a9c44ef01231b7f3358b0749002f297c47b65c1a8029a8d00acb85e14f4f778dbb79ee8d4138393299e7c9ae0800404f37c078d48a5b6116f8be351618a6bf5591e0a63b6702fa6c5280fd2d9582a3fd7a50d8f51340b4a787783412d334c2020a3a244aef590581e2b010bc96f023960ccf4347ee1a6bd9fcf3adad8431e6ec48330e15d98a119d962918fe317261be0a2799060317b0cd2af8bbd206d52c1e8224ed150d69d5412361f4809685e5a8c42e5e6d5815d3fbaa89aa505ed3f30bae064eb45bb672cd1ee511f92f129a141115eee5045a03ff7cdd7ec849da2d51bbc6402635b56640095014eee819355fd3cdd4d7c0397f1d732bd7d02f1248b427dfd0d85395a9c32501884f1c1d75dcaed33ebeb7f20ad79809c7017f0dd70428319d318b58b3b5b880966a42f7f1af4f6c3bdfe11078e334dff2db994735aba9d91e327176cb2e5735edcbd436be6b10ba223eebb0815706ae7af4e716c3a4f614d55158d4605e2c71c74260d69a00c8bc61c5bf152c73c1236b1c2da8773b7399c58178e46d2f6e135493e6acf2e0c57c35149a3d250dbb047e39b725cfa19b35a34778713a2a9e6ee2bf5b00872c088335111c192f3b3f352e5aa50a2ad5c22dd9ae3da4d4467c4dba353b92f33ba246980071deb8a049c1057ee4bae33c63d258f5940b81d48905fc27818bf99819d531044ccfd5cd3c9cacab38ae15ba2435a081ad3f67e8df8ed074d251de063227bfe0c009939f652efa63f5a4b36a5810717677a4dd5c189989d3c398d1d7d735edddbe8b65fb1621b4dcf7288edd579db311a8d6e4165a11cb3f57b7e769129f2a5b193afe57f7c8ecbe3b0a133c7ac47f24810b03d99f1f97a1eed1f31215c4706638c71e45369c8fe928cdcedf39b6a65a9092f0f54c2faa776393ee8b82a1fa03b7d8794f965aa791a5bd2c31e4b7a9d55fd9f456f1df6d620f6e32357e7e4977a01aadfcec0a890212630ced891f6c5b2449f5bfa1bf5cd243e923adb0c50171c4b39b433e4147f28861dd9d3c4beeb03d2d13ed0e9c6176a2241e0d2fe06d262ea45508611a70a990055d5cbc8ee74b057d1e56aa9951b75719cb5472cf9e471fd41dcce7ce8b70d70a2dfcef543f4d7f97e3e7ff34f13c38bf3a8117e2e74eaaa93098c27540a296bd03e2d08c06baedd314033e1e0d7b3e524bc21c5214ebfbfe719dfc35720919ef0df114f8364b8f09baa9d1be0963e0901e7b233402414e4ff015fe77a19683f54736ef92c1de6344d89722320398c3f00bcb6befe18e850fa3b06744a8004b8b76bfca39f8148c5941f61361806e80b8d90a0359cba228e5a23c8cb79123327089831bc73b6ff27e82dab27f005652b692a5c64ff05ec7962f22fb35da8449e004de0df0b7c81c57a6e13dc58f37e6f29237173a67940dc385550011a90d8489f65457d74ca3829e1a69d74740166a0db7610df5f2555c4c5e10347a8046c62868752d342b18ac518e757e93d6fbd792e2f4b9ec2dd916070f91e00f24e94112e6cf20067e5bb3c71d8ef730eb8abb61794aad646f5b9d0b1596304f39b5ca4a781b8b0b460c9eaf4cb51d639d5e455471704845fd11442ecf5e027b5d411707c1b3df04e51acde6db0551f1f48495a1eb064b8b75ea4a707a0945f6a11d925c741cafdb40ff1676f6a6026cf1a5991769a4d8e867c9cf19cd5a51c79f6469f4030233a63f778ffaacc531b71cb1ef3e354613da4343ed4b1f278eb809c60779ee13b4ff1b3a78043d6b9475d857388a174bf648e8bfda511a18b7c448e60d28b7721a1285312a8054a90ad6d4ffe015d6099aa5e1f56e3cac8df341cdd208e32a278fc3c4569acb50296d667f133a7c273c1e5153b3d7467d3056fa14d9e4b504282abe33c92a0075924de72dfa1b8aefbbc9f4fb6dce1a1d15c06ecc748a38218b70be5eb955bd47db963b58ff547d623f33fc2579d18c2981cb29df096d71f9afb8f010945c11ffbca216a55977c7afb4dcad486c123a9a10be02266bf00a5d83169514fbacfa98bf5ddc055fa65833e8a338d1c0f665b5051dbad1e3b495713a315c9d3be49a59620869b75547374e1c465c2ffb188afd1e4650791a522556f8cf0bd7d392461303af76b06f0e83f9310337f237e16004add48247ff5a8dd326310d215fe8fa224b41869cdb97009487b53e728382671414b410add009c0c12dcce5795e0c991fd3e5476e21d42a60922ca770553b471ac9d39b1323a1d7bbdcd66b86407e5da93b710942def976fcc121b7c3f7dc76365e2aea6cc01a2a4a3b6f74fefbae0fee03c0bb84cbcda0af19ac91570892414f925ca82227276437d4fc37ada3918c4c8e393475da6e25499954d43bd54c9bc5e3b51460564553f6d5de4917db1e359a75850e629d8d575cf5b4ee99e45d5951a6e9d9158f2e3eff753b660ee644b8f7c445b1a5c5fd4d706bbe84e8398aaf535b58cc2e235eece0e893ba6a6f2e6a2bbc1d1a0a8b67e3a1d3eaa6fb05fedb75bd25585f086039c2a5e07897b9ff3410c91458c61d49b4c70c74d1f89bb290c72edeebe2b679ebff851b62bbb66a78fbb67fb7843d4fd5318d2a80706efb773c42348749cbfbeef13b7643373ba91365b14a6a86361a5c3e1eeaaa6fb910d9d52d1479e4589795ffc52fe1f3ccd230436ff1d19442bc068bd482e0541e94f35d5b10cc1528986e444661fd5dc0bc65f68c8adfdd34340616618623235310bf116b1868acc3361fe41392e9c34d57fcd8852656471a35e5c8a42ab973f0b6cf5b4ab10c199febc8de0b9abecd196b15acc74425a09ea934f0d27a6e1355c05cfce800f65d5da4313cc422453b827edf9a3db3b21aa7b3063059b0620a5b20b6ee242fce0f15fe505005dc87be2ad7d7d079ac67f04094b553566107dc06837a9771362276509c324d8f682627f1e091dec4c56e9cb3d921a58b304dbdef3139c2c990ed2b7fa60a4cf0f43f7b87b41419546c2c097f2ee1bb51778fbb64a6a7e5bbd6530549827ecab0d809c3fcbf304b88a320a89d792c5827b5fc3136de11a427785f1598a044ecb5225c138e3c704604888441108c619979dacabb16303d4809bd2d31ad1808f9fafa96d0830b611825a3e0a456e84ed46f252bd911d87af6abfb72dc919c8d80dac24f1add225b768492d10da22b0f57bbbcc68eff7386b15a605a776b43f230b45717294fdecedb5017a9009227743cdef969a721f8a8fc724df0868a111c3784afbd7e1e64953e756b02ac849848c58bdc938d5723f9d814e6f082aa4bcbb909996c43d4f1e9805b3d5629fbcfbcd5215875f9ae5a39db394ba7c921ca64f8f0fceb4e0357b22ae3fa44daf43df55f485369275e5004a8f65410dbad6ce2eda87b190a46f17bdc40690f1c440b7af0166dda6fc6021af2611782a82d2ebc1c95fb5cbe3b727680c358d18ce942149fc7f17b691a4af26586b6d461b46de990bd3f993498da243b8a3423e4dd2189c8ef98e056717f07b5644ea7c33217ac59a29881785f595d161c41a37b929728180581150d025d0da38efd118ae51e86a6a581f60f3b70f71122b7c3701227c3618d06fd8c9b9b9d546ab656e2f9d121ec2e5f68b4c9489a6f31e2499607c3c3ef4d76b1f5eb82738981da2072f09121514739286dc041ae39e97ac6d92ca02b965db064155c10b34795c7ba69a378da416ecfca555d375cac455cb7da2ccd51443d51d6e37489ca26f096f8472fa37d81ba66caf1b9c84a25ad973225caae0cc3a6a8799dc722a67b5ddcc83b841567c50e408d7b22cf03e446f580c2030c65c1afc77cfb985c1e5b8bd1740e248a94858fb45e73841813a80f50cbb254631c5576ed00002c2150d94e0488f99e83699fb322283c004079f7de82ca4de049588fa15cff7ca341ee727572a3172e9cff84a3a00b3fc2d92dab7032bab3aa4533b4d613520a084eddbaea357a5f2099191772ae77982e30a4ddd18566b8c75a5f30454ff026d4b7d053b3e7007d55fd9f314e1ca6985448c52db6563f9ec73638fe47eea37dd75ada62c3f66361c0dd57b2dffdb144f86f256db5d53c191c342bd6bb85afe22df974492264c8a17934278c54cac085db69173b82941693bfc48548c4d8d4247a699d8844347b5e022fd34a756938d5610a2b9dc8af882d4cee126e6bf7a235ca5429aeb019205eefe8abb6f701f91ea6a22b77a840e5790655a12aa109f0ee14c3108c43ffd6c1e8427bb08c4475def65d4e11671e9c978ed5c34c74824d1abea449ffc0c77c2d7498a73605e853a5ef764d33032bce0c607529e7a9719d4ef863dba8ab77c609f3337f1a2777715d7a3fdfd10075a32b73fa4cdd7f088014bf3d87ed479f11ce20a35d77b6637726aec560303408148bb4a8d04b7ecd9d9a4f96a4583cf6ba9268be049842ac7b73a3fc3acb84159f646aa0bb39b9777b9a724e75b6e4464cf5f64dd7599f068824bc1c4d0c5998ec732a43a6503f05a33006c68e96695d808452e916f9d8ddb7f7ee5731488ba1e9e5044d4002c56406f8196a76958aed6cbb4706f082a12566dfb60767a30d7257524773b24abb7ab91d1e3a300a1800774011b133c215e84c0c84fb0c4af22cdedf4423803756fb58bb145178b092c3c1e7d4e3329e1923b0a01459ff81d85f55a3104abe885ea4afb8555fa39adaf0f3086a77c2d2d8ffb03199756adbbf28920259c6b4b0d1da55406d8f2faf241a528b135aa0a0f3a6012526da520f4e43fb83f47166e76b93cdfdb4364a01bff4f14967b619236b6f7e943ad3f9f328751ceeb965b3ace4f63020630bbe01bbbf1ef3a05ab1ed2f1e8d5fb0976d0ab5fc86e5217d1f1dece7a4d5f38688d7d28639cf98cb9c07ea0360bf88c0c3f54695d519bbac0a744efcc456157c31bc350f52f3a6921d0fe89a009ff41d581d0471fe5882669194744fe2e730383ad0eb9d06d3762a8b821a011a7d716f58b76651c9f9aef0d0c933dd18d497487e25b266e9e2e47fdebbcd3f4d9a67622339174017078abd40723aea9d6f9c590d0edcd324f6e2b25863b547e4137d922f98dc86c08c0c735d95c56e69e24fc32c731eb4baaf0378b460f2e12abef8eead08f8f41a44d4eff1d0ecc0834788c8dd7b4b94d7ef07afdaae91ce6592312895162c306a7e07f802b97a51316cf7a40eae2c088c41001aa826155601e36bc8424a6a2f02c31dad1a48c5bc789ef942a2dd14aa75f3fc64506482c9c904b9b56885bb78cb72c5391692ae04c227e7578e98e94862bb73e37262cc5c41125d76461fd45bd6b59b3299e8e2718724c4a1b6bd43cfe767783628240663b1ea7595a35b268c693e2c3e84f14f59f0f86b822e0156ab87a9c229dc3e03323c05cfc2a3a2161bafaffcdc3fb76800d7359af43638f3de827dd17d0ccee171d6d260d04b46ecc41c5b359862cd712c0d0fe06ea918e7ade9bca684482cfe840b51eba863def566551b919ff9f51bd63e11509bb3ad3658c892944e4509decf2b2f7bd027ab3e573ea68537a3adfda10f6eaa3996b73c613d73db2e67118476eb5e42be132afc2a8c93c58a59272ea0bc3fb80b2a0626361cdcb80e1c7042323428e853fc2492aa8f2363e07866df1772f31565d4fa38602cbf75d9881772bbe3e28bf0641472e1c7cdcc1d5ea104656e3ee75f78e04eb0bbe2fbc4cba19adb1341ec44e379a6b323650bc1dfbd3b076956baddfa0fab4c1cd749e2bb84e45ec75d73a8413e7a3e7be1912fd519315537b5ab51b5856f6014d2ccb5eb47609721553ba5950569168ecf654b9c7bf0b818cda6b29620d88e6c55491cf9945c3f81f7c02b27ef0339caa4c9d2a26ab29b5b0df173db5443b4c64818b842bfb79605ddd5f6d5a7c7afd836155","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
