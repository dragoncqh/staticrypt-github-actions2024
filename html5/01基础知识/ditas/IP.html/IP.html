<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b672db90aa41a8e044f11cc529cb5167c1398dee23319b403c533e0dbff16577d2cafcdb24b3fb166da89a6de3a990ac1b743161db188ec197b7de27873df918e69cfa1390760b790704fd84a07924196570f3f80fc51ef294f7c577a7cd41bb52c1a2a45da7418dc549eebe16cf34658a99bca8e85c6da60cd1c2edafcb577e17885d97da19dac5d8cc602be888682422bd1ec3e9bd0c4374faf5c08fdf07d7f49179b582113fb3de4da73c43fd51580c779cc1dfded9b195e429fed9416ca62361809ed9951b9a329ea36bc82888df0b5320785aea1deb6dc5dd9aff503e4705e3f13e9979791fe62bf25c9a4dcfd9035bfd5e710f93488e8ba6417d3cc53cf5066465c6f5112c93e4f2ade5bad9fba59be5b1892becf1000ebf5b6a02a4c3f7707c93c5f3247a92381780646eda09933b2da5728bdc8dc4a8ca29f71ffa0e6c9e359a98f1e14d5ed8351e7b9b9d88102b094c82c33ebf62aadf32397b02c78bff6d7f3900b6ed4e91b1bafde46d24ea407bf4b4f329afd6894d7f1061ccadf5978a1d0806efd5a2655f1816005016c9848367fa08997a6d1ceb994609360976a6a7832585dfc2fcc48c60de084d0322de1e184d7523f6685003b38f2b1b2487d44f54e1ff7764c473ae0b849900f3719d22aac53744fd81643dfa72f4803e587be419525a82428f923f868d7776720b5cde4c0469dbfa4e33c92d1f9d1acdf8b51529a85dbb4f5dacd874b7028d93c44fd5eabc0347b69a173278002363407ad9d4d528d36526dca8de8439e5e7f2967afb35417cd7ecbf98628988af26c30b0e16a93974c9cce6b250c7e815b1ffe52020bc980c5692e9edb1902d980e2515582c98c843c4455628c59fb0b947b4616179adc5ff0740fe442a6d46fbb8c0d20416e8d3dc8ea3630082fc8781da8e5dc0c7c2b6f0a5bb93c70c65bccd1d535aaec1a680a35e8ac19e17bbcc80388fe505fe2ae21d612040110c7a256f32b9ca112d2bcf1f5aed290a2e94c8989f06d52c19eeb721849b160bf1dc710352a63fe0ef13e99e9bb448b1516b0de20def51e1ede140f452c2a9bfff9e9f30b3d5fa6efbfb94666a79485ac2f2b5f38c5284e0e9cb3f18396bb2e2246f2cb4a47cdda5f0515a001721c8820683dc2af699972356aaf19b081e83c18f9e3ae8bab556c6aa6b1884f60c199e185d0f988b11625957825273175cf77e9ec7512067a5e8d7738e420df25f32612017ece0281c625562d454db4b5f2aa97fa7fccc3edaf1e8ad9465669fd95f05255f8000f8ffd4ffa407245b56732848e7806f5e52a34a122c65ddb77fab70fe0c110d8422a206142a98fe9fc72f98aadd72a5149d4e3cf1b5c1262419c4d3140140c9601ef093246243c57868578fff68ca2ae978d8c0c46593601670f0ffce27bb191de369b8d60959e2363e1e2e790a01593c17a1b8376d6d82650396c5411b2a3e40967fa20117327c38646f40c23d4beeaa8e17f71b60db44588dd003234b86ec36742570568aae4027368b721d8841cc1b88683506eeec46c349e64c913e169392c7b24be6d081730c4a91e1987ecb25c5383a932d683a57d308f2e0de822ddd14dc97ed07b96146c49f6a75ba480450732286f6b8863a047faf7b755f29b590bd4d27ae87a8c085cc0e940f1add4d03b021ac164d4bf9f511de1ca4a7752c9753192806c1c8ab9ab7ffe4a46a4a45566f96a000ed9aaf7872c8272a01fae9a40162d12814357108fd4621447614024d9347525bde1bd2a29ceb88e7ece9c7fd0d57dd8504dd17aed1ea1ac5f3584be5f9ba84b62f0ac40272865aea190ad51a78fced12ec7ace3a00a4078af8730bbf64d3c01eeedb55e0df6f1120562723e3c74b4d2b265e3270cee31bb95d859fbc1372009f3a69ee9c6ad619dea8bc8de9dc2dbb30cf8dd1617e5e7352d3baa81d4079317e7a103eed4923690bfacbba69652730d9477c75ba823a11add556fe53d308666b7dabee2339157346e7c454dd6caad7dc2f580c1f99008599b912ec461aedfc6e41ce41bbe436e2f647d6eabd49fb77d289e20e2a1aee6c6488f8124d2c5642b7fa09d111f658c60c7f6aeb737f7ac7ce0bf8e734acba882f7f34b6ea727c6b94cf66b17c532b6800c550769f28e6bf8db190687dba036a1ae4b8d3377a434f7b7d1dd5d65a0ed8a9a5a099d5a49ecdeb205f8f6c9bd9e3d417725472b7db117f2fcd50c124e6dd3cc4f32628729b071b64ade4d4c6aab407a7aa16a4a5bcd151bdfe89337485c7189ae18ac886182766eba85d53454cb6984c87be11ef476546bdc35918715f5bc68140df52904f909c7647513f5e8ca343b06166a8502eb40ea14de59abd462548bcdedc1778a57164ba363c11bf07ff75aa49d63a92efaf18a88cb663f020c15cef41966d9c0144b583bdc2299d0e4680466ecd6e1226821085dd1fe5f6694423aff045b72e39cd3cb210b8e5ef882655e53f473f9ada8c57e6ac7d2aa49385790ebec873c690784f4d40d7c5c43cf88efa2d2853a4aacae3370716940386fcb390446e4091ea521a462c226ccfea494da24256dda94eebc34dff27ff7762a1093348bad03393705c5e7e8da777951f61ad9bb7dfc3238a0a5f7eff08beaef71e7e3a325f4da27f2362794b4a2774deaf00e6ea7d01730c6e5627485b0f8e646eb26c0db011c0b2ab2cab4f37f6958745a0215bf4d291fbeccc1387b8bb7a7dfbb1f0c76912f5fa3311ee21d5dcac518165965bbe4144a98d6b46e78ecb8f99ece743ca3c70544cd33ace33ff0b95426ea6b26007d4c5d15446722dc99c5a4c42287e80cacefb78df0f3c3a5b729dd5b76215ff62580877dab416fd416ee6fa7a04d0e9b9f189287e87b6cd82e440d635549b8d32668ec1766cb2cd837380784716beb4b0ed8d3d3afb5fd21c7eec1cd7b1c337c5bd9d6981efe4f3eb6e20142f61b323717234d42fc8f3e62fb004023e31c4a2aed692ff5e02df52fdb8a8ae48fc3ae16c7c1e0201410c08e440d108cd2aee03b314842e49275ecb5b4831fffa0491542db09653f63721c11b838e23cf32860038db59901a4cd3503b35e3c916259ef0816cdae1631ca8a467705dd0887edba3fe9875133a01541dd66b3a82f427650ef249d5838fb8679ff30208c3239e227718bd9280ceb6e52f5738acacd8f2c3425034fa531d7b3559d8863dadaee020df6f4d659398f28647a1d61952eb37cd860a93760f64edea1436a2e3ee7ddbb5174cf99922d3618a821dd11d6034c2e5785c7abb7ccacaab09997716d7d302cd64f4254c13641692e9a28b86cb099aedf9b0add7212bd362483c34b44c0f633c9b1129c578f06577bab027018f7d934234ba4f3adb1e5c6eeb4924796e5acdabfa375ec7a1b4e0a9cdd0b6226648e640700abb0ba95cee51717fdd614993e4c52cffc2c9930c21e9447b35fb2ad0e512ef5deb794bc9c69e702dbc690cc1a7555df9573c466cf1e61daa2a544da7ec1d1b622c5f14d265df51ad88b27f9f8eee77defb6994fcb009f3f046d34f02368bf36a7418047b9eefe1878d5932f216173f114a3eb0cd4e38fb4e0f93feca365add5d72d508925519d602759d9dc3a276bccace7e4e791e252c70af142124bf16beca526a970d116f14acf1d8fffe0b101432f2c6cb588b30535c051d3e2656f18d79de04153618f08b5bafcfec85fd63937fe6fa6bf1b9fddf6e140402270ad5a31322b1c62517467db85b109a526a460e1b70d15efc74f509c5567998614179cdd4a03700263e4c5ed4f27d277b970efc61fcb93221b203fcd32181b5cbc84f7afed5a756fafce145a11a7343c97c1384aaf6c3961462c2c7990b21e0f4442686e0d565a4d302e40339879e8e2029986e110e807808416a4a5baabe93da40a329549f037969aad4ee6a69bf3fdf4d13000e3955ee35160ff365ccc16e33d46b59834487aa55baa027f993274a12effbcb9232bbaf38a394c678744eae74427e288411c28e9ff8f59f787c4ca9c2f2504604bd3852e9b4ede12776545bf59258948c11593479f6d26ce153e3ce494659531051770d67147b1fcd2fd3decd53a946c898dac4863f9a81f0ffcf5ff8d126e8bb952d6809158ae3fc96b30f293ed28f79ca04bae0d2650d592c6a20495170ea40f91a014aa5429d6b92250a645cf66e89225a58ad134c2f02c3bbe81b6d4fff3570bc99889dbac945637b893dfb6792af26fa7e0d5bd7a9f030341c1346238f8d603012acce4a58d1e668e36ab4bba6977c859a67b8433a4640e97bfdb3a88d931f0e4f8ab5ce8804159148d37bf8c770a7c7da7c3780066167bdedbbb7dbf098eed94bd95d11ea28d03cc423fb3760d7666258d357ed00f64ef6a796c0263f7b9c912e44a8ec88f999443494a19c5679aa90dafe6935a661725f523a530f94a44b5583be1132888c7969460160c49f35f6ca9e79d6b42b62741cb7a16c1aff2203d74fb76439bf2b6aa929a1544bc15b0ef395aed84780346992da4124dc87ffbce4cf8915e315bef79e4dc681172971fd294949de5843eee14ff42f9e848b482884269a369203983bab7b0740c017cee6588cdaf0ca90ac42e4515a27ab6a0f3568ddfccb977c213e04ad2c7eda29f72364a531a8f946ef362a791020dea17697f51de87cee5d40391db70850f2a56f6a2abeb4659034491f0daa110094f34121d10c7ce8d2a48f4b7d81d6c4da65e44465483c08319ad4a29fb6bc2cfec7226995ead70f1b8031674eddb71cb8921328b01d011ba0fdb7c125a898459669b8fb57dbe229fd92d16c0e5b31d00dbb287a70d4b694f598c96a1b971790d29680fa3622c33a578d49193f661e464cfc073c2f61d53beb662e1ee0d634ec2f8fe256eed72910ba0dfe7bd96964f26c6830a7e2ffaaceb76e606a71be9ed3d2bfcdba1e3eab26d627ee6f5e5225e6c306b35b445e7c48246be73d6a5067701f194b2db8b10717585d0b47b2ccb02a85715557e7b8ea2f0adf778789c7fbe44efb154324450bd3216e63aac5b90ef83d3dec0bd16ce20873b4da52dda4a78d9efeec0b8e25ee75c04d5324d2eaf866b26375db3ded4e9584f4998466c5e78d685eaf76db1ef26e45e667e73ba889048047f7fffe8ee208bf638d65b60f68bf3fb24d552789faee4b80c439c7c62e45364350637160bdeb7dba686b0641a7751f349875d1ad2c88995cd8f16cecaa74d6c4c4f34f9a27b954996220a92dfb8579b96bdcecda4b0b8febc3f0fb8a9c4e6b690c179c7b2b527fc697b7fa425f9e168318d51fd68a8494d488a215fcfcaa250960c1a446da369dbdcc637fd753585f3db84e70e42b2a7ba82ac71989b4c40f39bdd8fae9f634fa250e31dcf14a725feb28055ba3770f63bd76f26aaf4849d67d9fc9b9ce114ea6be418b019b6d1584fca42d66f23b1fe7900a05cb2b2b02fb25b8c6af2090c00531f9ad9daab99e23895912d122783f9faa59bae03ff08c73dcbc317cd646f9f4894755f44ed285eb2376e1d9cd0ad12f3d0475b34e28f9fc6f1601de04f9cd8ab7662b03ec7189c2338ee74f73f59bc80349c168504f5d640ac622c379dec1cd332882ac9877b3b47b80b756b458b43219e7f1e051cd9818bb675937cc2aecceeecfd6ae7f78b6def7b1079705","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
