<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ba6c0a61d5a897e828f31e67136777be657a8029727f668dc8f5f04a328e8870dd97e90a2afadf1671ac2912678f3cfc37cb202503ebd70407c82d10833a8863732fe72b02de6a85e044cc6bb38ea34189b839e6fcbcef58a2bcb6a34c1584c086fc45d09fc5d73f6ffc6dd5411b0194e3849cf77297481a31ba3dc92cbf8611f71139f3c564c35bf3b5b0ba884e718accc342a6f888c470efae93487cc7670b8a45b8e2613d1c9b00deb5c977fc67f78e79768d4aa5d68909b91428033d47d16b4beb891bccbb1ee481a8b19d23bbe4c2f322c4132132c30fb9586d24468a2f8113a5ecdc6c65eb2ff06fe4f8b52970578cfc32463ca53234f9825e90eb32832065059d9bccc6056eb587b12748be1ff870669ef3db21e080ffb77329931652df489643173eb0168e6bfd5826cb116a1e6e3d74de051505a905dbedf4f4fd00ac60ad569f153860ddf9883935c05d53978696d5ef1fe3b31f1e5c79ee8d3e4a621b9f3b17e9a7864f12914e30982c16d01fcc3d76d62a97d8945712b984ceb1c5a5d609d8620bf48e1b6326ce2fc44872c761097495e30aedbe033f3aed5ed300c3d7e4855262dc3da41ab7c4891212aae49f015dffc1d1050145999898682d8f5305a24e85b6c6ac4118a65ffa9a04b779ea02532642a4514516ee96de29c82912829eae95154516a3c4f35e721cb52133152d35b4045e156ada61b75ae85e63f791323bf50d4f9e66a302bb67e04d064b0abecd37e99cb1b4e0396bb440872a7fb27e8c16e516017b89ae30c25e8a20e350e18dad3f92946efc06d68d7faf397bf64aefa95309ea03ae8648b2b0bef27f7486e138a51733e4c139c96ad73c858ac6ecfcf46e20479f81679a43bd9cf0c48c7c9eadc5b65c553c20eb138a5223872b5da6d16f41437c24df841df4d2e3893e87892419918d07e0b82193f089d130825c6eecb3e6705720428237b4f5b7dc53899f0594d78fd69208062089094475ac82d3c9c1ea1965d85f3ecb41b3b22ddd5fa4d2c81c5f9cccc42630077cc054dd39d85dba7378bab32d610c5f6e959f0537d34c8cbb990cff64ab96fd20b68b35a8482fcb568b63bfec78449bfaaeabfffa47ee299bbfd350f3f6c23d046f1780293fb2265cd46eeb26e807572031e8cd6d00417f3d03a7782a7a7d0346fbc243febe9ffbf3e5e59a2e097fadef51a9c958516a95921cc28c0d8e6251b9999fcb7e93e9d4d98efa8d25e8ddda5b1894803a5bc3a5116c6ac58c70eddcaa63d23af6c453e60b82ec786262086af2380dbdc3692cca55ace17bc2333fd901e3a7a0cbf5e7d19ed447eaff5a8b61bcf08b0e0beac10e1c576e8a9e8a3bd5652ded4dbc1e0bacd248c512e756308414d22a916a722c6751f4fbc6a22f60c3c447766d0f06b30f966c960a1d58b83df1edae24449935d995d536481f281c34a44fae98576fcdc2fbe915b04daa43c50b41de417cb1bfe1171fe87a0aad54271fcef852663d3ef18061f4f9d41ed138dfae9ddf4c6c634383be10fcdf07fd74b94538d0aaaee18bd6fdaee6d105f2fedbe723bc0e07cacdf0ae35c0fc382056a5f2845851509bbc5d65e6909bb89826f028e2cb496e88681f0d10888c0758a082cc8d9bf9bce971b6c8f509ef8340d8b01ee8d78f86078c615e214f7210008f20efb0c753c9e50015f407cc547811e4f2be576890af6cc8f01decbdd32cf10823770c4cd4e1f7c55f194a7327dd2c8859f1074c8494cc9da23c70667b73ce25378da645a7822c7739cfe7557d6ffba8c30bed04bc9e7fcf172d19b2c862450a43e22ba57ac315d29c09567c374e59fa38c00a25a0606223200b58eac76e3c4937d85029e5e8a7ed6aad50b3fff3139558767c3f41bdbaeac824ece8e406335e4e5562fae4525c929ae9ba20d6fb75b348e831b509c4d606dedee46b98f4bbc379aefa57526e93a29fca402f7d21cf774b830598afe9cc2f0378c99f6839b59e9ead252015f5488ba3e34ad49430f1bdde7c4754889a3386887bf2e8b56965c946255011900425e0d367b0b76dd42a06b3345303a39d022e4afa3362c53b52e8726c48b3542f89f9b62ea6060663aa2cff1f21eb675707cfe59bf8849ca258dd4a94deeae79b21b96f515a2646c0b7840d1a4e3f6cdf58656a08847322b8647bd8d34de1b34cab3673120851d08667bc43bf79f4205fcf88ede1616037cdfcc166b759b72f7e66e573d743ba45091ce35a222562fb42ca901408e7f893b0a1fa858c6cce909f6199c2d213fd75ce114f1c5882106df3a4fccb079e36821029fc538e36dd2b4e6a9c4ece4d2f659445219c0e9a9b69bf8b093fa5b25740a07694e8fa3757cf7ce81a96e4c051867b369a07031a118dc947c7186f123c5555645afe7959200b8301020647df5d759f0917710111e6f699ae3e583349eb0bd2102966106db672f988cdea3e70e35a45e91fde2f751b681292a2ff7d2f339fa07cc9c85844ff1cc427ed23d8f08b763d2d1122aacf2979a8ee52b4f68a79a3a55dbaabc6341d94660e3d3c18515f3a3fc20f6c4150bcd6b219995befc3176474276373b68e35929472fc16c246cba95aa3dda177850d23a6810b1196b87caa85ad28c7057e6fb5ffd5cd7aa866aa30a1bf2430d415ae30a24fae29d81ea377ae5f7446386accfc51d3ba84f356237859df5da8dd1f6d8202eaa684a03f4ab2e5fc5173e2627ffeb6578c5f75d5e1914c2c464a53486c51d4d0f1b6e580e522964aa67deda33b43e772fd8ab31547d54a0d7517f405982afc00100d8fcc863240453b767c5cece397e45cb8eeb7a88184d6fa5d4722320243e5ef07027fb1bfd88e9c4e0b816b0ba4833d662e1f5f73954eee197b91d7bc9367c8678e4a3b315c3dae38155d5038d06e6c36804e499323a3f45fe204520a18d68deea0b07d018994645eb45641403ae9c048cb8af000d9d41a4f3dbbffbcf2e93d9ee0368bf080ef2d5b9b59bd06037b42a7902ea98534ff4dccc03db8cf2d47f65225b50b58985dc5def585ab6cc595fa5adc5c3384871b42dddff6ed01f86a258e8359e2c0ba7471e02d9834b7ab8761dae9e196d9ea770653dbb8a490c6ada97f09f640455c702f554a07ba466a62eef41558641ea43cfd0078df1adf664dfd1e256b6eb8482c47966ee8156d13a365abbc57f1de6e10250f7081955681d9180e844e599a627710f35403863223534a4ef3301116477cddcbba817af75b4c2081a4463a19ab4e3ab102c1e3f4e8975b8fd313812ee1007735d548ac8b47390de781916fd8e5e61c9a11a2ad9f497b7e91615df2e69398286b8f79c672728a72fe80250867d84ae72729d2b22aa7bc92fc286da1d0f8be8cbb521e81fea2b05d9409be505fb52629dd11cc5991015f373abbf729a47af3cd14c0ed083d84cd3baa93b2abbd905017e13011a60d38c2518cdec27c6c186586b8b758dce953ed8734a066ad7dea95fdb30837e0416856b3a14d640c466379f6cfb79ea13477e768bdefa6715cdaf4789aee02a9139fa9f6c64e112075abbb6f5568c8c8533c245f28e0dde4b252e87996483da8861d05411a7b65b8a8fc6162cb187389d2cb7e81eaa8090454607655fa5687b57415a6b65a25acb0b1bcc0a601fb4a07970caa8de7c874ab1d7d2fc1a67bb9788eb7e3c663bd7ab7a4dbeca638c694516d530da75f9ce9b04eb6957cc3e83035ec2a530a413ff79b9753bfb11fbd432b08f860155174b1d17fdcead9193d744921dac5e8ff4ac20d859f0a5fd21eb98852ebdcf879d7f731d4db926ee23c9013f4911c232cdf34e9c822a02d249961e8012ff76e49e701ae7be67aa7ffd3207dbf426dda138c24894402e28ebf3c8b36b163cea9262b52d1f02adcdc2204e7597c597abd497095c669d154258bde773b351d8b114fa9d5ba20db70a45b51fefbaa22a8dfc617c6837eea666de4e2012c9a03a18de24a490f898f22e5012fd8613d6f5c3f2cbc60e0217655e3935b49b901351dca35925365c5c687c6ead24b7c088c5d086a76df70f1efe7f34e4fef0c5fa9afd84dce0fd66fb38087d9ce5f28c95376e0d61ebd0063bd7b2a53d578068448008d3aa73517b7eb8bab8a5627c8fb2fd2654bd74ac354c7dc10fdaa88fceaff9031e2fd46748ff75be148db1dfe5a0f56a3a9b32c706d53ad6fc4f542499c822bc3cc19061fd42a10e16d5e23624153bf30cd39b034af4bf596e0353969eaa594764b2c037e0f76fd710f8696788b931b1edd9fb4eb4ddfeb2abb87955d69cc414c7ae783585790712a48ea663fd3b3c04afec37d8300b232a8c08e5b172f7d4a05f016a3342c3220be2cd42a7e34456919070f4fa97dc366042690fe9a0f43a635332ffbf488dab3b7d7371ddbd0e694864bfa71984a91d9a5af3788d50eff4dfe517f70029f6fc20f8f2c463869f104b9e2542ca90905bf5db6fa756f282a77688252d323013746f16430ca417483cac335c5faff9222f7d42dfdf1df40ab4f00367efbd35a636e8c4b674d101f73c5e38e8d4149e2408ae22145d62d8b53caa270988bd714cafdaaacefe3b6508cdd8101ffbff3c45f53960fcc04ac2bfea54e5c8d115c98ac63df174ae7e1c46a5529a9efd7b72e549774e0d38a5dca95efad3ce14f064063add197e047ab68b6ee404ad9201719d147760fa1f425dce0ec6d9de7f460b3fa99990d7255d9ff1913f22addde5824b1a6e5b7f899ebebd8114152ca2e00dbe1bec2ff087e65a60bc9a94421c26dbe3971a39565bdb2441d187b6bc7e44dcd292871cb8c013b3b509b2daa200306c691e821dc21959a7f4fb7d2b6f6bca0cb21c6a789aca1be411ece8f9638e682b532e24fc67ab37659ccc0587f77672b9226960874d73aa7b278bbc1aacd3286488c5072701e6232e61187a79b3023bb81cf13758a25546884cebac5d237f498c9b03bfcf16a0446a32d93529c9d4dd6336ce58af4a3f180563be05b3790f6d9591e969f167783d4e499ef14728f694e026fcbbb43b3ffd65cbed43c33dcdcdfc91e493d99e7009dd7d160b2c7b1f2dc7e2b2cd8ac68b69582573db3732a91fe1d6b8e602c6cc2a63b63025da4dc84d2eab356c35f00187eb522d128169016c2a659c122b989d390bba6a9fc119494369942c59e99573b0e3b3468f2172b5788025b735563d79d6ab19ec7bf6477be6b3e61fc858048b3b430bac58c099e2821e215ca6150c514e7031f7b58a9ff1fe9b8c20b13a6be2161f82873f3722c37177647e8dcd05f7d8ed3e937dda919ea06bdaf514e6793e2bae2e5122c5f67f6f14a8eea5144d85e8342fed1499141b3984fe267ab87241c312f0c3b0fd6fafe78b3f7cbe497351f8784d1656607914d985599b86aa126a2d8b6ef361eb7bc98da00a965b66a9ae3167ce4e9911b716e6d0dad8d79a7e685a0875aed80b10d8228da4c8ffdf69358dd7c6eff98f51cc718ddc79e4a95e8b954bc8bb702fa75ee67e097615bf7f49bcff1220c070445ce130a048372ad0faf52bc2dafb2f95796992fedd03d76652988a97e93f082b1b4a112e70c53e7cbb4214dc947f366b2ead36bab17ec85979d12d092f5efcfa7b004a488fcb4c0efb63bba64c9730a5b1285a9562af32dc766de81fb0a13d82b829acb9357c8a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
