<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"343c270cc95a6465241ce7550f5b96f2bcae779cc345e4783b63a9d40132ccbc1e17d1c9f58d5d28fc3600bd37389e8832b8be5cc81b8d2f780a591c2fef082f55e315ae994b384786215beaf1355055e2a96db153cbd9c2594f2782afe3c8ae53963fcbc0cacd28a236d2ef4e1f901efc1bea0d55af1d3eda52b2a5a9c396b5d8c9a446ce5fc8e81d8d7ca907d3670c98c38fbf61f1fc6a62f8637fab17d96efe79d1753b2f6a09a11ba82bde8008e9b6749e60538a891f3f2241b4635823220923309b4efe8207c6a1986d0b27eb85b503a3f59173457c3547b98ff503b856043ece114e74c65bff964e37f449360ed7190c023912834eae3ae761a70a645bdce69599e10e39ed5155881f9be8731373b929a50d1958cdf9da1710a97c44809b15bfd863427693e042eaeab8b654a720b383813e5b7e62b2bcb7c6d91913514c9ed8b792bd39f881d4ce857e5e43fd944f6dc87f41bd21d0074cc806ddea7247e8ded43f55da0cb7fb66c73c335f08d72f7b4ba380bf41b256884a6906f7a4a8bd0e49b6c6501631b37ec60b081eb2b1dbdf3f550e3d2ab35d2a05572ff76556ec883352ef841c6e4fb809383925b03e60ab6a0b78e82da17241f541130bc3bd73bc30df1520e9f955def1838e4de881b19226012173120380683f158db08138323c7fd7622f65cedab5215918adcb866df7689a9da4021cd83f7094a751bd961cea63d0211742b1b7aa853e3729c90f1240417c855cb20aefc13b7d36ea1d7514306efe4efc07440bd79588d500b7a74d2de27b50ea7b9408247092c5794b63c7e6e4b08913e2057549988d4b466d967353781aef092fa304015860e1f809a2a8aafadeea8d40ef47b0299fc1c7ab815748befbd016296c8e19d63753730bf80601d999f583a79ec28e7e92717c1a5e56723f2264d13d3199dbc69c08aae22b122acff729565920cc3b59eb489931e78b6a55233d6ee8f43bec043dac259f6075d7649bc1089c296083d770064230120dcef101f3db84b162ace221af4eb725237ec6722901ad90efcca66fe6b2c13fffb9953704421cee4690a62aeaf5b189bc1d795c8a8e1083c8c22474d3ba4b57353e8c624cf8f973e725b8cb59eb6c3180944bd5b417495837fcf0e71b94e61b25ea613dabfe8bdfb29fe47e1d7daa54a2ceb5bd0b38765668ba33267bf8fd3b78fcfcd1f86beec189ce99c5d85f2d3cc250a20b07296048baa19730f58dd739fe135b4d184653dff972a9593bd7e1eed3bf8647d3cd88890dbe2f643ab1b00da81c76c8abcf5a3316d6498559f546ac79cabbc0d5cb9bc528b0970d09c7c91e9d0947eb7a542b126844177d5962ced74655ed60bd144e7994e08bc07a1e2b56d7b78f2cd71ae0962a07f27b8d03587c6d0e53ca8df1dc6db06f6dbf382838ef2c7c239cfa530e27ec403b210b01a702e12ba4b5a0f428cc330d63e2819e65466fc1c952e53a8a5e89a956fe7130a0b066b0a766da0715b1c52b6f65e19991eb697fed356e5373f9e43af4343421b0c2a887fa26d2192186feb9df2a3ee4f4cc2e96b06fe8d448025c5dabb74add96c186d97fbef6fd32ec49727d7d6c71246684a538d39c55ba6c6b379fefcd5ab11e0c68b22a73b5f094631c51975978105d94cb8949e89b48657085cccdaffc83036e33157d0d577257cf612414bf3006a3963a415e87a7dbbe8c26e7dce4b85a95912209a1de0f67076c8cb6b988e791d502d3fa4f3a5dd907630a26669f79d507a5433c7809f3939108bac4d5a4eafddc214a8699cb0d3900d57001439a608ffe7ca1249feff936c7827389f732b011fff2619f92e222f819b0a0f52be32cbe408e22a92dee8d4895a0bc12f4ac6604d49ecab5a14a14aaac92244ce9be0426190f5f03f5aa28b87e0619556d49417539770a472917e766f04bc321188e17adfe48867142f06f01e6adaab380eb735b7b992f1ce4481cd1d369b51db3451f0bed78aef32044fcb6c4108c0df97c39ae2bf1ac166fc4521a946058e7c135b07db700cc612f07c55788973e65c2d53d330994d4bda9b3eeae0d1cda8c192b6b0f39b88c91ab966c416672e386d1bb098d19cd6e84dae6eb78f3b31f0937f33f28d88985b27fc524044f664b1e31d8bc818eec0ff4fc8b7582f063f483651126957eb746f21705069152f231235028cdb592922905022c0669c3bf5309196eab6c52c9e828228a07ddc5f980926c9b949743db95e21caabfabfcd29f559a10228ca5e80469bf5da3264a302dbce3f98fda194b638eb485b12deae79fd34924cbc1ca83e0d965f7634a40f8733e8a00b35778ec679d164873d8a09fd9e6008036095e4bb084f94daddd71f5bcb1620a259207d71a56fb9b09ca9bfcacdf1c0d1807bb9d923d6f000c3b96bed559ff9fd7d6b4779a4053e116e51c892c63a9ed004a414d6ce63d6617c3a65718d993f52ee921c9f32a90f26070204855c4d4c67b9b8ab5a18e3634dd5f2b38c9e1804a87079cd1a8b7c5d4e47c39805c799417424d65a84533e6eb967e3190353dfcfb7f841bcb1b994f731075839e0046046492fe8b4c18fb8a30a95fa7052ce2a4d3c8994641034b819ccb676edff8c7b2613d9ca1723d508737cabf8595aa47d2e1e88c78777e8537be5a87d05b883cbcda4c1b76773c55371a837225b4485dae317e424ed25494cf34482752c932210ccd9788f6a08cbd6f3bdd9439514a54b144d5bfcdc9eb10db4a9fdc5bc44fd26e141912358a4e2446ef7b3dad9ebdabe10e8be558c6cdfe65eaa8affe50d2cf1ed0c64205b3f594d9618d8c439c6a52eed4b70bdcbd2c4bfb8a261eee9c6a2cc4c275cc332f54498597cc1d4e2c4f606d7bea1f245c4e2fe4749e35197a34297b940d9bab0c66d468ddb109226166a3e8b324edcc5dd69c3110befc19f308251e25d1580536c3324c076eb5f2f464777579e62fbc29b238dbfe059b51d83c955f6eda57bb75ceeb84270cb7a25e28a88a94cc694956b9be3b6de3b0eed87bb0ba36095f1f96b2e3e60cf6b50c305088cee027c7eb7d4555a38fc99bddbf7ddcc4927cf5f54ea7b43c35eb6c4d2ebb4955dd0d2ecf8bfc889f636ed7f315764362ac16073c856639e06072a62a15aabd6c4dd4b6b21a0cd9ae139f003d6c2fca449572c32ba3bb388793b0759b3fe104753c9d3820719d3721ca4a9f601a8eeaccd757985eea57a260c47a39b13a0a5f0cf4f4375001f86147364aec136abf89b13d52e0aabb68cdac0d74a01fb8111d2b81bcf2ea98727020735e033e679a238e163ecd69047f1ea98150f95168ea6baacc442c1ea37a03f10bb996f59229832c71c4f107dcea7a766e7c3f02819c796442f6d09d3cc316e624a8da379d5a5b3068c6214f20db700a239e3019b45b9003343f7108e6b91aeeb8334bf967986c627aeb886c478de2b70d94cfcc7219c9e57604260f72680d30d0f621ad28085514b1a67cd98ed7e8a116765a797e87b7ce44cbb10fa0f8c78e44f31d497b8d88bd661ac10b7acd724743407210044358c3970a5fe34472360d8e7028ee6151a5d5044e43fd4a8addfeb65c3cc598a4dade9111854bffe19a0e69e4a3c57f81b1465b708527094a9ce247b08d7d774b4ab8f5927ab1b29ba7fc2e339a6e9a2a81d486e7fb1065f4622e43e93331b3d9cee0c4226f884458686d8e048e652ac782777eb0aa11cf5b5900c5bea237bd544ee2ae18f7af12f8d0e236a01f3145a31e722e88926981f93c9131fe1db03c041c42d32075813e5efee6dcdde1bd60feccfa378686c8acb6e9541e8964296d63558b9c2b90f455a3df269f441c92e7d48be40f24b2f8ddc53218789c66588ddbb64a06b0d2302fb283c8af1ee79a9861d83c998610520acda0a797560c7b56024bd56bb055aa16376916697f5720ad43f266535f0b40f008ab23044b6c7139836cd81536061802b0964de5bc8c1d3143227aee201ca547a946239a2f2140466696ae88e00df6b3f492b0ceaaf7b5a4569a57642bb849e7a9aed492dae70ad3be5f1e92425ad97b116c0bc10d124dcf26c692fcc7c341a9abbeb30691145465a301588bc401177250fce121bf1060f486e4c003fe311bac0ce6c46d3c0528db2be2a264cd41e76fe9798beb10b7284562b67e151482cc50c00976b4138f0d385681cd738081365bba71be0073202e76a03ae7a33d1fc460360977584f87f500d2ee9b445fd2f8e3c4715b6fa3bbc79d990ec920f37f0a43669929b76b4ba242d9a4574f29be313159aa6f6f4c2c33345952b0140629bc5341cc37b02759ee7e436921d865d26370d36b93f91b8f2526cadfb7a8c58aacfff765388086536668675af9e8b1daa96ddc072954a8bc9653ad01140f77373fe3386a5f713aa124864e25ebc555ebfce35068ccf6e067d33a9a49c731c6f41863a12929d3e45432a74cf1d0cfe21d5984f3e9d2de1f9dc57bbb4d6fdcf3724dd99a0b9a5680ca64bbd5b4bbf42a53604ba9a801fb6307f496be298a959b424dbae12778cd7415bc2f37e6b428eae72538335db69d22cc02de01da02fe56929803c9dc560cce49142783d833a4a87bd8a2978fe868996df31369a542aa67bfa6a83e4505dc46e4365fc7613d37e36ad0689e599df68ef1f1502fae7f269c8161fcfc2ed9db7ab74508f7e520941e2362298d007d3f2ac035b68d92906a83d5733cefca78be51e53b94ea86cf6bf3ee345df8bc989f640c217ef089fa6369c0c4be784606b6db7ad3c592888bd7284060583ad10d8d76fb2428b13a4e8fa105741318d42fa1fb735785afc8b6edef141cdc362d5bbb63ee4467b95181d2e1521e3efb3a1978bc41bfb518b323f3bff5f7c13180d4f575c1db0a8eb7b786c6c52f72fd9f9172db9d17947f84ce1d65b47511efa54a22374f9f6f2285d98dd3e3aabba91d4bc99621d07ff3650ee2457016f93bcacba52af947a0295fb8fbb3a5ce943c4fc87317694ad59490af0093a950d8167aa17906a27ea6210bb69839bc2d04a918bfc9b49dd6c2aa5ead3c5b7f6d2d02167aa16554489185455437c8d6a5797221d0301c4e77b2c294e683d9c5322c896b8c9d9c17e19222e0a3569667968587ae0960e16aec6fa404185ce47a3a5803b9ef028f221f895c1380e3875110b982b7deefd3b6f1c22a8ffdb3c775bc0d374a11ee28a6b5d2e5ea00464e898677840fd7365f1421877983a249e4207954a71f80a489fc1514aa0fb8b99f7b8c3e85f80145d4dcdd910277678a029ea98c4ec7625d12c67e279ce36818b46d40f502d68004bba5a8eb90390da9f05dbb963f54992f241adab9355af953409df3530dcee862c17c3b21fb0449825691a084574622b1ef8150e42cf250dc0e064b1f892d44de01c63021ac11a89393a3a40ab393dc1bc81d5856865b55daab7258f56fbcc0ae0aef222e4ad97f2c1f052650839bb7f5946a1190eb58fb240b8681380950ba6eae481705dd61ce85176dcc7c0db9a8376e87a7aab1f04e9010d5bdb3fad2f163c726101d68c3468009fc704bfa264a8e8bd32edc479734fa8d169d21252f6dd97b1a7b4035ee2e9cf0650af61eb635097fd27c2b95518c9af2a3d4fe261f568d905699454ad5ba5046b6e67235407e512b7984171fe0ccdf0918c1142f2af531bf8a0421012c27452ecd324e3e710aa02e91d6a7f6402c6c110aedbdeeeb84b745de66a490835bbabba6355d9ec6cfca8bbc0e136dcb69466735ac3b6447957bb4c6229daa581b92f2c6ed7be5f0e20891ab3b00a8c5ec98b7963b0702f8f29fe39523c563bae4a74a6fcdf7147b660ed663e8667d54f1a952cef4f615be73e23ff5e3d0172a146ac31059708622955d041af5be2770ad7cf436cb54537b678dc6aa4cb85c5e813bc6ad3d9bfae6b5a04b0836e3e97c988e3dd40c6cb57908dc212c63f708ede1753fa7fac2c87a786a9056b1730e2d861fa690035cfa51ad2bd415d2eb59825f4733c12f74a9fad6928a6837cd723ac86eaeea0bec5f34b7a1c308fcd6e7c0ef9cceed8e6f26f28f49ee7eb5bf3892d67e538cd915486222f33888adc71e402612b3a8424e867bdb5e027a95e11ad02a2b6b091334741ae2dbd79c5eba546c8fb0034bbd71b1074dc3427c2daf1dfe32068bfc75bf108f7d6361fa1d0d9a398dc78bb87c85499580e617bd686cb0ddc1b7556b847423104ca2ef4cf01a4e2574548551578c64f0f276827cac136f70afbd67ddc4bc129a08a556f288e93cba9bcee426b592ad9a1fc9acabccc1fc0794b3b76c4b14248519053f2567518fb0be946a83e222ab56d2c428a7030e225f249fe74c597ca9f2cbb9eae4e072948ee0b1831b6f2ddaa275af6d8263fb0c261dc0ecb836fce42a7d8e5f302916be5838a8c5d529909dcccd36367b825da206b741aea8843e9e605c4db4056e1f87541007add7007a0cc967099c9b80c05237f0f14681e01dc401d7c05f237487dc9714a65884196fa75a6f94c46d3759194a05ce4c3151b1f0c5d8439b13bf89a1dbfbb16728fb400a78d3f42cf94d98701bde7a760ee9fc43b22682f5ffdf1ea01c40750fda1686250bd2f7ad17c5757c3ec9f76ab153c7debd94c62b02817208529f9412a7e0d5304f6576129fe4b129bf3381fcfdbbc4dccf0a75f05401f66a726c34720c6cfcccf5126adc4d6fbf3372030428eb48cf50c5c99b466106bbd611c4ffd66f35d37e59e54ef4b43dc0c715ec1e3e2bc5727ee46a6f563f2b218396dfce495c7ec0e3874c3c065d75e45224f935dd65dfba28e855983d92ae86c38c2961b5ec651a3b56f18bcec8f7cdb7c2b9ef2d1813c6653285b113e72f37cabc81f4f5df9da450df924623cf614000b61595d34bfb4f40d5b69941897f3ae54a7c1706bb77c767b69daf3bab6e63dc1c9e16f85fb47787a42584bf33f915dd6d6957b67e7ceb0d27c0968c3eb83a0eefd11f0645f64db0e716899e32da36b5504a99878705dc330dda6896c1df8c7083c8d42c03464fa9cecde1101a92c27061ac68ea855fae355fc54372a0c57bff4bcfb6c4314f1ba32e86bdebf0a9d6c519681fff52ca6f1d4fe1c4348764607a1fb874a2c9285ae0d52d670675470954fe5798441348865474117bed10800cb1d4a830f68173bc917b85e45abec06f94d156d1d80b08d9316b3081185b5b88fae63f314c61c11fb117bc11a660d15ea75e70b7c5257a334f3526768bc4844ffd4867f60aad6b8e6da8936b14a2378b4766194f3d08d1f5b112205b90393e599ef1498282fa6d12643c3c60f9539270a9f1d95606d9c410d824149f695184059b46b14bd06fece3766400d181ad8ed615cc45df6e6326d1357557bcece0aefd83476a54baef3394ed43e5346c8a3d63981afc0df0b5831e9ea5042ac1893360147ef85d5c1457399d19713ccb75fcaf62236625e7724231d84cac143f5d2e518efa4a195cfef5a7ce529ef6272cbf841db3a8e981c1eb2373e121187dbb17fddcc5275d7453079e2895162bd6c43cc9ef064126079bba8237c0a53e8a68e5b33e84c87da48ffd846e7ac0754da634cbff73dc32c1b093ba1445e965cbc59b7731147459e526efa4f04f2399c0c5edd1121b0c17ce08c28243051a4e3c3f164e19caebc13be1209d3f509ccb43bc53534ebf4d187504c3c96e3a603f4a2ea4402a0bd8eb2afe7b68d6a3eec796d2352981645f3681a43f6fb395377b875ece0e679e5e27705cb44e201bd235b2e846ffd710bdae73d7e80e94fc66458c9dea9fe0a316aae7d57b03c9df884451d87564a042bc512a614d75b6cf5d64073885042d2efbe18bf4a086cbbf06f7512f69980625d01e5a5d01fb48891ec49d3bb1e19256a83a09cf6c9444931682df6a0869ac518a8bd8fe4df83aa275e2c11cb9e59d3559b3cacd552076a6baace3170c730a09077281dfa2c555436619187a200e735331ebb6de6344cf654201edb11a4b0f53f6bb8ecb882dd3fcd82e1462d7ef633e79ad73da6e9b30e343267a74975e6b3523881d8f0f7092a2dd427963fa3619d184a9fc209a6defb097dbaa2e29b45b7b3cddb33ecc4eafaee45487923f1fef3dd0f5a38f845b0a4893ed792dd5b202959e7e70844b57d14d9a1b6cb2105741504de7797b5d6a24a1a21a5bd82a1f0a92a97f42a45b399ffa6fd7f86014454d3fe23ba6369094e987909c0c915eb9167816740ae675f884a096cefc9ddfe6cf78d4252b4da7e71c018b65dacf2113ace5c131bcef4fdcc69bab95ed4b1027f7f3055d1e7bbe3c395d5db63ca6002fea5cad88e338c0746ee5c193bba033edf9b2540943db6d650d076d139e68fcb21d9c8d3d0091af9da9f9bd39d4eb763b73561c4c742935389a970463a8e9e754c98c8a302ec2234da3285b7794ef4755aa4b46579c45665345b1ce4bd1fdec494ad4e478d04b1698e791a7f42c7707d3771e1c12b8559d0ef306958b9a062422e94d0d8250a930106c01982359469472ed0b484c00817974c4953d19a4d3b5c8d499d51645de96889f2d1c6c519f82310987e69d812a70789321c01042f8ee60efcf2cfdf2131375a3c5dfbeee7e2bc2bcfb8e6ae29e49a91a51bd1ceabad08abed9bcb474319d0c4aba727d41ba27292a7d74a240c2afaa3eded08338cf147d3deebc82e27535bdc4046fa5f595a2e186c729882a45e5cb533e86d49eac664db288ea53237980f592e47176343654d59902c319f524e4b6668bb79fd4d0edbe6f8f05387ee06f47e2b14e4aaf1cce089e45301690bf6ed043921229cea8aa01dd76c0e1d7239808378a0ed42fe183937e2246a0ee2ed743969be1aa084bf2e5dd2730ce6c0a24662dc4f3efca698ccb5f05ccbb256a706429ca04aa6976ba5fa59d23428910a40d943a514b90b450fc6a25553e4b7c418c033aab974aa2cf34fa74b4c4724d920768ca896f8066b2b71a3d32c49c14e1658f251fc757c9903d18d2bb6418c5efc3b396d2f674bbcfb59c12bb1ecf7ee9ede06dc90d9bcc58325085afd9c0369bb0253ee07de1ed7f35a725d0d25af75495900c69f237bb878055c8fcae41a55fcf5052c5f8ac8f0687493123fddec228637290ddc84657cdbbb9a6a94bb39f5ae5938665a907a2ba07a189c90e024359e19afab1264225655946711ecdd63d5d2160853023b8b0404c8681964a4e01465129089f24a09a0553a91d00608e5324765ee5310ce69df22753ac0b48dd57fe415dc4ae65a230cbf129f659dc7b2c464119e1fcd44936b0f04575f5375c22cab93ec23c0955014965bc403c972ac18501ebb4a1576cae62b9b96ce5421f711f7a705e5051b3365de0bd8028e582af8c1de964510ff0023e1e9ca2f5049e591db3f6b18808de6ae1ed4b37632504e741ae4d78895f7ba655360f2ff36e1d30971c0bc0bbaa2146a4856da1058fde61a6fdc24e94341a218f6bdf5d7fdd129dc6948799e893f3d3309e94017829b87a0ca331a058d8d30629dc51019667d884579af5c5ad764304ddbf6f085c002e143cb6c72ad74244611abc0b8c4941b72c60ae2b279aea84477800d390d014189ec6d980da01ed72b232c9a832d23c80c8d1c672fa1d64267fb75f2a761461b57015c47f6826a1b7287d37b2a19312612a3a9d119dacdaaef79ca234074b59f98c3e35c52cffeb1d3454c22220c9817c767c78db1b50a95d12cf432920adff71bd81fb22a93869e5a1d2e00817c656552efa0826ddacbe59b55812e4ce3c334b5cff0135bbbdb7ed72bb645ef5a207a5f8d77c152a7640e5feaae1ab9fe3376acb538b296a5167ad88fce841e21573807f83384cfc5cef2efd2f23a58cbb920fc27ae9c56db319764bb8a9d478de44e0b75fb90c0d937cf8a95d3c83aa4d249ca8fc6f08bad3f4a3c640d64c902822bfcad6264a066988f1206dd6324de5a364b60b32230008c127f3d88267e9e769ba07afffabd9f49df1d47cd16796bc3224c189c47126cd9bab93a657cb755a350e82b9187d4f63544701a41e6fb1c453f9b16078a252f0599cd15cf9980585b74fb9c26c83e00dd23f7f54da7a4ec5647ca63fca0849d3dd592fecc3a3a2d680d599168c0b56dd393a5b4844a8e9a8f2abea019b169ed9ac882c812bcb6db9bc4b8e534b548d3b13cdb8503986818411d0c5ad6e7fa0209d4b9c51b0ae01852168a2f2394698822cdd4708f44166e7721ace2e6f20bb1f8ce819b48b9e0e2bf57b8ccd95d6d4f5cd882f2bc1d38fa35e59eebd167ed0b343c7cdbba1eb20b1f852fc17218cb51a2d78c06bcfbff0ddaa873553ec627a1f1efc3fcb228431bdc220b1e9723ab5f77f23d84b57128bb43b4b4cff93305cbc154f7c634fc6623b18fe8278f91d4d3022ffd8644727c70be5cbffc0d33d0f1c22f03ba0e2262122e3caa019b05e18067020df9bfbf93b2c61404f8c6f75663551267456e6224eaea4c3f984be0dbe8b233ade4349c6126c5204be4fec81792f0e1325dcfcd932a37bd42f4a5be55efd14798e3b2090bd757218dadf310e2882945ea4f50d3326b01f8c6fbc543431564fc8e399e0c4a41a5ed6084fed0d3dbf62c71118b7f3929f0ed98e2cfc61edfe876a2676d51cb70675391064eff8abec5ca111205b8ed79db32bffe06e79924fbec5610a45136eebc82c80be890dceb130f6b579ca7ed1958158ad67f6c6c22fbf67612d8b392a48ad4bee0f7d20ca9f2d1f5a8ba272268432645933983f25faf5881c1af3e39eb8c4ce555b5f77e35a9817db445770faec082aa483d2c3df5b56f292ac33d8f9c1c46ee5198603414a16e50da7dcaf107be9a1d4deea872c542c8727473d339b65ee7b6c7c46e7aa2b149c828ede21024a84a89237f4bc49506a9b02770872101197a210e6bdf4421813430c2c85440bf1d49694fa0359083d85b82d30c7eafa5a959308a0129dd5be130f291500b8886ce0263c3e7c03354a4f8155321e17d1152f9778e7a460851fa483b8d5ef2128d7fd1bb9d291abae9b90b4721c80564d91e1cf3d1e8601f447dd1a4c1023851d866a2b80a2db7d973b7728c0d674087436d77a856d459e3b027d2ba6b64205e7258abc857a1ba55ec3c13f1adef6859de56030c3e976d470f0498135fe137a40aa4f29d1fd07be26e01e1822a1ca8ee465b696e625fbcc3f5954db95180fcce7ad578dd669e7f1843e76d9dd262c21aebb80916b6fe3ee70cbaa486730feb69f2310c1c2fcbd780081c9cb7cd432018086c2d0347fd63b670f89b5e8270b1cc452a1caf1c997f05263e8beb013a4bfb686b4e442e8137cde0988ba28d1e7abb9585285cf6ae7cecb453927c4a8df52a4b2e7d53195e0a355da7624e82ec19b6138c7138c2e2cc5ab5243667ca55452ca9850dfafced88f3a965a6843b7e5fa5f451dd67b086322403e6082d87a610677b4381666c01241327cff03bfd55ec958b636768f107cdadb3c025b312634e9bf9473de5d86cfc1ee127fd4c8fd13876407a10069ea97fa7ca1b5db03b99c0b5000356d3af8eaea839a7afe1f9a3e58faa5852299bb6041bbefc222cc8f4fe2517159ef790baeb93f8156702df03537ac3c9095eca1fb442c2ec98fe7f4aa7daf3b0910ca4e4142471ead29c5f80491edc56a44b1c0d3ae27c04066a0aa33fc2aeff36d150f07408bb8197cbce5fb8bb65c9b224dfc31a144288fe966c987d4504e7a18cfcedc6fc0e0521f4b150e11579ca444468583de7800f0b2ffaed3feb9da1e18d70c57db7432c5ba0ea3753bfd63f8f24db63fe7731170a234df8910aa481a89f10d25f8e695b31aceee14c4124fcc0326833395e82cd578f74b768561063f6970078df2287529bf564625aa2777a60cfc5a53a9eac6ca370dd85a2f6e010ed95a22526f00f8c4a674a062ef2ba0cfa7a3754c77b3fa97ad0ca03cf30494c1af004256592eb316c8c657000b3eb1823579f71582da5ea20c5bb81df7a20b61f346d9aa4745db895520691a1d4c468f44790f720ff3000ad2644bc30b9d6a4a0de0c52676c6fbc9130848f7885599d39b8f572c763a7e637043c537d7aa49c05ad428331867b39e1fcfde9cb0ef764b90283a724658fc46a11c07f58fa5172cd850a46875c76dd01da59a006c8407afe36c01e912fb45e162966dfe1bf82c801409e88b18dedcd642a5a6c9c4933826e07d280d881de8509bbbba69cdd86d2b3a0a73bfd461ad6e2770b1a8526197d5b32baf0259969f24e34e36a3e31e1e01601a025eaba4c6fe17d7c79abeb67a8be3b3545a44acc1bfe18873e52944a720a2fb5843562351d5e18158ef54bc1e189038b51c3ea2aa15860bb0bfa281b410504d5b0ed7545f2bc993fc37ca9b6cb93d1f6657cad812b5072993e75b932f656d8b1f22d96da66368b736e7e96568230358ade3dc67e33b825ff835ac728236037787dce442773c3bb04e31942a4f1f36fb8ae20e2b3f0167a4c4396651be94215284c5b02e4dcabc890a45b73cc8406336fa7e5a91cf2619fecd9caf8269385dc490ae8fac9d6b8ebca56a111f66ab20d4bd37c3931ba99fc95e4035bba2c40d412482d718b57ff6af7b5c7e60389ae9972996b91a2349954296e5e5f60724d8ec4393cc8f53f0a77e18132adbe7f32b373442e4594a1d2b7fff42fd067a37a94e6fa28168bd6ac7c3a739051bfef9a515c4e99a33e363f9f2b58449d6530087d2d253706c5d0e0ae21f28454ef6b9473d8fd367acf0bdb8ba52afb6fa0b04a20ef8e208b4c23281e465ca354854438f13fc3d62738599e6410e1cd821e3ea3c4f0b98e3c1cdff2e8d5fe4bc17baa28fc2eed0910931f2f16e479e23d12c873abacdb91cf81c13da2b4f3c67d80894a985e614a12d62e74fe26709d8e2483eb3e1671b6218fa623d77ffe58bd587337645596f8a6f2ca6d7bf425ac7b528c5d5a19a6b593e1c7a1f3852519e926883e50480245e5eff94f248b375f904330badd5d616f642737cd8c91b2f5f9f6974a46246eb3c9f12d795f5a0d01838bc32d493c5f6bdf72f1ccbcd67c3a4bed0aeba15121a1d847c2df43e75f2ad93dda657dd060cc5a631b66d565ee1bb934cc77b86f6634754f7e3b80d321da17b2c8c139ede6ef4e25561f17c5d160ebff7005a28c2cf65bbf6f5d3ba09e20f4418a00eed0309e8e58040890ff7f6f5478aeeb7885170921684ae3bb8f6a0454505ad4df566b70349146df1b89ff7aaae499c5532f548978816d53b319e1e56462d37adabdb3575a3aed2b490fbf3dfcba4486958c7fa8057034c41f83c6b96f9962f917c611e75c5f519f2c445c7d080593fa0b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
