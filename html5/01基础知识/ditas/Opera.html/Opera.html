<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a39844548277593fd14da92abfd03d025d77221d104f6a7dfc8c304d08be11be05c0f34b8c69dee0dc04b5c623c90798292fd59440ab82f54a7ad90c476ea1d535ccbca8045b351d3110968742c4f1b229dfd27d3e2add8f1bee7711886dc7704c155e90489ecd29aa08d7da6731b6c5d4a8ae4cdffdf77ad7c706b290d0f167ccb00bb42694e84e2c09f6e8274b249b6af9bac21d851a86db78341796331897a46e39019b01e72b022503e3bd38885d95ae200e089a71d2032a579177c0be8e14c2ec826ebc5401095e865520324aebb8e6a65f788667f5280ec256185740f02ef593520b82d21e4b852110366cdb4ee4e38dfeeeb5db4f2b4d8e8337ad90baa5c279353bd18123e750755e99fc22beef27d49e6364e17c7513f9d3fca8a9bf88471937f143ccfc5f474e6f92433b004822770ea588297918e453adf8d7c361a4dce7dea4cd111f44c7f93ac65a3b0443a8b657a1de09e215b96adcb8e0e7dedaefa5e35ea9e0a7218499af00ccf0db2175a9dc3992525caca6ad5fb1c0aad475299d8730af73d712e3474a72f3a7b85e74bfced3a3d9443f938b698fd0c6c57aad3897be1b058ca46a86f8a13c1d6209a1e63812b94d2fac49d052d5017bc6efde2f47581d80c110df15982e397ec4f75ad5ae1bb63e13bfbd477631253b10e66581e3351c900deda7cbac091f4297369d0b66f640de8a97dc04065fcc471c075db477796460f8cca2ed435340f73a153c87a5d16a0faaef7dd6d67c011a010a50ebde65846ff9340ec9abcceea5025f9c17d6cc4ca92ffcd421091409d58f7a7cc2cbbf8ad31a785b7d9da18e9c5c2b5ff495c839660b3c212ce0d8af4b76947d4fe39890ee485c7e3ca2621d332173775452b1e57ad203267982323610528f599456d97f1cc73c8b496269c1049b69a022dbdeb1c9cd60c8e5e533f12500b6278551ad411b7eea79dc8b53da1c1dd5d11ba43bfb25b6ad1c8a4874079b2f033eec9567c71419d457ca4e5eb70e80e38d7bb647ccdd383d7d11b3bbebfc62a27f90ef409ddaef9d5367fb0545c3f1eee78c5877a4b5f2b6eb608d22bd94671295a233edc4e63ede8e272ec73b0f80945a6188813cb63e47b920ba9b8ed6616629a84c336356f4b380bba7f79133eeced77aeb5de436a3e0be9f3e05beef355e311e0caef3c3e57dc6ecb162eb93e5a0e7d2615ba3f2aaa15fece38578763c677d900afc3e0d8daba5e05f2031f7a251b356981e2e974b46a89f85ea1860d8193b5cd3b47c5e65d586ff87a3f73f1bf7295ce3b8142ff01ea0a5447e75b23e049cbe17dcf875fb90da10de1550477231e9689e5421a2f5394539f638fb8d409a89b7a7e0c91643cc081a4ec19549e9e06d28fcdf2d5c28c80b9eabfb662007856e18eae9fb8a47b4dd0f8c54583d2ffe9a86a34621bd57b44b6e07ad533459bac124baec3d7608bfc6d6a560bf08e4c400d235ea7c285c21ab2dbef1e0ce9e08c04288cbcf53d936dd3f7498c6b2fd4ed2a1af99b92ac43281107d7d113f1e555596ab47f74b0333cea729445996605a19fea98db13fc02946517f306ff765a0ff82420055eb20fbc5a1ba543f4cc1c65125328957204dc473b8e30130b12d4f47908579937a5ec6ccdc50ad44e6bc93541a0e52f6bc805444ec495f9e67b8e8c7aa694929ebff87743c7c8e938b246a0c182c74be1e068ba46b85850f7810374b9c37be24d0ca34fbbcfbfe48a520a7673780b7679e48967f59f32ba6ecac4ae720691eb373c6cf7ffa315681b1b513a72ce945f312337e96497038402e924490954d3c5758ffe7be10822439f9fe19cb8ec86438a507078a5bf933666bf605e8d7977980a121e3bb4aa20a6a172f108c2a4d40546bf5c798e0b759ecb607b8e6cdcf9effb18ba3c87c00f425c92417774dc1af77d046bd114e844ed2229ffc17abbbe0e1c4804d5c8a913f2813742eeabae1a83258eda80b88a2632231c7b315494f0aa0dea7023f1310ef9e5364e4d1cee36d7e04c4ba1a64c3f3cc0def0ab1e6dc6fd08d63f970deba0e0b3ad83f1f14908c0ac63cd2cde1ec20b738fc09ab5201113e2421eb6fe8a0b1ab7eb5ae3ce02028a2532c86ae2f8553443f8c63f987885c1fede7d785fd2fdfb40a34f2e2cb849f8968c3c034d3600a968a80c5015826e34fc7da789e9ccdf4d0fa546b624182b5efd9d476da0a6b0a4ac7fa8d0ca0fe886bd428005b3052d36eb5081c37e0aa6a03036bff94ba046dd7f267a94e38bb192f5012b80244656fdbfa5c2899c16e214cc55730dae57537efb5ce8dc1bcd6b7323c315922e1820d55d7730986d9005ed0d89cb01d39460eec144bbca1787cef620bc3947b242ca904796c904afbf92cfbe4bf2d431513f2f8c369321cce7d7fdfc994c92b83a3506d5bd593d94c46a6ffd94b3ea81baaad565a42977bcb3104b76ad51ffaaa5108bf9406c8bfc1b1f667daf0dea6d1ca955f4d68855e497c76e587390887553a47c10ad41b45585c63250403a7f9134f5a93ac65ec9088ba445d18e38a8cf21a547e13c2a9570911f2bef64072fb703bda321c770bc07644ff75d94b1ff0af5384c7c0b7d7b84aa8f3698f4cd3613b5055704d0e8a2df4c4e40f08ed6d9076f10d615a9bf84fdc85af8381e347f3bf7e142cc74db3fe742ee397b06652c77c19eb2b1600c471efd96a7b2469f53be534e8b4864deee289c438a6ff7e8e0fcb9509915e9e65600272b597138d452e7b7208de5506f2a308b7e0d1dca7d91df8beaa46c9493bd5d514dec3dddf421367a164e34c85d57f2acffa63ee819782094386ea26868c45d904288646c98b0b1c2e9b65e48f6fe76eeb0ff36c66f035c413d61af570dabeaca4912ba1b510c71d2951f116c22db661f8781d49ec7f6398cd8e258cc0c369961b5de25819fec33a4051eb58260598cfdfa1474dce4423056f3e620ce23ea433e405353b5f5e1e10c8bf60bc4527f4b70b41cc8138e012778597ba7a523c360c6d1de679c73a0da168fcb81b759ad678120c63a5c076cbe0a03cc332269db202fe04b19203f988f9ba8c1a22b8c3e4183ef92209a685d277c9ffa3325d78c85ea4796c07933352b624469b69e4ddeec4fd269f76ff0546eb4898ea2ccfe888fd478b32e3bb7c9acbff21549f128e8b3eea197eb1128492045c1f566377b6e537e9179216285aa6363803c60a8fc3e583c03f68b7649b2163747b8a2c16e1518ba758bacdcec1991521fd704e017d5f427c3bceb32ae02e68a52ae9bc475e3a0f60e63861928cb403174d5330be2dbb7379295c79427a7cde2d2f842968af3caa4860f17c7d0d584f9385f3bdf3b55e7fad114e2526f4f2722a4de8b705ab7828150a650029667c9ef6e9d591db4c2f83a742dcf49ccaa2ecb387eac408f0e71653f31e63e58ed35b1deffb46567462b8d12b987c36257eeae689885bdebbe8da289bf69d6ca73d9e4e811e35d9ad3786c383fd1cc166553b045e323b8b973399f00456b6a8a0e1982df4f259b4ab549d76e3d9e51849b46dbfa2c631d1d29a8d2be4ae87374e6d3e21d8999d1281d5ab224c39fba62bdc6ddf3d8573f3f07b282c67f511f57447dc8faff4f25eb3c8115f9b42f88c02ae7dc5146e9f3586b025f66033bd26ebe9922041e8bd8341e188dc4054e61912c323b427000dc3490ef36598f4f5ccfc434bc6829d977dcff3a85069d27a8b759e949d8e3910f68e29918897121fd2378771297b32b0b5831f3021924725bf8165f30edb563fedd4708b07fcf9b4267924f4d10c7dfbdb231d3285267b61f2654945c317f24e331bb0877d6a47061e8b334ed5051d430fe70afae763f138a97f00ba76c6c6e9bc6bb26efbc5a937a0473a6ee5d5895f48ffb93e5fdeec0d8e1af08f856716f0c5bf984adc59744f0e26098056e6ce28ff06d897df1cee3a9066762a4ef2f62ea547f79708ae99aa3b5185a57765b43198077e188dcac63c708d7b91244f571eab561e6619bac6365434abc3750bf10af5a13cb7002b40ab512613571e2aeddeafa7626be5adc379c9bc6695c25328da918e9bd47da8aeb543bf4cc6870167c2b77450f1715f348d885af29b46033a43e2a154924607a07992efca1f1b3c6597454aff24b11824ad80977355ea870b0a8ecafeaa5d231ad5064d4f9b53dce92a6ffb5a26725afeb39ffea87cfdc5dc22906f202b53d13f912998276d9b92df0f86d7cfdb94749a175c2faff3b0d1a0e8effdd6896d2246165e8c4526c64a3c6cdb2f175a158895d007baeeb2273f93ca5bf7a256572c2a0d35babb31a94df83dc7084f9d5bf8f3fe59f20c52c81582d383f02789b5c56adf362fc09e9d6593091c1b3cf26f8bef17a0ed1ec7e1607e1011b272c427bf8a7d02fe5c6c11d36303f1f2262ebdf1288cbd8ebdf78e4ed287666985aacc6035f4f233e77edffc9f2b5ccb8baa7a4fe6e18a6d9effa88eaaf3548a4a64d6d5772f638faf5d5a3f3501f8bf6ab0574475dfc0a7be99af7a5ba37023f7a9611ec861e62331b1895d63b30e4321ac8aab253dd0c1b514be814c5a4fe7fb4f452f1becc9dc723ed91024655b3b0804b8fa07ca952742d9c38369690fe12d6a6121de76ac0fb18926606fd199e451356e2dc9b5a5dbea7db176e36de51315ec9ac8e16997d521a0b11e744173b76788267720861813b508900e33df521dc405a479c51ed7c8cddb892d594d421fb3bef10ccfea99b4396989384aabfd24ecd8d73edc41a967c633d2701b9962888ae4f49362d267852ec2d59bbc64859c50a36124c8ffdae60b2994a9c56ff92034082aab633c1f9a66930f0bf4bd0138c9af6a392dc8f8baeae9dd30cb18bd0d59911394219d0d1b3700cad98b0efac9fc491acd5268f0c62a57b884fd536a12ffff5a80d484957ad95324e7884b079d9d88b8a2498bee20d6b1d58f0c15b78e12106a6fd00a895784b3de3170f0c4073f2a9c3a7ee1915ea75a6213c1694a99aa088a96bd0b4b0d491e65c01f72391412cdd9fd98f7c22bb94b7b2532555bdf6345ad8c879019134da018dfae36a42cf68c5dc3f7dd571a60a5b8f68d45e0f4ade835ffc9708497cc3d853b5374e60226cd16d51ddf660e7948415ea02d75cd5aa7aff1664e02a0d737f5e38fab14310eb52e2661291ca6a4cbc6b550ad683f1e6b870f2f973a8cde7404c9626f9a4775eca73a0db3d5de272f65f4a8ab940bac57d6b367b6c312ecd922495b8ebd5eab9904a0f6317fb102fe1b5b30810adf47a333ba534cbc25552c17a90fb2ead6752d59dc0cffc42261789ec313eb9ab3ba82ffd50bb8febf8b39cab8c81970b20d6a1604b533a3f0fea08d1bc02a2fdf45e15465d9674c37187672f5cd90392b02a776245a1cc635508070b88936587c4539204255413a050f8ed01ef00d0ea4ca2a8394e1c2fbeb401dc9aa99b183eedce00fdb222b205b0c60dcad9b7d4c9d6f9f1099d56d3ebd1940596483222663870289fb88899821b730d9679dde511e07d5c1bf271a82ffce1cc7f4a184d8eb96760bc31ba1ef41838aaf7879d7c2a7cdc161da003cf4c253fd0a92161fcda081e71b3f97f1cd118b058ddd1623aa3323c756a260ffec7b10c5fa7a427b34ec281e2f595236563e46d067fea85ad1ea3a1fd55efd4b56c5676e1a6f1e52022e223145137b210ba5e108993777b74ba2fe2e5c03796eacd5b329aba10153080c6c33a0c0bd6944bf8ad91d4e68333f03884165679ad71ec55b28e35bbf57a197ed5585e4bd00ce3cb58e76cd3db92ef7153c32b9de41ac9489896cfd1515c6cca85d811144a6d85b171974911113f4107d352d83a43cb849d269bd91d96167e810524ee70e24e1c7e01127c88ac384cb0a411359172b7e0846ab164b42e89282ecdf5522d3204f76c4e3e6628c35635b76338937fa13f965173594dff0e9f275a9088d33ccb2039280619c187a2579a4fae5a022202da1b6b30b2883bc5ae5c91fe217154b29aaeedaf930b654fedf7ba90f3bbc3a533b8e5f7e235d19c7228e09309f39f8e386c7261b87a1ae056861d8e7b4d00fdbf531c67c6c1235d5b36a9de1ccb56bcb2d51dbb2cbd9939696ab065b9398d7579fa28754aa9cfb1f22fb366d87e52db452c29f1751eb711cb79e6a052181df2a5a87582c591fca22255befc809ef863b3a66a2bf1f702380d1213b7d652e8d5f09918630b07f0da1a4014c157a741d79da01b4bfa703da95d3a372564b840904057a2ff878bb5f742818e83f28cb12903b51b4fd34119e2cf5e3db55eb87107ce3343dc58847d0c351ce34400805f40d249a59051885f5ad73668c71ad46856adbf284721fd7339445dd4322056401a4149521ed0af476d28ac26166c8444aeddbf65bced525b8965eac7d7148be6d0d8cdf1cf3e32f13b4f657206958276eac6671c8613dc90515da0e4a13b6bbfcf0e3a6639aa1cea54b8e2f8117c764e4b8e30daa6162118d46c15c9071ba8fca6b8db9e200de1ab83bd1cb974288f90908a5ad65b2a3d74a4b4492265586be541ad2795ea75632964a09cd8334a9d7dcb68cfec2d23cd7b542ba66b2103b2e7e282046d0e1aab0e39012a9f47bef8cee648aeb5d7efdc56fd1e85fe796fadae875b9650f928405c3277bd9e798cae51611ff19a680c3325f8f83275dc93b51c208970d25dfaee392078b63b24bedde310aff9dd78f944cec7e4470ab0918743011ba07a59708185869ef09a149a99267b7da65c11aabc2cb0a08409e25ed7ec229de6c6042f55072801c791220a2805be94931636993a9d6b18455a7327cbc468406cc10eeb9563261a61210b03b20500365ac017341645603c7ed290c8e0a9e5f94936a130f13f999f5734714fc81240f3e5892f961fe31684c53ec773616c7961edd1dbfc29cb4a4ab212f90ab8016cffd0a1f5e06d113036d67745ec87213da4448015b1c6ddccbb8b23f7aaf0308bea902ec5c771dad1044cc5e59c9a940097c5e9ee6097f6a9fc64c21dd24f359145dfcc2330f2808ee9087b30c181480026a82a28361d35ada0fdab8ea6d72d47c6481306d690d6c774668136f2ab1d8a9afb43bd7ff02ae65b753749678f77a327277245d28ad15e428c595da658c17bbc0752c5b0fd3e9a5cc76851949f3817c7f00e8186da46778b8d2eefdcebedb2fef19e70cab755a9ee16a58afae0f2641c29521df98d3f7043d9bbc18a1adca16a7ea1becc1e2e52eaea00315b54f71420f4d5846cf2d7625bb56366346d13d721acd2f89f837f198c353e4cca07216f11cfc3df958da3fd14425aba4ef3c1b77cefa10415cb091cd2283b0c3ca2f4efd102501a74c520cf57f21611397b5cd1436c64e251c84e35d4aad9c093af5b69e5db2511fceefc73669896e3f67b53ca3e81de924d3fa24520f384737c2e104cf54f56d9a52853091b386eae32523da79d87dbd5ca4924b42527bd3886dd8272fc90089d83ac3e3eb32aa3bceb50309956c4e3ec749333bc68f680bef34c0f2675d2941d04590cb014627b8961ce643d1cb276decff219d5aa4a307b2d81ed51b54413db51d5bfaefa96ec005696115c6f7b9eadac79ef06799106ab5f072ae111020dc5c7d896169818060cd33040a25bf3e94435578055e2c0f8dceea3d75bc1e01892b5270ab574ca241f8fc861c023a0aa63de4bde0c8300b18da2c4707e89657fd897b54b0e2e71466540ef0c58b287710b04142b81ba5fadeb42e1038738af3e68caf9d475a8aa45f756291a6340553902eb00f8f0b7623581d6261d009526b1baf4dc56ae66d9456d8218f3c75e099b1ddb06d52abff051cc3310df10513bd66190f416d8f16d20d9d3c2085714e4fcc53484283c8a803c061942f222adbdb2551bf56719f017409f55189ddbec2eb3c51162f64a880384d83256272f75ff298b9349ab7523c2bf2f814dbc6fc9426a56127e6bdc6a641d6bd746475f0ee96030682cc42c9ee77b0705134cce41bec8ab288cf9b5acc797b0d84801192076e1632219cf893752256b137b3d63c85c3a16190c49006e4c58015ed1fb7d5a5a34e42fa560d52147ae81bae58a68a0df77def72519526dd1d98656e63646e4be3043dbbd7598cb0f06e5942fb4a9f344e85716cfcac206a7f969a8cd1763f1f188c4aae719a87292648a8f314a042321fd21601db813031da6c532b0c3af27e3491a62d397dd6d43e5426155975b5ed427f887fae1b274edb7435f3d7e95d2e99e04b7ed7baf4d1eba1da90e0fa712226496c0194f728326e5939eb5e834bc5483db56de1cb04548e55e77cc86ce160bbbd504c3d98d5036d131cdba78b01bafac7be216b7801013f72af225f28a4310ccac43401c83833bd181270dec456aa51c4ef546519616519c4908b699ab42e65fcbc63966979046ddc8967564f669a602b8d93f4e58c9eee05c4a545806382c194ef40c910bb1acd5b138c5a1f2d89fcaf848dd76074337f5ad9aefedf4e20075f5f010be0d1913ad270f2b825091497207ca137c61cf20c6f74cec4ab42720cb2237b00c5a4674033ccb27b3048029fbe3acf73dac2f49465580b7cf26f0b1e8785455f2592b619958856112e57093acb4e6747c0353687f9597facdec500f7aff6fdd5170e5786ec1e57b5960a035f833ea593b017736297585e0aa92c6b0223019c36ead37a5a370b0d7193e8b3e862e921ef4ec96024d7b29078cfa7e30cec5a28d41d4536963d71d2ef0f383c43ac69ff67ae2b22c104d0b4b12f05db35a3b7f4564291184f9af94fe407146ff63ce50cf4284393c68f2a9b7af14b2d3ff5a196489c3ac6434ac54ac33fb9329659aa1e4d396953b1c10c09ff76e613fc6600ec2db9705f2bf4821b8497b168fbe6d2d582e2ec5eca134010b10dfdb02acb3a44f255cc57fe7ebad598284b288d611a38eda82f6222b9326c41137d3913f910487414a00fa6fcab0f6acc6d63ea2f48f8a37ec3b9f38f314f9819f5f2f9e9ec5dd44818e22a15c59bd7a1a8edbe7d9b37091ea703432d729526de231b36a241411f482031ed2ccdaf2cc7c40e6aa8c8237f20b4301fb4d272fb84ce451cd739ef5cdeebcc25daeaeecd8ec91eee4a297b354c677d500185fe1c9b81cdf2e3ebbeed2c7286aa43af0a0e9c254fe764f7775f0e2b98d319225b441bad06edcbe0484569c342438508c0de806598964dfcff2687e482f52b09cf4ee919e82301cb471b1266874cb1014f5058fec615005dae1f018ca82045483d17cb4e8a880dff3cfc24809de84b624bc4f240ac2d8b252a1f6352ecf70cb2be45229f8ad03051715dc014a3a933a2df05c927c112996c41eb60850ea2af99aa45baac1550335e8a91c044f6f8b184c681505fe41d0667497cf0e2223bbaa5fa0e43ece2d86545d1a49f55abb08049cfa36bf351508eb39002204605714f882fffd54b6d44a2610013b0ae31cd8c552c226a7da8da4a4638300f1fc3c18a6386079daa17ad860dfed0c7628f7267e95e0c0143633fe9beaf70804596f27c2641d8e50578927d000d0c1cd2c0acd3175e0e4e8372bd642203993f1c2e55a8e0617e1b92c61699f89a8f9496ead70172e24d20f5b19bbc3fa876e2bde0dc23836a0eda945386987d7ef032fc8f229ac726335c5da6252048af507aaf92356eaf1a640cfc6cac90617b2f79b04bd31f05efa0240a4d20afeed5f87b3e594b9b052323b36d94bf98f36f6dc94473002a4caa039e67b3f3ce6c90bc5b4255ccf7f97dbe17d69c42183efcf97d1f1afce31559d082c677aa1f09d47a81e3170b17743e69dbfdfcb727f2957abbdfb4dc959f4bf60bea252adf609174c49911214e56f082888aa4b9a4343bac56f59fa301dfd1def4828586dc1d031c8ce17dc395bd26e03bd977f0e217b5dd7c5d16004a2cab6fa2c379e7a30984854ca2626695154ab8dbd9e314d49aec11371f5fd25e766066457811e5cbf04d93f0e4a5230f0fe9149db6e3c9d697123a87850f5da693ae46938a57cb9769ac3ba93f6f0c9896639e56fd1be741bb37e283cdb29233312514a58fa6c796a8aa2181cb56460f16b050321bff8a665139bc152fa9a5332a1e080ae150e49e8cc2b92684b05e4280727fc7b01e9f03f78457e3d4aa7825706f10c6859b32366a180af007f5a78604ff004954f7836907702449e7586d438fad826877811ce2a2b2f2b3963099b0eb569472a229951c40c9cf8d870459883288baf9d17050d36393b7f5fe26a77b2d1026739fc2298e916db2af6b1b45cfdf2ca18af67d69681771e2ebe32a74756e4e2d0f1a184609d79eb33baec83fd2a0a97bb8b42a0bbfa123ce92d6b390a805aaddb8cbeb69b1b460fc4948bc3d397ada7138acf23f496fb961210e209b9b3f2b441441f85500ec50629230239853da25fcdf73cb87cc4318f79b467025426dfb1a2e6c4260c88678e30b72b19759ec24c5d919517ca762a4926cef837bf191d0958ad7893d56303915e05fa2faeb71539be239e5960c701e5f9de5fd0802cefd458f4c297370c14b168c188509a2c9bde879d5f83c2d01955e8bf6bee7bd2ee33cefb64aac5e6a7c2df7aaa966e0b760f2870b6883e692a036996bf6c10cef3d9b1b74bc505c442595ad73875ef558378e2c8d065e58ec5f83eb8a3bcae343ae3955ce3dc6ef7e7d8deefba5b497004997ff0faaa003c06309bff781cc167a55fcc83d484beb241365eda91c1d038d6cc4fd2d2350cd0c94130d141d863813deee7b695799e4fda6428cda427240ba94c072fbe271642893266f0ceaf8bf7ff0490acd1decce0dd5630f3a54bb64bd2a3ed44aa9c40f40b298ceafae3dd4bf9c559f78bb15ddb331dd0ed32d11917bd4e03b85683fc8730a6e0458baa72b6fae385b82f5353749ed961e33d7e8d3d5a35eef19e0ca4a83ed88c0865fc257a292310852e6ee41b2695b47f19a4ad5b0667e9108e40d6012904c61ed9c3f77db1cd5f9240210026b43a3158ac0a5acac2c1a623ac80f03847eb67f28074e67815d85304c74264840224b752eac0e778a5fdce715e497f3af08b877fdc9dbd300f287e1e9bf285d8d2b9e0ac26eea6ea8b3ceca66c5df8aeb72f693be59d049bb1f00ccc47494b9eb91c72ff7182b0261c0dcb904bf0a982effcd46b204b2688a965c3cc77029410078e8eefee2d90fab509fc17c0091e23e917896c498f145336b824342549b0faa2f153a5f1eebc199d31cd0fba419e6d39a5f70763fe9c83ee176ddeed95782c0f638a6577e0f21264af16ba44f70ee9a47dd5025577ad3f270bd10336dbf8e1237352a2e5f4941bb4ed74ae15538eb436c1e67b5050615a2f737247b6b73cbdef754b30972ae9e00bf582dcaf9468314a39b7e1b3512092936428752c12c1b555ede09f532eff2a08c90a39b413e6b461193d7e013107b666a2d4bc64ea827681610de25fd709fcaec1c25c6511b1b8451334b0b212d8c0918114e00f5672782eab8f65a3593ec6642c9b87682dd990a4a38a8f9790441d0a8031c0d057583ab4d40985bd7227a3304f65c895fd5079ec788c0ed7f85f6924ab0843b96fd91b0f257642796365282896d06828598f7eefa77f3f58ea3834f44dbdb024cb130bd946e3ba40f6c1a0f2a70ef3980cc3d69e3e66406bfd6d1963cebe42a56412f541d800b3e0ace145099e091b93edac613cea056b3a1a5b48a2bcdd10c67d5f361827c76e6e826d913814df94f98b57c4b0b3261d872ab116102edac623f7f2e10302783fe3181d6bb8211ca9605a6ce45222d5613813125be3be593bb84d2df8d4c7c0683a0d91751d520af14bf44661a70c47a2b7b9e04740815b4e81d39dd1f7d5d48be2e7ce01dad73b8be90466d8eb58449b0edd1ff0e371d1c3ecd7f7127815b0417a3ebf58c55b6531693ffe544c9db43e58f427db569cc639aaca6dbcb7604c31b36085d1e5cf1c5cb32172728fff9f71ee56b371e80dda18785a7116ff8d4d2333452622e98f7185b763fc9414ed55bb10ab8c89755598594a6e3e7b04e9423d6643133623335096a2fd766472cea6c7610b951bfb4d2d98b842a4350968a710622c135bf1e3968d93f23c0ac218a3de5f187ecfc8722fcc36faa8c9aa51a862d32e08f5ea92dd9f8085421c53a432c46a1e9f85af4363dcd64aea57809df5f3453b47eec6cb75122796589a39b8c989180c985033d56e790204d377913ce7b49fec2507f30154a08e9a6e2580e82f4b320eca33b4f95a4109942f7ff4d3d1776309669aac0fc50d66b06eb69f462de471940fecd65424cec2f18c070d8bdd212c931a0549ab3fd402cd835675acb441f305189d1e7ebad429d5e963b0288d38854b49f393153dd2057f56721d0c566adb2844c05855927c02f903cf782a9a18e8d6e4aec4db615768aef1c8af87e4ba5d3b01d2de1b2d9426b883ce457ac2f6b9f945090997d99714bae0a44fbcb28e6760253c293a4998e71a06b98dc52fa7b9b5290bf48aca62559a856c45443cd48eb379ac80be045eb83d6cec5a297313ecab57fbbb3597b6609d18d502cc65fa66a409aa7e5855def2de7de63270c9957601e77e3f98e8ac8854edd15615c6b9929fc488819176a91a534a624e17c008d164f00bdc9008c967aa112d592ba9f2a77b95cd4deca3d8b9fe107091536ff4e65c58864efae7b5f66c241a64980e0191a0f7d5b5a8f70f511f497d48bdacb0552192f5c3b771a760be8473e835ef33f13dd61a04cfcb8783a745db5c5ded9529a6b77812cc029938a9c88a8d3f160a642cb8227fc93d438448dbc839690df919fa54152a6aa9c15f10b2b08bee9a50e81f95460cf31046a8f6079bef31ee7976a1ac32eddcf7264ae0706a42d57983659b825d026cb8be1872f2d06ea625225a1922c2b7f86807a234126583c5ae5f6af2f5c79f5e7189948ecb6a3a20ac96f6b7d2b6a6dede46410b99c251b5c2d35d01c21da054133e34d84bdae34f1d277ff260262025ae4794df22e6cf06232f0874d05e2cfa7c6d885358a326f3fd38147733da213d004627eac10b96db4bc7d81634626939cb46ff5386099dca74d0409c0bb3b224f1541d09c0e039807c632e0f471327f1ca63397818636827af399b97ed315320d8e4f89284a63f24f1e8451e8d282ee8413d46e39b81633a7ca070c8a9964ff1a368c3909772f343be515503dafd39b7c893d527ceaa22a9d4f2a3044801e68199455d9e8a13497acb89f4ca10bb9c4ced4eec2045d1657f7025e9a7757d42e662b5e4c292b30721b1da95a9e8003522eb10ab7cc19f3cc1a983c38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
