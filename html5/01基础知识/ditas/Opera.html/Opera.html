<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"901a446b7951c32e57ae2796aac01198baeec2be7b3962994f9e6b5928ad0323c605e44c1da5ceab72c18ce30b2a4ff6a0c64eca1067f2e670d58de899918cd72e2263b3b89cbdd3c83b8bc2a8dc6a123500abcf860e364361cd82f598681024047594fcf4a384954f57d748b9d1eab0a3c1e68ce479f30397cca1676da0513e36a5407749d2304e6d734da95e48a54f2770309ad5c981e9a6445db5e0abfa2e5bc7d0e96d7bf28b17dccdb5c5c9e664a49f473c531e6962e8ac62cbd493ae2c6db6de42be4e281f81e523f8ef0f359ab1ef1366eae180a4dc507d07288371d89a6218a975ae6e4dbe0e45b087203a7d685805565341e0e8307054df4716163c48f64ca4b4f53ee227bcbbda9022df056fa40453d770b008b0dcd516e1032ebe4c5f4f764375b92d420ee23b04d343be097a531386639cf8e9abccdb6869e27392ebfdaebbed994ce4192bbec9fcc17249d4b005eb1c4bd62ad9f1e2190ebdb940f457ac1391f6cc13246768493facbe946d2306628681d1872b9b23bd63fcc55ac3a8f5a35633a677cf6073b12ac24a854f93aa6641eaab57d6a80c773c66b08cb6591ac3d9ba2bb17909655d854c6ead8d714dce8d09b136ada8c227318d69d8a59a408d17918a3fe971a9d0dc8952ce6de0295d7c95022bdf7729b7eef98e5522614714eb53373a898c450830a18fcc77fd31ef0489a29495c6d4fdfa2e7081a974789c3d67f1bc7541706b3de0002f2c48a767a8c4a82d9d65a05f13df369b05ea3db1a9d617dba189a5718172d71e825358fc9eb4d3325c0e92e99cb14d75ade9e83d5848d7542bf25521a2a2e0ea53d5675d4d4811ac03695d0e68b233048b47d909a3208dc00c1e4a976167fa41d2f5563cae86c5f475941f27d0270b2ec1da40aceb70aa01dc377723f790740d1b9abbaf85b107e06720c97bd59e606fb5b399a259955eead3622fd881dce0fb15e0d8e8eeac8250343dea75b7e023e495450ac3d7389b1fbaf7c1b33d21a73e82aa21620f1f6ff7ea8563610febc9416abd7d6b7161f1fad3cd70ed4c789c652803b89ac5b17f2d0a0da040ad6976721d748152d6343c0dbb560c441067b594a6d91564c3df1b97840e31d40606297a7dfd5ab63232840903aeaa88265aeea636f59ef439f028bdc455505e9a5a76a1889e853dec8e701e1333067eb33e14680987e0fb22edac7552efd50f3cfa197a63dd527d7a9791a4c0f677b7b15908008cfe4cdc1b5a2d073ebb02ab1fd986c04a81409b7c729fe2adb9ee52269d107abd1060be0ceda2271c20875d6da32411c4cb1d6d8daae28c9b0ec39357cbccbdf401917b34dbd2af3cc130e509ff2ba3c9bc009aec27135f79db9f68e348f8b6c9426c26ce9e559f689392d6c5faedfa9d65d60ffb99615a0de2ba127aae6995ddcaf718f54fbe655799dbec0551eaa27ae2206f5cc08631d21a083690fc1ae5fa7d48cfe1fb1ba471c0498acc65998f2eeb8b6ca73c8a3d66be21b866f8a932a5661233a20ba91946259a297409fa40db4dd884053ea3cb55a558ac3f01e506f479a56aec3cc66b2bc0b855832cfe34066d3f45a455512cd8e4509c79f6f160f69648d04a5be13cd6ded610a5a17e21c3f171881c7d6b0c829847a740a3a45a611e0d62fc1e241269cbcda0e68591a8e9b36ef481fcbabc85ddf57752a74c58792c0ad5335dd98a8472687f92a95b64887a3ce532fa065db5903461b2ce91d287f26ab81b9872ccc3d807605b32785d48482d743a55793b4f0fc2915edf2df155ff7628d1111bb29843d13ac96fa81260c08cd40a05abf158cd8aba25cac6daebc3c0f8186c779b74858e4c82d5681e4a8483e367c2813ad499881ef49b75f510f4e239acc6c4a1f35cfb8bc14acefac3450adec52f220a4846f83a4502d1952c4db90f5d77949ac12569d4ca4a10c7457c156e4c7024c76212ba2045bfa69b63f98ddd9876e2fcc05afb157c502af11cf817cb1b889749194d9b0cbca2ec434e776a8696f66b02dc40eaef8239218b2425734c36195f06a1a90d94aa1e7e337c4e1386ab710aa897ded82c456557cd257a4536d5be26c1da467ae0506b0ea0746457e93aa9c0f00cb87b20674a9478b3b2ed11058afe6371253b14d717829cb91c1088271344f458897d7952d563a372081e4d3c4772c610072f8c5ea252eab82051dc2463ead4eaf4c8b0321cedc6d562c30e6ebf21a5832c4ee13064ff52a0037d4621f077a8003ded3c4cef8b2559b35fdd65e5ea2890a648c0c394a3e778020e130b01d1ed038a449124682184137c2e3cc3c6c0803ce4d92f32ae79c3a9f7e7e7bd52050c407bda73388f9fcd1dfeddefe2956e9c9d0b40d5f6dd913453592e8ebf2dfcc27a3f4b1d5d5e49408a02f89c2360bf1d27267ad7163fbf69c70b2274ca0857289edbf4e0bc4bd6b50122194a98a1fed3901eb03ac97d124fd875a72529159f322b04d15545facde28a6978ea703d9b003e8ba999ab26819b5dedc3ac164f901061f76fcc029f02aff20fb4769226afda290ddf2eba9bcc4c57a64519f10b04e19f84d633967273884bfbed1c4205aed2e1dcf58ece5579c68229cbcda29182889e19b6f008ec22816f121abccb73bd7421d712ffcd175be2e99eea4c3b77bfa7293d985c9e1936f64865e3e4071cb3f7f795ff09ca61dc2fbcd8fbdc606fd0302508f057e41c3793904954cc3fe7265bad3192449271b9095035624ba8063dc05fa9171e702410705baf939e17b4256f0dd4e85de1eeb98e6d0c7e858b6f50e4d43c670a3bb847a8843ce758e4f749453020648bf961febca7c73406255ebcf942aaeae95eb73d1ca50978e09dbbfffc755270b25825b8fc45f2a6452de5423a795ae960a68a244106f325980cd98f435ab76213eb3e5520ae6e8d2c92bb58b61f69d6059fd157f03c23c6e8ceb2f874049a9e1b3779ec05d1e3767eb08a7d17e4282a3053ebbe5a047c65159a02b3d125600ffeaa56c0af093505c796cbafecb90f724c50775be9d6180205f8e176497cc9c82bc7a53160e85e0a407e229e0f29f8b0d1cfe80c01926e863f4c60248cb2d9a4454e6e440354ade68efc2de9c42dc29e16a18f3cadae1fadc121ee7bd0a82962e0a22062b812413ef1e1c13247835f16ab41a076c54022fbc18d7f67d9856ae1c93b47660ee25805b1434b06db75334c4faf95ef26aff583af0f759be23001e7a6d7405fe6a6acce8181e670ae80e238d5f39995dda83f1fefb12feb02e2a1c93460a3483915d5d7cc0762e80c175ed5ddb28ca8903c5931fb4d34f5fad8ecbcfac0488d559d9935ec4f7679aff6199026e68d0f71b5c00411a14b5843ee657104c1217287e2dc663d46b5812df491345f4dd2272f9570f5cc57ab77a17dda0adbdee81dbdbbe0e11b4d3bf4a0bb38d85d7acbb349149f4c7276c375fbd8236ddbe098448c53de49d5b79dc51e4ff40a692449e5413854cbac912c682381dd07b1239241aa67ede08eedb130dbf92bba04edefff18d5dbbb17ae2357867a3fe74bef96692b1b00baa8ee8d39857c20eb45f4f78d53202d5c709b626995ea292b153601bcea1c5ecd274b2362f7d84fe5e205760e150931a2f24fe9e819b82fda3eee518378d806cc7bfd18f76e50e5be0f09cc1616dd674207068549e718db4874c3bea6f450f6855b067b51a41dcb1a11ec82af2e6c5a0900d719fd71e39460d57d21b281ad3b7f5cc4d452ff5bd453c6865a4bf3f24a4379fdc3267c16e969c9f97bf312201abf722289d77b30ef0ca0881543da622fc3340f5e4edd5bb0423b9e0a602816fed953ca9290da647a64e8fdcdd79220a985d0ddc40261dfddfe99e08c09c2aef4c131f308392e365be0f0be3749d7446ce74057b0f6a3016334fcaa2d94b37d14e6bdeea87051c417260c5009dc5010b3c6c14e5d6fc34fe06a4ab3bb4a945ea0d24ebb361cf7a3f03ab1e3d24f3f4a42d78d903174c3df0edd52c9528ece4425b8a3a32d0e33fe8d5afe672626f9323d1175cd3f7b1ce4af604474b41e6603c2814fd65c60a1c4fa4c7c0577bfdf74b79147af0016049d7c0435b6848a008bcc4c4c6724e079e69fc852a12ace546158400da95345050a7d6ed2e8704734a1ade01259916d45e45def83606256b639c5c213c4aaa5e7730634b512c766d94cf68598cb589bf1da71af4960b3d68a29963ef83e39cefa486e66671ab0bf200c834803fe338847b330e3930679a9d65d183009d043120144d9551cfae9db87db89b4eaaf2f9a83c4d080adf782f3123194503b72338f02b137eae2ffb0a7d90ca78fcfefcd4fae23175d66774cf1460b776439dee8887c0532b10dcfc9721128234b4a99d5edf330df86dda36e1563576f53a765f5a589625186219bae7c2ff49e4a141aa5da378593dadce7ca4af3c7c13b295172239e94b8bb15d8b53b2deeadf35814faad4b4a29d31a86293550c1a3e4a7d0d90af3472e4e1263b5f153440c0a85d094edb4593d390473ea464504c3f7485684bd8e6eb413ce558c03f4c710a0b3cd26046d0a18c3c41d055af4e9a0fb3bdf4e241fde2898947fe89cd49489f4a67d1b0ed97be7ff2753f2a2a31075fcda5a92e0ef7440099e30c512b10103714dbda95e531290f928eedcf1d82f6217e4af9a481a8d1d34966a40d342d6409f76f968dcfff74c187be2e60e35dc4a0aec816aac4c81e7f744f055747f182ae4ceefb0a0d3ef5b480507fea9abf191dafead9c2d689286ff9f38f43056c004753ab9ffcd8d2343b464e99afccaa5f66621e36d4afa22d613c4a9d615dd5730cc7f9106508af304ff0882f8447d0e8eeee84517da979420631d8715b484b705684221e895131409998538fb53327bd3eac9dbcd243451bf3640fa4643092489a2b85084a9df7f574c324183b1d1d4e4c9b2e89106d040b25f823d44bfaa604a49c764c17be9af636810f7a03a9cb5dcfa60403bf0932c349e8da0d5978a036a788bc289caac94dbd92dcbfe381f30c82327384894fecd4227899bf16cf5f5d10b2f793a946aa7e8201645e3491a7e4d1c6ecfd41b5e8772e79038e4490bf0f74c45205561fe0926c509e6772788beac82bde3a81b09d388c55bff393db7544a63ab44b9f9be6c690eeba624355a95c3182817090f6c6bd296d8ddd6184f86cf5fe0d9e95cd590f42d666ea0b75347ebb010ee6987582acac3dc2ca3b1b8055d9c9b9f76e3d892875f7c3fd8ece8da15f8cf354ea92cb936db792f5bbfa864e1c84c76961341a7ba4c89162b6ed175bc64ded25f9206d6bd82117fe540594d82ed5d899764e2b48b95401972586b3a71bdf8cf13fc811d918a3bf14f3c5224af88d921b3cd1c12f9933e16fd7e7b6cd2f77290ad885ca37ccd48356c4829ac57893fbc9d759fe02d2ce3aa04a17592f5923157fbdd8064f281c01d314e33848c78e4f1523b5e21353bce71ae5e60fa902a5593962d9b9d1616a2b01cca2f05d55ff3ef734b7bfd0911da988ea33af8d081dc57e681ad41e17a2f030afb5001b568fec4351b9ece9d382b3d5aa8f5e72e7460def0567184167d091a990c26575b9629c08555150d526adf134eb89e6f4d4d28c93b32b07ca2331b8a50f5100598aba4871b5dcb43ad443733d7da87e023eb115ddd686380e54e1338e80a163d8d86577ecf3c5f5a5e909b077f634b836267e0e37808c0c83789f2afccaf98df0e3571800bbdaa5e3960291b0e4a04b151a27b9809e0a05cc975676a87f2ada39255028ab22204f37ae4885481ce3ec8ac5da3f6620c8f75d5cefadae7360de933bd1d7d64b9c29877c6a764c62b8f101f326f01fe50cb61fe49b088d092885e71944c611605fad202f06b7615b1024c540b391039a094445cc18bafbcd3d17b4fbe11c60abc29e82c61bcc8824fc7b6137a2feb9b3007c7aab56d78823029e686b544e138edd7f123c4a5dec4d2eace79857fbad9776aca98462b106d7896135758003206f5946866219bf79f2c651afc5cdff31df8528ec7ab5a456d4f67c463e243488f23aec3da5ec57fb42a7ab0b7ddd00bd757d1c5175547f9e644892d61f2e260766052a3a639dea4853673258922e1d7a0875115476ce49261a5379e90c5a7028ed6319b9476c888364f55d27df93d160fc25ac2b087d6c6df29c8819d4a51ca0ab44de5ac4ecd2f2846320af0fdf219d47e3ce5d240730e43ced1ced40d608dc28b0f73b2142220eadc669bdfdc1bfb08f4b1713c54fcd7be941febaeeab22345bc3fc0333cc38e6cc356ab2c87ec204887cc39705fb9b86827eb9be4919e6b344eb4613f272ebc1a38a4fc5d28e37a669c1cb4d199c9a575e021313a49547ff4f8f174611dbf2b9634484e310d8f5ef021db10dd8a2e77123fbe76917325d0cdaaa6583d4ae1326441e2b93036a7ab82d80f1cd0ed3e336093452d4c4ee6ebed910eab8fa5a85947e45c737093908b84c8c6257e724cb1364e2776f4d31e08f18f23b015080a048581be333142a63a305f78b7ea354557a43c4cd72f115c13da12c7a413a8c073a88476d49302e4d74a70dace74d685faa80d34e51fefb8d71e9fbc73056e8bef5d8bfb54ef8e635902beec90468cde23400837aeaa9fa67bf89be80558116c4da4174cfbfc5496f19ab81d3c43b9e8db08f7d65565acd6dfd38d64405cc87460f84ee68580aedc59c02215efeabfda9df331693e1844261dadf9f9fe2dbe5495b867a8e300641c8dc4f0070921190a64dc11a25654e240dd9074fe42a462ee87d60e95bd4b71718568028a8d07a26cf6acad8f4c46fed16ee0da98fb3ac589470d40088ede01c59634a2c4f6abf9474e0f171a4dbe074a8f1d75c665a1427273cf6d7985be22e494c6aa655ab7e0995509cd0dd35ba1b5c4dc91e01f20d17fd3fbf9e513a79be4189b10308e231309c255c19cf7d8e7b571ea0bd9a91030ca6b47807f7bbfdc620d1fb356426491f899114c9aabc1f2408f9dc3b784ecfa781cd188cec8cf6174afacf5f5f352653cd297c0c0e87c8af7aa4297d7d358046fd13969ce33a863fe30158123aa132eab2b7842e97375ea0bd1eece07353c928dfaa6aa40a168f2a0d17886f20d352ee5b7701fc094afd9903ee019a0806527127499d811359755de2ffd84495a0182122f33f6489f30c4f3e39a266847e02a9b8957fa96acc7d11633206cff2ef0a7b101fb53e770e51d5707bc870ced55948e76657e097b0696e21f82657ad00279364bf8d92b7cde6e2ff976b1a16f7485ba2f9c82a301f2c85a12a5709ba1fccf45b40951e87d3f6c7fd5ea976be44d4f781245d5cb53368709d87dcf75ce11261cb5848e89025b5548f5c0455c72db773c04eed8f9a55323bd39de7f5c5468a070b457f90bba91e7816c6ebce852eacb5f73fb6881d8a6b8134255c6937a755bc3e3729a964d37cdcaa9f6711ceb240a8ef99f0fb23600cb91318974d0644c16981c901e1be5ee73bc84123fc7982786e1b40df914f2e75635bf200224b53fb6a6800cb2a80c8e1b9ff48d6172bbcbbf23bf2811a0cd81c346563ec0fdd2dc41a0f6f24aaf29a4fcee0530156099928bfe4a51fa2fd946d6f9615b783f27a5f606cd48a6502300ea41ee6ab7b29748c3574442afbad5f50021db2ec76a48086fd96c606cae34602922d1447179063ecc6704e78b3eba1f578ed7225464b3889e50279375c1fbf527f89db65346e103b961f5828a55e35b416dbcaf4009743e2737d9cfadff3a7598268c3f609f16454994421504e6a412bd96748a884f172130678988450724da1c1af1e32a006b06eb4e3d4f6a2d8ba315814e782e188ed1af9342b3e8b89dba5361d501253c91567b4e1c7324c0bfa6724d043ab5870e7cbfa7e5f2d1e716a943b5adfe6148a0c2e93f6d09bc4a89dd1e52900df8cbca853cbd7231a20f775e53991933803f3c557c6753ad065c17931166ef657fba038eefdb85e14946ced4e176c4a1e3581727cd3f3015451aee3940516cac13efeecf8d9763220f57a8c7c7e214a1fabfbb3c5708d3b8c4ba373939582b8b54d2c68a5c7131550625d85204c8b065fd0e234f0b32b0aa46c76a4cf0affee4851c4eb8e855f46428e7178b07675fc91fb2ffaac050aa707e873d0a875a3a9e24485ad178511bbe90d02c496fa6a974579772728655c95253da07f8c1c929453dec4bc893012657ae515e028503bdbdfd6d1aa1057a21883e09075f512e357c45909e711a2c7cdb079f3d8f0e579f6b3f1401efdf142bc03fb3c15558d817441b14f48a113dbc7fa3a288862a9797950be9ca093a99895c36e0c994bf6bab9e070bdabd9b41796be6b9448a14eda70cca27362e60e30501ab067d630d639d0ae012ce2167f496eb1d1c12d0432942bde0ae2c4d5e8f64448a4c810d71ead53e00791aca4817814f5fc982fa9e712bc10040a02682492819ca2ebb569ae0e431d3224fc82816c37ab1f3fc3f273d2eb235d6d8e7351e1a768182a6bfa2a607351cef74fe695135b8011ad88c57ba21470043e070fb6bdbb5f1d144fc595ab49832908a4d43699ab74c8eab2dc44e805dc5fc48804360109b539b64a999a899abc7013b2006d4e1a98548d03b2fb2c8c98a4eee02a5b1f16d5cc30ded28723cbca1197021d6dbb29bc79bab2f08b00b4e8018c86c44734a044e626bf2fdb2544bd1a2ca6ba63e56683db7df95759a4be86001c37f625f310762bd5be4b14a8da8993f0938959e8656bbc252e59d609158113897503a162d0b529d5513624762a1abd8fd1c3cc0df33769be590a4e8fd00a651f34288ca5f301ffb01b1fd89bb5553bd4aa480cf08728660a043513c8e95ec8dbd7e8d864957dd367dfdffe2710757c8280626d366874f2d51713ea5f9f4bbf9a17838a9dd575d99ed1a36d8e46d9ee7c18d96ed488ea91af72e230d0721a691f2bb05f5a32aafe2343480171a26b3c0030a6ac90570a4a508883a11703e935cc726597a38d529b0d569ac0dcc46b7c5478044337b7fb6f04594c813569351f9552bdfc4b4a1e26f97a005f4a4ef503387d5654bb2d56a625e2ac74a37742d7481a0e268a0f96161f5de060868d968039c0275eb2126e1969335333a7b9d568f899c7a8047b62398455ec935576d85b831a971a6a1bcf649d23eef93bfc7ddf251be1cfe81bd7e4c02f7a20403bd1ccf0b649f4254b6e578e9cca886b303c0b116979eace81da98a495de982e568168bf7453579b78be33521b700868db4e525829e0a79ffdaf9ff2e9e112bdfb72141d72342ddeebabbb121adb14e2bcf66f427a5eaa4c210274f36853c7cb22cb922d5abda40dfb451e19f3740bb9d136312fa0b20740c0067c3ec2f434e23f707db0bfdf6ced3be06e1f918faba09d8469b36b47d60bac82e5adc56e82ed53e022b80bd02a171322df607e2fb22a005750a0a074facc6c50a903459efd03c4747cfc5ed076a5d0e7b9d53e27cb20465cabf79e648268c9ed4fd959d15ce9b8aa888ffb87d1725a275a3e57c800891e469b369e70dd0ba26c36833e6ebf525ab61681b9e92ca861b155ca29981f898eb590d22d9dbb777592c8390436431e452226ade2b6817654589a426867120f428b69ed870b74e0a537904e00d54afb47d8365a38e8e84552824256479799ffbab931b3a04e121b52232868a068273b1fe039ba928063a581c5edd641ba079027dd59ff1aaeb640866a604f1f3df1ad040f27bb344e50be489be5e162fb6f102a7664237cb01f851aa86c073b21fdbf3e70186d5836f5ec5e1c4947e686aa6075afb98464d7c5b2f828723e8b7f81f5d082213867c93522eeaf903ddf619423ff181cb2e6f45788e9030c63f91a7780ba6223044792c4014d6e834d0f95d784b77f458cd7fd1637652f24600a2dc76d26aa4a3715ccc52dbc7d2a6492dd6249508ddd492aecfccbd615e4f9fb554577c111ec7fa4038ea0e8e43c5a24a8f2fb29d510e606aa7ff2fb0408d405a694077cd14b8fae708ee1e41462c38bb486bdc4b02980d2af1e41dcd0436e7a160e8d4195c9ec9920dafb4a4c041cdc4da2412c5a362206965f3d936b71131da93559c9e93c934b23d1a74bc27a62e2309e00c2063b07fe65cf5c574f659fccfb03f3d7d5ae3e48b0f1dc89eae8ecac0b69bb407ff9eb0c19e1014bf1277c2cad2a078e47ddcf62d533c535e9fa2e1446c170d8540573537afadf97dcd67dea950b07c43cb2eb271c212b166a3e228aa0cd3aacafbbe70d675548387eb5bf39ddb4b1afc62d761722db471c45720476cd49e4b5a864226d26848868bab0052b3937fea19849b230fe340397448dcb3c4a6ba3a219d59735415100703419e48bb81459e3c610b510ae82979ddc3044c6d97d7c48877f2637bd8f44bfd1b389a502291644fa791e547435ec5210c20ab7e230703d809db88e1e8a214cbfe208e3990cd1d6ce21fe8f1562053b325ec3c7fbedbc3eb02eeab2188a5abac4b684c9524dbc0b3c05ce934093e8c425f83c941230c911adb4186ef370cc0c21fb7f3fbeb3c3157ccb94683ee9776556023468644fde5f8485084364b54d1c948c87312386ae56297a7201ad078cb2c6112c48849b3867b2edcb148b31dfe8222ffefa2997006e65eff16167e40d8f90a68613dbfe11f097afb2babfb6b10511700a681a31c5c5f04c3baa119e31bb0a46d12c1366541644f446f22ede50a75426193fb5e97cb7baa71b7b87750f9f2a6c00c3f333dd3763c520e7ff006dc74bf78d65b0579935046578fe318db9cd425c514daf45b7cbb228890b3774ff9361d2e67d22fcc953aa9924c32c4fa049e1b135ad518605e436df8a97acbfdc0936ef8307f3ade3aed462554802ec15ab008b27e855ae7d6bf2b519afb474ca8e449d0a279ac446d7a787e7a61e3d4ac850a9c9469e44a9c1fe203510da6f58dbb0dc1362c3b2bb809a86b6c4bf9ecc50c136e0f43f4cc2e484c77807f89389a9c61f42a92880c5abd93ca6e2e4122a1cc81f84e29bb80af3761ca997d9cf9c97ff85290f35ad950c19f6734f54350b60c9e0dd967f6998b11adbcb2b3ee9ef842aa76998c0afc4ad16e99b539f07959794af00148ddd24021abc1b40e7ef80189d19b38afcb9f66c3dc89c651bee1de0b39f5ccd2334b2b688c9f22426747f2ff6aba0ad3876fe7688b1ab41324a9d5e0b93871b8ee76baac175f671c3f669d96fd1157ffaf230815230e41f849f4bdf7b7684a07cbfebf2c8f2ee799052f0b456ef3349bca512bf7eb421e6c163a8f6d12388be02d13f2b286753b9313f624fbbc65d9a540a25bcf402ff87e686cb20035be8ba2744f82b5f8b88f4cd8a54b906cbb45ff7509321c9e16299e117407a7b6740ea91257432040908c697c3667f6f197b46d462fae7db03a86984d6850a956704bf6e9e33c9ab117cb9daa5feb7da054f93dc5dfd3e3870e680af46cc7ef699aa735a9129bade93ebf9a7cb541e0bb2648dda388cb319faec604e578bd9ec8ad714912d06971907f4655cc9aeea16a972888571a09fdeecd525f5fea21ab27909b752644f593d434d7dc2521764490de6abe3a87fa60be4af309bba8ebca490ca3705bc0565d46c090861e4dd6d09a6f57dc054f70b38fe5a494de39066b15c2fb3b684330330aff6cc1046946e84265c681b0d2e38cff430f65964f4acc411cb89b814c77721e1a8ef845bb6c2f8196459f39a306845466383103b2b00cd5acfc160b5006ad385d06f179336614a2f3966bd4d379d965e4284e78a18a6298fe12a99269c7bae9d95cef5ab18405c027b12c4a6c065b419b0a62d5b6217806af95bd4f462ff5867011cf6faae3152a0c8079bf3465b26e56f5d862d7c48724453310c877532f2f51d92dda1adf38c2b186ad0dc4eb155962820ba31f9b0f5916df0441f34827a7bc7fd6a39f482080ad0276d5e000fce4f5a46e6ef1b39b9ff8cb745593465baf25a7be02462f2bb7516d716b9f575270602af7ba9140fa9ec5bd0611a2cd757c55e6d47800d1ca3c598c4ceab2a7cb2f65b1ee36cda32a59d2e19795e6ea2ec1a91e0c79ae215dc5eb9dd562128c7a9f29a0c0ccd93bcd6e9e7e4248ef0f046b5f85e7c5e5665d6d573ed5cbb4658746f4ff2fed0150f10d36f84934ae9b4cbb17a228875a461b97f5f684c2b8be6332971ae00be6c920ca718033bcb4e88a546b78c0a0bb37857c2114e3f7c4bcaae8fcf1b98b5b4a8b4449ca240b5c16e8b0390f57e56277fe50e62664f8590bc54d25c898ccd917a05c1408c159b03617b01f96c54b146752711902d4b42af8680f28473fa1a2bad054c2c4b0169d94ccf5792424a6cdc49c1e5185769219a5637a8c33ba3ef7af00a89c3e36bf4d2ee7956434695e3350737e7dc3ba285d9dd957712b845c181ee4ff4ef9416e5ac3582acef5f3715213f854e620ac87aa29ebf24f2e7fb4f1d9c6851bc6786562e95db6e24f9da3eef935e6e433990040948235b637ecdc50f32cdb1060bca063e904ce32c523934397d64844f1791c8312958fb070c9a77c529ea004fb5d3d56ed319dca5b32cb00434784328441302279a38b1a871530e04bca0cb6d9698dcb33533bb020c315239c99ae2001e6b7c43c7189c3faf3c4bc1b83f284eeda92cf096b97de70cfbe3b45a5ecff28d1475f3cb35e358e35fc5a5ce6c17d6f76ba9c33cd33dddff9a2c7ccc469bdee68660797197f07b8f9670f4195c7a2bc6131e7c30933518248f5aa44e32fcaf43c83da3cb7e3ee77bacb9e241b6371c2eda091993b2fd1b8af11398d06ed00b21af560132f35c32576f4f74332b4f6ff4d3351ee9e2fbb8889b244a5cf7e3b41417ad611357e39014b26c8cae1d91243eff1afcdd52ef0e88a00170327b2f956e51841ce3208547d9c504168124876c15836e30fa9bc732cb771949cdc91e18dd26f4dc4e55f1b34bcfb965f373238f8ee8c75e188b34fad7440319c2a0e36e6afe63570343710db03febcf255f8393e7e711c904c2e41d74fe4e39235f42f663832f1a4219e28c53a8ec53c01bdb43b9bb5be0d3437b6041b466b62b32b4cfe5f19aa45a66de81b5051ca71abfa1ca537f2f7d5eee2026d34121ca2090a128fd3c7941563bf1af5668822adfd8e5ecc37c895acac61322d645bc4f2c35c18e0fcdca40fe8fb8e2079da7e887e6b0bd67e1efd8c1e76f1307a21071859daec1ecee08fa1161063bff152ce0be41c8e85a0e8797da448f481556f58ec1c466946ed8a26ea8d843dfcae5f3e5b129a25c06577a54697d984cf0a7f2406718c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
