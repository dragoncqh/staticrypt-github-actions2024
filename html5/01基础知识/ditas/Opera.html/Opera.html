<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aff0126545e7f9e57086760a62e78f33f69d4caef3e043453bfc9f57435fc487da0f9e7da1d09bc5353bced72c85d352bcca51260d6eea527c381169f39f028f19ce91963ba31d6e029b1f71666a86f372ea1ef413b5ca8226e6db12eae1c5809832f51dc57c30f9acb5936507680fab93fad5dd14bef2c6868e58f5b785cf6d325caea8fbc675618ed9273bbee63a3caf7043bcdfdf486cff77577a7b8dfb58a8e010a9de327a92b04acc09123194196602539bb57db56b88b6881f20d033b9295db21f89b8b6eaa8b684c4908e70c7a96d81b7c7b5cbb73ca22d9e92f8517000b5b7e8ea970d7cd3a122f40491f8ad389a793345fba4a9ed2f79fa6a3df02ab15db30d8ab62f1e101d94d69f7ca6c4eb87d602a3d125b31e0fff96d44f016dd52b25077ac5fdbbb3edb605cd578a2b1b03fc4ccf2eafdb7c66419e2ce38a5983113f5ad7d1d108047e9909cbe71b726d70b57a8a95238bf155734b7166ef25be714ec965643ee0f6b657951eecbeb6ab0c5eb242992d3642c229f95e68bdcc54c4ef826c4ba99db03b1b1ca437f8ab1137cf0a8e05e8dc2b9bb190dd673dc6172f5d3b188ac4e645c54e21fd3a8292a00c8c71208198df3e5ba4c7c6c3811ad3d4a5afc44198a88839df8e26497e3189d11a8b306645bf9798027a28ee433406171ada90e01b7cb517cf6cf85b207d9390a3ff0785f507a8cb23bf6c18e95bdd3b67abacbe1a5c2bc8e50e4a3becc61ffb69dc68b9a329da959f369f50b9470d3b3fda8c77a428809a54247a924717b81ca9dc130e992ed1535f1bc547823ef353de50bd9a3645dba24af918744eb12db0fdc2756026ce3a8601f74012ac92222a2ef969c44acb5fc4867575168c82bfd9b8e1744e1105f97d82358dde543fb48d8fe4b29afa4b945405f7cc7eedaa36ed7f946b4f808884608384556af21d82d32479c01e4d3adaedda5f529adca564c242cadb2554290f53019cc21c0fc67a0dc53c999e993dce410641ae84297ad6acd997ef3f65655e26491c2af48cd1d89a0d11672255cf64f90ec5b181def500b58ebd40edd401ddad0738ce60fee6f2fa5bb8447f7622d6b780171ba56b29add48ed63417a9e166a4aee71fe4141f97ecde7cf365c1656bafa11b7823b9d670d80b276f38f910246f35bf99e1a6791eaec607d82b34b65d997ce9a923b96c9eebb4338cca790e3ef031a5734b0fab2f9380ddf983a5a4fca198c7b7130522b3f6ac31e4ea90aed0229a31ddcc76d6703d80fe7ebe439437b99da141cd0035413c4fa238cc91b9b4c935cca9edcf641f2f0b5ab2e28c94c1ef09db6c7bd1092121adb8051ca47d71d89ed15dc4a26310e243ae62e70bb4e0f304a6653610713c09529818b3539f4f423c53d26ee0eaa5ca3df55ec682b368599d67fde57fdfa32e4396367d4e2c62cfb26d602a7807284222e4b062fb4fa3eb8ac3b5bf395438c7b779ac36fda4559e9ba95a3a1d423ac87f819c6b976da3567bd3696643e932320fa15d9137382d59835604a5ad8ed7402d5d7e6d675b2408b9c5f4fb28786f31ad8fbded375513f6b6d53d207b4c3c0969190300f9bcfb59eaca9a4ae66f92750000becd28a091c4422e292cacf8a767b7bdb5b0dd4852e1b69e5c27c26e29f519ac271e25722065c9e5c74e042dce795a660b3ec77ad3f02e1caf8e0b6532ce8b1dcc3586debfb0dd6f22f76605a9f455983587a8d8554b44d92b488a91b250d89cd782d067be133569b01b335234afcec61394a8049b3caec99bd12d4306286325540ad3d0cf1852b4ff1cfe1d9eb626d699bbb1a040c8b4e11b4adb3d723470791599044452f322b52a25ebf5d8c8c20081c319f95abb0fecdbeb3644ebe02a1e75c14078c4745889e04f0c85465cdb724e1a726dab7fd55b4d8a3ea04803df1ec117943be0bcc5e990920729d6e7a6fa42340804f9663ec2d98e7172a790e0891174abc88964a81e0847f8094ba344a9602b33c573455bd7f9a872c0981af81de8a2e2d37fa3d88b1d9f80be49c4f594e76c4a6345bcacba64d6b63ef8c442dc7f73562d723cd564050f4592718dae3e2d70cf8a215649c5f1ae0848ebb37a68327bd580a9e95e8de5feadb6cd591346bb21009ea7edbd117068e7796fb29859926a544422d1ab6e21b9bf633cefe60e2c48fa58dd0b18afb5f2ac7a42a46baa32f4d7c764cd6731c83c962694c9dd495aa9f600624a161dc114bea1bf158164df0c1bd584aa70f4eac679deb16b325687dfc8eaf52f89a9472a0276b5c049dee6c4e48a4a2e2b3127257e01db5d43b96591b3a714a611de82cbfb50b06d6c7965d9005e007a226ec91415f0649d91b21a68b70179f8505db1bf8b9749adbdcd58780128faddaad1b8965101a2bffa3e14a4fddf6f711134ae610992f84d863970068ba839d4bf716ed72031793d5082a45b5f4d519fcbe7cb01e391bc40c09f5072be5a19904884f8278dbd1ba56f54120dcd294d663c7739403d5cd73ced62a1a5af0500955d996c3351d183d17b90d3a3f22cf2322f3db23c11fae0c8e2b5d1deb8d2bdff41f489492cde1ea5f11793c56f51cb3c1adc6b42609ccd6ea416e7bfc8ed4f6b8b8ed708723ed7f6cd76436018a72738a42fa292b8d8f9b69038f933f823661544de484a778bad3a632efa296b9e8c704b1547486ed31b31175d58239e7f556ed5503941324102b6da47e57b3a7b40fc6c0231b6afcff9721e92ef22a3c59933152837f48196a972430e623c7749a94d86ad7c94b5f1ad6cc7339aaa90d7d149e2703e2df23616544612a778b37b980af9a138da866626a92372363a4d7aad51348464183bbdfe18566e73243fc5220c3410222bf8f6bd3830e84964899c4fc1f81613c1eb84c09542d49965c09f76b63840a7e3ef8a4821c126a0f16ab62df63e74949e1d4dc5ba200d97072654d965c2492a15bcc0310f7161e4afc81dce356faa9126a2921b3f0d00d3f2fb72972e01488125638f41f3b467be496d1969d2ffdcc9f48bfc795ae6a437b30991133f0b1a7afd6c0e3ff8fd5a96a2cd79c4c448922ea7461400b82c1eff9c4d9f11e7613d958afd1003be1ac6adf561e02c680e3b34ccea2f5486cf0c59f8517f69b2342b4cb37160e9b76125b89b48516169aa8f78e8a941b8a5dacb9aa74e6cab8ae9428ea0a68c850bc763abf3402f7c70a506d75e2d6b8a1cd06719013466f3e439695b103f343cb2158355c4fb6482cf349adbdba52461762884c3ddcc17fa09a5b73cef90b3fb80ec252c9e6f1330262bea3028dc4f44101605b2adad7bf2d2a0b730426fb75cd9bed13d86ca0c16275e0a425829fc41b64c8c764cb7cfadba7d3031b3c10079dd3b82f88ade97aca745ea002e779554e719697b8c165647c0096c8406bd333e5b57713ba61e6083808fb02c3d0f8dc7494cc9e2a1cddf1f2671061e22f0e88bfb7e685df92871c1f9b06acacf24dd0fea9512d821f81e9b86ad0f8266c074c08d07f21c1d921906c5b88a0efee8fd1b6fff66b6a5f253a07519cc1f4fa60a31a025ebb50b9894bd380597c4de52e4c11181c967544dae38a61d0b21d40967cfd0fcf3f4660f71d24d2dbf03547d46deb0578d61203112fa26be2e6b908cfdf735863166a09f720fe92488e1c25c9c4451e3c969b4fa2e810cf5c3b6af05e67b255d2cc722be381d6c4e568d549aeac6743ba15c68ce4e454e23e0a31614159ebb992505d4979ffdbd9ca1bf8b8baaebd95fdd3974ac404cd1fecb302dc7d5b7a38b334ad5bd9b17ce1a3b64fb96a548c9babaa4d4436d2458a0cad96687fd23be3c57194dc105f776a7749a22d1c2629e11a004bbd53b596b20b3299158b1a05c58a142d39d2edfbc8d74634b9a95039b7443329e14317cde04f1a8240e5a1371a62987e3bc9ed937ece10e7c4a0f780859d0def5c4297ffbde7ced20809a11898002f97f02abb795db4fdb5a999b4950118e26ed383b6126b7b6a513730ec8295a7a7d36dcf9fa96abb3acb03c6dcbbd2bff8684df0c5d9a38964375681d1ad41c761b24f8988cd4489a4a979e9e25b558e47c3cffd1ece906e2d2abbe3e5355eda6c51f5428f5e033f2a99ee9f6b7bc3d3539eac63beba8e829253344de0b741b0675268e0e120562feabf9823c28fdba81a8ef1dcfd80419170df726497ee3c1736c9d54f43c236b1f7824002535238c2ccf48af2867408cf2af7ed39332a1f4f0bcef13b4ae3529851a22564068d8c403e18b34b3142290aa89e15245067713cfd298f1b6914f8586c32cd4d11ae2ad3efe3273224bcdfd60aae63f16dd32835a1a59e1f804b09300b00ddba043e71e0a004aa1ed422af33f198acb4cc27abeef9f3d6a369bd88541b7d530f482c71ce2059b78a78084b5c344fe7f85ff1c5fd5c54777e54916e2b1c60929ec84f611149406885c19e49f322824fa4771d40b0adbdd960d10daf21d9b5d5d22b798fc406702f0d31057fd684fdc1c4995264d6e22e13f510d4d60ee3e4de5286475123c5948189772b9160f14fa7a1b1f82334a5fda9c68046efbd6d7630e87b92872b871ddd32a38879676902e23008a0bb136edde900bf2d2ec8ed8a3f5f6ada9383fc88a9de1f4ea8237249ceb5dae61a70b2615fc16167c7bf56cb29aef810dfb517fe76468b7c9f72cf8dd820ea02c58d9dfb658aa0eb455d19006aaed8d60c6f37a90c49a73cc66bf6833186557dbf6aba2e4bef5109764c00da42a559ba658d87a40def3a6984d8d0305088037900c5f58f1a81e2657428f47635f25c16cc1fc082eaa0f438b6a858587e84b4457640cf41159a35536b7d9820e480fde92dd05973ec9a9aedcc2b74e6591317862041081c2b58a49f27aba1ade52df4e7b96eed18c1af07045928afab3970a6ff3f3131eedaf1bb3dbf94f40f4572ef07805e7c6290f1e3d673f6bdb4d0a9bc025806f035ebf2dbc4eb1d536fcad05d35eae08817eb9855a0632c1a2534f10e97ebbb362682bb47c87ede6a4a7f425cdac66b87de835c220381825d1b9654bf37a13de75c411dfba7c1f0ded254c570221657093b137dff303101e12b2a49cee1865c892088528fb0c4ad61da99a0f26d9d003eb8a73a5599cd37886937ecc1276aff1850d0a29e4b7ce4b6c1611adf1baf7129e3bab630efaf07bf7ccb35131b0a6a3022f3cc9dcc956eb4e6e981d95bc71c77b7c860eac6adb3c6da92c27a73d7af607b332ce844ca6691ecba30115e1fb3058cedf49ef753735f4353cedb473ee25972ee7b4701af8d5ffa3ab30b953d2775a58d31585680a68f45ef70fab9a916b20a4f9522b382376179ee3f29ee030d0338dbf3fbf89405b64234d3a3fb20c8f5ee72478610f20ac2e011c24872851ee2b500347f774c88e8fffc0b3d5e74ce4f1991bf5042c7305d2b13ad1668f6525bca80e96b5e4995d6afcc580faaeadc4f5951f61d6b3625bd0583b3a0a1d70ebb9c252965257842f2ace578547653a686a6ce30285da505f1b8df3622189b625ea9588c35d94c746a07038d6161fb4798c413d5e5356b8b0cf025ed232eda7cdce63461a605b83bab43e2a411fb890b0660355b1b345f8bbe478a2c01ad2647d567debbe4b563b21f14479b3e5c2af6642f6425b56d6181a8f0a858b189d0dfdb58abd835191d55c042b2924f8727f469650d50469702475fbe5e078927ba21b2720fa967b3a4b98af6cd74731c83131803b72f33a2a976325eb3d67913a3598e8d8ee77f7f594e736947a183659c0ab15ab467105370c5c20c01a82569983845c927ad72e668155ed4a4da5d49695abfb299680aee25c8a0e5e862fa0b5f9b59d2cbda7528e906fad5ab34c0d43933a24d19d50f0fd13eb72b2882a4c0c6377e10f98add6e3a4567c86b7dd482e9cce4bca92c60b35db6512e0302bdc1281dc9c31087d6dc9099361ae0078767ff7ea9f6b95580286549e3218073468c8baaacbcf3f07f4d2a745bdef5d28aae3cba63f65c64e3f48c68a46b69dcd120340b52406fd164f3296c2d42467cfd500da2f6521e9151ae59e3cd8afbc815037104a1f6e54b9d2459a5e82147804dc9883ac8c44dfbf96a54af8d28489a6d9a0b2783346d6bafe26468e3b7d9a149a4ce761e70ca58d31b47b89191b4c1acdd31c75add03f32d4d70d9db42f3c8da2329a6838f7619790cda0af0ba388a0d860a4e4784694db84bc537ab84d5eebabd3e742c39194cca5c2cc88094406fe6cb2dd226c684475c043418a41c50b11456ba07fd1e8e9b6812a2538952d78cb59e789d0d32bc14fc0a4c191bcaf81b864ecd5e4e1450fb059fcb873f6239986c32a3b62c5dc22b9a32dd19b5cda6cda397e928a54720f62913775592bbc6472039ecc191b3857df6c48fe28fe956e21a306b60ef131f0899ff8bee6571578bd47afd017640d47e9c78ef14c3090bbfdc50494aa0f93fc96bd0ff0781d7ab8ed3c90352b76a3fbbf1c2755fbb663d626ee8ecac5814dae8b26eeb7dbc01c11f1778016ce0c29a0dec1228e40ad566d710215b90058ec4f78d2c5ebb8a1c2b25430159c5041cfbf214258dbb1a8b13b45e221255eeb6b9a63d43320385f405908288594acefb9b9a3dc4b4287b35041061189d1f44147063c68c2df5abcb8416521c9fcf689a537414812620b8f2b440edae9768f51ad44336fa796c06c2a35358f0d50ca2aef3dc4d626e9d5873e2bb40e552ece641c7975a05a7b4a6c3c9001e341c0a8a37a5cc5d13817ffee889ad0b8035a95de444e2ee3611bd1e762bbc2f6b9c780bd285d4c90ed98510fc0f6e3fab16fe0b71c372b5a533d7bb1f69bf51761f67d6b4ca5ecaba33e1ffce9e99f2f0929756ab5e4df9a88af3ae46a6277e5cf989727b93da1c6d97797d53f7b04a69c589abbde3a8f7e9a03b6205db162151ee2e873bdb8c6d6cd5320ee48a398e9aa366aa5fc8a2eea5826ac81c93fe521d6371d01c9bb57b07b5d9ec66c98e40149a04b07934d29985b174cc6ad896bde0c93352be9d5c72fb50e6fbb2c2c583f53fd1131402ca5f579241c8715b0f64c71c174bb105740234d3023d51849da57568103c472267a003cb73a1d3eb68bc90f48472433c95ae7597fc2688e696ef8f431fa7e44d9fb12fa09df2fc16781c65aed62e9dcd3b794fe05352bd6db89b5db64188d4ab93d86926fc41a9be9e1f1abf1e96b093c7b96100bed7e900907ccf26db5a1af947038605bb9826429712ce3387b5a835d6e78d209373f0fa94853d860638588bc8882188603c3ca5ba8773e0172d00f5b49dbe013fa7b15f11d79a3d43d8a946348c911e10760da4f2783fe46ea92b9cec29275c230d9ed46a2fda60a05cd4ef4a17f06adb7be3b703b3c9c4ed2e7dcdc911b460121bda92119c051217f153cca2ade5ea6a44e33f3c444b000cb97f8cfd62364472f789811e3f324645a0477275eecc3df38db9360fe446f52866b0d7e6413fe74499d43dab9e986004e34730e1bfb8bbd8f122f648b3ddb15e4a4360d6b1b1569131e52117724ea2d8cbbbe973f9c6835b6d8e1ac92cf235760ae3b2326a9a3074afca0a272b91c1810a3f6d15c7c5b9df163e35d66eb02dfeffadcc7c83f8c175b274639052a01b712ff62cf8981921a8087b819ea01d30d51e3ec6439a475558e8baa7706117681cba80c34c2f222b45e4accd86ed77ab74dd90ee112015441afd592163fcc3141a8e44f0144e7ed47de83cd64b586bcda5237b6c9fd2435d65ff5aa56213d8a61734ee0e64db485a07a6e97503545e260f53569c4b933ae60475fb3d3b84d8be0f649807764ad45709ff53a1b6646624917f431b70b95d4d2682288bc82c21304d88dfa494805dfef51e5f89f178485b57b951735e8eeeb292c53a384a1b825da27a9bfb5b2d51e609bfcfbe4192d56b5c9e3ea23bf9bf808704c61263fa392110c6cc315624c6f0f2a29bc3dcca53bc89c664d4e068f9a2c0b58050eb60396c2a78591a70d16c1f5970794c1d6cf2440bb2377bd0f2aecd453207bb3a78e886ba5789246b6505283df0763e88cc4f4b3856f196c9e01ab780da77727a3b6d2893facd87edf728311dd4189421fe13594b3074dd26dec8ae71999f2d22148173b7415a7d3a97f6bf19c27d653713d66d5dd969834353f884cc9be8620570c67121231201cebbd104be00c9403a73af6204b4a4636b7425b566036baacb7b66c2978e30d6da8e341a53fc44bdb1f4e52bd84ddc22c79fbdf33e3819ebbad6e36e6fa666005b5b681739e1bbe9bdb81343e24ab33e2760b9f1dfbf86d92bf23b4bd2aad0b31844c8459bd65b88167d4ddb6519f5486b991b17c4a081e5e4bf588d32f06361d2d876676454a6b9404f04dbcd1456ce26ebfea2b405f07e0c433c5826fcb55fa66cbcb349bb3465b777acb160f35f0d41bc157498efe7a15dc3ece23690bc9d63faaf0bbb74b9c8a1a6c6027c127b7f23f4cb971d6f1a0eb06956b91231d45e7e68482177d16263e08b8479bf2ca20ce7ac3c45ac4faef3f47059069a1e25cd089577d9b98b70a4c25429d609fde1f7ea8d13b838511b69d306023b31ffd60c2a7b24da9fbf4746f47c3e3660c39f7d6f207908c4010f9072019f40aa704b882627dcdcbebb0c4274b1be27467d0130d1a0c4471df9cb9eb7c318abf3308c89ee09dc491cb6541002a59ffc8ab9efed8a27baae5bd7dcfc6cde056a719dd5eeb5eb8ef3c1c85ad05e7dd9a7bc7871ac81f2bd984fcf4cc4320604c3811d05c7026a29d839488824863aee9a2d9e7e15e81f81d14f41149c786ebeabd1fd8c96a2cef0d4e39c206a31f3130779f3b1890aafda3572b3bff84843305db8aca656d0d1795e5cb30e43b39f80447790d015531e88daf9e7ba20c676754fb4dd26c2d0bbd2204fa1df29e1c83432699a830b6792e7e336f57afc26eec1b8c023031dbc8e37c5f6c0dbcf525757bbf553f7068f6d9aa51ef507c0a504f78ca1ac268791ad10d3793a9983de2705be7e18ddfec530efc3aa77a6dc9b8e695ecf350621a974974795d84b67625d09aa2dbef3974e106ef27c289fde3fe27e5b3a7d6532cc99efe36f5dc8229798731e8a01981092798dc657db2230fb1c7cc21e0d1d246688c573fa61331961a4a1b2bfd04ff598ba9ab140d1f11a42f89959079feaafffe8c9c3eefbd0ced58a4175701c996ece018d3e41cc43009879ca8412b0c007375449c4ed0f4fa0805398a8bd607be7c520e690793fe7cc8ebecfb285e94704b93ac3f0504b951e43617d72417a678b9d7d1180dfd75fa1bdea00cae0aab31caf17e3acc3b6515751415abe5d4d2f9a67de23e2644eecb2fbe90b5ca99daa52f41dca0432325fd545d2887480ed18364946c5070d51b3c1bba02bce71d67d2e9af9a48d02adeb332175cbaaaafd72f15698365335b79ec61d8520c72ad81361d05ccf0eda6cda8fde5441d878e44269fb465de7841f9a7e356beb0b13b1b22a6d99c64230965dc315429f75c3266970db6a084d94100f2845fe87d65645a548583a87bda4654a881b6623fcd060ff7844a51b7b9f08fd59eb25a3e1752303112d770767f5e60db00abc1a161cae3ac8b87fd2f835b914ccb0579d26b1ec41397d54c1ff73af92a117b40ed42bd7afa8c8b51b22805935ad478ad2f21a9b998f45a105964a99d9a4ce74258d54f708565530b2ed2df58aa10d70eabf382b41b7a837fc53dde15578f06b4031591040aa09867b0eae6ddcf24b7a095181bb7cd741b4db7c7d91e3d024417d6155d1492e2722af51f8f8656c3a1c7a0eeb866d598091848dc141109c8012e48aee8e428d09c18e553caed94085739ddc51b46705bb939ecba9f5c7331ada8ce3bf50c82b3fa5179094bdb3e8f3cbe18be136cd8cfc9a3a155faeef8b6635eba700301159c1620f7dd1fdc7b233ba78a9a8a8131d5e2e5714fcfaa843ced2c8451ecbaa7a339b2a6c358d88b5136fd8af3d70d258e64c041a4b59182c9a8ed12634e71c5b5530d7d153317f4b07d29e3b3a37cc83695e5bd56ecb07a74e2d135fc2f052444828e4ad28143f2440453fe29a43b27ecf9da48a18f10a07a7b2ab9e802fd35090573b4fe8e865dda087d2ee5ed9a3cb4f5800329fee60d58877e2cb2655d27bd52e26d2391bf2f9bb3027ad193b8b74132c53bc46500be1af6fb8940c9296eab3a4ce13ad6c302eca594ad6ee359b32870ab71b116bd19e6d31f70788b258922ae90a87177acf51548837ca27b361e9fe3bf4df2552a56699c85e92a39792943684f4908e4599c842ca4b04da877def2da2f7e296b1d2039e97068f95bfda4834b79cdf0128e1968a59971f70ae7d82175eb6e014e98281132f611bf482a22d273013a4f7b1be460c3385c1fc25ad11591b7c518ba5659c4de49fde5f7acaa6bd30ca9fb5dc82c7577108526f61f347eb181e3bfa473f2f04f61105a9186ab7d87198b4e7e9c3730364c0260b347efa8e682bf9b9e4eac7e43207afa2baaf0d3ac13ff18a66410f3fc9bb9f3e41899b2a180738e8c72f7aed6fba28f4e69da32edeead3fd36be0f5203ecea06d73b34e7782b07b5aad36ebbeba9497607f454f0615a71db6b341c0ffb38b815db192abfe02556278508b70256dcbe214738a2cdeeafb3cffc9f3883526f3743e30fbaee1c0b0bc4dfa14629d54086e1ee6277ea942e94bbcb9008beda5df3fb92560032a32694e6db581b10624ef5c2598090f2b4bb0ee4dff4631e0b6cdf69190aca6510d7250af8306aa01e45e5d38559d09f2263bba6bd3b9cd72315a273e6dfd02e649cde0fe9c9b2d644c92073d40a05402bd9975c0a749920bf24113ae8945f53a5c947f8bddf6d61c6aeb122077be3ed2c465b480b56a02050c0e8c7833780c5691937c5b0041db5467454faa34ffcac8ccf51eb11ca402b5182f197f91e500ab4c93c552a25b53097e98b7400140887285b03373a71650cd7ae1ead0ebe2980205632eb1a0336088d9f6c8299b2fd8ee7d8a405a941730f1f67498a1feb65d505b76c4d081bc78d509e5bc6af9c425356087f775b17849131c5f89aa159f186d20cad4a760aea07ccc0ed51e4a12fc08d5fc4fe32ca5ead7e1830ba9265677fcfa3006111b77715faaa366cbc4d571854132376f00747b7333b3ec8960795afb24cfd2148ec47c382313bc7f0e05060267c34b3509760469a3e697993917984bc28cce9595dce7a77598cdee2ece74c2a7d1721c621ec624dbe2f0e8cbec502018796e044d80133ded30a87f386758021b56a9349e367fe89a7d8c6d7717a9d9dfee65dcda2b58ef3943c092ed4b9e548168bd26118048b0d8b86ef2a2478787a6b72f7ea44245907a424d26d1b944a551399c5f4c4d1c620d5f12a799c187850b639ff586485b96029317f55c29c0d6ae99cb451af4cb51e4d672d9bde2bd87bf3d421778a9523f2bfd8dcc5f709aa4d115565f389ec31339a23b30e6d10bcfe31ea1398f34bcb7dcced4a7fb700a094a2ad4a4ced278aea54b21aca1dc3899634aeb40466d7411fb7eac5a1fad2014a59f14c4189956b2b372842528f0f919437f4229d6ff01b0b2e07ed94eac092e26eb907d63666c7bde5c0eecee141e9dabe84dd06900f3bbc0c28d6f666edf18bd72b3d8c411eb4d457079ab76a3ffbcacd91d35503429efb14d4665971cd562c1fb32b2cc7edfd3a0518c1027471c84492b914c192025bdbb9f457a1c17934d265e3c09bb6a3569301a4da5bc2231ae43f240e4d3610cd181610ef194522df5b3991ad1bcf7468fcbeb5c277edccef92cd822c072fe1acaeacaa7fea45101e81b2c2208976043cd457d668fd89408de452b97b66be6f8d8a371cba8c6124b5b3434a7be4dc600c0dd4dca3203fa593a55ded273d4a757afa797d8364b8ebdd5a77d53cc6f8e663afadddfa7cf29557118de350c39dd7eaa0a71ba320b943465cff41ae1ee21626a135ae2b4f2a1bfb9433eab49712e66e54cfbaac831de69fe78c5fe4e678a184be67d0e79411b58a2dd82baf72bdca7e68d69380236e0c7be3bb518dc9eceda08dfb2f808b9489272078921793a1655791368f9dc1569f22c915bad045b15a05cc99dd238966d490ab1d4dc4dda286615e9852817ebd58f5fb25f75a59f3106497ef3f863e487489289f8ea8354645ab1dc3c528a8c5674e2e7c23aab7eac075e55557fac30435ee171e9ba25f50cd94d7dd87b26f3f71719ab61e555c37462c66456c38d7bb06b67001f553c9b5d8a934f2107bf0fd5837387f9bbf47cc0e4efb3e7e97bb2bc103bd56587c84b89414b4ec715529266e1414f4fbd44684f94fb691b3842c00568777c49d48f2f436c3fabce4c2e3280f3d15d57c7a6a6a231fff40a8a52bb50c9867a994b0d53543274dec8fea0d800f3493c8b27b8e021fd091d4694e4228bd382eb31be7f05f6a897bec6097769f8aaa5b5b18f5236c47c491b38423fc33615d3253cfc79751781e4db2740b17e50105adff5f81344fed8532b4278c91a2983d1a566bd1e74d9076af25df0a0c41b3f2a808a8499cabcc6a702f3a572d9cf3b41e11115bc85ece0dd8e85d9173f48f94016838df622b1f33b00e8d6045d2665eb2a31d56420b36987a953e88821ae48f92e41b1a4cd32751b59a5fcc1d96705cfa36e0b2e569f5d254e32137db2533d77d6b0ee772520307d5fe403de7c8e86aa4481da758f9c3fdc342c3bfb0699db46cdda2c5feac7578fe8820a374eb54698ab7f2c5519056155892f915f369dfe4c9a2ac1d580535a04b65bcdc5b7f478ca61386c8707d11df4e50825daa49f4abce5565d8acc77914727e4cc36a77c9bed1cb7190ed9ba4d6712fce59a49ea1d63c406cfe20e8ee209b48f3b9b62c5e9fe770b0be595f65d5af666d36adbaa521bcbce7c6b7950030b4211921162f4669287506bf02129832ea55cec0fcffea5151543dc60c1bd33b8e9daf6844a850d35d7d3f001f8bbe2f644a13dc964104813e654e29f1bd4bcb1279b2aceb0257574398d77fb9787cb1ea9dac03665cb08c2b9ac22dd7bb979400f159a588dbff6794742716c1023dd5f83f2a67e4294e5e6a061bd4cb460ea0c4f31a56313a7c0001b261e6cce87f98b4ef2eaff0dd5805633e80509cbad5ad1901b7a57777eb8dc9d6678bf41f658b5ea80931bab0ff29aa43cf54a7576490e4e03f56d014c2cec29d0b7e646f70c0ce27690a1a1a24583161abfe6084c78102350a4f79cd5f99fdd4b14e0075fc53d2b4241a34846b05822b85a70d3933f52d139a207c25ada0310e7210f5470f287","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
