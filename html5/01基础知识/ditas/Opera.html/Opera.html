<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0caa090d02ca528068536e3c351483e37fbe16a1700cea5c049054111689ee4f9bd83bf71d2e3d89670520904df0a70cf3b4f09e0e26f432e1e4b4efb37422c90ae6f6f938156b2ac634f384e6a4edcc4d2ab82d104d0b283d2d19c4315cc51a0e2edf454f16c5682630c9bb202be04a9339f305576979bb563961c8af0be4d208947f70c13a5bff8814a6506d9803f74d91efc8873fd90455a8adbe6b8f6c18bd28f5a9589125807a25872c4249688054bb52112b17c9641a50ed2f4a19ad153ed882bd5ea7e569aa9f56471f8818e3a3fce16c40c2dba05d509567fde5bcca3ff8c30f04c36c970aee9eb5db3e12a7b8a2fb0ff0605bbf75f25dd17c7f724511bc415cdf02eb61c78323c74a8ec952294fda7c6112a9dbe93e508a893c3d4e3bf1e0bfcea77c20e0d634ab94ccf40cf70c869e7996c2672e22bf93d70f0f2e3946563fb17c87516fe76ca5b3c845ade0403f8c2a93b4dde1effb692bcaf44d9adc1c16b383b69743cfd3c66a8cc352f1849686190803f50cb2c174fbdcf432906b368076fb72b8b1b64eb0a8f9a48a55f991adcedb888fef4dbd5137752e913790df392ad6be91d9c27076de97c54bcb00fb7b74374219d11640357529f8fed09068e1671f5806422ae79b211add887da241122d8b8586eed42ec9a246245849648fc136e00530ed051d68dba0cf2095535a583a2cc3d692a871963a6edb830dfebdb841987a89090dd62ac6129b06df2f17bab7de9efe4cc67ae73f47ae93a47d18e0dfa6d844c4aa3237107fb9aa1e762b692042ca63a98ab793e69ac845bcdcae32de3676e80750f996b597e0e9cdb40d5240dd5bbdacc00bed4b72e48dd2392a8844353119161251be9f0eca81de69140b127a31f920fd114a2bd48e27b4390a3ddc702fae3c2c6280d06ecb7ebca6a2d9934b8f0b910dd7e2174596d799a073fc5e3f29231f1ebce93475fc28c8adc472eeab93b029b6a792dae53b663040f3c41998b5eee1ce7ee48071e45b910bb162ef8b2b8e209e7fc4d16c02dffe87fd86ec5e1be470f68622e7cbdd7585c5afe07c9545bce7c62333ab4a95568b803dcf78466b83c343d538a7177d0b91b4b3195f8c16b154ddebd500bcd6ad51dcfc5d8843eabbab997bec98fad179f824e5876da52a79a69e9858bdca66c4c22aa119ee1387460960ab5437cc971adfeadf89d51cafb267d170920b7c6851a2e0a06b89926fefbd9d3cd48c15a6ecb049cc4f1f4253e97bae87dcb88ccf3a276de399b28e3592e872d1bbae44b5a2549912f93670a809a18758aeff6d2ddb3ddae681239f91a0ef7f3d694c03810273aea0823eb8ba15a2ad839debe21af71a1f543998898ecdd7ae5e4bdbd0fc3a0abf7ab2cf9d238cfa8bc7932ab9bb73620bd4405af1b7d1eae1f6e1ca69c49a3b429abd4e42d0eb81f7784b677472fcf1c57fd9f7b360cc4126dfd32aeba51f4cf9cfbe5be44e714977eb682fcc04c0f6666d5646c366818cea1076343dabace082304578c5e43ed37db384730e42dfa515867a1c3d11063d2c8cf92c44574f12d2de9998909f09425bea2eb368aef2a6b5e4948b8059ca4779dd7108b54ef40cab3021b52043817ce619cf84375ef40236256e92a587164a23d7bf22d0b615e4532d4f1e3d2ae9b44e618dc046d750746cd481bdc6cb711addee943d381fb8feae69565856a98d58023f52424fa34da805ae3cc73a01373ee24e99b01361e70d3b2bcb4ae5735ca8ce7afb70e029a3ae2831d3cba8e38403b41c6c178bdadbb17e5f026c90327321621504b68c5af2310bb2c72033d843158671d0d15ceff75847ddf3cf73769043c20e7c7c52fee0dcdc46522dcaed702fc177fc096d0dc72ef83784b36983932171d3a12156525f87064ebf644490eebb56ee7c80358c4c4b21c3c1a42ec6112e5998d1b07ea67595813bd94b211a7bb7d9b179296931363082bead5b9bf3d4caf14c86ef483a19f9035df9f6578a270160b88b299f345e303bb2a5b983b772a5522c29488e840bc1de419e4999bde3d9b3605e45b72a16f1e0e786de4632e84797e31c5256de5755934511917ba8e99a7ff6f8ce6a68a59565db7cb447306685da783915ef7b6bc1ea7522748a0f2676c9ac55991f3b12d181bd4fbd6e25161ce7e747c7ed16d99a661af12ba13074bcbd7d0adb9dba2069662a8484d5b0a9e905374e8e212d476d0dd3e37bcf573ef6daec92d840978067d96176d99019ef1fc379512f7b5e2f051c3483d75e44695be2e6128c3fc565de8c1131dd19b171c01821d9a278c73fd16f32f9fb4098bc676573268613f2027d63b5f7ee9d74122c95e95d693fda5fef8a02080ed41b58a1a58a83bb79a90c09e2faed5a2c8181fdd75bce65f43c6ab6fada0e96a38327466533a1bd20b64cb0bcf32764a42fb595504b147f66ad819f3167e4a3df80c022f07d7d6497319213329ad5b47d44126ad484875309c61c96bfc39929ad58e0acd9f3188bf9b5628f775268d721361d84cc56b24557f3a6e2e77907c64133233fb6cec34e1c48b183cf4fe8e461d0e7f2ef69fbdc5bdfe8f8bc6dbb8836edb74aa933fce0a7d1297434f49a43e7b2f693e742e5281ea5f3b44dcc5cb5737aeca5b7df3412a5454c8318c5ca00971eba1fc9f3450520ada4a538426f06861dad4bcf4e32871667dc267247443e86c30e4d951a92531629cdc23b35f7deff261df725ac3be23e0942b06d8d47d31eec8d332f19dd0162d49fec2a243fd64106075ade3f9cb677a1105824f0548d538952b1c4e0acf1ffdc494e0e61057fcd97de9fe7273cd26e69d7f76b1e8558d80ca6f2e73d826aa0cd3d43c68fdd9669242d06eb7a2dcf9c3d1f3a5057486de95f04d77bd3666ab094d4ec8b008a32080ebb4a83ea64108487e3448fb474791770ac3bf5f2ddfe039774b2ac9ed0d964d46ef5ed2301361c832362057493023938be15f407329be74fc0de32ba0aa785c23a5d983cb32119a3d28ccfda349be0d180cd19a829ead8d0f428d1e8b644dd6d5ae9df5c46ffb5146e9e3036a18899b114420ed8837b3117aacb946f773b54ccba6326c03b3fb0d3bd8275d3955760d70d70c32105031d441a5c466bd170e7cc5772e5979d12bebf8b167c23c96c4b58eb727c7a3f8e7f5c840878a94b587aaaf6f3cd53ca0491d5b528ce4f3205ef4bf3b421381fa90652b1b56458ed09a27b9eafcd1b0edd81812dba1e4042fa76cdf6b5a02aa5dd02d6556c8d540639aeb2cb452ddb5bdb7f73806fc7571e267188d6cb98433481890703bb44c5e3ab5eef1442cb1f5ae0bb6387c4c5e37183879847f9d85930ec08d4f63623c39b18e1daba273cc8ef40f017899e25a61502a950b88e0967f5162e727e3211bef111b97db7aea621511f9fde2dc68975ca0d7294503c4421e21d854585e5ae95a7ff0abbe1053a9ef8e94e933eaf7fd55b4b5513e2870817d518ba53970eecb9a25b28944872c99c83dddf45de2f4f7a7494676ba91bd811a800035f3b8a4061cd86c923b741a8531a043788bebc87b25623fcec0461464fb2bbc5d48946a08db9a54a0d88dc68c91a4f47eeab5ff15f14abb38fbb3eaf2407b5f3ae9dc3b836f3c7e3bb45d4770a407b0cd2d4b66bfb917ec1b872d6f102922539247b0266f4007672e358cbcd97ccd9637352c91f0b4c6a79c0c6ee4dd9f0db5991b27c26a27259f9e3b8f7e1fa7806d48c864b75be4b18e812f274ddafc1d757b30683e0b2420faab6564864811d9fef0c4d90ce520a7414079b1b17e601119e7ac66a50859df36a63f19208edecd8d69734536ba7ca23faaf89480f13da0461d233d4ec543b405344799a1919daea1500b85e4aa1ece08d69da7941474e20bff9719b5eca4107ef5a8b7f5b9374ee8566e548d79a2d6350160058d69a8294a543cdad8a362cc898b453090f7b49c416cbc759c165f7144c0df6c7a27edfa060e61627105d0c6a9e0a9995384080f0a62d2b55a80cf73b01bfd82ee17d03c94455fe866601bd3cd2912122503613f514758dfa4901137e8daf63ab61cb6da44d4851200e19e77387b56150be6048543513c87059ee6d817f29aae001bd1cd516411ce74e2376fff141947f537f3f6d8ba2f8a2d04975d86eeac5b346645dfedb331a8af8adbcb2b338a5f07ddd7dbcdad0e8a5c30793a1dd5648afca6ed8c5eb5920d14d4395f021e913893ea3027b5b1632e56d4fbf10c21940c14c4e5dc1151494ab06b3bfd239c1df44f83440e46a283570594add3472290c3681c1d8da7e5d6581aa96dc42d84fb920b8fb010f8f5401d9fa276d317756a83461f0b4586fff5b0905f9defe4fe1a722b2e36da367242ba854805310be0efc5a876081e7eea2622f9acca57318c86d2993f25aa2f6715fbf10aba1c59901d6528d36117dea4af0d5b29704c9d24e04f3730c2af2fca0746cae1a34007bca824c4e0ec3e54047ee5c5b7420da32a797774ce0e23256506ecfddf37d7df9abc2ade7b4cf8472818eec687016ffd75752920f01f68681855d887757d8ab417a901e6ca226c8c4858188e25c0282cdf02d5ca1d37d749644c3b4ab2018652bc2f384188dba35e6405ec3be171678135785f71e0d8b95a316ce65b79ece70f084850c2f0f8b6e689dfff21d696de3a4b69851ff03345218f9d10198af35aa03eacfdf5bef19a9768eb822e00010cb0a1adca4a3c0ecc989f260b07b3ab2181ae742a30c65ee8733e43c44d0c58e8901a181f9d21fb6b52c376dc031a6e4f95eea0f715e4d66b1a3a5a6cbaef57a7a914f26acbc4e560eeac117d1ecd9e29ce8caaa66d9b84a18afbb3f0c2cb9090523f51b8e4b8b08dd8aff1034d48b845bb7bf51c9b50ef74bbbf90c01993ee251b1c9bf16f5fd28373779b52b93d5bcf97feb82301bdc8fedeb54a2903dbf6b3a6cca7a241fa5e2820994eafa917e39d64e801777e77a742cab848b55ec099e137f660442266b91a8f21296cc852d92ee572986b3ccbbdf2406b97b1a4d17a639904d210ea75e792c12c57c1cfddc9ef3ffc404bfbc5437846688fa2a34d04a22cc2cb23988e9a62353c83ce96b4359868110cfa30bf8e8afee22827b8d8b65b9e13dfc12fc50438938c715cb8422f212487a28aefd14f798401f8d328de66d547b5772a0bf722d6fdeadbfb8b601e3bbae2c1d0b1859dd1a9814fa457fd5c0091ab28dbe545e264f7fc6c1dfc17d0f3c96d5423d84e1a9b6aca7c3626a3b97140b4cf46f68047aa8843bd2703602e1d1d17b35acfef6768e74f3712804232e142f9926834e24befed7dae0fec57d9e9bc1160c36bfb277a497861a0460b8f8f3fc1c57766bdccffb1afa8a494e7cb63d9d86940dbcac080cc51acc5d35028e791ed09ee093fd574e2a082ca4698481790ed7603f75931efe697e288edafbaa58083675fbed7e6d56a000a07f66522b3b7ea8df0ed92c331322777b38dc8ed724e0e877491d175d45d41353d36dcf4ec3e86fd37b7150a44d010b76771452f04a2c1e4fdb4d4fbb16e52f36625f87f64046730c4829237cc95f3d5b19811538d3f8c9ecdeaf378e80489423c5d38a6cbb3bb0bb2bcca0a37752b2fc8463ca808c4607ba633ced2ab2929abb106f8e35e1f2169173899d2a9bcad71c58d1eb78ac3a9475f101255acbd5074d1c3dffc073df61634b5190b3a9f229dde0059213f97f6f91e75b31cd1a5d1501b88c0f72cb769303fba789e3ad5a6b0ff70baa5eeaf495d3a498f7057efdf2e091c9e56ab7094338536d56c7e1ecb951449981a3f3bad4469ff17fde3630f1979ef72d37c51e5a89c5baffdbe6a1ea281ca2a47af30fce4b2a88b209acd6a34dd764e20c2ed00531a835e4b897b370af12cbc2e5e6f9a66be95974e15c92cb81935ecfaf357031162c9cd1090895e397c21c8710b9c556fa4a107340cdf26e64b2c3949acb557257072c1b5753769b828c3e1dc237d8d291978da617fd6fcc4c8141d8716905eb6ad267e327a12c4fd68e20823ac5758a32ffaa2ff15ca6de9761156785190494a8516e46d3fc62342806e2281cf979454059fdecba97ec35ac49a87e47805d53b1629b7d46819bdcd5dd3c40f206cb4254b6aed91e5b80448232c3ec2e30414b46164ab7e664f524092b0d14aa1807065adb80d0654b5a2733062d677783a84889258bfd0395bca03d51ad3c9bad24ef72ae51c7335f3c7b8d3fafd151f589c4a92b9f6d0ffeedf237f2567b8afae85949d02b59c2eaa49a7cb8a5eb23c790e37fadcac4c82fa1a86b25ab27e60cc60dea3ac7925bb287ff7e251fe19a383e85982587e0ad2c0ce47f19411c1c222e741089a0a24f31a336b62a08d1b4e512fd2e2407f59dd69a069a4effbb408b349de8f85258561192ae7d53d4d2686e665ddc86049c296cbe33fee8eb3cd415d92fedc9b3c2bfc7e641956224d416d5a359fe663dec3469953558ee199b64204fb0f4a5c7181faa0640d6053e207e44db4fd7e3b9ae2fabad3d4088560c71bc72c7e5e3a08629fe75e213d4890886d3cb1904f6c0e7c6f7ecf9eed49532352930dfe6b61a74528dca721743b97a4c600ca08992d7ea856654c40f42fb21cb523f21e27d2f9e40b33f42f015a9074f2eda6b00edb0717845b859735157fba04f2e9c3b798b866993af6a4a444b9c97e3c0202ecf3fc838caf79a608c11da8fc354a080150b7cbf36101283588c58a8cff16e474336f8cc2fb34c79f6e3220aed497adee5674b2048e5905bf6db1a703314b451052ed4cd1df1acba474c166ce738df0fdf4f6cb5ecd36734b09fbb1dc4b3f03bbf3445d77e5ca27a4e2607d1f4b21da34331f7fe65bea259c976c2cc82abe978e34cfade60a41ec8cf117ed11bdac3a71feca14a367fdb9524a8752356c6611e98ffff04ec6cba1c39a610a8d008e1b19432c9904059eb0b35c295161f543d4e75cc5bee565618f28a4dac3892b85eadabbd720b56748966ccc54f64020e13347e7efe1dab2fb7abbe27b0ff46d2d4926cc047217554e4a201534dbdbdc6fdb7bd41adafd0e7e798efb8648ef84a9004cac113b694dbf8faa52be3e771d90643c8e297b15f9394c633394cdf98a652c64ba3dc1dca34fe16d6521f80aca7966d0cbe49ce69ea498d42ae03fc426b8359ad794c6542ee7c445d7daebe3b68bf4e5d5d480f6d8aa6ccb3773dba310f97eb1f1d7305102fca263d0b625b4099194e726e443dab8843089664d6f5969f8f2d99b82766cdd1736de4796a713afab23a877640a73ac058c390e8b68e006ff2d22bc52822397e4a2ba9bfd557a89a10afb6e9fa8a8bea89c33ac8b6f570fc002618d90c049e9d0f732276ff62b25e5aeca6f5185a12c99b1d0fb878f96882cc96960a33e93feb686b2eb079a65c06db1cd75833a38663ce32319c273a03166fbf7be0f87635e7218d4010de59f88d88d6b154ec62d1997503c71229e0e8d5596d672d8242b39ef354783c58b0940759563df0e1117dc70c5333d932cc6a14b3eae47b2a5c3fec44b95f4ae0fe3baa0793d095352ca29a3832e5e74fd4032ff432e0b9fe3fdb50484364c307c4f7db4aa81f2829879cdfe4150e580a111d99ffcc55df211af0361aae1e6bc3b40b0da1ddc28e37a0dbb83aa248829193a6d55aa4dd26b4a29ec55bc14336e002e7af1f6263540d60c36163aabe74385c89ccee9165688e0b63468baa045edf26b3eb69749a864d4f3cb4b4a997cc4ac56019dd0af79aee0bbe6608a10a11b0eaece5b161e168066d7fb3c1f071e4d5bde160045c0088c6f4951750f9c8b3fa345a98e6877ec596abad13665a21147150d750c0c29eb11490e660b640d577bf0a0779178da997a26f5748575e1273c990860d41477a49122453f00335087501de4a2808bff72b4bd3d758744c0402faab369e569c092ba69fe1914607246bb940a2e1d241950752bc81dc30661592acfffeac97b3209a040a26ac2a5c8706097148fed417c7b33ee32fa141a49e2fdd7b2200dde8fd0206a7a41c8d2a72f6b170343f66ca53790bf07179220dc059a2c02cf3fb1f12bfdee8e48abb3f4fe9c3d0f02a7b11efe11096594800df8a086a5ae831bae8f13c93ee587995bb1905c8985467420b005f074714865b07e2a9a2fe67428ccdedef818fc67b0e6127fa331ffc5725a8d270c6f5748894f54722829d5bba3da5b6efb1d25df65e04c8841f66104e6b9f024a25019e13057bfc01e7e27a21a259ea9f0aa91f19c7f19c00975a2a0152d8e50a972a936e300554eaf144f24ef792ee7806889769862cdd821cda1139f06f8258dc4f022c85f850ab02a8ede38afd4ff69269169c72168f7f29647b1442a0fd58d339a292e872a1bcfbc31ebd423a0c12e58848cfaeb583912cf36872a47c179a0015569f80311abaa73a0966a006d91906d40d1f9a06714165dfc94e14e7e72748baa05a20275fbfff13804539decabfa509cc699b7be8291cc24889ab395934519cd92146d2bdbfc11650e8609905ae1514e0ba1ac4e56d6166bea228f7e3d891868ef9c9d01e9cc2511f697bad1e62b0980b9ed51f775ea68a44d3ff4c19ef45819250c5ffcb8ea3466936fe95aebee83c6952d0410356536173d96110a032a71e3d3e1a21b72f897aacebc2049b5650fccf98135cf51151eb4c999c5237495de15aa632e68ca2ebdc4a622199c05cba4bf2aea50a62db640fe6e28fec8f9be04ee4fe584f456279ac06b91c008f4a09db39e143233b7487df831bf98efb849f953193dfa6e24408fb18f37bed33b9a41d9afa2264b3136483f09252888e7826bed675512cecc15ce1e603d2b5853cace89098b999c72f3ee72c4a08d8b2d07b667203fb35b23a8f11af19af7a6a0ac0cbe37580bcbce3ea440a7bfc01a6fef56d16eddf9c8b532412eaa16e715f3322c6da88b3eda517c79e5c674e3a4d2aae37a1ea415e8362cb2062db18eaf7bb6a6d20bd8f2b408361ea72828765cec419bfcee800fbaf7505dcd5df8f5bc359fb6719e04ad999837ee9bb14130083494622ced949dc1dee425c7b827caff511cd47ea01855e4b8212e94f619f6dc47498ea2481b3d0bce4ab3f7499995e0f3295f8b63519143353cad04e3a6425b1ca25ec2019ce14152f1689f64b5ceaa3aeb29feb3e5fdacada05600d29a532ab28b56faeebebcc8a70359ce7c7d2ee831714a9da15b13b76a6f8d0acd7307f1bf7b8c86184f159af6a03640c0bfbbf461224736255a54b46b9abedbba1f54f2ed0873b91accac1fb5966cc5f688acda62f6b14a627450e095425b0c39c251131ab41907a690544eb18a75127ce632a92fb0f203c14e45eb0ce71714f2fd337df92996543d5c994c0bd23144219c4a3e3af2d309d5f3c39633db32778700059017024aa4e13d94b442d0a311e0646ccd0048ff10e56bf9688759a60888af40491fc23c6eca98887b35087a7171c641d633870150f7cc311167c373a826032fe18634b6748c00f16f14ddb5cb7cd9b170ca96f68827561d3e4f06d47a526b9895c5231f511b8e431e3436160c29b17c49d2c1c1cffa494cb734d458e502079964afc40fadf83373a16b2a0b9c67e3bd1b29082ac0a7e70e5c15e747643b7eb406a19338ce0c59deaad98fc865710f696f5c17044cde4662edfda6f91654a64e9a658a8354e9b1f6e22a4ed5e1882e9fc75c09adc4348f515a8cdedc9cf764b48edecb2caf0142f73bb95ad621b04f5e713b1edf730829b94f6a592f5714d1f6e9de1d41689e39b1960f3e461455a0e53f856c981862a951b6e9f1b494b4365625e515b49e59e98fea4523a86fba541cb4d851e50d7727bc503732f33905007a6578ff3c35d1c1aa7ce8fb0a4e9075d05340b6e816ce8224d62f21cee1ba927e1fb5a8a7ae4b0205a288c00e3627d8e614f2ef37ca695c330e3a0b6a1d9c02847031faa4e280b587fe278dcd88c5b302ae2ea70ce330fba8a713f97b13a177fea547503bd1c1fe2a9a47c37b9040a3d15e28c5abbf906de292b6e0ebae0ac700521f4e655d17487cad7c489d804dd32aa8d2879d14adeaf4171ddaad8a4d1687e250be6bebb27654ec22f81563216785ab8972161350e28bd58b76e16767d44100bd866606eeed9b902ed8bdadd750703286df7cea66227a41161e6ac0df3362c6de66c95c68daf4f0d7ca2966f604cc12cc492e60c3eab2a1fec8c9fe6aef93ee516d89baf852e0859953319fb3ad87ee5268a379c62dfbd5f9faf2780bc68857aee45d3ea52f29fa67f173f069fcb06d27d916d6bbec1d6e578d4545315122ff54531d1a0265ef154b11a3b2bd2dd80e55aef8494b63913ca6590af9b5ce0e5ca51a922fbca924acd9f546b2c03677d08e646e356b078ce1c5e7f7aacc06b781094a57b04a7f6b8fd94f51fe62af1bb2dfaeafb3ee0e0d8b3d197f3b5145712753b5564e84f8967889e4ae8a00c6a8cda6b6e00321afdd1d18897dc556ac8505d71aec79a34419c5c8c7ba3362af7c0120dd41298baa916733a69d6acdb2c212ed72000a7180261fa0d4b9f668444ecf013729f377ad0727356655caf64f9d2bbee9343320b07a235bb235d2c956e1b5cd091761fe1771e05a4cbbf3413391a4af738e9c3e8f4c31cbe7fc6b73be5a2a4311863c179667cd0509b7a9dea03a4bbbf23e01819d0e2b3aa83ed8127fdc100f8279b730b4f42821170fd87b1fc62e0344d4eee8f0c295e710c839ac45c4dcdab43c4a00c9eceb69d37a866cb15ec22bea6eb944fbafbdb10edb9d90c3fb96aafc1fa77bc175095b1237e75dd981ee5ed59767c5fa7c51245fc2bf7c6aea1df9d04b29209e7e9d824d139c1f64fbea28c5cd78f6c0d0ac4fe121cdfd8cd50398f3e8c23e501d9bddd5a9241aee3ed43406658016d5f3e44e48871ff4ede2ed4c9c67af973c78b62b7bbecf2abc9426573262d6394062068850e741cda6d24c765d3c49e58f0da84c23778673361420e138df22cc25752fcb5653b6a264cce3239045f5efbc8efe227bd561ebdbf08985545f026b3bba055252700447c1a63d3ae73bf66baa8a07f57c2ef3fd2cbdb55641e442734acc03f12a3aca70c8096f91dd31da3b1ce85ea7616c1f01c46183e89245388fc968dfff7a5462ce6ba8b8d996c8689ff3fc6d9b2dec8845ba7c520f28189ff6ddc3f9ac6693d0067f7e22c077940c6ee8ecdc212a60a38b4eb6dcb664a3b9f770a48de8202ec0a6160f392c906ac5def5555830f8a9a564379ce21fbc7f64c813c5848c440581a47f34556d5f72bb7708d44e160ddca65c4ab39277a1723a0e194f719100a297f387c7a6fc6343cbb52cd420c2b70873ae918452c08bd205dd1ea32abf72d3322761b9a5d73e30536c1c8249a336a4d531c098348cd0e6c4bcf2f4a7577603486c28575ce5939ef2b0adeb4e7a8d5f5b63ece3461a8b1e6b231e34fa9ab3a4b397a7611b5641bf029b029867690b199860b97ec948d1ee6f7ad045c4d2d8a900a6a98e2d535b6e0b1110e6ece1cc57513a58ec9bf7fff8cffad72e23ccb6340b41f754e83d9c39abb2ab13fe154926573b6b5a9122d6cf1fd7bc363d829a1b7a6a58d5ac496087085f5e6012e8105b26ad93f75f7e0814997fb658fd264fc84bfb54ddcd4507fabb315c5067e4c9357d7db1f1e883fab1e5f787a809fd95574de66e14b9c10ddbd79f63a6d5e80ab5de9f78352571fb6f55343c266ded5e79187d5459d41d7ed2c1dc730193a06a8c8f5cbf388f122553e21e9c5bd954cf2feb30b82083590271ada22156bfa99aee363088e7e51dc935e3b0469e9065585a4af1ada43b413aaf9cae0073307b19408bf0218c902944324d64c925476adb8eb2b0b6c3b93780b7da93911c5c78e390f5374710948507c2d8693ecb855e27186b5c9b58c6162299cb326fbaf8b184519863cfc117c60d22ea19963ae2728a7fad34511c0adeb3b6d061921eec6c1694ade0669a4b251018271e851915079d3f819482091df381458049dd3fccbc1a00d6f6e16706a86a3ec3cf8c3b4d197fb53d160c7632190f923bf5dfbcf1e4fa2a8a0ed2b9b76b68d7454ffadba548d8d5cf483ff875f5a406d1d2e19f20a984fe977e423d516e654a5ad79cf77cd481d49b0f174fc1a08c7c5a09c5b7a49bf582d717ef12b5318db314e8f6ab016dd0508d10ef66cbfe4f41862dd9cd50239a9320b967a37dffc8aa8133afae9f72586a563272558e3d07b7f7b22b02c5912cc2d9d5d9ac1183f911bef75d768edcd9ceb0cc5afda44c6a379562156e535c6d09ce004071531e57d72d0418d05a538de0321e932782fcd6449c550cea80b57665a995e0e1827099aaaac4cb2c15540ac866b5429869f4aaa0dc169672347ff3413a1f67d2afd9e081723b750646af737c0eb1d91b657dbe2b91cbffbe7337d1bfbf25495e0508d3c3ba1d71b1084ba1f9a64e4c42483f7846b234e704e116292e907effde044aa1f1b2e9d3ea221ea6fd97c7fffa6f94e90d793414434c75fcd658a38f90dc9155a73db95d01e9d65f7fb5370ea0f62e55266e76e2f8a0f744b14649736081093f107c80e0449f1b28f53f91737a78ae75d8c563c2b878dd4f01559981a2d4263bba3721df4cb182fbd82620714e934e45128f74d4f1b619db7abd91a9f8c669a5cd8641053bc6239447a1ac91e7c74fbc1577a4e5a21af85a3544c208499ee7c7a883d4f5733d0b80a2d24da413541f39eb6b54a2557a3ef12c447fed38b712541a3d7bbd481f10089cdb4a374516f0a9946d3b91a85169a838384027f599efa3c5ca0911fe36966cf2070e0d32d95b0a656469de2533b98273c22b1a2239b00b47ccf8a58787f7bea0b3473c1d08621d2049393529cfbd22059120a0686732d291d01274161957a47f2abbe3f065067483ae1f7b5f4852aae70002293cc4b1a7cc355ffaadc959346f321919e965772a0d1fb5dfd7451e68341999a6bafc10a3a1cd4fbda59afa4a467905bb8bbb102356d0a21a39c5c71efb96c1f1bd51e46fd27d93b2644d0a3252ee93e0aa86ee4c4fcadb01caa6e77e7594d37862b9d90fb45256fd91a824aca8922137189a16bb10917c24aa207bd7d6043293cb0e58dc87dd14f3c6725a0fba5242bce42723dfa9362325f2b66ffc316566f58ec99c494b11e881994a650fb6a58bfb59563013ecbbc0f0ec64b52891d7244984eabd53caaa1e9f443a38225201a6e2f2bc5db96107fa8e4ea2a503d7ad7575dde5073c634bda6da81390a35a35ecbad845d32caed36ea99f4986e1d33d86c72ce956d895184d33493","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
