<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a5fe509592b1350e50a66fa97450154ebfa2502cba0449729406a97ae32ddca2ff92e9746d3f09a3c349edf23ce735d2a17e4133d651eba32c8895af3985df16003a95a969109a3cf9df2f4409900d520a59458a35c5d8b0f613d041b805a2d0989021e9afdc31dcd9faeb8f98e7ceb0d24d72bb5d044dea5c8027ebd781f5c0e1c75e25ce2d0019c142db1f28ba4c0c8754c8670577c8b057cbc5ad60086b56cbc6db3a23205b197c4068ef6fd42ea8a82f8e57ab0a2ce164788b66573fbcfc9d63d9e351781d789565b5e9d8982695111745d5d6d608dc6e8863dad06befb7a64f081c230792d062fd095ba3d4c2ade91258a18b6404bb1f7c33424946ad94c8b387a8a0b492d129d4922457c371c3ae04165b04f029152514bad80c571d7d3597eeb1d2d7373a7a4005974daf455a48ffd48b71c9bac1d960b888d22ecfdc13ce4030b9ce6afc162cb415b49d534c27918b75cf0c583754100b0942a1ef28a82dec36470195f1f15a41bc8d5645069b138e952f2a07196230bb9a0274a15c02168d34ed1003f7ec6479d71b5f43bfbf25ff2f57645d24c0d7fa1d4c8e1be82fa950fa9fa54154d61a0b4df22ff1e97f4685913494f9a35170bd03cef42401bd8b2b4048cbd4bfaf94ad69116e8c2829740aa7522086d90ad6a3c5e6b129c6774a747f0dbfc2d1b36497747247c719b80173c2d5c6ee2b6e2460139b4a98bb9676ac0ef5976cbfa3ff8e514b0f9c7640a685d50c011a25c5a32b9631d17fde12c20be0577f91a029824b2a36c77ca2aa54c21b773639612dc3a775fd7c24999ad319e0a4ebc4d10c9e261d1aa1657edb5bbfcd7dc3786e226cd6ba01cf1f1c6f323875b1a43f63cc2183dd9e1399492bbbcd1ff6b81ea47b9ba0bc9578532390b87e8bb1dfdd3471703313a325d80f7b774a1b9605c455397ae485a412a93f70ad22d17b3b2bfa787f2234714fa1bf941d0f5375d262a6daac321d4c3e1e14b77c0f937573549fe315fba2cc18b4fd437804d281b507b38bb102114e07bcf45fd27fe28a34554d82b5556d68c31338cacf3a3e6e9cade7bdd8e635e0eb2020369ced2346838a0358f27290d789dda14bb9a8fc63e9ef6ad1e11e6318612b8366ea014fc07d3ec3517d7585a3110d6af2f489a3ce13c92280b6808008565c31eff5244c7d0d202c3a2ff537988b97708880ed42c8c0445d1fa7a0928f7945bfe9c2b9a6de853416f00f4b36dc9a97b94f46f3ca5657c4ddfd12a9c8fd27eb125bdd66432b5d52cee7e9287c224472168506577cff56055aea3536d0b6f7edb640c533059e8162f160a39dea87661179ac9311c01c1c5ae85db174251d09a088bebfe32f4986c127a67b9e2a27d897cde3ebe0309a30b2d5bd800f3e190faa73fff97bcf4c0fba23e0844c4ba0befb45cde5564002ca8cde90753fe50dc26aa8d2633a512a5a9a9e49a3e6efa700d72f2621453339cae329ef8a81b46cf66a63af619a0731cdccd603598cf253a7bceb5f64dd95aa311d6255ac3b24875eb682e4101fa2d01b43171890ce2d4cec97f3d831a70ecd99e161fc98206312b69a04e4ccf95ecc6ed6d294a53cfa2a2617900f16d45bc3880387b9c89738f935c90a02b72c961f934a004f5f109b0f0fa88998bf568a6f5dc127489a3351b2bef8990d2f5a50a31e76697ef034665156410780d900c7ce99b9ca23515c610e1fe5b961de2fd62b544460bf35d05449bf05b4920d237708a5a1601384e42a034dc15690c8c569008708eda8cd7dfb8bd2833342d50accc400620cb802e8775a9d2b7de6b81669cb35fca72038537fb69132e2c87ae21a528c9888eb36e1b90311a44f80827462654fe0899fd34c06ff11f03a53dde1347557da6f2d228846e2bd8fc6b96781a04684eb2cec5d3d012f22daffa97c6f0d05daaa9585d0427829c1432a946331ec9b9b5cac039fc3e91087a577122f583a5c0bc092f5f82934b46435cc4954bb9a2ff6e0b0e176fb8be6c180094bc0d48502c61ab1946d21d35349cc6378a3be6698172105f3e065aea631b5fb8cdacd8f6e33f49445d26e043ef306a4bd66899ac7de7a88f2d85310e8b3be2a8099e0f8f21481b9895a95728d684767619852853f962aaaa4e157a41a4435a0b8bf32c5adc2cd594291835276f21327ed8cfbd435565b3356887eeb5cf0fb2e8252d55212993f27a6e96217405eae380921a3b306651b25119d5a04e0ee8babdcbe06135202f08d25f540ebfe5d60ba6687dd81cb7963c38adabe7608a7a6cfd790409e5ed3551e3f92a4fcb07ef496f1d9769c776992ae5a05cc924bb3924fc4753565606a85f8df4ced2b742a3fceb39a4bee5076fd454dedbcea3a5b69c5273c69eb2a09aed8940e8918c20f556dc231aa1c1642264c046a8692b9f6b5e22a13ff236bd300c51c51deeee00da4fa21fd0e5cfbaf82c504980cb8d8913b7e1f3bb038f864ab6c0ed010f77613b6269390b112229f43c09e28336100cccf0bdfed2582df2cb0aa00b7728e0d0b60fe12086fdb73d74ab360c335dc7b071e51c892abeb5900169d48c797400778ceeacc47d78fe7266f1e86cdc9ced19777c5fead1e51ad15333da77b5e349b70a86f421be899b3509617aa411b7cd36968b307b29ddc234ddff1fbfb5b0235a141ef98ff3586635924dc9960ab0824c30f76a5ba6597a760fcaa28a053b776915a5a7cdda3654e097e8bfff557fc667b9205a01f1e433827e3f516e717386e134078f8b555c6d137bf56fe93024862c519b194557d63df3ed3a52c0fa8b132e2ca98a76e5bfee80167dfc0871ce4a68b72889f16097d20756378025e57319f21bfc85d5546b8942d5b65d06a0e4932a6f049bc6e7f241c3687f1ffd4b4e69effa0ee9dca6ad35f2389bebc3ab5c453da32d7f7779084e114cb53ce62b6af48800493ff174d6546861f9f2d1e08c716a2e5253310a9a0043e37233a8acdee0e8ab4a15c39e687bb29f13062ce609882013e91f68f17bb608721b6b2782eb6aa58aed954e064951783daf53eca16a18ff9a8a823d21112fe7e30eb19a499578ad9a02269c83a96f3e3d44ecd8a3af734b958d9c2d21410715d003778889e7a3fbe0811dde9f7be6af18e492d6028b556d6bc08fe3b28337913b2ec98d051db45bac150a232685917a2005da35a3e9a5dcb4653275a2fca18cdb7dbdc1a94ed7f58fb6c2eda4c42eb2638e3e0dcb9583a8f3f7e410047aed53f453ce3a3c6a858fb4e4b296019498c8a7caada200853ab9836f464690e9eafef7abf1e57c1b702663d5c4ce9528f418c72c38f512ee6d39e426d0df4718e03dbf20149a006a39df9f5e5f8a1144c2df0881f00f10286e04973dcfdeb140bdb195d2b913f3ab5438413497c90a8d8a98edc0f601365876a8937729d66999fc1ed3b0853b57739b75f0bbb5164a91faa05acb84292f428f8b147760e1882ff158d1fdeb8499cc79c33728348c0a04610c659f69ceb13f4670b981b439d8850637ccc90567bd9f30754788b62de140109251cca15c0007baf7b73e4112bec414ab61dbfac1a5e33000d0e6ba23a4efe0f68540308f3d8d886800cc534a8dd1eaa53bd802773f3b6e2de1cf572d619a22d15d8df4336c66a099ef355639d394d38f6e6bacdcbed2e865f585f858667c58f97205f0c5d6cd14e44831f4716ac50cf93284732aa5eb98719f3a6a4a269ee7cd9c9e5c092a11a6ebb7237cebb6fdec5649ee94fc24b232d6050cb57bc7a8912badff6d1517462f5d614fae84e1ea524edb9a589d1181b8ad883eec586bce1743b24d08bcde471cd85eff50e680bb0fd1cf0760f550fa8448073829464ec0f27a7dc4b5349f03028442e54d2939cc55fa45486d98169acd0f99c0371212423dec38b6cf44ff742a7040dd536293189f1d907bf40f9f6207710d25e823cd456c6a4c9c50b6e131634ae3fea1a33f708a383604d5493604fe16373834bce8d44bd155435040b9d0a2ea5b3f0d4bc49b20b6c9fc46118c682606acfbe844c59b8d765ddfbb93eda0a61d41063e2bc18d34216ee3455baff0fecc113287f15e3e87cde14a1623b042783d4b4348eedd774bf5c7ff228cc9cdf404068260b1454428f4289dd214fa300b201cfcb98d2cc7a0ff9fdf67227d1c9b2c824151a2897bb95ad5385a410562af5625ed6020cfb45ac9d5f9eddacce9b1044dd4f910a90851144022febe7e1700d92f00b7c3e7de23cc00a7ca54a3f4c757db4a7527804fcfc61994409de9339312bf43ed676a7cf0ca5fed077ff9b317c6da1464ce918f393a68451d78404a9c0f786259f7298b376bb3c3f3bd5e172d4bfe185440ecf2beb20f067dbed9bc115f2ca4e1459eec4a8cf02001b820a2fd50180e90c6896a308932a39ae55bf790307a578118112d6c6311b5a8ed0e5ec8f6dbd3763ab23f245f51511feb22237cb2c43425af27fe96771b124b5bc99191bdb2de30a4d615986e747f50f79ada72550179f797a892075843f479d39241acfc584b866592d22b206b369de03b49c49d019ba788474c20749afebc3a919efcec688337d3b7f83ae05f905dbe5c22fb848079bc815b2e616c329c3cc73513cd9057c1b1d50a0f893c3c0a7f73fdc1fcf66e50e4b7eb56aedc4a76fae4519b2a307e6769d781485be0272ecba2618af2d6b4f944aa87b5e9972571896494abfa8d01db09061d9bb7d8399c30120571860a72a542c893c8b88d7ad283a28a1ac23ca60536fcb542ae1076f9c5ccd89520fb8994f5652fa4328487e05d5010a454922233ba515d89b97d910bddf9763642c768cf2a6c203eb6f3c1c249c4beb400e8bd68813991c2094b64cc82ddacb7ca757b0a7f1871394fb595f601be29b3de30ff55188474719798d277249296ffa23be461e7aabfbe4215b851dcf7d8d86cde9cb445962f0a1651253778b0e7a6f394ef3e01de37a64ad5941f3f7e8749e5525a4e1ce047dde95e1d46af7fcdf2c4800f2bc834b0c56f44719da75e73051d546fbd390cf4e051f4b3ac4f77a6b0114ca8dba556f5ba55575e3ea46e626b250ac5c23411ac83f74b276b48b704a3e1e3309327ed6650ece879414cd8c4b6a5cb7305634cfa1ca0b9a502932cac8ef0af36d79171de579d9a5d2b049e2b4d74cad4a55bf4b59d72a1db8b967d675e4eddd89158aa72be1be99b9411d0b2d192bb9e45667588380ed5b730d20ba0e4d607ddc24e75286a10396eb431dbd8f5f4a470d8022e0d465ee17859e439faf2aa4f9c2cc22c6322250ac54a9ef06873a595ce82f6dff5b5e4b9de020030712a9f1cfa9ab03a420468d7d38af4b16b1ae9c7a0de5f1ce0a882ade17414d08cbc0bc5d29e456fe11f34a97bb5c1a0a854245f2bdeb14d75c2691020666df235e22a6aba4cd6bdf3b883d22f2cf45eab7e5d962209286fe3affbf3b486d576f07a4617b1eea4535432348f00340ba2a2e5519b9683e77ca5318a41c41a8a857bbb64413af0d80297affe596ad0eb0628c08d35db50ac50d22865014a14bb512543916f4e6eec69b643a2f8cda125dca9e7b28db02bad7674d8423da41d3f92c9728b17b7d01d8d8153a74af470644e9f6540aee0b2a6b2657f092d777c554515e4772cf41e179ee60ac30ee916ffe32948f0fed09ba3c8d546067b0ae6033b91211f348a747a83930abd42bd169c0050372372ff84b2b7f8a7652945332cc83142f892d1cfc4aa3372a2a4f1be8ec5596f408202051554d23caae54e1138e7a538ddf0e2901af04361e0cbba538cf0fa30244e5497dafb3150436c8f155896bbd36ba6134ca910df7476890398373d639079be6baa1b2d8af9044c29155e2ead03967b4389d9b6dc023eb3e30e09047f5f784ea31ff437671954eb3ffbe53e292bf631be673985a48c6390d139b4f05a18e5a14d66c242d31b6c805723190b93318d9505c8a9d41c341780ea2fe002b1e9c5607c9f9c24e87452cad4253c37a402f9faaf56c70ebf1a995d0017fc92e46b26eef7bb8ff0f275345b94d212e7985fa2f15b3c7f34c17373d54ffbad056c6fe5f644922bbe91d4e6f6a8525505faea1efd364ef19c5d5e3e24f97e3d364e020bed401b8b9b009ab8246103580d3cc9dafab485c601023161f1a10b9c925bc01fc26fbada7a5928e64aec160ec4e14c5ed6e00d53436755c381283ff0a93788d111b3c04f695b17bac16f90f0d299700e07604d0135fdcd03e26dc8e4d9f7af7bc9aaef2cfb0bc7a46d6a2797f7c26ea09fb7b7a6c8312ef40af76d186464b4b912c4289d2c79c03ce650740ec4e94a2470f5e0bb29d51f9f6f2fbe2582f9e577c88baefd56a2095814a8610a6c3516295e5c5cc2162b02a7259cb10f72b0752058b9a2118bbdb6b563691a813f0313590e613a520e6e662a4295f5a270e47dac68a17c167b3050ef26b1759e2e081f2cd1844ce9b2aef097e418a1be5f651c5729b87d47355d77f5d746db2972b572b2abb04afee7e47e00a1d4240ee8a37618accd65a8937669e3bcff6faa12c2646d899a3c6f57b3356b22353bddc24eb6f19ff927555c5448e857f5b4f96355086866ccec1f71af770df41881edd2340222e1107e470ff85a4bcce1509337aed34422132a9d212611c6daffb64695638fc590017280740a8a48b5eadde85f06460a8727e3f73d86fcc00c44053ef4a8230fce9c3d47d39a94d615f37de7c24720431c0858d292843e4030818422faa2318e3293741e18366c570d9a9aae578d0a2ba1bac3da4e13b74d5f483a73f906c4738501b4f712de09cfaa7beeb7b2278ba591b0312e82f6cc3206eb413c8d80870de5c02fc86ea444e5caccf591b9833d352b86e1c93882ce38bb9374413d3a17483240269b67740a6bd1ca365314af1c174f9140b04907ce17a20a48a73b2522bd8db0a507170bc2ea67a009c77a85529f595d4f7f05bf05b96c91b5c873464da6a9153a9560a6f8a08ec5b2b2b1058812b6ee985e024406a8edf1ae28aca0000ca130e915a8832e6702d8217d61b588bbd216d21df0f1a71a7652032ddfb3ba0099853d926b0da8345fcdc0dd908f52a6586db491ea3580a29fca6ab48cd098dcdc06ebf4597d9852cd31b1f72acb80ac0beb4885adbc30f51d83663fe9bed88ffeb9be0f245b08b014dffb7bc01148a992e17a5db77087b92081ebffc5391ffc6d6a7aa9e4f0277b1f4846f312349b2a5227d8f2a7cfb93d609ff6743630af670f825a2a2f6e05ede77363ed555de7955129cb33c8dfaaae243e264846b5b551390e453efb7a7ff37e03bb22d74ce22c9d75b61bf41e553e0c6431f474d8fe287c53c9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
