<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9ffc4bebe6989440016346bc0faa8afdbb2cca57838b1ced8c441e4fcdfb9b5696738aaeb6cd8bc2df94440e2a217bd7f005443370ae6513d95d73818a2b7b52961233500dcc0db2c5f01349a1777b88a49efe3d0ccf1a53f4e5fbfa971892923c993208f142bbcc5858d8495d304e87c48abd41f9144dde0edc5c99eeb4c3d015eb5b90bd68565ad64fa1266004251cda289df3ec33ffcb0b16d50f1cd8a862df414dae35155c9c13b70f909f2311c7dba3f7504f85f6dfa3b90604ad33bfda2cfa79a012355dd1a05e9180425cae5b5d004833eb9f6672d1271629cd16e04ef5b9ffbc866725f8369fcd5a5d785c27efd5349f0c0e8226dd7b08933fc72861cfcfd01d9bcbf44559d11ad82790523b52110766ba961288d95bb72527fed107c527acd81e2ecbd4e2cf3641f6aa7fefd5306644d862d966806d024d3f8741c3dff70f9297984501add031fcc70bba67a3c1ed1e0b1b6e0d4474e65947dc930869a86df1d8ff7b0e81f7faebd3dc6675a8dbf88b70b3ddf871e94ea461ce099b02b6292c50bdf21187a4e44a43c5d751998d80bc87ebbe9c0d486646e1ead0992de221be090b71583cf9b2d573b2bd1fbdcf7b46c32273c7d5a60545535eb5056777ebfc5263ade5e1f3d01a71e0ef97445682153c2aa38fa5d29184a344dba19dc688b65910b83e05be1e1f2c450d25444f0e526f375311a408f4ac6281f4dbdf8c2343f97a204d2f023de29412f7c56e59e2e750a15715fbfc62a8e4b972e0441a78077e499be6efa5eccda5ee27528aeac56793160226bda5f05fa35d11d769f3da4102cff3a186cb84b567206c18095d6a5c5cdb879fab96fa985fe3c8ff6cd49af374f28af68c445f1b384e02488b83ad662d410ee65111cd1d08d0b28a4ac7d1c2468be8d411d339d709b768dcea15ee6f36f58fd0a8bf8f2a974890a5b629eab62d133a8b30db1b253aa60209ddb02caf7fc54f02d59140a910fa688d64b5aed597e578141206a898959c2d53eefba3f87c6af15a9d13a568d6174e972071cad7261a9e42b41e024f75e06a31f9ba2f687fafbf8c7518949bc47823e1fdac2f176bc212960b175402bb147bd606e77acb90a1fffe6dd2903603de05e352f170cf5d63ab37c80122d1dc2be31e13901d7009eb9573a8aaeb59234c27dcbf15c96c62375025d9753b2c41b4c0c24d02a7d592aaaaf806a652124dffb565a26a0b23737d43bccbeea36fb05d435e57e26ae7f379f4000fdbbffdd844e00380911606d9ee9926ad47866ce2e7f235513eee0c838e79e3f2a2b69199e6725963a59cf8b9575c159887394eabba5ae170fe106c7ab07d812707db85f0f023141f4b9bfd38d2539ae8537d1275a71052fe1643c0c276facaf7bbe1d34cfaa198d5562254004584290abe977c5696dcfb9d937cd9c792f0c1615369aecafea71d1662d066880bd3279ab5b5a255ac81aa9a551b07a6f78297a81fb01b9c9803810ebf0bcbab8aa2255b05fc2375bf7f08b0f310855adc1e4f810d8dbc401ba9c6dac8546de1a27761d4549f0c234f774f673382d8b6975804aff16d92eab1cee683ee876689d69d12f29a7a58a1b8db76c60734377e0419e6a8d0b05b726bf121c1debb98f4250be7498599db383bdc158660f1a62474fe48dff7773a658ad4c4de7d2b2294450bbb655792e1ae1304f5f5ae5db703bc3644262f7ef16d0bbde4af7a150bf8e21dd800076dad6eb049eac0e909ba6b54c18261d506e969db880f381cd1ee009031f7bedb502a111dfcfd82f67db6eeb82afd08d3faec7ea24483ff7343a81852e45ca696216a5d8da92483171943c5666a09d802ff530f621df8dbe024908473bdbb29b0f2de935470176c90bcc4ec921de9a2215fb14fedd01c0f3e994b5a8d3e667ccfbda3f5dc7dd81678649871e4241183a16b81b8b74eefaa04374cb78617b704f66456b8490da42edb4efbead96910de97833c6bebebafcd8a1462d6fd4b121ad0fc7b0289c6febe9aff1879600c1dc3884b144f464abba50f1cfd944bc5397aee733c378a9aa545962b0e909b88dbd959b8c6385d281b3cc7cd4149a4738ddddcbf86d2b5721b01e50c2f699c98a5317c3fb5fbac0c5f2ab526670c59be3ad6e1fa704f9bcd8bd8ee799dc9f5f9cc9050cd4ffeb444068468699a21eb8dca4b85559945493619a59b6a9a6ae275d927a038b42f6287b6194595d2c0d4a8ba5951e1563077f0f7e19dc3a07dfff178452899c8cadf1b3bd154b69badf1c04a0d2291fd7e88f5f11917839809cc3d92aa51813114a20c57b349070ee1276c93097f17e3850802f463ceff49750eee07f2890fd8999769f79626770ef69e436283aea37fd09554ab5aefd8530f6009610bb5f70e0ffddf55d10aefde5c483e666bc94793563eb42513e2585dc1dc56d6010c83815ea150d1ad3a223ebc9c80111d45f885ecec4e994dc85b6884f7811d4fa43cc949747e4b7ca6d6ab832652d2977330d78d29be54ef851c53961b3f08c543d1c107753fff74a41e9b0cd03ad4841639cc5692864926077eaabe7b0bdc0c544c315bf90381d4c74a50a1478aa2c8f053fdcf87e4eb3011216eb034cdadfe572081b141537e77ec3a0d5e5c71c0b1e90a464640c9b6fb335332ae06c407380cfb17054f41b89f01e619b4d8b622df58997a95dca808fae336e6d9ffe35cc535fb0513c469cdeb42617cb0a5d592f71f0a0105dd10cc461236df44c3d53be3a5cffe8a9cbe77c2d49aa580edfd016ba8ebc1105c031e608b143580eb3a635106a80f6897a49c40ff27274a8b09dfc4be0c2839fd0b4095e85634e38d259310b6909abb6cbb8d55e3c37a29d1f9eb2b77a45daf0070f09004b8361cd1f458399376270e704db1a8aa3830ce4d4e4d23b587915ba1b3e64f75c5a290a91ab08a931ea87b160210901048168ce7dd4c3593c9d95e9cb4e97c89a3005deaaa0c7ff8b75b3cdc2540f9b1cd617757aedf854139da28e0ffa446c5ebc27979f8bcda89c1d4ac2e67bf65abbd99500d0bc0aa5f8d001e914cc46d2f76f08b078a729c0b6ea0a042e6bec29613ffa75a1e4f84610655a6fefa6fe716bb3abf0adb0d351dbf76308b44c76f4d937a6b1970df2b0bda8afed818e281f2ace687f379f41f394742d983cc7c5826f6cb6b68aeacd4d23da9d07c747d9b4a69db4029b6cefc18d84ad880aeeb81c1a5da778e54c8bacbd5d5bc6904279b1cc65fb44512e2968c65eef566c95aeb57d0ecda42d012fde43b440890074aa547877fee3dae4964854153dbf57df38887b7fa931a967d7cf35b297d2712d971816e1a3b13672ea9b2f532f570be61c2d7d1c7b57fb368c2fea2bfa2e2387dc3bf7042cdaa66c4ce84368841f718c909cf0682443f797a61e2442f4a1e32eeb845dcefd28a960cce11941c8c3beb5b5cbfb6adcecafba0bc7ae464769b726c7f3d63d28b67c0397df178d261ab21d0897ff0f3b57bee292a1beaf08a9268f3d351b5f559de2b539aa0d9117df0e5abcd6c89d04b331b65907b7e8a5982a4315ffb550f71667e5b40d7157c641562b849c4aa609cbc0a9a73c6ffe73168b52831b4935fba2a244ae09a34868f888a8341b938be94ee6f8aafa5b95c5807eca77035cbd3ccc6c348677481014d64bace09032cc0c09cf9f29c8e01b9f1c1c143fca90b35b4bc10c7ead3b28fd82801391c4f88d81eaff1f4868647f75a7252b1de5bf9b17fc23b2c9ae6c2077a5441309b1dc5c4226be45b70942f18decf6cfcbdbc8df27340e4a3caba1e75651ba1b33ab7c50da4c933e29c50a0d276a5556d0790ba781d978ce49d39514fb0eb39291dbd4d14b8d727abe99604b1a11b1ca9b3168d3faf7f5bc93ac05724ddae3cffd21e5db83555db36bbc2b5012e7d7b542983f7434d0f3a3028c8b388e141a25f0a4bd2cf6bb36cf0c4f12b6fcdbdd1ef47d1e55a0dd49f0dd18f025cc7d2fe8f5be041ace6848243b18b69267bbd56c164ed01c9b5cf14964098da3e206e2ca3abc1b0c4b93066c4fae2d2271bbd6aeab2aa0826bc107f57f98c76509f30e55da6788489c586ca62ff275698be24545b2c98ed8c63b1bca8507dd4f3fd72c15b496e06447ce8413c4d53533b2b91aa2973d386ff03aad9ffe934965138daecd81dcd29ddd72a1f3dcd7c095d366676f8ae573e3a6d6488364e305db5e0e197eb61c2267431e328caee75f16dddca1d9b1f314563dd5e9e9a597f014a4bacd826f60ccb833b876c7523f728485f45b734c753d81b5c9b8e3a8cab19a850e3f3334235f053dd9a09015d74cdcfbe65829b29e6e9f7b96b834216e3a87831c98dbb56855ab325b380e7bc1f9993d2c9804e6b9fa99c74af6f218cdc038155ed43c45f80f4d68394cd0b7d0702877955ab88cc202ad561e911c1d4a13622fa0e5639b3e8203d4243bab522e3689094f1e79f1cdadd48f0a09c463b6386612e8d8c3cb78a5e4e35becf1555617f7d48e63d2ce80b2e758a416bf997b779c4cf300145601918c1f2062af087ccd4b02981361dbb4225ff5b42f391b125c425283cda60e76b4aebf98a8f994a58b19a2db7781b458804fea58a3ef11ea06ab18f22ecea181b93764fa1c46e3b2bb323a8d2ad1e91c5038dd512b7df5c2f0b1c3885c3f83dfedd6254daa89f4ec86601b167176d725edf64d26254031ef61e778327174d3a62b411acae3f07a3360f20512003bec5f685e6af92bb02e523840f78f2ebfd06ccf2acdb191c0df5e1e01e9e1332b69bc148506255169e83b33be6c50717d3fff335f847af5834780c50647c752282d3102760b4752279a48735caa0373a6d238f1a2dd3dd0802e6f283002b516170f9d4c464751cc928871bbbfceafbcda902593616e0b3b42a4f1fd8dc008c3e88bc593015bb7c8dc81fc3e30c36d5c994f2a0e779c59eccfd466c9e11bc85a6944cc045788cd2fb85fcecdeda5fb3940f33be6eb64174777c2eefb969f620a3813a388b5422cec23a0ddc3f7028a35ca22bb2797549799cc9587ed880098d3b7bcb4a301e2c250151f9a4613e01e5a4fdecbd1b6366b63c55dd6f63b74f5a167737c9379dffb28a54e4643abc665708ea444fa6bb3aeb5b160fb7dfd32dd1a231ea9b2e433dd4b56fe09b74aa3efa3ebc6b0b1391fb2df3b22a142fa6010d7521de10a9f1aaa8dfccdc594570afb522f69fb1335550e8fb4e831e2ee292509255741ed7d53b3f1b0be0af1972925d462bfd8cdf4af9a9f127e2d77c4d09039a961eac3a759dc6ba75af18171ee090e680373efeb18fa3edd343cd839dac11fc56a9b85e636312083a18a8bf17edf18906b6cb4736ffe7d04ffaa1cf9564b4a39dd3d5179df695dc162d0878d47ccc691612b826f6959ebb4243b249290e3cff2749e409e98abd9d00402aca2979ac00bcd96c17f0564137295727e9f4a6905f012220e9c80116d912c58cda8145f414060ee952c157dbf441fe3571c89304e03b7cf38d66236efb9026122d3e230c461ac19e4cbb7a60ae35defca02264788a67b71f5e752027e8e2dc61606f1e63c7f70807e448a19e9d7f37461841e2ad7f4e23bad9045c1f5e78f92ab23586d1da8b42a1c920d753e51fe315b50f0b9f40d58de72c39ed7acf9f280d2bcd52e66c29ca767513ca7812980599e0986126567b9b1e8e9a9c4c5aa26fe188da550948af0d62d1c92c6e916f298fa00b03648014ebfd9a6c72569bf3dc34a82fc5762aa9063e304c6e6f0468fbf80c0726db95b4ed5a99b694ab6e767a95b9e44a94d74cca0e4150a4ea68336b066c5589b2f0292ac62b47ac5554e5ee727f1c9f025cfe94ecd2e7727a31cb653ccf8cc8f9e4d2d05a62f6f823e4fc799647e458c3bbc8c58388ebed556e82e71236986d343c56a7babb03d4e935a3b3f53f0d011408c17dec158ea0993078156473d7ba368e9ccda8a97e8c9c78a1eb7e85e411f31ef83d5bc6af284aaaef1fb998d69f3e9faed9cfb9820240e10654269d61bd21bba2d4541eaaaf05e888606b9d2f272e2bb088e287d8314c9112c30744fcb05f6d968e0c66ca6369a9e61b27f0bd7f17285e116dcf697333ff61ef0bbc52b9897d521f0d379b5305b0ae01d930523b4c9dcd0ab60f747e4b5ee13c8aa1e849d9eafdccb6a758faa91aa70b8cc7d558b34e1b18e3a2acb87259ef89fb81ff0f338158214ecf3990cb63f95607b8467276b0ed0157257c5b1987193901731fc9ee094b68806ed83beb5f42134bd6e258961c0c97d810a20ef492d2858049789be9d370d5ca4b2821adc82da8fc82674be8b178b186cbdc60f0b47ba4c2d328c270a248fe916faad0f7daea0e26ceaeaf5f92dc4ad906ad269195b5f11b524a02783a43df5f8d673964d6064b4146aec7d0cfeb216ee9c7fa1b9ee191b38b76eba1fb1c07861efa9c27cb007151e695f7fea119af10567fc31590cf3788902427996bf4b46f9700c5ce9c96686bae4b0c0953cf0cce6844d2441782ba485b439f89a62fed7da2920682876cf5f0b9edc7cf74b4360421d31f6a76b3e03e5734e7a4edd403bfe53a20a9cc10e436a2cd9187fad00c7b6022110d2042d1be7f2062b418efe6be18abaab882c13c7a1c254f2bcc9b92b9eb4aac11962d4413b9d8ceec292972269c16bc83b17b122200881d087523164f8959d4c2406d9622c99f473f54a685c3c4218ef4a524ee580659bdb0f2a38b350e11007deb5adda022f2c96d0a14f6734412bd5b8ad02b7f7f57fd1588a12abfa556d9ae17d4f1cf280b1d25bb6fce638f5fce39c718446706f48f6a677f7b975897ace49e5b1b8ff62c24b8f098341bdd326eea65b975047ccb8996eaa9d79ee885946a29d59dcd615b02078930920f96a59f0bdfa29591a1dd3533c5d579e922e2d5f21e6ce3c07a38fd30b375aedc7bb0375ad8d59d8118334da2397a37d178589b3487eecce6a13ba0f95f1793d7ea0dd4f08e6c4aa6bba5cfc0a0f24f1207a79bedea626be0ff07c436030437e767e225179923548fb6037b2303026bcc55a4be1b743820b560d3aae772d79430dba0523baafc3f400c19249ba07d1e73844024969fe8e0be2dc07eace13ac27fa6330fb8b22c48f60a7dc97842bcef60a28f8e1b2cfdc1f37d48f930c076cdf3853c42adf8c618efba08ab2110b6ddee1e64c3af846de4679e6756109d080ab04242333c9977371981f7b497ed9ee3b7e1f03cc1a5f8fa00531c894d9d05d600b1a874040b62a1c21f0c58bc442fede42e3b9229ce113ee66e6038f06d7c890f93f9e82e6d1c8c612e5979f123a48425a2d2cda0db0d3f1d1f67e19ba90a66a28bb6234903e18d78e01a898c1c3208f2b3b7a2b9e3f0631065030ed177bc16b913fe767cc887a118aa1f68c25653b3994474ce3767277b84768dfb6f080ef8d7d6a708fd43350115561ed5f32c5a9961e500074c3ec618a1e8ea3aa20aee77de8409beca08b77a4da347ddd1a35612a9a20694929ccdc12a0d1dbf4743804089de484965a10f6859ba3615b649c236ef2f9afa5b139950bd4417920931e35875e6749853691e4b894ca69d07d4388669ab1031bf87c00a0aada500cf8afd41c6d434567ee4a5550a03687c08bd5484fd20d9d3e6f869894c5f22dae6827ab1a2a473535445635795f254ca0b47ef8ed62e3a6fe2fb036dbefb643c246ce6f8d5cfae60ff88c2b234b94c937d9e44bdc54dde1ffd2a5c2e257f9ed8d3ec7f33249010cd2f713c5e9b210ac3919b615bb6f5c0ed5599b31aea1b3222f99c146b23a8a7a61e3862756a9728aab057881692b79f5f3d23a3e38640138f636eeeae6768fab84a74304679a4b1944500d1279c4dfc24232673315414b21fd2bf4469eb69750120684a3bd6b6bb1ff3998f0f123e6b5765dc6f990059b3d2bfe16114e9c86471c77d2a1ae647296ca8e89b5475e8adb5807f050a9417d499f8b0aa5ad79eee82e1567444d1d7c3c36c7f5b37df8b1ccee7447c35eef4a63ec21bb47b951fc0b5a044353d59268420ffbc21778ec4f9d38f3886c10504062f677775df20a8cf9113fde3c6c808d6c1b92cd18f7fb2189e9e34f4902aa7ff7b9ff5b01082df37354cf437af35dab24696aa299fd50488c5648847fd64228c12878134d48fcd4ddcdf4ca04ed1ba14d2a16dbf817b7faf0d4982957cb938deb59c37e9e5c57f9086f065332ce01e2d8af3bf235540c3c78d45a2fac502d8284f70316820b3b2e7ca7b22020eb6097bbb299b4f76fdb257612ef1567356c40f69c99b426cbf1245f716825fe1db97ebe92951028eb941ec288dbe2495ccd96faddcd4840c6c51adaa0bd666bbbc56515a74a8071838bc7709c3e3363ce3a87c5a7f1fbe863af9ae32dbd95635f43c9752844542a5e825526a098ca5edc60b0ffe2cb4325787d638f628ab80ede30ea5bffb29819755b8be6da7747dcec37a7b5868bdba16850299429c30300c8288f5ba58773ed0c8a56da1eb3d9178ec123e057fa3bd0df0e1ade3718b6a5b6cf8a6946f63acee2ed2242bdc73bba1119c6c7f0bc7f5027b8594a5aa374bc2e8b08ec163fdd54043a559fc8825f8208ca7ec701795a2244c2c4ff5b1719bf7592ab07848f1517a6414108e835a1ddd978011b071d32318e17cdaaf11d773e6170c18e1d7b89e9298a3d4a92d8a8d2dbc08c7f6e0367cfa5afafcbc132fb6eef5643a89ccc2f5b0216885e66a986412f93af5abadfd8530e78f9fe47cd3d0c32145b31b714054134aea640ed35ae711a77c081e6874cccdec8ef131c7cfe012c57bbbec7634c30008cb7bcce391061e5c18f67f99c9f9b78e71170f4344ff7733b4d9af3b8232f3323dba629453aab220b9f43831833fc209ce7290240af0dee3160fdfd565f0a7e219f6cf9641ead7a7a88748c6945a110fbad6e4a519023887e91a9a57cb2cbf7f7ffc463e814fc7bfeda84e68140c4a7914b4fb280262dc32b4e7db3908697ccbd5b4983350adafaf09ef44215f204798f2babb3981399a794333b7a0f227bfce5cf7487f56cc5c1a11a43c2ffeffce7977f96a50c629b5c85a05a07ee79b12d064b6185beaa947a082fc55553c9d3ee82eb6e6da4ff582960de11ab389d770393a4a06f95d034e1d1f780fdb2dc50dc774eaeef94b89d48637c6b38ddd43b3bdb10504917add994b9f8875861df5200f00cf651e7c4f3a7b45690a7dacdea2003cfa775cbab9720aba02ed92d707c08d16849289f3ad8c7eb4bb2b88415919a2426f0507ae8d33a00c1b5dcba1de8406177b57ce7556e57880c03295b959771bcaa4779f12b1f891f20bed014b0852b331db07377fedf05fe86e334725b13e4e15073ab3436fefa5f6362c990186780475a00315ac1c2c0ebcfc4c7670908491c4ab90da271c1f229a9ba10fd55374376f5268253a00eb2b71b187c78cab69f7a72942fbd10a5acd191166d6b5676cf92edbeef386d893bcdbeb3c49b8c0a1e4e3bb74b7717532bdd3b05881c1de0e57d02d96c2ab8bded85a33a2b4908be01a28add8773e49f4395589cd165f231affcfa9c7132b2235e5c12dd8452d7151878d95f14006ebc41c5f0009108dd131d6b41773902e8800ae95e9818bd4abbdb0be1a18b4b1875ccbe16ee4cfb45cbbc9e74ddc48ec0af07a017060711d2e05629a1f5b21a3c80cb2cd26678a44390ff134cf138ba379ed26ced1fbfa1d77114d7f61ac75cc3f86574a6f0eb1ded2ebbeacb8a702120a373f22d130bb5c588ddb8c4ed1faaa55ef0ad660d851f34beba7a611bcd020fd6ad3e817d65206304ed865e5646a83cf006df360c5bbdab6d363dc588b00af6da0e418656292a702b168c8fb66a67d3cfd5e1411e3674e7997de4bee896c4febc4c02c3122e6709731927aa262338729fe5d64b792bcbdb2380696664fb2fc4bcaf0aa0d25708bf68eb518d0bf54cd0f5d0500a3dbc58f9c67ce9f0c7dd97619b9b16c305325291e772778b650be0adbe3fb6e228957f9dc079afb396682d49ece00a17f250796b4b2e82948b64e4fdf1ab09292db6bf22dae090da5fbde313fbf7931022e87177441a3fab27fd09a2de0f39746d69bca62f3d69b1332378a7dc1d481248db9fec748771641db3b02e8ac184f899a1d4fdee57f0d42fee3191e952233c6f36c116e47959b7dfbec4290aca6b7313014b423fee3564d5599adf028add4f2ec23ab6f7f0002b49305e783a0907f7674a6d1ef1a2e0425d6429febf333d7f81198318ace03677ff9b8f01dc56baf2164fe5320a5e5d6ff3a1655cc4b5eff4c6a561392e325bc30a2fe12e24877c5272dfe30e3eb5104852e206f94f18e8d9978971e251afaa8d82f401346d2ffd6b0063c17279a9478de1ac80088f6c8461841914ca420d1db49a136860fe5c37680f12100dbbdd3ac187a10d8f7c626cdb90ed1e3b0214ba3b3cfbef9e6b8841f11a40af1c49b369f80e39053cb6ca9f8ac00b78d37326235f90e923786cfe5755673e86afcccc256759024e979e65d2f8b86f1bfa460ff58f1c2a5ab617551abd2f230b71d64fa25b66d5de560b066e56b03966b0fd5ecaaa182bd7666626ce5a7578324812de447dc3cc21722ef6236b3c2aa3dde4ef050788d4e612162a9aff9f1a26b2ad72d16f5806949e4aced93724c5c19e5842ff451d9e6cff0dc649feb0d7e0536ac4830ae4f6e2ad4f30c9070023788089be0c7ba57d61ba8e633e6b8545efa648eed5c68e23ffa42cf615145f9b9f169861d3b44dfafb5c673f6895895c99bc9f041d3f39c411a37811fddb31f66556869bb5bac559041655267d64d117ec7c67ee7b3c23501138c4ea3bca0c8bd1ba7874cccf14bada28467e195c6af3b94a3b0f63ff35d57df6f47e6923c3ceca22a55e23d968e8131ab341264b653edacb14bd05b8e9a81638ccb7c10ed13fe3ded319cbe30953276a26ce39cf25637bfb6f343392721978c1619d8b091f8f41ddba9ef0dfce89f4504c19e1b5afed74f550a4604aa72fa2698272c5a1e3fe664b116e96e5b66ab68e80a5d999d966da9a95401e6e60a945e3be1d8e7917cd7f268b1656ed3732df66af9f15aa7e919ddf1766ce6a7b92d646b484b5af3dfcd3b4b00991888830575cd8bd10c6aa5158f612c47b3a44d56b4869383b5fa3298032757aaa008fe44985e665b5350b2f1c0b2fe1d6ebcbd32d56ab7da6ef3c3e9836eeeab024e436aebe7de024616f47ca461d9bd5303409dd121260363469dd0e551aa6313d95fb5f184a4a597442d4252382feb61cf00ac213e16c9fe82f91c3e1b26956683ffd94739b1d50746bba1a52d3e24b3a6b09ea99ff9e7a513ba17aa757d3fb31799dbd31d3a3ff5652807e7ec4d8bf01d2fed0d04be50a80384acc27d2a6a51fd81b6cf411b51246e463e27a7c4159d29599821f4258cf99fd2fd3df02922e0a4628ca9c1020f4b11d22bbeafba7001510965e0fd7d7945610c0b1f36c1139952f2d6642a3e029ef93b95f846b0c66f67718659b29973b45b9a6cfd3dd668250600aa631634c388b3635b29240e855f50be53b1ea64becda58f5838a25a12d25f3c512cb6568aa96922d7fb23083c6f73cf1a438d5e259ac0a4b12ccd42b10b4057d214944eb634be190f6ea805545d8fb4946c6175f2abd12a0e9e8059157c3de3f0ef0ebb7609424d6de381ef07209d2b1cda3d28969ee3a9972d9dcb4bb867fb991430ffee56851313f32693421d147fa701dbc3322d6c6b426a5942d657a877062af105d9f50144261f8d2e68f946ef9372b80e3bad07d221a83ee561b6f81ad7430bf3cab098e9554317749627b43a1786f6c63e600403075c27eab4a713901927d54e456ef07536630ec91be4b5cc86d2524103abfc526d93a6d95ad0dca4bc35fe0177c9de11379c804544efb61e0d1529ec9fbba2c9f290ec5bb659d027cdf33a5a2d924991ac521f9d2f177bc963d276c6675bd82ccc58fdc7a53ab1cbfac9431a9a81583f8232266ff2a09c031fdf092378e509f158d1c40436cd919d34cf94ef2aef96009d883ad51a0f90b3a90e8922f010b7047b93f50b09dd10da0d3885e9d755981724bb58947219b80b5d140f70cb38e8ba35a76c7cd771c504fa9cd02a09d3e1971091cb3e096d5deb23e5eebb994ed1309dae58cea4a25f5bce21c54f1fed030486089b19c991a8b82fb1e89aa1c0ba63bcbc015061fa454e60ebf504f752e93e611feb5aeee58863f178cdea1813f940096c765afdc01b94d4e1333bfe913190473e09af0e3ac65ac7247376073cdf45983c6689627978d46dc0cdb603ad90505eff6d98c3e9e287b030c4690388c9130d1586a965b0560e814bb167da97a9b9da62b9a13bc6791e1f1ccf7ae2f5136a9987de124a9dba93327c3051bb028ee20ab759af1147b672aac6de0ca73cc0b0df4def6599b15c02bcce87efa3cf01efcd83a6d60c278e356612f26a96e42b8127d1becd981335e97479e21794a993060f287db323073b333fea619a8d265183828c86aa0c07d8c8aeb366c47a966ae298a72bab39ce1b82fd26474f9113095f6ba31ab386fa5d9eeae22e0f5a89d82d539265b1171ec49b185fee6c4567e5961ce02f8da6cebacf83eb3098d800632dbbbda9db6c5a2b935e36b1f55fcd1c6ea923eb8298726811b5527caca28f8f85e46284b38668cb2c7509a55c89cc3a566edcf32c34f9a482094ba4571fa880e52a61ecb831b1c01caf795bf63fe7729ab6858c59dca32d446f49f6e8ff9cd30abf10f5d0494b4fec971c3ff3458fa0467def54a96527c2dabc38222bc262f478d0402baf384a8b51b0191630b1bb4cd1b57ff26efa152ceaf2b47b4d7930489e6feca89840f79c399da294ad727a8867224b139d76127c40874ed1c0af1f3bfd945718909f4925c3a92b4d2b9b99e4fa34e591e7b99b9f982a57bc572a64bbb2160e8d68c4280dd6445f396f10eb79f20746eaa3449b3648a939029b45761679c6afa193a9db543372991d991319c6f0136226d623eeacfd36bebc00ce5cc717b9a7cbab1bcfed35dd49cb59349359ac43e93024d6b085af1f5a1e36d040038a49326685410dc3450a00ffc8cf1fd66aecb7338d179fb7517a2d4bb728a70c488cee0dc787df8979f0dbb317b2b160e5ca4435602a56ccfd80355152715c9402206506d9a3bfdb0da145573ff8df7fedcba3369564df107810e40c594d14f5facedf5139c5ec3b5a0f81215f9f5da83eedf160c7a7f3b18c2f405767cb6fc5cbdde887285ef2d8fb2e540db411306c01c634c3703d9ab6c3b1ae93ffa32fb896c134010b4f361d82a107d5735ce18d9a3666c8ddf70dfdba32752886ca5d07d379eaf215c252a99a8663da8ad75729168d0ca5a2406ab9c0e0dcc06aa78097a1d38d773725ddf7732808fa321e0fe94242b25449a78a39d8cf219fe596aa073bb40710b25ffe29f616da098b39a5b7535640d711f4438251aa51d32e36c6bb309468a65289b88dadfc637676c8904ec5dd92297423c90dc263d60926f85f261b52ac0adfe94d982bc767b69388a525cce22620cc1f77700688cb1328a368fd4944ae8f0cfaa30734662abe404464ff1431d489852baa8d470cfc36828033be3bca1ef2b401e67ef65e07e651a8709986378d26e4102aa7e9ba341db1c0f7f48c9bf9c06c75207e106515fc57c907b8c5bb7479ac4ae3ec1ac489ef5ae47cac6429aa1b2b04a90828d96bccf50927aab83ea64df57ce0eb271167266c93805aeac0a0da7db13c0d45129a93d1d527059124a90cbd9fa234042108e461f9f9a4fe1f5aa32ef7fd528a36cf7f3f903c245e7cfd84899e5aba6f219d74cc5f98047af256360f79cba0af510a3d7c4fdae96d4216b211e4679291d11061d1a3cd8eaf2c06ec63af24eca1df86b358ae411ae6d55b98e70400788812a628094ad90a2d404a17d96ae3a8a318c1dd8fa27517698fe4e6210187bc9a500014d72f2c29ba02734b2c1b40996f4bda8e19f5a2c39b8a7b30a5b810388b348f3917fb677c7bf14fce3ca29aa532f58bb5b00e39f7ea68bd8c41d1a3199ed77a19579aec309b391e8488ac50d28c5c776a0a79b0bb858b1ca6e8098ce7ea8a5a4f1c31216aea49866adc1c05dc8e07fa6b04f36afeb022c6f8647051f16dedd358502d64f84a8f56bfe9418dd1fa0d6ddbaa9dbe436f3dfedfe7b37bf5e05db6591fbf7b746f607fe2f056f0b8ed86210e8da0165ac19886369605decc0234d4e3ae7a3f71ef262710bf3c68dd90805d11f209c62de18c6c76bd4f67b38cf36377816571398746110161947329c36cc9e9c2865218ee9a6b3e41ca77dcd63fe9c468fde6c2bffd5819415543824dc0370ce65f05de8de89b9ea58d8cef6234c0cf0b7f7c44e3aa547f537caf01842fbe623f1e46ae8d31a83b8cb59c447d01b0422fc5cbc6eacb4e13cedf6247090370d8beb65a78dc384508ab71a6f6af728f2fc3faf6af862cc38d3d3195832dd4dc805e21aeadebafc5f3844d5ddbd602bb9fd964bf0b80d55b9fbe62b10a8a4d7206c9dc86d61d8512803870f6b1899f5654706899a53fb97bfccb38ae6ac9676aa134696fdfc6e92f3b06f0f22d12db6ae8a8053a3523e0b848ededd3c398caa6460d8d63d60a0bf6ed89ab1e78ff840cde76fefa3e42af515e5d0af7579576c895d234152dd787cbd578d83e9b06ae49f28cd0783285b86de33525ec33529d313b6137f7a9babe9776024bee62a3d8ce0db4c5288a390859106da92fe5667804b1989edacb04b77bcddfe1dc12a009a1f0352f06427bdca14c5b80641997e5278658745c18da4db5f4e792b6d4a3ea761fe631e8cf40a734f077989f21e109d4fa591be1784215faaef8a4f9bd2964d211329b132300e1fa9192f4c4c07a4aa7878f9d59fcbb0c56e333a2f184b3708ff73b063f92e22be540cb19954cab86cbd762ef00c60844d2dc8f7889c902606d3f518e155158a779898c6917235f0356d60d8ba5cb95c909dde7e7278fdee3d8d2104fcd56f0355a1201fa0d2c43c2e655bef89b7683647fc752b10e1614f468de09b4eea9d4e2914f284a83ac454d2fd95e43d9fc288fb49a1008177c1bdbaef0929d14a600b15a58c2053b030b8af6a1d3a504e0826162c75177adb7129296a7a59ed2ec6d1d3400d069816bc5ecc9194d73076384a6a2dda172be63932774af4b9690de763a2362fee1f3ddbd6e1a3cc7a687e151353315b617fc838306694561dbc3b5e7d54dfb2a521f52e922ad24a8e758196ddb066c860c6edb2597d5a742977e0bac17a0eb6d3667c8ab130b453834da3cde390c47dda9ebb7ed01318d7ee88cb66016ef8ca8c0ec8caad0361030e68907c7650dd70d03b364d4e55b328a500db7c6528c4a0184de69dd3c500c2a0e2cc82341ff29116016b1e39d2913e735ed36f11e1d15315b16564103f92b2991dc0d16f3c2298c3793cad2b6ba1abf817db8202a4b26adaad28e3780980eab521d737c3cfd468f8c2c506f26aeeba7583e608213b9f15d3e2cc66c19dc2113e276bb2aae01c007924fb3b903e8924cc13da636a4c5f09cb4f422de7742acfb0fd4fa0d5ce7d44721afbf5f4cb38bcff0e21ef942575e5bf9997230b4d7230c5ae1fedd9a0bef01f670aa4e2ef73592d93c7bf1de0b57ca784cb0ac46e3b1adb12c283d30e4e7714fe4ccc0ca77c316ad6508bb1bc72869c733dcb2727d4829087925588aa5bb7e184406d648ccd52fb1f1f129f56189769757e717c2498515367dccf7b26a025d4ee98b0d491bece1c6b108e1def6b459dc0a896e8a0b956b13f1d01cc4628e9a7150a9df1b2dd7e11aa6b858af8666dd652b8cb2c163aada7d18c090692288c53172b79cb38183df291d08ac097bbdc66a97011f97fa97c5a0b430aac4efdca0c5a67259fb0fbafce89db3921ac9d1500d474ebdc51da43eae27e22e1e677d43b1e8eaf8d36d8b200bd1a66771ed06498a99876c5d5a4a44e3d254f85c4c160cf684faa4921441ec11d0e5938e630d6d4fc7b95e9ab29ebe8e33152481e03f44f56b618cbdffa31e3f7bc4427c79827966a78308a508504c4fb1b944368d56d3fb029050c1ca62664320e3c3f7dfd4deaa01cc2e1a16b1241cef7d1e305095f5369e49f33db9920ad44f748ea55288c2dd2a48621bcf1aba91a45210976ffb28884f10805aefbe04faf9824089a72ae03be20f7afaebbce398a5035fb0d4349d0f1707b1460b9848ae091884e56f1b9308efbc7e9ad8f8747f441f0594437e02e5fc16b9074f283db7ec693402c206482cd6581adf7264878f93f83e10491b165d1a02d114c747f52eca59c3e3ddc899189231d92613985a67b551db8769d24a4af0f7f3f64eadac35a0bece2d5e297a8f76d10f321917059f29a33889647e429e5c495dded163379434e52e30a14b726feabcc94d33dd4265e89bdca3a3fa04ebdb339dd20dea8835b3ad1ed59d4fb081860ce75aa78388a97f86308ef9fff37acacaa8b205047844e27f6281cd1bc55dc744f48349652fec45a6fee57b01e78cc290534bc010fb7fddeeeb847a532cacfa5bfaee0277fc714799d7e42740fa7064f39f8b91fd8b7d6ebe41242e90e6a6500ececc9df707b776b975726fbbd15e5928889b5dbb7ed34fe72415c3df626cf6d51a7249d4bdfe856fe8ebf2ba9070715b8bc05dc268cddcf1026ad8eea5a26e4670cc5c496a84dce0713cedb6118e4ee81dab6ddd40c406975cd7ae667530b52633c82fbca47dc366c96259f5d9c604c29952b93edd3451b26855014d1fc93eb729c980968575a0af3ed90eab057efcecbb47d1d96dc85823aead94eb7edd4d9993cc14e872b2bc558e056eab68e25e7fb2e9f614b33757bc508e8e154e78a7af0b87dd7f12cb57e0af30e4801b4e36ae6a4eba0ccfd9d976af0b3b7ecf303b50d5fed950768335ffb428497f2b6862425bf837dac164a916dfe6eab96ccb73de591ec495ec77c073cdb7f137aa91b3ac2e2ed40c5bbfc4356464046e91918ce98b60d544324e44ec4cfb0f2417d8a5d63d017bf771a49e263baf4e60bf106a9789c3fd36087b4c8a01ed297a434a7cab2922770a33a1068561f4468ec89e2cf7b14625ea7460b2956b82bd333df5e2e4eadc059fe864ae88f9a7e3d9951a9b4c4d19234b4659206bf933482e494f01b140ffbce946bbc2c6c6b5f81a28c5e784b3b1c44510741c0ba5b42c171fc44671088c9d36d105912128f7b7d22fbe62bebed229223b74bf5a197c9f10296de9cc839407d7b0fa37a60198a135a6209d3da48c0d1ecf0a9be8524af7e81d6d67e1ee02e26787dbd9eea9aef41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
