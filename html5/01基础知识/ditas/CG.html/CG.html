<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"044b526448ca35876e0681346ce20b000ec07c1ebb03bcb9e01db36710c2993684d6f97070ee08ebd89fe9571ceb84eddbc1f5ed5befb3e713502fd0febb06071034396cd70692e47866e9e72f8fabd2f718ec7729bc3531744307a7c19887529e42a87466bcdfce339a183d564ca8dc5210d4ca25053129bcb9ae67d1cbba2c1a977b09a19556df0416e06568b05eb829e7605f4b96721e3056f89149c09912397b0b69eb1b321ab58f4d056e28ca8c8e1c6844e7b24faaf0cdce34e1d5d8d7b9364dbdf94c394b6c93acbb0d6a06971ee94261533886307b3f723ae8be3da3e5c9bd050d2bcdb195e9149177f87c1a6bb3c7121ba2a601ae857548d7e30d97c0e1957946cc82ead2f3b096b5ba476a28fd7630e44863a9a098a5a54bce812ba8b8ad18b3815d69f65200d585fc591274d4dc99974273e6dfeaab47026c756bd32e9115e8506faabe4c37edbf3b58662564ad405efc238ad45f9bc9a44fe75470863d4cc41e6a8f453b136fc620862c90ba28e292ba362e2c53acea79b64acd1a93fe0f72f9828fa1eb88c46a11f64ce2f5960c915b42d8dbffbf5857a70844b4f476e76204abfb8bca7bfc61c8231c5c4cbba0fc96201005a4cd73306e8d9b34a33046b132f4d55ca95ee897cf7816154463842913cff723c5c5e00508079fff0b007c0b724de90296561e6f867f3cd238feed3263039bdce088b627950ecd7de258e62341f91b8231254ffae0075897186349fddb5f8e5bd71f36d88a1caccbf63be8db8980fe61441d3e558b009982fd66b2d6f4046fd282a889d4f70b225aaabf1751f14aa0aae02a3d7961b90ccac2903544269b008a0103d03699545399ee013362eef27f621c667ac3ada950de15dec41e1c66ce0b3c5a78d208e52a5c873661d18f2964979a67f62568009aeda112a3e5686de5374ef99fcc427028f7698bd676a0af614455cb4fdde3528c36da2161e9658b35aacee601726175b136a592519ab830151955c1a4ae87c8b04df5a943d430cddf3b4a10474ac2dea13885ee24da6105b0a3c90c7b74b123085049e365e2e3a7603136bea118df6a64043e9a3a339ef264573cda76c5a627fb3cc0b921edb2b9027227dae8d09de9f7c1a5964830c8232312adc2532425baf1e1f22f3a0c65ceb2dbeb0201f7c3f29df55b56f5e64d16fb85e644e09e077b00743aec18a916b8fecf396703c86adcde1ed4a74cbc8fc67647367d3e754b6cf6267d95f4993f112b824e36a04408d6ac62171a9431c9577a438f8e57b6ed0af4c9c53fee609ef198f556c576fcb4826858f68753dd280fdc6226ef99071c59d495539761d300cc61c764ac4a78d8d0aaa7405c15b182a5a137c9129d91a216f1bfa045baf878bc237c9a5a83dc42b55b064c5429469bccd33fb7d3ecfb4359fbc2d07f35e0282729ab2e4b67cd4f806e878a4855be7c3fc717ef65466bed787a0217161150710c6fa25d60610f3f12868a099442cf9a7a17560738d0310409991c2257ec137682e9cbeb1b20cac49a1a342b011d947b0088e01bb7bb21f6c487cb83469be02933693c0c9d36cf931dbe03bcf4ddd1d4231196b2d0ba05999ab988946bd845e8c332f74a6f69df1d2cc96c73fb3e77ded58bb283a85fe872531c252afefe63dca121eb3a5127fa897d3d937c34117ec4e231de4703bbb04b22ac57b198f880bfa2212b3f330d6c696b1a599c068bb64ee1f3d3e81c4f05244877f32de504c300d94c010a8e4b371be03658846a83d24bc4152841510bdca7b7ae914bb210823483c50e171d5d6a2e5a8de8b0b516ef86d38dd944967e2b1a574f88a9cb0cebf9bb98f612b0db44bf5be36b666de3d244140f148a06aaa845115e852971b7091dc175b6f7c100aac2fb33c2be9023109745f7aead6bc479eab32edf411128e9c6bbe6611ba8a83c20bfc59846c2ce9da729faa2cb1d9821e44af15243ed393a4e2ab2ddb35124cfea9b6b479b411ddd98f9fc2eff31f3e94c42d0748d080e4f6883b1904c2718db356495b35da65af0d1661e0b7ce1c280b51c3652a78ee7360de30faa004e48a6305259c00ae0af3b4d72021b7bb37a0af53f2f4aef4093f776f09edd9d781a0577ba95a6c9d3c4f7bea444a6b2a089d62e3954016632d59edff8492daa31f0858f5d8051ee2ad02ada2f50bef75eb6cac42dd154447875f61cfa4f1ac761f3d5e0295b2f00b20329c667cc6e717cba4605131c2c72f5139833d59efb4cdeb8b2bcf1185510ca8f080c4098dd4c2b59ab6a66a4e64b8660c61a9fb98af1a33fe4413e830c2d32c42a5c862d4d9807e5c62a2410ed5d3d5a4bc6d087d7b3cef7432db757c00ce71d7325346f5a2c6cc58e1c15335a2d185acc3277b971a1cd9a811efbd30509df99d65c631b6d6f3cadd9019921d886806768404cfec9994bdf2cf75384efd4a52ad9b576b68cb6a4ee38817e6d39cc8785eab44767c924b6e01f4f1e50dc46ff7c2de691644efeab305f62f1fc5018b5bfe8fba3c60eb36f9818d65a72d424995ae393da62b1dac44d04730baa29655d861586a9c45383f7543150b42f7fed59a63d42ab3d5f0bffe42d324f44aed7561c43d204d624ca401193f7d404111afce4866e00385a10e312a0677100cd2d7a3607214bd91d282e11772a48200ddeb0d8aa649961e0cad0d84e488c303705520068d8c26515fb75fe2eb9ebebb56cea83f18f96ba4b7d76e75c1ed12d989cbba8f9df0a163fa349f97477f5a6528363f60ef5ff0e011d7f8f41c9b7a33ed663b3ede6c543f815f4ae73ed8ac46cd031a4d8382b11e36069aafcc549210990326d2fbd839cacb55c9c2e0eecc5e133ceebe1ec11119a4c00e20eb16a499703597adf9990ce703c0a21a25de3f17cb225506563622424950d3032fedc2fe5630c0ca6d9d7805aaa46d427185214964844dd7d4b68d2d25dc8284083bcd8af2c555f059169372096a6fae782cf83e5786642d8eeca04845087a6216a3eaa7ec0966fe1ba7e632394aaa4b50484a38c729a1d6baa085871328c72be9515d52f930fbc011d5d14b12fe3372c45db4841dc720af7fa3a8252a549bbeef6fc29f1154a765f0f09f74b00c4d7ede6f7554040eb509262d7b61b8906fb38d12c483142557c60ddb1707edf49c32e7493071ef299ec3f2658e3e99cdc1d4a47f51b6804d6ebe9dc98a22b69e346f838f85c6792d80afe3266a28676b37fc096a607c1c0d208760514d2aadf0b4661c546e2871a0e0273c8020dab4a8e2500cf67411b7c529c33571f58bcfd0b494ad73061d9d8be597e8728320b23882b6e422f1850ce7c698587d736eae03dbfac955065c74d63e5a03d8896343084b381257e7137f7f91d3680b5137c5084274419986c73be9ea912fbffbbf8b833c4f50bfb3704df8fd4e179ba19ccea127de2b140f9d097f33c81326efd880a6809ce07b1ff425c59fd8ab6f00120f06f005b77db176e73efb517ef0918a1b7ea5fe3ae765f8ef26be3e36aea29d303eb8e580745e8dec45dae1c5af4edace3f066f8dc91e08fddac6b1d16ffa676cba1f8541eb46b982079bfc73cd7b658f175ab8408a7f1c5ea32ec312d4d309f22ddd69c0ce37d88575d7a0300199328fb642fe44f4532ebd0b415a4bb7107f892f1fa36255734bb98f145ad0ace3cd339f8ecb180328dc2b3c3960a863707aa00109752e82cf9b5af56d4768e7e440ac402ed3fd479c4972ee69df4d0e4277856edb2df31140d467c5f7cdb4a6057829210c99ec0d7ce6d887658a1bc25302627dcd385a9f47490f3fce3467456923b7cafc507c8aa3fb18567a81b49ade1088875dc276960050b1ae5fa27ba5c89026b2870839e605283d3ff4e17cfd4a2f12307f3ae3c39a1ddf9f365995d67a8c07e185bf46b2ea7a1126807bd2a3975a652060745a048cfbbc7a01d64a480b4302a2139783bd405098a0144b232f87c8715cbf4b210a853814fcd33aaae87eed1c1c05130e4c34882ee4735031163ba2ce06fbc7a653b34835fc1a0452ec2f7fce751219f63e6631197849f7cb8828aeb44fdcf84e527ba0c4aee40c98480458c8b11f48fc7b9cbf137b88353e32add4036a1edac18a71bdfda070fd2ec730fa914429f3d0f5520f06678225c16566e8d38f895689b4afd272462cf65584cf7a2bdcf96d0b90872a770ec1ccabb542782ef42803207209b0d1855a3d9dfc71580eab5cc447d59d90a860b4b5d07efeb2791b62dd51b8c7180dec209bc20002414b2e2b50875a18fab983d390c33d01364964711a219081a59fc2b1320a3d5c007ddab9113b21cbdff8ae945572fce30d9e03570d1c561c47e51a46ac7eedcf6f1e7e43bd44b86b056211f5643d71610ccb9352cd77d97585b04608245cd8a1cf32155ff7709a875d8439e84711805f267bc83a2130afb9bd8f44f420d206285bd60272c8684e2bd3f362ed32797d47bac13119c02d71f9e20b79d4b7bec0fbe4851cd4e041dc9ac4a5103157fb44b690da315e545e5c64f517505b8b4a207a4a6c5048d34b31a94cb920bd07e5cc8fdba08e953e90e0d2224b6d8bef0cf8d5216b778af835c9a4e82d83849dd355e33bb74809e12f69d110831410209fd9ac994a064d75421fa3a2ff85c7100f00f16bc1367c99b684dec5bfe0c52bf89714088f8ac6b1dcd7f721bf6353faf32c42d8f7c33f76233951bdb8101f8a74b4945f810fb1d0b20c13ce742773f2ad0a7f73f64ea996d18e066668299415120fcaec8e1cd310e9cc007b889c6918208515a4c0f55950e5bb2505628c4e54e2b87a3b503fd90cd5b2b34e7ecb5bd89da09a9cc99915e3538925e2a90a60d3a39cb56ce887aa7b0d6a5fcd7f3477fc0f035087e2d3049d56321528edfcd04e4597d59bfc6802f3328998a189bb77275958b5d73a77e1fd927d1daaab3c496bc06fed0b605c5b911e8e7c382bf46f8c0626b7e022fc4abb33cfaea850d979d24a993fd01e02569567d83628dc168c6a1cec97e48fc997213e818b8e51d62730d962de57556e60778eb40e0ddc4602ce8fdb19b8d785aac475ff5f8cd45680d2df4cee68b71cf22548995eb8891404439f9d180a35292a3ea33328eddfbdf381bcf3201858e98f1288b3e1aa680ca5e313228c942b7495cb0c86d26d3353b557c7c6ba8e4ab4989e5aa4da5dc0e9ce359291e663e9519b5ab97254dfb361aea60c48398ebc86f7fb2ee439153a3906838327e0fadafa8ada6e6829e2dcf65a9c94289a4ec5bff687c6c7f8342ed1ca67c431cc3bc5f07c74800fb71701fa46d5799217978623dbc23d7cf3a31213d4cab6146abc47d84d7eb51dc1710d6f8e88466a56e06b74c231be268bb50c63cafc5e12f854235d7b1e46f71d33e3f759747cd58e6ca150c11e94bd034a42b408b46f353d07ec1d5f5be0808479f551750ebe74ddd1d443f48c30ddb8cb042997a8a501fefe7bfe56271941e00300c6683710e5cec6e2b58d16a3fd729e28a60b4222bf6cda232a39c983c27011dc877d62eca2f5af001f6986855618e564772c7773cbbc4334f6f2c5c51c4087bf3cf5ee8ee7f9641d57fc1f51a29955b4f7fda3428d4bfe2bce5af68dab05ca23b15aa0b90c6cc519dc41b162f1c21cbde999fd23eb381d8ed759a9e11f7259baca8d45b15f02fe5b96f7c74e6c4b5983654371cd15b96490516a704b4466801ca38660ff49a3c321a3f61f421ecaee897e38bbb6a061d83e178dcb8e5c4eabddcfcd72053c37c3bf0ee2ce9f25e0519dd5aad618c95d851bce4541fb8c91c3bc677778451a50e24b60f0519515fbe98a0fa932854c87daa7923ba44e6606cedcd078b183b43821265216a2145644ba22c4c9500641539c6edb8e1d0c9ca68b88f68309e2aec35fa7ff819e8189a635feb89e9a4eed477b364c0d54497f9be486616f1e96ce45feaa2ddc8596e27180d2488195d59a8bd82ac1228143f2ea08b9df8306025df7c0c50fec48d58a495a7f3cd66eafd568e8b38642e11c60eb533d3ebe172b9ed34f25d7d4889e7a928ca256ba2c6bfa7494fbf2538f6902e05ca866568e12d202019bd6b6f79d497d8a0bee232a396e688cd142b679c2759a4ddd1cc929269095748829fa6ba7e70d9478571c4387ecc5ebd49a27f60448b9b596be1c1db490ee1675e3dd5822b363b3dd09ba5cffabe72e8944d55749791462aca1ca50964724700de1e331b680537982593e56fd968143bfe4bffa920aff9a242c37b1b2d050878082c5ff44750e8b4a7376117b952462d26da627fa741ff0490334caafa9f2ca6450d06c39cbeb93f890ee9587c373b5728125010607ac3964fcaa4a5a9a59e3ec9a49211b4cfb3490c81c68b97b0b7f634e1bafb85fde672a4ea95f14a4d09c4505a570b6aac44990838d321bdaefb4a40db414cdf7ca05137201eb5d825ee14abd2e9b99cf1f47c562017428af33d58585b29855b29773f75a0da8b1dfe0a49cfdff7c248deb63769e8072509ab57b56270b97b014e02f5c3663a78bf59f07598b07fda78f772a0e2a345118eae2cbb93ff5863f043981244c149035c99faf1d5b85adb921fdde88a34ce7f0db2f4ff349710d303e2188f45f8a3fe07c21a6cd9410478726d3ef02ca57c844beff8fe5173449fced0648c7652c3fb167d8ae58f885cd2398ee6a88ed1ddb8ce92b620f05e5ff951e84d2d1d17e1de3e4aa04eceaac89c3a8c66f57f7f3d1b7f5305548b286555d7efb670afe13d5534f4a3dc6c165aed43ca31d3d29fae76628ae58ce5bc640dae1a53d60c3e9bad3f309d62dbb24021562f882895f3658975149091d75162c7c7adca961836837057c5cd6c0b0657fb634e095541d01fb33ed198724ea4060cedda8fe4cf66a42e353d1b4dbb903bbb62576d4b6cfd31c5b84f65f385b5b2389b9da074f005e6202a164e6e347992e796a67dc125e23fbac1f6067222700de37c7b0f0df2d61c044b66fa3a9c33ab18e4445984c2a8e55c3fe81b3a92ca0086a88215805de5d6c267fe06e89c113370e811bcd5a173415204ac74ea2f512ee681b30d35da45c08fe0f076bd2378f53720716b36a587e7ee494bfc2c5a764f63131fc7cc2e0280ee5a2e68ae0c8171737266814edbec3f8d3263908f17401bdcc4d1df0a6a8112fe29ce6b04cb7da0cfe029c9322e62cdac71fbc8e8be0e0e952ff27d96aff0b726098f4fc9784b74743c7d28fccbcd6d06e28ffd3033f8934055c8c3ea41ed87a5b64bba878258a3112ae82034bd69e7d89ba8a85184c85ca791ce21ee4a631cb148d7aa006577a2044dc44d1f845ce6e3230a7c7295d302a2f544ed093fb6112cce60a609b48ee0c00142946d4f435bab1bc4fa812109cc1cf5a05dd8bf280c0d14c97ac4aa9e356e56504c637f4d1b994a6bd898e6944164565dd4d152bafffdfa76af27846cdfcee7e79cef38dd2349d6c47c71713b3ef50fd9b2f5d40da30890119624a844072230016e8e99b339b7acd384db9a6de1cc380c766fff5d05518fd0c320a6c5b56f0796f4204262d441d9d4a0a024a838a70923e8da30d33fbf291c5dc56e6a7d074d876eddd05dcc471cbbdb879a59d7fe9461c2fc8b05bb75859c407ecbcadfda070e31f8f28c0035af2f4906a008d73b84252fcaa8add3215d092272d930eeb3a3b050315de4985b4709c13c7557b35ddce0343b5a1aadb24c693bfa7f01563c4af18f89d7ada3b4cfa202595074a7077cbdc525342fbcfe2960020dc27c7d48af7663592ee8e700869f88a58defa58ccb6004033e07e5da79469ea9ae0c3f84c25f55326b94bde352c9f88aada1fd5c495720319dadffbc0bd3d93083af09cadaabdfc8516b9b4cae62b309384bfce175f152e6779f61d1fc0ed571e3091e7a058a96a6099258b9abb4b663afca3433ffcdd4a5b29cb180e2d4fea6d98c6e51f76af7f7c2992620795618c91f48418e86c40fae43298bdc0c59bac908cee27c454098db6864f1d3c90014634cfafbb2f12911d3c2fbb4c962f38451ec7a3dc13d7900e3b6b26fd5a87e1b0840e75bec980391df0ad9560338db97b3dcc0c2cd3312d13180e294994ae890356b1e8f34714a7b9165dcf6ae2a31f6f1bcfc7eb2d70aba877d0919a13a21da91cbc9b48707733b052ebce4bab67fe8afddc78d0406fdb96841230e55417ec160080ea41e9e152fa2d3cfad8de52daf93d09a5b06216b2d82893832671e6a3a9da40b59fa5ec688e6c1548397606a37062794c383beb43efb23af14fd50937e9bcb076b6a9d10ce961012810a9da55b0fa15f1627fd44a886b313571366d2fe8f5b632e8aa7b337b511c6a6e1c9161145b277852851df3ca5550e29967f2b0645199f1ec7c3ed191d78b42a7c27beba763cb2536eccbb0bec040658667d40821e8bb57a6a3c7ded01d87c6901676606aec6dca45965a0e2b397176007ad93d674e2300e102a820fe4d67d52e4427427bcc98c1704c8ca0dbe8f59265439cdad58050a8384f06574252e00c338310881e4e09c1670c6e8375fcb3a02ff401795d7aaa9b41fdaabb25a9951a836c4e7a0eed5236186260d2548a74508c854dfc4c706033791cb6515d78a757390aa0357105aa9706bf0a8e7bb2e644356a083bd73018e67de09cd1cc81cd59a4eafe3f47f041490abe7de48e15667aa2a7957536b4d8b5e6dede2bb531c255af7871ace8f78c980fa87411610d7e77a063e373956c88075367a5fd053e34c6ca03c27156720623fa1b44cad92f4a5b8eb6c872c6b8a8cfd41634053e8149f478ea4936f514843a0601c9b71ea133943c0d36601b49ab1cecb66a1f6c43a785a5ea81d6b5640a4a4d48620cf731f6ed6f5f1112756eca86d064c391984952883f384e4936dcb12b3c447422b6a770f71909bd70fbe43d83d02000d6b0f59cdf49795af80e1190327cd11788f8c325dcc5739b63a48e3abb251020e0fbc352a7e3c02f7e9d5ed12e792f7710fd5901b5f1c445393a28b38463a9b559bad38a779742a8f44809f65af408cdbd94711d4b097bbbc6f623deb8f21c26075ead17ef4ebe565e12096097ac6ecbe93e0bb13acbe23a03c600c642118a801ef49fc9b207aad7ebfeb5af5ff52ff13e985304506ca0233b75d3b8556bafb541bb7c8912e28c12e76bca2bd3c76e1e10bfbc0c7a391c1f310420ded74bc84270f350641385170d2dbb2facb029b6f713fe42c01db21b3e6e3c44429aaab875dac2fe2e2946e0f87e8fc452646653ac1ba713b607261eae10844f8bb5d4c88b813ca9fc20b7dec6b3ac7046dc82db02bb2a5c9d273795d08ae48533dd5c4bd3604770272dbfae4ba70138a28910775e3988bbcf505a406f1cd725baf3f6885686c3f33f8c254fe496ed571a230c217c514cb7ca9e76bdb694d668845793d6509c5f4d84160b223db590914214691dc03d46904a563adb57ca0de82dc882e21c4d844839defe64a689ff21b1615435ce16927371253ba45273eaeae56c14f2c0f66abb3142906a0312d4e654ec991cac12639743b8d73cda540004d7205b44cf23ac1e5d3af007fefe06abddcbd0d85767bc00e0f0e84b9914eed80303645c12541f0ed4fc519a31440fb755be7a06f7311c96ce20dcb2175820918170c2ca0d36c31c855320de8997c1a5210e36a819a9b403cd61bc36617d5368a3dc61186f588a70960e19ff7556d48e1bf2d569cef284556e203ecbc6db765f38a596af592d7a8027251735b46375e9ccac1a483e4143896d2d4e1225dfd1fe861d635f67d65e7afd5df767c50f2023542c543154745371e9906e5a5307dfa24acb0778e5074a11cfc7b7e4761839a4b99b3807c324a458f868fba7412dc8cea46615616e8d1fcd4cab2b45bd148bd9a1cca3cd9cdd538ee91186a580d9276f3961ce14980f598c4ac7338bcf7f1fe1aa7c376404a84332745ecd550af121375b90fe303ed497e43eafe29a1bb393200db3689b7e98a41f71e9728fd2f7230010e78a5d4162079a74d13d470f2b8d9c8e93dec421ae88346601f665430ee9d2cb4de26d6d245ae61479ec6eb63ae87337981e2f7b0b9bc00848700fb68438a987be7849b54640b51ceb5a90ba1a810d5bf2a4b17f809562fa813fb66df1609fe657f7c419d0218aa1c34d7a7599476cd78d9593abb4a51f5469efd1a6d2fadabd662486cfff622bfbafc42ad4a9315b5129b9c194f28f820f7c4116a67c3ce990a1bff627185fc0a99465a5ccabe566c128b45cdd844f0cb40ab7eec63e86c8a27e924fd86f6094bec44bd4203d73dc897943533dcfdf3b50654e5f8ba0251eb42be54097fa3500c0f4fa780c7ce01e1aa5a9c0db13708c80e5f4889f791dc2d964d047edaced5b6bbdd77f0fb555ed003385881ed784c9cc0c57073698fa2a48ca9f874eacdb6c517c49cb782dde9d2cd75eb9c6042c319b62b5740c3b5160570d361421d531ae6d667ee33176b768c58cd21904f8f6d50d5f1286fb5d835d4859c571c984aa670bec7a941879be902a8dda3c5eb0c7ebfb53901111da607b878488d48710aa38637855f80a8a84c455e2623a5e6b5db0ac0377e47394c047e2d29abdcaa8922c1103ebef0ed721887b10f09a5007d18e01483c953545eeb4439efe94a0b17bf874b61fa3a756f383efa24b267d678e77d7767f999a4ed746deb6d6ce2019f9f8bdfa33dc0db0c090654c9fafe6902c91859864d405c2d07a9b774cd0b5e5f12d4646dc344bbcf37c38505cbd73daebfcb05165e02d018d400da68d51d33272d606682967808c18737987d721e7f911a2f76f7e5754b56cae712638d4a5a6710148452f61aa7fd4af8dd8e27f7dbeafc92bf6f8d3e67c768a3cdc21d211f5beec97143399394c45a315a378102781a7a85972c43e4c82aeeb0096bca7cd21770408820a08018e1bc8feae6d51a17436f29ba800a9f245a109b2f829793620107d7c6652f21141007393c335de51a3dfc2f0f6056570d9f90eb24a16ffcfd86a717553c4d59632ecab4ccc94db93bfad05b8fcb1d8a7301d80b9563f48b09df963c6181c27348bf5eb2026eb581cd41365d37eab480f2818abcecfff49efc28a20c1067d1ccb01ef1c97cf631a7a6ea83d69c059d8e5f1b79f7b3fc7b5dc8806032b2d82ef9d6710cf254707517ab67dc1d3aaa3696eef6c33935f29a2470a33e5c8e1555cb34b8536b9d16de11935ab9906536e34a69bd0cf7bcb2cb8f89833ecef5b82b5d16c55f1bf5bc6da10df0a8f9cd3f829af7d6a7d8af8082c9dbec051327af9271d89a4352ab2d8c2e47004005aa5b55517a7c19588f9df7abcf1f2f5ece4d18d40dec2c0ca7831ffd17c009c4705624b415cab5f9b47ef05a28dc74979234ad17cee03a5c8561b1f02e9261d5170fade09706b117ec81eac5c360f0f440fa55b98ae1a75ece4d300d73726efb560e63267c0553abad44ee899123a6ee6e4d4866ed214b4f4fca3bb38ca9f06ff2cfb12b36bdaf52b697a53272be40c63b41372f8e73a22253d8f46bba42e5030c1413b8ea48fe36a00cfce510b097a26465be47b1bc5801feb45e9e5d76c50d95c928287b08bd52d411784fff95ac86c32933aad05fe30bf66cbbc8a00d2c1e10f9b14059dc6f60883df29e5c9c6268dbf913ac6c5cee9b4e1d2b9b67d3f0f73c3b80b892a4ed0f5765aba68120dc6c7db99cbe892c1e42e1be63a1f89529531d9c9fb56591643620d3dcd0fec290e2ed1c0d65f23e47dcd5452e0f7a2cc8245eaf45351c95f37fddb4000ad9d4e0c9aa0aee1a67099477257e4ebb0ac1f1ebf2c135cfc23acc9e97b131c30da2795f2389b966b5366a214b371e50b43261a40a118a80ea1fc7fa82265feac82ca459554d2226654dc0b381fd0849367f047e99843a53fb01d274b941a1193077dccfd17286b89210243b73a6ec33b113c1bf87594b3788c99e391fd136c72a7c2236cb5befdf12e026fdc89484257f16c0586c3dda40e1cc99214da73d69fa87528a89a5134d5eb2b449a23d15d5c7042345842c09f77ac9667fba1ab46da5e9d8f08dc77f241139cc68e7d382dcb20f176c9dedfdc0c030e19fa14e4eb66fe5809d4827458db1e7af39588e11a8f6392845473d40993f22999dc5ce873fc278b11a63c92a9c166add4398ffd659a6abb9429ba9eb903eda91e13c5db5609f9ec6470bb25c7eaf4d73ca518ae436f7c74e9e4b3854e7c5929d82f28f27070c7cd1334289555ffc8c9c1466cb7b36c883c2362af84abaf2e227c3baed7f959606b08eb4767cfaf71a1eaf4c4e1f8baf8dbc5f7b7e5d1989d82aa510a4918a121bc37c3b03ff4e83ff84c40771006976ab84821e05cce0c8e34036facd706a776b0a09799eb64538143a901b49add47521c87ca0a0725a3dd17a95d213ea944e27c3efc6b6dab50b8cb2417e9b4e2a45c494eab06276e4c4e3f045e9648eb7b5bb752dfa8ca86c2df300cbacfa3faa88a8e5b714eb39a2b44c69bac8793ae4dc4e595ed0ad675f80f44bc4f1fb664ce3ac5483950dab8da645774e1d0e724e6ffe28c6382ca408d3659f025fec847a34456553cf12ccad1fc35a985834f8bd289ce1b692c1f4be5e8592b066809010bc18071b1c0dee37a228c88023410642c83130df0d3ee24c0a79469da3e7882bb6d056c543f501bf63611a206c0ad94c6338640fc57a5cc5cdb9242977977c515848bb460f7684982c62d10267dde131adee5a64567c11692e3176bd2200dc2208ed8f64f39c42c80b8ceec56da3c3da9f88e18828fba5a5924b5959dfb934b6f13bb6b572a4ec961e597885e1fa6f7e3cb81b8558ffa29ccd8068a66c02241e3c5507dc41ab3a70a8d300460325eed57a2db0c1b0b7e45b6b32b97787ee33280d6a6f1eaed6e1565992b621dc190808a12bbe77ac740baf6493bac7f5e8087554ae76a358fff44b9b4be2a8b27a1391a45fbce3c5d4549a3fd379a33f9d4b025e345ce81f1a6ea04ec19b2b07d444a80475f8b5f82df00168ac9919e7acc46a3c7e166e18e11cd6fe4626617cc28bdde23431a5c4e4d54bf46e95457dd845a0f777106fff49738e2c3d39344c8f5fe11c49ba15dbd578b14f81817c6054baf8c26dc46b27a8b68e30a16edee810a3399f952d7b869d438f314a0b23e6bc6483d3a74f7ff23faff09a5ae0f70e59437baef1844dbced702a7776131f1702368f49853eef0f545d639dfb0e7729ea2e49dc292c65ac5246dfff64955da9abc92e9b90c4d9c0998f973570a27130a990b3166ef34d267c326928705b655a6c7b942cae3958e1cde6a4f0e0335f56d887d892ee2cdbe344e651c60a4aa1417725577cee41e864856eafc6beb40808cd29ab92c9312a9baee566621744cd17497e93bb589a4603b0bff16e8e7265b6d1426c9ce3e4e01f4413dbf7bbd67529b38a2a7950a4c98bb88023e09634a9c47a73bc6c229933470698590c8812a37abbfd428beee087e0db166bb31379bd503499c4dc09785475cfea9c24c154b6879a60737c6aa854dddc128a9ef1285ed9a210eef7fcc43cd52e7c619fe665c0a90f6488f91045c015058dde8c4160bf54c6b06bd3bebb8405c66ac50317479c5c7940f7cb326b97b79073a48ea48194adac61621bfb6c625eae38c2ec44ba382263ae85b47f8f8e31310a309a978cfb21754e79029bc7c07e7ffab885f6aefeed7f6f9d1c0c81b421f1825a918860ce8fc788f7af7c0ec4482f1d3eb4d32b31b2abd93a8fc4ed74300f362717a92282b113fc6f2860bc4fe4fc90edf43f2404a89a7af56e88840d05f6841aaf1d51283209aa63bc515761266dfc94855441df44f71bdef8e4ad495f26e87803d34717d7b488cd999d3fb4a6c5e54ea79c6d19f9491cb56b93071bbf229bb951ec75f6f358247370c84650bdcf74d0d84eb615adb7fa7ed2b3a6e78275452a1af520f4ff74f13980c3976da7a2cd8cff8ed89534af636d85794c0707283b099657d88abc9a6c23be7ee8879d25d33c33bdcfd1ce7e8d992c40c19accec4024c70b6e0f9d16fa05cdfbd7eb5d2472054bd56725d5da55dbed699e751ecc4c194ba275bf87d627800a6553a0fdc74226574546f82e539ade9c36959a83e396ee6a0ae509473df0d71001c5bd678debde55bad0b3fcafb4e16443ea0f4ef567901e371430be5c6a1620b017abaf14bebc144b6cab93bfe3ada7f18eb191dcb35c3ce2c92d4a70ab5a796762c59084a85eaca785d36aa9e502ffbef9ec695c26b495075dafa0ebc8038616f1b430816c08dc5db7ff0b21c8b257d7e4b22cd17d55a4204e7ea2aafdb456fd6bd669d0a41111ba18e7b574c201b8a1435cb46a10d33315b1bba418099f94a675c2317696db6aaf2e5995d538de71205a112ddc8b194437875663335f0a9dd51e48afa536d2de06e17d3b9ae244d16608c8e3f61836b3cedfc08f7e34871b2668e7a87e01f6cdeb3b330b3390d8dfdd848790af0670904a3381832acc3a9d975b76661f8064729c39c3bc099c4134e9684fa95ffa5f1abccb6d7d56d2a3b0a6fcae70d90db67dc01b9932c90a17a2979ca5faa2af9f74b8ba0b415bcb0e5482237c682cc82d1e9327fc988ccc90d61354d7ba83107c8354d74e158c89539f35ceb8fd2bfcf30f5dc72cfcf41e55dbe592506c5666ddc16ab20cf92ec84245617baf40a35b64b478ecdfaeadc7e4d404c4964bbf79e7072a1336937144b8f42361152962b7006ce7415fe7bd28a817bbbb2996dcf1a9bc5b3da36a7eeff9a01e125168083726a7394c7b10d64834239b070456a357d11a43e8396f84eb1b4a8b2e726ed9ea0e860a67579e58c2155003f10d44fb67c5db7696e259518674f5f14a2cc4ee359c42ee8e8203a56a1a31f84926033950cb483ac117e2f205dd8df5665c44b2a7199c6c929beed5eb809fd140b59757ce5ccd3a878106df83cca1d1b92d5f431a01664bcf0f9926c3b3e2fd48fff1136abda073e2bba74c58cda0ed10e99e98282ababc6a9ae15af34efde33c7e3f293b3c4c074af27f14e476d5ab0f208de9267b3a7deb0d6e747818da72b94977e5944191bd9438efb5e9c03183aa9bef914e8afccd5bd74afb5ec6e414f09d80e234db0148175f2fe141d4ba06ef9dd95dd54b316eeaa82655aaab491c4ded22e7c445094e18896c7e12420a2575d38934bca63ea3475b5ff39c6492e6a2e9caa390e788a509253f230a143cdadf1c6f06cc1911de42a24ca62e65127846cb02ffac50bbba33244dba3cc9495289a99f51f4f4193d16b4d2ff7c120b55a9f28b16ac660ccd8a8c3006c9ad76903eefd666e730778eadb8a2e17598c4d96ceb75eacd09fa86ad5921a5b88ed5a6f625f6f938d55b1b12ec3b9cae1580eb371b222fceaa00bcdbdf03aef6617726d6d28f66d363b44f51b6481553ff3db0ef113c456c8adfe5398087cc116c14804a0c9ab24c6c11ebc99f20c598a27c8b1096a34f6998c0365de74e9f875cd7a527bf2aaef4b258b98a653e018b0d1aaad9285c1f69e95ad71a338f83a3d01280caca7bff94fa461586888ab6442491f113c88478de96955dad6f7a2e21daa909ff4cb343ed95cbb0467dc350626fd3946abc8be2b6a3c269e1c7e8d66a835aff1731832872129f4f6a39b88007e345ac3469f2ee4997c5b5393bf71653e24b24e243a62bf9265467b8893bc3e8f945e0d1415d66b098e9650976448eb8bc754cbaea336cf9f9a573efaaf7eaba7675a7026d304f0864cc545ed62b13a547ed6541c4e8bf5c3f20ed3b32f30f040530d614fec562fd6ce23f178a66e6780b353db9f8ecb2db001f9445bafc87acc6763a680ac61d69e1a3a361279d5c68e573a738bbfff6889f07d39c7329153e630a55e37a49d0742065804db41c9f7093a2c075e2b458eaf545f7a506a4433df7915eae3671c0a0247b27d1b50c1b314884a724e6ecd7774e0578e3feb4e446c7687e8b817a583339ac516c71964ca51edea67bc46f0770b30e7a06585cb0baaac7f74d2dc38b7b6b86dd95115ee3cba4cf48230db620d4c0cc4666a949dc1a11ade67df62a1aaedde577f518cce825cf27b228e2ce6c03d3dee09c5ef6a3d8f31ab3cd83bb4fcf43907b5544c5e0239a0e1336492d4a9c6674b29442c52b03a0fb1ac92a4492308886ca721a993a03e3dc65e0488b6f0d663c8736ce3479d004e312e1c1b937376953e01bbce479efcb732692fca9a279055356edacf9e310599d5946bc852739595eb1f80a3a44cb1ee99d9cd86fb9ce90c59df29d9f2170fdbf4564c6c0b9a5cdf0e288eb2112816f239b88246b371a9799b8b2fa4d352fdf0a91dda6ec7071624711aa2b1c28441d9a65fffe41f463310207bf17b677f137ae2ee29f880e5392b7685a0e3b76bddec673f9f1f305cd6606f2abdf66c148ee5aacdbf67431bf06ec8312184cb4f35ab3bf6732afcd17d33abde8a9c9ded48480cb34da83681668859c066b42200eb6074f3716dd27ed8df1315f6005519e8ff5d4c5ed110cf7c92ef3d4de345fd75372b5bc3e19439a9a318627ffa382fc974a9df0b13fc752375045c3e49f2a803288646a19695e66ea5fbe22b2937c9f5a1ac0f6e32d97e6337a6728bb840b034eb99e78c85ff0eef01cd5a461ab42df5c869122c99ba8e6a3e0b4128dc1060d1a411ef286be849d319db182d72ee53387adce71d59a7bf113f430d8e1529ca4b98cab3ddac201548f7fbce90d78c42a2e379bfb7a610bd56f36cfb8d3e84a56834753a1a77d49638b9476e9d533b2d12a0050f816e08a20cb30446a96b167b6da350a486ebae3414ed57615cd650f8c2b464d804fde777b1c9bbecc520a522182835b3b211dfd1528491eab1370ea9d77da75380d58a21616bd1221e89ef70f014baa43149190a2b726a9afd15ad7ba0a5b09b2e7c1d982e220f1ac450942dea30b0e8cbda8b1954d826873a7a96850294df3a33569a78994e250fbaa13a5768d71d685e34d256b2e187ebf275306a95674e497deaeb1bf622c3055bf9bda92927796079fbac62ef105937673afab25d2d25223cd61ed1339e6df7b0c892e22275a1f52d0d5c7f0c8e069f114f85be86419ec2a62c3c116efebc75a84b8263f45507de9b7fb1f61d8ffa8d84c40c344959f230af61bad3a7d1eb3703a4d4496a244e950de00a9f6ba439572e87e847d74c56c457ed5c426fcccc5544020d9556452a99c64a425684a1f2d6638aedec07127cc37adb2c7cb204c8064e13bd875a9f9614f0676accf380ccd3b5c7e5434d34317172e638e4fca158f3e848d93867989d40a70ec51250be4a0b4bbd71cf111eddddd85afda97260d94dcf980c355768778","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
