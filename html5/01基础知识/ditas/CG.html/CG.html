<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c6b79a1d7197bf9218d3c0cc9aab2501431d2ecf6942641d19182074283e150725a0c137f7401cd17f85959ce3d59154f482b832976539186c5f80c406a48170860179cbbe67fa0baf7f9ca25657d95037bbef1f4aaa36fc38bc5c35515fef0caf0e83b0ed51679db2d76d7765fab13e86606b86f5c5eff063983f0af78084ffc463ae6a18dff66d0243cf23e54c2a3b687ea3ca502610a2b89e31485f7d0a6884050cc9d7e1af817cd2ebabc44bb27cdd29826e385d1c43090ba9ce1ca0e34cf3ca3a46f37fe13e97f61101e40da46d6f6c93ee1c98345f55e9e01be41f40036a2a3b55c503bcf8ae7a04ca2ad0a5ceffae01ee3a4e2363cd5b27a06c70cbb15fcecfba84be016bf395c37d94345a68b4cd206038cd02fb10b6fc2cfd7548aa73dba6922666137eefb8ae7019253855737cedd61a7d563d7efac21a59297375cb9a03d378eed86043859bb9df225cbfee209ba46861eec6ef354928b9591621248c44c917d094db4e5cccbcc3da5bf3e2f5bc261eeb5a45ffca25873f430c20112e2a10deecf3507a5455f44b2de6328b52abb59efdea2e6bad040fd361742ff62185c80f9fddbb5be8bdc88c605f116359f6adc71e1a11b598f88bac81b6479fc3e659aed97f826c6de46f1787f4a05ada09ef692b401ed3e7809cda56919c060ae4d50975bb3cfd04a230caa78c95e454f009b729a69688883c135d658ab616f3c9620d5d6b538e89f4edf41106fd2c19185e6c66789d8bd9e4b2f88c5e029cd31df58b616c185ac81a3785a5c3a0bd723200635559b8aeb3ed23c25ae11b6c59098380dd8fc4490ae5877404c8b823f0e865f4e5a6da179ad0e5327acb36843454fa6cb5c0b7682fa7564d55737abbee58a3c9d66a250f5a0e02b3f99c3fdeededb29f9404a0e3de9e39c9b903d8028ffb2c023bb89ddbf0f65d386a17ef691a20d5d83757bd8d6fc07fd6838abe169c2293839285fa2cda185cda0a62050662a9f6ada423221925c5b80f567db0989960b8dfa3328565c58d7bd6adaea754bf7277feaa90e27f49f3610b275b253f7538f11b250945eb10cf52e54103c771018d17593bb45309a0ea43de90399d10bc87fec9d3d530191a40093b07c8f5814f04560c72b10e50a43fc336d56390bfbbc7fa6590fc30ce15c413ff19f14d71b7778c773ee309246253309df459ad65016e02808947fbfa859f0810a6f324a1f22b5d86efb07b70269980a08b44b18889e4eec7570d032c3d43b030e724de3e353266c63928ed414917d011a3e863ceb18c9fc416628c0465706cb424ead03d5a52b3221e657072cb0225a10c69f9f9a739347cbc42a3ad5e2aad3e6ecb13011421c2cccc24e3f97cdd9a80f81444c1f4a432e2c627e3f51d7e147f18d5e277db1f553b6e0d1d76b1f1c59e681d26ca9a2ee4f826c3c70a45f9109e4bf88423ab92eafece01c7dc5f937cf67c56698549222e4063553de5fdafca3db8e709292a12a5bfd66e6701af2b6a3053f2d7e6a6f73a61e4a0a031bc603176a1cdfc26098bbb28d2825053acd067feb3a474bfb5343c27331b98222b60f9147418825050ea7f7b0b1f17c407e9a39dda8618792f385eee0cd8a74952551c8fa15a87ba4c67944ed87b1b20e1900462fb359208e8e092f0befb630e70995d1d8969fab7688f54ca456f2752e63d423c077d489c64ea18d80a86ed88fa84214fea73a9846a0512d453de1d537b43f9131509366478005c2d7fec2d8510db5f234ddb1b931fb528d363f1e1b5d47632014b430c75f82e2f46aa3cc2df7e2af3f64165e3689e82e17fe51bf529be77279f93c3d1f893222a93bb6989a0f9571c9d26873b617cb7872af17aca62f78bb4ecb45925f81947e1764402798cbfd14eff14b21bafbad49f52364d2f39f8e5f9e30e1153c1fbe1079ae7818e9fdd049f9fc89c3107c0364ab69369981a121b41a72089a9ba3a4912e1d993ab19fe2fb28112b983e1d301cb5b8ba11aa9fc47c72eb681bbc6f2b280c07c1657dc9676196cb8245ee978ce1bb9898c16c5b90aa645c4cdb8bb25016380572c9a7076a1a5f4d355e7cca60152d6241a5e05f0169a5d6369fbfafc1ca7cfc144e2ea9762634e338418e49799915c80c4d7ce6f246b553a8576dc377a157a1c369b267d3da36d6a00b5f37face66e98635fb9ba52042ebe7075a3b51570cf80b9651a3a2243b3e83a630df738da1a4dcc90ebe1da81e58a69a70a747ce640f260e1f5c0352b8816c26a5fd3c7b3ee97186c47ebc8400bd997d09108905f7d13939c676f27620b1c7ca00b3faa05d47edb95169adc948caf99a130c8d56d9f54d036931b6b45fa65e20e1654a7d8cf7458341566cc2980c420ab77d3068858f05c7cd01f9357575cb7b7d98719fb6253d932658f113c516ea6f17fa13760605b2535718e5a367cbcbdfecfb658eca1acea07398f76537c0aa1faba0692362d35e5bbe578ef5bbab033cbac8e283110fcb591563e08a04370f27c5f813095bd1ef006aa3407950983466bb6e435bbfd37e36837b5868efae7b9beac8196d6f1f9e5213946e6771a217f15611112dbdfd50c8344a794c3bac4351c22353cfa59423cfc36f73458ac09d01ebcff2096c9a65d4d59e7e99c065e28706d0c13ee9b2217ee12d903bd021698af32b4cdf689c49eec0a745eb923d4c71299eb155a390233fb00ebaf65eb21e04427cdd5431f60dc58698fb59ba95eea9581f09e0773901056c3d14a9ba131f156b158e3c08f1bed142e624401c1eca1a2cfa9f2dbdd38c6a543683dedcb532a5c0b823e96b1a7f7602af34854792ddf27f5f5429f356348db029351fc5b2acc2f3c89bbdf3fe0a8831f55eb09d2deda4f5614da7ba1b2a981135e7813970ccf517588b3613d3ed4736536177b4ed9d5705ff65df4f78e3f10da1c3c2e4104afbeaa3a9115f0bc499646cdd7439ec40d418c4899f42a39fa1a89fc6e1915c18d0c943da2dba3e4bea11487bc3f86fb91c2057868296a6e799946d233861add92cd7f04452bfcae56e12136c34dca63359fa63189823f9d29e0e9351a652fe5f485401fd8c462681e43dbf1640ae9ab388cf8db4b10aef3b347e2bf8ccc06027c6dbb90d033d27d4913a37ec647db81b138a7739c6aa30aa40ff8b6344aae50a088d32cd1ef705bfca3fed806491d00f634d9f9f48bbe1f32c980a1b66c3ad26a7dcaea910b8e841e7dbf534e5aa34e38ab127293d96449804ce09080dab6c47291ac1fc7fb8faaaf7a0db7e21c64ef2865164944ee3cd4889deeb0db707fa9aa079d7c411adf23e2b48d8490c3e6d6f6aaf0f6f09f402e84cfa60704ccc01e7da96b040db89f93a72b6f97dfbd0efb72c50ad3c2d3c9416754d1cd3a9f39c4c324ec71086d192ef44e563c040d3fbe2643ff307764011bf2f1daae949eb3c3d5add53e70b1ac9970faa18ba883b6981a6dfd337a5b7d677af8f288f7aa8a007e33b38fb33d7be6786ff42019b6580c3d9751c5a03e38dd04d91fa67c71cbb1946011dbac58cde7aa92a0e610269714a4e4911103707e2d49531469361101f090a982a250e41ef16809d0cbcec529c30d644af303d62de9fc713d2c47a71630d3b85154c2a5c3b29a026c6a961187a310ef88c21fce059021c115ca2c75c4ffca32b50e26352da2641762dabbf43861c5ddf798afa99c22f83eed9d6795d375a2298d7dcae7f1fa7891a19aa998ba49a77379e99211b4a91d65504cd20090c8f9b413153176e7bf0c82f265d996aa03e919c173581bf7e2b539b67e53410ad275c6808f27caf0101fb88881f783ef6951377add0a0d2cf98adc2d222c59f1c69ba72762d16ac82cf643fa3dd2394f7288de9364050b64f6320793e7e08fd682be6e732e20f7ab20739958df75da59155300fa8618da3266d64b0d47b300562404941c2447805943bcd92ff1c7312037b8c85d47a75273c058a4b6b2e9863382468eeb12b1a7783a9cd1ae4129544196d67668a2043913bed948e1990e6aef64b4e47e632573d94e340ec50313d6f9c6fe9bce75954df516c4453e139eab73ff9e2c4bff1a8384e51d987ce1de99a9a89e7d3cd4dcc71aefd0d850630f8645767d6d37eb068e1b16e6fc0d344461fcfb753a7380d37d44aa714d4b6823ca2eb5b64c0bf7c805b1cdbffe8c48fc9cb23b0e586de0372fa0f2b59f7b40bd6239108d3572aafbf0e82de6cee053e75fa99a2c8c8814f000828718ac26b54f557599f75ac5b8f40fb35be9579edc22e0a5050df8ce5516d9a738b64c6f278060f6f2aee774835f98b246f591f2a3abface4887741a6343aea8ee6503b968484139d6c939897f52da283fe047ece42facae282b3c553bed73d45765070f47536ba32b757facd7121ef75ae37d721890b2f463d2428ae2013fb52e12941b03f3abe6c0820e88011a971dc813dbed3722d453a4ea17d6e88e2610f8b7d19b00a8f90c7b4142891038272ffa869b29dfb233b6fd20205c94f3cbacc52501c09b71a2a8f721cd660e96b879aab558ef9ef06084ec335d0c92109bd82d133707e2f98ff928795f01facd8eefb25fc2c6def9f3ce85228ab5d551dea3126d2d27e2e6e62f5409b829753a893fd03d17c9813990a8e78e3a6a0d9cfda37e3ff3bf9e239e350c53ca43eb5e76b9f85b4871d6edf76158f8d3e5e49aee48f790052dfa12c09a4a7a564a2ab7d42a542469e9e3dc3644fc637f6a6d8de2e382f646e358b70bbf1aaa1fd740c96eb47bf81acc4e16da08aad61fbf848791607e05da8c160b088394d318de403739e92e56a713c476096b718ffd231df8e0dc8a3467d6c8c3da963f56ac0982d5dddbb08fb1ced5e690256121fc6b29917f1e3d837a13a98198ef5d86e88ea6ea9d24f664947c4fc52542161b905127c82351d5b8e9c2f388928a712586e5a08252539762b0c0ce7bf096d8dbf82fa2b25d4371e2e7a88a4aa02afaa3939e284db91a6546c54e88fb32ebc0cf6446610d26cf790dcc0aad4d80559f0cee621b513965a05845966d1bdfc73d7a6e9d3b2b09b8b4b9e5e5c2b9eb426783ea3487d01ef4b48b22297fdd0fe46412179d8ae23ec28a438be43ae1514e2ae9725c30f6942d93af7766bb1888bc3d57dbdb8351bb195d4c3857eb2ef797776d0acbb8cd20469354420f4a4f2b38f24b9e9514d1e78a96d4459b0084caf34d9541b780b820a10296bc7f27f54ee80f873986a66c95be80fbd9513c8cfc493bf2b07e19c8f449d76b6fa9afa4742b445b36aae8bed77cd7efd23ae0158a5c55deb70ccf960f04355dead4ec7207048132f7c1df581e29bcab1bdac9ce6a2468358b3118adb43f5b816282655af11fee5564a88543ce3fa76362cb1e491698058dfccf215f4c3c6c9421385a932e44e7d20bd6b2b719394b12c88c9f9641515f88c91d57e27506c13e19d26fb396a45c16c02bc7646aa832e1ee20e4c16e2f98c28e123d4187d8054196d3f351ff2a28de861bc02c242c70d4ec426bb28a331054278cf86631db47db98143bbd3590c3057289c25935801255759fc6c2efa7c0a12b97410493f3d61c1fc0731d24e0721fca2cbcc9adbd5e174e7254a072be92aae850996170789aab31d0146450983d6957554a778d5f3e5f4b94601413365a645962d58ead87e22eea1662a4eac7b6f9c439e11bda9b86bc82a7e8170ab0316c1740bd4f6d3b2556500b0c3483bbaba7f785f0a281503cb77736e2cad543d10282375ad314e0df7a68e8b3b9f1feca3472cc9374704b210cc5e365ac86369a6d7fc1e890284354a91a02174f92da9ff0b0824d845aee379af79e3c03c106de0c67c2bfda0cd8f8bd9dc5f9c6d7b0c1080b4a630e4c4af0586c1726c9a986c7d26af7d9603cdcd461492375ce76347718d32208562ba3330e464e3e5c0c5bfe5774a7703f4abdd7118beec32bf977f905bc92f522df65537db51a9a8b89a7b06b9c37a9e3db955c4d1aa4072acca5d3e16e771e633c38c9b8c4aec795f6e6c5aabaeac88ae3ce7a8ec996943900d7c76dc8bbb6cc83bc63786347da34b23890136a61d4e8384fada29f39fe40a9dba60158902d461654bd9e5b3b79322e08e57fd8c36fec3831a0a52d066edd819dda10f9edffdbb909cb4df9df30ff781a27a8d29eebfbff265c8ccf55b43fcef9c435b8ec15d98ab5f1561cac3613936d9fd0d6baf06adc7573870acc6e59599e7518c322ea85cea86f5e5bd0536aca313407468978e401557755999688a9c3bba79a07da2025ac2b23510760a3aa9006befe6e293de310011c8797e79c324bc2aa8e65532f780f25a16b3dea389eeb03e9de0842bbcb5fa3f9bd98469328ab58dc86482e99bd06669d73195a0508b8c12c5644871e1379930dbfc9d35f97d685f37b6d39fa370d97a740209a486db8403ba57b256dd2d649cd92b9ecb5fbd63b1c51f4f1f5a67f50bccc90aaa7bdf8c7883f896669c760d613e2c771af0aea459b957db833cd411454f35ded7b9dfbcdec635243a20a0cf2a8a711af69f12e2650c482835ee2b9c776003216168f8bcdf580b8762b62f3b78cfbfbaefe77b886e08f5b77e69796563463a8e9a87969a65fc469ea1b5d77144db705c3245b043ebff3603914cd8680609ac8f79b6df84adde944b8daeeaf533addbb8c6f31821f311afb755ef2c11db8e18ee4c4701df013affeb385f6c89fcc4e793988387f9f74972e65c0b59feb55ec93bb6734a7150002658ce7b683247ac4034f0d88750174ca30390953628f0b3749a8dad5745012cbbf19738bf8418d623cc49667dbefcedd7da27b53cf4bd56bd52fa2aa1a33df87259f18b7bf6e415dbfeec00fda47b9dd26113c3190ea2821f6371461177f86a512c503d3a580ee62d930ae90d7e13b28102e9940080eb5f9ae3a6e40fdd90ec98975aeecea56b0e264e3254a04178491db385c4cfcf68ba4f0bba07016a7f7d624da2e9fe397d7a125dce0d28fc6648d30f9a6f80aaeb98c13767799b5da385913321583b820253c1e85e58cadbc38287113bda4adf3e14728eb24274c5f7cca3bb3621b8012832c5c1cd3cdf6c3d1b6c77225c8e78956fd3bd202971a6245122996fbd98d09014f83859cd2c35b6e8b03297cd1d9de4688064912a134684ad426704aab4de6f32f8f7007b29034b09dbb46eb7537886b10a86f238aa8023db87f96043bce0d6cc0b0c72033fd5632d0f90cbc9176244baf32f7b656c3e4cf2419d1d85ec2482bdf1c2352c1c701637e6f600a7d7e31211ea51460bd16316d1607c06b674dafebe9fd64793cb6c724f4f6302e5e601ec4f0b20d1e7118fb980df795d467b8a951d81658d9c1d2ea34c3df313535261ae551ff59d175261214a1f5ad3693deb9ec5eebe17d6aca160de0afb4c65f71f89543a2957f90a142aa769e5a7ada620d3932f2e24bd396640a6aa106b8f80615d5fb270f2cf2cce513c5291fa05c689d2c9ce6f932274a4c2dfef55904a600284042910e4821c08e5164631f9c420bc74486b37bb77863e4282574f269fb130e9a3e661824e26e971c5f98bb99247013aa50646d62fe5b5305d9500fb9af6a319e7d869bd9ee0bae9b9d37f83e545ac066115a9c04c1c2af0d07130402a8853391c06e12d80c92c42d2a19ea2abe101955d72da14e203dc2ee00519a7871453f40e5244b47b756905d1079a2bfcf2368b46504ab783f23e2ef57a5b9cf4cba434f533e418df0a892c3c67f7c6dd17af3f1dfab5cdb292fd2c815aac990da7cea258d53e774d0c89770ada07910ab75876f6e1ac2382514dd358ed754233643330c7091543aa4a2c911ca179a708f26ffe9ce7babb2817a83bf7cc523abd8d01880dd7e58e3c8e2ffa3f98cf48873bfaf4a78df6372cfdf1a3b5193cebae65139c54e3cdc706c5056876755490af0045f5158568f4af47e510971cb87939c81302673f453e6ba90a27006242bd9514e7c33e7af7c8a279ba571b9b1db121c28f10f927841dd87668e7c3afc73f824d19da1c3363c2a5bb395a892fab78c4995fadedc3e2cc7e0fb37f305f2666ad19c00de775ebdf21a17e2328f31a8e4b5606249b903941a54de24bf860ecd298ee2a03411e1dd87a32caf1c62f56958db378f8b215e3d99e47394f5f083770d4ba891032c2d24866e71372de4c743ce2ed0d4ee2728d419b778622edbc406ff37095e500a468405387e64ec04555fec010d66c3ee340bf3c8f2a18adef6b380833d799d6813b485693e5b5a455ebff11849e348480a85c16c241ffbf4e1d926cbac3d220a181d8ff2f41d760124486a12e8aeb77c76813165046a5e3a102f23fb431de977da7928a2b910a20c892c1b7838532a16d1c56e2f463db39bd96beb8ed9569a59f61638374af187dc2fb533b0fb8912a6286f3ad2f95c7db09d5a8ede23dbb42a90b2148b4d75f9a57257c90ea20f5dc8ec6e5607eacf8b8991b8d4a9c76a19eb66052f2459d8cb8ae1b97068fcff764785535f9b2a7c721ff5fe38ea1b09090d119f94faeb37fbfd3e270881216a56c866a5612cd5d1636e86ba4d61937edc70370275567079ea967381b0ddec71b2456e5d4175bb696410ce0201d0818e701ae332b5c117659ad5f124764bbcf63fed2aa1e8d06ba887fd8198d5d41eeebd8708d50be785705fe8968926d488f372ae5fff294b16bcb9d20898d337cb7d9c9c92d56a3a3cb107ffda52bdb713581eb6657b20d62acd75f217cd3ad73a51b7eb02dfab5ee72be9df2c74f10aec77b23aa2f19e49dc7bc8b3e735dfe254eb135417ebe448e9563f1942e00fb480c856fe1f4a7e1d83a41dbf306f5ba7dd56c63f5c3dee23aeacf8554c5e8851910b3a3266b0353917ad44ffdb5970e7338969e767974fe299c71f5dd3580a64795715e21df1a7f7a17e0c523447657c22bbd05ea69aba4589dc88c6504fb501805e79d4852d8df013524a372c9f5078b71b92da1c19763c0388baa7212e0aefafcbe664c3ff6d03a7afed7e2fc1081d84ce1a32af62e8f94b169e139402d121864ac922255f49a548577d29436ef5769911c73736097fbe343250a3140cdd3a100c8537aefeb4a030ed8890300447183bb3db9b05ac09c4a9adf90b0869942d32bad9c47a1f175a21e5e9d6bfdec7baf43928fcb033a0daa96f6306a18d0dfb13378af0b35d39c361d0af08991e4ed9ee1e30b2d0910e0d2a0d43a209799c7e5d9e0ddf8e0d2783d66a1b9ff57457383836e9da57ecf34e39a4b2b24a11cc7724985ef18709a9f2ca312898c7fd1d8a5a00fc63755f9a0ae4844072ecb4c2134677e6360f0c8e9fc2373e5d849457979f0bc041886b5b33745efc0640ea29307a49daacf643257c15420e2b59c139b352612e685b15eba83f3f3386280f3afa87674a5a6d4e2eb4c2016025b80fec8f392043923c810f848d392eb7483d0523b33dc113684f07b5763cf52dd2b3c15afec4d52245c05ab1a979e4d2311d932db2463f7988fce15124e5214cc0fc9a35861dcb997bb0f26ba20793008f0d2f4420973d78da489e624002564818ba2e594e06508b776798aa9c493e6b1626d95ad4dfd96bd53c79462d73285c8b8dc4e6eb8d5107c9a2dfe7d679849ad5e65015d73f665b2a8cb30e52bcc3e4db0b631d1699375c8a33cbf48a804fa8c3b8e05745e7b1a45a5bb826a948b07806d1a9f912d44ade862a669c476a1fb278a739a1561231b28d44b5013a5344006f6c7bbbbfb3cddf9e5374df15df44ae97e11954ade2a0263a49cdcf39e549dc458f567e48e3aebb3f3b184944403fdc2ce4c8de221294d7cea2b00f923744ac472b835628430c96a8dcb51ad75a7f8c29d4e29d620aabc0eb0365dfa2152371a9e178c56ff12f03c6b3dd68ab4583150ecacff73ee68e5b0d3a129b46f37653ad07bbc60edeea316cb3e7534a0306d8b28303427be574d761cf13245d081f2680ea34b5941843917d46196750be771182cfa7c0a20b647bf57c78b71b56e009b16f808d5575aef2cd01c0fe37b695a06734b723fef9b299c987f5971266b053fa738d2645a24343a9f3e3a6bffeb1a3d6140129a4585805d281479b0c55b8ea0bbd0b7265e187864b209e67356d8cd58fe93f3db9f8a13b20bb83719f752d27fcff8becb17ab3ea4a3c783ee01dc9aa2919f7d7846da42509d483be3aa72b547a199e4abdcce19c177a4c7dd4c6ecc1f035a8b69d04c327cbecac060a09d1bde6bc0ce9d0c6cfc8990c375cd53eec55bd8acd661459d91437a5b1bb9a6aeb4f8f363cbbb0e791a8d2f4d0b54b75ca2362a9e1ffde84661a070403db5a8c74f25ef81d2c0e2d07e0b8ec6e48890856a8e12f2889ef79335312d98ea57e75ff77c0e160b8f633ee3be000eef85be05e557a2151a60f0d4704fde9020c0b2a61438d8b9bb77e183a8a2f155bcdbc55b5fb198f02c40c09d7b679ab79d552744a78165914bc1a5668502469b49069c1a954ac5adca462d0d327693c10d93b92612b14f41de11197e73f34fd734dc7b4026c8d5fb86b621cda61ee063af3b390370c39b30853486b28e72502b818994f7afe0fe433a4394b664cc0efd353da4f406ff262f8418abf4a0d55fa2f92e0e04575fc84edc5cf9124e97a853862c4e10fa99565f5e5e4ab345516f26e2540c4ccc177ebd987212d0c094a6bd496f188fe5c3de1e6cfb4a53913b37647c6b5138bdeb639544dc8375e23e6383b6acb152eee967217ae47edb7a9e2c84b62493059f3bd2dcbd3adf99b4d65921244803be75d7a6bb9f1981b9d4ca4ed714cc5d02d23e2f16ec745ab8601d586b02170c91aa2abaf94ccc69f08ec60c327acfefa17ed37a89e7a65803fd1dbcc63e97576320b6f5335da9b27d357135d4d0c50538ee5e9f237f2fb99372aa6bc7fd02507407c0dc3bd7f23cf105c4ab9a77111e7de8c4d99404d7c280bfeda320b6c1a4258e6a9c2314fcbfbec8a6ee55f1eae4c89cba1fe04dee7a3e3759d6e83e8366a99dca81bbeffcec76a18fba817e104b1faee21977c93eff9a3d19c4cb4988abbd2916142ae7c86195c3cd69d3c3b945050c8f1a9062e5b7d3d2cdb27ee711f9c80e91c1b520a31ea016933800f51d7313f1081d756e17a7ecb7a5daa36e52497d3a72fe1d627031290507049db7fcbfb055dbe9c8dcca4a06654f5605bdf1840bdc4867c1745d57a60f286c0f500299ee7bfec7d5d097a80737fc0615c8d8ce8a801a75be6f3d77cc80f8c9d092d8454b395a6884aa7ec8e88d0dcafb0c75a0fd392d730c90e37988cb6c9d00ab9f30bd615d6feff52e7d7cf36c73a64c05343af775ed5930599f5131699a3096998d39b939ff36c19bf547f6c1da5f7efaac4907a54df345bec62ab65cce82ad6a3a225ca1e012621e9487a60a430c5c93c5575c52097e8c83827231c9c00721944837e800f4307a55821fd986e2ea1196f84b97528528fefd949deb0dc3f447702e797f5aa87d9ff2116351c5e401ead3c45a5fa01926993638a919380e69e61060e0ca55d9f2bcadeceb3be181789c3503bd6a463c4736ee698ca0403043c27b3d44d51a8d9141acb1d9c5cfb82c2261d6f50ca102461cd5d4c39ba2d8f746d3397bbf9768e049550135f130216b64c2ab29a00db33041cad04c3e10c0b2dee8b6858d89fba95c198df3059a2270ca2327c53b46ec9080263f9778a932740301a7072a4a1d8c64e1bf7befe8b437162431a20d549a5d7b4a3fe159d74c7da7f23c825b624a03e80b64659b3291329e0df4983d176a941656968cbfdbd659eee0fdaa786ee38c92de66c65f8cede7a3f18b491554d6bf72274eee0e54187864eedc2f20e1befa700b90dd699e5d1b802381b8baa33c7e6ddc8fa738d53832e40ed0b54598896f7bab729815711a91162940265f5f667747c6925a741e05361dbcb851dcae2de95cc3336d40009d21a19fc205ae0ebdb834f5f7f068ce2dec92605982f4df77fcb15bfb0453fc684a34a1ee55bb7b36270cfe16f757e01232ec60461a492b1ea473ff5dfd25e77c646d6ffbb845c6c32dc5f4eb20f2d71e3c14ad4c1f12f54298e94ab73f3a7e756e4dd836127e4afc4e2533c753d301f2bd0e0e0ab56133df028c91fd7b65033b771d712db4556be750754b88b0fbeab1a3304159f65fb890f4c5b53894bd8425d2f4cccce49f2ab1866c2eaaa4381669e103990cfad9877adfecee01d83fe099328b56128e33ae21cd724e084444460b3e559a23d1db929eb53cc59b4b2ee6f5cd2dd802d48fee50b22c66209a0754f5746581cc5d574ffc3f631a9ae8dec9b2c8a83a4f6615beb04dd24c8a68a5d72893cc659662f43a04a15c2e94306d31f31f4407229edeba2bae8d9676ccb3a21e8cd2de6fc1c8bfdba3c09e246323eda7a3c6fbd4283a45e22bff3b1b325e96b550351c77342f922ac8159f52453f56032b2afc69e554e7fca561bdb49f0eaeed92bc2bb4bdb94b75e2105106a63209707c26bedca6fe0af51e6fd7e4362be0d1d52141dafb1be2016f0dcf8bf88b83db9b0de75c631566117881d65ba2591b85b70431d32f9bddae411f1b3751e5102098119691c295a94b08f35c7cd5083a36f6744162aa570109ebca12ee2d44a1682e82fae3100a9b5fa3d0ccb6450222c8c4c624e0a8a7d26caabc0b92270878b4533583da1b4970fe6c9276494252c1897f6a3b13cff49562f349d49e9f3b0a41569751d46a30f239ffefa7454d93c9f8915722cb37b5ca51a2654e34fce8aa5a094edf7c5b50eaad1fa4839976422a49cbd8667e68e2855ccb8cf34098289c8144da67dd39500102677696a6f63171d239db11b31fc56f47b44800d460e053f987e099ec0382e44f296b7e431384378db94bd4dadc74687871beed6e04ea2a10360578f636dfec267f650e5ead3af2991167d3b383ea8a94bd70acf9e2119914748ca8abeb9ab7a7fcaedbdb32c31521829bc100ddc69c99752bf21b9b60fa212d7b880188ca392f8da96fc62badf1dab235f88589e01a21ad4bbaeb37de3106fc29fdc044198958c42a390e8eb835831e0eb7586bb0e97e0f8a5f266979bc02c8ded5b1d18f33eb194931549436fb19ac1d4dc3504bc4a6813f1d08ab5a9f31bb37ea1ccf9e379af7c3ab828a608ba77ee2e3b49ebb589deab5cf6f36bcff528e335c4446269599bbc5ae2fa2729e7cdaff01b9e238ba0a5257302746b250a9063d67730173e856e1409d0a6ec7f7b4c9b3279f4d722983ede290264f4758e4e4fdf75a5db00f984e1d45ec0052a533d89ac755fdb19790098063b29478edef649d2626561409e59d6ec0b28e7b82f0472e775e1b87ce6a67fdabcaa08cc5ced08bb58019691d0b64edabff2f78dcdadea3804f23321b67c49889d8d3be9dfb3a5111e9add0a9cb33120e023b050c91341546333f3110894ca9ba688e8aec9a3e9db5f41b132b8c8a54ff880709fb450b72611af6977b38bcab1c76a4c67328a43b97fd496b0a9701ce53d4cf04b08142617fa9a36f2833fa0e277a4346c5a222de4c545d0c4fb5f634011e436c70fa3529dd453fec9c89ffc5efbc4c83f8dc0f040cbc7e41e6c4cb588ee0dc53f1c59a5e272cc0ab2edbe0a609628634fb14cb664f8e35363eca47a48f603ca0509a793b61c9055c611bba05d0c65e8af9e210242c287912a476ef9356c076e9f6717b1d4af4d5a566c8b96614e777e8c2b0f5a1e9f9672cba6201172bcd9f2037308bd441e7ddc7ff3fe639e96e79e3e52fac4d84ebe631396325ef0e2adffa980e368d06554ac57e1b04fe09cd5efd408165b76c61d9e20a2f2be0eb7c3c06fe1873e76c7f660bc5741f84c501bcc7de9a8f804c407af93b3c17f0c56094615f6633bd805513d8c931690a01c6ae43de54b251edc1e1d7212d0c17eab522ff7dc64682c5b76fcfd847270befede3a2b0c7cc511f0481d1d626e2bf607eff843f04ca3c1004900d5cd844b191fde6aa586a84f7dd30ccc85db7aedc653d84c6dfd53435d3085f451e731585024dce2fe6b9efbc51e151ece21df8e05ee403cc983ed7fed84d1a7e500a0cad6cb800ebaad13b04ced7f84dba8e04836d24919efcf3a68ca7b5bc7f6d56198ac492eb8c57db5b82c5a1fd728e46054e7d22d8096d671de7e57f339a49c9d235caca1e99889524434a7ef0eeaef1f965bd948e72b66a7b307f41f2f63d71bf5ca0ae95da5cde57bb90729998be1232f413952425ea98db7ac8b6862fdd69ff5b2ab2850236dae328e60e3456a55ca76a27158d20cef54de528edf43ec3b9ba6742cc424634b7e1d7d26dcce9c7cde9e09ad5134e0c67c5eefe40bd07a33fb370bc1cdbfe75ad94a6fba080d1872a40246bae4d921b7e9b624b57c2390a7d881a1acc12c4c9144319dbfe0532d172dd0c5c64ae4c87423742fd5c73f379ed09e19489e680006f961d7cadfa225f0c9895cd7ecae8726eab2444c14eba65b3339c66fa975bad3be00379c1f8d0526a12ffb1da13d7a5bc04f4f414b0340b947fd050a2aa9793b7ad37cdac26b46fdcf2dfc0530952ca17685a1af8bbec057366625bdd2fe67e0b824646c512c87ead76401c0a5c9dc0a68dd89936a35305cbddab37da0d28133c00d21afef2740827a973428f0b21488c9d6e17c3ba361a34bb67f8eab646125d97b52f648be4bf75913bb6615d24872b845fed8ee76ccad4c9d599cf028ef9880833e968af349365ffea959d888001d9a0c6a800f16eaefcbd1c0444a978d5dd1c7a4588767e536cc05fb94fe0ca38d07df930827d6787eb05effc3140b743b5e3e1d4ac1582327f5f1e755af7b26085e7e78a00906ec7e7a193309b351c1545c37f162f561bae5a2a2ba15a71dfe32fa6256f3b9c0257b5df8383376debdbae66f94cf4881e1b57b7b8144e3f4e1d54b8e62e84d93a3df1059c5483a0769403375f09940d229ebf4b6bbe5e6577dd55b369ca1929be60a91920891f01abc84befcf963a8ef87184682dd9a9011bf51448dfdadfec292d6a10d4e607f15105210b385d8b6e9bacf1e2dab1e2605540e4c7248ee7107e10c968558010d2117047cf52d1879cc1e2407df0cd704eaf4f9fbf8b39706f87458d8817d0c05bbfdfebfba5dcf3c3d1794aed979c7f3f64c82fdcd3deb42362cce818a2c31991a790120bf51a1f664ea79c57219fb36a572b5a9282fa2c7a6547cbd657e271ac8def7ac2c83b5636feae7280fa9526140c0d6ac6672c27263ac2186791a825936a073ca0e85c0859d0652f0f9b2225c0b3743fff9b5c1dd53e2b464f04012f68f62c0952446838a98152c8147a61bea6dca5e84b07e429420540a152a2efaf15e7cd2e0824c8359f967af1929ec0744ab9d208d5502a6488f6cca58ac51e75c7b31aeb700b6f9a2c36dfc2aeec961a31f448dbd9aaa4304a23c504c6c74d86dc84e7eba783dccec6364e3fc11cf12cb13b39cda52172a56488458345cc43f507ea5d0878a7382a5e67d6585477f2aaefe543d6b24c86e79bd14eedaa7e3de851dd84fa4a2dbca68f3e42f3185d7c468fd53a13bc1868c7f3ea9d665405d6c8aca9ccecdc3a6fa6c8a80fe729f0548ab5b0b49806aa8b2f1923a7e7c8ef49642a988788f226115d8fe05bf22f060376c6fe59e11d1e84bda0046ea9e72bd7cb8243536f2a025bae4445d201c29bc9249fd5703d01fd4f9abb36d6000f25459120f660e06b4afdda932d2a3cbebe789452f34a65f3e1e939e890e9f7fae9a1d91d51a23fdfbcd35b2621e0b73035b7cc6314b525558e9d1aca7b88f042a57ad19fd441fa3d429be8ce3826c502ec17ee1afe3334a43c3dc6fa316e9a0b38e34b96b53d46ff3baae1498841d594cdb976436c02f7a065968835a1013ec4478f8bbb311f0ebce6b53c386ae98222dc051ed1c70a035b9aa96c30a1009752f3899e886dcbf3c88a22ce595fc6fda05888f433e9853551d4a3c9e5bafa8ff89853438b5bbdd1b9c74f1fb02e2542fc558eee5e37579567521cdcd829c7b028fbe88d339f701ab6e425cef6e8af3f6dc3f243c8be9d3ad6be8903d669028fa117bbc09c8d04e90d4749eb35463559cb044e1a964deed03cad1ab0c87c3f2092a22827ea14bbf13bf98280f9c7e6b0f119ae496ca792df9085c66d6b783a42a53e1cff4ac5ddede904376b6e75b0670c15005805ae1e650a36bdf2eae0432af352a098767cd223e1832edf6ed727fa461016b593558987170b952b5898b978c927589a089b2bbec31ca7379f25379a67693c337786333108d70c784c267254a39b15337e2a235207e6632b1bc683ae38341a603d8a6aa2b8c1a319e66b08ffbaad36f5f4611c0813ec748ac9df9523ca4b59b7a0c395ee92b444b36e4dbd9ca73ae330c08278d622d459c431a7f907bcfa0fada18c491d67be9cb9c9be83eac40e067bc9f5d3e458f1b039d23eadd0fadb5e55a0d92968034b48646a8cbf6359de481b98ab1e286d744c6140f5b22822f343fdaf31da7c8368e69adf6ae57c5452a7f2f2c7f28a83848d89f8677ffd2e0ec019f5ac0ded7852a857d4ffb4e896e08fb372b4e72207700d87c1f5e0ef7c4c34345f0fa2d3332504d5e6491a35093627850fc404190a432fce5b2e647288e0870511fbce191ee3932f02d8b0de4f95f068dcdf8bbd9531eb3a5a76a6ebf9627fefe2a4aa7456307ecf48ed93c89cb83fb0bf6ab4bb32cec6370dd446a0fe5fe55c790530f4e693e01a99d86a762a0e6a7e36debdd9bfac68b4d393dadd850133215515abc7872bdc687ce8489afd72dc05662cbec6a36f1f92c094b485974e905dbd5858668054c31ea0ecf6b2a9612d911b42f53bd21a507dde5432b9f735bce96aada52e2bf288179c56da6ecf2e1c228b357fc8f7e0fca1652ae113d6d0200ba4e90a1c4414ed1e5f8f482644fba8f7b12c53374177b8678c176abf976697e81d554708ff47675b525701eea09e38382ca131195c1aec78e621c03b134152f3c3f06d1bf842462694437db27f05ee7d35aaf840318854848e0374c737b0620fceb2cae46c20c1be571c8faad6e44dbc58c663889712c19f135e3166f2415a62b6f5b5e3934b8b41039e2a4b134a057984fc7ba0682ff3eab7df3e0b15b875de6f9b16828a65ec4e08019b519e04f9cac5549ea8ae09a7dd6e7c2971266fa194d0fe79a04923eb9e843818069e5f95385b249678137aa677598844a77183ddece2c7564893cb8165faa53c088bc81705e47e54043836f498d5df3eab7a658eca1fdfaaba31edc58d6f9c8abeace666de222e9ac2f979ed6a2ab5d826ef14b848c8ce7903b43160b1d5aa1375402ac9be47224218493f869a825093","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
