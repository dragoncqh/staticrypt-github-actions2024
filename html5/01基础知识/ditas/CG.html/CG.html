<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e743cf031a5ba69dc873edd6bbba1bf8fa247afc4e28cdd2123d4e03eb4adfac732053198588026baab45be7f7b920d41fc5fc9e68fe8bc91725d6e05370ea6d5fbc08d72a67b16e084a5e15c25371b500573671ab036f5251020f2e2f1fd4b4611b7842718e8ef402f737e857da81fce56cf9d935fd8ab582f8381486e4cd05d768606cd6035ac96ec6bacb77d8ca5bce5284327ce6d98fefc560b502c533eab83ae759fecb167c1f8ee43425afa786c4f9975457d43034aaa5cdf801b7f56aac9d3abf167ca1802771529b04f6e223c9c76d670f36d69cf2ee788b77f9dead53628495b4ce0bc2bc466f647496f39d62706b2b7fff03d8dda330b1cdb7f8224fe0d455ce4a162e96529fbb1bf8dcf5a07cf3389b2e170a2e41056c270fd53a60545b646c800454ea16864d3119e27eb2248045285f0427d033e0d477584e43e308c6ba3a07b0a06fc4347560f996babcaf087e27136e225797d2c50dd01044ee5da28e26ebbb803cefe933e8b33bf2bf41afb0b600f96a7c80269e38a830e5034504ba4e19bf3a26cc718b4c7bafb9497a43e23e3351d5ad8b202bb9fe62e50167bf93fb4477c6c24da61d9711afcc20c2129e0c2b99dcfe87201e2d967f06a3ac798b4914a18106a9399c1e32e26b15f88d215cc426b12a5e385ea4212ed88828e5c87391922e868bb35c374356598ed493e5374561f21b227009b95d13a8fdf55ee169f310b0dc726300d6845de207f6e85a36fe37d5678c77546489af1afd2914eeaced900574051b2cbf67479ab89e56dbc69c2e10e47eae6afa16fd79fcd315363fd512f38d2d6f314029df3b8cf1d5ec88bda5c3abf41a471f39b01152c03bfafc222741faf4a5ef816f31aebcf7d51779ee25d9880be8d4abfbd6eb54619922ce5ae6426b5b971e8f18b32f110b88a610f67baae5bc95cca32c9ded1a3ca107b0598a11c05b9dd68981a69d2fcff568dd1f61297bff7a1f6dd8a6bfd80329ba2b51a107842fc992fbeac52f99a4da410a9fe11f7f1fe8a19eaf6cb5669c0d14459ad2498bf772424760c2293d0d19333c213485c7c79ef048a434d9f545eddda4ac8699c07995c94315eef6e136d7484e3148c67e803ba74de2d8b57708cab484e6a2c6c5460bb37858340ac23d687685e8da98a15b2bf720221fd9c5fb138d66047baa69d0c90951a10453f2f7b7d6d282796a7760d3a8f2b72fb3433287804e5075122379b8e8cc0904dc6cdf34c2a2c49ccefac8ffe777c779f88317adaea1696a95a11da30c8af247d9296be8b8f7caef807e10a5479ee97aa35d8926462191926a717d1df9e5953229446b1a920b7dbf5d25a1e875e9b78c0c796511dcd12e784eb50d6fbb51a3e95bd67faa2545eab943a5f3cdc46e91e97cebc6dff08898d6b1e21ab6ca9d2ef8f7986a5b2ff4311d372c3f427ec6f78ac206fe60cc8bc351d20f037cdd1123230e47ac09a58b6c8274da0d4c84a4990d9eae9f313af40d7c02bc00246d13ea744e81d6c30282bcf2d3c2e7b559f8aaadef4ac14f5d191f3372d7e2e5d54487982f52e6577eedc1d846fd52fd0ff3e9d4d0ca81223cbec0bb4284f9053a4cbafafb23b83428fcafa508f63cd0b948ee2f6407304bfd2954cda748102e9c3be065c804dcb6ede815bfbfae27a335d27f30abed71f39ef85010a75e89a5bb0bcf2ff8eeee45f12950a0940f019fd8276bbd4bcd44f41365006438c7b0a3e09d7a6bff1dabf94e534e58040fec4536afc473df092fd9b7c69d509e427fb183d26344669e58422bfe8cb5e9f85571fb687557cf881e9e483a0fdb67ac61b068a49c23743fdf22a9a71441d095e41b9a2162a6352efd33499cf27c2698200f15aa5798dde840e9424d297e4dc6566ecb4f1ed545cf5dae52720d7af3b8298cc690adbf65dbc2a102a86f94fc41d6de32a3b258226d0bb61ab11e500590c632f6c91ec3de9d410ba095e581a0e3234ea848a17502c937e73d93038beed89cf78036a7d98dce3f0b78cfe2c00a5cf751d4863ce5f6a43b5d4e5ddec74856e5c31f7613f8d28dfbc21c43c7d0ff72176115ae227a6048192d03c254cb1e1a3fc365f44ddcaf03b4e9fe85df873da88ba47f8feea27becd0d9632c93116ba9310c6346726471f22730e459dff5b77a9e2018f8b70a504f86a2499fee82c36a761b7cd90142e067199d708fa73b6793a076540cc46a9788bd0e20ac856aadaaddc3e61760b4a9e560cbe6dd9862fb0e717a2a9e84cd8811545a57fb530e3f912178970d5cdae1cfa77351639b18ef0afc4bb61fa96b35305cdfe22fbc4a1b75b0bcaa86c0d9b61fe978bd58a0b68db432ceb635b5e84d444129590c7db8c61dc09f088739a3471a973944c48b13de135576aca18b9d29007779785423182d68f7ed7c449762503bd9556afa9ca00bc82f109f68a3970ea9f405b1baf6bcbefa96d9c34702c21b66d9f33b16df8aef8b2f503f6531c7009c41ff3504e2c3ac253a452fa470a8cc70441a70124cbd8f8e8fc4ade640592dc9f5f9daacaa5283f3075ebd20eb154b50f01caa5078968ddde690e3fb833b1efc78ca890b5313d33ef5adb19e052ae45b455ad18a3e4d9df0ef65385e153ff028b476bb16653a6b645883bdff462f0615438b0248c6c5e9f6614ae4e3f3c98f146642d391a00d1827db4acd643d6081cce435b95d72556dcb52f0a06a124f548c757e0370eb1c45c8609623caac094f13ec6970afa97250e0e251319cb2eb713f27a3869da7579ff1bd6a28f99c8c5f357844cd5a6f0581fd8f0429fa071e052dc840bb56fd7c77d0b77f47f500357719737cd9bde59fb489b36f464676b4bf552064a6a8d6ad06d00ccf1f12a2d3d856f4e16609c551e472ccf1626d7c5e0860b1e2a76eab1e91b0861c48ea06cbc33847f4e4783e3d3de5e22c8401e0c7eb36f311f94811d866a95bbbbd2ac5add95bdf1835e51de41fee34c4bb3bd53c43760ff1f97b9f9ab9caaf39ec4ee5bcbfbec8f14fe6698da18493d98b3270337a9e55c2366dba1ede8ccafe3356504f8de07b641c2525bb80c2bdc99e8f52b8a8f5e1cd8eac46af112a8e68b0ea6d4afa883d553d3460cade7a63899613856de5d86350536eb7a73a61247b27681fb1a7c3d1811e126644bbe89f100dc889177753cfcf41d7f2001fb6adeeb454f4fb9f1d109295ded4e2ce37ba66d9b2b48c67294deaf86298ee9ab97dfd0d4e406921f703789d977e26ec305a8528faeb931873f77ba01873d386fb7fa28228736ec87af1c8d33381f71ff63bc6c0185afec55b5d1ae9e6073716136b99fed0fd894c1ff1d30b93fbed8c4322679fc3cdb809acbbfa643f24078da170d3cf2d37ee069f33e994372903e71fbf310ec193a23892040c4cdbabccf04d57e5a0287a118518dac37b274caff6a820ce3d78ce28a5286f0d6c432bb476d08f6f5cf95956b541797f619241d056a05ff42e99d3ea1dd57264cd346a54c85063c2889b861e1feabf43a5b2def9dc38d3daf32a4fbcc1217eeb1e2b6ba17d68e4a3eee720ea16737b53f8ad0527ea0a8854929db52765d8825c2d6dac4800f4a97a95f58198b3068a71bf82bfa384a6078dca112ce261a90223779edc199c8db642cba43cf60253b8cafe1e7344d16a07c7e48987a0e0195f331db9def0ac5336daa1eb81ed73a1eeb657ec0792a021d5a0b56589e56f0ecc37ff8acc4f1a4e29d47c76fa745a46299b43220bc31fb47cacf6a499590cf6a0a60b235138af2d88fbb74931291eadade10c02823da18c5fc64078b3ee2659bff51f2f892a61e22d863a3d12612b907eceed47988539fc74b9dcd7468ce6221d1f80f8e36a8471b2ad9a4ddf8836f2412c030bc732f010cafbd730ad22a350205eb0750829200b8b34377f398a26e248b3e18856bc7c2bfb7d051e3a639009a7578239de5f532816a2c739f1aa9bf866b4ef9fd7a7f1edd08a6eb72cdda8156f787b374a4325ce241254230e2eeb3121495715dc3eced4b59b640f9a53b3182cf3f71bac32b485b7fed03f7affd08210b93857b1bca25db91f8f2535ea306674b607d69bf11a7bbda3d19f52915676f79ed940bd5c6ff650ba4ef0872d942cecafb1ab5b03a432c68517a2cf1018fe57fe94485769ce6c221c635c15661b8d95044ba89542f3d89716fdf684650adc36311ca489307457b8a60f368654991c0c9a9e3a345207925334b702ec2c83733d1df1c1354dc434315f2ced2b7f5cc70300d730f2c5b755dbd5f2892b3b072ef933e7637c0bee2dae50e7375245c48fc98a2c121f2f62c6acef727cf25ea9069b20f1f315b49f7d3ceb4a4e37de1d17c4b33af6476da71419f401510ce36f1043c25bd7c7d0c64a9c8cf4b093bb362a1befd043bca7c047dca7a07717f13a5a2e8e1749f4494c9e2dcac59d1dc513bddb786029115b2ac7b25d04efd0cc75ee0c943f1a5eda2c5da1ee300ea3157a17be3cffa6885f41dd976b8e79010af2a74ddf5233a9c5a8a6fc2f4294099de6341edea9a2567e6882112b4d8186984ba5a3191fdf6fd304deaac840e7cd475682e93497842c3906dfd74674b307d93499594d4cee6bde4014912a41c0b25895c12bfb526f52cfb33fb2d31abea1ea16ee47acd4706de66cd2e73ba5522bc45ad7beebab5fe76ed585bf33c8a17e3fbcba08c7fcc8b27a2578c3ec1ca08f532d695d8df923ad11b8da7b5bd81c926ea7b6085d1eec8ce4a74e43093f11446b242bd1d0005a98d53c006f204824e616f8f627876b3659c5afc6853b34182538efb67fa52230e84ad93a356c5cbc92303dac2d77ae37e17bb46adf530e49eb4fccc15501f928e385ec9a40819594ba5faee90a59993def321a67bbaee4942de7efc6a1b43b708145b2b95357dc1cf09fef32f5fd7edc7ff8d8d028588562890ac9fc6cacaf7f4084b544098e8943c9f93e7536b6ccac7c7155d86afb874d31a7c74f9f5cce99a1eca26749edb5957d2dcabbba9d2c284cb30b7fa64841b7fb3c2d3c060525799d99e997cc74f7667ec60bff216c8796d371d7d8757158b72b0e48457b230c6e6a9176bb72e62e41dcc6db82feab3e7d962d382b0d1e2e0bb36b0a22ec6884563f0ee5b54188c5f558318d8ce3b7441b4bcf39056339bafd208071c8849bb78ca038302bf46f6e435b5f7055a019e471b4e74512e437e83fd0d177263f28baa8ae3b94552f689ea53005b542c53402f6014ad5ab588be20ccd576a4bd4e3370ac26580ee17ab4579a6fc9ab3cc2eea6cf2f16dede20ed61ba4ef48a73448c2e330ce779797f40d5cf07785d8666bdc4063f12b637e07a806f4b72c59548d76cc7e318acd253bf760d02cd6feecb61298e11cb7ea9582cff3b8c886b1c2dab586c7650ab416e29b5bba1cd7851f66be7bc3cb19d82f790986bf899c9ca3ab02d9b384c7ed40e85442ae3fdca1eea81d8ac700bd83b6b3e6d842d5233c8bdc4bbcd6ef31014df474925973b68b2023d96c4050c949b0960b45299d0059dfabc6560d5ebf79f99b1e0864bee2daddd699c831749f05fadeb2df1017a22fa53738e07f06f8f38f8ab141794b701a15fdc11b08581e608e9190b355db310c5bbabbfa82276e6c5cf294c437ec0263ed7bd6feb9ce2be87d4fa9fbd46e61866182756fb4998f04c89ae8e6947f6b0bd26e6bbd3e2ba0171bddc391cec83a22f4a153659a97da29a63136b059225351eb830ed035c8b608947297208dd30f25cbaf61ceb55a5d4249a07afe045ec83ea02b92cc08a58304d862cb062befcc5cd96622500217d9c6459ed62ee0c6991a4254fbb78487f5648b5504317124668f6f77dbfe9335691a8645501eb8d57d546a402e6595908abead26e812631055674d954fba8028ad23d2874a07051f87afcc90d00208bb41f63c47fff32b47cc4ce0ba87b9fb79ba542098cecc751a8bca9016c7708fcf7cc77ba6ae816d381f4eacc985650da0b4363e2d95747744c1c171af125d7ac11b80d7054676ba10b921ce2a55a133189c200463bf8a321d2a1a27fcb069cfa52a4a8b6295b5ccd9d8957f09a8b275fddc64bbcc3aa6cb4f0d8bf85c3e8c6e615dcd736f47927aef7d4d5a72a8cf019e8b5de2f9a0139fcb9f65e81837548ac9ecb7397599ca554dc9aead569e7b788be2f0d00204db603fcbb2645e5335cb92027a04f5b5745994c9aa1c5018ab85ac597f30d8756fe61ac7a243af740a56f92da9aeefd9ca25c5a5dd2214eb85d741793f2e11d8d4df535a55a84f8f1cfdfc2e4cecd78680c0cef3ab15477dcf27482ba6a34bdd59d82bd4aff1a0b73c9de08f94e68ea192e740e221fb69361e9e48194725af7692ba0b947bb7e2ab54cf7cdcdfdd010492a9a42e1c2afa8d801891e1e56887542d56a0391a144a6d221009e0bca765bada420a01f1e2f7175f6f43e991e1b78ca340e237b3211a3ffd8e4c27379c74ef46f99990552e85eba06909f2193a653f813e20543fd25d03e7ec6f847b41a1f4bf9ff810d8a67e80d9153e7fe960eb4f1a98db12d629f907a4da2d68fcf4401231b699ba42bd725fa7e93cd68def687190bb0fde31e212a02e6d23fa7832f74496c7e54685512e336e55b359a1e481bf94cf80a75b9a3a130f59ce0a9336d1516c860ab57c354f869cc3c1d949aee61f7c7bdcbce3f2deed7a3f274823d133e11d8814fc19245b4b69702f6f6f0e9be2a59f25f424c346504bf00598774646d395378ebe7287cc2f25a5ebece637c3ee39cada9507d323ede06a40e5b32933030a55fbe5e467565a2dc89d7daf8107402d7b064e4116dc08d6c3101deef85dfdf80155a2453efccb3a9af74f829afbcbdf79b000226f881d618382dbc28ffcd4eec78e6b88ed816dfec4364f2494b0a2d33675837c2164363ec91cf255ea113d05e1da67cc13606864d66561b437832caa4cfcf81804b731c609fafd67777dbe7e555c4cd9f5c48632fd365ef21066eb36d5f7d0a668e4e163bd1e3ea520dd798acdb03afd17a9323cd0e41fbd8fe9d2aa8f1381ac93d58de3474cce42138878a2a8bad3c471c9bd79e9a06037f5d9b43d334a17265b4029604ad81e3f87416b023e4f1027888d72dbba7f2cede4e6c649243f0c7b5bf4780b6bbc37149bf122f2f6d8ae6dde5c5092b87ded2cf1541b0e9ca9e8ce0cf92cfa7ccf12d368f822416c7197b1975ec8e44c6b554dade47912d50bcdefbad577ab8c98b9f34963e28d6404931d7d2994fa11a6c1d4ca9ee94facff8dbd7679784f07ff225c03fc0dcd7e15f8692a096e52c7c0afa5e727e08e7f1d5131175c9b76ffef7b637a51aa0289573465d9ad8df61ab28f015e869e27113976bead5ab6aefc1e9e937d2cc4b5efda3b4feb611670158590694550a4480d1dca5a2b17e7865f16d6c6b490d57006e7a5eff0ba17b669e2e4ef1edfacd6af4bed3be0b273fa3f1175350e88901afe5b55247399350cb813685944a3a0a04fc042f07d511f141653561de78ab5fad2dd7b738325a49a74666071029097619f202069b4f3dc8e87d27dfcdaa2e09931663b78c9e8504dc490e1b5b62e1dd83f5d5a9999241a45a10c4d96d035331a4d93a91ce5cb35c341b167880f5734e2cde1edeb8e9e995990dfa218cb4c2aa6226d4626f22266c854426404acabb080a15a87024b7ece65b8ab1ca62f1f4f707dfda027c289de0fb5ef7fb2cd722712bee455bc61f758650bfc3969b95c81b5556faca9ded54ee384cb9034259da14c8bf803b9a9d1abd5f8b1b34c65339f49d22524c00797cc6dc6952a0f68520b9b61879e5891297f578c88fb1e9245baddd2d6f8613527e09ca6d269672d82877149b941f4c0d7a32d902b261fd6872033e7011dd1dd34b73d52ec533489aeeca25f6714e68930a0eb2ddd588450908e538d7b94433ba0ee44229e8d3ec2d30918a2b3dc25fa3b8a6cc520e18e4f1aefd44b599d0342a97eefab885eabccdd021be1433a644566a3330bcddfe5ee39696a9e73fcdcd0e0db10f8d4f9b0b91fcd516d2959bec9db351e2cdf3336d6324a4477fc4ec63ceb164d1f059e4a15e4df89e8e0753642f66432433a53b648a02518c3d60825e76be6b0d978ee59db9c107174fa9c82efd04c54ce903bccab85c7c389d0af24334db8cad0875053c67ba779223d1e5087fb4133f1930006ca6b1220f4fae9e0452459be59b02b3f4c80cebee5aaaad415667de005db25adc3fb8198c41aa3a0e6225bb490763ca5722c49e38ad5065fa3b79ad8127da4f852bffc5b9415103545d94595ecfaeedd16dfa7c424a120e9a6c64d65fd94c925b85ffd5ddc1ad6c3e85103e168ccf1e31b63d885653d72b6ac8b89ad7b353eab8abc2616af987adf26db0aec7ca8b1bc36751fe3579d6bce39e2f33af9e4cb6537d616d110aedea964da3de5830ee0fc995efb6f50a03128c92cbe51c677d900b445f868172de1374a8cdf1c7e12f2d1df56c7b2a7527a43d08e246e836be0224fa2b8e431920dc69fa763e917929b31e919e1ca7b3ea43e1dd2fbdd4dcb67a3f837ff3cb770752a6026fcdd781de4099a684cf0df4ab4598afa0c2d1c7395116bf3aec7a6b362028deb807af78deaa8a0dd6668d882a21b38a2044e2b5de97e9e64ff60a9363ad17411d99bc64fe9263824dc06a1956134bb23e711b3e334bdd1ae247feaf8658744dd6afe35c03e3a347380bc29f533b31d25960c3134c2e7e0de4bb4845dd8067df52d6a08b7eb6b7396d8ae04ad6c273246641a46a80aced04c986aa7de9338cc1680e1992204217f3ea2049d451e00160f203f5e402e9b0bfa339fc4b604d6c413f47d2ec014ac557f8417429df51d25e31ba6bd1007ac30ad85293e891cbeff14a914ba5f08d7a388fa45982b71591b992dd1f96acea0f9cd7aca0917cab56575459e64bf282a8767199d026d88abfe4b6d0368e261fe67b3e28fd13609da8269039d90fd16cf0e9ee882cfc361bc09b38d6e9fd8bccf4b1e179572f5a977c4e2deb467a9f499b740a5c0d7519826cfbc83c40aef766c3597ea6dea539b9829108d84fae95b8a4334a48e7e7da9ed70c5cf441f4f6aa0b994096cf7d43f6a3a335c701b7d80e25a2448a7b06174b1237c493562ddbdbdfa8c5a25b5f61f5d3f0da8de0c6832df97341c21e8c869559853d1426eddca70ec066db79458697dbb6e023150b5823118606d2a92259566e758e1a79ad7335c42e3b391c7ac83b23b438bcce6ef8644f9710d0c8bd3c1d0a8feafe0c94bfbbc0b60d0c1391318626cc74bfee60297a84c7db7c17f492c06a8c8d3a6f6a87da89a1229ffc2056497929205df596d395df4218ca1705019698d2d75445d5536682f6e8f681d2d26ad5c5660d08e971088f98d0c1d81fda6be2a1489f4cb65b9b11ee61cacee422327699bd2e7a2b835958d810e51bdff411f8c79dfdfd8d8a158b25bc655df282eac1345942236dec589dad0429217f6e2cfb088e79dd17aa569139d669ba55858c5184689b45d1258dcdfce994ae0bbf3cc6b6ed4fa82a3ca236a75016b011aafe24b9273a3c4a6493c6a9cd9a9c6686fe3f11b6b24fedbb4520c519b6bd188a22758df58538fa353fca369999aafc98ebeb6cda431d43efdb52ed3e2fdf4c7f3a3c64c7edc390590be414948753f7dc6f98afa40ff807872cae48e66aec887d8a4034dda5a8e26c43e85e6e6ec32892f61c3cc94d2877f9bedd9f63cda914df6d15187e808de7db7e98956bc210b68a286c573cdb7e3048a7554566f0c79521b3544b6f7ae30563899eb68a74a2096ae93500a0f1fc8eb8c840bfe434a215fe8ea368b75c0460820551d46b23985c3478d79b3c8f961cca9d6bb9830acc381e4f411f5e2442b5deb723fcd15bb4257b1f8aa3996a2650738543965ac84edc949d89a5e2907edbd19e774c16365848af03d9a8d4e9d3617902c798b41971b9a4bcfb746f6c9c27bea95959e22a7f9f17d2f18fc9ff096a9f10a2ba85a2667fce1066049314162ee9402ebb939b9634a8d9405e7873078f511d558138f836e252cdefad99a2e77067b87d9bd837964f0f1c4d83d429e4bd7d8aa16ce344898b20c92dfa713ca0d92601b440838c1f2d6e5a1ac0998039054eff64011d02bcda6e08971afd136155cffe97225e89f1ded999c22f85ff3b1aa0a637414f4a63121752a7d6ec0a3275eb286216743b67174d0b3f294364e50fb0c9ee93419164b321f9c0effd66b79672c158f4a47a67989d4df5efc639e56fa657fd454d5bebad5b23285c6fc7114976b52daed2512687743698e8cfade6ec0d120516cfe9b79cfc0ba67ae6ba6480cafefc5c9b005da0b6f103753c52b6f495dabc54c0a1430d0290bc0855f787f4d149c891b14860a0b5bd10a0e873162fe01cde040ad08ee5b726c35422ba1091164e0c5a7b67941160ef5113c231dd36b1fb577f179547e8721e6b812d00f24ed79524ce731457094bf5f1d3191c1f61d3c2bf3f83fa3f290c35fe879515ec55e8a6d66b534cc47f22c908deec2e4b24144e88e797c5f5d8e19a60646f5624b1fc9e04401f7f8a70ea0a4ef4b6a044550d423f18e61e1e6a831b0b7aa60e19d3596aa512b339878e874551b2f560c0e74fd566e9b9e896fa74fe61b47cd474141d9f4a0ce9fe3530fb1f485c1c80816e35b1a96d5d683584e9fbfbd6c481d22e0c0785c997ab5d80140cca3ccaa4eca34f91b920334f7d89141030ba896461af7e036b7b121465b77e78cf0f55d41b0dcd8caa574361de559d68e76241be97b62c71331e9e4ce32473b5c76084451d4f8980a6d4a9da6ca9a117235d5a36bdc476d8b1c0a68f8b829fb69b541625b3210ec9f5dea013e8f8ad17571bb9521490664ae2db9e3a7e1473414ef32cb9d4b84786d5354deb8271a38dea6d4c1bc6a410b410487f59cdd1ccc167054f134a061a0bea9a8ba2f388527365d38bdef3408242a64b5ce2153f3577180e6ca6aa013bb355a46c7282ade08cc2d0eac99d11f743b5cda04748f78b4cdc76e3a1dfc5a2d47144c9a036b7c57a958b373cb7eb6c321db8f01dd3a3b59e6eb56f44c324043699de4d855f5fb7177b67f0c36b8fa156054f60a3c078c3b513806c2aeaa2f564e0c4ed7ca8005cd9cbeebb5b49552d4c19ee8813c88b0e212ee92549e6bb464e73ae636241169ca68452cb11a9b947d3066641a9be3d9201f5c323bc94bb81ec2bc384efa1878804bde8c71664dc50153b88029634e56f1c8424c13fe420152f36ee3154b3ebafb749a937627323bdfe31af2302bdf296a349fcf02f2bcc3a93d46937a8d9fff5fe437f3124b34a4e051dbccd24ab458a39b73df55988b53ecc8249c1fa559b7dba61519851f3949dad5088e94bddf4bd4a51bed398702229fb2d7e707d3608b56fa1edde19b36e7fa3070659ec751a9a40d1686234f05843b7b65b57245fd4c69547e8cde103359331f6cfacc7e2cf5dd6149871bfcf6e08bf9af1ce0082a4e3e6460bb5f659e984752f7cd10ef258a29314ff839827136732d62ae4dff4eae125f227aa887890c39709c374a718f9340b13d9542caea08729bac84bf3d8e094fc84ad20e2bada014b49973e9ee2644e6a10782139184ee376c5253cae985cf3086d5b85517b860fa4f5100ab56d9ce23175ad3e9a15c61018d998bb49b32470ae751b3d2f97cb07cd916f1c3e5b5a766f40f646f7d3f73f739797dd9aded9e864443c0009433422a72c968d733c7bb6a8babd7954db97b08c0831fa330b2b39bd6460d46151afa145308385c778adccf59559ef813cc855230ec73bf575f83f6be6f4006c86700abbb78bea92cce7d08d2029893190732f5d1ed657e316e95a3e97357450476fbce8e8ca90e1b1a4834a5785cb3c1f2cf2e4e8cd2d2d46ea5dd287fe2a4bb40a58f5feafbbd1c70293cbb050b439ce8bc7b302c8673a91c678837c71c46393ab5972000389f434fa738e850c6b915bd69ec0219481ec9f9826f493ff61bd5c86a3c3a20cd7f46620ffeffa3e2e03f5d41517f3b8f0efde4b47e001e1dc0850fc9c2fce262ddcc8df8d56e73f158761281b4b7c062401cbc6b1f9d636b58e3bf25310f5e45183f2e1ad7609bf8a169552535dfb8ca7848bf0781ece913aa69c4595b65f09849b4405b2baf904095e050a4d488e64159fe0421ad54f375ceed40c1bc18749af4461f413a83a26991b0a982268eb5f8238902e466052e96143e5297a0f085ad1aa130893ae78ae7e8dc0007474832b3808d0233d9b4fb88e61ced72f9afbf5ad108669b21655128fd1dafbb823c896558faf46bda899bbf4a36f41330f61743260a5299753076b361e513f4ba76569a708d617a861bf82a94992bf9d8dff171f14ad706f8e1b1882289bd5400b8f9e01900e155382feb8881971a167bbb3f072c7fdc2018408dd7be49ccd41c97a1edf29f58e851e871c029147fb46ef52b6df370c732cafe9241c7d57950c99f30f392723964db0c4ebed6524a7c65147f6fabaa1eb7c00a794fa8cdbad67ee7afe6168fd33c037942961c77b84aea99521939fc878227edb054d6ff5090bfe10ccca5fd268cf959529094a96debc33d4ccb9154b1964355557e8fc0d8afb748a368c522396a6f3c00b20e5363d890024ad23e73a6d2a16fc198d1455fdd4f6d5e8262b4fb9b7c57b7126656487b950ca15cf0dc874008173a5e69e51582bea30123e0446e1f07152024a30877bcc6a5872230cadb53c7023b970d2686c00269df81ed6f27eafa4c57e3cc54b5881dafd5d6b6e64ce0d39b219df668090e0eaa1052b6bc46a02680afe244fd2f677e8b500f422a958b669d3c6ddd706fd0e80455db98f36c4651182f6ffcc9efa948ac01e9514172582a914e070a6aeb1f3b15e6230c341d25dc2a799a17d4d13a64347bac0546103384b6bdfd9a0d71604e1be1040666dfad3e6eab7840963a4e4b59e1b5030a95d480b2675cf261f98e0f296fd15d5c71f57330d6ac6a06ae8032c9b58dc5187053020ef42090ae7cb23344c74a35d68eb782d8250b8caa8ac965c80638de95572c80a09e861feb632104556518480ef0b1645c7dca2adb4a994d5fe273e3be603e3a2038108f7866439342eb823384434ccdbedbe89e95644743e7078b4ffd61332d4c48622fbac38da8a5380ca75345973e9f80756f93b2646d348b7677b8485fce8f8c37647087d926aa082345b9a635aa451c848f04d876df9751363f15bb84b9930a886b40c93551ba6b119abcd33909d785ef41c4888cb46b46b9d547c98a7ee1d6fe33a8b2a4257ad479add2e6f6a05c04dfa14c87189ac288ec7a19e992dba084f9fecf94d6a2152650c5067daa82b1bf4bb8333fd0985d7933c59ac4d30bc8c871e14ab728b20458761559b39a1ff143a4a578e7fedc0ef43bfbcc6209166c44d09b3ae8d58585af4dd9b82756657990864d57d73302f963a9bf92e91c36ffd7106b4c661aaf84c945a74e7b788315d6037fc566a0d894bc87cc2ba0a1728514db83934bf19bde3f46c6448439d6977d5797349fa9497790641034d126cfefc1ca5fdb3f6d7c088fdcc2aebc3340fdc55ddf8f3e566df9774fd23198a706ffa1a14cd72c44e6f09b99400c250e59f2b55bff76a327b9894a568154e5ed69b6f555c85e9782611b9b3bf985f005f057115567949e79d011d4de8d68e69ac35a8efedd7971d1d10a621fd8934db83d65aa13685361c909ad16b4ac7215fa89f83b669e110e1585cb07e5d9562feb64fb57344fcfcd778dd2e431b51737e2d6d1dd20f2231471494427348261b7fdba010c133219b9853ead9f9167bda2f427df855942259a6398bfacea41b200ba93bb557b684652f96fde68c629ab117524c90f565f7acd157e5745a7882f80769872af7f075d14236baab3f58d602279aebcd0e77604fc2056d16f413875bbdac58c6503cf0c3b5d0223fe72d826c54407b4cdf40356850fe21e1285bd0efeaf32a4992e7c7a215fb0c5b7c091583896eaf34e8f69300f76b89216da200d897a92f1aeeb632182c5ec131b518c3920ed3e7ae313be7cf6a3e08a0c6f7feab9459af3b503b6029781ae4c339fb320ec64367dbf29be3573e4c868285a2b66d1eff31b057c75e84e4551b8ea3bca14c066ecece1596ac2562460cc916d5506f04f06cf4cc4985433da4795056a98d78b530c59f3efbb080b067dfe3b475c3d5b8aba5ea50158bc303aa574bcf1a142c28abe297b3668f8e925b93afe25d991e0c5f959bdaf1b9d7211731dadc5f1c9d39a04c8a22994cdac995241ec1cd24829e0f0a264f2a6ad39b9ea9449b7b15e5b0d8ebaf8a29fe64cac56743ca806adb0a9da9b605ededfd4c7c936124dcd389f8b4be80a3445248c01801b6801aa4eb6ec8c8438a95a3bd08387e7efeef0484302638c5f49b12fb21dbb049bf925284bfa8574b8cb4baf09f8e75bd631ec842956589b876672e4bd4eab6e54a404bd3a71d8e17b020183aa2417272c5c90dd13a9fd484eceb7aeea4e9fab0d341e5d2e3475919f49df6a328e9224b19ab34e3ef8af15961a7676ba6b32406f9ec4f520661b18a5728a1f2be40704f0ffb220ff95a0a72c5ce4c3d7f13d55dce504e4f547af01521888a79beb1257d2965bef02729f9f7cb887209d190396c5105acf48fb879dbf95c9f9a8fb614283b8710c910c42051b3d4dbdd89cd4ea2b7255ba7ff2420ab8e45dbdc7d996b5aa42c47b6755b9d8fdec1e43b41b616166f00b293daf945da1e901ca78375ca5a68a9657aeddffba2ba019b6dd63c8de729508bf04dc84773b035e0cba3381b07e10dff8d9bb54aa3ae97b1b8b83ce91ff944492c8119920f6e029a6213403581972708e784d18256fb981fc69c5b8519004ac48217dec3cd27cd0a76daa7df285b90040fd808e23e8b7fe77f504aad10cab4305012b412f6b032bead7647aaba3469c5dc752f72ccb2072f41de6106ddaca4b62f61fc5a3b01f26ddc6c1d148d5894fbab772a63553cc2c73e6bd92abe81cac6268f88483b23a4d4ee8d778dee483f751e3b209a05c817bfa9d4f3540b3257b6fce65de40dba193049ab13beeb97577d19216c899cc8cd4cba35ff1912bd02de821f27bdc841625cbfeb1a6acc4b741a8b462914c095b62bc64781d20805f1428f2557f185d9ee76d82ae378c0fedb25f0def6620e5ac78afc3360c5ae397636f2d4182079b1295439f3ae593e797ce540750b9c3e7dd7674f04f4bfceeebcb623cb46496a777fba1927ece0a75d3f47800045a4c50d60810d2c056bb644e1cf24984c0a587c11eec6464f61f95577ac08676505de52b00d5c198bf3b5227629396b7dd719df36e2f3f2599ea254f277f36453b77b513a8e58bab85c7e1d8f314dd2c08e64cdef9025505f11599dfd8625e13956f6e2d9bfb03858ef971037daa6c9d78d199280db872b4a25c514a9b7fea06e719aed39ed7b41ea14d39d76c3315134475cdc3b8c687d41ae21de0e73643cc43aa8f745134f87498390237cb1b6f07896f3dc6ba7c0d3531d42cea031bc9b268a31851c93c93f7c93906e2223c9ce9a689ba9433e7ae39f9766e80cd24564de3cfd5bc0db8a3f9074b65516a1f37709bffdc73ad549ef4c6afeb43b2698faf0eea29096967836d56ed1879fbfb50c45c8a153db8f8b4409562b70868c0e9c68c39ca135fa55dbba19fdec153c8ac3a190c123259f4364114c1f73afb1cc5fdba0843b628bbf5ad781f57fbb441bb3f153b1ef88c69fb669474dcdf4690124642d4c359fd946b1b51738363e17a6a405de7c46ba8df79b8579c7c40666a730c3545ed29119289e98281fb5bac314f668d8e7515674d8bda3099f777fd9128014e47717c83ec755ddcbb310e1d581aefe6c280dfe5fdb7054479dd224797d2c0cea6b4c7d05fe20c5fb61cdb968b63b714c61272945b5206be26bcef5db8ec14efd30cfeb1d149890a2045d90cf64538dee9d89bda7c5a8d22be0bde3b5d40bb95ebb01589826283853b480b8dd396596ba13e1237d55256a645f8edc3d22082f0722a7c42419841fb74042709bb63005f73e6297889e6c6e7ea47a00fea50e75201744001095168a6146dde731fae5eb021536bf8c806a51e38a50521df51bbb8f297494c8a0f87802880964865fe126e4b87af8c8228a4687be398c3a6d98d3f6ac30f31564f2084e3afc4499dde471093aad3fa0f5d682ca7983642760022f54ecd1078352021d5e9072a868f482423bdf48884e885309761306a34e055202f04fe95a75dda0cf408956258e35c48b06f5d37e7c40c354b3961fe4251527cd496d8ce32dcd87de7f39a0988a89cb5daef0c7f37c4353dfd9044005c914af18f2306a6809c970412b7d04837422e66871bded4438eaca9193f6cc19a498c294dc0deecadee3fbb395e98498ad01168287c53a9326bad98cfadacb3af44fafe488860a9655b3068d0392cf76df862eff0dc0cd60162e2914f0cade85a0d34a519de0cffdcf50b3eb0f22527c7d5181db17ddeeb29850e72c6639ab6a60c64de3be9c0584e895ad31003097fee98fa6c6bbfbdc0effa6a3e7c5f2122738f78aa29e2b6e42d37bd5e258a82824c72a4b3bba57622c735350db82ad865f7f88232788b713511184c6c6dba6fe45ebaab38ce96d7b8afcf88c00d3973cfd40d1dabb03465531c26a83ef8c07e4d52fca7bcdf1ee201994ef494411c46b1ef5cf5441757fc54165db62be43ba0e556f225cf88c14b3d34dd175a8538ed73c37505b2066d27118381b11442d2ac37467c140c5b48747b5496f9e5be1d27d6eb9608ac0579a35ad2dd2fcfad58ede0bccf1841708e88385298657e06ad4c146231af2ae562d37fbb4ab136fb4ecf4e50b39dbd9243e148cc546fe68d9bbaf6df4e98a0b41df491af0141b1d2a3ec943ed0aab150487386d38563b9741ebf01d83c530045461941c6ae6265d099cad9264fd51aacd996b5e9b77d88f6f636aa130574c38d30ae04e7640cd294b9917cb05616faf05e2b4ce5a7c918b2ba59ea05671767159d111f3d7a6504cb7100fc2adcda2fd932e1757fa50a2e144e38d8684eec5635827c166e2bc0d587fae0d549f88c0d7f8d8dfae5c5a3d470f796317523722617c1bdc260a94847b70c88a28d97bb1f04f650a3efbf018879ce30c4af50598152cf43552d03857350c67d3eaf0d57e7ce9f1f6f680e5530a14f6b0685e0c4865d015f3fc58db904d46f76c68266cfdb57030e35cf578637bbabb098526369532af2e15bfb9fba02f2bd3a0f29d6ffcd57a9b382aa945c795ec627f846ba15d6484175281a019df1450ca498afe3ecbdb1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
