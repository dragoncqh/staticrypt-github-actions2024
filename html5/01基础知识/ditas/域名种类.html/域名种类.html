<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3a4c6b393948c8f83d9dcc8812dc78199765a687ed7ef24ae1040c3e9f58f6b9b2583b11d7b556a52bf019be16025afdf816d222ae31fc3ba3b6e9cc9b0350e349d40b22fef9d1b95216df5f59675766999500eaeb2932ecba3e50224fd196fb7929e538b2211b7359b3c163d99a559435f7be8d584ddb08e042fd5e430a3dde2f499d7a03d1095faf27e62692390f7fa2bcb50f4272c2c23774068bd9d294f8047b5315aede2333080f06addc1ec3d19f5a069d1ed3de3a0cff504d0966829fea5e95e5f4f1749a111c79920cecc41055b52fc0be95bead696b8e445e0a4cf7bb4a665f1a26c5d178dbeac8360677e07e38aa4f133eb0a30954bc61bb541d66d7b6f4b92eb17ac1fdc1599f8968ba06e76736be78a82f4df74c4ddc4651a0b1ef33a97f132d03359d4fae0191d0be048e054a20bac01d759c6a95c6d31235f10645fde1998311e3e3884b475662b849833cdf5bbcefdaebd7f7bf1966f96a07de8f70a43ad56f423b4d15336a13c30dbd477d27533c60195f437444f15de2a0e1f3fcb1115883ede4f864ceced6a4f3e0999b6e6c6e9c6ecd4763289724f3979f6848f24fb668583273e14240ed134097e7b783aefe02d5ceb832a00a236e23b28c1901101a0462625575306d78cfa4d24df34fe3855987d48dd53a90e0ea92c9b8bf206acb0e94f3db01647103fa1a3163bb1c6d5f279d64b294973b0f00a9b660ea0d002c85b40aaad4f29c52f75ebd4c47eee9b05f8dc98653b70961f20038dbe55ff4edf7760a834667a33885d5ced94a3b397560dc07364488712323546124c76c1875f55a24a481f3c7b4ce47fb591afcb977d15f0a524f8dd68870256444d701bfd69ca481115014e23be72232bff63d2b0874f99b6f5cf83b1492139ef0c4a47ef3906fecf27176c5c871de893bb0a478e725461da31c9878e7a91b89bfb47243a0188da3c5483937e2c90563305c916622fed2717bca2bbb4504ae5b0fc4a771f659f3d298acee80644dfb4f60845aeee64f6675b943a35d4699b89da8ca862228a3cc35599d3720c4c00228325d782bd10faaf814cff80a8b4b60a3e3b99a16bef7ca751dfeef1a8b7f7a56570cd3266a991b0a6e8d1625e5e82a2af5cd194aac4c8aec93a5493c78395248af2297cb2e197a47298137dc6ede31eb02a2af9c888d52338c036a0fc3a2ebdb1ef77df98ca2964c4cb04ecc69b6f79eeb0f0e48e9028b520fc3b3c414754b0adb5f2106c92a32b6aee40307193581482dd47980c01c63afd2c139836ae9f3edefd4da0a77c6d79eef164d7c7d4a185ffbf613364a18d2756e702a649da67a33fb05921ed5a0e0bbb615a77e29963a2ac46d66fa3e3cf387762fab6dc27f24f23ab0de5bbb5ce50d9bf487a067b386ee05ebec64b95269cb20f14f25c76835e111e3d10d0f66ce673a338458671e7112d5713d8885b97ea249c4b2922aa55e3d87fa07708f8dbbb5bf3ff45762a47cd0b34708ea2a748a0c210f9bd894aa80cca9795f767c38c2a2f1067c57d339b531e75965dbff238cc6407dc14463d00db0c95bb21d7981dcdbf16f5c9f1acf02798792f36bb151d5d46a22cdf4af705a24213fc49edc493eb0aa95d584e0ab1b58c4f18a551255510a3c0e87d2e7689090a4a1cb7fa0fd847152c97aafb79a808fd6f2f43a7b10f1c753c68927deee3910305e76ee09e7e791db2f213b4717e0552b919193c467d82f0064072dcd920fdc760f68aefb855d3504969993d0ac3706da421d3f2b99e47f4d0ed35571310f87a45bc7a0d96e8a4f55e3d66d813260b98dc996be8b2ef41b70c40a97a8ce9f8aa4f2cff6bd65b2f04f5d990a8e4e4a56bfc1e0033c0915c409e5743b08409d657692853a452268d6e38a1f77fb7637be90c744bc361a37907b11233016a5fd1cef6b6e83fb1bc8108e0866b98b4f556203635446df41042635ff4eab2c03b59c809733f7b23c70d1d406f8db72e41e67653c4f1eb1bdfad28b532fc11006be0032ce797221b9855ae3e2a7601db3fb5e31b0718b657796d8d734561ff34b348007b8eeb102a3d4f84439ba0d9c35a59307e05319f0848af4ee048653d88107efe349cccd71c32fc7c6bd1e4a22de24d469e43dabbc07a60832364713d817f0603bc0b71e05d3bf914d3df1679a478f9068cedd06a58afcebab588029a1d40a6b62f68e2b983f8e6ed562a6c8b16deaa07ecffdf6bac44b6226b96cb1df572ac4b72d4f1653cfb260c4cb8d4a49118b475b805b81f8a481c1086e647448075407c495fa53e10490f2f6b97de0f6c48d78a503a9b5157079724e1b76bc132a0ed5d39d8efe3f5a1a9957ad17384eb9e5686ff6e0db45edb9107a82b06bd74fb3fcf25c3877a01d2ea613052eda6ce2e2f36eaed06709f282ff7b8ce3a38dd819045caeec640db2d1d9788afa88d3d63fd47d812a0035a0b064102486a3343b1820813f453a49da285fc38ef0e1bd2008f30ddd3e4ab8f639a7bd06c9916db3971033c808a7b23ac868fbc9bcb0602e52706ad221cbe159f7e8196b076c01624ce8734ae855634165354de21aa5172af6a4bbe24fa600936445ab85d7264971f1b1b896a5811141a873015e65eb7b0b0b19defa93e09a40c8a725a98d4f0eb64b958b5d4eb931a2cfdbed143d8e8babf00ef55e933c0ee5006c5e790bcc070eade354e5aa58efa6d12b6ff4309d7465210b5ce24142cc895de06cf99b16c38ab08a82f873a83c6bcd198898718ddb89e0ffa1364536fcfa814be50d2d4b0cde04805bc7a70bd7c85f8c9295822dffaaa2f832dab1375bcdbcc925b7180452dd49a29c10f68a2d5931c18dbefe3c0f2cd14bde8847e71b33017eeda0f97ca98f00ae165e3f87ab93680b99ba3f45e9772300cb50f9e9c9bec664beb0e52aeccbf38dc4462febfdd5af39e132bd9ff12290d46e95d4298453153f171b4bf33d4c8102ca5d9c45724333c81756dec04ade4ab0da9c2e27c849c1bb41354807a6dcd879c01de846d756c3fda58478031539ee72977c54a4a2387ecf7871e25e36ac79b15d8a5809874e3a6e2241b2795c229b84d0e454a97556f420c37264826a24e1443edfcc8e21bf38a36a06b44fc5037adb2a47a748d904f9d04b4f1d870325b15478197bda73b8cfc12d944adc3513722d602e27eecefb1041f011e3753f8335e18b2d41ae968fdf18915dd55755cc4e81fe0d91f23849b0d6c93395e8ac3fc512d799bffcb29e743cc0a4dbb83d4dd8264381f909bf796fb89c3f8bd6e84bd89ef52ca3d2f8f59b7195729d2c99b4986f0e7a56f6feace6118dbe2ca42ef7c55558d90e4754bdb793eac203b8505600f4783733035594e82e270898157bd22d7ca95bbe6a0e73117013fb8409919266a5c9a80d88a97b24e7cc5a4af3e8d827c1b270b4e302aadda42c8b77c8096d83556f5a504a2db1ad4e08cd9345f56a2801c48799494f610c97e5cc6155fe7d2a45794cc5280a5b0e23bd859ad9879ad303c366655b4071e16c6a6436a92c375939e967ce1e7aac755dbad3c8cc38bb3f39763d5c9e3cd90c17523451a854def30e4053f237b97c460a4a9ae630ec517992c2d7979b8386f136e408d7e4632e1db155fb23cfc00ff30dbd48618bdc00010b126c18ed43131a3db9a7c0557c1a3b77c8006118e1fec40cc73be231d0f903201c5b51d01515c3578357f40a929052002cf3d4cc50b31a8cf768cf3c0cee563bc0cca9c0ffee02cc780d0e8122484b9b30dce57bc5cd9f551a12e21f9e96592ac5717a44292e52d976ffb9f3f6670a0b542f5f019f98355e162d896893788629563ab30298243beefff495696974b8577aa5d12c14348b0f3633d036c2a1bbebe103d31888bd164102b3096a741667ddc40c16e5ff71346ea3f72447a2db7f6855920e6fe0d60637c667d5ed172e87c51e65ea54aa2252cac40c7f5ddc5e3716ac952da687391146c8a49ae601e705dbd647945f53b1ef5aac4e8f74fb2a3e69840972dabeddbef2d07dac3b2f3446ac0fb6ca4ecf6a853c6e1aaa2fb74dc898e7832f5d9d0da60e43e29c34b216443863424fe39610070e5688411919755e1891b608ebec4dd52a4707e7916aa4b6722717ac4fa62fd11fa2a5e57e4dc5af9002c4a3f33644ad380f7b3d15c435148f39d84ecf4aa9b3c74b00dea99df343547baaa97872dd217b6630c609784c18b942d7b3b533f2909eb5fc21b12057e1acf5749111974f587489794ccdf65b87fcb5db8c95cc0598b88af340978ad7a4d373d37aa0517b5e0777049e9d0508c07306ba892cd59e5cfda90afaf678d837b73d77d22d318e3fe03f986b0811e080e28c39fde2571a86260685b1589e70e98cbf74eeb5b26131ef591aab955c3fde73b41178ceef3ec6e7d58671176996728038539ee51c5e0cefe9a610cbb6146d9e519193e88ba784964f245d7cf46e814c94799fb60daf422de123fb218dc562ad57539272dc7c87c1f086b03c74a959c03cedd355a7732073b14c0c557c6f71bda6289075cae860354749ff90246c3fc91931a58bd4c1d2e640745d2149bc131b9832af0f3f77b2ee7a3bd794912025fd7e507ef5b750ccbd1dd5069043e32d2b132137a8d6c5dc997668539a3dec7a8c40e9a0f94cbe48be1e0187b220b309b19502722a53cafea9ac482eac40529b0f093d7cc2b6c23fb76ea5e6a4e11e666f1960a6714b73e30a665e56041989003b5425bcd54073a5f07b1ce7a63f53e0578b94c40497b2d88d16f8182a1f96484e10b95693ae512d81f38f3b322dc432343eb38d0a69992934853cecde9e512b09d9106a051419d37b0928854d508220cbd2ebe4ccde5c695d0c606785df66120298d9a53bb7f91f6f9e5f15f39115b0519f1c42a0f98e706b3fc69be60f340696606238c1870c07882351bf0e83fa3ee20111b1cc798e26517d63593fd33f932d8cd028f264390036d0f64d05c467f449ea8b4b92af2f381c9034a37dc309d97c3411202b66d254e717aaf6f7510812b2fb609022f6ad78bd5a2e1a1e698b89fb73494284d73654e8271d0bdfc69e0c83ac1655f32ba7d5f403ca18659c4c257b9858bfb69720b32066bd528e750ba9d7d67e0277d7984e62f8ec9d69d05ef078e714a9cf2ad91f6fa25d5babfca3dee30e7a05714b4d06b8d75379d6f309dceee1119546733dfa882a0b24bb989f4b6887954e2740209fa2eb0e8b74af0c4d66303b855b062b0ae16a14965b1c2dcfc60e2b8efe7aa82ae44f8e8caf4834ca88075fa81211dcd6b174ab694ca6fc404bcb553a871ddaf115c553d6203ccd7c37e038c8f76504f1b10fd9f13190510c669de4e030e9da973534f6900f5de5f89635b2203660a5f99b02f08b084226d101f099b1f1ecbd238d2aa355dfc2e62805bdef73c97094ffd4a4db8e00389673bf10bbb3dc9942b3488500f410b27f374e59871f3180d7b7b0dd55528e230c151ef8c5dd8699c0317d813374129bc9ba16de7e509fafc7a568d54adc369b78fddea1b3f497353b8d55e8eacfc4db359fa158a646846d3f55652648c576f002cf7b22ffcf9cf51c8aa518c780c466742cea6e4c5b3b824ab3d73d3c3f66655807a17657b6e58ba4bf289771e31a57dd49798f7890177c1817c7552715eb53de9713dbd582d89b61716d7075d60384d711fc7cff8479793bf31dc680c826270820c2d1499159b7be2165368ee7e2453be9a0fef672427c13b604b17c2c23d3637575e9772e650567e5e322b970d13a5ea69a0e50647a1685b266343ecfb7a59a14e71648ad2a84010f6d796b36c1f4ac3dc213a6fff76e86c73870a6b668a98718c1cfb05d7224fa980b04ef61607570b51563d853ee952c65aed357bbedab8309b894dba16ca7631ce65c3303568d2f8a29a911d60ba01e2f611900ebbf88201264ca7b26a6ffe8d488479f7c048dd1d210420a341a9636d1036a282df1fb18eb7180e40680fbef51616e4cf08295bcb8b0da1bfbf5cd15f9f4fd4d5032671e4f3c9ce25a92e8302efd2d967b74cae540112ce8b7ebeef70b310641541b1174e47c403d3cc93ec1fffe0ce1f12a23b464b994ae825360d759952293798977550c57c64112d7b5d6a36b2c67322d97e5ca0df201fac18cd0f30de83bc7162e62beefefaa50054c48c6e99a302ae7e665b39bae3681155d9d441f95cc147e78f866e4d668cea44448e4c6a269801e6aa6d515b413cb6bcd93771ceb7cb693da0145c684fd05aa7b110c35fdbd9d6e758caaa3258f006d194a8accead08fd24e9e8e6f152753e4b7287427696cad3c0e981d83a3393be7299dbb967be42b5ec132d910b55b5cc8205b8e0a3baaa0f3795c8927d3b005387a58ccd538cf999e2b98983b09d02dca085020962a3729e3a4b824b6731b56969f8c04eb11d1fc33daf53cc63cba8b339a27126a81ea7cfcad5d457e890449ee816c62ff4763f066f5d70404ed1a933676f271913ecffe974e5ffe7f0f0acdabdb6ca37c4cdfa0db0bd0f5125fa2f74bc5479ca9d41806982ad6da08a94c026497fd52eb6439e34b9094a03a75d7aac630892565953ddaa3531b432632af58dc999c3189005c7c59de52d2c6441a96cfada64f304483149be6b4d646f2d378599784b1417b09e6e3a315d5bb4762aa6e13da147bb5fdf0a55bfdc7859a42b21f74b59e17a2df8ae90df1443cd0fc1401140608bd9cf2a3eb1a5f79041ceabf22d5d91a4b21fc82e09816832494f21f9209ad0eef0c0f14cfea9d15a9fc8eed160d1d518faa82f0dde5461c98c671c48362fc10684aa0d07233806a6b647f6f04be37e0e164b6d7149f7f6c5ee620b357c6ee542ffe2a49c6979c938b2d3f27058408a2d9767b97013dc685db600fe12ad722912f83838c724e7b84f121769cf810d37565d7bb4aaa2c394c17d657be2a4695836d97207fe6cc5f73cd59934b15bdf88125c963a978fe56b9c39b0d167e0cd744bb7104ea941adab8d5ac3db6309ac5330980f32ee5a7c5b848c93d6e170a7263ed457442171672e90131d8f14a2468239427710a8ea66c0ec4b51baaafd1485f2548aa0869699064143bae8733014be5b13b26efe7c428a690a5c08bcea72f28e558803a11203829e84d2b9fb9a374ea97c0699270e6f194d135cf135c46f2a25840fd6fad7e12b165acd67a1886ef2095d7fb8fb925869aaf606d42e9c5d7104bd722367f03b8a44b3bcfde393265ae2aedb36e5c5f894ecd46737b26e60f662c1460aa3398f806e03b9d7f5044c37e1e813b6fce92d3c566e4dc42cb5954a27e70d5389983710f204c595a93f35dbb41fae179f9483447afff762836fe4a9a480f69d2f05955f39e31a6e3b7f3b3aab7e2b8802cd97accae2dcbbbacce0f59999a4659f304fba184f6a27e52ea72e30f54ca19bd62b98b72dc9206f1dc7915e565065c9c8b6477651e152e033af9d445b5d4f498edd41f90c71c9b2a9d6f331a24015aa270e32d80ed1686b7bbac4f5affaf77b01d1778170c5e5b9460b9ebb37adc601d0cfafe18f28a9393fe38dcb4eb97b57ebcbcf86f8d3778d1c298a249cdfafa98be24a95ed13280cd25515c37b45a93059f472fdb66d2f036c1f2f2b0398d916c97da55b6bb0c337c0476b0bfe1057b09ec515ab5db0ff6cc92db63d27a3bb08b3bedc340431b5af92504bdc0b2d4d1a88d969478e5fd5947115bc69dfc61cb22534b5b1996a05d5331640edf07350fd9d1b316cac0f274af55d71f89ed356f8a46e78470ce901139323e275255963a411bab64a88179b44f281435b89dd6ef8a0e02944fd12e2aa5c9ef6a8b337eed6040cb855188c3a0eaec72c5d6a8b3e4c12c669f0bf3f9b3819068eeebca3fcb19e5ac5252862abb09a240445d4231fb2e0d5324eca3db5a8bf93203bc591668352cd5177b1c017103efead6c251ad96c77b0c17f9eabd8b0c67c8b2f1f44d48c601f78ad61247727dfe799e01a04f43853fddc3e5f8597340e5ca9c76fa30af9d56d5a37b003570560055babc7701430baa328a7cdda0a3a84cf5e6dc2eef234382bc8a95256a917c8f2ecacaa21b31ff848a79792682a82a2c9288368bebc15831d40ccfb0c366686eba026be3a6833d1e5fba084732a5396d9ee79bab2bce1eec9aa1e96858ba7e386519df245c651c378bf0158ccadb4bd6fe09ccc67854added791248f89fc46d1d97428878ea00270c51070aa3ffb567fe191206adf24cdeaff98b0198448f10a611497404a8c43eaabb5699e444a2e9f5fd4cbdc2b7d360a2559c50a9a3aa1dc6485e9411c0d920db184d83d5789c655dfc24e7e54d5c46eb1d711d9c457f0ad063c7b6ab53b24ec138de14dc9be48df4d6e074571474fb8c0d8f11072586b04fc6d1926c4470cd46a666c2debeaea1aad284f25c8ed8b403a35901b88e0ce192264e589e701f6f28f4226158ee470fde921355c71f7c1bfe5397989078ec70eb52e916398e915d932f31f274cd65c760e352fe136d51c87dbfcab786724fde41bb9916538e4e30fb966a1ef6f38efb28582385e8582bad13474bac489be167195a19c9cc162c50dd0a487025543b183ec5f51e3cfeb3a6aacac6c889c2ec2b4cb5ca68a53fe40c4020ca79881f3397bb415b6784c53246223c76dd5cd9d9e811330f783cacc7b26ce51034f7b560861d61dda20d6cb5289561e7ee5720b541a4111100c93527899198c0b1907ffd48435d21cf8aff41db9e3c87c394147d513c9be369efd94aa41b5865f3be3c41a5746353b25677967f326269e45dc958d4e566ad1e6f1b8c16ca208f63b94d0324bb37738689dae41530f31ccac1bbbc5189481893248d7f816cc2d65298c11c2d92e13f6fd33106009281c951ac4c08f2e1c5d9dda0808c1a2627f9663cce43ccf85be7bf65b5b0e0c6fcbc8674b013e0f962e91611ca3a75852eec5df1e044ac53ee91afb01e3b60303a766c064716a51de8c19da5d18dc3cce3a37141798a6a0eea53af8ce7af949804ad49a729cb42760e8eeee0084d2c6555410efd81d5e6174cbf09f6043504f4f5da4e167cc656b1c4b25eaeda98a28cb581049b301350b210d87e070cbfa49887ebe59fc6c6fbb953a5907ae91d65cb1d0148ee17a0da948b756970afe412cc5dfe0b33e85639fd873d695ae08425fff88bf86b226365b1cc02e9c90c82161057d3f88285b9dec172abdce19b4dd3f8c95d04ed18ad17eef8c9e35dcecea465dce9481aa03405c61e63915db1d4f7b037a3f252a96fcc8866000d6547ebbc9dd26a69b1f5fedfc80e3e3f007aaabf4c6e33662237e9896c4a2718f90ac7924179d77acbb8d94408392a503bb8eb2e64b9f4a2db15c421c7807a6c3b824ca668584540c728a2fe87f9f4eca0bdaac994b5ff3eedf46650e0dec13f524cc01f0a3447f1eda99433ca78e87d9f0d166620e30c53833dc64142dd367c192ca7fa85e41b87df03b7402781177a8d86b6b5582bb09e6323aa88d3a3411bf23ae69ab988cc50b3725f88410505d0f43323fff100db9b7a77856af05ec7024735cc69d4ee1da45b6aa1d655d1f44365eb0eb62e43e9960e67d4858c645377bebe54ca54b8a8e78c02ffa338c2be50f2a8b053732aa768d4d1f108cffcd25b30fddc19b2e1cf5bd1c4a0313a717b07a159a72b3cd4e9bc450ed0c3eebe73d4aef5ef5bfaf31ff146411fa56b99fd3d36cec7065da083e3d2cb6bcf8ecf7a604ff0258aece1aa5b96327a333b8875e0a61cffd9627b9391451d51fd45f1cd9b09c255c5918397b19daecc2c81238f1e87ed065ba9c94df050ac4dc8e74356832a7f30c35eee3e1c55388b3fce07ab916588fef60246ed110173c10f54087593f22c4dc5b32aa14d913e6b5cf27e750029996417ea534ba9fbabc9c20418f997e5711613cf91957afda3337695bff26aeb6792c61c4d28a9c277999ebdee08ac1be149e0b13e765f4adc7bded4df2080ae84cfa789d1640f0b6bd8a40fbfca844c173e122bfa386d1ce5adec0806f6bd77a278b420df8679fee2448caf7337448c4e999efbbb512ed8a2eef055866493c1b3c0f171565cdd66682ee59ab6641f88ad5ef4a512c3c3221a4d0313be59a6887f6ff12b9e44c01423d14cae0d677fc6ea07474d574b9f45f4c9ca5a121703919d7ed676932dfee2066375c77638208180e8d6fdbb13b83ad47d3c8b4de9ad66b808b4b901c6cf0f9f36ff5d519fbae79703b34f20ffd895579f0e2297bc6c54cfa0dcdcc3547bafae63638c1e4f0c5d17ccec85cccdbb1086df7c60cd8f2f81c1332bce1bbf9b9cf1028636e39e2f7182249d21d5cac13c37bd55fbad001c3f8abe4f6ea22ba9cb2aef5e4e1f1a946a735206d299f42d4577a397198c3b8479080fbbd19c2729c1ef6f243d0955b2884f67606c837795bce5f8d5f1f31181a8cf85e190f999a2b0c421e8c0bdae18289667bd89e4f47434768929f09547017732c27c4c78c3722c6143873b7b10cc2c2caebae6c7f40df5654301dd68eee678e4c6b258f18b934c0da2a556771dd597d2277609d8508cec5ffb672658069e68b1c468a8b3395ccf2caeee5dbc8da4d36846c5927ed6bd39e2379d01b81e18a2d8ab2cb41863904fd7efeb762ad51c4d4a274940c2ca62fe33e1030ecbef5ecaef4b6826722bce25b30ea979fb2cde9ebdd028c6164f2b7a859958ed25ee5cc87465ee6db075e37934c599b1453f478d6e021e66d726dfa67a3bf7b2b2499a57821d4ac41ce7562663bec0194f96d3d3a55e26100aacc69108b0167abb0a74d6a1cc79d464e1e74420549bc8af2297657e0eea660940168024602eb3374fc8ef50f11f59f6357ab7c96ada022b815df7d4a31b18716fffd41987eaea8c6ceb5d9daa73deaca1551b67e50e18663e720d6f804313928202a2c8013c08b75a587345871d97a6e012b25c86a41abfd980131b599586508bb4966676576464d14974b8900e4d67a63a2b9523a32b67d43dccc6baa7de719b77df30d495fd322510c68f22c2c26e68a26ea4f88f8ecc7db0732ef8d1830a665f298ab5b4e86ee13d2410b371b23a16d4b92e8ba03760ffa91b8b6c73635b79b04b749e058130d68ad98fce184862c4f5e2c968e06f1ece9e0d31748dc19c11eee5f7b7065cef471cbed3ca2578b3054fa37580e1e3174e6d40f7fa1eac7d860f40ac67f7bbb0f10d2b12be098b1473fad55af124af240eb07974e20b47678e79070952afd9f525307af9c9565f63fe77e7af6ab4cb6ace476f40f8285600ce17ba3e428adb799e70773570245a408a9a15fe7594886b3569469293f347183c1e0de82d523ba2b51b327b4fbbb2409e3f5ded15cd831c6198358e21aab685e7f708b53e1c70c60dbdecab1dbec92fb1688fdd5b002f5521ff43d89c1ee6b8e777b9ca0590032e059d19c2f324bc552ac94d23489ff33f8218785d58a4b9ec2d7670d334a778334de92f597b1e4cb8fd8b3dd78db42fdb148df95c488a3d5072f8df7b6233decddb4e3a9f49be052f7e46304fb8e29e4db37fcfb1781b4d53aa11a6d9b610149f9f29d449ade36fe2bffe0f7eab63d92e0f9af2ffca3b9bf4c59132130cbcb9c57d360079ab4876bc0db180c9cf69b114c7ff03d9f6b1b8878194f2896622b6c781f6ffb58159e4d0e377824da4b57fe84e6298979334d29d12c8a10c5df689b995faf792b0742e2f47f25784dbc0b3f81acc2b56815b2e4dcf525e728a7958326f985951251474d12bb59dbffa7dee217c1851905a9f5e3cd8b715a5f398ce7e4fb204269862c21f7cfdfebc1e6f1acdf063e01ab0a0c8c42436f5b06eba49b4d7731b6ec3c6c892e3f453549c3723a2ca42e16d9c8a5e97585a552ac82dca29183aa36da43631bee9c94b9ad39f84193ab371b13af2086352972ebe62c553f05f7f1e03ebecb4d203960c5ac01218e8576d25364cf1e455ddf1a57022d2f513c6ea82e5508bd5eac8263b32b22782326f5509602669871bcea9c855860135836e85ee5d290d6e63f8712c0dd999c8b9373461237fb90821dddb1d1d75674251741d633c2f322ebab5d35023d9d0b1237d219f3e5a0a8161e9418cc16ad177121dc8fda10e92226133815731b51ceff467404bb9259e9f0bf7ea9acd7b09d4734b53a434ff5969a8018fcb322ebdadca8fbbcc4655d83e3f7bc33d72af13cacdb42d685810da737885c655a90b621fd066871f2ed6bd1ab853199431e008493758629ecddf5dabf9e30cf56ba903d4f4b9d673bed62dac0261d1cab9fd3c3f0ff1f28cf1bcfa56845e630b0623489bf98eb21c8e8916e0ce5e349c8b764d1c3f53c1ebc7dec09d75d4f02f74457559cc169712513163979faa939b68a23d00367e1698e79be7b4a8230b0e64100c51580c35e8fc129d978c81f354b8c5422f1d0c47f45c2c76ed4f89fb81c14f9bba73c53b1f7d6292975348b14b26b38f5c93bf97c9cfba368b79121ec48bdc4ed21345b1a4838351377c6b674f95d4ef87d0f2c4e8090e78e140f6403c33bcf394ce47f4924b81fe5ca0c077cccd1bcde9fb7cdb6873ef4b6156b01b95169f25ca757d4e964592663406e7957322c2b89b0b88432f9adf4896335aeed0c502b1d39b3641574e958cc4c676ff0124cbaca52347f21c5e0eb27f14626e253cac03fa79890cbe97f57bd35a80b1d9310ef618913ae9e8e346d5267cf106590972e4794fc39599ec4adaaa66e49ecbb261cb0a574cc7940c3024784b1feab8591efb604597728c0412a0d89da46a88bd631f470c42187bbcce2155181f69b99004e584c7bb70de47b279dd8cd043d1d02afe2a8295dedd79a460bdc02eaaaba8cc5de89ff26ee15e58d3232ae214b6919d36803a6bdfa07f951d324e3f76515abc1275d13f0a5de3d2472ec02d3b1171f2f9c26b1029b1b0285c880c94ca41bc4e9b05fb6d83b271b64f8b705d24ca84dfd464cc32f0d1926c219504674454fa4a7bc2812c3f4105b6d096fba1aab177ec0462c4fbb5d84624ec327798227c0c977b0fc8e5617f9518b595c331be47676dfe5205fc90ce68c7dc1aba935d54e8ea570d8ff9784b4055f0d948fa8c754457b71b575c1b8b41384227ea446f7af0deb245cf1cddc03810cae961eaf2c645dadc4a963ec7eeae0084b904eaf2aa9872570dee1424850cc1901bded2f959ee605edb0573fe13b52817058741bd5de7ec3cacd4f00727ddcb6b036fbd1c6ab42377a203a5cb219a30a78ce2d93d58f387b758eb39dfa3e218298deb3a61f04b077bb09bfd23a5f03d12c6e6d6cb3fec2fa0e089210802b9d4d8ae36f023d2957bb1769a67249c90fd492c5ef4d351b7c4881af60fa0921b5b5d20cf87c2ada8fede4616c97c35f4f402a7ffc3a8b47464004128b6af4986e6768154a6e8af5a4d268341f9d0b74684459b18745de8d7441e19850b36d985228d3182e3b318dc81fdcc65d68c4662a885acaac14f2fbbfeffa786440b14e8a3b433b943b899ab61d7af3e4dc7d0fc2a2d4700973b59362fe5ee1d75a7bbe28d0e54ddb684675f7ffeaba78da8695c9fd2e0127550f5601a93d642b46e652f9669e99355d40fe378b4d4066487fea088c3d53fbdc36b55f37020678c35f8cfa93826ec5b7011ecf740cf6ef31c94d8a6fd1b29adfa084a7994443b3186c15e1f85fbb438b1433cab9fc98dde01aeedcb67951749e6e88e2eb610382c0c93c742f8a748b928e5f4f9c738caeb7e38c0f57fac044333d19a27bef962845db47900957dc8ff7cde1538d5e86d71affc3d830ad39181f7b31ddb3644d236a881c072ee9b516e00b539f620df71466f037cdb5a347cf9a5a70e1994b9a9c790d4d42f7de90f079548b9b054855d0e1f0c5587f096de07a888e114522148ae248eb0d3868bdd482c4e6870f167f5629127b811923176457117f551021d75148984bc06d86668f36856ff7e5f6c14dc08229e34c7d6037c74502fda634ebc6de4ba50fdbf79c8dd62556682dd59e9f5f861534a026ed01d41a313cba449a734e6d38bb9f8dfe7d9e95c9c718ceb5c1375c918fc240586a5df0b279b4745ded13f316a705e0d14d1c95dd2e238d1bd489de603396fbe85fbe5244bbeb81a581baedd1567328cf7db35d01507d851cff2722624326bdc73b9481a94606abbb537ea4bd7042f5d81024995fca24b16724acab6dd04cde982aeb8b55feb20c4fc1cbfc8c907e3767c00eceda4704ab3443410dfbbd38ee8337ae5d175cf219fd3a158e800a96a32a371b9781e3865fff7dba80a10d666bff6acd2464263bf92b738658f566f0e89a48f4d39e3101a6b8436da3c0e4e474610a342920b56fb75afe41b67bac57760d3f0af46045f1807b1853ccab0f5cf7d57ca25f963c1b9676228f7bb58aba62e28ace4f45de7ea8eea8d00899860b3060dbb20aef10f3a716965bab4b5fae9b884dbd2d00dc3a473ea2fcc50abd2256c87d0acd5e1de26ef84f4782e7bb508c1b2b99b674a3fe496d464d2e65693514bc2c5262c367f01fd89d01096e88e0b9f132be153093beaf7436fedf929c870384bc251a1ce4975e382b7d93f8e1232d6f4c8a503ed1bce4ca491372cd1b9f42cdad84ddf72426ab536af75340e61723c223eac4a88e2f545f4f197300b75d7137156dd7d40016c2053ce7263d8b3294c04be482bbf90aa08aa55e0f6ef3dd3838ab0f7d5ddd25488f18afb29b84f2d6e3b3e298409d3985e4deaf86bc0b76b6db92be094750e9a0f91cf0c95b00790593abb29db5fac540c058b94329b02aab142d5356219bd2dca1986f2a74dac268a31bb5a61d71df8e2158119404fff9e8d5977a58660c6a3721fa2f1ad1a5aa29360d9a0ac1cb4ccc25825132ff95b9b979ee1a1e9fae8b3fbc6e2fdf2bca32741b87aec2bcf5d5defea602550a0ebb9c4f0267290089f8dcddfda529704c5381a1a6a56b2cc35056c60f2bce57548377e5cd8deb856d0a1f5db9ec0a85dca093107cfcc0ea60ea480b04737f104bc3675654d725e259d72f42603105ab5c6d795003ab02ab8f05243a41f8a43abd35473a8a89933b7df02d84c872e27a96c2f46b13a4e656f33b0c719588d73c3884de5a2378de93420ecf133d23d16a47aaf657262e349bcd413048f8240f1ed00ec2dc9c17a8f0fcb9613805eff0655d836148e9fc81b123976a6ef6eccaddb4df3ba7562ff141f1a3cc6d692ef0cda858814b81adc05f768be052ae748c1b0a9ea30c2988703623eceb07799a6b8e7b74a90d28080d71c41095cf981b5cf8b48fdb099564987f082002fdaaedccca3e7f01f067bd40bafe10d97e6d33d549b061aa06e5721945302bfb22186274612579dd4b472230edf91ec6b66287985df5d8be6e05e334fe339e682085e662b3dce7a41c695c989d36574d23d1019d76fcfb0f2bd9068ae3871270a7a6e65cef55a58a067384ee0e2e8807967e92fcb4e19114d55d4f54c226b56391d86c604a9265f65b61415f976091cc0f576bd2cce843d86956a9d36064cf8a977660b1ef10f2bee7a84f55b36c9d0bf17430439b828578185a023ca4432d6260f5c8f543270c1aebfeaf701871e156675b49ed844ba5390a67c1854a95d8d874df1ef11cc1b963cec59bba650cf5e612d891272dffc414c68346d7d54aa3d782ee6f329ed7ff183ec07970c6217ae107191b0aeb100602c2594ec793e4c0f319c3c9e9fee55a0a954f858a6c3f9c8388c4d5477083e78f6c257a6c400676b18897b7a6edef1b95504b1e132c12cb88a1b07fc96191dd986d429bf51574778899a693623435fe764ec07d5747735287f34d2ab87a3b407e6474adff9cf800ef304bc0ca35b342b464ea6daa5fc992d3f87a2bb210d8523dba8c97ddb76871d0e196707d173a0a7b975fa7fa7c457e3930fa51bbec7e6e4ac674dd6e99a16a90e21d6fcab7e5d48b03c1fb32f4505186df8bbe5510167a6f4bee000332a65caff5fd4ee10fcb5575925b6a02af88be9d38023a2e16e32575b19c9462b18702b9d6c82e5ad53612d07728e4b78fc8b5b014cf4cc4841c23baefe5fb77f87e6543fa981e920d44d9a1ab10375d8fa54f2df2d8b41655afd34712c13206f8620c2f0202a3166e95776fedda43e095ddecaf7a32c566a2a6d93f602f34e496348dacec56c034a85a7080dc30bd13a170c07d557ff6de9c16582ad389d029b0ff409a84f2409f5dc26f32113ad61e9ebcf857f759bb80008b49bb0cca2e6a6857b6ab0d2d98b897853b1b72a3a3f493ec45caea999defe9134dfa085d201b3c8dd1577d6bf64d6835408f2569d572dca2e77608d20bcfeceeb3e1a970c375b8c79c7988e09a4cbde3e908f7f94e7864b7971807097982a2ec6b14e3a1f33717907c9da295c2cbe4c8ca8fa581b689297a2c8f905a8204770f3754a1c9c200e0cd72147e8c47395062c65e175c8851c90d2ec0f25f59f4f4a512c85b9aecdd26b2c619b02726546387b0398d96e4e813d89f2c0c2a30ce060f053769862ce3592d21f8193a3fc382de2e3b2c985185d20d4bca7faac2f2650fb0eb3ff98bc9553cfb85511d3561eb92dda8384b5ed799a6908934f52859eb9b65699d83355f9cd752438d77ea4c0083d07e23986edf32a9fe3c30a4af9e3f9fbd576a725bf29939f49c76f1213683532a8ef951a0cb006c6605f3ab2a066ac1f571521e553b3345f185efb7afdcfd1ce8d9f63a9ef5ef2b572bc73d9b88e869d392f5186c17eb90e334ffb20db302fcab71cf4b20a86720d0c3df0d43ac6284055317eb1caa47753c0749f80c8b8287e512f0f89e9738d2aa02cac487a2b29bc014eccbecb78c275de605e309cb4afa6db917a5c575bbeed0704c5d0e193f85531716fa8ae8d97a315f43dd28c5ba2657a70e7674082504e828d3aa5269f4f47ded510f352cb63dc413f89574ab503e6c84d32c6de7dbfc8663cc8c9564cd692f53135e383ce11e18746d4ee3be1c6a3afd28b00113747a79cde94a801a76903e622ef65090789a9614ff6bdfb153488ecfba5d5b30f1cf091c212313205ae6137634f2ba331c3d53035813bf55086ba8399a4486dc55d479f01950f277d76f383147c8b79eeac00de23c41a1507429f90bacb258e91a21a013d6f045a7b3e0bcd810b0e5e0d593f05e834177d9429ccb5ed78188b736d68625dfac43604f9d54e07cc23d8b8816d35cb93b4195f4708c07e59c65b1e0b9ce49fba281923576940c2a70806837329408b8b8144554600c0e4322424bc2cd03de8e56845e0a9311c1b51a44c79433765878d76a9de0ffd318da48b8ab96bb7323fcca017de7e8dc97151aead3eac75d86cc7f73d63bd088f492440a5c0d8995794992de7b906208b324d8fe08b16b4190a9d3bf103d7bfdd81f560edc9119b447866dad2cfa476f1bade570601a5773e6fa5f75e9a174b8a2c2db6be475f40982d742cd7b06887bfce74d2b90afb2cf92dd5c734b4107ec9d11c73442e57ff2c998dff3aabf28384d18c899ba162bc1d62409e96dac15b9c452378b39e925b338088c9b32bea3e48210ecc8852e204db1e5fbe145fc10cc3c490c8cc08e79f50612eae55470501ada104975853904ffb6846d718d2cef2262282cfff63dd36d11e398a511be4c31dc6d00b1ed1fb7681f2676b9d8294545685266bf9c6b551802da1eb53bb557d79f82a8a867149681313958f7189373e07420f1059424d95e153e31c66484afd8973b59f27fb3cd67b7cc89581dec75d3ee659ba8ef696fc7a1a8db3bbd1cc4b20256858c758ec0dfd20a5bd1beaba44b611182bc0a6b84a4f12ee1dc83d23bc2c3923127da9feb44096373ccb18dd2e6094c93a11056dd2a27f19f857907f7b9e10f53b86e1fae33c9b7f22d210bceef19b94b3587577fbb488b368d722dc9eed1e8b76afc5b96ef4612332983b682c60e902d9af0e197c7cdd56cb316430959e3ee87591b11c464ffb84006cb458a987457dcf8f19e8c9d45c0ea1faf7a66c93b502b45de07f924880d5c1a122ff94a61e24772473d51c8b85a8937d6f1e9227fc9c11cd9c30f3d5eec4610670c2f48789ddd399f6674104ce458b1a1f729bb44bce0d8641936f3c6d6ccefb55f1f95e1a641e6c823afed724131f5db522eea788432a25ddebb24169043fe506c43cf5d163209a5dd1b8f6dd92a0f19ef81893d8439bcaff72868f0ed2780870f05485773822f96bdc960b64ce01510a8f4d9d87146a3a6b46c398ec839f4f536fe0c78d706497d5640a72b979733250b28fb537eb56747f2769a1749657350f596e91a859bcaf0122d147989012b64618b368feefe8d17c01f632921d43c61f93d2d0266e66007c3e3fca6124341e5423186ccbc7302daf9d658f0c6c46045757be0b302da170adefc3d1b3c981e94cd377ef8a5db1c68d81ebe29292133c2ef1d5fadf28d9af84c8627c640a9a79a4086b473c916a7c015c0b158878c804c35968e5279b5e263521882e08856d63d602d56594e3dd71ff27353b58e0436897a182f9c6590bf56b947432b0a820f16fae9ca0ab1fa9accfc573997792d0cce7b66970094744f1751a4054ef2d53fc2544108ac79a22e91053ef2ae2502728a741d66d236c704ef180fd2005d0de1348b4d585ccb8da6ed6915e8b5639cf1d699905bb11b86652495edb3ba652f29f98050746863e4afc6ea038395f460e5d8cafdfa92cb118eef94607ee6bf3047c059582945b28cb9203eb7c11f24ea0e0f95a163f8e42c9a61a70b321c6f0d337c5bc97d60d2ad776d750e8c728329f82b03648efb1ee73a655e3718dc5cc01fc34048e4e92dbda3106cc83b817365bc1bb3482340d19faf89f1ea0f59e742205d268a920c4a34d13017a7a02196f096ba76d36de4744f33cfb9231c35b2702318f42c24ed644731ce70d35f2f845189a549e17b1a58403d46148a3db86cda28215f384bec3febb0d95e3ec1daedac5af361a904989e7e78366ecb48c2216fb46cf1eba2de8ba12b8dc081f9d2cae47496eff6c468d009efb5c114c89651850ae274e26171b1b91047ccfd0d45f75296f088886e8cce86f9c0516ef9c6a4f3f623cfd8c317814398baa0d0e283644f2704371522f2377eff7300a7d9acf7eb116fa264a35fd51e34665411f8b13d39458bd9c02b04ed870db2a5dee338c71e3e030709fc1509a3174cd45bb9483693702a9b812372f4d834e9717c7510db6446eb18624794a2e9d01d248506c038f79c0e391c266e754096a9467c82aacdb9eb19b6b7f65517891648fb88c04d017d87f17d05d6357ebdd7a9b7b8745f185135f49d2966882bc982f61781ce816e44f0b224b53af4d81aa987aea310e5654e4f80fda9c7a12410193f7f43e27b15dfb780ea7dacfff1e4ddf6b9c605f2f7849aa08d6fb2a30314e15a0e4825f101993ba7aa426ecd6564a982bb1f37be3071560c709b691306d0c14d2559a6cd7bb92f6475e2af5679a4a90e6d10dbe0325aaf5e78d4c351b57b7128bc19425a02ebea6679ea1140c529acb67b82bbef2c7a23c115618b334aca301150cfb0efe4d733c953b5bc685b5dc5758abf0f54c4aa4ab595ebdf446e13932427be1a39a42e3437bab3be87b08e7d53d9c22c6aedbcbb8a90e1de48520c76138ceef6b7c55cb46fdc5cf7cb97191cae125c6d489bf42c84fe8d3006efd4db9cba8650fe1fbfa402651eb69f8c0ac6bf6daacc169e97d905dc042588e9cd1684ad4742cdf7393b01cb6a4581145ee68b3f2cc84099d3baafaec572620fd83869ef723038d8ca59e2444d5f7b67a77fcc0c2397de718f65a3fa8b5610c87bdd64a17330c594a98fd953162d2e27319ecf75fa6af2d717accbe78c3c86c12b9e572375f0d3fc6ec700963e00b06fa8c6eaeda53c8c0526f2b1694b27b834b1e25a4b77a0bc1509791bc05df8a40d34c65d491264ccdc7dc1ce95d3ede2ad093a018179a49b5cb8bd696e89975a7f09abae3269cd378fdbccf9c4d7f0d751309470c88c000f3c26bba3897d6e50860a0bf9041bb0bd1d90db5d4a76089d98930212d9078c91b7d883e0c19e7130ad1e33e9a1e2fa0f1a89de94bf822b2928b28de25dc628d6e022e39d535ad8dfb379132b4304c695b04627a3e7d9623b197d95d894903957bd6e85c9d9d114ec17b97e91b4d1b26c3318cf3512978dd652c9b9d9aeedbcb8d1038cded297fcfdba5710c4a009a6f71b9eb29c2b83c1a74aa455475f312a93c4e5e4231dccf6ae0126b931cc932bef8dd50c7de2257dceae080d8b0bcb4f04a6c13d84d4039ea20dbb77d7ae83379d4d80ce4b9cfccaf6f80a42128d6132a0916e1f7bd3aedcc84e66df4382cff69d0db0c9228330df71287519e979f1ffab40bf4a122a9e69549d02968c642bcc5b26e52622d628a3d92621783a395ae2e8906d2064125c16bb678ea4308be2e5c855ce901fcde09cb4c0a15d20d6b0dc8bec13e92e031254adb6b6bde033f837f8542fad9ecfb39662f3499944aede2d1ff18a661d9eee624da4fef43d4b8f5631349dbcb7c10b29df8d2012d45b05d94a2b64101da34aaa8023d0b3937c817c0b24aff3d30aa2c3471a2b5690b019caeed9adccac1a10e49b7e34b771ee9f5bbe34b50ed055f9a82a4cb9fb018202ae1006ea0112ce7ca52fa7724cbcc3bf972b461809238693019e5c584d70d79a4e9b36879d249604a52c0f1c89adff3f8eac59fe9c1d0d6004416717b40a9b5d22f480fb526f947426168b9170344837c3ebfb367aa6dd229063dc353ad3aebb905cf08816c0c242cec6eec365fc262db9231c9be6365dad3eb1f08c8a02174bdd84b9e3316e5887e116f69c125cc7a1d3c75be9b649b6584593c58184b9ee1bda443cda7fa77dd7608d851c1566c45ce13c2d48d4a9315bf53ff8665f3c60224fc6897169e6e77a0cdfff3a75a1172ac7aa4e9bd88b2f1578a8ee37e800289c9292b59080193ad0adeb06c27e419984189177796468aa9c38d5cbd60a000fb31c5859e7a87a2118201f1d95f37d369ad0c093ce6d6f2c3bac9eadf364a2ee46badd552d557ba8c55f073ecd5e792952ec8ae3fe081652ee9fccbefb67a345eef8df7c483aed28f0824dec77564cff402a25ef1f98b4e9b05ca2e9e17104939e4f7cffa28d291589f2971c6e1b0d00f08a2e920b90bbfcd647b51564cccc7bc0a15da522d17c17818164c1947cd14c368d7fd3145560ad4492f75db0fd767f0986771e9b8e9f77376c86261e35585d5777c067fe26fb97b799103525ffa941661435d4fd29b199c8fb2b100ea21e8d42930f0c2ca1d8b5497c485586a05ad34af4406e29c4f58a9b1c68b0ffbea8e6a9a3662991810ffa391bf0df195d14d8e9af8e344f77ce8aed5f21fcfd7a9656d1b25c47da0e0b60b929be2f3de34ddc090ed044790721fee4f10dd29396c210eb8b4fe39ce01b29fdc8c479d5d54b4be9feb99610802ba2b97069d6fa7006877458c727211bce29ccb98d7606241ddc0a617cfc0058c60d4e63ba01b3cf79951e4991eab4d9d79c0d1c0d0228487aa1ac51b47e3bfe1694436653bd8f812afbe757dd01fa26a30bc69e2f424d4e1238c7b6a627663410b805c8dc454f918c294ec0a317a9a51217ca4ac053cfc754f45b69cdbff14c3aaada8c35bb0e8b5265fdcf41322bd21dd65ec272ae7352d661476d598eddbf224da4bad27c4752fd362e399ef7a9581f86d0a80788627bf1cd84a0d7e3213ab5cd643762ba72e70b25521a4001556137c957e06f5655881ca40a0a4d80c34fdeba9d29081a649580626b7ceb6d2a4e3f9947f4de1a1d26602e0a6bbf559d6a1e361d628c68de03f2e054a05acd1c4975d6407f8b4cd6c38c5db1e704267ae6637dfd4fdc5ce6c5312e78408bbfb64b725896972200677865d570c1579765e8586caa797a42e72d18766338b2cd1b8f9c5ae3246877c061f5c3f5adb035a12ac53c9294db6704a76c91e95681ae64f4d1f712a247859c323f0f662366dc97269b1ab931eda503bda3b7d349fd13abfde07d0a50369a978333ea82375580274158389158adecfb35902b8b309df8f60b53d02d7fa6159492cc636beb5bd030f25ee8d7272826bfc725d9aff7890479ab103bd75227ed6876c4a92274cbf39f446cde93ed613217d537e4ed3d6c4a1c44aa6d8a3e08b49a6a49878f917c404e544eb01144db6d4aaea9fafbc1f4d5757e90f3d419373d9a8eba55832d47b7fe359a9e26fd3a730f9fc056cc22c2e3c8f20c038df09ee77cc8e273624ed14601425a8165fa09c9584af1f58681f0dbc137b31fa1238dc7c11145fec5c16396daafb8b89b64e91e185e9425125657813ad6912ca15bb840dfaf7e70d1d9d6dbd8fd420df16fd2b290b8f7bada00a4026072a05cbbb2d596f6cb903f4276ba8a0843e80f496c9b5d08632e299aa04a59ef6e502907b22530623861d43ecafbee46598991e613c453b81b369f907daee78d072eceaf115e006b44d4d2d3e1e6ec2d78c7316435caa0de89734a0d2d87ee09791f37de83f33493c3617092b4c94417ac4eb72d9c105836cd6210951035067587b77bf2a56113bcf9c437203403e07f5f7b6bc8387174ea99abe95169f87515186688b8107e6f38894292c7ff40c7781d8790185ca255d65286ebdfde183ccba3ccfa125d1a6f7852fdf5480fc904987dd63c6509b91bbe472466ee0ccb99c9f1c79f20baf62fcf0b7b00028f944e98b1b1bcfb6fd5cb0074ad8024f9113bc20f4df6fc26b89507e462f67f1d6323940b8260b814feb57fafacf8077f53ad67b2497d0363bc9f0949f067afff7acca13943d0b842db241a751548556200bb58159e9cb6300f9318290247a9aaed12254d195e44196b5748efb08daa3ca942937c7b68cbafdd0a01f54401f2032550da3062de7c40664d4baeffadd46aa4a9e24409430f0ac2b18b35eafc7d3a4f9af8d3e2457c7b35c2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
