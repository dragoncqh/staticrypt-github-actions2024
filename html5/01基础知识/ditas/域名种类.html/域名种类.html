<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21ad114f80330c7b5b02d64a7b33ae138b7aff697fc7a0f15ed051b2934006054bf33d7061fae91b33b129d5d3e08bb85eb9bcdacd611f5195d290ec2860877dbbf0012afd84f9830229798a62c54fe63fb766c92f7bf528fd9d9edf8e8a76df60a27a5cae258cb4ba4e5588034055f32c398026b85a43d0309530136b05d03ecf88e3f9c96e7df423a3c3aa0fc02808daf659b63d79b77ae483f85051cbba734ab7c49f2b650461b63ef15a02ed63b0aa7870c3c86ab50a8fbe941e483b25752ffad96e08b253bf82aff3a912cb314052da05219414cd6e340a950e69099a5e06a91f884ef700e0902ba25322f8f4739a6c3db54f706081429cf99b5eabf603c9cbec06f150af1d91080384d447cde10a6c7f81953cfc0a3697fbaff56249c8cc4759ea77fe36d93dae6ea9469c9a808dc1d2401f89560255098b2b6fcb2c9be64af46f67144150d90304079e85f6dedcc7628c1cac0f4d9521b1e0d015431ce40aa6207f19eeee42cf19695dbc629cd0896b7d35353ef520efb4a44d17bf559c9da9dd061261a937c35f776e0a50795b5857d1c908143ad241bd03b6ec01240f0c756156cc7d12b5c6ae84f4d164c31cb31d4ad317ffc7ff50965ea3f24f9d89220cb479a202856f3648a05a3966e8c638ca76c86e87fb31a028e221969c6fc5b8a194d26fb8a90954597e17576ec04e0076975b6774113a8cc8c89818c3ce7c7af2442e5a7c4d7d2a86427ff44649319862b3be6e20864e9ce70ec3ac7c10ead746b10be30f3524b0f861aaa33a36008e649db52770d110850500a52f0d569b78d99d9c06df41662293321c4cc9c25c164902117568941b2dbb535340346d8c6d741eda14f7b8ef8630371d0f31196e41243c711ffedb6ab373be23e6d0020f8e2c58a7ecdfddc8cb0f007e4507e6e574ff7f9536df41c460ab0303750d683ef43eee0d45f4754c653e7a6ce777067e5de34786361dd285fd8ccc8ffb2f9822bfdf34ee8eba13b8ef2fed680e33d901027beadb8a57efc84d0f852f288694d79e51fcc87fda145afcfe1474b382ec588c87acf550accd9e8bd94a5199688ceef47299d97cc8811e18c65f659af1ec27209db206a5e31c5cd6c6f47b34d1c2085dad86e4e61f3e7afd851513df946d50e2997cb9381093e5df26deacde448a6ef023c44b4afdb3db05fa2a2a362b9512c9b646a1387652d88357b52c15300021606858da13bafeece10468b3349f070aaaaf99bf207d2c4437357dd17fa1e7311f6280c828b57c364a05d247ad03ed684673f0a918919d03692ca52bb0cc6f6ddd79181189ebddb379747abc80b62c98bdeffd3690ad861f05d8f6b79ee58b7a73d3dbb568acb222a1cdf08975a4934fdbcc5f6060e4f0685b8bcb17a6e0721227c1f762baee7e547087e2e0afe00b2c5ea4e7bb5719c3a7541c298e5dc9bf2ba688487291fb6e73fcd2ffbcf158b7076ca2ab6149f374e93e5e165e31f863b01d8b10ea98b3939f15fb3116bd06c493a3a34792ead880d0e186304c98e7347fda7d191c4cc221394fafdee72dd6f1f6579bc027a28e1e138d5e1076ad2370a2552baa17b13d398bbb3d2cea4d394219c84c369a992efeb4c6d00635ff7bb4a09bf91152f2246475a37588b5a12d85ae5fc0833fc3e3b3a1e662153f136f820273199cd291b7bfdd642432fd035f8fc27952e483367445005817cb2c6a5c7c47e20f121ac5e4f31761139721c06dc94f02116c1c3189681dcf05ac6a9ba9d070660f064669b5187c767ec0be0d0b4a92977097be20a775ed6e549fc1874924a1be5c5970ebd0edd1dbd2c42d743972b867bedc0d8625cd1fc78ecfd0ec125c7888766093762df72979aa92f5c44d6c7b35bd1a33cba16c1632303e61d51b1174a23d01a23b327551bd18e611923c70139aa59f8cd605febbf439cd9e4ed428cbae63ac3653d0e282a640b971e0a0179ac7af0a2e4a0550622116221d2c3359e68f7713a1e0f5ebe4e76391c81d9118bb5d6637c0de96456650a9d7ade4f8d49652d6c80165c5df83b61d9f7890fc78d7000f10ef29104a808fd5259568b7fa9f9b7146b620756f34ac1fd6ec759e1cbccc93594222e21d0544a6f3b5890941e9a3e66dd8b7e78b71bb561d12d120de777aa39a3d8d4d23ff113b3639b25db6e071af152a787eba13d50ce9e61645ae1c80323013bcb32b6932a66b6257d2427a0fe41b30cc170dc008c7de9a5d13d198dd620c41e8760141195423ce6313988752302339767ecce211d8d1aa86aeedfe06d37a652004d4d73811bd8740aa13fd4284def560a1b0c09adb8f34257d7905d36c2f589392521ed912c6cdefefa390ba11d019c4c33bb87ef30261e83e8d0a8594f3d4f313b5a2069302ec94a721d134b38378b7439899234086b5101cb5be91fbfc1682ff909641e10318a9fb28da1d1d1c44f9321bb9f6ad16d3ed6ab8bdb816c8fa022cb3e421d7481669402d5b3df92b7699a5b86a729cdf6accaea80bb3c48d498f16e1898de77e3d0b28acbe4bf1c16690c42d6cbae45c0d55aa489c89c68cffc7c5256d86198fb76948d8861823cc59e040a5c6e6050804b4e8d1b630526d67a458ad7412a503b61cafd606c4376a5ab0bbc8a906cfc1d89b48bf7a512a06e5b704ded1c5e69d5c215e4190dcb3f92562d44c5c3429a43176fbab1a1aa90142f50cc040052e32474a17448e5d50c5bccd5700f67aab30255afbc0fd7742a7bf449b26674ea6191bf80fc881ba42e13e4a4ff0cadf11aab37df75a5e594d26998ab484f1a847b845e4e1e397d99440b7bbd0c0f265cb0babeddeebae8e554b87e5170dd03a1692a393605e3f280e56a7934a39a5e39c746b88d75210082ace414d3374e40e9195de6f2ad878bb318a5051c29cf9c2c81d8ae364cb86414f11008e755c3e1e159c481d3ba812ba6bac07a49a7f60070008e9a22e44afab989c5ad0c5be9b42d467607424f8e2d1a6687343181a32d7d244362ae26ef81f8ecba31f1e0225b73f6c71af7f365dbb33779d8ae914c93c95e6d95abe54811dd6a2ec4e499babfce57f0ef91a5ac12e84801d426a59ba9a2a1a17bd8d0867644d9c3c76c2f17e111f7d06e094ad048d3c304f495a55316a1f97b8baa1aa720c907f54a0ec1488e26bb44d5527e47d4bbde4eef582cd8a4459183f0bb0eebea69d9860034e861b4b992ad67c328f7f37428049c1983238449778f360cf219707fb7b9352f830cf9081368ebb21614f9af1ec0ee45c72a85677cfd736621b1e8e567324d29c0c9fe5056e31c2a8f8854a72a2b76bd54de2fcb63b2d49262fd363f1ac252708d866ce27aa6c654c4931afd9dcfa389f79f3360d15c93e39b09b282a41b7d4dbf27eec4b300fe108c0ee17f08c39befb8d2f7e0b443f5d9de7a9d28d4fce1b64db6932c1608b4ad2c0a75dc037afaa9953ca7d2c6809c7c7c606c28e2325778de0ba5ee44a81dc5fd33f34a24389ba591a3c02e5abcbc579f1b08b8677b9366dc22c6aa3996e7a997f964577f1f029a42104261dead566ff8c18a960a59bd816817ac401254c9e3ba062a3753cba9c76657f1f40b4af92d8bc41acde8056b146dde28d8faf5feb3060a46a764f3d22d388efe2e9a90efc84343f36066d8c24b9b614b9aa8b9d8dd0726db353dadded0099786cce7ed0d48cb95b24510d71df6d1bd5cc059f20fd731339f3bda09edab663c284bb369ec286760d9e58f976b29132e63beba7274691a943f08b9221bfc980dd30013f34de8e00999434f5475a915e38220f4edb863cba4b44384ef71555fc3f751f98d2064940a22ce1baf6d4881cdcdde3713b9914bccdaf8b0da7d80fe45a4640c9954a882b913357c0366ed95d846254c40d16abda14d2750922686deeb7b8f9faf3a81d793a2d58bc7735111ff01d0c6dc443a352297a718a823ddba6dd3b4a478d6c68ae4cd566ae496cfcc3df165525879ec88832d1cd3062597f3920f959a7979f7c116a97acc3ff27d6b9a50b266fdb4de937c85128fb3664d4c8e701fbb8e4e4df1c19de93e5e48ba994f93ce69a65e5300448c53f469d8bb590dcb5e5b507b66fb9c097a66e89705c29219710f38706a44cb281069bb3a7f8fd9be3bf7be291c6d64e6ad0bedb5666dae8a040c938b8b08733c966cbed0bd658e450d66c5126a7abc6056fae79e35757c4a4c5bc045cadd733cc799cc60892b58abd0951ddbd84a26e36347b37e2bcb61439809aaa72cf34b07c1629e0d7149f426dd170440f61b98cb3385fb4fdba3331670d3b3678d757df09c341d5e8e453ebd37b70de39927b0a0620bfd5055c970180efde466007c0c903678598bb653da7f3e06f13890b903acbfc755e548611257d2d1f2efa90cc1084a13fc8aba6b873fb7bac402b73407e53ea542af22deb9950f657dde943e5d3d8eb1ed75e2f6cf8ad66cdda8d3f857651f56cd809e74c0787c2648005633ca2d67a6330ef665e37e42d8ab53dd3bf56850c9350eb59b4b392628db8d90a2b7b9c1d43655de9528e4f3b9905d4c91ff0276b1dc69d842edcf12452c495be9042f5a1aa13f829d55ee71abf3dfcb911c62c42d0d911857e09a4d7b333f8698e7c1c21756b1308a2b9cf654fdc83dd737024caf51eba624a65554acf2c765e849bb3aa3c54b193819e9bbaf187fdc09aa97302c60cfb909d01219404ba82bbc4525cf13c9fb5eb3137600c679214ba2e5183af161f06234c76b38944271faa25ad8ff71d1bee6f237cabc614fea8cd4fb6be87bba21a3436da3b685777feb09b7f4e98d893c3e17d8d50b96c95ff731cc617a272f85aff96a7b3fc44de3442df4aee17c5450d9ff52d66a49f3aaaf3c28f95aaba9b2b7926ce32c03b74b24ba4f8c8b9947b623ca7ecbc7a0373df5bc494acd7e47e034ff08eac141c09f2275d99848b9277b7e81d340cb921808543ca25ef5dd8e53367067bc968d0db10ab41a6a63db15de62983225914d06e8bc0fb701c5362ad9e10bfb2f8eee3037beb1048b17c7e462a1f1f1d59b3f86fc682e551a9fdac9cc9344d8c093336930aaa65e000d3da76c6ad5f3db77aa054a88019419df35d1e6b5a172a6611e054401a2f466f3154c333fa3db82e63f35911a9ae3fb8ac36881e8da1865239fe676cc3f6bc8e811f50b54fd18cc064458fc66431a0e5917f868c134789a99fe4d30da7bbee39cef93e88afa972895b68a595449efc151d3aaf6e42caeb718da842c362225f91f973f833851fad2f8a73a70fa83ac244ea768a0fc0c71eb0ffb154267dbf14076d4dd9f65b57645d1e9647c85e5270e423dce64e2055a4c6d22ff913a5ee0794986f0705cfc8eb414f8e75935badab8f7aaa3aaaad1286f8e07eb2af688c444b949b9d3b1dba08f203babe3b1d72176853a9b1dd3d8ad0ad97be22fbf970fa4e02eb7fe9025f67392884c92b46629f6f150af34d4acd85208d09eb3640b26c77b929eb6e7c0a3bd1c7e3543d225ced15ca5f2edff9375d9905b723186f3cdd2298cf0a1d55e8b420965b812eec3a2e3672cf7e821be5c4a2b1470f93ac73e7f35ade171b78afb06477a0ad311d544b8e5e1acf0697f44923a440fbdd410a74bae40555c7220faf296bf5493535ab912fca2730d954e4cdcf370fac86cb578433928a2cc193405e93bf25637a6c50c424a0838716bbbeaf3a716ca8bc46f91f1d0c86df9dfff5a4256fc8024b0c44cc7bc72fb967de326769dbcb1bb276244c5a8f9f3c4af4d95bce318469c57b7f40b7993bfcbafd49f29201255f3bb694b42d531caf97d69ad6878ef6036e51b7123084514bb6397c974e92fe771ae0a106f0fee02bbe8c03e7ba03411b04db7f497ddd874be4a6c4a6efcfc1d806bc7eeb8c817d66225f5753ff9b258e0d1d023761b01bcbd8b21bfc080c962e6bca35abe862f1a4cc83e25deef340d62488e5cd7ab0b9b90031ebfa86ae62b647c09c726f0ba00af3ee74cc1b83212311221100d246da467d92cac236360854b145d761fdf31830f28e1cbc25d2c99c98c34b6c1ca0e3cd1552b25a6cd372afedd0edd007a6ec14e3d8d840ca2e886a734e1f80dffef8486c9f1be2ab5e2624e9ce1a3474b9c07d0a0562608814adabffd85bd20841f7059c4389b7015426a93c49acb6b4f45c99826786b7f826b7a6e89ed5cd407f9e16f06fc8923b5bd1678fdb5a5dff897c732ee28f8e8794a4b52823b1cbe9dc47e84148ae9905e4af0d6bf27862a18a2e8201069b5b7559367ff9cb2cce91d5c7d48c381852abed4687d45b9bcd50b88a662572df8cd3d291a192daf799606060411f977b797713b22799be8a48a495b9ff0bfa23ef88dc8c68402f56149a5fdc654ce699bb7a98c049417c8c545f0354efa7fa1ac02ebe2cf80d14cd88ff175dd592ac3986955b725500a13a42cbffc3e9da455911a9f057e4fc4985d1f91ce2c11d3d943bcf36c33edc5ab0e0389be309da7468899ee5212020e82e723ac46cb0a2f5731814664bc1886fbc6a5a186a9ff8c2f2cf05ad4ad91a06f12faf46a4cc07b919bd3f0f7613f2bb4089057fa6e2ee3270fa774c0ca660f020455e1df5a5eb3eaac123fc2de1a81e90507b2da8e60dbe5bad9f67e3cdaba8e5887ced7f946127e5b7d4d3d8890e1afcc6cb318b4a1d004db26d34b265c8ca5b49d1976eaca0bbed665375e49036534f084d4f918e9057017ddfae7fc8160ab6abb32c6081435462483c5f0ac99b0ecb1002cf29097a4c867e0fe933078915f651a1caba89c3daa20b209634b13ba27372b18a0ef0a7235ccb3afed4b4b0c3c9123061c9535ef596ae26f195633e67afe6399381d23c5dda096b7b6ae6e86f265e5830a203e84860951e0e9556c23efed282bbc652a96a56e1db8cc1501bb401443f412fc036c672cb444aebeade54336d66a07d07ea7c3647810c5788d6c8af0fc77b7b0d50b6051e4fec45326e7160334cfa52e51e83e31a4895bd9ff73e9af6d7f4500f5a9642ac72cc2b4d3add4d41bfa8818c4255704c1bccf1e982695e7e3cb985f0bbe2779c62980a5fc5393e4c38308297f37758b713627a13f58ecd5482fe0dfcb9917e9f2bb7df570f2dbf6e810790927b287565d393bed0393db092143c05f47f0b076fcd8449e43f9b35cb4a828353b1ce38850ff53bca67270dce2d920335be2972965848c899b18eec6bbc7be7d598abcf5e1cd9953c92ac524329ceca9aaebfe2f9820dd3957c23b65c8b9a886814341bb0b9068a1addacc90ed4cdbd296950849062ec4c875fbd97da972caa07febe679f8069ca9da77e6d56dfd3ada87d01890a83a63e28caf3bd82f2a890c995631451a5f2748d67cc9c85c9d3c637d6cd20fd58bf242e93bbb844c5638dc0f7216f40241a06a1507a0c77a6dbce83ae45525b1bd6cd49a9985a6d915995b0eca4a5bdecb53fb03b7e8d144bab2deb2448ca1dbbc527eae4601c5600f75bf5f1f32320420ca12de67cbcc941e3c37c07e55bddfdc6e112b8f1d86d6726b117bb5b7af5724c11057e81e3924a025664faf97e8ccdc89d38b2f77b0e5b72ee005a260689cad0df7563f3856306cb25c7c2241e809870fcb4c29d0860cea330bda8cc63714875ff287a231acb4bce5e99d93eecba606e520662ebbabc2f93c79a0e12105ae6d5ebfc2e038d4202a70f3e656d7b07e0d41648e59225038027683d36978c0edda6002fee5751db038d812105cbc4e2ac737e055d4c487172f8f19a0887d1754aa72df70cfbc551f0ae4223b77409a5b38b69aa8f187ee083a96d512768e18ae8cb0a681efed8676d662ca4037f50914daf9af84eccd3fa861c41bf064dafa0381c0d36717da97ca8731b8bfc945ae1cb104c007f4d4d9bf2fb5f7fc82e840966fbb9ad6365ff792eebd2853bad72ed9e2aa19b379002f50cfd261c14f97c6546b68f902d309d0f6b2cf4ab2cb1e41e32695cec3e462433e35292660392262b63001244fb6de2cd4605008050ac7af924030617f223ae151620c2f9a788fe3571e3d45c25d8bc32c13eeafbc2d130ff395faee334f34fad604f08e83180034e4ef88d4674ae2229d896a708ad975bbaf78256c7fbc0e79b4f7ec70d3ddcdf13d0451de3b1eddb7ffcbe5d5c047becd41554c846ceabbe6f89d671b633a4e70da562f11618c61e55887d45589cce299f931e7706688568dd20208f69845995a99cdcbd26d01013fadd271e431f549d8d3d4c57f200b1b939f3503b622f801b31e1e5595a7d13beee78956463f44056f6f97c154e8ab050cbc2eaa941cb80734ae107c1f455c78e88781562f3a69a3c0bcd0a0db1e09688640400afbcd157be2e35d8343fb1ce28b34209243605a63f4e1031db8eb1ff9d4d3140b7382d073e5dd4e9f0e6a1c7b1b3d856fabd29a957ef73d408bb021a832418a23306b4fbe57d25533d887996aca0725f7101eaa46da367cb63a659ad1529634ed38c61fd1ef24ba8834b49717c71b7b9ccff20f1fe4c24830c3ac3356b97c70355886facea5af1a8e33dc06181426f7f1d4c3057534eebec4a1b515a21a6432b2c9fe42d8ce562d49b833a910b74eecc195ca0ccc044bdfcc7f298ed607be88794fe8d3b5159806b617f0930fc8e29a0f0dde9ba40931469a88aee54be9909816a576eaae415ec0955fe901a261cf1bf49631a8ddbc6c0b997428d37facca4ba91d56a55eaabe28ef6ca439ae26c9e4986aa4a5c7a12d3d94a5f9912408285d4ddf9f5cb700cae06a1d366b5adcbcaeed7ec5a09ff9aa7f29089e7d49d1c8898b755703cd788409e5f618bf62ed9ab6ff3c89d8b8e064512b4e6bee4a54f69df4276a671a6c7587cf42ccde866f42de693379a357ae357f61f795282a65310977d36219e4577a525e1d664664c47003478d4eadc3bb0e539b7422fe86911c484ccdf6c3757dc213401bc012dbf992ab4f6e1b3c36ef5a3bb5687d3d9d495863f06f924f9381b9dddaaa425eea767aa30345227c6fc789f603388de9f16165f0f111301412078f20d1f4b90b8d622788daa868b6c20de5b3be9cddbc8edc63134b3af2940545509f343a76df388c258e1ce83a7d26173e546926d8b4e7970ba2a75106e34a1a949a7d11c157889ecdb3b0adae99b89f9b9ec90fd3ad8dc2c635f0900571f4d28891049560c595c1103208b4881dbf32343f7e6b55bb35eb815f23ed1dce5d90ee1d2f2b1b81a31b90f28ce113cf890b2bffd39ec2bc856308dff5977c224d9da22eedf16ada6ef502f9b9131b1013ec3128972aade907fe8a3a27083ae9d0ea40b203e44b9b3021319db00e6c619b275d0d093a2b918d400b68b186dea17ecf09d258ba964691fc80fff7d1664678d7fa7e075908d29797fa50aee92c1b65ac33414db1d032bcf2556f42dc2ccdf50b281b9e9423386e49359006b96490f748b519174d21af1e91762962e27de170b83942e71be08fc64fbd7c73967988cbf82b58c3d0317dbf4fa5a951b6e643e7cb731497fbdc3284c13b8a55f6bfd089eab757d7411f14cf9d351f3eb8fd2270010ba466ddeab6606838363270419e26661a10e0b170da21497fe42763bfea05ca5bdeebec429877371dd3f8d160c40b228a7fb7ad6eda11dda284f8d8a46ca32665b0e277b3abfe23b767ff626fecd2b9cff3a35d45c701ad41249036523f7f217f0ebf6592d9f6c1696fc388fe8efedabcc92cadf899ed18bb8418214f64aad0a604e0061f1551b15363476f3f0717f77d3dd6c6e95c350d63abe9d89894d7f1910bd8fb58fbb5076be65ca2f64bd475ed9ae3de286fe95de95c10ed309fdf9dd3bb4a957a4e968baf2465e8fa3649d3192718de8961cee2d3728bbf0cc7b7e69a096c9c9d39128fa2db27e70924dcfc5f05cd271a7403f4e63fe6dd5e5a3470e565d6fd7623a2194d00e70fb864c26cce89626cd3080c5cfc23689a734a9401204135f5efdc5e2ed3bef450ba2a165464dff3c6bdc80f97598aa081739fc485d213dd9177b98f51a57e734509f08044cbd7fdf510b15a246ef72c39079eeefba99333eb787f74280e76292a785ee1fe590a723557926a7608aa73173e90e2117d499ad39134c77ff3b21e2933ef14d1fddb1398c7bcdaf606b88e5031d88eb071fc300d45c71816423e7ee08e9b0915d540e53d312dbf66997f00842a354d9d8d95729288e41dcac6eb4c4ba04713e8876b1af3783d6b5bd579dc1cd5207fee135d876ef15ef09079239c0e5b7974585f4440b120f4ea11b90d005ba55a58919439853f4e09f0e82108857d07e710411302dda70e47f29072b528164804c2735b6bc7f292efb5b90c4495c86e7a9740d285214ef629a74865d7a1293a1304144f141d6ec5f3e93c9ef9fad55ce703e302297b64372ffd000f48ee883ae65b1dd5701dc29028362d991b5b27e05fef36209ff21a15be52cb93bb3a19c6e1ea95e5442efe4d5129b0d7cf0762be5f99bf67bde4192935f7a404be69d403e9a9617f99deaf7172593edf6e1ea40ac6a2a2271d421c1a7ba836ac3ab80c1b78b09cd1e3663e6664d80bb03d33663f1978af90ac216d82739fb97b5fe13f3a681616c599ee6aface32449980ebb35dfa05ba6114830eec0ab6402e88dc0576f26b2d1624d9eed82fbb354f19a467f8ba5dd5953b952e2cb30455a7c8fb4a926b8fac76b8e45d54221ff18d5ba2de039e7835dbc2a10423dd0eaf4eebadedb51b9bd93965aecdf241949fc99ae160ebc886e7a44e7db0ad26aeb9f7204ab0760244b050164431cc8e2517b408a97aa5d433a80142a9615de866e3559dcff63ec0dd664af30aeb03a1deb1c68d03ed030cb5175f4b975bc8e423277ac2e410ba760350b8a5a7cc215f586fb8f970e83513a6ecb45b8d46acd1bc8b0dfe9218cfc1c465606fd15ca007eabb75f17cda98b08913120dacd461f12b5afc8b326d2185d18b2535e20f01675762d3c8840b502ccf324a0f4cee321ac4a05dad5f68f1d920620b936689a2030df936ffbece2e5b36e3d0581b4a4a07e100b0af93b7e817c4a49a947c5b4d55429f3af21e944481f5e82f7c2bd1668f3ae349a10d66250d6e51123d95156fe423273947a3888eda383a12eb1b0bfa6a57f7e5a45354704ab8d16ddeb246ff22c669255fb55deda05aecdee34e9659d2710f125b8f9c8073179c55c5df23d5c38d4d49969da98ed2f925c5d99c4089e0958af0ae265b15f9714e637c1b156b79f13922b3721854139feb228fa0cc9d0ce4c0ae19456e1c4a702e8a22f6788b558621cd99b0119651538e21c13a8cfb1a77bf5f17f0d41e859d4bbbef45938c5313db26a54ff06221138be9b960a53beff938ced7e761589ed1184cd68ec7834f1fdc61453ff1f083824e4eebd4291540a1af3981089b2064cea7d12bf37ee7524228f131c2640711027a25868f94c9f2a2a8cf67306de6397fd6cfd60b53940dd6eeab5551653534ce78a4638b7c4b29a154e1a5b1a119d14b7ac749318b92ac4fd37e80d7370e3529a54eeaf8cedce2c27210e18d801fb6692fddc147b782e1ee919d81d8a550237bd4dda328effba677cd18332c641d08575f7a9c2de11197a78d3ce2df91afd2be4e7ff508a0a19269470fc9cbd00aea8b1f37eebffaa62d6e6769650228694846deef1ca2517016ea1c22b2499602a1eaf68b0ca686b56df85c8bbba3fcc0221bb7c5191488d8c0607091b6c9033a70252916ff97b9eeb12ff46189758c3a7b7ef2009a645b563a5ed624be333c6f2ebf4cb4d583817f828fe8330fc229284b03dc5ff420b47b3d8edba29bd3ab712b2b7841e367e4e0919a0be0debc5cbba7bb35da4c63b9c8c4aef513842623ac3d70e06c252dcad60a2556e962a1fa537afac3f709581840d0ae5bc862b1cc083bddfe2806ee9e4f481379b71fb0891a6c7dd9de5a12b09b2589815589c48b274aa175494d6fbc09b221bfe8255733970d3ff0f4f22019d1291623e881d9ed66da4f8c96303618c1a60f12f16ba5ef6fe01ced5f6498f4cd9dbbf375fd69ff0036ec5ae528a3ae2b91262840a65ca4895e0d60fec1f4d3f9531e8ccd4c560111f951437c5e61b7e8c41df8b6cbb5604e76cea34c8d1794fd14f226be8d34da35a466b31395a03a192e18ebc0fabe3c02e764a84ac3776022ea6661a7eac9ab45b24cb7a60079673b3ff360798460d33615b4b096dfe8153ec8744895b38b4581e9893099bed9b563cbffc4bc3f5beb68db282992f1ca6ffe73ff36dad776ce2f150638d2e0b8078d70f899a5c6684129fbb836dbcd4a14cbf3fe5967e430b450c2f084d7204129fe5e3a2af8ff2ea67c9244440c16dd0581392dff6a575586bc421bcdd42b197221d5f8b80623973b79e3bc822e3e3be0dee0fd8c50a30f5683183b404aaae5f99643e4339a06592da3a6d48258f18fd67f585b6bea4373d4ecaf5ce8bb9b2821dfdc110c8c8ec638997a08ee3baadc27aeafbfa06ba1b6bfec19b2a2e0995c1b0ad572ec4bd28e565710df98f4ccda53c83dbe997e96c48d059f74e00dd956a9aac5f06c1133962e1e0d1c8f7cf8cc02ab7c2f6c76fac3f6a56ea6d139b005dd63f7977c839c0274f2d65881c5a45f4cfc361dd6b58518feb867fee7c58ce2cb6cdf262e96a6434a9945d38018af0e9def493faa35e0abf2474de076ee3b5b0e194bb191dc304398501b8ca193e82ccb836547b4eeae5a83621fa17e054f31ede0209ebdaedcbbb646ddddcdc058a4ce20a76547fb30ef3a465515d1f7df72f1b8180600d68c3033382fab2993bcddcaa576ce38f720ba4dada25c5d1fc8de3e9a45669952a40bc918116d1b1603f4992167fc94cf7ff4864716a72623519981b763c30dd6d92f4b563756c64cbf5ea0cf3de398af468d7c203555c9f715ea87f9a9bccf881ed42ca170bc210f81db7280a833ed51f762bdd7f62d497679bf9e4644cb1da11f1801986640e52ef5fd74311bdf002e8614f03c7db55012d8eb002ed64e30ee3e26178ce7187289e94a08e1e44ce1bc6d972005d841b7a9a1ad8e486b53afb3af29168501924893eaf771df5a2d43f558a9760b98f4398d0b7a47a4b550e363dce0ef1a910868a9836d97a19747ab4deb51b0e49419d39249acec617acf83e5bbb07cf248d7977c7d88895cb220866886797b12cd43ccdc44610f1c7648dae586a5e1306219f333fe12d976a042b1a80db7114dd82a6dbef7ff4aa65543b792d9b95f0f00b5238661eb4e901af880c961304f53c777c813ac0bd0c7e6d257b34f43dee362a4a449fca0e46465c37cabf17e4629f34b60445ce0f8dffce0a434b9063e9baf7ddf72a4e9a462333d65cc4ab04208cb869a7bb67b4eb2d51cbc845d3ece70eeed7a470619c14f8575abe4705ba865a7f8415837eaf1113833b050dcc0d583846b649fafb7289d33cf9ad99351dd6df7d4b6f57d579437377c247130640fb28c5789add3cda9e3e8d5d82bc64de5ac9557cf6b05c0329cfb4541e8074b638bcfe4db12b8c1e0872576d6d16d570ba97f722efe7429aed758514792e384629f9e03235538cf8ec2f03e330b7e3b12cd4ccb86f162bcdab08e34a66ecba2afc227ba14e211f0edd67b7b6202d05bbc8816da8af03f6fed411310723481d95bb2bf4142cd9d62c64c617ec718d669d079363765bbde02c8a94a00482d795b465aea446845bdf436318b925e92507127e7378d173319254b3e81ce66244ded8e7434815cd43f9a28aea51914721d9737c6f0c6a7e23584b584969430524187cf2396e33488d439162a3b566d3ce29ba83e217e55dffe49a1be8184689dfae3e9786b0bd9b1d8c786584bc8044f0adc784fba04da68881a3952ab8fe36761f2398cabb9db789d1faa1c62574819e010f14d88d9f89152a8faf42fb0884ef6869626d145494f00380bba7c38aba28419a9d30069d28157c06a4f9b48c95de236427348bcedc63a3cb48abe438e3114c9b0f9a230c12ef4645fcffaf1bf964edeadc7f891046abb1652f1539ce5a8c040fd4cbd2941794504918579b55288fc0aa8b49f98ac46fbbaad58065c165816c88283fe0cee77a3b110c73bfb0deabd004407184f736885cc8d50afd4b77a4996ef608d75a1b2c69ea3c4affd1d50ed6df00702767963bab39308c604fa6ebeafead6fe09afd4b34a5804a667353e275579d060b47b06e3eb111ff3651ae7c17e19dce51474580947b96c8f84e68e6e5b256b6d6d18057410a1c4e46eddf8ec05d4d9416ea62d8d3d3de2d47e4622cea44f2b2c2626e330634b287575302a6a58d805478ea8bf7c8bc168010404c4fe52b34018b5cf98da7c0511af1be48051ee5a1422a7da34f9bf4efdd2b1799bc3ccb73584be3811296453df3c68e70b0d6a627e384dc9fa05d1c42f25918cf69292ba6c267617d85928e60b70a294b85c42ce49d40ca410b66de472bb7a211a002fb195024e06ed7140873d0ed2137fd284b33c8578bc908d648da22f555ac633a6ae45d6377bac129a2ed1cfd3b592aa12843242e4c2f07afbbbde293ccb2dd0f3dfc3f34b4b8edad85ce9bad08d241a4d3675d0c69863f663eb17ac9f37000b26681bc41ee139e776973648d8f4e33014c74df3a0310f106dba0026315d2d5535af96d3724c7a6545f05843f81b5abbeb4bd833a39ededc78210ae8f5c88111be12976169474a9f30f18063d286d4b1f66a55ceba9119ec3f22c06764995065edabc329d7af99c860ce69f5bb4d53972c7c0b97cacc49bf59979e0abc0ce0b0989bdfeea886637b39bc19623faf946528828a010f6822f81624dfc74703f70a7b0def0f4f27858f340283918bc9898de3fc722a0278921c1dedef05cd31b9bea47e2807d822811cbb4b0d7b8b7306c344d31f246d70459d9cb5ebce93210f783460740d0345387c9437500426153460b0db5be215c4005d33a3f6b2391580737521af45ab41ff60ba7069fd1b612900d8c56a52a3c110c109c52ef256faaba16d91087c82b806ca06c36286159b46206a2c395626f69aee285586df3bc0395b5228df66e399a1c372e757d9a71fbe1fec26b831cb1a143ad76a91d4dbe807f3e475d321e8602edef80e4ab78ab51b2b2a8f71fa1096b52d8d03e93d40d96455d6c8173fe7dc3d925c4acd0da51aeca2acc825d95cc77a259505632c2b4eb9fae3e22f87916518f7c6743225441912241d93ca3478e97b5d8a5dca292b71fda38e02397814cdc6cf3d3ba4f34ebc81d3b994b85bd0ee43ef949bc41ba50949f43ba5e09646cc5ca3254ac422e3def915d72db5473f8844bd3502321e16bdf2700b6470d8faf3b954b3e04bc7552acfb1a3591ab9d898793c21498d32f24c7d63ea7817c32a337db4318691c706558c3609b4dcb91225a1e4129bf2ba7e10d9af5cff861701cde528481857a48bd078da06c02e904a35f8ddc5f73a735a8b4d38316d398bd4f07a4bddec3ec11ffcd729041f6d0a2cc23a8e6b16b82810842e938d572957d8570338920581b18791dfaff0e8c7dc7b906f4ea835e43e0eba59982ef3d5454c2d9d082544865acd4383da3e8ed757f2b017aee7250a94aaf4d414c50e7075601041b8f7def96a09488091fac2612db24733ec15a0df79238187e08121051af11044f3dd1f74e7ce71805fdf947e84585656b64a4a6a6c41895867413ec1734d8e35229d70325fe322ee50a8efff6b3d3b4a7a8651c379d5afcc33babd02dd0a1104dd70ed1986393c6f7c68ac5afc1486dbffaf85f10478fcf8ee6f0f085ee60c78fd7643b8f92ef6bd8bfb0d22eb29368083bcb849ee57956bb95603cc8cb98a8dbb276b96a7cdba24400054e7d338389c51c20d15ddf6c388c9bb20c141a82b4885260c3fd4caec34f441a0265bbcb2ae7f0800fef9851e1fcdb3a887e5c6af324c3757b4ef647c3b5ee920a19f0748550cc32a38be3ee08ea6e5facdd4c8dc57eae583bbe13ee2e42bfe200be7e7eae511b177b524afc6fe7835fccb2adacae2f8fd2f618a189b2b9c0a7f16e153bdaf9361aae1b011194a7c192d174d0eb525048c60b227faf19da55722de6f058f89b0f31c832a063b010cecbce4fcf0b77e7c02bc10e92f15502816b0c1015bd42a78c982118d1900e430c4cb08149d6e1bdf55ccded957b15f95ed83dcc2091570c6daad1b36256ba4210e2918f7b3413d79a9267a9f3a772bcc6080999f257e4da73930b081c5fe4c9790ee652e6f32ec80dca3b6a7e8fd4ab314130bc24d8024cda54289e23c5855ecd2896e210a12e960855772b575d01e03e71ac86589b8ae6f9ec6cded5c87fca49f8256f0374468536a3e87a6cbd752540a6d3f605115bc4c8d593a7492a658edd202a393d16e832c116b2e83c76d470a2a55e55851438999f5b557bc9437ba6df4bbfdc6af620c0b74e99c7953bb02c179443c7e9aed27dbf4119b57eff72d32585ffc56d48906d1175c9541acd7d5e75f659bb24dfb60a97c52e35e8cee0c2a68c25b462383667e7dfc11572b197ed95b443005d67b72b03482e18074321ce65987e7076d293cf394134d87f3e20c9b5a9c485003e25d2570f81b602a38c17ee9c8ad7fef8729d937969ac2586c25de876759834dfa1304e5a574d3e69f97b86cd9278dfe4e2fd14b63022b1c5f880aee0ffdbea77b16e4ebbccab31a98904519575be1baf1d55350e5be4a7083fe8e720e8b786efdfa3ddac2ecd1eb3483020249b4a77fbc79ffafa8326f8ac0f639d42c90da5650d17c7586d13abb2f8f197fe5b289b6fad942f124d71b6dc2afc35cd3c7f03e1160ae5ccd1f9fa5a6f08d03bf1f2b7eede669ace7d1b4c4c27f1588ee6e4772f742c8444f9631944584679a2c8ad00b08c4364530534dfdd4afc24926faf1ab6b4c5198b07c0333990ba9383a476dbe53907c6d11f2129982aadcb1337372cda2de75221ecf67f8994c568678139fa79ee7aee1e756dc9fefdb1d6f7fbf971b4959229c1a3f7b384de46f617164dbc16b52842726a0141bfb8126902a28e4a4d143ebe7b224a44d9e41531daaedd503c4247843e73b1234d76f16219957b2d2107e7c7e872494b808392efd0f079c8322a9ff7d6ce22bf6bdd196d979146ff3ad30b654a1655cfc9285e146f120c62ef65a394df2ffa4e41f04598fd8ee9184b7fb2dd100afa52eb9c01e37c0b455f915dd6c31d23d948791904c287091d371a1013628d9724494337e6f9ab04dedb6b45503052d34040d795a36208f23748bee7bc510fa091912c76b87f0d103b610101620a192e4438c052f20aca8fb15a441d886982f4c17601a313cb98e68e3597074ed625a19e2649b54c957068695b14e224af859bbd5f3fc63637cdf4efcb8ea01fea5cdfdc0efb4f11911431976cc1fbcab00ca1d4d3dd968fb21dcd2608cf6fc7e114163a2a1f5f65fb24e1fbb8b3fb0bd6beebe08efaeeb2217ac2cfa01c131833077fee05c41665306558dcd988660b5e1a33795cd742580f8d17e2b8ea63a4930b4cb7469f756dfeadd42d83c0a45745ec83bd6b7b3f3d6f00e29d618ecd5236561d20bd04186c5416f5b6429bf5e694bac54023a258138122af6e752e6f6852ea9b5b07f497d32b002c72d9713eb6829c3d6fa113848432b5edb994410e054b9ccc86a5e4286d6c85e51e387169a1799ad0a949654f2d0919f4bae1e8f401c882b27f9f4932a1b21b4ab208a5fc5efee4257e78d71eea7579d48554aadaede7138267f4178de86b5370524455bdea77234344f036ac523786fcd478ce3269c9d73b787e6e880d1ff4c791a5d2a8645df310b3bda9006c90921c5527f844d1693d478eb7bbb2590fab86ce8d56545f8f7ed9ae03ab7d2aad202a2832c0f2e525ebcec3f364096d46036d47f843552a7a3787eee3c596342faf98bfa09bde6134ec5e4cf8ac76d0f3f5b6fc87783c0191ca931548571da5a56b615041b9ffef736e33de25ed3a901c6c3a39c011687dbdc87301dc8f8c61263c55d8f4e0cb786f0f643229ef10e6f6c23e0c5b8dc5ca3ffe53101596efa1d6e99f2b2991739f39b7e9b4cd8c688b67a50837284062c4e8a5ace50db4d74ba659ce6eb819e49f2b8321f2ce8b0e93311b1b6045f8b39799909a486332290db18fc8f39c7bc60c23bfde705b12b762044356b02dcb8e61c528d567a60670879ca040336bab0943172b5175bb18eae5bfafb198e4c87f945ab7377fe9928bd4f4bd9a3ab791903ee050c3a3d919231e2120673223b907d716fe110008f18c375f7c3ee04b68478e7df2e7e007184ae2fb22096b599748ad34068a02d0edd1a63e0df505715dc39fed6c910b890611659226fbfabcd78dce0a1c5310acae5ab5ee9ae2e8ceb59961f7f04b5973d0f1a1ce40907214d0f350ef9f873dca329fc95bd88a8904cff12d4db0fd45fd57508b2adb765dc924c5dce46852d2200fc8b3da87a1bbd0551aff10ff51a1ec042ef0404e64c8c3c34c9029692bbd217fd016735806dc4ea2d2bf65744dd562c7bb969d31e32e3dd987165c29ff5365743f8d40b623c4202a74cd64c4c01f6fd2c39d260dbeda9b12fa376ef1ba33909cb93955114714003ebef014342905dc2d7d5af4cd4ff5c422cf22a095a70c085c5aabd6f425fd1991dfd75f38b388b7d0682a9efefb2eabe0523a9d0c51089737cb4992dc4d21ca67836b04e24fd5e78815535bcb37eece0be0e02ee17ea0232a99471dee369b3bc99bd742f8fc99a95a2c770fc0b06c9c4412690ddd3311043bd73a3173d7df23d0fca16f7ec3c759c5cf4dfeb36be8f1a1e02ab4fcbb58c61f06a7893d573a3ba961304a419a803420cd034a5816c736a1393cf7f7b25c3d73fb25d931a7e0040b08e5d1b7f1cc5388ad6b1a064805e4c958489a482f3d25293a807a54fa488fbb419b5cd54776c1557a0714a790014f7d58a2f44c0fc5cc05f68e2d45cdace0009957965295a4556d61c840778887d6bbd3f1ef8ccb88953c10130cb6f99852ef83d73dd62b22e1de296b382e5e48cd5b567281fcb7f97821b936d6f15c6ba147e760bb782267437898571b94cad20eda7b7fa2d17363415df31c4b686565967d078f555c8b5120bc574cb9689a94dede699af62989fe3e30ab161281f092c2b8b84590d1caafec86b65417cb02aa43080c426f42ac6a8a3765828ba14dfd07c17c6e983a78cfbfe1755cf172dedf08ddbba364ec38a18f79a0647f2b172dea4f0af7ccdd671b0123944da26eace6432289a93078ef43e7d4080c55427ff4bec26e7bfe77261f8900e51436d1a2b0a6624f0053babab0e70e57f8198c254fae602b6a6744fdeeb7a59e93ba7b16022ba7f7ccd6d424b101d82d7c50d0b96a2610359ea35a4db28baa91be99ea01769ed3ab0eded14d0138fd5a986b55c5bfbd99f9f5753c1926b519956d52d247c0d04f7a0eccde8374d5346205c92b1ab688ac318d8c2d356238d2ae70de84b46bf472c74e271d8ddd8eb6a01b4d3de224de3d23778a3b81b2b9758ae642f20d72efbad328c7a91c7a2ed75657b2b75b916f12271a7d437c12db4a510a6edc5258c54ea5b6772a4bc442a13c8a8c313297d9903983139e0343f22ff717cfae263f25d87954220ea1befb99d8f8af109431361cccd5c2fc42873afdc651db277b56f1197cf0eb68fa3b629e8af1b5247e677f648cf0b28ffaf867f8fcd7edf5ec68a4d50a6952244a1213a9853029f8a9621acef8cc7f09a01f61701be48e40d8e2c496b60ed29cbe340690c59b0303b84ffbbea74b6c39710f965310278ec2eddd261fc239d2f297af616bc5d1da08db0ba8b2af2f894c4928371651153e756a8ec003b4adfb5fea978ca8dcc0f100db92dde41524fdc9273266a9082469470eb7e758ca34251be1c9961dcffa19da3bd1582e4302d1df2d714a2544df211d61950b7ab65d0305270324efaaae03fa520a4acf65af33639d5cb25434b43b6b3336d67fd24c9e665870d6bd6c29d0fd54d895c3aa5cd6bfecb42550abb23f30642e3c838d86bc3023aaac086be627124377c7bb251913c30cd43151872830a53b1aed0b4fee73ea57c142a7e08ecb87543c7060b0ec2f07cfa6aa927f1b5e70e653f6051f7553465944630ce040d3b3345dcb38bac3385d4dbc1e917fe382b0886d79d52793667a52ef39b0b3529b6b59a79be7fe572299db236fa67a201b50c9ef43f1b10671663512fa43531f0ff14b2607390284b48bc3672fb1d498e5f57c953bcdf65a4d629d16090d7db5edc62dd764560dad8287e03ea3d263e22154df113520b816fef4b355f8f447d61e17ee517c582ea1fc7773e7dd963c8f7fa8d28777530bcad53b60ef07f5c89af16e317d22ae9b3c27e0b228962d0c3425bb5b5573251a321fb5c80e448b46c6fe92a833242cd632e01db38ae75a8d56f98386fe228583eedea98bdbe08c7de299d92fbaf4c5a335d8f19a28023a549cf3e7a45d3070524af58b3dc9d40c172342837f952db43079ac6e524b10bc86d858077a780fec5bf7f1c7d35daf614bfb8bd0b7ab8e40f2f7cdc2053d46239169a80031013954313269afca1aa26f799d3df225f89a784f35fbde13cc5d947808e3c11b466dbfed3c4b1c84202938f24390658060a56cd71212b6483920a549ed70d881f712e46bb4cff5842ee98971a717eb9ec33a9c73d11054262afe93bb3049eef202513004f66960df08378479a254c17429c2037ab5e0e1f7f201ccd2d386886fe4fbe126200345784927223692f26a3dc44ca7a225af00dfb959fee731f0b5a15f6e22f4dd4d3d526acdb97532af5296208251e75194190fbf6f3f6f24e97bf52f55c0f634842a7a463c450ed73017a5cd4b3a63545588e37bbb944b7ff8d5a8534288465b5ccacd9e2006f7ea185efee4f3554c4949406a1cc76a7a25834729a5af95f77825487dc9abc17cd5b5f2b8c4a7e67552a32affe89784d9dd0e32afef796ea825e94696104d48daf7c89604d4b1295cbed4444e497daf98fb756d0c83ee073f124829ca33969013a8adf6001f41361d263081ec9d5ca6a0df79b77f7a74003b1e52e3317c511395ccbe576f4f3165d5faf13bb641869fa2447e835398f90559f141767c49fca6a7985da636f45a80b5ff98eb00a25a8ee118bfdf87ba92f81a041af2ad4270e1c5dc73e083eb954e65a72327cc4b6e635b52068f1d3f8a3e5ef3f88c1ab179cb79fa1e9610985e5e41dbb0bb9de506fc984fbc2cead4fa9e6341ffe90de80672e40b79095a1a388e0972c33e5d1029b760424720326e9e8e76be05a88d607acf3ea21fab0819586c0742fd5fea396f186d1f79c8264ef3673f49f579c083f9a7cfce66786d18ea49e2fce88d2b4f32c2db8bbcbcb4328f69f21f0383e23c08ed35f117f095e6e98916ac21e480b2b59fb734f69203b735cee2c92b4338582b3d5cc4ac754bf1f97e80467ffbd13f7fc96ae554604a527cf093b901f57e504f5602669faa2481a433fe7d93c132026b4c0ad191816d0379171f8970b171128d7ecafe59ed8ee1df6dd9047c6804762f1171f8d7fc79e03b54e34e7469293fa8bc888a21bce1ac4926667ef9710d1d1ac329b885d8f416c669a1f925f25be18be4a996c941f93be1abf608ffb37163779da58a40e5aec460c13074219c33149f7712e057014145df241d178050bef3891ce38d380923fcbefe77356eb959a81edf5605d540090a23e4c1e752174a3c4cbacb937b0b59a559be8e6b9588c32418aaea989aa49783e6db9326e84f392a3521c83589e7651f476d89a672c82a36c723b8109cdcd2dc1c6bfa9a8ff556a130846407ad68d887c95dbdd243a8bf9c28d47a5c58f8adc9f879f62cb348437b5909a8afe3d1c33d69d1c51c4e37376d7505b8e8c717e1638e5b036bbf777b4154387d10a99abb2fb5474e7c856541a716bafca66a5d7f1996a0b491202ba226faf7441a24a010eddaba44e77b5217718e9bc253e4ee9b449f8d6e97de2b91f249b9cd4ea1bbec49b00971009ec4d16a97d82aa66c3ccfdbc3ebe5e1f909ae958e84a5b2f925ce5f89a4b30592402553eae276cb734650efa001227ab97866f9e56b4f0f4e0d943c4747fc4fe6eff5b7127d71fa4cd036a4cdcead4ffc7cfb2ffb89540c74b7d2e1e2c5375f46563997824c5c9d5506bccee032ea44122085ea40131eee40f12a24b1e60949e861ab5792bb28e4f65cce90357e32ec1760fd1abc0da7b32d0326566431954973d55f50697b55e672c8d5499a07ba6aafc235b36fa9e498749d89af5f5fdd8ea530e5a0123793c0324f0ff0584580cd7d0b0575912bcfea79531b0eec90cab1e736cc2e07d0d155d401089ee02908f03811eecf321ac5030740c164f963960ef7ccae41b98c4ac07062c207e65332e7e1d3481dff84df34b8ecf66a51f7c28d92488a374578a3fbc0299d545163464f018d6f6f17abf663dd298b0ee4d9c7acce930a12c94ff0a76512bd8e7633e5c9ec2899fcc6d20c8c217f2cf428f0476763701336b7a2a9be151a7a4e4961548fa5bcd2e4cf030a6c6803a2bdf8171323591faa0a1f4383a1d0b5efa534a95561d3115e495898f3935d3478f071ab56502a35f1935e4886ae071498daa1e2807eacb010fd0a8b66e0278fb44430f10a5445cad927d11bcddd7f099ab260b4e2a0d20e1233ec243520b61978e98cb2607c06b36935c387b8c58adc74209300d6a46b277951a7c9ab341c578f7d6f2c01bdbd1dcd896e3e8644abaaa08b8c4a089d35944a57d2e6843cb5d709a8d3e8cf8f7f0a98137aca86314ada8dd4d0352c05d154daef515ca84064760f6af97e538abaf4b680497acd75ac1aabe529a93c1065eb0643b82c95dda308de0d1195a5bf7bd740f6b2b7b674ba710a30acb52d6de8c764427f25445c5352d576b28cef8e26a1687432613f956693d1a6c12087ffed7dffc3fecc55309d175de1d26e84e9daa115356f60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
