<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9261f928dbf04c93523add042b13c31f5b0a0ad2b4ebee33e2220279e9d4e56c3ce6a67d40232148f9b31af4639f884e7e64f96a9f84dc762fc977292b4c3ed8ef6dbc53d617d7de8989205213aff0d1e28c72660dd55160be2e9aed4d753be209367623c321ae77430488f8394b4248706f2d02da558dfe44d09d802cfc623fc5b5d6278460373162c4b56f91039f7e53d3c17479ccdc530ff61d0ec798f59788ae9d910d047093407cdfb67f4109bc941343fe34ba8180e87da7139475928013e922090a5412a2d78c848f903f63bdae442044c87c1e2ef96a1fee9d0338abe8f2dc3acaf0e4c18490688eb2c618d5a233975159e13e8fd870bb48b9efc3ef81f207c5e1fd498ce89ee9696786e2577b2a8dc4276115c7c68c79c320ba4fda673526e3f200da7f20ab00b82b45854f271bc8e9208534cbad6eac2470933dd8beb12ab3751c70a169a32ab73d678787af8220ecc2c0cc7d8f353a782cef6598aa2d7fa196cbaf926b9ecf95e23e266c927ee8054f354d453604d2f177e347e39b2caa2ec286a1439cbf7ad6be4768d9ac1a7cb1ab8fb755744f46ab11442eba36b0e00809f5d6dcade7e46354e6a68adc6ec2161ad4411b8121f7164b6fc87e08902e4a6e311c2fac62bcdd1e11b9dfa0b6f4fe376a127d26d83cab27487f539b949ce7f39c068bb58085219fe05e82cb81ab026a4fba2a1336256b78167d009df3ad7e4713045827d09cd9668606e544a06630a4144031608c325ce0ae2bbcd6be88cd53a14e75f3e63f97ea2e1d124431a5bd8e781ec9a8587a2e060b244a9143a2be6f8124c60165fd4e9b4d17396ac7db18cb5a943ce830e1ab89ed5b040473ec72298b75a9c4e9b76ee730a6eed23dce81f8d8e83e294af56f05de8afe9c6e907cc2de0ff95fc7921ab70f3532dfd8605b96bfb54fa901ca9c99abb578d4d3c39da54b1e3d9de8422f5388c0aac3dff8015187bfbce9c8b1ccd87a4fd51f98032a631366197b88c0059f40d2b806185039ea781ea2450aa1e24f0625147c6a09862a5849ab8b9066fe4574758c2b761a39117e538f8dd2433df3ebcdd16d7cc0cde3a90238ae2ed7be9702e268ee30221848a654e156b6eb6ced6f68efec1259d3cb3a2ecd24a21742285ad4f9b19b131e77e1d4ecb78cd22415559196b3785d9707c79b723f0407a8b52c85e03dbdb8894118d761b4372be42c478c4c57c8d0068419527b87b8ce4dee4b5d327a049e11828160152bec372be4989662e1c4ce8c4c3fd97063fb8c83b34af2601048b7f3906c17c252cdc3b16001bad1f2cdd8c2a7744da8a89d2925211b8447371d485ebdbf138150fca68fc58144ee743d6c1c7133361526051c1d1deafe3eb464299b8c824e71202d5544ac6b8bc314197ebd0f6571b87126777d81687cb79f005d96dc74d1bbc3b58bc08c0cd0585eb9278bfe6b3020d7a897de5dbf988f7dc36e13a0598ea6e2e21ee860463d2d9735b7c4f5dd7e444307c07d98238f648af2f55c858a72538d4403d6da6b64c67212d8758acc3c39e9058060340f3f4b097556fba058de039ba73b66dfdcb3a76b7ae828aae516b675dce8a08bd16f97eb00a8f4a92564be58c102f7ef6786be2cc6d8c001b1b303fd124c6267cff9aa962aba1a55bd89c4479effe53d139f29402b0e95bedb87dfca2a3b0db5e48d81b820d9608855362f206feec9c223bd1f28f4f27f304880e6026d5d05ea8f57499890dd0acfb7e8cff5c91f6340a931de4208159853e61a377577d06bd278d2da3b0cefeaf037b7ef7ce8a7c170bdb976d5b4306c84f854bb9810aa96f8ecf46171a4b43b37fbf86efc4d741d96c8896a97f7517afae3c73d366f22ba5d13526012e7440777050acd7a3bf086c446482669b373be50eccfbdd0e21449a136429866e336e81288134a2b53b06c0604fb01ca8b8cb569394fe6f1fef0f419ed893d731824dd23f71d0d2e0eb5301a16f535b771acf09c45b09793b7cb631f4b47f49baf77a64791d8752737d3d3b64592a39849512877bb921b7f32d5afbf406b07ebaecdfca83473316b40c3ffee28d08ed213ebbabffed026331eb1f4f3aae3b508f43262282ecd48b65b773ddceb409639eb59f8a14b37275c0b9dcc614d50e710bdab061bc6282b702b68239c82d145c11259a2156be631cb31ef2aded72e3a9085cf2c3aa40c4c68cfceb0e29326485a4a7e457877697c75b52bac5b0d5f9be0251d49005996c4372e5e6c8bd62c1e285359021b7c419c4bfd1cdb674d286c0ddd3101e0821d8f9905eacdeedc086808df5eadb65680a272f3e6bc20f4f6a9c89caf850eff095a92183f5910a0535d9c581cadc3917d1ca1cee478f401c2d59dc8ca3dfe98ab1c1ab888400c2bb320670ee9a8d1811ddbd4e0e25fe287665af540eadaf4c2aa0a0e3a623186476d2c96f155cc9e54438cdba3d2760d7450e3ad9ab780cd06e9b303cd86c713fe76fb68a5cfcb6ec66e5277b5974485d23a2847d1be24705c1794f808ca24241bdc8834229b14aeb3fa71ea956ed362c8b69c73607ec337708645d7da81ce98dd9d569ee07c560f4cd3b3fc29b4ffa92dddc200683ca88a3eef0ed53db198478dd97543eceb16c1dde7410ca0189cec2375e5851d247bc1ec416fa0063b03de2332e68fe4e943feaf3c671f1c34e5270671a658e53c259a60223d619b65e933be8a3a1883c4afc0951f257e34d8857d48fb6ae0b5564731f06eca8cb1c89e635d0bfd8767cf11050704aba5509b0f44bf445c511df24450ed291873ad45c5bdc315564dafb13918908095b67cc6d980d87ff4b1c58fe101a3a9c33f068cda36e63cb3ddd5dfb55c08eed8ca7972dc5aa02d24e0f9a535372fcf09db52b8247b21a6f3aa4b7b39684747e7a1f02da1e1d808897c741250a621da0429eafb92d1435aa727070ae4879a510fc149512e935e62ea9ef26d3079fadc5c09aa407905e85803a5f1547ed1989362f3736818ad264639f5c81c7da8ced49538de6e34391ed019c08e0bd7447b761fa5bb6b8c8b2c22b3f6cd083a016f9f7b7dadb064548aac78b9cbe5e3e49294d4fa5569c9b24288aa6638dcc734976708f6e5676d2e14f1e09ac68fbfc27808fa5a56c2c013acbb819d6b437688728a7c0e13c6e0af799dba445707ced5b61b65d0d2a1d79a5760f90cc1b405a6cc9a303a9cd00bb26b5fc0aec40ae81a9d2c5b86864192c9405dd8272167139e8d28b6936cbbe1075ff341eaba451d335b5f4da20ba4199df40aaa5457a35c29d66cf494cedf83c890e751295064f240cc506fc1d3d168720e7380bbb31e573960f9db9ba9e86a16d11c7471177ff6cac37c2ec395ed53c19e5b7d93d1bf49df606e5f28ff2bc4a714c9ebc8de7d5d307eb167e17e0c3666169564dc506568855118390f061b1da102b358cc029013bb03b83b76bf410626b1fb9f78cd067f40f02643c09c2282b7e8ffcd24db6601be4e6429f2f0e7b433cdf2bcc568143166954405e15e541a9cb398415e0d4c8818111deb3a1b10285566c61178f7bb0aeed0070d92fe32cfe779368ac949afa238a8d158b2d14706887b69fa9b03069880da5e279da47e2454dcf55c383dcc693ae0c06fae3a0dc11ae193e64c70790ff7121a422f0c9bfdb5a5adc431e126dfdf6aeb721d7f6aebec344657f67c796c757c91bed698396534ee55ee2ee5932086941c854b8a7e4060414632f2b31d5a5a588d89de1955c3cc4db5acd6e6ebaa42884255625f6b63e231950993fae5c970b692574d78ce02436af4f17716e28125ad0902d458dc83c525bc02dca0ca83147ca506b0e8e2c674ae05d88498ffa6268de707de8c08aa37d3d006853cb797a062d620730f775a4bccebf70db54ac69d9d1af268bce1dd7f32b6d65b389ac56c77d70d37177265d47649edb193acc782d869c1838bd4ff07531ffcf4550e94b683be7fad8fb65595a742b15de4aa9d72406d36931fd81ed42063fe15f2ec086a28badf0eacec99b20b0208e775028cc41cda6bd1c8797ad56cc7ac08ec60ae0f54ad422ff73f694d2586b47bdadb9c46cce3fe6c0cf451a272cc9a2402db8bb280d91e033e25abeafbae3732fee5582f639ef800834151382780f02864835170d2ebc2d5c710e24c1e278094185a74c9187e49e0a46a2a13b3ce374c12be32cbfaee07266016e9e3e26a6868668043937b679019c54d57ce909531b5541644f303aa806f437f25e2f6714da61e82fbdd8f3054f709d67cbd1c4441b0fa0174eb1809490b3d0f63a9a310b2bc9c9584ff5954fbc058f49c6f6a5f5e8472e9cb13fde48a5fd56885ef1c4478d5bfdd1d1c98c827cb2f2043515be99de44f5b2ba3c40f264a2078fbd32eb050f1a1f5ad834f80d4f9a5c1780c1bb6f04614fcd93ac03dda60c52ca95d0f308a47b46008f749d9fbd0fd654204cc6e43a872be5e417a751ac0d226c57df0d4660182146bfdc7bf3ebb3948759ad4a52aa708109ce7f9c39ed8b3ad645dffdd5c7fe68bb2252e840bf769b75e537b0905969e2beccedb5ed34dd16e27738cedc63f1c5dc13590a44f8b85e95af7d877a5769db6b9e610e2e0ee8e6a094dc9fdb6ebd3f237d288be0b7c0b095c6d0ff22879d6d514529cce9120e51f2666b277aa9a74b0ef096bf26a9d873ca02fec96bfe74d53b634082ca1466895b7a1b397b5b829d07ec15b3b6f11272b4467b0b0ae2a521bd4f1bdd762f3eb2cd46cbd4a19a4aa5bad26f031201d0e6fe3247eee8f320e087c0000dbee9ace2660e7ef498b7a9c1cd21c6fadc6dc07fc49ffdb2093458909a822ea45a10be4fb3a62dead28b604a5d356b781be7f8bad33dd096643951f07f2198cac6417137137f7027d161bde8e96d614b5f212e9e635cf345773a20d3b69e36e1912561ec096dff8d355b16347dd664cffc47138d2e249ef3c54feedd633ad6abec719ca16d3655249fa33faa1b6fd1f091cfb55c2fdd14090cb89526db481543bdbfd86fec99fe90995886b9427a93d4945fcbcada52cff90f467cacd2c73be11d683f8ce095dccd057933fb3cc82086668141f3f272c27a4fc1a44e9d6560457423f2816cb5e8bb10cf113c92e5cf5747b3c73ebcc4df5ad81fa57bbe642859ee5d277e03a17f1b32104163b939675ebcc55f1746d59c6dfb56ba0611e42fe8fd06a6fc444b2b6523d0fdb09f42b8e40ea5f483e9fbcde1e7a410d2635b141bdb9f7ce1cdb94a01a5975766ab263a290d265a6ddb694bae8daa9baf70ca55cd5126ef8a7f606cab322f726c5d1049e3058b157804486e68d45f062c30a62ee13d6486474808b0df93072580d01819951a20ea7df6ada7d4a7171a16a9718dd6cd200b5fb0f1039fa54366c992c078ad156fec96854ca0e37be8658101adc0d55f099baa21b10e1b06583149197e15548fdaee1b5258f3dc6491d712f6e3e950c9b2590b725ea9e9389d727f656a8ec161c918183849a179ed86449fe63b2267cf327c666a4ddf66b815e7cc2b62e7e49048490478a128e053dad98df21e25becfee98799907a1d25b434423f2905fadfb335e14c7cbf56f46cf15cc3d1e49d6ffa21b464efe4435743f4718bb35722e9ce1dfb35e5496a849d6e89141cf0155678e6b9fe9825f16e0212584bbb0a8de6db0b29ad63b93db556761185d8ad3ce2a545fbb731240f2f3a46c91ea1e58a488a8011523eb1f872816dd53f9bca93fa43ff57b0f8591bf9abd55272c3a52f888c47f9e92f604612123e7db9a8b2ff4db667a8d7be5d7660fa5184e280726053ce307dccd9dfeb52bfd0bf295f721fa9464770c99b6101071ad579add5155cc52967c82a240d26f61c61f1bb4f623b3788d2b0a802ad5931b848b23d731c31eb3bc5ed5ac85d4992ce0307426f386539abae097f4fc6b9990d20e7acc4409a1662357b18754068043380e7bf4d21203b5079f29871277234f0450a1b9b2784689cb8d876257ce4c1189dd158c303782c177ece4b2866b7ee08f5fe6cb050c94b1b2ae63e135b6be7651b290da18ef2ed3e03bb6124f564f2dcfeddcbb831db8c3c6b870f07b9a052977b0102420a59e39527f3334fe4f511ebf62bcb57d19c426e056e85969fb417b1f4e820d3e82ba0f1728da57219dae0259b29beddc22bf8d6b15c16d976466ef9e459b53a921e9965c370be1f187560bd2ec062df7c936d326efa011d89c45ebdcf32f798c7aa65b3033d9ca705e667b3a3f293a2a8d6d4ecd56c767f31f092c896f2e225689c44d9c34c3af9ac56b6e827a9fcc52690a0622031c704fb7de37c93843cdb5c9da1ef30a0e47f5e46a6e4b887ec69638f91e1512555d3e808ff132a10d9e05233e041c66f980de8d643fe82dd97ebc576080f413955d03c8d6de707df365addf0759c146edf942168fbfd07391d56623227c86f52e07d956526e2e9b69a3a3051a97ed3b307f95d3cc252b18ae95521c0e55b2d262e8ec84d379f631e11831f450cd8ec541e7d5f10220ff872b1dd9ded47b3156abae95b336877ce8e463192a15a7f2926c079afe65ea9d59c84f5f0f3e22139b6cbfeddd08a9755f6eb55738ae60205d69aada5d52cbb6635a6c30a91b7fb95235effdf737cd3356545ccf4cabaa6020b266face674151ea137671fbd1e01fb006a8d57387dc04f463b7e836424e34885af2799bebd6dc93da10fb5b0270f9545eab0545a92da65cc9b821b57552b6abd3578f14a70d473494cd6f4df29802e9a3054320d86075360a4e771195f75cefb9cc2eccd489bcdaa5db72861ab54d273e1564831fcfa1af42d802f3da857cea218a753465c0cc2c2990734e9291cb0f22db0e0ef57a588aa8a8988e98d06d03add8dc0de92c1ca09185d9f801827f5ef8f16ee69c547b1c4af57c19111b5d9855c54ee33a7e3ebbbd3a4fbaf31e96ae41e3382246e62cef0c21f222e864ab40bb894e0ebd3a7faa552d41580e510a79045486f12a51f80a32001a8f760fe8a60a094780bdf2ff8822d8c9b0ee5007939bc58f066fb43bf2574a56c9af46579e3f63d6b72a46eee6afb97b117e7f3dfa91260641a461bacf1e864a7c43521d73c03025bedaa002854c357a9c5c5252afd272fe284452e63a0a3ddc9edab7be239b3aaa59c230392ea312c5d77c99fa240ea052351b080c44ad223daa63fc0e9e14798d073e03ac8d1b1cddb7d7b2fc6bfad7689dc530e880ce17a604a49bc55a13fc155a4e9b89a599bf803ed462702968bce109ed82847f095314285fbc47648b7dc6cdee28bdc4b0f47f0634e220be274885e0c25703ce0e9e5d5a68942ac82c095b50d4769b83f09e39dd3fc2373f8fa5942f6f7d6da276e5551ad36263592577a10f7008dee268f8baf2d4f912965d9be13da9d8deb23aa7e7abbe80e785072a240c38fe46056d51e010727b7411de972df401aed51a35570cec75d638afd7908b3569538e3341b898ef4fec8de25d50069c815e9f915ebb02dfddb55c1105e52053c822b1d9f903b86f69a4a468b5b9582157e40391f5e6a1fad92ea46a71621544cdb5892d9a4e81b77988d2c1f38af5a7a8130a1d006554c15fd89529516987f36f890c51c228ad79a3a8401b795f9d092fdabf7ad9a7621fa494817f06c4989e4ae91d95d8a28e63048f19ff3d73f4325263760d38c55d4bebf76ee44c34ee9e5c4873a69aa06588baa578811f265b6c6f6de23e4f350ef0946e75b001ea136f04baa1821314d7624b86aec0c479c3bdc77a8e9d75025e31e27accd6b495aa7fbe27713148a782891bc7f43ae907f7e54df448c8f7bafc9e22db2e8ccb95391b4c37951dedfd1d1c0dd29e701d07775c70989b1b38b368fddbb0b648137e010ea911b75b5637f913a467dde041e482505dc61b922abc10e55db5b3458412dd1ef1a38604c1063b2b5e4953bcb32fc13247e10216846902c0a8b5fefbb2f4836b12f94174d88e481386d0d1f751a3693fcf036681af18970fa19472c260cfb339d830f98a6e8ec2843a5c9cdf62c8f90146508b52ed144ae28c522975d5f7ab5c8ec14dbcfb7d5615da98a1c094cff148ed4d904feb0e94da4dac7fc13bda9b7eeeb6af4118d136f5382d365a01650460dbc838a6192e707b5b45dfb63d91fdf13fab746a2005562c1ca4a3922f09fef7b4f68c80e8a3c7220bd958ec80c5e2f6e31a3698c7e29ff2b1e53d759dd5ea8aae869316b993d885a0bdcf2e46dfb910742e09a64ea347fc302a44c7033597ae8d3be68aee366aa3790ffe0ec7828d8676c686f94c584bc061b003ccc9637e7fd1fa2e04ed7d7eb0c6974c04c0f8baaa3fec895cc4601eb1a64b229bed5ce335e5ed6cdab6160167fc91f5784cb51651a6696e19f377e8df10b4ee19ea8a42e68058569d68a54d59b395dd7982604bb27200b34bf1bdff28f473a12c49d36bae8559f7c82644bcba019a54d51d66dcd5f2d3b8d039400c7b2ef309b219af1fa6dc73cd8562bda076d08992508b0c2457dfa5252a18a1a9041b4d26a464a90f7976d8180b8606ecadb3eb1087d47e70500beb0e0e4938182ad5452837eb41ae317c2667186d06ef3636fc7773aae0fbf9267255dc265033fe36f9a2e68e44e657d02c45a66f66a39f12f863ac1f7fea595c0a0e4983876f82276259008be2d36641c176c12ce4cf0b58f2ad12fd4bdc9c5458cb5b180d205962a10d56a50ccc5f58bf3bd1d06e916367197ec81d74c1cfed263d2499f3dd04a48014ee5be761a7b60c9cd5fa86e5a2f23de6963da21e863a095508ce508a956cbfc413d3460e95d33a27be7e79585841e7b926a5f2a548c6e810f392c70800ad056eadd7ef55987d32ce8b8da75e508b286a28c79a01266b0465e7f262e28e4a6c8c538d320b3fea5a561777ef5e096b66d02be44a2854648988d9cb3ca18891f332966744e7123405dcfe6d947e4da61b5884098a63e989a20115776e934d0c3ef43d3fb3430e7585a11256f47f1b5e72458d0ed92f44a034e6d4b22918e68923ea25f8336450b98878207b985dab1672a58de4f37eea08b99f2bb94d2f4e5a565778fc00134088731da0ee93a06f92f5d2b29df1d6b58cea450b9c61ab3407fb285cafdf4454e1bd073de9d8ce83c2a39dd63413db161b07ca80c500a28ee6b93b8dbaf1d66bd116e1009199024935a2f23dac6a9f655480ac3e9e0ea6353e177903e9b14778d761117d9641a1f8d5fddf4e2559620ba7c671fadbc80f17926bd12ffd9d686bfb0c708b1dff3587ab9a502fe9bf689a8299e42368334fb0500c7ff912b2e9381ae432a9ca1f9deb4b868aba795c6aebdddff53d75149dfbfb9fcd24ab4e9370e358ebbbf33352e60203bb66eb97d3837e0e74c46d8b012cb5c2182473e1beeb5e558a8aa158983928694eea9bbcebafd104c40e55ea9d3c51b0d982edb9e91e35bb9b73cdd79380e7d8c34a86f53d26edf60b06d1936683758085c3d079d85bd57b8e83c0aa47d5c437b3a8648939b47d58ad086e53cbb544ea67a146e332164dcbfec43c5309dead890245a7e76d563e36c4e5a63c505dec950faa3527d50cb9f9dc8d740a1251d6f39e5fbd3e4503d4a2de9696e6a3032b8a35c397dc8a04687dd4c230c8451877b80ec8c68616bb7ad917aeaf941399db97a449c6bc332e557808267823bdd0541da6a731e45191eff015281a6d1e6663d214ffcd7d0614bdac390063900686af7d5d243029377c592a265c95ff56b41b489d6d29cc292f53f690946a664abe62af0e657debf77fc211384b741d47637ae2972bdd1abd3568071493d0ab6459b7d372e14ebec1160d53c86dc311d8a1ae50d38ae9424b37369c6838f75d53c111d9ecddd70b7bbd9a42d326ac5157ad5ea491fa14d222fa6aaf6f71d58bf996b2ec4f92afa2af0228645689cbeaaf917e517a2ad84e4c3f617a6f4ecbb5062688c8cd151365e2707ce2e05282b8f5bf064e9f2d252223e94967fd6e29d7e95bf90603df4a5fad95a545a287e34b2c8b7d38c268c7ed8fd80c1e4d1fb066b6ba2d4d24f033fc4022be784ce583acee2cbf4bf7e0c3d24966938552f9f9e7ebc6db82f3a926ab36cc3e2e43ee4e97ec54189493c17d215e8a906e63c45470c326a6ada86cc900d2b19be7c4cd1bf09de2eeba18be3baffb42254183e8025b306399499cf6586e891157cd025082965bed2b36fc27b5c5dcbe98fcda7cb6a61fc43a7e252eb5bb30ac80a804e7dbd335642022647823ee785a7386706d4358878de1ac6d4e9a45d0d1692e860feaf183603109078a041f0f5230666ed85a284da3d7cea44dbac545e067bab3b9ced142c9e9c3a4c6cc511e392d7e7d022bd8353ec675175c374c5e0dae7f5e7ea552154b819d4c6d1a77bae23a7928b127968635a7ac4006291c1c2257090e5c26a80c14e9ac417fef89f0a2397c66b46c9e4d464f66404f068f3f6f441c9ddeea4a06847de50ad37661be8d8f19d1a97bed9b6b7f404bc512551358d3f01b5b952ba49deb440d46d7f88041db8ce5b870baa588aa91f18974875c49890537e77f509309dc84b02ef167040bbd429f01ec2b5542a36de42dd9696be080ba0c9d1ecab407c1faf87b628f737dad1585d51a9dc398e8fb07c078c1e439e1a18b4fb5cac3d76ab62fdbf114f8bef37b74a8710c8baa9c7d0e64d2ce217cc7d40112b8660fc2f4f8341fad1f3edab0ad22b2cd2b5f36b1effa65c6a4b0df2e79e70ee258044e0bac2cc3aef273b73288d1b62112c3d44b9ae2211be4766e413cae982a2f66366f276c1d8f73166d8a3d2bb4bb54757799ad4f94b8413a02238d34140cbe5057d0986b9233adc58860338f7b406d6b378e4a9fd18fce8c42be57f743de666344b45234a545856070731e637f14c3079b17d9b4973e5af01634b9eb43d3ea408085fd8f1bbb7169e21b7f14e3b3eb140c0dd57db8596e0d87024ad25dea064e1cddc2f8556e73a012b3e3e725d70fb6c70b4fdf1d88bab0eb011a77f7f02ec21a839ac66ffefd18815d000195f113c282bd592f8daeae2157cab3f19a089ae473b68c89754b1d8403f929139330aea590768eab5688e6f47dd53a33b4522b3e4b343a1957d5704966ee12faf8c6b64f5aafa9c398f83cbd1232db5833f741a2bbbde8ab436758c74facba1d0287710a093f5450c2cf6faf122530c26bf2fdc392e7778bc2eceeaeafa6c54c0ad806962cad429043e29dda2125fa38f5ca163826e03474d06fe909a820e9c07191e44d05d74e79d7537cdc6eb7ea3c2ebdcb26e9e175436e0b3cb94500221b48077ee72c5a87e436a958f0f028311b3238b508aeea464d544187ee83e99390624594ba399aff201bc60b5ea8e3e598b9d9ceed654cf66ea622c787eacb9bd03bfbcef1ef251cef4d74f49ad74ac699cc8cb8974adee7b2619d675b53faadc5b600959ccb8066ee6b3ec2d3ac49f8dc08aa764535b128f53346b9cfb360f42da1ecdbd6deefb94f8e7b716a8b9882c9f16ce79f638e39f6daddc01244b0231072f7a3613cc60f7dc1dd4879500117519955c116a1617095ce4d563ac958ce83f4549ff3b414524aa2372a1bdecd59886447ebe8a45e1693b6a9d76f5f100a1c095e909eb891713cbac45a0ecfe091b73a39320f3371d5396fadc3bde4378a631dcf5544b384ece3fcd47c99d0be8dbc99a2266a4e06d58b5ce6306b623782456b6beefe3b3e44dbf4534ef5caa8b2de51fe374b4cde386b0a652518fd51818f69f9fbeeb679e21b0c9db124426490a5112be1304584a91c5d3dddebde69529a2029c880caad3281825fb236e7de32caa2bd368912f6b704d15458bab5da133b1e05d5e0693e3edd679f584e099ad42951089c89b981feb1ceaa3f5803bf585796dd8fa95d5289faaa3da5368a94d4115d7f829980f2f20030d3de2734d8032a596d6dc8dfe897232faea53fddaa4d1e7c504fde7221fd4281f505aa2d790b1691b175f907abd3ce06673ae2f15681d9f53a7b2a26ce7dbb4e0d7be6dd5c988435a144d6e25c80b05c8e5a8afbf1c2251427069e13e9058321820290652ab467251ad3bf6541041c97ea99aac80fcb5c6f8aaa394a805b3f2596d48b7e8f752f18adf3c0b1d5b78d60b648229641708c9e7fa5da233713b8dd35ab41d6ddf037ed70f51d998508e2ac43f53902a8258f048d71ffa671380290491a364fd9a07bac00b8362c7d9e6cabebed55b613add19bf948141b2c75ea832b82c2725e0ff75e02e117ff0532661c7620b39dac81f6e4ced7bb8c40fe5a301d11a8e0157ba4c6c855ac1c170dd1807196724a90de7c798fbaa8dabcca3bc5163e0e5a93a89dddded1e232320406c031ed0db490fef86e0cd1a8deb5b624af44436b8d2a6e95f454a71d2222f0681ee76a542b2a6fe7ce1aae3a73641058fe7e5573d92f7f66170f50c3dc1e4097ac8f13acfc02c7179c6b455578a52655b84fe0f8ace70f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
