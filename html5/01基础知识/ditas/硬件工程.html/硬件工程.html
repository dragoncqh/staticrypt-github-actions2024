<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41b95c862ebb126c514c30f4eb7d07a0616295deabbeb1ca16ca111808de2935339b7c10116966a326fa7a10c1b062f111490383c5268986f3a3bc1f9706622953dfc0cf2f4524bc92aaa7e5f9d095cbb65ae0f263fee6fb1ab89a09e95a6e83e27fee4ead4a4e6a61b0c9791dcc8c8ddaa1aa1758ce84789b9d349cc469551b9b7c0058e19ba2719b5a7b0ce3d8bb00c192d35aca0ee97f1a7978e7cb4d059e01ff82583be8df6af487bc2d92b3034e1b9c73180de07dbe6bf37bca9c4fede1d0c2cee451a0cf26579440019b9e35c4eee436a8f5dc7e8bc03bacb5fa68d6d1be1a375b1180a76ff6196b119ec0bc8a540b2f9db463d732d1c920c960f124adad822137d391ddabf9167dafa311026edbb832cc91f4bbc08383701203b4bc077b004986d0c464c50e64e5c803f6ddb402d605313f3039eedec57eddb9196124ed5935789ee2e5d027568f87e8b9a92814282cd1b497fd8887b3f76f0ee6f7933e98abf98f753b45b8e7683c2a37694dc80dc2b5164cc23f736b478fdd0dc8d5825973076312f7d249d52e246a55dbc9014828ea7244d801ce15dc13d9967f4a155eeced939984609a2de80ad376d8fd73a59c690ea2488efbc5b6459e1aea793c04028758c857f2aeb6007b2be4e33843f0ba0153edd7271539bb77d1b063e0b26c96a4c84c3aa03c0173d430b62f640e7442e3177deeca3a32cf91c7e8c40972c505ad1d3bcff23e2491019461865ce24ef7af2f8f999000c168ca89c99088286f233b96b7e6f29dab1a2b89daa83080525a68c8b0252cb1d3cc3e38be627ebf254721636c7a69602879df2b1a688c9dc0d1bf999cc086e34c3d0622ebd85cdf04c6cc7c621a92b655f54343a20985b6c438a085cdbf72153803fea4782522a703a759f1ae35275c4fb4e351144326380d55f219b451956a6ccb53bd32acd0cc696a9e346f5514ec777491103e718238f5364366020bfb5ac980b052589b2b3ea1dac0a28e8e6b0b6e722d30b1cff7eba536c25b85647430602e7d6e01598fb2fc0982880d103fc236533a5d77fe5feb58cc6d0fa48292cceb27c3ed31f1bd25174a1d00a4630bffdafceb6309050caeb8c9b33b880bac1e65a85e1676d9599e5c4e778fa1482ae1ca2e11fda81d9d3d5221f3dd8c7e5734a27c9161a7f3d576c9057cb41434b10eb4529b04e553a340427faea461aae06ce388cb89dc4dbf3e8661f9ffd364cd22713bdef4ce3eab7b71c11ef8083ba9a949afd042263c4f34f97d0cc9832cbd2452238ef24314668e559c69517dfc42bff37933dfb84512b48d4571607054fa824fb5f8e11f0d83390eb8c8da7ae29f5bca2673f034ed0eeeaad5ec426fe0bf352d72374166ebf22a7c7590c86118d33f9f4d951a89648fa9c263f2024f1cc62243a51b12284cc4f3ba33c96289e03708d37b796c008aae466bb948e81f36d2dbe6125f305a5edbec2017cdd0a8f3fefd53d658e33b7472e67caee0e45eab6b716fd8b5c909df4d19cf6abc092ec69b884bb8ad26f2b8557fdc73a7554c90155c73051c4daea059b948d2be481b2713a5f3f9d6acc85d8c45893dd55a09cabe99a7605f73bf0fae4813deae9828f7c85ce9452d43c5c28eaeb9fcc3bd8480606bdcf896e230d8692062cd5ead4c0ece16f7571bd8ef79ce1ea13da9cf2a7d62e30dd3bec0d6a7392cd5e42be20f73a0e627a8797f7266a8b3e57afe1b65aa2858ccd6c4ae8bfe596f14e0004de5d493871fdb7c63d7cea820679c230deb4add13423a7de91831922cada3294c059364306eef44ffe9c07524d95d60a460744ff373ff0d3d9caf203f98e0aecb629477fb9eaee88e24f66619aea83a4e14c93b00745a2686be6c3254511233160ff029cb5df19a845bb6cb33534b638c1019adcb3dbe8435e7e3f42da2fa5df71a9d6936fe8ae016ea3015e0efc891372b73595b1a47b63975e976e7e24ae4e0af74d08a3bf0540183a0ea5c3579852a0f9dbe1d6bfb87302873c9c6305804a9d6eeabf973d81484b53112b4efd0c53fbe22129c1cb3fa593bde4e60e3f2b66f355609c3c62e790f0c5ae5e8341fd8be5071f1ea4650d9f81f5bbbe827f49d2a15405a761db2f288cedad58f16ca37aa294c73a5ab866ed7ebb75212abf3cc3f3a7ea34166a8673c9277ab687d13682c42399aa278a81b6f206e7df4e3f8a36e1b71ca6e33918bb5fa6492cad4509c41246348c1d997d126361acd9915582eb69a185e095bb526b902b293b989bf4efc214609fac8e0a50f96d1801aa0de73ab43dcb2ddcc18cdf630524de53cdebeed70489146ebc3707392b75e87e4210ee910d74ba0373528aef31b73c44ca010b5268a197493909afc377483449e35940a79394dd9201eb22e98d80746618723f9172a0fee4a579ddfc8d7eba13d5fd26dec6349a7e3e1634005be217e9faee3dedca40b54ea5bdc04155e418dd5232c708315212f0b104af657e4733fbbc3917ab785099ac40ce47e84c83ad75010fc05015974946e8132bab0a00587205f7473147db7314f7a811f6899db87fcd9713e31f877e50d8be23e07d744255d38e936ca76458d4d66726d098fa99abadd07fe5d032a580d56cdfb7eef23c1ad07e61595b34d6476eb2545ea59a5d6567658e4812117ec5c2434e506e2fa3cd46249f5b781ff72dbedf07d783413d3f0d93412591e85b29e00f8e211ac4930b933910c874cd463bf8f132c846d783482f94884a13763de44ca7b0729826971916922500a85c641b18b63e12b740058249b5ba9041f941f112dbf0391c55b3f4e95233b63edc8529c2adb9533a6a7f949255bc41baa06100b29f48009c8ddf41595f89d043b190438aecf87e20f4ac50028c1952b14654e4fee2681541ccae7c99bedaf19ec6b8506ee2c225eb645609030e75e36ce4f701c9e14e44e2a0fc99f70b51342872572f950152b94162a34c1fb981253b68b5f09c44b69a027f6562c951de0a91dc0d24603b7d514abc1970e5353f37821a643dbdc410960e7e74a2d1d9441c012027c85b3510dfadcedd014c74c34efc7cec63e33610d59c23b26d9347cf5426919a086b0fe3d7686b4beb4f703e92c53fe774afcfd436dcdf3956111a9c5eb3da46f525656752d44a477e9d4e7c6ec499d8aea20ef82332d3cce17b5bd3e1f46e9ec8df0ead1d9ae97fc4a40254d1cc10afbf00d3b9f2d50e1fe3d7383ad4a79f144adabf1ca49c5c22c660117b85cfc9a3b13bdb3a5f81c642d4e3c948b17b690f674d170ae6510cbba54817de4e2f7efd41f0f0b7493e8317c074eecd9beb2d5980c7b9c4df321f9aeaac6e1290ca338d8e47862c4b8bd90ae45635a3469bbf5faee08fa6bab4b5753eeec7b1e3b5fb704c94d623d19f5455d8c99349f309c3889c23e179a82685d48ef5e7445ab378a44040af3084ec7a14479b904e7eb9d0d6a6452809e794be9e5dc72f630f01b56ce87c1e144ed64427ab3100760386c77e6c6626e3c379698ee125b5828e4271886d3666e931e102504dfb35cb3ceec2deec338e4d4d898fe29afb0609414b8aa04e4cd0adfae0fccc1807f46715642ad20f634ef815f165f437f13eb66bde65120ea9f5b544031ec29af04ee6fd04196f5421419fa49ec85a258bcb0acfc7280d4f60b8e4cd70ab7e5d625087fd8aed84861dc8f31f01887f90612b7ed6288e02cbff22e5f4616073df64b4ba36d3c2c5bd2f54e21cd35d87cbb1ffca45b4151a9d5472d325f11f32317343d01cd01714fddd83ec6fbc73c4683923dfe8c42f7bdd40d4ec3a68fff4cc8c67dc7232f745a6e8831d6c838638a296ae4760d993a3b031c2d3809b1369619de75ca5ef81b6bdc34bc71cbaa7bf62d9a241cc6ca7584f3cde48819eacdbbf6a1307920068c5f7e1150563b416369e0176b729d6ad883f78eeeb4c25cf325b301260ca0af4f6f538de3094adf3a9294b66731cdeead80a3af7ca36ad48445a57538d2fc9f74a46efec0a738dfdb1b0a57c5f8f357262c033c55e38b9b8c4d458b6b21c44115522587a9535a76a63357f1eceff042a621c74f73bd0d02be26dcb5881eeb1782ec14c678323a04066024b224574ad1d0d1a3d84f6ec56a36fadb7dbbca77af108da0d7b339cdb5dd4a217b111d73993b795c090606ff9e358e0cbfe9302bbe0b14316cdf5957f41d0b099102b2a0f70d19a6c226f74edc58a68aac2ded059890fdf1c2e34f3aae3a5ca301c0b292ef17045543e0e22b754bf64bd43a13f06431c73bf50c4643f179a1af76eaeeba699f3141b06eeaaea3c4d58337637a3d20d1dd036afac1fd8ec27289e64b1ac96b453888eebcd72626f56db04e8289aa8c75456bb5c17de6ebf75aac2af6ec69b8375d1c2142c8fe544b8291e3ee110eb7454117005a9372e600f4878d664af9833cf9701839300b58ee45ca58732b3b27f5605d33ba2694ba8e6d9ead7a16222b9a8a18eb2212ee87dc7e73a55901481faf57c0fe40b2be12c99d9af731069a5f7d76a81c01848c617281b5a0074aabc439601c3204c27e98b1daa31e4348be99654947e6f36400e8eebf5e351a164c79b34ad05183ef4693892e15bcc60d24b9839d4e578b30dd4d65fe06066930315ba0ab2cabf110c0c4fa61796ab4b50aea2c442113c0cfd3b1ab62034411aad8ebbdb2aec9181ad937d8ba125e4f98b81d5d94324f80311795de351c02c5533c68d48b6222f045127f8a1895e4e0e1299b889307b74a4a6b8f07b7005701771c701c268686be0f8da15a7d7a4a8a8cff2754f3d5ddfaa6f031cca5f0ea80b64792cc37f38aef3734f0473df1142b073ec30f51463bbd653ee8be2c021c69f9841b07fc43341c9c016733c9396a43edba0c65ebfc8901b29d90ae5681edde47b18dc56c91ee2bad546ce4c9fa061a80707797c6cc400895454a0984e6c651f4729d62ee2e7580e3734359595b29f7395850076dec33decec7a53d08c3416b2d3fac51a3d46dddb3cd21784bc9d888bd7d5f9f73415cd90feca11469d80922131dd412cd8f77423cfe162688f35591c7eec9ca03f375230486deab7b620b8cccde82dc6804e7bea16c75a5e9fb39c78b48f00720a622bd4816cb27ecbb4c034b49d011be3bc7f49487ce334df12d446976b40797a7b28d5067b23ba3b1cd2f94f4f549fa9cd77a429f8d8e9f7d68ebc32b5c02f1027af9d8ad8e88e97fe88667a3b7e6b4439e6f6678f0d02fd9695bad46b361b62011b6847fa2cd1e68caee1570c543b60d195b194b7ed19dd425145b49bcdd44e8a94a1d7993a777d83c03c33e570296353d0b6bf213b517e7c2ba8c24e4cc24e547a622f200ac5821a80f06742e246df14129cdb8e2f47936fa758751986f94f912aac0a828279bffd4d1c6d570bde7b8977775e2d57ce5519cd55da5ac9e5a1f2888aeca005cbbabab768a60327dd0e2233553cefa299deb6619bcc092c3a58046e702c5a673333efa1eabd1762577fbdc0fc42e8dfb0aac3c92bcce5595292915e893bb735c8369ffcb465be1563696620407ff41b6033b60ce50c03a5df926f1a53e98427c2fe8b7be4fb10eb5e53779a75fc0942021ea0856b1f8cef01680a4f364e4f6109c361f4151485192c9e2bd5aadeadc89a395cfc43c5b05f4cf7b35fc90408a1ebccc316fbf286e93c1d6fc60ec056cb87bf83eee88a17e19aa3bccdbb8ae9299847bb0dd8d421fb4ba90a7c9923fcf3bf96ee1b27c5b62736067f2facbfc485d3711daf0300f76eccf384ad4c1eb5112477fff968074b8e9be4da5b096555f833b34ac6de3c6333f0d47b692495f2e91ef9f5acd4d435644bbb8dc4c0ed999f425531b5cc8c661c14d8c51d040ab0a12379f40c5686b09f95dc5c26b1478f89abd56ff22f0046e9b67f1d8dea69c29ffece004b2359ee74b0c47aa4702cee9e358a4b8d696ade11e2be8229c9c0c41d1cabd2f62d8e9638590d0c3a09a2869f1c2f7e84e0516242eba1b20f09f7cca1f0717af86135dfb1153b46fe59594b9fd6316fecfefb1874b6b5712caf4d2d855cb605bac7f4799d1824b04b7d1f024ea9c69e4f91bb678d920c708fb65fa67beecd4a98871c032aad841d8757c69ccb352cddbfc46e722c1db3e6d4971346f43333c5cf33ab38c3385168acc91f7bf13d57aa6083091acd2ac1f76f67edcc1dd94b549c05640294f19a853c4e315334444aeeb861f12f853d596b63980df81158cfc825a301065354c6cf6ac05dbda4fdc7b06a2824ed3ae92d119b658a71ab44e2c2ac3906b670804a179fd4238fa410a8010c4ff8f7899b9e37627ffe310f932980e09dafc6c2afd7e93e04f407f9f9bed0dcaf5af8b5927697d595f90954e7033569109d6a6d69eca7f9fb7f920fb2e611b0ba40bdd3cd9ffa8f85e7e6c7599430903a06fb95fb7dcc1f5a425604e3f8aaaf67a6a93057cfd73c92bb28c97e260654c250ec1deb17e207fa12dcf3a292fa0abaa83992e350c87545a0f77abf3e4d020bd3974cf3a3631a181e643196e9ccf690d0135642e1d08260551472f195004ec83879b6a36573d6a2971a76e9cda0ad3746288c95a7d0c6faabf431fa77ccb46dc569da7cc8e7429561cd1ab85d46d0007c79dbb2345ce74654fe01bc2cabae1ef9eec8089e1e30b79368d60f11ce7b8401be90023d5508f69277d1ac07620125f76c61a5953e5a6ad44ca1f6056b56edf42848c049f3f0c927055163a8e4298a9a0a95c1a9fe7584af0fd62deba01300b9e3f37becbbfc80bbcfb58aafb5505dbb512972bd57499f1136962f5c5ba9bfaeda9a2a8758b349ad0d2e6db68c18c2c007818067033031194b62d783d4a6bc49de76f480a808f592514908d7afd4a2825d08597782dadd053e232b434ec2b4607f8c4f02a6aea189bac04fe3479560cd83b2516bf8b1ff2b4c1d14050eaa33757e6371f3d0675b42a86150a574e7b2cf68d037e4bee7cb5bd52bfd01b6790915e0852ebecec16c61cc92a50efd6b5d4d31335b2cc98e27a3e4c4b22d340bfc31766d57f5782b314ea09c3b4b55b65b91c9edd6176593596cac4ca436a0f9eb2718288427bc6431c25ce9c8619a8b9d786477e0a136f498aca24f3bd388d5855be86b98c256055414d2816eebe32363a23f475daf5f133272b32e0cc7389edca127206ce3a58867949a037e862745d67645b8f7b8f44ea6585a1c34dcd4affaa13be993ef852ce2ceac265f668b73b3614f54a572feb38c38bbbcab4d4b8f8155cc5e0d40896c189ebae955c38c3d514d601b3f648f8e3f9e49c1c6c1c214e94208e7fc8bd9f2f23d2066b09e647e728adcb17d0aafc5e5351bb829e8b1da960a87ac9e748907241340a9ad57e71406596fce76f3e5d2f45c0894fff51d682086561dd9d19d3baf172a85d3bfcf4e5ec120b25e5bf5634d7e1eda358af7874f734fcec2f88d0edf676b15d66cdc9f646a5e1933ef5c20ece9d7b81c545ebc73df7745af29db2ba930ec5b49e4fe75d374c9bbd1d36d317f43c6ff05ce48d3e6259abf9aff6fb645b344ef8f1129ee7687878187406927ba4d9bf7c9ca11dc42fbe817d43d99d95da751f1951f810f9e4561807245cc1d383124ec764917c9c9d0fb2210ac9e14cdc38ecf8222650735d1e17d930fa1a41a4916909b91bd1eb2435cdd34ad84dbee17411f65a3bd0470b7a383ba62d332b543088a8802aa390149657a6eaa8b4fa2a99a67e34cdcfb2f4b065eb6feb50f230f68df18ebafc7f868cfa121974748247d3a68b3f318875cdc291daa7e9c2f0ad71557f8892a460bad842d1bb2c6d7b119dd84676ddeb3c31984289727771426e912f67220710ed2528878064f69d17c4b8631972b37a20026201193d0024ee8b97d35a7bc396d995b69fa33830317ee345122d1f0c940e30c0a52fa993003c17f29c0a703ab92c1cf1d02dae9d015eb28f9f2acb31f5324ce23ffee33b7301b051ca3317a2d2d25426588c264cfd7ee8c0b17a6e977dabd04534b55f68dfc50d852d1c05eb23f2891ed0bcc80a0862627d2eaa608a6666964e403fa97728983e270e7ede3ffa89db840caadfabb87b028cc8c36f9f78580bfd7008010a2999abd06fc66c99554791341bf9624b1eb0bf9d0c012d16f5db4a8b8e073041f1e2228e1c9a77163675143e1f3f61785c49cd123a01c974851d9f35f1e78c285f9c18b665e00e7a3e3852e56d61e082bb9824ecf34dc3379092c439686e66ca29b36c9a2ed5722116358fbe793c6f3330fe70991bc8da382862e25d2483dfb11c3d5275f8e5e5301c2b015857b2c474592d9da523c6b77ecb0db481af398c1cf9a2b303371094b588aa6322aae3e42138ea5882b5262166d9aab3a1930b16b904f30b72603916e39d315569c2d89aac0fc400b35c693d54b9eff5bba541b6107c7369054b612fccd0b29c7d71a945c021e20797bc3311a7db45d040dc0150e88cfe01127e3f8569670411d568c40d39b9a76c041df2328d456e337938fba709f99b47ffd0dae820a1efe200cb889fcc15ff0053526beb0e0b7e123f3b333e6cae261bcbee3dd8b3a144e774705693477fd566bc740a96a14bd785e7bc13c801af2de7b298a7212249cec1bc64adc6d494c8bd7e279848d1f0e279c6b837c28a14a267a640b9b3d6b83e8dc33d05fc27562187aa6e32f3fecde995f4f0b879cb240d4d52f6ff1a14bb35c9644ee0c7b395f7b1c467c75182b6f4ba49853806dbbd4bb173f3fc3d0882351643de26a7d4d5c664f77392a9e85c65300c64e8082aaee60960308f728661172f8f4e04297d132cb03191a0f7dce629c3a8aa35594994b2fd0f89290dfd8fea427a442f5479eb78767fc52fdcf38407c6a27145ad0834ab407bcd5f2c6f4d38f6dae67fb832cb8f0a1e1c8303a2dfbaca2d4fa514833f114315701ca451404ef2dd38a427147fe8982b00628f2e9e376870e9aaea8afefe39635d23ba3e8922e9c4a23e9a20726540603aec990aa9a1adb3be2ad5006fb0bf3eed25a2dba8cd1b69e5037af61847ef20746673b60d74c06d26c56a777a1f1d515926a06f3a4405d24968de32c261392ad88d40acfedc032a0e58cbb55a540003615c5da2ea8cd8300af40d6a44d723b2cce958aed80060e37a3251ade8326982c20fa613f962f7769757b62979657ec7486d00f5165d1e951825bc7a6aee3896041fb2b29d5646a98faa2428ca5ff28b2977f1eda8285713f09db8b845419ee9acf5aaa7b87185d5ffc6fa8e2e51df8ec4d3628fe54e949e60b7204ff419f6039866dac0a991d4fea6f557eeff68eb87cca1e9fb485de65bfa1290cdb0c29d5caa0a46be30c9f7d4e67081e41cec6b20cccdb4842f7a6a701f17aa6febeed45219474d936ddc37a128a7908b2ef0a3bc55d414e490775bb18f595c8236915850176d43d18bb2017e562797fd763a8c7fefa3fde45da721bc4ff729824f8d4df753ab55e79de62296fffa79f2e9bb7e3a1d995e004c8ea0eb9985c7540b13bdb7f49ad8a23a65cce779dc98bb84c2298517a91450e3b5c89827e3e96e2e489f75ba00daa0d06574f5976cc443cf9f152d24890de74b69559746b6f1d01c7859b9724a49f45469ac96d6829af85763e6f78695ba39786b9f319554cd08a72ea88ebe33c3f5d04b9eb5bb2d9e657e868c97beabb16fd1159613be1cf7af4469b7050a6dcbf735cae809ab7154c3c31744d9ab5280d82c113d42d28e9ef1b089e932cd726b3145302a3e68ab5568b1b0714125d859a6509478fe0ebb76cf9789c9c48df62ecb3f014a756bf3dd38784db16afc6a73cdfc4cb0f74f1088b7377236dd94eff9eeb1301f1085b95030b8aaad01e05fd8fc6104358d3251cfc1634f84dfe033d00ef4082555453b7fc9fe542d908f81c00e47c983b3f2b7a5c8125f9303c1b4a3bdfaf829db7ca415759e606fab4930a12febd7576d4c559afed34cbf6498ccb42fe836c907c1b6a59e2f093603fc7c7f3bbb1e56a132f17ac85c0bf7eba72e86413a62391e906593db863232e6cb13616846eefdcaeff56c83c985012e8d41a8f26df61142629eca71f9d01b975caaadb77f398dd96a3da8f370237cf995b5066bf0458204218835893430429336b9b69edc77081b4a0d912955b6309ad5e056dc3d6634f811f727d90074229791230626c862ebba487956bf45c1f322b3df8d99d2e7b495ddb018f3f16ca58f808a9723040b5c56f4bdd907a5f1f00521578aef33c44cd189a4e2200baab124f0d01783ae50b1490fbe5b04c6e7d20b8af366990413598442a3138c4cfd2676eeb307ded616d81896df38ddc1a0a5e47bc451a46a335e14cb72a3af2f5003f1b093e5c3ebd2fe32b644366a564926beb8179a968f8c71fc7527ae061aea8a9afdeba477cb6b4b6c298bc6d48900a1051aa6df8be696d35b7eee8d83384f9a79e3362c927bf4469a2fc30eec242a00ff4b39db1dd50b707645a6c701ad0d70e8c92bfa5107bfd3a000e5c437cb475802b95fd2421ca66e1eee258a86cd1a4d3fbf6261a5e0d68b46ce0bcb4569de4828f8f328efb598ed17bde4fc71cdc19e32cb73ea3b07832a5ea5d4c37986ec45f9861fb82da406f837c4bb2a2eb81a5bf0a9a7b0cb8ebf5624143f35b7c10e8d53f5e563184460a656f3b28cc7b626cc9fc14a3816254caba1638d48da3070d5085c68dbacdbf7ef5eb2ef9cbf4effae59449322ac2d9fa280cacac5f31eec3095b3249842394228abb47ed0678091d52e99f2feb5dc798e29251fc49ac6403e31f62703c4be7e35f14410135357f4f6533e00f7e1b1e1f69c039075db6454653096def903e98e45a59194a29178e735eb35d5948ad6dfa38bc498cf3bd174902b48aeb09cbd6dce1e3877ae96488a0dfa966234fa2ee12d40107d85d6919439d8b385047a5a3054c8bd6ea43388481cc62b7290c2e4b182e9f6af1470fcbddce84f9d369991e172ae197921408b5dad9a90d785c27e922adcef1915e1dd66a7c8d0563d4aa9030d585bb8bfe5091c9166a02317e8914691cc2da3d3389556af3135a5fb5c81d132d6a1279c996364895c95a4297b7abc645a641cc31c36260aac718f3e05228c0f8e5b4216de4a0d8b32b5838a8a37adf45c9134ee2a4984b2a5b427cce75947b5ac1d987b525e609034a8de1c845bc8e21667fd7557bde9071e105b25243755345ec127cf207654ac5a515ac9212247fd29fc6a946e266721cb52a835ea9c586fbdfd7e7c13ba3cdca50b80a36041a85261a0dea40fac9593b147b4e390c58adc4f1866285b4df815b8ae424de136999d46a881ef84f599c615354b93f22980fe113358830c7605e10123392c3463b899c02f3bef79ae8d169c2524d2bd5d1b9586b2ddf4e89cc7622e6f7d934913d69dcbc75a05bb2952f8624aa701a7482147a4356bc5776ef0f757773e96b57283976479a59758efb231ae68ab275e4eb54d4d679a24c57536a8f9a9876d83b1536182adf770af48f0c8e239f9cd01821f2e5014217e14acbb48d69e0c3acc23b05cbf3c1d0ef6d9331d4be03d0d75932e4c3e4b470121e532dbffb70ab87cdd7d96db6cc0ab5f37ec3c522bd112260ede5091ba47f0f5896dbea92aecc1ca609c0d5110fe0e418f4ffba88c3e2fd958a560cb1b0ff57692c01c921f33ed8940320c9093172064554fb53b1123789136c6154dd07958a47821d6a100705817a4c07a06e33a293b037fa8ce960b092154921863125ff1e99aa4f2d74f48647820134e332e0fe9b0221680de8b7d3c2680e80cf2d07794f70ff9a2da92829143329342b9bb459eeb7ccfa131b5353c7581fff020cd854ad4ecd0a91621da3429ea3b1b5c79a0beb0576f2b3818fd88432c4375bd8b74acbcc66a471bd028d85b1315731b5154f3ca3adf98f18cf4435efffcb9ac8bf503c5fda2f25bc3b52d14836537318c45ed89d325f656aad67403cfb7f378697eb63ca800fd1b0ace14df5c36a378d24b46fb432888abba9c0edb17a071c94a0dea7c829174ab710c3d49f63ff48ea5a385ebc9e735488548038e7aaa870ff04c21c8a5274418f61f0fde18d695f8c9b7bef4f682cd9c361111c78a8dd1391dce29286a7d65ac0d7ef50dd7470cd9d6ea2756dd47c03dd52289e3ee02020b3a9a62dbeedc3d1f60d66618b98369824260c4392edbce9e44881e6beeeb8e7a9d80e99244b2031778557883d71fe2070cfd3153c4a771da680fff2b7ee5084df04671a01e5843eb44c9a0428fe07dac7da6b35e9331cae8f3ce6ade7c31c00aa1a0e900be303055761dbf90f41256298fb2f4ebee5e72c3135d5ff153f44ba03a2ab2bbe4fffa7125ccf8b6ee8af30fd5b6a971675c186b12bffd7aa634631183078a61dc032c009eaf5baf8a06b2b48ddc0463a45664210531df59f17c3f9a0b2a3827e869e0ad9cb0e14307f443cb41049f3f291dd90b55f3ff1b15b46565dbb14ebbf207c39a2c3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
