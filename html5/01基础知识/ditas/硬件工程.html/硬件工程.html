<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aed739992a11c9e42bb452a718ad40c6793419527b691a6e84874fac1a21e378ab091666dc55f7c452121710c9e48227e5f9790ae9097619281fdf1754bc2c2638d8526ec10edb975b5813a8c2a9ecefe2dfc7726e6f11878cf21044effe2906f09cc83e9bdbb6a47658cb3a9a499212ff2a56b9aad3c7866d6419c192643bbe96707207a3720c50fb116d04cf4a5386c917878749b2731b050abf7e10bc0dc53acad27eca58728409a767dcae9739fd8c45082634fec4cb2deb193c30e78cf0fca19f603f8a0c5fb20f3ac13450ba754123d54b83712384e8b1ef5574bb0df21b468254171c05aaced404f702a866ee58c30065bafc3d973233668a92eb36fed613dbe56819140c268d5e113c3e7d2aea7b40227a0b459da3bb852bc2466cb336dedd3e69aefb596abdbc6fa2c550a2ab9469bcc36232de62468db1c48f64ddaa6a6d9de7f8c7c22d83d3b537fcb9e71542c5b7150efb96a3b6a32d13a698439f5edb14ab01d36cbff4a6a7a5e7229b62b78a98affd9fa86a1bb814c4f7fe3dc61056153b856bb23f3bd2982714fff799c8d0ea54111562bf6d5e418ee3decf5e92efc31c421d0c45ea6cebabd7140b5d697a7352764549678317d6c42b8105481589fdd25d03f44af380541df91cadeaaeb8c01f9ed9575f3d1087ccdec8e8d0afa3a0b5eaebc318e62499589ee0d11f787226071d75573eba186102f50a5a7d180fa7a3785400a08873a8c1a1e410cebd0bb0a7131c152250b7070f81487cd22c52a77234cd386ad0fd96e62e8eee3a03242e277cfcd6bf23fa06adb6720cbe3b26d897d2699387258e0b2734c1bc3aa8b8c66dfc6225d1292f58e84e899c99478198e9f1b9888e1ff59ca3f7483bb8a37638d91a1f6d63da11e203e99e9e7aaffcb4228cfa364e3b9a2b8a02959184f394b236957d005682923344fcc36aa314ec1cf86cafe064bd0f3bac8396268af29c8b636648a68473d0cdc875fcc0277b21a6111e1f64ea5d7071773b5147d689b37d51d636323b708683560aee1f99bc72f0f1dda055bc42878aeb3dc3093e97ed5fe6c94a997db939445e4e272d7627a92d4b187a4613e07cf8078fb6b281f222b580fb7bbdc7428055942ec3be7022624cf81e0b6b74b53d82d543955ed928b66f74a451bbcccdc4bf07798ef22d35fabdb16fbbc434d5e3335a84b8f855320ed04acf5f3b08af1c8ee3a9cc4c5397381dcd5c79862348dea1606c3c266297deb5c29938e0bf158ffb732988c4165226a904eae89e3d1b31038c81fc65b7f6d52c2f3738ce9d82bcc76a4ad8850591d9bce8b5db9fd6f614c2f48a04c3f8044f23444d427ffb7e6332f86985a241d76c4dddb91ed65a69eb68c141129d0248d7921e3c49a2c7c2ff268517748bdf9ef74b737fc607d342c07cb9edf07d444e1728e3698eef1b1e50485c7294e914fcd4ad6b1762b0f999afb743803e50660e81b9879452650dca3818ba71242898f8459fa6c7d94fb38a204e828c7c07873a387a39ce542eb47f9de79aa8de262d018f4aa23ac20b58b30b82b8bc7a3524128517753bc39db3e35de7f7f8e1ee5cefa45d751721606870aff3c3c7d1fc21d2942b5d53564a2513434594cb7afd8db2bcc13311c7e00cc2d0962c0e4343885385da6d11b9be7fe88ff91797e6f0883fc24cfde716fc43b0700fc3836dd388c4b0189a5e929d1f342fe5ec3cef00d62e2a67d3dbef35e054e0c5e0f600d47f2c4156a8e5137d19f870e4cf1952ce00122112ad59d3d3ec261c27e5a7ae66bae4c80a96c183c2b85982051ccade3d21fda84edcfdd94872413bd97f8d0d19bd40727d54ce735c533b684e31f125a633d1eab3e403dd66c9fc898cc3cfd3324613b636898b32cdaeeaebb44df9dfa1b28ba12a229cdc2b7db384672eb25963a00285fd74667dee81f06bf5fe54b0deac92b6c8c4ecb38958ef319589f92995691140f7f89336176964ca40b30f1d9051d5592c4965996f3380d6a84fca8c4c528f9029f9d2db17b6ca49d9f82ddd7c840d68143ac3a6292365f3a9ce8bf13befddad804f29a064680391bd58b35039ed4c134bd1755809f6b03f6787d5bd97505dc90500641db4a206f6b5dcf391bffa70cdb3ecdfc2519e601a72307a1d98237243fb719e67d021ddd2d76faba2b2d4f97bdba60a8fde45e506108ae8a95163dd2b1427801a5325854a99240f28c60202584fddec004f8cf5888e88a6304e08e215c5228a9bdc15cd9576b7c7df4434d7f2686e67e28e80d758389612e5becbbabd07a7a0c0f6669ed6b2371607fe2442d3f27a3baca048cd30b9cb6248b4e523e4a6706ecd0d963bb7249510ca28e1cd989d8918af5bf525089abd2a39410aba760a41043a2a42e179e66ea46aa59873ce7ea662db0a7b58b4e64942e57f1a7e444c86aafd584815edf4f895192df510479c1592ee388dcc317b69c84e704de48f53d25192960b4fd876f4e5a59562987b7ab5798477eb796fd00bd4e168f370f2d506971790bd5c518667095509a017b2c9bea22bac9476f478c517ae0b2d6388078a6d1bd9005ab3fc0950ec4e7f56987ee91722d17facf371e0ea5216b3276b3ad6aab14c457c274900f649e32a7bd274267d7c7c5fe68bba02017ccf7c9fe881af6d29dc9982355f5711a5e9ddf3f5bf97a95a0c7e1d6cd6b6bf8359906b6252c6dfd63a8cb4a51738a3f1cc136b6c8625c6fbf41545ab06956e655ace77437b457cb39d972c4d89b04d3694243408876659466f2fccc46b88056e12464f9274e0ed92862c79defdc675504c1e356b0b978946eaa65b4d3471d5b3cf89a91114f49a5e44312d7096429c763e4873ea68c8bf3f9ced78c872618a53bde7f9073fd99bf3ced1ac1fd9aaee6912e32b87b4abe937983b1c35c5f4db965af9a0c0c2b053f0fc0ae4082aec4885d4703f80f4926e345c367c3141aaf3933119022f6c270e7311f65897e323ea01e2c46e826b21ded41a021648ead8969012debf1ecfa26a9479c87dff4c6a378ac87158ac75e52892f2555bcf3f8671b302e6d5dc12e8c571ba7e07f3d4d99cfa4091f40ff29318da55315b565fdd1d6a48b92fbd3214b36626baadf3cdaa946f9c901809b51448f21ec64f5aaf9f125cee191e6f31c87272ae82cddafa124c441e5ce649b7dd0b1303202047499d60d31c09774431fde0a2fd36c29e50de5087df771869f22c87d26ae287a0c80ddb1a2e65ad8526d5a232907dc66262a60dcbfd854e44dfe4ed46a54d9b0add6ecb27a9e1f9ddc34ea24c0a885647d2857712c72b577f036f43daf05a7705a73ffb7d90c3988b1c2b2d117dcf9e6ddc4372b34a0cf843b88eaa51478e46efbe31b62afcfd25bf61b1347c6c18a52f7323e958ff284affed31b299e289bded4a49d83dbac547c71724418acf2b9b3a1fd77b2aee7ea2b7fddb49f07ff00d5c52186c04a4517bdf326c0924eb69f42cfd727dcf724d5bb1a6fbaf1563c99ee46788549d6b2b45be4a755f22cee4249db5f49b655447dba62baebab48886eb417c153506b240ad605e9c36293e8110dca016d23046055bbf7985f62940072f55a43d781a3b22685d9e3d8da5b1d912230a6812b173987213af8623a9cc9fd28af787d2523bd6dc932e108a64578665906da1feba44644ddcadd1387247a83566277bec9295471f54b4530a9d3cf062272c999fbad23fca505162eb56f6101b655b018a36ce0715294944d3e31099b7dead7cec9b7bee094db6c75f3b80fa7732e74a71cec823b1e1d9ed87ca75549ae25bc46e1aea0001dd7301a8b0af77fc48d651974896ecba452ab6b3fd4440cadc3325ea2b28d03acfe9aaa80f03f4abb2bbb1a60fa5ae40c3a3dff792c745a70c740c6981de37f3478800f38661df8e7231ba46a8b4075867e5c6476b4808c4b45256db4445a0de459a6f5308ea8481d0f640b3505540c684aea711f9f3d8f79ef99dc3daee43162f35fca410fe0bda8b9b4146261ab1085d3d0f25f0dd47dac6bcd8b6c8d8b02cdc0a1d6c088919cea9b6957d4db03dcf62c9afd96361c75915d04ee0bb1b0bbdb5ef7a17ae114ce0fdb60149b26f16f70b16698e41c06f729bb301237458716a5952040e62ac4c5370d5fbeed502b4f44c2678c36da531754f81740afe297df626f994a25e244ffed0b795f9d49ffa7e69793877e025cc252fd6bb4b2486e646984041e6bbb32024d123fc02783ef11148d7901995ae81e231d02f50501bf36bb6bf4645399781a841c887a1680a9862a4d1932d637f5bf01218f6ac5aec2ec1303c6d2ffd072529f887342cebafcafb0286aa4f3899371dd0bad0d974b743f9a2011227c956cba8a39fcbc90c2225fc4c172d2b3afe04d66770f720f4c2418a253934f57c9f258dbb8f9dadb8086886be83d56404b3a9dc16d85623423c7f8a74b141c741456c1bc018efe43a23fbec572941b751db1e96b9ca456001856f0416e32f44ee953c23767aefeb4e2cf88056aa8d2cf645e6a2ca7de04600c606271d456566d9c510708f087fb4efcc3e3101ead3af1cbefe055e52765b2335a29b8b95c639ed77acf4ad7d5405765bdd5221e674eecb380a74a1b5a17397242e6362cb0e0ef9511b22293863f1d6d78fbf699c7dcb9646a98784cd4d0fb7b3301bd69ecc5dce5dee4b96c5d323b59f035513130c29be419345a6d9bfb436ec9cd942f140ec9f4e6717508cfc4ed9838062c2d8cd86490029d45236ca126fe524e94839b12d11e1cf7e32e98b5cc8e45af07b72b4c44fbfafede9121e68ac923ec272a6c79efc03b73628504f871c558c65b65c8c64edfd8eccba182872f7b806abba0a490c7c954f645d5815f81e96c85c286cb480ccbd329d572f088437bbf64cfbef8f402ba622c862567980ad385531d19cce7f5c134bb798c4c48e85175e0dde82aa2a512355332f2d176e7fae8836d5bf7df8e2045bad99428586fd48c1f075d47fdce4bbb727bd06569bc60143b57a0e95e33e514d82520d6b43cb6908a60bbed16540a206597b4b633dc6f03a1a182422f10b79bcd21ab518b3d6c27272bce3ec7b327319e025ab5edb02f342e9e121932490fb04ebed98eb30600d2e47cff031a5f6f2b043fea7f82c7c2a5d12b9d1c3cc57fcfadbe2d9dc2ade9d014911ffdc746b3ef4729a6fc62e25df62af6da511b073a0a4beab4ddced16b302ab962b2ce421e825f982167949bda28921152025c0f036704538e14ae8bed1a38cfc0fc8795018cc02b705a838e52ceb2b76807764f8ccd1cdc78146162f479fb0c28ca89ab0c45040723f6eef12e9ed48295c831111cb46f353d51e5801bcde916eb4ecfe8ea8279ee8c8f0785017d51436c281f38c224c3c819c05405ff2b102da1fb9dd5e6c8f34a2e4503a735d76300a8f5e45945745e0e00a1fbf83a42c96c64f0de73b4520b0a533f7702abdcba57b0976c57611f534d7259d370e163baa39f069ff01bcb3460b86dfeb73c2d2cf7eb608c0d129fd61a744abf3233b84a310bdb32f2cf6d24327cda943ccea62eb35332be5448ff0cbb4ac4b44271858c9128a2811a079da3116cbd66ed95cbb9d006d3c5ee8f7673245d0b9382e2d2c29549b7c9071c582f48d2d509004d17c0a8b653ea5edccb604ffb98118edce7acf7227c34d332c72549bbac0cdf1fa26dcdcbdb27ab163b2c504aaca5ad7939b8f10a865a80b0e191d5bab276b886c5bb8c9d846d91bdf861a3b55d7861285df13c22cc41122f9c25d71d4339634c733a7738fdce396b00f0442fca12d43c9842c05fa992ee4d3b45c9e0862d29f70fd875ec30db3d5eb414e17f9f17fc6c885ead1759f3a5b7c78fe5637377e6a592d0c17f3685a5d54614a2b2c3bc19d6b610aaeac3b0f69cf48aba7cfbb24ca2f18e23545d9ef3714796c82e07c4c23c24786ee035f79d77f1e1baf97531b102fd1188586cc798e7b45013f8be309c919c971df81f46f450686fc8d99829b1f8b9ddd6ea3a7d4c56b7a342adb4008268a6f57d2b280993f61fe734691cdacc3c6c6608510b46c873f1eae0752e2596e2d9afec97042f04dfac2b8db927a8d8626c71939860c56276d6e678de8cda8b71e319c082572458f9e922fdbbfff0d2f3ba8b90004878697c3a242301fe0aa41b3fddcb7fdf93572b2a6b816d70d18c5186da58cfce89b89ee66c8e1eea71a37b63b0a89c785d1bcca907a91e6ad1959da5346f214f7030f8221d8aa2400f82169fc837d9799b1b085ffcbaf90a1ac8f92f981c2301b5874261b9c572b2da1141ca41f71ad0042a13d55b510681ed57003299f3000536bfb1561e4d7cb586b0bdd4275c80c5d94bf7fc58dd35bd1171d54f0e4b7e07fb568b0977b6f1029558d498bc6f56c0f7d56cf5d877cbbe623f5af546cc5b9df29c12998b4d406c36cde3c5f41fd8e23b132a50357e367827e2d1d6b4430b71f9e34bc571cea25b0d3cbe18408a26c299430e380d2abd1cc4143aa4ff2531ec258e496166c94b607b932ac94a57dc6d1fa48106668950d22aa8b5889df4c1009826339c413bb4128071ff3f9fec2489364a57ba649f34362b277e1a7119de970bfa1175f5a79aab5288a8a201b1a508a1a594030101206c8e69d7e71411be04fe5686fca9d2e953919e799dfd91ee5864154d2a2d7e69f7e9cdd9649151bff346c910031605d32561042697d3ec28dee0c624151dac52b973248b76d443df48d29c60b6f68a93bfce598395a572013c19b445797307cb5e663608699824c99c3aaae778a497dab2643321b84e1c1244ce43bc845beb1f218d953c0a8ace2b27055914121dabda05d6bf5059f1ffb31a348c2d9aa3a7784cfd8cf63b9efc2dd24daf654fbd6a6c390021e7b0a35b6d0e29dbaeeb3620640087bef5c4f66b470881005245c52917e20a0402fd8d3b4c6356969311b644604ce2f16211253e32d610e353ed0b905ab1eb0f82a8e0fd508b1fd0ebddc401266144a824df7a8d2850226fe702c62c6ab80fc1ab69d88400e702cca22397e4cdb538bbc15e0c37b3454496cabbf0249c45d0b2beac05a2f68216d7f2f628bea61cfadc941ac6914fd07ed0661f97138671240be8ccab5207927119db6469801abea57b55284fa667f426856d9afc370af85378f8b1742482508b886859093efb524bf5da6916bb116d9b9018f853a8c4cde44493b52b37b9e35bcb50a6923c0d46bb7ae0143a7c5f4bda0e1f97c92b4845f9092b2eaffb2d01c0b372f5f4e0ea6bb5ceb7de0df0c7f0539091cbab8404861d35901b51ca4096a1b9fdf6445e42037d717e289f92af40fb1c88ad1dc627b021258317a4477b63e7e6d3d96e797efadc53a2454e0a6c06479047b8fa73a3a489b2aad24080998cb7a1a2dda315300048c214d5c70548f44539f3647790af778cb8b5738adc9277a39d124d661eb4e3dd45289a43fcd9f7f332fc89c35800b321062f794ce5962147c207379449411ef3bb1a14f2d2cbb2eeb8c9ea569f6de39a35ca6a508dc2db426085c5e8eb306656d58433d3cb8b625b5aa05760d714d30363ea3321fd167be63c32353fe5d9ae5d3a72a1c94b1dc8605eb82672e28e1284d9095ccafbd1312435e7eedb64e4e9695376dcb31be2713527416be705759a6d0f499e3268923e1bbf49984f4daf8bf35a4e5b3e1105588ad7265170b6cee7bd29d734de80d8e08066a632bdd50db1703bfa3580f6ed21b3f852ac419211bac91e6a984fc65dbbca933c30cdf63db189564a6ee7a6a08f7d9644d007897b13d4729695a39c50b22c30a5808629a7646fac5845b3294c261964029338e9be3792b08162bfafd31219dba4765bb2e404d0b357bad34dccbbe81f56ada0c2cfc59c8315aa8b597b4af49f8993ec6dc8220f7a64ffe06a3e4497e4b1ec35982635c5e9d084027284ef65653f089f76dd988a5d1b44f66b7f4ecb75e8c388e5a524672a2987925bf2bd49ecfc153abc21a316ed24fa2f0d969ea70e151f3ba09763694653b35800a27194a363e228176b7b03003b63c796e8560c8751383aff85b7e6f087cd4f6544ebc6deaff96887c28f5ba8cc27d78fe0444627d9959752c812cdd74c5b2d0f5576f43998cdb3cf3dc5552fc2b5396392f570859ae017d8c2a8a16336a2899e8686d38a93016c0132e04ee9d1b4fcd3491eba85fa781dbc1e7cecef2d444bf07fd92a03a97aa7a3585a62a204f1f741d3409afac6819db97e30a720e750a625c5884d6028c43f65fde51578d03b9e47328e880f43dced77c14e98a28ea75b1a029f0b52e1c6bdb3e4f7dd8d110a7e9deb93ed898a5bbf9948e2d833260220cfe2f837b522974648575c114223fe37aa2c32e0856d8d8bc94f73d9af2b7e84eddf72be585de6987cc3e2bf2789f8f8e714e53f4dc97d454ab825d03a895494c15086eed5ed0f3bc38f0055f874b55373a6522610efb837dd61dcf322cac88538fa5f4ff81523134fc5de72c2b0e3068c103d33b4f3efb60948883b7fdc78eb868756d66c4a6def7ebdd6a0562667fcb09abb2285607ceae588a6b09b19914b5c457eca9a7698880caac1b44d758101c7eca90fcc63f3b8ed89f172de642e77dfdfef7c0accfc125a1e563e7e0fdd015221e19f7fddd1ad344b47399317f5a6f9dc4e9d3686d01a76ddd047adec248270abca6e3f121fe736634d810085b86b7c2963234713067265dd02d4982ee741d3c984918b0d73a4450f58f8e172703bce854518041f3d421a4d8211aad89a351219902ae027fa7491b0153c60ef1684cccd5d3bd0c8c78f02f702ba1afd3bf62ff76eefa0d23f8786bb0b52272b3a52d56a73bd17d3e7d75a7e52291cc704a05518904bc7e1a93c3d38df1099facf0527d64c189811bbb87d2e3e7b7df35af3f3bdce28c2f1ccc4058adfb24758729862429a2b03b7f46ad5c3edd480403f8718ac8001e1e64492b8e3678eae6de4498da9c1373cede6b0f105974eb17aac2859462eac445579f068cc924b08ab9f6ee8c4e676acc40345169f73be69196a18e5369a29cd20fe64d6d9e4252cfc49a6f496c81151a975b19814779b764ee3c3f4de6044887342eaf7d30b7da143a6ff238bb3b6b9af8af22fa9bb8dc3d62f67bfaacdb255cd8e8283b6d8fb8c1ba5c9844410fc495d6ffec657862a1774f65a71cbecf5913bca55994f6ed4db00e78dd0c2c9dc6cdafa34805caa74632551a7a32cc5098929d2645247fcb70164cd42fd2b282a235e3623f97d147f2443ddee61c995c51ad29f232ea6f075d0c49336847b8bbfd0deb2d4da116c634bb4bc6d0f96f14e1a73d2887676a1bf83f47b387699ae8d2cfa7599282ad69ec30c73478064d448b2b04dbfbfbe24426ac92d1392d3596b255a2367521f6b9f71ee85d07f10187b001d5ee22d362ac90baa74fdb429c881e0069541268a9af63ee50a1ff678e82e6df7541fb3e9027b824d1f37cb65b6ce87c28bed80c03f701ba279b706e9db047ab95c4e0e634198114be729f2757ce66f60092f0fa4988606cc1cc1a40d11544b4e9c1c4468215dc443598d1d3bac98dd57cb69156da1387aa1aa49450e3c3c9a2c5a61bf418d38f74486c722d7cf1735b91c9ae9e22b065eab621c3bc2f00d8e7f840e5b865e786e94b5cb40c28deb7b2cf6110bf86ba368d0152410401be5ba9dd94dc0644330f0c9efe198738a57cbea7a0d454f668cd20ec4a2743c2e962ac788df77df00719d1454b997c40a3649c7fcb99110b042133b557cd029bc14a9f255f0226e3793c29701cd9cc3c203491257ab3b4738c4e96c7d9950504a26e4be93e8a29db2cbdfdcaca4b4887f7a867e702d022574ea1e04a70fba25bca22c526903ed5fc6318df8055ed0c4974ac5ab7f1265fbcbc96ab3e31d06bcf7006ef9a4911b613b83b51b9135b1a4d34fd173e625faab8cf3c0cb973f70a77dd6535a717d2dc4ddfd761d940a749e032e6448b8c2cb951ceb67ca8d6d6551f2c60e2c02374551ad22f94905dd3547049632137ec8a1afd3fc8544446cd2259cc2541bd5013629932e2d4d7be4ba67822ff21534ff0d67bf6073ff5aeca7c4e09aecbe1fd1a723b2cf14f7e748349a1064746d2658ca4f3d61a9bb429b942946610d21f642c6bcd23c71791c881f2657a72549b9513b69398b25248a059b4e6638f1b8be209ac8185740a6b777fac3ac6d89d93849989018a65a28a27259fd85221a542790ebd3dd4254efa4e146b10d88371cac88846f990a5893f1ae0a0281f45ff89ff3bab39965d263e140088794df2de4397a2965aa7f03667a2b4f05a303d3cc739c645f018cb363ac02f94047eb71fcf6048414bc256981d0d5ff889c839c21ba8f19488ac1c2c35311c902fd5467d168b38ba4a5d122e1130ac94d3ecb8d955d3e16893b9d7d11c8a4abcec192052905d4bc72c5b808e6cbfe1a29355f28cc268f7b722f56eea449305d7cf6c999f98831037599913ce4ac3190e5e348d26fb755ef9d1405c5ec6b193f1fbaa439cec895b463499efc8997be9a32c5e35f350e0c623aca3c64554b82489b492c503c5890cf42c546ff26a1720b79a1672714e9ecec46a9447477193de0b84e4738b79862c26ad0c1435e4c35f3eae60e83a2d7d69e1f8bb5200d99b35b17e47f257389b5cefd0b7a469de21c80e9a5775fd6889b87dd5d15a5ceb5a47c951d33cdce193adcfb640791d1d85ab4f60099930f42c2cc264b29aa58fa595be0df83e01c78d5a8767ed1297ccaa2173de573e1d566703a9177182fb610b29a51689b62279e0e91faddab88368ff5f916ed2cff8c4174c11b2465f246f290c73b5d33ed00bc6f3521790457f286ef629434c6cd9d251021a633f26edf676ced9f4627f1b124a536fba3354357fa9975003dd0f398ba739e33788c0b6c5805736addb2de5bd54062828f0f4d5d05ecab57cccc29c40cf5e569bc754738d5e79d56e4b1ce5b08d4de26292097e8640e67a6ad236c3063c5d5ac5924cd79e02fa252d66d640ac73c5e5badcc0a570b402b79e9b863d8818c58617256c2fd7b8f3f482ca0d176973403ed091f1823f3a96e46bd7cd99ec45f69d45489a0e8fe8197d07a889506ff2a804ccfdf06fade4884fdf391a935c42099fcdd9f3157e4fb76aaa42fd8341c2bd1ce75ca201c7fc2c5607c8af3419581d7ce88c5a4cecda2b1b1889d01ece66f5ef16a702c38ca18e02afda8e1844fc3a9371eea315711af8a9a032bce21c077ba218ce07ef0f3e7dc7edb711b0408da86cd2f18473183ee7c603a85f4ba53ebabc020caa2727fa0bdcf64b4c204d030af6742c8e81ea93c1cea91c9d1fe11229eabf17c1b9788b0a9ffeb5066bb48a63c9ac8bfde7661abe22404febf6e4026a1c91243bdb377a1d2c9026ae564a31bf7b06c9ed9ffdc7325d750b5a4dceeb7ea8acc0b4a4eafc5a445c03ddcad60de34ff75c380b90da7cc2705ecfad4680e69a2e7bb8a456a2b07fa99e69393a0e5ae9052db05a2a011fb9f3cec1a36a74b48343bbaf97a4de2d8ada1306e4e9988302ec30ea2cf4304758facc83466d46e20611f9229ab1d14e4cd256d275f0473f632e7f8ebaba708081cbc8e9225e1d639a39e7c404310b50fd7e7e066d85bf8e33ce4dde8d302fe49d6f8380e18284f27d9309a81931ddc18b3a0acbfe32637625f91f2e405156e1bd132d1b4577f4058b12a55e42158df959f289126c9a696c8e8ffa58b50fa2f7a544976636e27af9e59a6d248c7fb48cc6fe01816fb9eb012363d1d9abd2a8471d105c6dbb5d1f9228fd8850c405e2699c9c8b96380189c0d70ae1f6f750bb60756df0b80eaaf16aeb3c3f50c0f237a7f1202b2347492d5fbab5b011078bdaf9d0ad4d7978cfcfacb680ff2ba374f4cfe8947ef5c3d0971630391827f7a903cbaf96b16f5423fc00db7f37ab13199aa7f4ff7f7bff2fa2b5490da6bb07fc8c188dd000e6135203a4c25e7237e4c62cbc73232dbb1d95215da6b8688b3e506890a0d54b3da6f9dc347c3b09395f96cd82ecfbe1df9339d67492d3339f764ff49274324e39bcdb5b3ee186af596d6cc478c6809d9e0ef299aeecc8af5732802ee4cb86a122282e416649ec10397e4e8c2539a54776c6834ecf3d37697394330c7e0182cb51687bb694c15ae745c7ff377f0d8899ac62375b3c7d28dfa929b6cbe5ff0b9976c2e32695c12c104c9f5b6ce04bbbbfe8aac091600f135e2efb91b83324ad11ef2341177bf3923db066dd3a2f300630252aac3b3aed3dcbc889b970d9606de7425bc2642af253149fa7b2cc6ae1402b7ab31a11fd25631fe2d7446559af5f287e748a76092a8e15faf94e36f38165c89d307791571e2adcbdaf639414512b43c544236999d7c975ce7291e92a3afbb308475a8ff16e49d0cca46c47aebf8af0702032aa1aa01548ccc2322bd198aa9c853f36f15b1d725af14812c6832ed24f9c7bfdf9ecd7f0f44ada80","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
