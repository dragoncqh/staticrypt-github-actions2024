<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8797c824e3222642a0971d438854d985b3dfe0ef2c3228d22d4d172677f3857982491425108b0a555f9a577fb3757fa5b0fd3817d3f4f90b24eb88c6c853fad43d1208f633710d3e8c139559509edf4a5f578316fc5d38430cf190d09c8f416365496df53fb378e66772e9b03283f91b65d391e736f185a96496c5c2a3364b1d7d1142919b8a2133e265f6f880b597f1f9f2efdf36c7a23e15dc1375107bf876337a45f6255d16aa682bae47ed148ad18610a92c7e37e0cf5e06b3d862cc5ccb797af8fb6d440d66b6e27e1531e68fd748ad9bc01a73a519f76e97e31baef25641cbf275ba3d83e5fa56cf1ebe53d15913b77d714ac45d8e942493c7b25a875bba29ddb61c3d46a11b07dcf802d566fb7d483244c6ebe9e950a126dca22b87f325fd66e9177f7b72b72b2370a818c792f5d018972ea24f49d17b5d43511e1b8c8a91d7c34901e9c5baf647b440b6f17267144bdcdbda438077246bce8056708b3392cba1543a497bdf81ec53afae740073394a1c6f8458695a51b2986d03e5e16faf0e68ca529986dec5919077a8ceeb5b482aa28914855be11d5bf3442f5961fd1765c74c635038b297d6dbbc60b5da112bc28507e42113e5c898039604d6f289c4443868268021039d1008eb6a157bea6c05c5c4c65f05dbe1a02b29df8f521094f6f14ec44b4f13009d79d0c1d373d97dd24ade979b3c79f37603671215f218a8fe86f2595a8652006965eee36538e162d57340647671776f96c11473a96f5ab6fec01e5def80fbd7664879040eaeec521ef1b5d8eacec9a95944b8d7db1f62f9d78fa21621d522280e2916dffca70b711d68baae3c3c1c7125de7085634f84108d5a6f43b0c25d737b2c11f8967fcd74187a3c83b87706460992e1803b651b40561536300f300096fb5dd3a411e58003912f956713c8f7b2b9636fc15dd1104d1dd2581fa5729aa3b2bee11fa4bc3308f26a1be427669473580a1613a366ff83667e5572f945d42d04ef3cd1e7b48af12a461500e757d71346acffab99b61678323c74dcb3fd05f28aeacf79c6efcd7a2d1035fee529412c5bdd1a741cb7e5ca38d432d4387d211333f42411d1fb0f35134dee1bd64bbd1fb8a493ce7b79c2117fcfef3befcdf74dcbf8c03cb6fe83c10e21fb4b1539949309ddd5cf778b4c3a125f40d7272783486b4ef4a11c9a8a802e07aa7fef2ea8bbb7c039154bababc97b1b268b411b4a5fa6a5a3d020456e153219d5903c2a74a329f7631b146e2918901e8f543abc8f02eb3aa230de84a83098c7329b178ac439b17c682b1f28d9e3d6f8105b554089da69d5102277a11aa6bd3618722228d522303f09cded97991f8c2b47c27a894687159fe99b6ed0fd041862889b9b3980d6a060b277e8c76177a777e324d1a542fb90584a0d47a703b46df1e743ef1e15081e54d5645648e3028a7a5fab13d242c5645880f5a89e416242a44c4609603cdc941056f1e62a8f5b401a6d96c3e1566cd02288d9e4ef3cf4f4eec57ba42901f4cb8b6205e43868ce8a110d82a9dc60e9f25a7ea47982438c43c656ba94ae7ba81f23d941dfa68c8f90609679ad7ecf74694ad9f598fc6c5c156735c3cac7d3fe0e187bb3746f41528e6422dd4cd906b43c6ab5a6d2c3185efcaeebbb19bba3cf79836b7689f16915b5789a0ebdc8bb9bc73cdf3a64f2c2aee25100e1ffa322e647bdff97c998ec6c5f3c580af72b01caaf79c3bb2442f26d71a31469f1e102331ae0cd3ece18287d8c996a551ab12bd72eb68eeb7ac5b502b29466fa8d751a26c4a6f6f6bec3696aa9e960617a0eea738a1646b97bf4eb077243937f24a61d6f43d890a65f24bd9bc04d382048ad7e82ef28033609bf2859fd4227956c62b5439501cf6ae87b8ff2fd329603e5a0762a322b7ed8acf3bfabfd0bce337188ad03c1dc8258e9698ae218c30f41dff4ca26da9655d6c0eaf479ba3412152ff6b3d4b2ab93bbfc40c3804231a5f1f5127cb31b760333b8b671198796264578f530730e118f072bd259959d584ca8e53ca97bc3e4bc5a845ead4e90169f6dfd2ad9669fbc45c499d32f8d1dda5833daeac32b3b5b82da6832d139ddd4be22d846959042b698b8c7a5769710588936c8bd16b9caa7d6558517443db2e0a63149675c1564e52084233a8b4e6a7e846702c61e30b6bdc5952ed5e955f03d1f33c10809221f99984767e24cbb1a970b7ea263078c26a95ac25b617dd2cb6249c659a35a20b04a82d48290ff7d55f08f8f88421f61040f4a89c134c3ca60af526ebb1327d84afb3fbf64e721f7f345e6dc43a9f695b9f002fec743ad16f22052901cae50cf1a56298afd77685f1a7627c3a6ce828606678dc7d470f7959511ada521397c2cae084c167794014e3fa726e2ff6dce0d463cb73b952c3654f5c93467dd7b707caa605397f213adceb65c709220426ac6e9ca8fb8984a3bb50b2acc59176ca51d1149d7161095e1e1edde3aebcb9a574e5bbece8d5d3ca1fedec5be6fcb4e672181fbb9d24036767e013e21177ba4b695409c5682bd7ce7a61d1afaa13773a5b21a90b988a16fe063ff192aeb670cd303e053666effbcc21875c732c2ab6e04364a4ce0ce7ce9673d2ae01955a5307442f7bc9a91db7d8b305e6ce1c0f1adf08c112072a3f69f6c10ea888f699f8f4997511885e705305f4314437fb4eedf045bed7286fd894eccfb3497e85bb55ddf52a4ef9838363e7c631dc714b246e5b34c41d8ee2685ac47d434e09b031776477c7d686b05c8c46865d78932d7ce67f7ae7c49bb601930a301171a7a8aad769ed98adc210039821f5751c99367721a9792350d9cad402697e22d1c48c735d814407327f71b3accdb80d5f967b8079e41dc638912e8f3740b89bb202c2e87510ac7a18eaa308d366dc2f7ee78f97a64da2ff0148bac715885c9a8fd962ca099aca2b00eb9793611f61d8cd203e7f397c6ac27f1e5f23bc4c36a0e06e78ab82fe862f58a28baf1918e01da19a3b606cef45bf210dc8c51204b9b96d1a6f0722dc34d616e4433b327515c328d23c3b69f62765b4d492bd4530b54a23caa427f52823fc93a8698c4fec013166ba9818c9b0b081de1b26772938c91cff1882ecf79d7b92894d64cf73bf878f490f5ee72214b655cf7c0df59d6d8bbbf6f9ec5ef01c91246044b3df337ec2619fb4c127d14889b1df897bf4e603b28799726f0532f42343d419d2414a01183bbda2cc62a0bdfa7a2b2f10574ffc0f2a95c2143548872ce275dbaa9eff55a156d9637fc6b06853d344f53d22bea2f51c607423713462de1e2fb12d796e77dafbbaaae0b8ac951479f86b639ab657d4db5e65e022e2677f8a64ba9423a99778f121e7ed4a2a88a4a9da9f9a0a39f04613ae4746fa5186be29233a96eb55bae8020cafdc984882d5f1e5c25e1ed6c387e7f57665df128843a428f85beb1b8ea2a972ec357ee1f50aed9ce937759db83ee0b32038d17dfc83d35be0b702fee639e0c87d7ad2ba2931df67bdb451088dc559474f2bdb562045fb5ded7a98cf20dc69ec0435e598cd855af1bbcfdfe0c709482c32da068e44cc9e1fc89eb32d2762601237a50b1087ed22daf776b06ed1bcbfa8fb07da666a9a328c7e41c7d170c374e103331491882b5cfe3c4497ec46d7a7c951ae298b63e641545c5d52ae4f7eabfbdf971b8cf668e61dc0d6436e2f595dbf9ef1dc0c6e8228fb0163cbf3d105ad9e7fb26a188461317d2b7f074daf4821cf6be7796c1b95c5bc23f8fbe04af614678b85c2a2f85a0cc3d0c0ff037c10315803c89f75263334fca5e233475ee3b7a69033bc6053d01a36d46118702a87b80e47e3d564f3d919c157da5bd9ab7beb97316cbf21c2feeb5840f9c9e8cdbf2383c37d57a96d20c963763a1ab086d9ef8e0e9d815cd1e45a657aff7b8304b063c07d757d34c3e195dbbecdb466505baa9327381add4c4a12810d2089210a245c3d6950a8d0365742f5de8344661809c44b5f6e32cd3ff327ed0f48499c50d69a35e34a69fdfde2673a867bd1d8309e974fce7dc7737990dbe882415d945cba50668486ec435b786590f9883f1188a1f51f9d1566f0e2de52fd588d10596dd34287a599e2af942dd2624dbd1580dbb8cdc1021e2a0dac2c2e19c74c773cf58fc30f504d65511746e0122f4302c408c852cc44b58c35492141584bc484e659fe391e6ff40601fa96312aa858537e7967c57abcb716208270a1e4489abdb97ee0d982bbc5c5e244331f5ab4353659e80776b843dfd423ba137579b2efb8e439653b9b795299424ad81b3cff9e0a705e948e3d8beccbcd68ceb232022264c64d85f43979be73540e08105397349281988cfacb3d524e44d210f88464c1bc388ddfbcc0a1508294d4dcd21694a3576daec8b5b38e48a549eb690789b20effff4884ddd0063caa5f1856f218c6fc38f42b0d8f54d2c8ecad1af0cfa8371cdbdb10298c25349f32946200cb213132f47dc2a3ee117d88945e03d823c9d3e228cd4d356fccff46a5371d83a9575fae24265ff2616be31dfb2873d4dad915ad276326e232523c8be42b5361e2b0637416e4343886a74e749a961291e9c2ab3e491aa3b8318b1def9dbb7db7b95e88e399fafd2935c70429caeed79a88cb002eb580e157c4d67c2d356d135b727795861f158f76d55299ce5bbeabf990dd55e25e53281e6b4f3441018b709b1e67409742a8b1918432a03448314b7477eaec3829490ba206e3fb46777efd7473523e375b5d07516e59f97bfa72b6be1fab46af69dea8dfcf44606d67419fcf20a60dd19cd90808b500273ed1187dcdbcf548d10317e9474c4a118630a9ac028edab50f98ca6d5044b534457cb45097c809ae2c64ae67b2ff29347cdd4a98234560269594960109b6b92d040a13ac2f9089daa9ee631c44f24c5ab1c08a1550da916737a0c8b468f59d5645fa5457e872c83d672c430b84afa742bdc03c285300588a5e97448dd7902bf40b1faf9fd0a86945a3265853e28ec9af0c6e3fc7a25103cb3d0f23435d4290d45c04d37ef3db266fedf43646a06d058284ff3344f08850eda3499e38124ddf69ee89414dd8776ca0dac2108a3b0aa2a29a279cabce5342441c1d0e7fc6b4342d0935d0ff0f10a0ae101ca8d0ad376806cbf8d8a2ce35969f858917cdd44c57b987d2c8afebbb0a6af100bd124678f28b3e0dbfe7d3991ea209ddd64c298c07087f200d8e7805f50b774417b41874a82e355471c2fe014075073c2fb5ff15076688672ae286b764f74785b38f0332174d4700356d11aa7de83009bc9b3e211561260c0238a664621af5fed14b2d99e6ba4e70a7a3a7f43eb67b60d1bf72d31d85ce5f089588614ff6ee16a307ec8718ca43942b339946a5225084cf57197634867926d71d313a6ef51bdca830790defe77be21e19c2f60478bd507aa7834de3cbd48cb46bdf8a6359cec49ce5ad91d9b27b75d49449f201a4466fc6b5b79ba85e3ee7d4b1e8c5aefeafb9186ef516ecd5d07ed6cf9efd8f29efda95b906a733c67cc7a13a600a2624e488e2c09a58c5eccd69e7c691d6568a3da6854719bfd63b0e77d688b461a948b6efbf329919641febba1e8655d758e8942ca19b0899f60e1dfcd24a460cbfde935883651e010167864b3c6c4f15554e910bce64d832d438b310ff76dccbad28fdae15d2e516f1cc24da677c4bc01b8eb5e5bd370398f3c4b466c19fa430af31befdc61a9fbe766465a1a6aadd4ade47baaadb6faa976e7fb16fbec9926089c5d2ad9a86af5a2169ed18d457c9a3678c0365ec1993f4abb684e773cec41973ebae2eb9c89ef6d8085123c3e0e91d5041f79c34bced8548c2eef063f7e2626c2f8aeba980001edf4c9e3b9b7cbe997a0845066ba6dadd82215021ea8c23cb07e02656578de78930557ffb068749f804c48b609c4f4446f25887c9d43ce73c3d950ae99dcf3443ac0c1bce21a8129a08204454cd81c81a2c82efdf6770fd736b322614ca4942d1a6141808cff9916b2ae2f11881e44fe9459bba32743741b75dc923ae75fd78c221f76d8431f1757e808b3fa07379d95d8ffe80d8c274bd2ebe858275ccc0ca1aca15287986a4eb610e4f07fdfadc372c09bbca026d12639be2d4b3e552e573e6b49def69fec111a29fb7772a6570fcb9d5a322ac34eda240dd60a89711bb45f0b21e08acd0ab9cdbfdad9753ea500a1f73a54a7ef6765d8d1dbe8552c8caa6cb22aebb661b6b105691a0f4496ddead1e73d4de070f5ea51c21123aa33493fccd71e324ec775d0af99c562bbcfc929efb4d504d8fc114681b6073a1b2d5784ae815dcf50648f15d2ce38a863e098b9ae1c616f6f9bca4584292a06ce037762a43ecf642d881f04637f525d1193ca3f7096ab51d2db1a4c2d7e6cba73e3c79e933add4996063ae9ec191ec5dfc668fe4b5e69a88690987f15968115878c8bc6aab10c1122557e0adc624704f728139300582cfe411b0eec37cd753cb329e8d1c118f3788db9c44bc26ea342186e81d86374fc22ad62e718cac1e97b54038dc521ea3f9a2dc924eb666fc6dcf519d6a5b2560170b6c4c8c4bde7a552108197afbd6bf1c284d536ef46099f0ed0b10ebae99b5a809453cb133485284d9f4a20e3788ae4045e40374df4d7f2561ae6df528e00b95e5f2327f273fdb6e6d9d1b67a9daadf559fe31381f7f1997880e68e3b23794d87f97b9750e3cce7dd9d84409511b8b3d74caebce25ee0a33b2adc4bb2c4b15751aade44393f78e522f891b2fc36d9765dd369922333af883a3ef0b6e13693542e97a314e82bfc29e20286124c1a2136a521e9adfe02a1da8844bbb119ca0154af516e383667a94594d9cf77ef31a9be54f97dd1838a547a3976f331bb7d621e0ddab3ba6b363858e230cb2ad90ccc5d22b8d42b54dd8a9ec606c0991d7cacdaaadfbe86a1707f24f468887e4f75fda420dca147978fc4dc2ece1bbb8d245d1ff34bfe50e50e6b535450360d4beb04c11077fb21bc043c594f1e08cf66f6e6eb732cf44e42f0cb9c884232f0ff3979ee24e12fd572e966f5a0d8f5e36f7dd105ac3f5951adc5ca5278ca36a23c33c31785788d8c312af0a817f886c7c7ef501f85d12973c4760e1dda9d24c460f963bcf4a053df6ad4a243f9a56c4fe4e932bc53758c5271a8a806411bce6dfa4fc4c452bbb6113720a80464409bcaa332c2af7abb6f51e7c67e8bcadf1f2766d5bec87c6470c30df5129b687fbd0aefce6d0d150ca15ddc9b0b48c459ac3d61d988b83670827872ce3be1a21aea7f602f05a3581d21befc63ea4ff93a22986465c405bc2731fae96d124f31f02164fa3c8841bf14c0d4522f653f87b855802d8691b23192bd42c3bcce4cf70369c47aabd602aa572bf1d59289027bf389dd9acd98232537fe5697b9d6165340369565481ba303a77cec04268e3557c528d0e6a7ca7054b2db5a7c65647bab11d468230925273c3e7d63a1e7d03df39610ab5077a09d10e495f85bc7144eaaa3b732d7cafb80f1e06daa59bdc6ae9e4bc9a041bbcd89ca6e135207839883452536014299392f4afa3ec817611609d57cdf13198a38f4336b7f2a35de133d2a1bd60a88995dd53f60812ab995544260e5471747606fc486d3c35f55fb593c21698f773b91e770489a59f3320d3039df84a2678d458391c8320346c6b80dc77b2939af7bfe81f19a23193ddac96978d8d679196426447b74a2fba1b2180b79c85feb254700f3f560ca2fe59b0c642eae0ca204a3b2692411eacb32be409dc6e277b64dfaa5db06fc88ec3a3e0247bed40a5a13c3c914df0aeb134a518a1c520ab6464a84f62c9c3a6162e0038e059c6dae939ee2b3dd8fcdf6cf86758d387336710dcdce7fffb412d64cbf6086009c711906896033460f7423e5ac5556d9939f58d8950d68118f307068828cf4f732f3c4755e6e75a1f544224f71d55fbbb333372dddb1b12c4ba55f1d741b7154e7dbdc693cb65612111295c6ccfcf1398e20ac693cc109b3f023598c5bed55a3222ba5e986b3867a263191c6f2de3891e775ead103f9f95e41345f1c705a66ca43c1191ab97a27335dc82c6e29684e3f9f5d7be563280cc7b74056d78f45ce965b3c19ae9519ccaf1be81a0d1534029dce89988477ae26971968ac59a17602f7e9424898ad49f3b067b9c5d22888ad93942c902ad0d7951b04224344993d6b34833408f01b436bc071b5040feb7bde7eb6966e90f46a9f6f995864a9a75afd0c149fec8d4481937cff6657acbcdae0dbe98e8fa87ada090006566d68ea6d67a3411aa4bfe14d5d6536f9c4e7c19881aa38b4016ebb390e24619766252562af3c502fc666bd6408911966ab52bbd4b736f0ba41e98d2686f0f7fe47193f2d73ef11f3ef4fddaac5576663354e28cd80715df76f696cd4b8756bf13edffd5380ea1e51e318c0b19301ca69f2645680022347d532888c9161d57b954eec87a3d004020dd8d25e373cb3c7993fcce270c9d068c62ff586d1d842e4ddf1835d82ecaba4664b85d8d78a5d2449fd96b6d053ee023244edfd01d029934a5a048743fb214979e769aeebcd2c51a9e125941953cad155942b2cde08846b62502e85bca9ae635f0b5548957c8cfc309456f9b14116b08c0cffa301a899244dedecaa54d20e6f297e81cc712c83d3425b07128980fabf268602c9c4967c1f1894e56a81c597b6fc80377889799f2590dae685b66decc31b9cf745e8c45c7d9e679b5496d1835e5c249a4534113f04dc2d7eca295ca28d2bf6fcc081d1303a4ef911a6f0e229a4dc8a3938fec5f87aa1d7e5d7a0902ecd91a58b82971424f901f63fb0e1afa52ae047093b80f7cfefcbaeb8c49e49d2bc02c2936cb8f3bf823804f6d16d4a88cdd8e5911745d2207758ab756b315bc246ed0c3cd6c682a477760ee0c37104087f9d644512ea8f72b8b0686b46b3678b014d16a206b9d04267a49978ced833ce0da40d93bb09729ff06153e2081afebccc36c900e7be18e1a3e36c872e4d05f0581fb67bb3a17f5ba94162b49e0fbcd7dfa6373d070fe54e82fd74a85cb3ffd52724bec12373b35e8629f63ca3dad59aec9b32c97315e806e7cc035e3e62e1d5b4c6289f19c7c57a3e7a83c4ed49274c7e67f3c6c43578ebe1e1198ab0639084dc810df2a6591a81331d6f75dc0b91376074a4600f08382c392e2ace9ea7b37eccb74e5a155ede3134ece64b798c225924dda165efeb676ee3edf0828130532e5884d8ed56f7a7ef8203570e0f4a0ada40daada456fc68237011cc6f93d890769dd38d560913b1199452f20382cc8bc78559e66619f4102ecea4f1faa58d578054715b9b1c521993188553e5249dbdba4526f713b34e16488a13ab5bb0465eb4ecb719160cd5948055be98c4eef6fe9b6c5917815881885b1c6822b82b8bb59c94d261040579d2abe1ba2f4fe0e4c679758dccb78e66e534649244d7ce3b9bdc939669fd86c67bfa905d50940a573306bd13c6506581f96187906b4b87e75fec5009a6798ead3a6b844324ccf2d3fe496f6de40d161afd443ff17343bc3eb38570b862d97cf9436c150959b3e8bd9f39d5165a2c8390f461997c683243585ad3351b1826a5cd7c5c5e7b0544b0958749907410e7be17de6618f52791973895bb9c6ca3fdc32fda3f7154503c07372dbe2e72bf89e3dc68aa77d5aec1b94b558015762642e853ce8013b46174ba1a63f68b70b2e3864abecbf27407cc9fcab7edc4610d5fab2d18835d2849ede47f830961b071132110e36d09dcffc01297684c0a7fb09a90965e825c110abf0396805c5621d964354d8e1ca4ed18fcd11d5c1d59110b6e324d2c843e688f55d4e679615626b95a1869236c94b37c9a8634d756161ce2c3afa5aa3b8d3dc1303958df143ff03fd4fadcbe3d3f485c8cc41fcd5560ed10646e308e63d18f3dacf8aad54d0df233942a2cebe07ccf9a60e8f2ae34cd39091b6fe73dc4d1abc3b61d76a173e39689665f345ef4981fc338e8c6635763639112df6f3f6c9a611c9239e081ef98d528d8cf7d5cf042ef36438a191e087f899c7ed4deca84df4119818ecb12d60439a5eabe30128eb0f32116bcf934ac311ea9d990916e7395be18767113bd85997ac2f2108d67d902355061a057491be1a762359299b53c82398aff920d483079f9d90c578a9624bc1196a1705eafdfee2abc7af70e1bf3b6aae145140096abe73f236ba4b5c9910876a7b72fc5180e3d63dc497a753c5ed87a96665203c5868cbeea2fe93a6776f0dcc20c256892d70ffe96291f70838f66cf977d0edd7fccecad210505210fdc28e8e1442d9dcc0e39fd006c7963c4305116cd6740ec38a5b40beef6c99ed38161c035692a6c7a14eff5f2be98d35ffd458819578bd87a10ba51927b06b809d4ccc81cbf5f26332d8692351a51bdd079fe4b1ef1c1bb69ec47116811ce12620e128b32a305ba57b1aa367efe08c81fbdf4ed74962ff7e4d3a8d6cd6b5876e90156c30dea614baa63c22de3ac2952574fe82c51ad648dca40e9e67ff5b2df1e857a0233d74b3d7004c87fbfb2e73651a6543ceb476c95bd576bc81007f8c3c56e75e29bdd0368ac4d5ca1128912cafbaa72c8edac57a9dfb0e767cb4b01711daaf1e6762984b884453946c01b0b4ee5b79e6f4175ea08bda03e74c83358f3cfad4efd1f31c49aca496bb03e363342337d7a56fe84f103e0c25bc01aa9cb83f53b386e4a6c4e5870f70239f0959a7cf36c54047860f488b1403fe2f19ec03429351197c014834a21c75afac96f159f4927ae8f91f75be16cc8f39f623d3bb660499f3da623a21c0150c608069bdf7e2b9b5de21825ef76e076012988576977256db59d06ba405b50045c003f16ddf763ae2e71074df9bfce588a7745b3e0079fe5f55d4a5c59aa4cec6bebfcfce2b96efdf6e5a55cb261ecb9e388a395bf9bb2cfc0fae1f9455518a0d26081d6c7c654a8ed7de1a3b8f3d7556edff31884f1bde0574820cc1e278c0a7fd6e5ff6cc6c65113a049badf48043aa25f361d9098e9284703d3e5f749a1741af284f9b8cbfa6663397fd1023e4fb54d01cf064b77b8d479fa1fe08b1eeb5a0107dff4aebdd83347507ce885fd2397d0c3130896eff1279e67f886ba66ee3e97423f0ced839e32a335752999fba7d3d8b675a49757a6b80f1cc0a0678e2cbb6e069d29b09e9fdf3b733b447795dfaced72756f9b72893a213be944dad01beb5a9160ccb309d5aa6a8479d87f23e54de4e2e4f4737cf5fcde6c382b17290ec832c85d41197323e6ad3adf09535adeae9737f88148350b1313c5faa1b44ae98c7ec1f3b2eaae82736019f437e0c658a267b6fff53a3484fc82010fcea1abfa369ce0bb16b484cce65a8170c09dbfa00b862fddf2979339b810d80ba5cf74227df0e6aeb48d51122a745d5a9b3d0410a14faccc64e0a874b3d9099999a975a5d8803058c50fe768d67de289a77bb23643879431b616079ab4a4936f920e5ed52309bcae606490426753f5136ee0b1d5df0446ad8f29a4a5b826015c377fbee2c9163d656a6068c9dbc3b9406613164163a0f485642be97ec435fe812a3cc50cad27772bbf0037f2a44d37977c94b1c425a53c1376370cc5d06ed60cfc2dacdea85f1e9c1dc2363509dba202c25dd88b9ad6b34fd7def745729ae4ec8d01c0cfaa71e2eef62c874bd20b08abcfb0c8a91ba06b53d7ad571ec99cbc92f99644910f59d3a47b2e0df95f618d4ef1c9da4945089838405f3cd058cf4e4e2471c19228eb65c16426b5e2d03906a413b9f9e178b5fe64e435160d06da2729acf6fe957e0092d4a032c294ec1dbbc47c214769ec6eca4e1d532412e40785d72bd1932e4be109cd2ecbec29d97eb646dfd77201d814e0e13dfdcce8c74f6556a67b98cbd1dfe61e995458fa5adbca57ff8800a40dcbf177db5c4e032b3b9066c703592a50db566925ff51acd26feb9ae45c18a04662ee367ce8e276390dbdaaa5a87948ab711beb73b12fefe0d98f1462179616537c709816f710d2cc2794c4128e550064189ec914ae05bfcec80619fc66fc60820ad76ed06405ba7a45350b4646625d00fec6440fc1b0a7e2074be9a51ef172049e23b7545dc57a0c152d0604e36385109de9b55c66905e652c4d3cd874b6a83b198d9b676aabe4f58729ed376eab08e0b869c23875f030eddc8e16b398ead8abd8f68ef6be571a1412749bbc95d9e8d09a04c9b8f1c1255984866b953462bcbea1eab64fc9806603ca556388ca46397033bce914128b7436867bbd6598d4ff16e51182887bc9c47a74b7530ee564c569c7c7eb6940dc4f92b5e1860725aac8312b2ab4897ad3bc5228202355b4a01d10df8d7145c7c97629911b6823bb511b0f1cb177c7815ae9bd445c513b85292e7d43412c357b3cd5cb4e10d35a90a4c310ceb424d48d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
