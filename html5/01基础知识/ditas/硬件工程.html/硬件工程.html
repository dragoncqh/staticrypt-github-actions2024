<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e159ca4b96d69f2cfa7334a64acad870a93c1790673a9e28e18f2b5a5f0b3d97b215a4bc4f9d1e232ca46267b7544232e98969c10f978f45a2cfa039d888abcee6a9913e066321523dffbb9b4f138ed13a90cb1f992b33eb13a3bc9b55861a74eb6df004040ab7c34524f4090aa7f0f76d220be129c6e570015621298ea248ef1ed508b6dd8d1b562827a4404d08ccbaf7296c4408b7199a6fab9811bef6407892bdb447717cd46c3cce57fac8094722daa5aeda45d8aa1c9a7c7016868e093b5ba7ea6268b04dc96a10e3aeba306cc1d6e0cca7a5a328dfb8ae2395fc69631aea52d6ac63165f9c1909c4f8d8994217d7025ce7a4a5bbc6067a9809c39900041cd3e38a6f4d92def18cc269e169dee2904afedc076a38223cc006651ef5459413deb60b08116763c6abda20c1d93f805e221f67386fee866fb58fb3357ac3547b22818c30037af48dc104f28832dcc49a1aef13b12635d430c4465bdef8f9a62e13db06a1cb7df4a03913d86d9edd87bade6fe102e970cb1c723fdae775187ed2b04f2f3555bb100519d475260b5c54eed6f6faa951cb3ff87dff131f605c8cd6b3713d36dc28ab8569d420e8065699e05e54eaa72649825a56e779b3b8842341c55798e25e1b7cfa1c346c33d9f55275d1ad4be84542b53f3e7342c30aa784b1dd00a7f3c53f3b5385c4794dde69863be73d362f6304d9bcf29126e4272034e0685f679e2ebd48e5b5b2ab456bd149a49d7df3904778f2746efa4e4d14b9dea5e900c78c65ec9c30a350a48f9e131d057067234cd6034aa99e6d3bf7b4145d3fa3d51edfa193bdf0d730664461d648a1c4341c76d8488f5a81496c15eeb8f5d1f08feed3b9b004efd5122c602627ab200bdb1fd5780da2b21bb29fe756e4fb19a45d1041fd81f51291bee311a7773123fc9d1d632a83e606f847a2a3ec27da292f862a7a1f7d6cf13a8fc98ac59a989579eb211381e0e6d3d03be8b51361cd3c34a1844daf29c8ba4a5d048c90cf9816f00af27244f75901715a4eb73e3ae6885cd68c22f3f05d6ee4567723f1de1b1321e8ba3916789bc1f31364cf80d00e86514069a732de5c03c2558583bfb635f77f79b7bc7d3b767e9a5b396a07353a4288afb4b03f3ee2e0bcf86702771c605c7d94600104915da2c37349c74e2f8cd75fb6b5aca4c10fabbf87efeaf04a7dc1ed0e675653c1651ce414704dd132cd1db60d23070221c9c8cf96d92891245cc845d68f7bec0346b620079844b22cc3fad1d2e8b6962534f7338ad59ef1254aba2b0d53b9b8343f8e07e1715230a62befaf0f9d041328589e264946b76c263141904a48964a583816b0a21c09dd0a20112bc8a78e69a917b2a96c67941d585d69b82c3d03faf21032bdf07ecaec3077650fc1166f473806674f07a5bba4d84ef6ca013845e52850b5b5e698d182841afea030a4e14fc0d9f9a55e3480e79b08b08fbdf39986a1aba8daff80168de53fef0461d2555d8c5dbb5507f476609a3eef52059267946bafcee789f4d1fcf01ef367929d30fb312c129583c189659881c1e09f155146b4e5120057a87b858b9d050e9d6ddf73ee4aabf360220d36d18a1ceec24e12ce2ed59346b60356e4fd2e03f9f1d507fbc3c27e94c84dcce729fa3678146302b753ebc77c4d93a0859bc70e4be306dc4f9316fb41e327f3e56c091f750e8541d52cff1f0f473bce35a5950fc10427ea647fd2258b20111bdd5ad2438358f6d91844c0fb01a275aad82c70ee7215b2eb62719e97254029c2f58e85af0a722511787ed28d326a2a843e4013999d8bae7a46d6824560402267af6070d1af063f3ae5b3e6c81254319d3a960439097c747b9d6ffdae70b0e059c697f885e30410c564772c1641ba254e93ac9ea555da6eb99183910c7f5ad4ae474b15440de762e9a73f55c907b7031154091080029eefd37cc302c8b7663480d9adabb71a21bbd221291ed1b007d9a2508518b21253b0859f83815cc38b85157d90245e942341605b089294d9df09e94c190042044520ba1cfb41e88d96371178fc4ad5fdb8cd7e956bc15af4036a8df755480de3edc4b7d12f7817182c272ed7d8bf04554bad7cf88cbd3779c3a53db00fa87c8dacf49bcf05ff475f4417e34dd9362bc9ea74ce1d7eec452353edea655c48371203706e03fcd34037feb18b2d1f2fda24bf8577c9a2bf8e2c4e39454dc4469a7d4c0e9eed6a8008a1f22ef24463a07fd7c31af2e0472ebcc25632ac2d310ab2422d8584de987190eee5ffd6de8c552f4d0e72a0a291c8542615770d9286c28025b0eb79a5db88986d68205a71cb8836e854b90ef07835fba8afd785bd8b6fc8e66da339a38a0f513212acfa4e79da913ee6d5b31d35d2127c87c715dcaf2bf4c0ee6de261a71b8bc90b84bdb86bc81f09c7a0d57acae752394924fa008e3e20790e15e6fa1d53bc925cdaf048fc7e795dc828d832dd00c0496656bc4c0fd81afe1536c262561c1033cb4913c827642883ce9cc87528b11a00bdb3afdd41cb15c48bc9fd754502a6aff2c130763dbb7f253969433890829cd02b394b0b0cc5adab05071a590bfd536f8169e12d53d25921ceca65bd02d3dc3abe0297b9613ec67411f2d2931c1cd58abaa39123a9b81b3d30da3e206052bfc8d27e7caceb515aa1bbf1ae017756df8802c9f373ca8e3f51e1cf77c3f98ac0c62264adbd07d569fe6d3a0d67e8818cbe4b1d7b94f3eb14ca5ec556a2c2214b97a7cac2f5a29bd2161a9cb2b06110de8cc558e3d19b68634e0cc62617967fe8612fb60415d7340b5019d61fdffaca5662f9d7086c1e2ba08f51d9ae2a23c8a99e7713ecb0261921b711d2eb11d36417372bb28a8ad77a8fe9f9946a157dcb193c783675cf57fb358dc9a163cd21ef6b27aa7c5cc8dd4b408f1198878025cdeb08766c930ba83bdf172d8b127f11da002d27676852d665c05d68bdddcf271ec4491c140e8ac3086f4e5952e4d53f5eb8553a321306e0b3b3e8dea0a8aec16d0a0bd7febb56bfae9d55b5a2b5da5daae7bde681b4d12daaf768be863f891ff93a684ba2d3623cd9c5f3674dcaf8fb927c8049aad0a474fb216cb7ec3e8667dfff00d09e662e0b613035a38cb505e0275470c5c078df1ab63f03d17829859a4d8536072e39eab8c6fb12f04084497809cd4122923865c5b38025c26c11ddbbe0c0656744ef4bbb5d2622f62bfa2e465d912a946891cb18fd89d7b5ab4f96fb6b2bf6ee1fe335917c66b67bf70454ad477b8a846de2e4392127d9c5b7589203654399d5a09f4f7a1cd110f5ffdcc2bb841e43c1ae1fd16b93c75d4a53f0da4d4eafd7780f6001d37a48efdddd464ab2ceedf54492b2255025798b7971fd4ab25abcb2c2befdc02a2380744ce9e50255d2d46631a0fc27536e00c707cb17606d430f7f522f343576066f0f00d43e68ddf2ba1ec36353c4f82058f6c32971be97e15015b3de0f1c973a843654874ff4840ff4924534bc7a24e4c24f540a9dea8dc38b149e3d4b2c9ee7dc2f58ffb5cd48c93ef975a9eb2133ca1482df8615f3e43796eda54109ae2eb19bd2b2c551b8b24547e4fe30cbc00464cd46d4e72374391a09cec22305d34c595c74629cb25a342c034dc095c0867bb375758b5aeb4282920b2266aaee1055adf1143cd804808332eb316c02bd166ad0c49c32c948e49922c0835c2645d91c3fc66e76e7870a1090aa00e649ffaa7caf5b44bf445d457e4d1a71becab1ecf018f8011183ca02ef15722e2e6d5d04877a05952ea3c4b8ebf3d1b5e5a82f28145b88081720f8f32bd513822d01a864ea83602921ec0ac17330530d87065b93eab855dde4c2f5ce37399be5c9cf97e6477f34b11ff9384c8661b9237a75a98ac3a1a2c4f52594b7ed35bd9abe885e10366be0b67005735792d1eff7ac89e3ed0df8c923fc9618b2b4705610397cc7cba90c8d06a7ef557803dd51dd765314ec6c2fc0954730fe94da1bf291e2065127633e8bc54ac5cd21349eab068f1051413383183d39b61e12f888b71c351e2232da019aa082fb563bac9c6449fd6645e14c44eefb472417f344890011c012c9d21dad4260e24e2bc248891ec4c45cf18eec427fbd0df866a53838a28fc03727e39be21997c2a1d335dee075f6bc96e079e6613caea767b413d91a6f8241997f7c0f7ac3ceb851d9ec07b1a7486a8584afd2bd7bf970d3dc7df79174a70747cb07bd73eb36523b2b8c8ef76aa6da0d483f9be43b889fb95562f30f29397f930fade872a8daab306805dd021cf99e347e61db2fe237651a74225eb640339d8545cae54d3896533b30b9fee377782361e57455f9a3c35e4a60e19d28d36d386f336b077edf9d1aad3c60d513e4c407b931c1f96f70d06b58ee3c65707a483cfb4b6b2a8231ca08ac69a1b3296656f9f440b8d89bb7fdb7ce447dc0a9bd958266b48a05d8e158806e18b87bbc89bbdb641ed36083eea1f19b989e013f910beae90314d5c1ab0370b9118a06f5f4be3e89011795c2d4b9d4b26234b1ea6e4639a1c4a96da59361602b0800ded5ec1041ae6877b29fb9971f08eb5549c04a087c8cfd54eef7fdff6ce57e418d80e17beaad758ac473e0da0e7a458b5658bb2c8fb4073620e92b190de90b27ae34f855fb8d59deefd1b976a041715f748be1ae4c3027c6e5d78dc307e52ab3074c6a8d98a3c09be84feb336c41ffa9750a1539b1ef7638700b443f4a1b6c9711072556674a046aa27aeb04c388e756fce1ab776448f931ea2f2fa0dba1e4733c167f4fcf73a4578b2b1e407ff72279f01fcf887d24f7e31afe843e64580ecadb56ec2a2d5573ca992ddbf38f29a118a2983d6e92c0884111884354ad8845aaea51cbcd33a652ef55bda8e0a7bd49f5922c122750111d824bc60a00641a87bb00906e83c8d80f0f3d5e206bcc89c58bb0c3d857aea2b8d6f170b6466c61c5cfcdbd50cd29d07fd9900b01cc0b36cc46cfee3ab304e36adaa9b016c0aef7cdef5a2857feba26297f2447046df0253b9fee4c36269764c1eaec59a51f6824d80d9182898d705c21d6d77a9bcd6fe832345a5ed20a3af45bc4b1a39aeb78bd9f261d45917b456a79393b69f70fd8fb49e9c79250dfdf634f193b97b25473a55eb9530c4459e22238577f26652103ed6666aeaf807c35e211ae104d3a340a438bc7a6e34ac04d185541a7ca8c6c42f629c40dde998f0dab40b913d7f3c7b616c3d2e94757008f2a9c4917f81b18c8d9cd8a240b36940f3023f3789c7688fdd3b8dd574939c720e3dda66ef98d010fc01147eb7607d86a7944e15392a009ed214e865258a09fee59e737fc0598133c4f5d0cd5d34509b01ed8fe6da35b0c7fa05536743ffedaa49aa14cc62c30e9b9ab26db7b890549c8f7f66272dfe85e9418982d6bb43f6168b99170d27861497c1df70572eabdcd1ed10497a15d7e2e98892eabb451282a3547cad257e373790ec1b774b5b6151a7624256552b52a87775a9ff2ee3040dd544383df10929aee6cd6d539095f032dd36b46a0e4ac70c7f8866c272799f46c645477710296453bc3f32ceec62ad98c3ce612ea74b6a3d26eb0a7fa7916a5b9bb3be65d5c9b073a5f8e4e005296a88ec907bcdbb33f2965f428ffc081c65ecf1bc171c0d9ede6a2e5196fdf0589395a53519602fbd91c70558e31ff545c2be392559d7a828ea6413322653e15b1d8a2c5c3e32a1801712c7d606ea623daecc5960e0392d244ca0798a3c8d7ebf113ce36e7b8e5b384feee71ce7ba856fade00ad7313df3fe78f2dcd67b711b0b710edd3b7c9538265c36cf4db696e84674fd4061f266fed2bad2ef4591b17e0bb7f16d337fa2ecf2618843900411dab64b0bd92fa0fdd2e4c74941b9ebfe697c22d5a150dfb364208e2db81e29d24ecd729e5b15c6d028cc3ef482ab4edfe4e9d1558d80522b2aa0a4c7f19672e3f3033cf360008577464c483b9ae9fd2091be7e1ef4a94ffd401947d527a7f3dec7786ec04e037da757ec8c7ea198c4f3047cd4c37888f961bc2310340fc6d9b16d2f3db6ba2ca2de395bcba7fb00455726aa02e4e0a7c3a4aaf816759ba097b4e59c5e4b85fb492920a4725e265f643fd94d308cff15f92512c91c8237b2622808312f1ef045ecbad01639ca42af9f2030142b4698b04f2c745be68a28502a65c9a55bedd6264ef0d3cbcb50dac966133fe7e2e898aaae920f43c45c4cd99dade68dbe4ffcf22c7e0486ffdf893fdf3f4eaee4767ea3cc4d0de853e30b7afb0cfb9097bf9bcceeaf507238f83c90933c7282425bd4d7c82f0e818bc6162b9bf97bd294e83afd4df9e38ba745a7aaca6e620ab4f4bfc3d74ae361e3e355dacaa7f24e4523ba89d88b12a8c03753477b40ab1049da32b8e3706a38490cae19882fc29e52cf6a85c5a7b08b5fd55637aac03ee24c8e86900ff91b1ae655696c00654e7ccd2053ffb80ec0ac20f5e9b59d0292109222b8e916865df005c268da6f3c9806bbf65f7e9bd37e8cff86c25e89dab27292b3fa07e292b514d7886b3a7cb94ea8791b669b7b572209dc63b4128875b39c4a3f08bfde6f6b2f026d4a3847346df7fcfbcaaf1e4a0485399a50843887f9fa88843bce091cc256c4681e388673025fcff5636e998ae1af2fdd37665210a1cc96daa299f47912f7f171cb3340b8c9d407f4706b4f4ab4d62d3dd2c48779a462e4acfc9729b978615a5c92537ac1b7dde389f3cb44481a1c65b80f08c3c5d1970cec5910e735565affdc44b28dffd767e3beb02e354c4c0c81ba21385059e4983f2f5c879ef3c4c1f9dfa99ec5f7e22ee5fd08937e398154523d66823c17f219f9155b794bc0ebdf73684352f852c72857d12a6fa1f791f1ef6afe2c1ba64fe9a7a90f5c0d16be09ff799d9cf3ecc931cae902b30956124bcd187a9282a1f747b9d9f12ff38709b4f238e3553ec84045a40c96a27dfbdce755cb3f111136d6b66abcc347ce35776c464db56282f7b98546b621fb9f3f56792e19a81430cb52346a1bc71be53db47580fd7145cc708744509a8df9af84bd63293a840db8bce334828ab4f194053b0839a15c4b3b08bdf970d4fc1d8c5808f5f26191dbefbc566f1d2f8a8f34e4ded9d548cca548e75048c5ca9cd697d128c9c803a8a511cacd443fda9bfdada6ff0625737ab0cce4a68c6720e70a8b82597111aa9437379db5979d660962128b401375806ac2a9f68e442db1a33a447bc4a71e99f376fce12a596fe43a06af470abaa602f8b222e50da932dc31b86bb403c69e7d37102cb96185178f4db7213e28408776d2d365b9826f0fc8af866f30d1bba377f03adf10d858cfa2ca38bef2e69177d3155c46c185c2307918ef998a91e9efda71bbf7e49ffc8e506ba10c484e79fe3dcbb5b274b260ff7250e85b5ecce69ca604176f6ef3c0bb39129deb1010c47724619ebd09dfb826754ec19a88c54cf7ffd9cdf671add3d5ec8d9d214333730a9ba132dd8f793b95ad8a2ba5a903720fcde37146f8e7adbace970b93e67d5aa1c34db0a03ff8214f1615c6893c617c27ef28612d22bbc4f24b40dbb3b2f032b2b81e03594c3632490af36d1035e2e8b466147b06f27c878d4ceabec6362b361f031078ba522e17a0f073990c08cacfb77506aeff75772108aba01001eb07be26f7147ff1232582e09e6fbe148c10891c6afb3671cf611dacc62f551d7f14615a41c4ad0bd04ff36ba0e8bfa6b91cb3cffe1cf0b145d67dc021636b3d9f884faa3e36d230b2c3dbe4927a94e25af329737c0f90638cbe6aa2804af0fafad019ccd0fe21008a7bd595b3fcaa6ee8a5a45bd4811699602e10623cb03a7a8be3b373cb84598886187f34c942d986f0d78bdd3bfa402574c5fa704f7dc278fe73879d0fd65760518765592fb438beac472881dfdbfeadaa2a65921a0a9e1e00e52b086d916b4d3ecc69abd312207d060805f24cde5619f94355d0a9b18848beee0effdef5a788f1a122986590fd9b35ddcd8889699c272a5d5e4bedb2b6bc879579e0f18f59e053affd4f5f4eda6a6c8985f3b446147f88dfb97438a75a4441fc286c8f7af02c176ae587f4afbe9dbf713cac266d02bd26a869c7fbea9fd0eac13858f6533bc005b56d7b2c3941131ab7256f65eb3e2df43bdf259edf750b6da2e65a1a2d7783468bad397389692de4a1d1586de60568f9b0ac7069d315e3e6da0c6a0084fd00b39fb6fe9eff6519d03f2c44dbaaa8aac22a52a70b434af8e4e797207b4d834cf6dbe43c96783773e2252cc50518647432109c342b9c0707828c88a5186681bba95cffdef8dd3187d3475e2d255c5c840b4fd9cc368f52d3c661197ca9895fad6b538059dc9cba2b70665cd49e2619aa9c26105bc86b0139affde2b4777a1b5b9c96b1fac04269376365a1319552e74829d2a657b522be477359c049d38a9322f44c57aa039f50de2d3ee08df46e0b3e0cd7efcfe768ee3ba2ccb72c6c1a66864ec076301a009cfe0fe3490204dc524fc3423b9ce84e17aeeb6a98a9118bfba628f32ceedbbe6d2ebf409b7ea3b2484d5f39895735a41be9b61f3cb88817b3bfad051056e4427aeeaf77de0ac5907a47d4b15b6c2c164ff95b28229bf09d07a8a900cc50c6dd4e35e9ca2873791cb26a2368cf3f98d36d8af92fc038eb90c608cb20663bef01f1c965172d58859535852f6ceae8e9045b0833835b26193fad18ce7bf59400ed00b6421c192a3bafedae75e84ff0eeb8c897df0b25fb35a0213d1cb27d46591d93d52d3702a7d6cc0e4fe49ab3f70acb958cce2beb30b53a84d15be61ddc8f0374129623795f5d3ae584fea0785675565a5586dbe37957bd23c330ae8b84b1581e8dbdceca438093fc0bec6c341884ff4e1678dee4c5c8e22960c56d8a3367be877326b029ecf20921b335bd86370a3da31a3a7ac7ad0c716c86d4cf26248d427b14d563aea168d0ef83799a3639079157683536bb50ec77a78d3ede50eadbcb91cc4bdf3f49a7d2186e0df8a9d86e5c3245ccdcdc13979609ec58e74e507303db75078322b86f142213d04d67f7b90a366ed0098e49058239dd2b795ebaad807f4c7f15c974e938922fe4c88df783bf036f8f4a150ee2ffe1f07c2d1c27b184f5e5a9d76cd191169c8516590332f4f67c6ab6e01582e7cf5d583b43a894504b23e803b0b2067e66263a1b103b75f6d29df840b34ee1c3a84a35289453a8ecc45e4414604f94134a3fb34fac6194d6ae7422cf6ca073dbc3d5aa87dcfef7cd4d6ef0bc0f75a78248f51b48fef6b2e7001935a850c8c384a1badffa96b712866c387fa60bcf696d5d9a073e14b8816fdd3a12720664fb9fd28c31076a5134b5f7c91d33e8dcfcfcca0e239a8fc3ada3462045f5b994bd034b8d20acdf3e319951192bfdb60def8805025f746bac8a7dfcd00ac779649138b4a97e5270a84b3ccd0791c19e331afe9deb0a0c30e65d77579097d43e741c5422b8f9a745cc3bffea46aa503858b77f5d95875fe67cec5f66b4ddcb751d1bf4f55a8615c0be6b9c43865bdac6941a49361ae952c80ab31e6109860af00b47d2c9a357ee6f4e38dcf67e569bc59e54d08725b22c362617d4b7fe0d33216126905d0a35394d3008db26bf6c55a929ed74184e890dbc036dcf65152c042410a2c5a305ff884f17633f8ce0fec1b9b4163931786ffff50e9fdfc098aaeed883693465c78c1ae1057374230ddfaac79fc7595f5c3c99898a6b0ec389f796ebdaf5fa13168ee8ed175ae19b63873e1503749bf662416916c117b1af4a96b840ae8befa040bfe08e4cfe274b4deb9e87f4f891b8053555a9589abfbe7e53f21bd624e527bd7282230719f67e75fbecc5569430821e4425d5fd4b6b2c0e87d1012ca48755b6eb9a511734395a7119c724d12492e17682ba1c288de532d050405dec277e2815712e77a0d8f4f267e368be5a572bffca12ee56de47090ed290458eee8d9b4c703544b636af808ae96a72bede4205deda4b1f38aa1ba4a25b0f479f3113b16f3fbf67130258a31a27904be4952bef90f7baaf93675b47d86aa290c8916618bdf412d00b3f24418308eb74c7afb4bd338874959dcabdb166e37b2dc7bb97fd8adfad9a229b50524831e53da04aefe8ffcb963c0d03f1339c015053399545fe450b61841424084755622715d59a181f3e2a9fed18ec7d213ead9a086dd311a4078c8414531fa3163c8baf07f6025dee8a6d3fb8c4e3faf6133e3d8ab52f3c3e42eaaabee9382922a53a38bae6e78eba19194750fffc97ebd817b3830a48966f42246832fa33c0f108d8c7cdc9c4368c1d4cdc258818ada7aae28f9ef169b2798cf03d170848e1b4dca13e5958438b0c4e7ce247e2a259842e026a0a22265fd4b4d1a84c521efb4117815b37c05e7e242d0f5795c51e97b4e4e17125fce236a404df400cc5b850f5259d1b876844def6eadfe81438232c2a8d99245745cb98a44d23e34f9fe3077af29e4bd26f27d939f7ffc5d98d7dd7d1b1b2b84d656e901b192b7e7f251a5a390c17c4ee698a0a09b4b1de495098b9a415ab3647fe64b04dbc449d0daf2247996c0c8c96381b45627333d6c1ae5a0b70b7b07693f055aa3dd3e8b30a54bac9053ca82f070e27cbdd67f91acc31d938d04a7d895eb2bbc810f940f46244535b4dc2f2d98a9ff71daf9629795b96a0e83d4611c01ab835e7c7851bfaa0b7ba34493dfa6d9437483ad7fae62bb00c3f00477ebb606968a2f61ac960fbc8e37636268b052c8a9ead42d03991a88584c6c2a49e72302642dbabca519dbe528e030297f473bef3600578bbfd0fbe21beb96a305da1185c7f01a65e9bc49d6afbb97da98a24bf8fd06eaa16944ff86c32ac6720fdef50040fde063c465affac1c953ce533910e63fa1278c1da6fe4c0548a2893fba37e7a9e8d2b791ad4181ba852abaab4423e683f9979caad4f4af578a9198a5ba1895c9f7a7beeabd3c1cae885c5c72aa8daef5540b75a36f8a46655b3b26996bcda72f39354dc76aeb3588082d1ed6cbb59ca42913ca2cfdcf593ba328e84e1ba8f96289d81535964c4e36864829b68559abba862fcb08cb016c24864097b9e17851d601643eaeb2014d3a7db584f73536c253ddcab4aa300791b40d3b639b9f9fa6a09ae7a9123bfc86fd32ea37e18ee4982c403623cee654757a37c8ef24f52e08770b2db90209cebbf873a80335c2dd13b30789b638d61e74de39fac61a36fa4c5c4982653703e157c83cb5f62f7dce0ae0e253105aafd8a78af6c2a0b9e2454c9044b93875832d06e4477b222b83c29fd1548f1b181f11573db4f706175403dea488e0aa6cac8c7cc9cfceb7a3c8706f9b71fbcb374047599f78e177301f167734cff61be3144ffbc38b8cb9d4bc28068e7e5c583c2de109ee78053ff4bf17982c83e4804330c8ca7265fde46ca0a846c473473b495173e625c154842851322fc323de19c17ecd9ae07a70d4d022eeb689bd60d164a2b6686458a1c59dd494e9dbbfda424607fb65468169ee4975c67e83b5381c1d26b49a42fe208c8dc06bef5e872541a4e1c5a49092af16ebf66ca4959a7bf3a1fd125d90c3e58670c364509b9d006f575d2ccdfd9df0c07df72de207ecf350fa176aaea7582874b28c13e84ece5dec0e4073241b1af1d3e5f878c6940e64ea925d922ba81df8f916e21fcbc0b0fd9434f0644e4dca9f1525acd97bf96220a30ca6e135d26b40a5dbeac262db3fcaf4df8243c0a535655f60f6c1e12398ba1824f94965291cea0bec3458acbaf9b4ded03eb9ae32d10a4d507d20717b8ba9fe852a0099b96a0d5f51a2679e64e79d78b13e976a28153b316d486ac1b14a6272f681b1820f1bfc0f7b29cf9f9bb2f9138feff2dd5b6117b31a0913d33ab7242647e46d0ad0b1fca6cace4b044b020bf35a70369b6339087ca13a32e47632155be296b64beeb84fa8369855a6e941af4e1b0f7256f9a8951aa5101539af22a55bda0acfdffedc2ecb29554914a3cb348eb1e9f2c0b15f4a3500f8b8aab4a8127ee22ab4837481d101cb19d85d8eb3c9477f5e90a7afd7919165abcc3db4e1dd8fa32689baa917f08914b7c16d7cbe1fb9536e1c3222abf52a16802e1669b56c49c5dd521e10b70bbe9b633e47b9305a00772a13c9549fd9a255e6abebf1ed4feb57b2687a720157a6733204ea9ca0f166fd6cae406bde5b5dbebd012292c488788c6cb76d824b5c57a7da963bcdb156f4004f8116dcf63ca575bfed11e1614ff110dc3e3335bbefcd5864cdb7ce20643a6c6e7b668ca44ac6eb7368c4426b0c936c5222c173add28df6087981a3eeb6a7cefad7947fe13625fad8699fddd1a1869608249331736c54c09956d13c8a2fc1be123d5dd8cce38aed28c9642a97677cb9e936346ef488c3ec3939dbd755effc85554be240ba61c3b7285eb88337bfece6ff9b27d9d940d6cf53ff8684cc88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
