<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d4318f8802b0f91b5d7cba6314899fe266eb406976cb2657078392e417bee7ee002ddcab9fa84068c1317e69f7110604c2d8cf6605c357c9f5cba0020d082180af7dc23a53be1255dbb05e0b53f8fc9c4fa4105479284363b8529b65c26b4769eca3b415dbcca314b2579f5c55a3b038030a3d6f80a41ee2cd7225c618ac0e2b0dc7af1a47679f98ec30da56dd4bdafb8bb17619dfffdcb4e8c3c763a979b4108822d97e2272cff28c3f8949ff0a2189279f39587bccd29f58cfc307f41d588f6ffa4477a0162a40bc150bf06390702486c7fdf8acfba67e55c2749152daab27eea5f198aa7dc0ccf33e6678daa42f00c5ee679ecee8a745604ce391fcf03815687e6958d5b6acf459492598b3acef4199930b3a30956e1bed7e2be0a305b32b2cb46510ede5304436e6782fc5569a00f46e448adeac43af3c785929b6bf57eda0f9e2cf890c4eaddd453058ac8092389fe2c4e312ef7076c8edec43bb0faaf1ec899cd51dd348672a77a04c15a0def629767b62abf86de3b4b2b70eea606d35990e1558a120572164ee1c47089e6e2dc253e3ce8286b7efd01c5a4a06fae754f8d726e9a38b83dac3c89074bc59a9530b454f67f49304613d1bf4348640612238411fbacdeb223cb8ed022662bcb8ef0edb91df7ec9822c9c8281afdcac673926c7f22e6cbf21cd910c09df45d8d5be8614a27f29556cad49abc71fe2d4ac1b069ca7f9c455610ade344020a0bb81056be57d536c6c89c00c48bf8b05adc4205b6b9830865834341a0f5d41725925c1fd1d76c5ba8e644a6ea8bc99cbc381f65c0aa5f67e71d01302017f4e3825330d4ac82bd4439fb24cecb6004827e705e949d9476199122edbfc86829685d0e62843e047d3d055a939dd1ac39806629e33f42752a61d01cd7e3da00530fd410f2289cd7c12f8f5b005c7296e13864fa281ece61adbfda4f329c8affcd2657a07e36974a0c586342cbdefe1d82ccddd53265bf0a52a7f331daf54579b630cc0a8e4f613c06cbe8ca7dfccac97b4276d19b39fc502e443ce40b67f039c6e69d4b96fa27aa9bf5325548f577d0b1da889b8234a1fbf7b2a1f46f3bb77c17f7c9df49648701f9ea0b8653983782531703b42dcf725743d8e5d77e8c078f47fa12b820666300f9a532b6c6d5e70b635670d42f984df7f7d1fab687a965a9378ae1efc9fdcbc6bf41dd4b62a7c3f407301fcbe8b69faf0a890a209c57fb8164beb1fbf3d8ec90b1b0870b312a4ae30ae814882382c64d8c7eed4d38a273dc53fb9bb8d695121c621607e6a8b45eb03c916a13a3c0f7b3e7894d442210ca3a5fbc940d12144ffe797e47c8d1e62038fa078abcd9f94ec1692554e02f0ee57e8ccb7ff23be44738238056e9217f19b2ee1bfac81ddd9cde2c590e9b5e872f94fbf3dcc3d3a8f7612249477c35e6944096a61cfbfcc876fd6520e4dd69b62adecfa24936a91893607a4cfb2e951af94645415409ce6e39abbc394a45e04c6061833dfda65a837489684534056e2cf3d33b8a18d7c782d258782aa3524fa5d0712c1f815fc1aefe4c7487fce2b95f50876cbfd866f170fb9629405eec77d3444d7eecc5ea84b6b7ab5d187d8837f8803eb2ffc34b8cb6f6684fbb9a13467cabb072f7377ea20a05a8091576263e86d7525fb741ac45b9baf8390e68cca2b14c4b807d02f738e352daa68d041f5a514e00113229801ff0b32385e0dd1f1e5a981693ede24fa2387bad7df39f39b55c6c040ce47c38d16145abb09e5e536145704466c3d181f5d0872e6d815e1b02c21bd64ad0ae1a6262c9b0c37e5f66f8ed5e338a67e0924863db5db0b90e64feb9c92f2caa929a2c3125a74a725f9f395456fd5a3b9b4ff546b74fc7d3122ec1ae85bf90b3a52c4be6dcf04eed11394434e72e98cdf152c77703742dc339c49b082304040c2a8a7c989780500191417fdeffe04c824bdf6f641b97997e0a7bef7e4d6b51aae674573bca4135471a4ddd4465f9323707f124492dbfc150bf6043bac51091cd4a3585cfa6ba50393ddb54d29405004d1a0d710bd9a318bd7022c5b4f4d368aa161280b9336d02edf18c9aa41c4ed5d61841460eb9470864d59c93ff6c39ca2fcc560d85209c31f8d9f0ca0d9a987fbcf5e81a5fef6d9a71b3d89022402b66159a9850421d4e85c83accad786375d057e9aa9771153ab20472f8c4eba475c6c7a13cdc149940a44ed21e6cb7301560d1cbc85985f728815a2fa5baadfb14aa6faa482c1996999b9c0a8aebfb8a4eae4775d084de7488758df3dc0b92f0f6805fc953dece1ce1bec816d17d4113e93c2ec7ba2cf83137088265250bcb175fd7fb9157ef1f785664f96f95faf263e06cdad8c8fcfce87a77be5ba3a5d86b7176a03a73ef97096fde89c055e89f802f26f8769c0470771fa07035178ae953cff7473533da1fcf85f5d08e92891ce40e31ea06e3038acd7e8f4f0a1afd9477f18856fc819d22eee10b83c71181625ef3b0ac8ba0fd206c11392cccccf2cdd17bfc5d7739ad711046f3ab7a88b6ee36174b82c8a59572d9b89adc2ed6cd589573dc3f47dc8d6e2b8f31ac3da8d195441f07b3aa6952ece781774ba4497ccf26d8cb66f00df2d666f268d878a330f2a5fc4442de33c340282745f308bf077593a45b81cbb56e9837a56c47ad8f570a5066997dc14d4eb06e97f5509509ccaee9bbc46e0cc6764bffe775079218eca9381dfbe041d6b663ce78ced281bf285ba30ae346dc26a26e2f96e7cb061a26e79b29ab1a5b55dbb55a6f429cea26b4e6489a3095ebe77e38f9326bcc4cbef2d2dfd9648a5af3137cce29c5ed222283f8c300f312d7439c42100b2d7b7c907c61fb38906202abd2f802f8c64fbb2ea560875b2c0d5d86fef6fff343e1320c9660d7e2ef41afbe1bc8a3af392fe02e5ade270e7e445adbb92b4c04cd42a4ec6e55926120a5bfb429532fd4b781723d0600a74d506150d1d4a1d2abe2653c49088213b95621e9a1a3b8fc6dd816cfdc2cf27378d0f5b0bd420d35a66254c3c82544ca92ba164b989e29ecb6843ef2b6b2322a0623b5cb72551edda6010111bb3fa9bdfa2b50270b0298f06d06f49836f06589f017ecc057c0de761586d6a570ed1bd9fdeb97b6ce766497617d883ebc4b0281ad9636e527fa3a5978de6b2cda9ca3122e50fd33dc9e9902535432104c01dab5661031d3988aefabff4264ecf0f9e91e936a5e8877c833065ae0ee8cd73e3254d182b2d07c6214dc8f570062e10bd2f15d9d60ceab31ebbfc03baa7d6a78eba024985e7a4dd2b6d8a218fd8932e65e6ad214ddb394a27a78d4390a434c73179eee7aecdf0c4cf0ebed191372c579d02167ba6ce52c020f1fce9f0cc67580833fc3c881fe4ccf804ae664bb68c8cccad215b873d55f70855c3aea01cf036bb60bc69ace9e0856fb5dc7613128787d2bce9572e2352a0902a560ce670cec334745f8dfe97fea856958663abd5c7b7ba62980658a561acbe5d4ddfe3367ed9444e69ed49432054dcdcd6b1c014efb5907759554a6535f1aa5b292f28fbfa98f6ad4a040e2c0a3a8c43d37f5d91d2ea29afe46397af2dbcca5a3072bdd520b7d23766e51202b5e000d544e94601faead59e8c86dca5309128e1e52c82d93ad985cef1d9579efe2e57009c12174454e9c9218da5aa2607fe1ccef96bf7c4298e408bc4356738bdc48ea7a42c8a21182dee7ab963f4a1ecb205647cf9d69c4f52ab81af6c0ba00c33ff70d6f4ff434d4f1db0a3890478fd3114b690dad557c4a35e6cbd4003123e47fa67d76b875477c59af749f9072c23167785025290451446002202d18e3643bdfc9a2b02a56b98c021bc93c6c1bd760a4186cf8d9252f5881d7f1c1159b43a7f478b639772c20b6f33b4844d4336c37eed71a9933d7d316c633d7c9598f7d103ac2d701c569aa9e99d59495bf82c35a7f2564364115472257a8c0c67bb89d0d204bb25559d27733fabf57d9031491a4724d3c2df4d42b2c23a19c4c61edd105547688e0fb91f5826cd6915d1dde148a797ed63fcef714526610abbfbfc2fec2dbef75c36d230e85446fbb81d9ab4e64d633c6fd652cf8b8c4ae1ea8e26715aa9cef6b1f89c9ac8bc2b1d33904cea0b9575865e81f1e34e633601e7bb9aae80755b5fc06675c483375d8fe12abaabbcc827acfbf7b117344aa3d28f579edfc1ff7930c508c184be08775a7729e7e9dc096e9b3626cb948fc18364eb0a7cd773833f213abb9497df6f6dda0d0355bad43e49536d94f31caf9f0f10eba25d87468ac753cbf2e5c274df672a259177691a9b017326fd9201fbe89819fd38f689ded393f2b06e0bfc4a96b7002d0d3e1855619c0e3fadb751dd0c8669a19378ae97f832f32cd0bd0ecd646e44a5d6337cae97a077b2b4bd2c0a0e4bf7bfd2bf9797ea7027ae24371c458b882fb4575e230c6183ade9ad23ae2e3c49b54b7841e92a6e0034d3bb0f5a04e2d1c44e2465dddf1b5a72d2b73938e525f92241a2092dc369ce9fc378defe7550077f262c2adbec04ba1e3b6c9e7f037a5ae0c33f1c6e683a5b7a7d3dc4a8e7344e709c0d340796d59391153af76de995d65da9ed563a3c4bf441b6f161e41fe850257cff3ce9c794b6030d703e31341f199f87f767dc444b496d558aaf77d59c2577feb92c03fa0b1aa1963f6a18017a481eca5d1d53c4613c3f4cf047d6beae1c6e4d31b08c375fe4210cce69b0f9b8af6a612ea28680b9fe6d1bbb4855d2865991853000435ebdf03cf102c78f5970926e9dfe89485c4d1ae06b1b1d5aba19ef6239fb10a5719b4ff5524b1cc875574c4a16605054be08d1adf6e88055912b26b40fee7c96a4055e84c2e29a3c06b9e3a4535e6ad416cbc0bda9e27914d8a2e877c80f623a13bc84b5e3b9152645d762c500157e82d717a8936c97bf102a15f597c0397e5950a10acf30d4a8b5696326ca152f06a2778ee9da80f763e27bb912b51abd725e5da43abc2a9b1a79affd5339561505a31073aab1619c3dd43ef2535bb235e11d282ac0e0653940909f49099f6925cb6ffb2c8ca6ebc457f3a4366f296063479f7307c86e90a51043aec2ea8f3ee28859787bca8e3da3cee56edc7109de078ff180d4eed40d7d9c7a6241be140f7f6a12259650faf45a1b447785627e9aebdd230908ed5d10768cdc3a49cf3c9170c48ff88658734e889fcffaee92f8f3d14f30bda15a9ffc37850e9880b9e261444665d0a8193b9211fc24d6ff7a3ad567f26bc6f42c3d5fd49eb24ae5bc36a29ce9a0711bedbb68064a1d61a7344d4e31264df04c766d765ff02ab200dada36791d7416c2145cfffd9741553cf27905f6de6c1b2f929158424b9a9503b8a5d8e80c6e413c27e9e58fefb51b4e45ea7bb840c63519aa3b6038f563c8a456af96308d48455d59b6f5c54de7b101b11c06ba870fccbef420657551ada92111f1d3bde882dddb8d45761b54445adefe479eabe7dff3ef6d7fccf88d67a94bda61aad7dc70892e527815be098366e3ddbe6b3f8965c2ad84be929133ebf01c48160a530805b169d842a3010d5027de67a5f5ccc4d5a84f042dd4ab656b591ae9c4ef6ef5cdbb42c19122d00798346ef788e297c2e7361067b3c9624d5b694f5bdfffeb12eed91964916348a38b3a2d60942c4996263560679f56e7b2bdb9ff7b15fdbe50a5413decaa3a6485df815db5e71c3272312076587cae191cf4199223900789d479ee8695e670f0c07ee79b294b2490aa0b76f6a286091c8e5a13c666b60fc5e45c82ef6081a99d57606f06b58f81796226282f2172466c0207dc77f329847372ac0e2b1c7750c09e4c7e6b8a66368633f095397d58e41d9e68101a149b3fea272b22a0689c470f7cc47312f9855c7ee4ab9f0d1bad7e038c70c763057dc559718c132443e18a6dec9f5e61f20ff86d34db0284857e177956f97639abfc1e6c5abf76c7923ded73d7eadbb12ba19f5e1eac06818208baff6acc10ab444ec4f348eff73b539f44bfeb3b962466b23d906c001880b951967846c2e64c96fdce595aac22898440c598ffcc048cfbe552308eee485364a703ccb79bbc876c83c683158893e4f602f0399df4df61ecc5487c172148395","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
