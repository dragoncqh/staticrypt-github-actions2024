<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5929439a6b7a7fb4e58456dbbcf272905b27f9759e5236555d3751182b6bbbfa0f52b420d32063b0643f457352384a75fb8d9ab84605504d63fa17ef27364c13f16377481a1fbaf339d9cf0acc3ef722277fe1803005f957b09619a1bdfc5b98e33cdb4cf8c54dcb58817629310a8617ce0b3a8aa775454cb329df26a2e8023bf1468f25eccd9eb3089f442af2cdeab48f668ebca6e5ae6e25a075183d98ab19ac06181330e41f65eaabc755fbc2fe3ab01d3a1933f1b6f093bc73ec6b1fbc5fda6e0843d1639518d3d0bf3a19795ea4d97006a294f4eda9f2b5e9284c715f2a62933ec2a354ff1815c339fc980109387dc38fbd38c7193ac3a92e2cedbc3edd0887910df83c89644266609b064367aeddc9989080be80c24e85d0496ab867435dfca8659a7f67fe59651d7534d88ea384fe17ce955ebfd8db1b2965d86421bcd9ae4386e644d1e7a9887809e1845118e010e78e3b1f685d3087cc77ae46c187ddcaa8101f82cc4783a7f01be8d8515705eb114caf950a3fac2ac23a418a9c3cf86cc94126bee545cbd5de74b118f412f82bb7c3ed2e467e8fbaa6434f8d9d1d80e4bd2aa585133ff205f291a3ec9e3f4008c90f383f38fcfb60507654d95ebe988f90e770d980e8cac2438edd6588bfdc34f61492a0e2a424ad4e6747da7e0cf5fa29f54d10082bf891b89fa1e2cbcca25385393161f13e14803deb4f8895432d7f86e72496c2481f951ab2318e7d082048707cf6df8c07b8d8a0c06556d8e8e8f4f4dd950be82f31af5377dacbf53eca6aede455f8d557378881dc6eaf918b56511298486481fe322b9a009c0c358cdbd868877ca9253dd6871fb635e7df493cfae8c894bf7710ba2dc6470597013b363a4d0eaf7168e4004e83b2c64b02c56949c4d13fa40707eeb351db7ca12ff64aef06b82e8685ec26260a6cc08ca91f1703ab8223fd717411cd4c8e17e5c37d24f586a0b851cddf67ebe76aa84e0b4b3f9d5a6f99d47644236841a05a6bd75dbb3298b62109a2149f9ae7424617ef389cb0ffa27aa8e105819d9b4f77cea79658524be0e1a3426ec2caebcaeabf5b63e0a0e0df40d590a4b89ffc13fc06783ed38052e2d2ba7263c9280f84f72a72e6b3430703b76a5b8ec5a42758ddf36238faa82cc53ed53ac5d9948c1bec69baf1549900acd4ae39e5de835c5c99d684c5f458577140b4cd32ebee91586e331f6c4cfb76d38f0fbe82acb3fd8d97fb9656bad30a936507acdf11c29dc93b18d0b7729d83ff4a4c0b2395e6420d70016df7ef8a4df5cf519727a2efd5328b7f6274c7f798539e4338878aa7c7819b3912ca662e77fa5ad46bc336544bdbdc1b63416702e8b41262fa57fa7e6cc33e53d19bde10497d7d0f700978c9aa141fc1d634b67fa61adb24fbf01f7cfaa4398ecdb96963328e56e7610059198f701ed60ed1251799838cef8a478173994c9f220fae1e916eecc598daf70dc32a7a1515300270d38b182f76664218c0da4089784b3b50a6174de0a692949ff606a66867fd69cf30ec06660a4dfa5b3d6e7ea9a82f7e04fbb0b46bdad9b1c2b3f963ae0078c5c27f650fa3b79240c080c1faecc023a4e74705f15eba6fd551841c75b451f89bf9a529bbae486c24d240156b6b6f70c93d938686f9bc58b0a3a3b6e3bbc9fff5ff70687bffbafe95402f95934dbdf21e9b921a1f522f912edfd53f9f4b8593908919cddd9fdb7eebdc78f4ca8dccc0a286b4aad652d3f312cd7e002dce48889d0300084021b83772000b11f5033c0acefd5a9d1f22bef76769f095edb452427aff40158987d8bd7fb5c75fb85cfa3fab346635359766565ec5c0925bb9c5f2fd58415bef0f95740b21d509feab52caa5d37591ba13ab5faee7d2902ea1a7c67dd138ddbd3042127e4f2e43ed774243235ceeee0821ba5965a7d724a696e4c55f2373ad7d9a51be22c0ee6a7245acbdb7718b631d1c49d047010af3d9cb7b7cc60fe6b904a5e822f1f93b39e0544fa64e12834fdf12f1dfe25bee3fb0a9e6f3a73a69de8b921a4ee9564561a81aae62c923dfe35ae7614d4cd36b018471cfaf9840082c368d7474227e2d08da8560901642911ef9ea221cc11a29fec41c585c45b54fb0dcdcc1c8e2da9190f234c99ee86ebb787571f42e5ed6028b33ce8502a7f2c0a257afcdd0938e45bbb02e0d4d2814bfcfd9b99a40de47c7369477549bda1ad5bb454a2564fb4c7e2dc7b45c335f3a01f1ac554cf5f397a798f3aef3e126a7cf88e049c66eaa11c7a1160aea4c6809b5cd5fa0fcbb3891a4c00175791c4b77798f05c2dff0d55afae7ac16b6bf606b5d049251e056fc877f5b1abafda7b3a3096e5a896b1b90577a45995f45844e14f3dc1dd35a4ca8dd9ac385e1b8033d9a23686a0b5ae491ca88d3e3ab807b7cdbc4bbbb452c3403aa5c9b70c65c7e60a4d09b2486c1968e11a919dd082b5cc00dc94afb03447fbda2113183a38b321ebb07292f1cda78dd032c0bf4d6c4ac5559c23993c4a13994f9d809ac3b21d1d6516cf68431b4cd500e5eab7b93c6eed7b6b3d492656e818a8796a0b3bcb08164e3d50f856f44460396002a164e73aa5be7a91cd6318d7947c3a01e90fb3a27fede8b2a5320b09bfd9f649933673ff64fe38394ceb16321a8f8c9c06c8b3299857f05d82b991dace912a7fe84c4300d78acab4fc1a11bf91b8424706b6c797b0a6c4168764b2d4983e53d05236545a44e766b10ca047904b03ef2054a0b78720be9d023ecc41a89c9a7c0d88d4e6257a066381d74b7ed309cee5b76bab6cf53370cc50ffef8795eb7ee5922af550e6f0a07fc9b2c3fc3b60a87e8cad3237b266334980ce56079286170500ff97e7301b9252e05a5b09bfe406e75edca7f7a3bd4df93972adb7b2b48d0b10229d7f576b52c0c396d0f1241a3cd286f2f3ccb1a9408cca2bb800c45ba76f7342dfc9be5570af3d7b123830244027f48b4d9002fe294ce8b23d8f0634e5b3b189f5a82987897a395e80684d81e48eab94d297388351ba8859d64ed08d0bec7e6417e0d33b2ee40436b2dc9cc23d62d7907155aa551cc84a49d2a9b75026016ed347559de65150448afbe863f83a49fd59b5c2086db12fab6c886a912d98eb7715ba065e8f2d7b16a4a21cf1854008a0190e0b3764faf6e52e096931cb88ea22c10a2b50ede7f2d93f63956f74389442d0321b084846f3c488391a401d2794dcd72f75281b1b6ea6c274564deca9c979790327db1115298e95b5ff3f0754f292fbedca8346d360f8715dd87091beb71012a6a55ec2aa1c8f84d5788676e2c9e66c084bd88b4c63ca9ad012a97ae0927a649f8d131cc2517f65ebea7318f7fd690f26de41ad15f55587739263c7477423cb685d53c4f227c0ca1a22c4e75961d2b9bcb5907ad3477c4d062a5ca58bd05eab6686acf8ccd45bbfa8c868538f827d40c5658253d57f17c81145e473b2d1c1dc18633a6039fff5171fadc0af8acba30b527b507f1c4b7ca65e3e36b00cc96b6356781d68e6cbfeb013f40f10810fe1f547d9c15426a13f385af12b5391a00e30a855ee802c2bd49f8ba712f9fc2d263ad51f9e1a94913ca52f3c7eeb3a829a297000947f10f8750ff750e04f038bf0944e3ce05c1fc6e8f51d11289542a5ec9fb42f5f41b36772f21896a8229149b062c55800ff72b612b391b4df62d26ad377052036fa3b0da199e26590a697ca9e6600ae2f9b75f9c70687383c8daffa9790616dead22849ef83385133529a85382d98b8d2e62ac449a5c749ba3cc60967125ed53cdfee24b946eaf2c4ec4e11aa11bac8856e6aa864e294e8f27abe89080e7ab4d51d37f15dc579db09d741aae5d2dc51d9bf2b2c9fd054ddc43832e3a417d631973423032fb83a44c6428dfa01976499881756e55b3a5eeb65537d2292bc3d79d79747b3a7ffbbb2fc294473db74cab86b81a9bf01985248f6710abbdeffd88007a1eb3f367e4425db9f5c6e8e19fd5c68a363d8f28c1c45b1be6d591ecbddd9a6ddde8d6596d04ed3b9cf818f30b60ac4057f979fc99bfbf7b318a2546daca529fe65c5980a553edc3f88ab752570b8283621072bac9da6df2c4cac23ecb57e2ab07780654bb7104b6962c046168c6bde5bf9a17b492ea72dc607193b3458871d6932a8c99e6be560a78ebcf6924c9e8366108a0c661bd3d6c20807212b1b98d119541ce4b8ffc0794cf755ccbf27fa4ea90fca8a1fce085b97d874c4541e2eac7fce55f2eedb305a301c5f74a2c43dfaf824b55d6adac389f4d1ac7862a8a57010b0bc24d5ce5662c9782854d646cdd9cbf11174db1bc7aa7c356eb532587066ee3c6332bba279d09c902ed0ab8de06a4c6f7804bdfd5fda88eab8f35e0b5dadc1b6413066d0193b91ee412d7ca407b71713f4b7aff908e94a19d820bf937a99b5d33c3d795a68be2dec2b9e4c774689f96e5a5e61c9e9f2c40f2f13b8c67ecf5ada463ccf43172a4bbd086afae19836ca38b55997f0772c39453718b6db7c790ecaf7aa7409f36c0e518809477b0da20f99e4466b69856ab1d20b0a8bd98f4f97b783180136716cd798d232311ce3e6e3fbd2a0ecb75dc2b7f1bc0cba0347f4df67b856290cfce6ba3bbe69f9a9747e57069ad77bd8c89ce939be5132f9464f46942e63eda154c351924f23780dac7600de1077062b75cb2acb8b50f44596691b8f6f94eb2924479d0452048e746a9ace921e53a412cc20c9e8c3b1744bf90b42378b40b894c4233eefcd48e6b72cab2304be57b525d42a8f6c27259c2ad5d90957ddd3a82a96d2146f936053005b35cb2f3a5a81a289046ce1ee830eaaab29f15b25e02a3cf2791bfae90bdefd20b59c7598fc5870c1f3171c31c87b17c6a2c54e737bc6a5de95b60bd124edda75897841678520f4dcd3d1967cffc44c56289abc07d4bd576b17a4109e91e2f4c4a67e1ed9b9e0a2b9b8be54ffca600fa940efba2c19c3deb5e6bf85d70553b0d4c01862637dd135f8d898a148da0ce7f6d1783265a3e181e371854c49b349d8b5e6f006d63ddec1d5478311c74a67f0dede3788b4ff58000c08692845c1f2b22a4cd7a74c10519833b0a5ed7ae837f57c0eed18d9e28b9db96266d48208eba121085dde43d7397b32ca6964fa8a96c4fba94a5f4f28980a204271b35a1f31a6a1a40d8535c9398b3e52eefa3d0d2281d78e0d9ded2c6e443c83602a37e05003a31b78b1ecb5bfa875c64d7acae651f0da8c557e18544d412e88e95a4744adaa3450802960ca9a43e9db4a813fbe892c0c7ca63ceeccb3a2c0fe5eea5446d6b964e04f9022210bafdc9d60834602078d0a6f5cf4caba50cf65a198e29f7cf79e6a441740715a60e3f9e155be1f14bce533b7077048a9bd4c3bad96b29cdf4378f831b54331e8e827ef53cd51f88c38e4f1e9dfbca3361b9dee55304bbd6496aa9b735f9b7ab07252726bbe698a1cf09392736c495589cb66aad7d0496fecdaa351484b6211078df4788e52507113b1f172759dad2acea17a585ae1dc065dbfacea7f9220146f89f0075ae1d2d954a0b3b7313d90a5a3713ab3c778cf6227d7d3c23cbf4fb5faf813b0e1c8f55927ed683ca99ed80ced6e8cc18cca1232924dd4d9b8fd6047f359ca11903af63eb363a771c42f798615ff912145d36c3c31dc438fcabbc2381184f162aab21373e7c880ec51e1bdf8bd2ccbee2806d835a1d2f651a57ec55931759cdb7a50c7a4d2bb48b1d174b17c5d2f5dde5edf711f5fc70a0dd33264a5499114985f67f523626b34057e7bfdb4737da6c42b659c262a42392b55b69b69b1529cdcb5192968fd73322c732a815d5aa27a5ddc007d282c8b2e6883eb26119085a530ab75d4b068744e4b1e0dd8b4f0ad329397a9adb38491be734e31915728fa49a3695c817b7faeb5be8f775c58afef124ea1732b72fdc7c1b1d250d9a9871b775c55b0faeb742c96b06ad863da76defe38844813fc33dd8ca280e657b0d59036819275834ac874fab3eaa8e0a3f85f50873ae9173417eafb6cef15ca427367e2775e58dba3ac721e5513b72bb63f52ab7d44f46b40363147c5845bea4ee084db44dbbea55c44a764503199a51be6cb752040014dd5554e046225814b9ef4a68fa4b650ba88f8e7564922441bd81d0f0410c90c8ce3922a56e60e44b0adfa211b5d022d229dd595667d482206db01f6ccfcb2cc886ed063fa5b0945bd90f55b6316c52f9d763dd4b8fa4df4af2e4814bcac8e4c6d08e8df45f780e509ae2214bfe4ab196991c22ea42bb41ed4d427520398275aeda73c512f10507cd8ef9925483a902c03d449d11b1e3508045255a386fda2fe40187cab02d828bd336b52694ecb0600a6d2b41e68d65f3a6a7ce00a1fa66ece00d77ea8a5b5309ef61a27ea8567e507b625eb5a26ae3ecbe4ec65bcf740791dc32d7e91565c65624ff834d29834934806a52561b171789682e94cd3d84d11650cec864d591799ef7fd92d35be00a17de6d4a6a8101e91d140e28fe8235868302b38b655acc51e14c98466be26c606d309c461c4e2e4c0694dca91f53b1cfe6c2706e89605e3faf089e0937182314cd39863c7fd12ae0ec596e145e0fef1ededeb2f1541eb468fe88a6d91bc375b4ccda7e79775e36fd37f605bbb00c7e32894936c993273cbcbba502e6cd63a9c63964644543712d3920546e043c4e9a38c351499d535c1cd73dbe38fa5d3e9175342d4d6b340169dc58e400b3c635a4141f40f4747ac8238cfe72e887bc284c21abd99f64a7982ef661651495daa942a20081083ae6a7b6f58cd3c857ed4fcc60a7c89eca5e1d9c3f4eb196053fb77a7cd80f6237af6ad6fe1fca2f23fc42ad4ef97d9e7f6cca741cefa66661df5054a44ad5682c9265020f8fe534a582cb85b03b2615b7af3503d916ea51733714945e10c94913758c007a9c721ac1d2f6a4fd9aa910739ccedf4ac6247dcac3786e26fade763ed935be507731b9e14b0c7aaabdfb8c6681546631803e608f5ff0db359a17439a66e9376c251fab4b109ba29d45575f5acb8f7e32e6c1377cdbcadbdb92a1a56bc0dfeaec18123d39d9d7a743aae58c0e5a84bd12447afe8b356b22b84064c4814020671d95c85584d91b8848d8388bac7a898d2b77a3d460cc5567efed74ccf0a06b413d167f6fdbf4e3dfef8ec42572eaaf248f954cd484e0de4bd6eedc048dd0834ebba546f20dcf0a3fabe800c8a5436bf21f4e64de592a1a83ccf6a19c96e79dd3447384ddbc9c2d3ffdffd651d88d678dd302fe9dc5ef270d938650932a8577941e6c62ce3c2d0279fe226f221d6fe5dc210ff7d1e3cb49adced4c6e42ef88c45780aec73b438adb98836d9b1994a8ec31ce058ec4fcbdcc05c798e5d38ec1501e3e126f55e208f083612266ba834ca86b37b81d78ac5bbebc011cdd78f469a34ddf5a9d5d34476bbb881d7ec652dd29ce518c2e36ba81b057ff27dd195131d67cabed52abbb3a01e025d78b226dd2efdab5e646b9849ab40b6e8772debd757c0d1b84ad0b1ed469ad5ec26ed230d0f663f9d86c6e88b0ae3ee87107e98eddf048bb81877d63eef89b52989e0e86e79c8e28ae5d0b14509fd43b7f84485f9535a63bcffa94d1405b0e715dcd3efd0d7be18091b9b6f5e617f5b02137c8e46df8862411daefb8712ea3cd96bec748ae35808aeef6398834ba80be42d27d22e0b217ecdf18944b843f6d1e7788e9155d1b026cfb9043b803165ad9f5126ab1a2f394360b635c541225a3b02cac60a38a5abdea7139cfba6a060fcc3c3610795386482b96d0a76d5028062d22100dd5096ac9faf7347df36cc0cf28931fad1e2b35cbb7af06de420ab55bd5c48d620cc2e13c3dc078cb477a5b74255655c8677b17b421158513e3b0f37bdedf56c728591cb0d0e4753edde6aa8655444dd70df3fe97a206260501b857b60c44f21488206a7deec394c76fe7a8511bd2d8a12a40dfbe80e5544269a5c88034d5fc6c7b20957b3a843e52bab7d56d012c13e91dc2ee7961dae8a6576bcb78224a38accef03ab30dd8d05d220d52cba4baa887eb84fbca3f6aaa1e82fc2c7515bba94d7fb36f3bbc785a831713f3d68eb29ce50f04efd8718eba443f9431c93ab9d07002387baf0e7f4adce700be38757e6839f2291b14769e498884bae5bd1580a8df894c73a53d2f58d3a147d3fab1119c84ab01413732659757b3be81974d353639067eb59d4670b29ef1936a96123946843c378aa31d4db3da380e0a1fb80b053876ab96577af0e9a0a410261b249195660e5b2998a21e1688eafc119841c9e9972176b87ec0f2155f514e00fe7becc37532686cd56201bf45f3e3b4ab15ff9071d1a8f910f0962b1a51adea1d19e7e461dca2acd4b1d2c62e9046095ab7b560af42cd329cf8ac1c9bb65ec90b8f65f474b427056cdae89c7f2fe2c460d0b74174ffd6dece471941dad1d3f64d0bc3f5fb9020891de5224d6d518c19a84304eb346a7942a54b454c12bb626f4205e20f7aaaf107c5c111d00acc08fb711b3d46234508edc0ed131eff57fa81425d7832d6533fc88f873e7b5e32e83298c9dbf595254d8382af1848bb9aee9f933fe3283694336ea9b2f36be071d54c55fe31bd127dd275042aa7a11d12539b9c56bc715b5ac1ba88ce96da4bbbbc94ef916b8d6e6a862d1fc771cb67dfb229a4d8d04fc4e6eab92f8179689741bd45d2e14c985bfffa7e6959f07676a5b8b699403a5cbbb0cc8bdda874a7dcd5d744825f4aed259fc9cb70fe6e60c75b4a79e649f68f44f871800f7b8a328d87a43c0c4f7da7389d47aaa2a76d5c883230bd9cf5b3630858ee59e50a3e3420ef2e4208d5d6868925cd4b8529e1f53c7705d40184b8e94b0997f4440a8f2cca37c230d7398c393cab49f14ac91f54b0393a6bb86ff5674fe01bc28b2cde345353b7d4924b852422669e46f76d72b644384d4403478949f31950d0385d8d1822545f7d9b5b517bc906c03e585193250e94c46acae9b98cb1eed81eb1993ac1e68966ac05e221ac9d15f9481cb0fc00711b4a584d0dfd5e0f6958858b1e7831dace84ad2fafe92d6921e7f045502cc384238130ecd4d1a1cc7a902ca54d76b376e36f96ddf7b51aaac5c26423b578fa75c60d54594645721923614ba44770a09451bddd480f8a18f661209ad02f862e736b5d0ad8399b0878ca4cf2d175cac409f033b8571f2e5dd006a400a29371689cbc82073723c320738cfcd311605995638fdb5b97ff97baadb952c4624efc6c29abb05282917b266eb88f2bfd00ddf56936d5b51777805ae9e5922e469e11ab59762d2f6a043fe8ab5f69e79b13d25cf63bf0a39e4fc1b572cd6f9b8fc7e10dda200ebbdb655377d1e4d18651c2535002030f047fc7e2fab88ba0e20bc1a3508b10cc7ccc8ae00506f82cb1e587d5380b7f9235cfdc8dc9e4555feacbe6d8ba844987c35ebb474d65fe69927d68b8ee9b3002b91a805fddbf2bcad7ef217d5915eecc535578e709abc1fb512165012d5a57e190ce5d304672ea28bc52de3ff648bf99275efa83952d7bce8ad3433c178439ee73d9999d099ae4d14b1e47b2ee30eada7e595a9443023811516b90dd9fc2b23eb8362275d3b0a08004a86aac2ddf800880f6251809cfb3a6a4da21c304cd3b853312c29d40089a124de362084722588971003f3775a2b4e761ea93382264cd66fb3f0e284bec18f02392a6d862d5aa87bd167c3637d1702018a459ed73683d55785c0aefbb4751fcd80fae10aebf92d7734409e0e20efad653245e104067f8bc142b38180defaff746a4a1cd36f1a31c84292fb091d1a81a9b618a5ac8a2686b404d552450bf65db9d53ac20d9b9621bf003a890318c5ed6ac7c5e41170d4f9432cb0af2249d9543b2b7c78b270f57c16948932db839a17ab9ce5a434902adcb534dda4e56dc4765103f00b58b1b959beb4dc503874bf4107e5daf6441b25cf8cf59e7ab5b234cfacf89fcb88be20606bb89787c5b65c4e7a0ec83f8dc820ddc770e278f30ffd2f22827f9ecfa684205611c757fee976839ddfb91b5a985fd52fc361b22da873502aa804b756e733b8a3c82b6ffe25fe0a602f4d53f85910f1f2f1e7204163a5b48c655e174b87cb9596a99b20f2375ea2ef78532fb0d7143a784839ec69dbba85915e1ade298caa201f0266da5ed3982ac5ddc4817dcaacadccfe4edee532f837bd6478f3d87d9ab7cbf9de5a5034a96d92f836886faa088bf76fa18edbf3078084e67f64a9e4f44c56e5e691825faf364ef483dbca061b229a3d9a52ea557f3f9d8a380649735d2822abd607836f61af70db5bf5ea1b6dba20f6a05f8866e93bd064c41420dbaf2aa71bbf8f4645ee358fe8bae2087e6d6a11db6701beae82fbf1003bfc86d8237d996d08b451faa19a51d66345797d641d75b2a2e8e5ecb2095c3dce6346933a6fbd622a7a4e6230c9478acf453b643c465aae14a6e0de9742899905e5e85db71b5b91692f65496650ac03ce11bbb9e19cd093ec1dc5b82dcaaaf236235ad58959636dab11a541c845ce5924f1635974875dca1d5bb2e5039431623ea36fd9b4295da2096ae317870d5192746d9369f0ce625ef4800d285c1670fc3b15a72b64bf6a51b4e795c0da9f3b4415e035b8045ea1d1b522420ad17373f50fe2cff0abb6a9b7255c95d41303949a57e6bafc74d010fc9d7f2d981af2378f38cfdb2ca28bcc769b1792778b676357577b3a7dfb696efa700e8f3a512022eb9313c3f109a19177a1bf756cfe31b011e0703a3ff45fb401d7f6f02df2d7c47572f165e08e2b423fa84057fa848c7b2ef83088c7d281e4417638499f3eea2c1ebbc9926d6b21aee345f71aeb371c33b9af2c16ba920bb11cf51bc1293d1aa92f5e5029b07bc61bfdfc9e6c99ef780ca85e1fb76d328e77943277649987d1f43ed73752a3784199e0f72b9d84aa2d42223dbd80b57811b95c317268245695ab97d48bf65964080afcc88fb573401d2c5fb49bab285e0739f04a037704cb1bfee9cc58d32d7026aa3680f44c39eb2a91334295d6033943e513596da9aaaa523f5ec81e92d415e2ddeba5480d824aea16ab217930012c96464deaa986d004abd1a7b0fd2cbda74c132a0a4b4c6528593a13b7bb858cb354ddec4f305b01cc050d1acfc93b79e8c6302d22c93185fa33d455ccc3598f2777b1a452c7ef758d42eda0bdc6af9dd60e9d009a73ddc4ac43f10db1c419a50fe897f5dda98cf92b6d14e3fd8bbd68b481907fd4451f8df5cec0a8fcc3a1875cd2b828193e59690feaae98580e62a318300a0a56415554fa7c34b8dd558af2e880cfa5fd749b00d6a2484feda684c1696282789f722867dba6c3605fd94bfa26e6dd30db6d854f31ca1c95dd5a3f260211efde1dd499e175ef309f2ea10a51ae2db9ce7ee5b7e963ddcab7be0efd7b689d66de389a3a5857a16b2f4422baf450eb1ccfba67ed8e993a2a06e9ddadfddb1f5703a951a0a06fda51049c8ce25da75c42abfa8cd778df217bf9e223858d525578148639cfee7d6da0ded77fd47e795025141c1d3c5cda878549582c0b470a153bdb6f5e16e51604815809c03e05e68debeffee9a265c80dcfef22aad2c21d819370670d2eab1b5a81adc287d3c9d9144966f977175c120d5231e5a6d5b71312113aefc5cb85170816ac7542106ae8f590ae33a569036cf7f04337b787bbf8e0237f024fb297ce3c9ac8810d0bbca6e2e9a598ce99b91b5ad86dd9ebbd99414188642190e2f5e150479f436cd293c0cb1349c8228244ad72a8f3e689c4897d1202953172baffbabbfc921466d17cd53a41ce4334f58b59ecb6d30b813a36b1be092cb84b349c63301ef0ddecc163067b23bbbbe7a119ac3350f2b68a2b62c91def4669801ccf0111c4498ac1366d074a9784a997f37f9681ca706230792287830ee02cfc1cc01767e042de39c441fadf050373639fe6d34bd2af42fba123d7c228ff04bec03e5dd8423f87c4ac86adcb8cc3ed5d9bcb54b94f7b1e8266a5af140a7db08366d10371d2bbe71d2e215ef4132ba376f69f9928d8903d1724e2cebd4dfada2527ad988d5cf48d31aab2d0d193dc97c98142f96b0967c12e13ef15cb0f50c35e1aca901f7f4c5e88234beffd4f4981784a86e2912af1b9e162fa137505a5aa1ba10d2d9f3c2309f54054a31d1a9672da04f707de791bb037bed97abbb67896022a008bd0cf7b72adce73d8e77076f27c89a5c4799949e1085af2440d164556c22ae8ac3a3932765f7ce36ddd4e88b664d8f850c9c85ff7b9f3cedf481ad9a0ea8dea3d34a9086c248e2cabf5d9e1a0433abda20fce2462f91826805e77c23e11e2f307b467d926e2a060ee6c3cb5065f36f7abc18a59442fa74367b9b155342ba6c9929e135a3ad3d43c65693c97605457ac480f2dd13b15dfb1082adcad9bddc4a7bbdf70877ff1ee89d01cf8a7f2f95be4dc7acb38d254381c4111cd15641d7f95961f24de316f3173a10621651aa7fb851807d9b794eac6347c726ca7e0f26b29840f2cf42086ea95eab2f8b6df955851445c667ec8dd4ec817a1ce41aacba252af64d1c0ed10b6b21941df11b278c5fec7908aa440095e08473502804a32ee177896507c2cd2adc49269aab875d7f3513e718f8ebcd3facad0612184f116da1ae0f017373ef919746338f8b039798ba23d5aa6d7c1755f9ad6d37400aad63e2cb4bb3f450ea90bca92656f3573f6f94fb3a88b4bd31ab40ddb3955935b903233fdee9523b65f1b7b08379f3b4f729b9615d3c7174e9fb72fcc17cd7b87a42d25047940301b1005d5349eb57c1a059082e4a2f8e365e7b45618159137f12ea616359e6ad2f0ced3df43a0061e8779a2493f51c58d132e53bb6aa2a51324a61e1bc612588c37cd4567fc4841aa2353f7ab266e87edafaea955c0a9c6ebb08d7dd38ad9082c8bfa96c719da1314f22f61a8b2bce14a0bc5f98e416373f98e82d321d373825cf1b2ca1450f7dd0801308d0f19932d50ac9ab882b111fa82c14f011168236dacc544bb3d360f6bc2d2456cfe05b602f745ee4f2ae86129acf708f7f603fa5cf79af7be9aaacfd231b0cab82dfbe9b979cb6d60196ad348328441258900f6732ec549c2b889891ecfe7853da56f9fbf66232c2acd8313e31a454df8bceb90078314b1cf5e90038e31cd7a50c22cb093c0a4b0325cfaf4ec58ad0d98b90dee7b2cd2a857cc3f7730cb39f0405bdb02a315085da71c099ce62125a247ff65c4ee55d17a433d220290a816e0194560b63756a3d0ed87553cbc0b53775723dd265c7b77ea05e3d4d13a7aa16d5d85fa7e7110cf50044ca4186ed0cd46caaf427cc7e7daff18270a2e2f687f103008d5d322475f76fd3f4fe9a848a7ae3094c9874e8964d592d9f4eb6bd507e98bed35adf91c3aa9f9294a2b3171f96253bce7fa82f37b4eacce410379dd580cc197bb5ea43503a689e30440e5b893e49b4a5882317173a9ead9956a268947cd48d729d5ac9197188b07f2b575f7ad0f2746d2131d7474b18128d68d580e54159a435e29f47547702e7a1120a068fd7cbe33d902b8eafafd6167f64a0a8fa1258b17ff09c01ae272131c356d9c027cd216176b36708511ebb078ac3b38a36642f3017b0c1e3c0c40f25d17017d11e6e3df14a821188e03282a3f717d7ecbb434b93ab06c6653d4409846cd86c7f39d05a5a43c1dddc4c06cc4b71f346ea1cd522e38ec5f62f45525be42543b511ff9dd520cc759b3a46b9730bc962401bf415b4fa375a1e7213d503a7023b04620f21d601d05f49ddc308458cd3ef32e4f58f222da213b2c33b51a501ce2eeb2c20c8771b07897349f976658ee7e97af6f934dd2615cae1a6ad5adf56a15e564efc34fcd2d299f1f00f61ea8caeddc9a0b6a79aa19ca34d651bb064946ca58551e1c847b1c67f7fe20c1617557e6e87a08e2fb2294f0ca9aeb698dc68f1bc839f577f2d6edd42ed6a3be27d26a5e4b22fed88b865e2bc762e31d40303cbee4dec2393cd17395ab954bd65b5988ff3548db9aa412177200fe47283bccdcf22969bbf864d97b5df75e3662f74f0bd0ded8e7c202adf78d623782b6fd75904368afd441e4b2b373c447029d81f183d41f963a5417a549abd4fbd86eb478480cb21646d5506453bbebaae3a2c0e3f50658e406fc5065598e009b68be88077a9d014da8b5b43d3091f294b3bb9dfd3d099dd44e393c77c846c75ec1aba5890421e2ef631186ee43e9c741a6fd4f613e17146a0314269635af27ca730a514ce6442c9d1a543b952c840604b6256a52a4eee11cac6b24da210cb30f235d91c49670a00f7e1912880dccb32851ee3bcba56e044881578be8c30ee07aeddadca3d1c7a9fea40696158f7dc84e81f3dfb6c5a08443772358e0be755d8d26494e362ce1a0eae2efde130ec863a4b543a5aa82ada4f282be818a2cb8fe16d1739868f2bf9c2676fd2ac923818fa86112639a1614f009767e1c6ed8be82d39be2b1b5a14f18e947de3714c45a20409f3f2060f678b348ef5f90d18ab0efef79ff0e0b69124cc845595081a0f9acb390e6d29fd7926cdd7cb5f81e7520940fd935fd61b4902bca98430cd3dcc766b5197f6cb4175d9b9c7650b162247808b168d933f74ec7b4d1ff8899cbe1025d36852bd2120acdefe844db06f6dcd9726195a60fdf19162ae05b3c7db2d92f14e0aa80e2d89c68701d1f00a4fbec59031bce728781db345116235784c44fb4619e9c7865ccd936aa25aafe2c12d1aea34fd8c39b171420dc7d95ecb2c35e8cdf2a7c314d01f5fee6bced6f5a4474e4abd05ba97cc1743379ab5a7df0ad05aff22086762163962b5ed91f72a177187e86bf3eac626883082253dc3fbbeba63e8f51900723f8b879953c9c2b095cbade8b51c13528d52575d911faaf8182bb8cf8fd54ababcd0b24765eb35ea2607e3269ffecbb9643e466b0264b244a9083a2dc6a87dbb803e2420ac1ca8653feef003f499a1983498128a1595a96011e830251728da47e032501e49f20ca0dffa894c859ac28d5a0c91e7ce73c1629d4f33635295a350551dcd3b1a8b736448434e6a03b375cd2b8d628d1730dfeaae58270788a66c7778deb21b595037a71b793fce3664a9deea9454eb725b17e3cffe631d288c6253024d34a278635f9dddd4145e611aee23cf02e8df5b5f966db227ab55f073530a37637c59f18c8892771cf86c3e7b5107330915e87b1d0c78216742dc3cf986c18a67000f6f85ceb99157b6d6d0d1da83e81300429ed3de090e69107e9360cd93f1c6249ff51b3694c149a7498409f2dbfc09bd85ca6b188c76837e5c2343f4dd3a4ea4e27ef8de1635216f3270f8942f9e5ecccf2bf9126f9f85c8c4f1f58e462d75f358a5495c737f06b0062da9048cbc3f3ce683b6807934e9f2485ed6023b7ad67b2ba352bd12c391ce65eb97fc0c801f283cff40a9dd2d1b2e5e18f344a2e8b8237dc54c5683aae5e456f24001c87bdb6cff2b6fad2dc3b94558b4f4698feb38b297ad7349a87910b978c81c723053246575928a2014e9dfadb5906a12dec151564304e6181dc53f784a10883c6faeae023f4196f2f1e1268e83f72122aa18417402cbcb1485bff0ce7a0d33ba6b778dbf92e5e6e60df36f6ae6ff3e5d91e98609206a4c2570b4d2c152d43dad2dd578ef39db68db484a4caa50a027aac7a0c24486c0dad8e4848b6b364c6c29401c31658f541030778c4bd9c81e237b2ce02177880934d760a14f58e02ad9474404331539d4f4fe299ae4ea885929a94b043e53187ddebfdf159ec6adbd922a610035f323e6f50aa78780682f69d9b6f6deb840ae75e550fb012778189c7ec08ec3257314673b842a86ba1487e95aaba21b878d1eca117bbd6351fedeb17c63e60e9b509839546df2e0e3feb7302db68542f5e4c0d9c8f7d67dbaecd82a4f4cba0c5a8dbe59d7baf355c29835cb3de09af8687a21d5db9cb2ce97220298e20b82b94a4e5e5443c5135d894dc55958d809177e3a51fc198fb848fa8ad91821552685efd3d5cca964c0fc9f52f011c421e48340f62a05b27c839c88113308e9b03bd5c9ea3440ec2fc9e588ac0b48d6cace7b5211c0c50dd32e86e7ab6c901330f3ec7f281a716eddd98b49385d150d9ee4b9959aa3f55df58012e22789a3360ecac318accb59d8b412c5d140f06efe28ae56a5241b5c25e3e6f51b86178623eb4ec33f38de280b89487ab4698669ce682a7442ddd3c0eca8a589cb603d1291387039bd682fe2442218c0fdb54cb67894b0118143f5a84af87af537ce007a19faf26549e020472941fd939b12fe219186de7bb2c1f8a756a831af1cd5378c2cccf75ca6dfdc2404a2f353771b752e7473b1197bc67e54ff98a46ae80e928cf0d6741d1534a81a1880d01699f401c72deb34cd94fd0e54fea7aa2835a4ce7826634b792b567c57d899074ee4c3328cafdbf537a10f95dfd07e80c303f7ea9799b2191f24be8c45115db2c17c9b6a559eaa3873093bcc2645fa30c42da480b4fe6f7173c916b7e05a7937a4d9d06977f5593b4aa7404b4f2305bf2e9020cc65b97f81a240fad64f7ad464e3166767088940435eb225d4194836e3e0e94e5877c7f7dfc2cc6e8f5c844cf042479d2955a6bac80b81bbcd0dd539bf8111f4058985537e2487d0f87b901690b002725d42f7d692e69f93cd1da4b230bd50287fcbb38c4434d666152c9fbe7fde79f25c0be795c5081f11c5122ffec4b4f94d98e25202e4341d15d7ab6ab14d682332ff5a23f271adb90475dc590c9f90193c625d079259a5fd63a5e20174ac034b4c8b5debbce2e39e1afa0308b0b71c613c7b2c558aad2c2cb0d021f727bca9c62cb1ff746fea86a15764e3d4c41ad175aa52f1ca382b8b888f3eac7c71b17e40a96497469baf528cf99e9552f62d909992c1ea6a9a07091111f9ac9109f2731e3d0222fb8f7f54b982dba460a614b2bc03d1c2f52f89d9724acc69e03ae820f67f41cd94c58f9fefbf40836ccf944b207e72b779caa9b52f5e491a92f1e5a4fc1f327533842d6d7098088a6648004f2bf23998e9bdbbc33c56241a68c44182e1acc614517625c709626ca6aec9721ae6480b30afdc82960bd45e4a409a132c1a7c73b801277471c6deb4fd22d36baba37a010f9d024c0cf29e4cca5be64e4c33596c51061c5e70dcd6f940a80765402b8b164716b3a82d534cd34e936748f74348c7aaa1f396e765076148936e858fa79e1cd149bccc4d23183ee6ce0204373a2be19a8f96d625817c32c885e01fbdd19fc6b8b682723d4d10a40a7da5023b25bce1723fb51eaa120671f421f1434ae389304f53869e1443b37b7ede7eddc0f008001b438653a6e5f90316816815aebb52531b2972a88709bf6b93853b28ab4618d75819d54303cf3386e4bbc46698ac9aa57a0bb542aa5305c89ba6f0e23023598836011bc58ee189862cc816131bdf334566beab5970c7dfbd312124719b93ae5890de9def27b07c26673c64216fe0a8fd3883610894310ce04640b94b22169e201acff292c087803977fbb74439cebf3f3a45779a0c2149a374c24b3ac8b03be6ea76f225c13ed963ebbce633e0cf857165b47d4849fe5e7574621ace05424084f4db207af2f2049adee1dd690b96277d37d88fc24981eb236cda1e0e469a5b666efacec44816ea2bdee8e6ee806533cb7d31fcb185027537935583422eea8a73c109493f3b75dcccce1ba229b25c2767edcf2235840e5cba6494706dd96c416abb09b2a5416da001146b76f62d2d9bc41a1bdd07f1592ec36c73f6f697b04c5a1a650f846b5f1fefc72a2ba63354b6095ac74f925f234e329fee8a80a18a759b474d689668dbc139e6b20e1dc78fb227396c694d8d5f84ac8767ec14f111252882c69c0d724b170407b95db726b5f5a68399aed5e40f9c231d9fb36547bd766558f7980ae4f725b5c975f750bd0534e9c587947e8df31ff3d85a1f781b7fe22d5b104d9fdd5ea2471a573f9d8bf6b946b04d6634f091da93b77a9a57bf66ce58ee5c0fc2b0d8c0d5240a6abd9719f814d819ce6451b421af5fa32ada4478617d7334ee60ca64cbfb072e80266f5ef558ebca59476d43060bfe348168b1b799a8f9f43ce850d9b625e7824bd2d6fa7150e56d8ea009e0e2ff442d19e6e5575d247e7a5222018407d2c73dedde07ccab384312bdf4488199054d222cee323dded540a1683bc25f17d2ac6e363388d2efa4e20da9d913b57dfafbdd31678573f32e3bbb3ebd17663c542d5ca2b90906e099e1d6fe623223df04302d6fe27058dcc6f889343a325e8ede2629a7fbc2faeb4726115fc030f50491f97c566bd0a117df795d8013f9862b7f44d848921e2af6bf987671b3a0cfba7b207b117bbe42f3765fbe6542cec9b0b9156a905f54a7293d285f2c1499e41068ed5a0750c7cf4bb0c4e06e9ac13ccfde871c54234447ad8d33f8fd8d993a5aaae9097aa1af4ed5c23ead4bb3a71c8e335bbf4e089a7bfceb8fdb864714b0b12488cbf1dbd2e4b032b14e86e6b8a989bbebc01439266ce3a3617bf4a35e580756eacba3dd17aa06bffb961a97ad1401bb01f912f81432f2dfd741da581751181e127f3aa0800d972dc0af87f8b82b6d04562b300e1b5adacb2a2ed5a8ab2f4f35bbd85da573d3dc01539103a400418fe56d31e749c7f6d84f43fed1793da7503636759c484331b6f64f975188a56b98cc50c81e12ad1ff26f0639f7b1ca224cb506fd63b514c5f09b90d31a8f9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
