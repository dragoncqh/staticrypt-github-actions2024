<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13471b8baffa4d5979fcdebcd04ecff6b6735685a5bb64820e81a8b8f5cfd88f5e2c11401fd490e6b4c8210b3694f76cb9c77c7672e0e4606502cbf7448b10efc4c94ccfe8ab80208e13d2a2af619fe9b81434a7f9420bd0293ff3a81aadfb824bedc8d0c0dc6fcc19bbc8d2aa95bf847ac76ebf8aaaa2c01c4e6ad23ce776ba08a8874483e064aca29e3ed4c968aa5682a3f0761d893ddd442d0a9d3421f67abcb2f51c97861cf9b8ee7605037ebaeb4b779a64fd61204e2fd53153acd8483fac3ece5bc0b89dbd386e74264c8ec87a2e096eafd77a77106ae60ddbf6719650491dc9d2725a65db30c603e3c27743af6c412d7d06c6aa71da413423b061efb8bd105a6b89936bd1e7ea4190a3ac14a56a1049e48c008797bdeb1235945faa2fc5229a258ab4eb7a0a159d8f99f0de91df4d77e15d500c06c1f646af4b9b30aed0e32fd6d644140f4ee3a87c3ba02cf64530da15344ed92130ff559ac1f2c50f208b83a0e34f1e016d6d0e5d2fac13dd13742ed6b710af11aa4925151e137725c234f5d6decac47b241f5d8bb1f30da4e82074f00223e9803017a40eea3d45678eca8fe3ec03651f142ec56d66b3f2b0592fe89b2dc12259710cfc6a40831adbee8c8b4a498ef5b0c5293413819685d60b2d92a3cafae5d01f808036d28268576d8f31b77d1c4e9fafc3c95677ae008e502ea41f38aeebc48501b3b75f9f2f4fd2b114163c7626bc4c08a294c894c7fde4b1efebac84d578f0d215cd2ead6edc5422a9253c10a52ca91b62fe87d94b17de7dc869208176697e2c48871deaa10834afc1c947c57bbe481d917363452cef37c319b2915e04141868f945d2c1e75b1df84adf273258be3e6b7bd103a5fb70a84173d67ebb95aa5ea672838f73a8706e80a05d5629e31f51d0b9247ab8c23f49559807e8d8644f63a71966af1b13a546ed46c7943aed82cef23abee2f4ae41c34bcfe23c7d959b61ec56bf96cf8c8fc091104096451cb2f9ffb3359e3cfda339970bbbaa8e0e6de33433bf16b639f3d0b503eb8555f3df9e807169e86a991eb2021721778364a39bdc204f07bf1d1441af665bb628870ecb8c938577f2ac59e8111a40a711b090650104734f5dfc80ddc5ed9d230dfe1c8b4a7f52268b2f5d2132e4d543ac479b6a9dbb0268f939e991a89e74560be6e6501634417546ebda395b8af0c09a2b0e551a2e561d5895b1c05ecc5c2441b9014a3173b9f3feb573c66e1da69b43528d2a7437c45bf7251095adb4a1ae71bbd37a15327a02edba392de3a9ba0fe7d9f5c72a03ff1b648aad436736af1a96053a57f421d529e02ced325b7d965f05754303fb52dfa0fca04bcb3d985dfe23931612745d75b3fd2b423e42bd128e817063b4da6fd66c5c959fb44cda1f669ce06483c3fc259d15e41aa27accfa06050ef2f1d51b7a5090126a6d41f2b4ea306af9582d465f9fdfc096e7edbf7b70ae791738a67d09836d87ea09c7e48d0b16f211c6ccd0ad02f2fe42ee6073b00e7eb840b090c4cffa28649230e521554f521d99b65949614a866a434fcf5752df6f653d347cae28c197afbb177d1487e74bcafd8987e7d9e24078cbcfc825dd8bf94bd73a5ded879891cad076bf7f3c01ed4f1785bfe9e505e6baa80332a0bceabfffa4c00b18e10b47ccc683f9fd0c61c145b1a85f155fc96e076ee5b956ea490b66ca3882dcdabd3eaa1f380a28f119cd6deba3db71ddeec195074a09a30121547cc40673914518b447ba013806eea41446ad4e0c6d6acdad9a16b018d1182377269ad4d4de57b2680bcdf9965fc4d3c92a8592a9412d1794796838d8f92f1dadbdbd516a5e781b49166b323dd007f6f761f9e0cfe315264b21342246650969c8fa2047d3a70f8626c7d88fb830ea029f0468c5d609ef69274ca47bc59e357c40901ec18927057995cdff7de5851b75e561eaa0dcd9c429a92568bc3db38278be32ea0907f774fa27193966fc4df47c07e672ea8824bb7089597cd49eb9a78bb5eeac5c4ca99110491157875e06015b2193ccb938ddb2ab34d4b87c48fa76c1b257b609c2a9e057d90e5733321b070adc81239f498633b10de3714a4a3af409a3cfb6b0d672fcd3c4cd21a7ab50e52db571d6378db4437d5f46880b200746fa05e50f85453ec2f877bd6b6047a01ad081787237def18fc7038a558e5a26c7e3b9d0d7ef8327e3c587d2c46253d8ebf6d8c1cf7c6c3b505c230e08c174982fbb4ea9ddc03a8d639551b5e8c29f8ec62da716df31f9d617ec3aea25b76d03ff0d6e61d218b06130ca07e20dad67b56bc51af2233ea19cff244680083a451f17086b76608945af1940cd0f525f88877a7385a68b59c3cc6be0b1710d6755a0f51320faf4e0d998d22b63a6b1da55c67c44742008742f537afd0faabbd2786d2fc9f16b8bbffc66c2cd66591578f8584c6b0becfd976818d22e3dcd864434df0d03d66950fd4fe8cc181b0be4cda197c537737b184e9098e3df8b049fcfa156c8cea59893bf714b02a4e5b0bbc4a577924b78bc22b0fb9bdd74e5f8a8126ff18aa59bda639781842f01086af3db44b6ea4846fdeacfde2e60639262085d8eb1caef53c6cb2be8a30cf9dd54a2d54e28f19d4b62279d0786b8443ff19d2a07c34fc4b44bbfa6f1a6020acbac8d00ff80c04c1d2328cd9e2b0c8c81417cff468c0e125e6d742e003ad8024ad986bf43c7df2415dd59f25fd0db76eff8f0e92b6bf0641ad27cdb38692ed324fb8a61cdc3d2d4e7c610ddefc1222229afdf039d76d9fcb19cbf276f6549088dc0945eb61a7be2a3ebbd993cf16ba062b50ef99ca9230ac260f5672cf562e63c59d938f4d97a41bddc0f2c33f417a3743a2081bf366a75a5266ea2d6b553167bbb8ed8bcb2c927a202c77288bcdaf8a4e22306d3786e62b9593d5e31bfdb87b3ecc5b4cc902389e3eff004f87674db1c0fa03d10af36a0545854b94147035a8a0d0fafd658536bd77a47cc51a91fb631afba7fc93fda9bb1e09bd68cb3d804c021175a25f191d7f68e4ce9818a6b2d6bca45d68dbfdb99ae531aca7a564c70263a7512efdf7cfae8ff1c96c90dbdea41b66981095c360595a321ad801217996a827b8dda78566041c26f84b89e6005714a4b633e5411b1d1ce04feb948ae924bde2f2cfbccc7d6f6b1b3d44073a4f88740d0b66d3522dc710376d673239aace5e92b0165efca45ce3667b632112972f438ef1cbb7fa69e9b4eb2996f69b5c88fb04a3bf2e1b502397b6e53e86bfe76b2e57d79bbeb2fdd909047b13610000819e7f3b980538f696b680625ef29122bff22159e32401cd002d0ca5f4a6e6005f157964a0e033a8004722128fc96b54a79d60958bea5b37259ec09953ce0ea4c675302d6fc014aa3b13d9a9a2a32bb424fd0c43a5ea8882867981116b81fba0ad7a91be87e832c4402f57bdb26b79e36fd78df7cc3409af2abdc8889aff09d0894c79ee300b5735d6ec337e12fd7e0ff1586fa3d4ffbfabdd3d02db8ffc6cb857c8104bcafb12e0ba91cafc4bcd9f03678eae0411bf2755fbd0a825c4f81a4e29e0fa7cf527ed5b7ea411cdc7295d0183a687defb9ddfd183b5f190f016787f08f3d4d37d24edc83917815432ecf6487c249b04667ee3607497b5a58af208967976ae66e49153a105afd6324763622374ccf33f5e168fc5dcd23757c144fc8de60f5b57a0c916158c827daae95763f80db6b63d18f6be8f9a78e8bcd8e4ef078996e57b71bc9d53f5a2f7fb728da0b0bd2a0323b304c5261728e54591704c88ff235263363811a4370e2a74e43a47edee4f72ec63d2548dfdf4a525ea39b6d439d1f4419c85ce5dd6b3b6d5e8f9ab84c208ccc0d1eb17f618da0f7e76cb11d679e726c44c0c1380cb2e5d97c446987bc3d56cc6eed12a8ed3fa09f80c7f85416efe0e8cbce24580b7968119bafb786708318c07f2ad14f1f90d345d8af57a6a7e83070ddcff3b4fffcba299d4405ff691b189ac40471182341a7af04397d8b44ffe5af36d17edde9aeb2fb4e5f4324f39c10dc89905313dc9ff466120e697f4c5e63e5f2bbe7629508da06b7a3b533822180108f437e778ef3b0ae67395385896c9a97305f81772da9845f8de09359969e73ae5361cc9cf23e03258d5bd4a96d5aea4e638c3cb4f901de4ed41a04481e03885258808c6cd6765166d39a68ef922c84e437f2ce7e8380d5843322441a905a4b6f5ab684d31b2116f33d02cad39f72ea32ff19cba3b1f3f604a9e717bd633f9c7b727f8ccc25f682a6f3abe09cc0677e2fe920db9d00dbeed952be1c945b2cc08c5db70868fbc27d5e45cfad6625305e76a410899cd4c29222b2d68b4edba09b1b158946a882fb8ac364348e978940324f1d14753629fc1fa8a0beeea781e61455c27988296c4f40c792bda914a71fd48bf75de02be493cf9833f74001523a71b28a3a9b490bc226c2607eee645bef3e91fd37a9bd23d2f049ffbe3e15aec11c3767f66bc7ad7712a4ffe5cae94fed44c98fad3d0dfc8112bf85e3b9424f9408d627bb652a360aa1998e8dcbc5357adbb99689c1e5d1c090e51984639db1e092eddcca36be576263ddb3da9b8f39f2e5c638882b39c941364e09b5b8e8366ab5127f8950c57c5293780f0b64292b1e20b81e0673f3e411e501a2e0ef7d4cfbcb934eba9853901ca53bf04b6583e10811ec9bbe9f0b398d3697ef5d13dc6c021de45c327edac75888e5fa1e70ec2b8246194c50f83061b5a35619338994d96a117868fdedfc6619b82218438fff09ade6d227dc26de809f2878f65f4b1bc90c5b778114a72d4cbf33b53f3abf37a38b03dc81d40a2370ccb3701efb1728d9968a3e586f20f1765fe2cb68c894faa0d3cd3aa3c2505c28146296f54ab70eb1af54495ace3ef90641687e1a4311b0628b9a88b3844868bdb4515858093fb93a6243abecd64d3b906b71efb4cd48baaa277eeac5550e2d619874b952bfb0cbed3fd29da8855ac75075c8c1dad99dc6c80c519e6ec2521f7cfd721c15298f7a30b37164fdaed0bbe0690ce98fa1939e0628695293b52b9547015c71d35ee0d557779953fd0b2185706ec3a1344143cf10042fec3ac6cbd7c7baaadf5bffe8aa145190bd3e5e0016e33928a04ceaee9c345751c4bf80bde3f237efe84fe8f0e2eacc1903462b8810a3a8466760a9c2d4efcdb9e33e2950b505fc4aef552afea80b50de6535a63ef6baec9e3aea5c2960021644c2791f9a7fdcc9aaefa49d26644037584e910f838ca8ed5747b9df6908968a9a420cead758ddc038e22164fc1baa9c3c11e72cd03411727ffcc4fbc7b6a536bbed41d345f0aeac6138b033dc343119218ccb8f708ae16011de3505a38dd2184998e524922d737caa5505088b7b1c2ef6703d38d9ba275d6028dbccba54e68b7e5733dd101bd3ca901ec6477dfb89136f579fed060592187feff66f49cadfa40d1e08953e1fcc876492935564210a7aed3c2e97bec5600e58d266168a702f779d16a338e7572bbf9e95c8c898122778e80e99dd7cc8fa903e5bdde7ea11b05dff2bc4801021847268389074a50160660aee5cc007dfbb7dd379742adf4c0aaaf9b3f807bf36239042c7fc08dc7c49eeed74a53b4f4658b7005349f18875000a5811540df148dbca2a721ddb1963b65cb5f43e97292ca4c6933ff12840bf1e66754e50e86af34fdd088da2b989029316deb9d9439bd9b8be3519d38c521915f32b3442970ba11c3e33f38a9dc3367d1bc1bcbb92f324d464486b3167a786bbcdbf292c00b2dd621da2070ff2314bbf38aadca2ce2af0410a110d6b5dcc640e046b6e07bb7d25e2e907bd05559e2ca3f0b4eeddd26a7a0fe93a29b351d72e119ae4cf8d308d88a95fa7edeb73ba54627f47a3e99fd4570a52d90502f3c81f6741ca73adad20b25866028785ad7f245a09b4f2d080589f92a77f0a741c01e95167ef5e4f7b8cd1604ad955d0102601047bf205e4172ede59e2a8e867e6b06f298390f4ab0c124d0daf8fed01e1882c5cd0d83f405df361dd5c4a5ff04fdee37bcb2d1db746b15c385ca75a7ec91658abaf9d8e6b3f3a207a676fc99a6103d6fd9b10aaec8d95af52f485b813c5ee7553c6c47ad07613ebf90d1bccde3444f05ba658efa124a6494cfd3f2afc2c11e7199c643dbaba6f70dce883dc78a398b3f95345ca816555db93e3c0d60dec24042e915298cbcc0f4bd78e2acc85c1c8d7d3ce75823239e04d8c147be2831880242dbc403f64d31e0f796490ffb0811cbc6f8a4d116e74a02a62e0c449fc0d63c8d37e04c2d58e87c3f3533ff3c1e8c68d5ee70e61f82e5a7ae9c822ee1e12edaca8500093e3238592d225abfd265d2aa8b6451779b690108e99e8b46ed730bb10b49e479c1c49e45ae8546eaa269bfdd675e6ac758f6ce5d29ec086d8df3bb0d6771301d468c0d491b551407ec037eb9dc31b9bfb929df125dc7b4794a6c254318bf3803bbbf465d83aadda67be8ba0e26486aef67811f943682c9eb35aac715c35d042242d151b4e6d6369cdaf8e02fc38db1d9ad0084c9995e687aafea76b94fc621343d29b70ffe2f394e52e134af0d9cbb78dbf86f64e386fcf4a9591fd5b730e166d41b522ca280d95f25663934c7e9728bdae603e39d418337a8924c876abb2d2458cce8deb5f1f8d8141aff23fcca0b82fcddf24d5a5fc09bf2d7c7969ba612778aa3a2c8761acab82cee4b09008e224db8707fc7052543bab23e44a8dfc09e86ee6b9147a163ec291839809547fac402b33aaa9f0764478da7ad80512724f102797a6f11682a378c01048a4e6964735df6e12b55ed2f62cddfa037ba610d7341329451db6e5a1ccd7be8e118a39da5570b0a8daaf5956dc6f20277eceed0d5bdcc6254658f1c89fafacf70fc504a7152d88a305e4d70f0524291ebea9c2c4700fb2f8e69e51e95e2be7b935060f758e1f7864a5a9ca64d30e3a1a3bd8d46f52bca896422cf048658f5c5be734963bdb6786c851b98f6a1efac39c9957a71e19b6e592c1bf49112d1f39d608cb38ce71108aae4bbdcf010356621817a9cb3f344d1ddeba1f4cc9d66443d8488dac297719df0044763da11827617b27e0175d632536fe19cfd2991e38e22a096cbb28ac9ae0bc146f8d0179bc76eb262d483dd928ae8d5e1b72567f3d4ea5f486f4b70b1339546a4864d66e8ce4731a3f7f972973b54dbdbaeec5752e72d27cf8ae4688c6bd619d8f1d41b2477153abbc220a6ae8b0eb2b536651ae216bdf6a55c8369e386c549dd40cdba31f16b1d66abba1193f3e9e3c8bb3adf13fd1fc8bada905cc466b23de41b1e0a1d79c03eee893dda9768ea17d93c86818af8c27a7cd239950740ff540f9d4fb2e076c46ea2bfc6970bf7f6283f83adaf0e54b9f1993d8a6e25be75982601729bc1a7c825bf811a23f3bdf6ebdf05483b39d8139054ab08e7ec19cc0cb224651c9ed97a38ccbb10e62dcabac716229c360c2b2a572e7ab9f17c868aa9bf321f11cdfec973486519de9d4b206c729d114c0633d18043d3da1714ae95a43e793f049665f78ddaa6ab670f7a353c8ef4fb57bce93208b2156d79a43b2d4d0c4a88b57dce493b657e128e0a83be8a79565226d1e41aee15362092458f9b3838075b5b4369f5ec0b0b6477bc84780b25823bbca22016ec486db7b103f657f6afb1d06f8fe1e3baa3f40b35d0eb9bc577c9e1452115aae91fc86f093ddf02285f746c22e702f31a5599eeded05ea733780ac66f568c7d447b958ae38a487b63de6ab428f47a0ce637d0e7938058ae1ed62a20135e5dd93e9de363a5c7c6a30ced7baa1571033cb190d0d542817f9a43d26a82ebbf166f94029a79052362f710f55e7f1f86a5f0ab8a2cdbb2b44c75c2c5aa004731f85e660e626f4cc9203a401896789181f25a1aeeb5b7d6bdfb4757f943452bc9034e0c64de0e8e9e23f9fab8a237482f91cbc4ba00f674fe958502be00292b2715c54d8bd780c133d75cb7740215cea6c071e8f86a297db34d62241511f86cacdf6f8e179ed0e50c8119539105273cfb33959201d5446612adc8668ba949baa0a49304c9e920aab394cc827d53d6458eede7517c177129361e2b2720ce1d96701b0e1e40310fa983b79e221c5591cbfa8ef1a6f427af251d679ea34bf7df7954b4f6740cf1838a5ba779184a9bba7041466df7c85a761b48efb18772533979d365712b42aa269efc66f854bd4c4dd53804cb6d75fba060022c1c31a21c6d11db1e717344ea1da234c9b155e62c8221c10aa1fe841110006fac198c7cf9f00ea80178ab675cd6f32f08435662c65325ba6e0212431a2cce2efed2f0ba8b6d1f3b9a9f8a8432f146bfe9102e24151dca2bf96d952f37e931a97528c5f162344c7944f27d633fbfd4006b5479066ffc750fe32a48e2c57f3ff978c42935fa049db3c3da46d7c3d6b60a9203a45a5bbc034035f8e616f636dcc8c45cd69bb7bbe3890f4d8d025deab763741878cf76a718f552277afb10d22ca3c764dace6175ddcb496a0065beff3cc00941fd4765c44d33725de1c38ed513ef8ad6d4fa798c63dde99dfa0f58c04cb2d226ed0150100dafa3bdad38978bc2e4197976a913baca3eff3a91d44a471035f277193f0e16657bf3c8821e1eb079759cd2a1335e70ab01f11d3083decbe7d130b3ebe4a2e8ea2d8ed3d351b2386498c844f29d75a7e291419e3ec569a99b60989ee973431d23dc2f707aa5acf219a54c889280d2a9001b056876377c57b55bca5d235578da5356049d3936b4dcaa107069fe1afd8551ff8cd3d2a57d947f73ba31ea818cb84521ead5cff5c2b1f0a139fd3527406b0796be4b20f248195d4c24cf52e330dd847c96d56ea54f564d0da0b5958c228e19f057ea02d9bfb2ce461769e9ce598f4014c4ff0c928877978b51b3dc892004b9bc87eb7aeccebe88f2cbbf78487763af6f176911fa69f404b9ef1cb80ab443270f8381a93a70f1cb18467a7bbfcc93356b976ca6215b8a1ea98b5cd89e544aafec2dfa54d33a89ab4ccacdc0eb00dd1405e62e11ef081289fe77807ddc0466e43187de2dae6377a4afa8aac68877961f663436ac818de0abf0dc5e3da85059362fcff17244c392df670844c01f71c2c0f5ec67dfcd2b588d4a8075fbd1780ac96218360e39e523f6d1965903b29679bf945c07f6e083302f2b9b6ab4ca8283e1554d8b77563331c198e26a6b887bfe7061c2601ee876a7f42998f5f5d764ed34cedc6ef14dc34f1e8c2315e7ad2fd13779b48d47f775301e140941257051fe8f0e278cc2e8246b91fa30061a315aa25719a2c607830632a2e89d9838e89b30dae65d9bc874b3f10877a1131f2708c7ce7684f6abfd8a8f33f66140c05e6ab8cc891af1fe385e638d0b157a3dae7a8dd14f0f5a1fe3e9694bf12518a7c65b968bb35b70c85a2b5b19ff8728d2ae2e211995dc6f81300f38ec13a6ae110eb9be4c09aef64ba34e54c6cce92c91574b530987474e813cfda3c07f8cd7632121316aad4c38cdeafa8e1b79e85db6f219fb49da57158b931f6c660eedecfe91e43fc1e8fab7823ee6ab79bb4ee4f325c8e9c3bb2701790bf746acbe5cdefc7e78b061db45cca260734ebe80a4956ac55838088a3c13453af37d905df5815eb089090d369ba1a6546b8c5fc619f029dbb562cc78d37b1ceeb2b171f0ee3c416ce17c2804a9556d55138a97c4a28fac8e9d273d3bd83f6a24bfe3e8f91b3f011e2c779e1cf606064e147f099e08f8b1c4aeb60e2541a9115261366cb0878756a6920d5e44966968c603f9621ab47168d8c122b1d4d6897596a28f6f5c16da5dad2ceb6f59cdcb1afd8c2603be3e9ac0c8d1955d164dfe855ad9269c8acb65a831de3803a04aa0eac8fe7012c8fdcf1a9df6b4154924761d028837f8c446aee39c7b33d2054ae7ff0266dba558c002dcf1d5c295271723205d9f5bf6be06f422e673bc9b145886f53c3aeb4d4a41c56180648930385da14475b12eeaaf01986fb4ee765470160460fb9cef6fa0ff365bdd948d228a6d5fe42344b8f0629319fba320ee433fe2bf47e06f1cc06c197ad959abd51090a9e38091cf01472d9f953cbf18a5c8bd7a867225173d077ac6e02112334984770def28ca0c38621eba0abe95e50bb07c7d654cfe576b0bbd8e849ee37f8c5d1ac72f49d649967ac2a6ebc1ea0700669f8d83f7fefa91e3125f08f5a7469f89e19346b163bf91dfcff3188bf43b070bc30e6654fb649acae6e5957e3ea98a0f9b5ee38fa76773e3d4531205f1e9bf067b4b6d9d46d9f1038124e7062040d6bb096219072b89449c2b8153d3a28bc7e45ba9f7b20d67aa45d3b88be241c90c2dd6c36913735455e5a3bc97ab9a1d76fea1b7533da9dfe09afda8269f207053a7251009bf214f53a4bd0806408a04bf7588785bdcd9a6ed96ee0cfbc17e765aca351edab540593552d87d6a952597b34c11c30f386e6bd070b83e81493348286f9cbd08c92b7febf989c7aec430080455ca88ac167d881b01d6f809b159bda83e23aaf5a2b4d92d3967654a80e6932cff0462b2657340b6e66bd700de589fbd68ab666bb3226603a07da89a9cfddda6093d10dcdc068b7a2590d01a682a79f62fc5568617b2773b117a151a2f08364e02ef25bf23149888d5b9a40e4f3d4fe509723138d360d4573945fff3e40ac2007c30ca1e25bbee6ddf86569dc111ce4ac01240eec12aea2a3216fd00a13b4b274ee0e39e4dee09b6999899f406d92d8de665f971e2ee9315b07eb76b9aea6f23b67fbedda3b6d4e9e09796a01d762ad366b38825a11ec5eb430e80a4762df2866f85377f13d62a41c9ccf0d7cbbd3ffaa3580c03a353c0586ced8fa69820ff77c3012b74f259ceb3c852a15d53992cdf5d9ba6ebfcee1bb7a12192a1c3ab35c0c6ce23d821f54a77bc1ad7ef363446073a008bb1964792ea2f0585e7bdf4e4800e33ff7234e7e70d78103a2a36c4b5a3a3700f11c87ea39f52b31d30811157ad45df0f3aff44612d412e49a00804c36f422044293df12a9e30bd62d7bccc41704c4d44b3272d6e1484e4b197b6130777900789bb90ff6cf7ab436b1acd1628a3dee19e4f171c2c24080fdf29a08c319d57719f58b1018b1f9c74d8f3e9d298f1cc74b8093d393f17dbddd88f018cbbcb95d1a77481d19a59e32a3a1aa7232c2e1fcef1c50b8c0cb124fc1fa8498f4dbdfc4ff25034fa57c8ea83bad3dd7fa830ce20faa0b068305ea747fab8a260f076ce78aba2ea99593457749e4c6053d4fe6f86cc176a3ae33d1e7580ec33e855b71c1ae03ab1392861d2ed8318d632f819917411788f8dcd6a86625c0958994f8b62dbff1ee81a84f3be6b03eed66c2bcdf6583e95d524b8e142daf36731ff9b5b146b9fec012d09ebd6be6046a57cce3971c490e3a9ef016d910dc92ab65651c26120982075a1b1900833b064dafbdc1bbc84b86088e706377e0c2063bedabb30fed64adad57e9a51d0f8eaa26dc69c713c00704774c75aef2f09e44e666b0f004d7eccdd00f893b6533bbbf698ca7a0d16629e61b7b8dc64c123c33da1d2eece6f9c5f6abb80fe65392d2c2826fb15fa6287f5bcef6f1310d27132e80c3c8835d8f5b99150abfa576635adf87444911ded67f2459f2f4dea85ac593da99bef88ef65899fcdf7b3add526f49bf4968b3b862ad09c89a3f9004e477488c28a1bd20a06e81cad7b50b4c88d1cd1117ab0f626f6f512905197e929526ea2d2b826e24765e6e3793515a676c6e714ee66fff22d3b13ceb6b62e0c594876640fa59bd4fee245454f756b65be43944484484bbe0087f80c797f96d21b43624f751aad6bbb347e02fa21cb923ab08a76b6d384982101f078afd906cea976f8460b0a49d25fd669f83ec4eafacada7c849750fd7973fa2375982b3904da619e9e30aced41d1c4ed254fab17ceb31ea71630c11c8c0d7b53a172958dd61bda6505aee98b0fda772fdca6cf0eb7c6bb5d1e3e26c3981aa96f1d82b4495ae18d97d3cdb712ff00bfec53f9023467fd80d4279f78b9a724bef3da91731aa6c4be7ed17ee4e83a9d7fa3fa993c2058606dad5c1857077eea94083efb32911c99aa57bb35b539c0526e641a986bab7b7a44f100d2cd8fd1f75e83a25cfb5bf020dce39086648957f9556fbbc86923eb22da0d405bffdd756be3c4c83656982e189753a667b585b56c600608edc79a4f1fea3b473ac0643755de3b73ef4ca368f4e5e0696898145e30d4815c6bce8d4e37d7379c7c35998121e4113690bb486302b1e4a142c3e783d6d76b50af008d661f2de9c5bf413349ae94708d074000c81bc0476bb62f8f0217a6009bdb343937b069c8e8bbaf9002bf6ca425df1db3a7cfd53f0477bccca18fc2a77cc56adb196a6208d9982bc2e63b194955907d702345c993b3fb1939ec2b4cc9dba0cf4d6ce711680c6b976694df5a4dab698f0f057b269cb30a2aaedd71271885ea49314228467a90d29f62d1459614172a3a3ee261e0befb19780172c219f2843f7baadb0a3bbdec41957d43054863cbdc9e844a24152adfa0211cdf53f7d1b3e44e062ad3fe6b85620e11eb727b31fdb491f748a70199f2664e589be4e1e15cf7abe77e7e8c932ba7f48b3edbf49392dbefa1f3e2902e03e6f1641c4884933b8280416283605321ea34f7e0ba679daf76976804aa9658796d1ed59bfe2c60c467a2f6f9601b6e05fe7ec7619a6f6c48145f062d524bb8584924b8620543622191c92af6f8377d6f819d5ba0dd7f0ca33860cf10d787766348cdb735634953680e1aa776457eb05777290a994f95864a605a0713a9209fdf4a0c1b9d614c211b44cd15333b150f25f8e9d61c62fb22972441c2f33d4361136b90fe86baa53630d44885b1ef9fb44185240d276f0e76cc13df06d07029a09550e35ee8f603f33d4416c7be3bb2a246cbb903bf761b7fce1623b2aab545d18de47565757268b6b72ffb7e0e21b29cf09e24e6bb613692b5e8c7ebe71b0f1538f1d51bb8e61e18480e595cc2142ebe0879edbf78ced95a215e982df5541c99d551eb3daba3586e0d29499c7b074c00ff97d5e7f2480e6c1ec1e4b638cbf055d15f241f02d6f58a2c391677f56b22d348fc068451c607aec88116162a8a6c47d7586b3c69d73589c125a197a71b5f3b09cc167b66a73c64858ac93c717526cb8957fbd605075dc075998887c53e89f80c6133779e5d9164e6f384b75a10e60cf9f34f19368f16c3bd5e795a5192d4d89ad12b050b7e6836470de51d347d36f01f7036689bbb3f27a58675175de2bac364a01933848e2b5b731df4cad14e1de2476e1d2d56610a6027bdefd77de8b2df39815ffc5645d4dfc44d511c23fc8e9fd083f1a3ab384f966e666e23fd492d5a01995b8a9cc0c2f86faddff8439a48c8ae428020d6729a24ba103e3669ec069b265ef615628972d9ce18c89199ffa03e6bac1a24c692e493097cc98a8973cf3fe334f0f3c98c2ce793eca61d31d4c640031cf3a9a58e6fba5ad2936a37f83f658b1f0e640fe4f84fdbdaf7a78a30490d98eee6d39d41bcad282b1b7a0bafd217db8fb6cab99f14902d615db2a36f3b66873f4d55790925582770866b687f02a32d518e520bed2b4e186074770d27996f35600b13a932170e59bf747b005f73c30d2da0abfeeb15baa80e36ad0b8e112a72a111287b523ccafee60c74a1df5b190de4ef57863132d4c97e5f059467f265384298d64117f0442d7f215b2536bcb4364dc1c6eaec0ba2f1c6f3b94205fc88105ed3939a300dd18a201b5cb2aa6b6be44f48a5576b76461bec526e87a61205d4c836785246c21c9a65d2154f43f59dd22ea2508851f9710eecfbd12b5f934975647c3f886de61fa84cdcc4a8bb20b777eb2c91fdb3338680ea49c8fff379aa5078ee4bf92cf28aa412e218ffdd019ea11784b75f352cce8bf585dca329c41bd3079cadd94ed5ef274196fcd5ed6fd4dc16aebf44dc6f2e3df3b1ac2a6e0b98ab7774570fc7e12981f1e5ee56a39c688a36adfc570268c62e31b1678f89c438e19c8554ea99d59a8a5fe867d81e8e01afcaadc2f4848994bc2b038b655201d5343766c23e87d10dfa13b84139a7ee421e1e13995acf92877c948eae6a94ca0542d3e6528c5ed1a0e4a69b2ee4997cdccfb98ae556e34299f1212151d9ffd13422ea71ea8739d085fda8d1b95829b8e15572473278393fc93ad441d0c6f996fe1d27d4f447dd469161cb084f589b1e451bd478e76a8ed8838243725d863658fcb08b7f724f93f7603dafcd00388db079d07d239c336477d1507f4fccf6631980a1efd724a8266f16c4c35abfea9646122be8cced575f38f9ec8f1fc4f8970350791dce1f7553e3805b8211bbb16eea5eb188995ae682943257fb6b231768773dcd68da06bf6ecb2d9dcc1e68bcfd17d88c7590d4804afe37e209f62958088b8638cc22cbc4e1a70bf2db8c6cd569374029729ba7034fea1b1fdb18979bce59b4047517503b3481e8070dda36b45a6afdf4f007e2c8062a00ca0f66d17de1f33ec982f3705f2fbb79da44425685516ba6d93c54a1a8a874cbbdb4f84f114ff40002ec8755fbc76a407e5a9712b3549d9a9acc17b38cd0ea8164a3d98da5bbdd4fb47d3b28e2ce3ff642f5b0ad6a52dd91ce4bff648a078dc6e67666bc774ccc5e1b1d8bd04fe5551ff7bf25ff8080613a2aed62feffbe2ec04b38027a7283a59f83235c2e0c6fcc1faac349970ea10678702f891d623724ecb01829ac643e93f299a1a43e74326be517e6471e7a40d63431f31a48499c61793fb7b1683899da493aa7520c56a3cca254c493b94ac3fd902190a72bfdd4c20d90ee105b8d426b303ca6ce694c9225538bf04e34224f3b9e00534961801514388550692beba24761de1d4f3aec1148ab103d19752bcfe006d5914c393b4be91950716d73066445ca92a80dcbf57eddbb8ce30940bc5069d3aa7fd6aee34c4d2ac6a4b58c8b3eb41b57c66f8a135fd7d3f2b5e636fbbf4135f108ef0750aef4cf1f9fec2f29feb3e2ce9f0f9f586b6cc0255a36c46ec825e8e15644603c9fcfaac2e3fa9ee624bcc4afe48c75b3586a3a3aa20b0a0640570ec30ee9144bb8d070412f9d2801a5eecbd360147f5d392ad4d8fc95ab578617aad020220b00dff4a5e6a7f656f0436efede2f6aa471a4885b60235eba057fada9faa8ce34eee53ad7733340b856019cda0aa664d1ebbb19e63cf0a50f363e8efdb17197c170014f23a2246003f588e4443686064cb62361044e1d5089476253042ef0bfe8ae22a632077f3eee61f3b00b61989d1d1911545a9fe526c9884bc97634e46755c81486bad78c8598cb26c739baf4fbf7205a3241e43e400b4f104075187ce796927d6679e4d9f7bb3807587c280cc22b8c765f4529be34f9c6c312e0108bd62821bddb80c5acda0091a4e0e4163760d393838e83bfef67c9be87ecfa80c5f641fa27a343c02e60b459a7cafa5c0cc111300ca333c17c01f589c36152bd0dd805cc710da8973852fcfc7bbaae3bf34766d3afd0d747e75ecadfbfba57a5d8bf41d6e8a4d4aee4b947b2f3a7bed8740d46caf574dcd9b2b5eb0594487dd53394bd5661cb665dd951392f1acdc67c5e2f676911cf05d9440bf6f04043bc0448e7c8361b0e0b35aed009da78401583b211dd07161ea97b83b5fce081fe91874602ab0706d5612ec890fe83ed61128e811e07660f36ae7b4088eee6340681472166beb3fc2b0d6afc409ffbc9305563be917cfc262f93950668349b6cf9af9c88d0dec82b0fd37e069ed68101dc9a8a29990866268108bdf99cf5c044a5eeb54a79727efeb1775c1dbe93ec469950a57de254387eed90093685c4a7b6d98362cf879c89346f915560378d1a6bb24bec7223b331ef2e0b6c82a4bcc6d1e2e62676881718c3810aa6ae6d6b7b274c9e1fcd12fa7d862b58cf7a7ed2b248eb569072262193fefc0a42bce197dcd6c218e971dc77ad2646fc2ed248b5bcfe0e7407111753c6d1ce4ef3bb2cfaee93c7c50d564c7cd44ddc4c95b97e4ab46d760b9b15a452e78701ad98f7edd12789c7a88f1453e7461019f2c2dbaf4d525461a1889c8323c893826d2df75983938e50a7dca45c0b61c86db7fbe2254918b999d156f005e466a6063ff89e30f6642e93b0aa93348d920c306f3130ed8edebc36776ca63b295cef35b0730a9aecf45e0359a3620e1a03a2cd5417bf4156040896a49673b41aeb1726d33437b997867c6d41c0800f0c78250a4639311b2afd7c82925c1376fb7c91050b736ad14f8d658fbbfcf3aae20397e9292e7429cc8891e6bb6a0ef86d2a9a47dd11e2dc3d3e458ff19c988cb4828c9dea4911285b396372a3d1abfc22371ef09f836be9df202fc232d1354c8c1d31c59c3772cbef91cb46dabc687dd91ddb945f5013203fb57235dc0f59100380e8f8e07e8445de7943020665963e45d748c3f327fc6fe14f351a80b86e2fdd336b3bf707c0297a479f293d0e9d164a4cae6db10a6d4c5f48fe75d82a77f4c4c33b95c3b0ba8a17ca14188e5f5984806fc92abd93b3472bb01c9896b3397b0bd3f801f7c9f40170bf81b68e84ed9701e4a4019173cdc5c41bff2a59e5310d2ccdf50c167764eca6647c8912f283c7e17b73cbacdbac8dc13fd78a8eaecccb938be433e8799bc86a77ed785e1fb592f14f479bd4b4f7e9df20a08d333facf55f45c5b6c9fbbcf80c6f64ac3276163742530fa6b671f429b0eb0d6b3cc3792c3cd4eb0a709fe7ed5f812f0c9a7308fbb27a205f39e502b14cb73015eccf00756a5d648bc21153083bcdc1f46653ac6219a146f145b9512665bfabc1dee00d31b80523062c2695e0f6ab386daeccaa8a81461fa9acfe873e448ce1aa9352d958a18a884f8ac98db61057fb233496e64f2648cd3927ba6601fccf8cdb6677ac1e534d5a30e8c838f7c476b96a29efd3b4aaaf9cb2045063debc803a45782dd5813773940c7a29c65297d9b3c2de5354a567610b4b07d75c93dcad6d9a6612705e59fb0560d5ce864e715028f76da5f1a1c7b6d1589d197862b2c748ab0aedb080043489a6573b0b4ba2e65f666d1326e27e983d7e49f441f6e1afd547d16cd0e883eb2c23e1d842e12fe5a0ee7d48decae9808d9d6e73a52a2d6753c24b99226a664388907ef3fdfbd864c280fab6734a3c77750523ab771e977621e009aabc60696672b571614f60fe642a6ac1f6922fd9c0b443b169fbc7a27994de520bbd89dc35b69695a5e6534c385a253e1dd3115da3c06a57f25fcca3a13e72b35ea028be13ca9e3c500f44be061d572a17e16004aac475e9a3f4a9d2053de64e72c463063328bee59368275f2b368413c22c724379aece240f3745df1d2c6826dbfed7330a390d17a647c7433647c12b6b551e6e780fad8e9a932b5b7121156da964666b8e36c1d8d088a5c10b3d0227a30c2580e8a7af48e377f2bd84e985da4da9b82540bb6be58679ab6075b87389342e6eb2a61718f528f4683899ed8b0023dd0e33e7aba6718b9e3914e81c251efe088a14770012ae288123219b77d2456a35c7f747d40795db04f78c2b7ce1948890cc0493bb0a36267284c170f371b59f62a4e39af8a8f18b31389fc70ac5b26629e4d598f84e081c818b50e588122131b453fb58f82768c77b05f81d0d4575fd76448f22e7a8d796c2136194152810ca1d8b1a3449e484399eb431aeb7f6ec3f943b997b397be9d3b4acf61550ff9343682a3dd42521603023a8b07767de08bdd5215b1e9bc865e359255dc922471e6419437ab7425bc381b020354065ab116c3222cd75643d896ca432b020bc497dd5e027173647a9d9c1907760b2f7b21cb8ebc1a37deaedf43bcfc7123d3ed2e64ec8d6836f78916e619e1cd0c7af0688c1d1d4229a52857ad6483244f31861c228d5e48d33354b3e8908e565a6c8becaefdc73eeba1d2a21f07ee2e69e43aad9da5aa4f02f5b3b8744f98363189eda17e4bf82e4c0fc62a42dc8b7d013e2848f15e88df8081aa4aab245c70ed4e11194bb6e5913ecc0018c1e3305319c0f5f1c03e4e95e6a9a78c1bbd2a32b3d1743d7996b28a6141d7a10e2ed1895db0f08a2f5962354261bd4f770373acffe7f7532af9666fb4ab01c0d9308d80699097853e0c2463eccf5a6e485a81f43b868aef88dfecb84124740596f0780b937672b0ec33882735fa0dad0a80f9a8c47d0a4b1790313661e1b65b985ca8ea74e45095315652d7f317d40fd360a6d5786bd98bfed0f842f4b1280c392b71328dabd56794d8b0ce7007ec8cc9c1474eeb5c444f5847e08de1d0be05a835b1a6c12ae5a6dcf08a644585b5bd4770baf6c124e4924819a408773a47880cb8863e3d566ab16ea652211659de01fc42f377699602929dcef9f88b9d0f3b0ecd102dafa1511a6c193f0e49ec9b74631604b0d68bcd807cc0e1b995e91f85ae5d439f47591d6a4903c899f9933b80587a84b10e022f4d97357dfaca4ce09ad04afed826eea505b77912f333151c4a38ae773a6162ca3e3093be88734a3e1814d7236984abf1e3f61a374faa1fa8288dbe0e98050de209069b2db65f453b9713d6b6c3d7f677d7af055467578a965b792cf952df1a785e0893f99cd752f700d608f33229048873ada34ba9626c6bb4c1ab3e0a4fed6187641ae75d35a95a470ff482f44f7d9c7422b0df15d16d1d154c5a89a3196d0cc0266dd49c7ce2400a725c16fd51853592aeb0dc5cd7dcc068289cea0ccba850e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
