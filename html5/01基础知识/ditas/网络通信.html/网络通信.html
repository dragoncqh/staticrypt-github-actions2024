<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90a8d3c0d572428256ff978f689f0b5b13b3bb6bf59c8f484dc4a07435ae8e04d45714e698ee90260d98e7b05a706b8ae1675e72f1f71c3d239f552e417dd6b2400ef92c96d0f7aba9cc6636ddaf04541e59de71df1bc6b40449a805085c168252fad5acce73584798a6e9c7e842a6a78919abb2c93f1815d23d815a0de4b59240cc7b787a86c7eefb31ad4c8d374945e989aeb2535f066a4a16979063e11d5cb9a897d3f85d9f5085114f18472be1dda259ec3e7b1dce6333cc811b5fda1d3eace6b5b19ee8690919195e48a6af660d77d2e380265a6c5d0ccb68c1fb719aa76a1428be70f78320ceb73c9a79569e7ee5dc8846f936899170eecf7379baf053d96205effb752c16c1f6c58e694a95d557d1f78643efe4b9b3a7ade46203f4e68bba171b879c1f419964d2189df895b5b947edb8c0ed0a2c61c7d9e0a13573867a892808ce8f39ce4e8feb1f63b837ee7ecd8de20ccaabce5b0b58459a3a3525c366f44a23495da5825b7f7e6ac25f130cdc8afaed8f147439b828b12b4871bef3460bd2c7dbc42314ec04740c05c268794d6c8e214d0344bf674585a2e8757b7547fcb4b577bb2294ecb879db5dc96fe74fd7629fd1d8d828af2d0b62bfb0d8b84d2071d825c82fe55d371fe00e57af0a9e4ccd966d0a91f16cb1350b2fd47c6804411143c2155e0c694ee5111cd9c56e4a55a2ad0c75366d0b000e1847c6319bf822ce16d0cfc2fb7e2226dbe9482fcf1cb5a4f81e39b372e2d49b91b61fe7a9acb594f77e04cf8726b2d66350a58d39aab80ca98d89abd7a33976a3833107f690b7d2ccc9f403f0a05f7622bd323507a7633f91a082050121add2e42295bdcab7fed7b51285b84c2929d853f0082d13d833ca6d94ed24eb7a5d356421485e92f9ea6782ece111b448656ecb44909304f3f4c359ba4e5b3d9aa222cf299eb96250d53d2a1a39eff3ae9fa5b0fa52582e08e1d523947b751155f8d12c51425365eb8eb83a6cb31fb208fc01a9e9b8cddc16b7b40e6b6aa16484bb4b958a8a0fc30a10f4bb0c686e46781248d4515a818060aa91856745dc5edc9171d0e89ddf73b0279e87b1cee391d0a5e14c0ccac1c30a811f3deb17613179357c205158cb9acb2409b3a13873f60ee15cdcaf2ce93cc912fcba4cf4efc497f348aba74af91a9cb9701ba7d61becf674a48c2f3414504c4c388bcaea477a5e04a0387e3e5fabf6b449867ddebfd0f87b08e81a5c44bdc0c1d74b32eca50c047cd1088db096d3a0b9f5d9f28caf5cccce9f600039a195bc9b56de05346c44dbf6b8cb39abed05e2c7ce66bb3a449adf26f39da08b32835cfd7fb10b4a06adf58ac050654e92429ed37e2046aa088417c0417a8500a8177d1bfb28baa8cc3beedbda5ee71b6a7918eca33ec4a28bca4524f6932180b0d5eaa6be98a1f6ede1e2f590debb74b92a7d43d961e0bcb2c6f2528e9fef9cded0d4e041dc8ff8f78d5523f26038db2bac8da2a37c516df5d703b0cb23697418b5f01706de70bd2b19a8a4329211c0cd2042b6298ddd393e17d46d6a6c89984ee000219f12fdee4fdea94314b3ddc8909da276a2da4a4ecf9f8e5eadd7f0d6c6249ad7603b11eca24373a2b9596ea3dd66afc6b771e81e918990d47c6ad0ff5f58d62ad72cdb6fa694cef2362b0d29a72073371c97cd3d5ec900cab53111f6024707b4da845b5d053ad3c181cd32536e1c5d0eec7e865e59dda4990d38835a6a6a9d8ec8315a084e73e43e1960597611296ebb3c0b8cd056d3c55f1bca087260e0f1363ed6b062dbc521128ce8ee5e2997293abaefebcfd2163b471ca5d41e0cac7be51c7dd0545fc89194bc05f28676f9970c0baec5ccfd2ebd0a33b98c283c59c3c1cf4614dd86891f6493553b39e7b5c2f0a1b85555287efad061c8842ccb4d7c68f0e759b43f316aaa84bba61bf7cc0466ddfd9307c6e324c94964a65c9f94007050ef961d88bb374f9e77cd1d73c775c4a58b1b252c7689b6cc1b319f9313ef9df624b2cb21e857315bd801bfa0e7056fafd16d52ea87c03e27e39b46d6f7b081457e1b665d4ea4918d25786f8a5de2a379051e4501a805af713edf3d74cc55462028ce815e045daa27d7e8009d8b29feca4428c0f16c61a99648e33f2a5a879b0410b3b24efb776f2ef8809831be51cedd9babe40730e4f8f07df4022f8702d91474850b405b5a9b9e0853263d9849fd27647d22901f7959d60a598e69a336e198e1887527814946323c42a95e7c739d3a5f0e96a0c8df76b0c6e076a864f9c0ff5c8d07522480b68d06382033fed3e6f179480921d2cbc9faa68045018288773ea46550906e351941a009796d599858541048a21d887cf006dcd322c058c0295cb1f16bbd260d4e1d6c093636d5d6b01f6494dd4a9ad2db2c1dca899deefb140fbeea2bf1ee97547a69fbe1551eac3618a0c43e624abd355e4dc0ddca6648d37357e96d59d1fadd64d1cee96a8aefa68c00e7ae9bacba03bafb97d7472f12d6013a1f8b43d877222f2c33ee8ac2521a3067026cbf4fe13860045724f42f0788982e13c1e145b4dbba4f3042efa34707582babff0be2f73988bacbbb82de9d7bd54b667dd63a67014dcc192c823f0a1e36d6cfa5b4b4ce781ef3cf6ac4f6f0f3cf61a0e3444af1c41dc36f7c5477ac31340df68a8e11630cf43670d2782b323847b1b7c23af9b0206a0ce028fed731b33238cf70b5448cd438ee12790c0e2cd4079d4777e1f187b273edc875ebf05f1c055e153b16a8c04d051fbb28fa7a0a114bab37988d995e016c98922915d9e43395eb0716afbdab08c5810ea2b864344ed3a4c2cacf53901084caff62098e6408c58a85e6c4b7462ae80c91d82de596c29b2ff24a1a1afabcff79bdd43b7da8bdd775687f1dbf7c4fd765182db6d9db0a7eb4394f12bb25eb0f60abf606b94177147a31abfa43eeb77cc4cceed137c0babcac50f5d81d4e583f46cea9d2d711c70f75178d9bf0fe976e05af40b02cb1494e6c66a6eda368fee599c77b0f92ca6e887f3f107a80e5e914eed2d84c9daf2068a1435091268748cbcaff1b4e6384063ce43e844bbfbdb80de858edf5b71b3f1fa1c8bd08569206f99f53791a514076f3d3dc64445db9c8637e6c5b60a8a8a68d9e25de16f1f34a7b61eda78995af1196ed004621cf518733f9b98229a407c8f099364bf74c0216be6df3efcd3d5d3083606e6a2949edde190d954426c18b79dd61f67f701bc41946f0ab8f79987c97aba3100f769a37313774754fae6b28367cb0d6eed0cea5c2a105567bda112f0c0f874d3c4ac46e5d9d5e4a310bf616a78460836035df0e285a24bd426f5db64892cfee754c40e0449c0224e005e4f57626580eb1effd1a6e0122d205383ca1e6cafd47c63cba3515959bac8fb1aed0a0a8dfea18d92aaaf2a285f601ca225fb78aa2a01c6c32c4a54962015bf23131bfaaf201b4bf14504a48b31da7cbc255bc3f6e478224302c2014086706f265bfa0dcf9d9eb6c63cdbd38689529f8020fc20fc4bae4e8d5061163533ca5dbd3c5f9c465135be15c2fc899f618201ba263849a435e17209c8f20d1ac986f8a7f7d6f8e7602fe4a6850d0d35a5b28c98016606036c39e0a181b60f261a5d4a68d489dac2f58e3ac31fe7e0665328f2c26ddafc02cedcaf46387e33fffdc709c5a06c1af57d4323b17da7940a083f51c1ebe89ac191293377011c201e66b045c2fbaa79de031b4cea51491e648d2cd664c1a9059fac0416c6270c542b83861d4fcc6e9d7be4e158a2ba8bc8db0ffc78c0f136760073883805386b24cec2a7a89306682e88c0e47827e62ae52a9276eab5a781a1f4841659f2010df9736d750047f021be76c4b0c699bdbf861afde4249f22ff79fa8ba93492869599a3df2be8aa23521f0d9e1fd5f85288731e4ad7459ba25f41668eaac48d17af951b374b7455a61c60547b52dcc5c2dcc9b3490163abaca88fb978a38056c31e92756db7efebd0fd2e1ae65e6d424595337a82f3cd3e1459dcbd1369df10a0543eef3e3ce6403431650acaa72da0a07c38e85c220e5c652988714c6db9caf490002f2722b2edbfb0a99338d4125a7a10a69c10e85d2c4d3dffb34048f7fe033afea8ffc1ec198b6c5297cf7b6fcfd710550a1b2ef04472962f94d96a3614e592d2ce9a064fc3891bdd7661bc31c4b3cb982c31437e45fb525cbde57714b5ef1c998d5c5cea71bf68e1b45cce04776c5cd7e0dd5fc3c1fe694c3a83bfb58c8510c193cce6f5ca10ed4e02ba9b468f5511214a58cbf8b1a3fe838c223b26b5cab7722e4b453a183b222f37a637f2c5107840aebae2c5e52740f75111dbeda83d5f75f1637a5983bc51fe1bfee10fa8f03a2428c6ec80c9cec1260c6a001c8e8ea73ab47606e0770a52a633fcceb24de39bbe7e11dfa4eee23dac8bc61f2c3f31f37f29f0729501b36f72c5afe341ef2f14a43e91a8a8ecd85da03a5ccacd77ab2ce24dfba6486507a9c844529ce76f4e14f259e881914fd0e31a28097055c78a0285a09b8bdb1eae0c068624aeb6eb193637758032ff9e8af3384bab2714be699ba1a0eac6b1d14280ca2dda2c78903048ff7a9964d8be93f6df608a1764836d22a0d0f1cf77742266813735244412c3ff9be597a7b39727ccaedfc1b803a65d2f41070dff343b4d0f929e4254cde46078849466298012c2090937db9cf077bff9b40f211550ff3dd22ebdd138e2aad45cf4b255e89231781e21b5ca8cf54d803aa6733fe8e515b73f33745ee6d92221d286df9aa90d675d23990e31ee6be942f8de79549fc2d099cb03630407e03737d789ad7e16e33e3a21c6e038ab9c14bb2cfe1b10fc5242574c2244987ff1d038c95fb8db299f207c353e93bbbe17a270d2bb626d15903c8889330e90df207705d06ce720d1e7f9d0aea09bb0a30406b3447d0b27d6b0f0cf51886ca1154ebb4cb43f484575144a9d25cc84cbc4f9490257f2e0d61219ff562f34d666684314c8ddedad5b41fd3b8534596b45a99898caf149c3353da7258014e3671198cc776d366d835e475128d2d0b451557804f67d653358003ed5c2bec163526aea53d62a51fa0b526ca26fa563625e8a749f3c4f29c0ed8fc8e1e37435027e97e8d0865e67cbadf7c17e210cc2c352d3645820175f3d632cc8c352ac4f55a20d8fa1f2a62bfd02b01e29b27f81159e91b139903b72aa7500043f85bc46d3e037d08971b2ac485c08fbf6d42d50bac2f7bdf1682807437509c0be3cd6c71d3efba568c0e1ee566fd373bc41592322ab4284c4fccd04852a834c3dc021d680c612eae1c27b84fe8ca6e31960293fde391132a6fefd16933f97a62e3b4d836db2e0581e1747661e97396906b1b180a305b97efa390be068cea1d30a5ecd641985548868a93a8c44f95cc6fdf949cdcb89c9051a565f618b53799f9be4f57ccfa096fd15c6807bd6d2fec8b16efbb4883e8717be49cae134e153ef71816ff04d74edb0e336749a83ddc8ca6981560d24b51a926f4e9990ceed7db6ff44632a1f2c537d6552eaa1aa7686ad6b4493136569638a0c9e6d6c423442b225b8067dc113feceec9874688f021542cbf33c34ff1e03689516a133b28cecad50e59e9771dde23329d6a5a4e9be860eae5ef526ca8ad96ca1af677461f5364a7d4bb77029fb94fef6bd59a9d91a277a929063100a5e50ebe20e4ab4fbc7526bfc2a01331cef3e760d7fa6b908eb0394e55c30fe807cbe582137c227ac8f2dd6fd3ad2133b1aae095d75d55f969260249cfe8417773c0ea058d37e2f7a04689eac824673ebd6f1f6f7ae994ae09e4f1861e1bb1b342b43d4f8cd63c6ff5389e1d47e66464b690352516d72fee1d09518bb5caf32d35bc7626117b465ae2475f2cbbe810ba7ef5c5ce477a98cdf47bbfe72a945b0ec96c5291d4f5ea6c5c8f8a78c57a986cb57ca3d37b2817245475eeb4da0180c811486d4bf0b2ce0aa57cbc8a36258c50fa19d454d7f8ba422c332482e61d1a2adf2a0c1e47e420a03b0fe0f318329080deb6688d50527c4260a0749b705d47005fd397ec152bdfa03d8237690a57e6f6fd1a97459825fb6a19ffa9d2245cd70b0663ad18522d349c724af2d08ac9e9ade19d36bf222247bb925637697949ee5f5479d2f40b63ee840efaed5578d53fc1b6264750e71e63b66ed19de246c66da9839f7e6a7298d275d854ac8c1c3a0606d3a63768fb254c362c477130094c34d61bef261ee10a4beda3e5aede58e12df0bfeb898ec23f74fd3619da0ba000a042f00d36d4696c40f4c39da350116f1fa430edf5192a20e7727a6b3036b9b0143fb1486533fdeb82d903400f17cccddb6b020e40fce5348befdcbae9a9bc99239d5e2955e0cf932ae1b2655ce1cddc9ab3675869abb522168bcf46c1dba8cfc7945e13ad3c37b0c2e1fb1a4ce28aa795add11115eaf626c0ce4e912ee36ba86734023bf97588235617c0784439cea414150bb68205f9d94cd57ff84bcb6d0f982bf4c44cd1c037be98115d85807b369421577bc7d1ab9e8ea98f916f5822edeb935ddcbe500082680b93aa84557ec2bf082e39aab94fe79ffd7b2d67ce96c8f93f85bf26db9011d0b2c8e265091b8d2d8ad0f78d7133c63a22b4be72e971b7534bcf8f27e997afc2082f406183f25f85b70fb40d5e952dc5633d3b95589a9aacfa01702a05ec5df9bf01baae6565885ceb30a4a7607e0cc3b505e59c49fc148d84a514b1f47704d82eb5b376abaaa8dfdc9068d9a38847a62ae3344f6e4609679564661314944a593b6a211a58c79c98e6a137aea0740f824c8170c0dd71c1f3f6f3f1b8b199c8bfeb65cf93aaa416f18be8ebffff6b217b5f2a6ac725328f70f4d8bf6cb02621e37744f6343a3d1620d4331a20d909fdaa0812ce796fc93fba8407d947debffe9786aa0a1725ea0fc92ec65045b57aa9c881d5ba177c445caeaeaa87f8f67d78e8d6c62a6fa6a89ceca810e32ab855eabb2707bfe4f01b54c7b56f95cb4e0e9f1024d6b20b2630e54481456d3d0fb2fc57fec82a52951ff71da8d7d161e33d21fcefd9ca9add7b7a8d621d5bc75ddb42ff67ea61b1fcb52a7ac81dd4ab0aecb806703fe79646ba31cfb09e881558678ab06c1299c02d001dd29f5a683e31eabcaa7bc1c1a87080b703d6e374150545636b359ecbdc736d3745e66114a78506d6ba90601ba0c7b5386db3b102489df260f14e7182485fedac8a8794ba150615c6c16a7460f89d504c08db24a8fabf2467f1d5cb3e7ca1d1161ecdf9eaff78398f1a05adf5068dfd4ef5edbf899fae1f6e8484f7ecbd05fd8ef93b9feede6023cf8b230328e9763e4fdf3cc25391e35b9f95b3e0afde1f9e8fc4f78abf9692bfb780302bddc670d61a8260940df63f58305e939c01146041ef12e3baf8eca3cccc3c0effa0c87297128c3c67fb29a0499a7a71942812aa56768c649488df77c9c04cd233653a10e2a5d464b443ca4923888aad192052fc17b9c9f78f82a7dc73aed92a211f6a8562a8a5a757c83b14b1e8a61ca925ec76d25b783eaf54f12ad31d242cda07e34026a5dd31ff082a1d95ac15e86ed49519c5ca50378155c76a29001631cd937dde53f9d0fdaa564e1e66d3d61cad9a7947a67518f2a0e8067546db35726d87ed990762563d29830ac96259424145054ca4ef59e2e3a007cc6829335b0a3f1eb91b78ef60a00215a0034eb27268f589f5ceebfff55ad00072237055638995364be08f66d034a8faeec728af83fbbc18964715f70060ce895c615cf9933e58c13d66b3ca56a043b51d76091963aa61ff22f9fc607fc4df44d77c263da042639196eb6e9f80e608adbe66500c1744a804165e92f2f18a82efa79ba1092a1e8eab37baa6b59570175f58216bb9970144bd289acfb0351d1e36e1b9219ed730419d5e4717a525b0166b304eb6fc29df67cda7364ad7950234c3d0a29f2b5228a06586aa58a951f52db27296ac0b0ccfd2d3d8fcd051ebffd5dbfff031b667f1c7a2cbf7c9ee64b161d098dd40290cb94442a52435002c5a75f985c189ec4157454349d8cf0804ad5f61dab6e762c16e71aed206a35f5f7a6cc059b385782637e9941adf4df233106f55923d312cff72877cf061ac42f902bc7dabcff8c3f95986895877d7a8280e0b8af227cd228c5e863247a4c45fa0dc1b2809486cce3df6aba401d481000747fae1de6966fe353a0e8c5aad7b1a63e7b255f23685b8d689ca3fe905b8e9238efb2b8288827e42d89c820f40967d766909bafc58257e084ee86d40df0f9dda3a6fa0c93c84868a97247907ef863b270639ae11358a8b08fe28c6ef4df0f52642a4235c939f59c1c62d3dc5934141bf467706475a837155cc0721524a7a1815ca0187e478c5a080f9e90e5b4d069645dd0d93146a36785b3985258cbbfb07ed74ee8d3755c545fa7756fdbaa15f1fbf5401ed82c4df32c517c05d89bf3a4aa9711910c8fdca50e1dfba0fc4818528b2629b247cc2fdfcfbdc6bc0c5aeb560076d2a195d8130158bee62d376730097b05d8cabb79820efed5925709a9405c9a997c742d66b1a19bfeabfed68ede9a4201acfb2a3e94533ceeffa45e17e2d76c3e3a85d37c6e279a93a794aec1cd179df5e639edfb2e3ecb837df983379a8c4e3d18fb26cf6a8f80545260f04a89c8699ede700ca4d887aee4c6c90692a771e35f099510127fa96e05744b22f58523188a91238a1f1cec4c9b7e2d40372fa7877ea0889f228a50014cc461377644e8ad434b1157c1c33d9f222d7b1e20666d902c7b3d361e0332073ff508cba3f497b47bdc3dcaf104cb6cc26a08c3512241b9f532f167cb0104d59d747912471ad9ecacb1f5a3d3a49e7dd6a628bc8370fa119f41c8b2f1590c31f935ce8e6e593350bc5a3c244a4aee8ead55468a2e629b45851227d889ce2e8852d064ea6d9085f8e7c1508ef83d9eb2c2fd97e86cbac971833073ac308be734ccb904e6559d5c561f73bc8c43264043dafcdf4382dc14c802a2ef17c2588c3b709b2a3c2da0eb00b0132d53a01224955751cf80f7dbe5180d2e44e89745c4d221c9dee87595acdeca010c74139109c1d046688cc39f39391ff7ab7629ad2aa2f633e46e5a2ee74db14c7bb84388d2ce340b343a1d8afce7da94431bc12a4b6ad2c32171292e7ab403419dd2293944002be7c1dfb4ab4ae742f578684193d93f2002da178dab8ac78a104844f938eb1465785d3b9389a64a48b558cead894d5a60b8b2d7bb3b68aa586f814354d89bf6bc27f31dbb9633fa683439aee889de1060edcb3be4d82085f347017af8c7d88e01a15d37c1b47ae4ef0815a3da75b648a8edf6f559fd7c6c0672ac935a4e971c83c5564664164d28470322332cc5f0a084fc67ad33bfbdf7e246bd43ee471cc79c1467080fd114aab74c9f9032849813b49ba9c9470a58a6da6928cf28d3cf1c234b53d4408ad45e122ccd4ec948963a3e1a36eae7effe7e907ed519a0196f7b2366b444b0b5987ef308d90e7f81421e751b4f242999cfb7b818f8eacdf0f3d4fc6ba7db48e663ca434a4a93cc25f91777c1bdce1cc82f83a67261f10af26620de85f56aae897b3b7c6bd6d0f27f74f6a2e257cdb6c3bfee314db4dd0ec2074c11233adf59ed67dd795bd3da5b37655b064cb073a53c1f26de8da5c694d4108c786cbe008be596c0de4f59435595bc285b5980d9c1356896bb1adf3093f38114586ff83d9b8199560fa111c7f2184a377180698f988798d08fc68e433f9ae15178a397baf31f6877075df20cc8dbbea1e73439c760a1e2abf0c50eb9bf1acea933b62ef10049ce0cfc89ab9e9bda399d883803d02bd68345981e275e2d6ed92acd0655edb66ce973deabaec50da65a521db11edbdfd8b5a9b16c2e442945b50beec8d42c7b0a92970d5c636f3490d8151f1fd8219e73b6226f29937e66420bfcaf0568c732eba01a855de7facabb8f1161bb2df00acdd75955d5caa53587b16bb6a4683e089a72aa4f937062f7ef7bc4aa6d2869b664f6b8b9947935a91da89f49891896317d410f809a6defef769a742481838755f1f8ecf5f7c7c66ff9e33bacfc90378e0de645d05477ee73f6df5b6235b85dc1cab9e337dbf91cd2df1605aef3190e24b6c92db1a462d1966727b60f4a20be6f656dad1fc82baca6731fb86d3ee4bbe859055edb2cf51fce0e017036efeb8140845e2f89246a59111e6956db716e1a93c1170978967c0accfe75ab2bb0d99daeb1619062c63036012fd94e44429cc6966e5570d517bb0dc1e2eecb1f0a0500f575a92419b5a6032d520a851eebdcaf68490445b4ee7b1e4ddfe05d4b9ad7a8659f461eae50b7d7c05872cd594672f41409ced39433c8688ff37bb59bc9b2c20bdfbf2e6a83f4bf029c8e8dea06691089b0afc205b748d290b56251c80f7499d4121d2a981a54ef1e360652d9df18c35fc832aeb7c617842cfeeca4e38f998877bb5a784f6720beaa5f7553d0f9a4c72bacd9ee319350ef3750360b27b319c60a5a206142068e4866a0121e8266c1d7376e87cf3e47570e719b4be0404cf42889e9f2c56fb2dc15217fb12ace58420d4dbd80fb6dba2efeaa75eecc2bb937b3af74bb1ebb0af8ce9c8c19fef1f0376b06eac8ed93c344d2358f1c16aa11a670e46f9ec50cacef40b44d9c7bda80ee892aa5067553dbb2a72bfa38adcb519f85e32b60108291534d3e7ec773164f8e15ad49a0608248858ea05b9f65e95984f2be3437bd25697cf6a1908c2212e5e91c809488d4e87251aad079371df348eb781750a4fa885cb862c9be7d5d91a4206db80725d0d598205f513b918c12ca92c4d146d98decba88381b15b0c990f93690d17be6ef1fc5512ae13eb70a596fcc7156a4dcd475e86635a6d1951edb2d2761c4c4530c63f0ea7a87517fcbbbafbc138282beab7d1e185e3d13c211ae925cb63b62eaaba6cf1337de93ed339669ba0980e730cd79c2acba859b47e6ce86325143109120e833d4ac932416faa2247283237d9871089af6ec730c553103d32d2a00bfe585a4e5c5baaec4412bf20ef6465a09d9fda7e3b8f05fe28d201a13627993d115d12b1d9f75ef879fd0262b92da724f099a610e1b7d54ed48679cab54d3c6bb51373baf72e6f95cea7e397e7b410a8158aa4facdcd0796d2e2cbe9dade70c0e61e32d1ae6dd3424d667799b806a69fdc7d463ed695357df56f6ca41f81cbd842c2241ef176c7e0e06f38b8fc3f8043cefc7a547739ceb8c67a60fedd49e373c72b44315733e3ac6f7873e76f0a4eb68c32c487f775e82418ed0c6b7e79ba89d1b1a28f53a9b6113a73f609fd0b7ac2df5566bd0acbc437a324560f4d077463910da779f90670b64d48e066f66988d5b434aaf71510f8a9f51f469f2b5bf699f63d2df404bc2b54c8444bf2b2d6ce8268b13213711eca7c3e4b36d30da3f7e7a3d54d3b64ba98e5bbba162e22d29d7de1f4bbb8099425a09294a97196ea6a93b35e9f46b4f1d8e8c2aadce2411fee52166e621ae851f201b996c239a5d8f530cb74f5caae231aa0371b3f189c2c86cdc7f867f67cc6143be9737aa51ec97143b08ea6481d1a6823b6bcb3c083619f1fa8fc4cd922eab54fc978f7380f36f8c1b500965ee945f68f8bf273ec8c70b41890bd85fa04d36affd8c1db6555b9fa2aaf0f87ce0319dd34810df7d696b98c2044148007c31907837fe3e904a02860138057999fec244ab06834c1cb506dea90d39f01d5ec815e16b94ddbe390607a780b382608a89b81940fdb4ca1a74127347d290269f04edd606e71a67601a5aa8a4db68f93b4c70e96a6dd8be7621eaf000115ee69d80d17160022c79220176197f4d152a734f0e26cfcda9efab2227cc50539b1e08b40ebf157db8c7ebced6d7a5fcf943af2061bf1729b5575a14c76a23a3359678f4d1d241e90789c0a80e995a7a5564b4d6ba4853dbd3980e9d5ec795098311ccf671bb5666279c241ab73a6dd33e3e409784c5496adbdd5588d9b85e7184fb799952b78352939c48854383bc815b5837178639a3e76591af889fdea65715e6f98b4747831a6c2b75aa0bab5fe1deadedd5e22e244751e77ff687b5a7e0122fc3798935109666cfe25b7b7ff09a0daccfc72cf8ad70e730a8e70adccfb23be2d40c2d71f47b76709071132098bd30b6c9455008fa28f33ae87e4082641ec82e65d91e7426603b99e4aa9fa653e44056092a6a05c89497bd7ef61360d37f84c0bcbacbe0d66bd7ac99717faed6aeeeb0231a2ac7b9e3d1fa2a70af58367ff764dcdad3316b5d0dcd4591e211d3a649079306104094294f96686f5328c567de32092169316b29db7975001f85b41bf7c535e344a5134f2c46a7a72e28bbfc6b989c5da82ba9941faa44adf4117dab8602ea485051026eef1e1042a13fee62ac5e8f1fed666bbb871c27fffa58f4fec4abc747d6795e8595f0ae841b5cdd5b442e3fdea3596c197e9c5e2537ca8e7a713d482f0fdddb744179709621b68aca1655a398085cfadc56295ef3efae930f4ca7dbcf11691cb36d8c0354f2fc58201305ade375b93affe2d7a944eeb507fcdb7f159ca71e4c74368187578dc42fad1791626bde2bd3288a6576a1fc11065022420776a48fb5765ac8d5299f1627f6a9d166c6903735bebd031a9cebeb7eea403b14fe805d5d86a496508d0feb3d91c7acd0b6f1a2421b7b1d2cdf1301c27a9b5890509644733913d8b90d8afc95df0e484899b9e2c246813eae9376899b03407f2c38e907c5b789fbc46d8f8a5a981e949112cabb0fd7778e1c85cd1ed9c3e17294244b0bc121c59ff191c667cb43f60e79131e7f0c0810af9336c491c9b0a981c595ed7332cf833f3d45502ea014257e5679f4c2c55365ffe60051aa3b42a0d14321a6b921dcef6dcb376c0117f627db76e5ecb230a3b15a2da996cbc225e35edcb290603c29381837ad0b08ef2e54ccbfab2e8e0b0eb4f984bb2ed1c26bc62dd4311a7fba1e7678d8c119d86a20f09a3d861df20874e2f4623088628337a7c2d2190e7b91ca5aaa83605eb0b7ad87aea5b103b29c86de305a57193f75048c30f3b0402a282e2332f2738b6f81189ae2b4e36d1ae6e55022826cb579d468436393fddede3b2ef1db212bf712a484b317caaa793df98e7bc1044ade604cbe662ba2e0af0c9955deff77874edaf0171b72c54cbbcabf0787225c0d281009d50086ef4a70bb30ffa79017ba2cf6a41884852996489d76740440feaf467ab7fc7ff8965f7e8c7a97a5e16bd0f9fe9b45d192d7fedf6d92bd2247211632c15e88774a23c54b0a3c55ba3fee5be6439ea413200c5e276f428c7c51181945f8754c6c14bda823fec9b41f1a0936c697be40ff6b0f0b91257128d99566dce94c8c64c48814d8ad45d3b3b1f9e6c0fd20512148d7b27da2d34f09987e22bbb628d3b3252b60ed2c5f4dbd0d7b7114280f9d101605833fc09a5b64c525771cfb52222c1b53aba0b8276e5b52713a3c4f7c4202f63149cb1b3533c7dbcd80e3786cbdf1af034529106bd09f18ab4203e5eb27fb6d1175972eb450abe4a52c26b1aa73deab2b192942aae0ef0cf9a4aa0f1c3901c53b6620e29f52f30bf220fce51c5f0a09efaa2785dac36bdff27232df2d44847b99c20dd6cdd3f33907793f1aac439a164db5fe6d6a7ef3c669d7e9ff9f0aca68609a822bf1b8037962143fd9c4910d376534c3fbf6b94f0c301a896fd9c2b425b950827bff237901c7727551728bce437df776c6a55492cc7b4e56bb8a8d52bbc95cb386bb9073c30b083f14efdb79bb59c2b8367764e43473d6c41d58cd964387574d76624cabe573f97a590cf7fbaeed409d07b21e308ed9928ffb63264a96ac5b71c507ec7ffb2ca874b0578a920b9a4e5291f6e30fc65077961cdd1f7576696870ddabfcf942af4eae0d992bd63950ff0e18b7882202517c8be3c6cae44725d55b771d99d53a846df316630e2daa3065b0e2d61ab64493feadbb92e29364ccf2901835e60634049150c0fdecea95326a625160ca6fbaad806855fa439f011853cf1d0a015c48ca621a48444131d3912c0f5a0f648d901677d5de09075e0e1a991470bab36f6f8918c2ed627c0beda435bd81b47435674bd87ebb04f99e62e74bb2d74a3c1026fd3884a3055922aff4b18be3a951627d2039a99f672b688ebb3a88f1c9d976b01238372f1517df73540d7864b19a2c89a1225d3b1ee52257e7c2e12aec82f5284b433c683c1cf02a56d655f07b646ece5fcfe95acdf428efb48c0e89ee313e244ee1e9c4a69c15b2905dc3ee555357d691b43140c0dbd8e8da5acbbd7fb9f45b27d142684268efdf8529a9073bdca042008da242de4af01c08818f086d079b1f24c5cd6842ada83ecdaeebb870a6069db9dabc42dec1fd515dae535d1da70cd78893f86dd10eb67cd9afa6862db2e5988d3d31be13052143f0474a59ec82b0e956889f6a9532b9bedeec434e0a81f63a3d6645e8630a0416a42b2cd51074bc43ddc259b6e19ed37ad1dd02a886780ed2805984ead91f21148c1aad3944d2a8b6193e8531843bbfc2376019a4c18f05bb41c1dee2f4b916eba72318c4feed464643e495ea8d47feb1f5cac1c5f94103d0a730dd8d25a89fc3e6161cd6c7447f83c66a0ccabc46861243392d456229ed94c491b14b339683dc9bcf7eb40914099f4432e3dc260ebd708f8b3e390f20314102fd53bc4cb228d29aec76276e5ccf0f5cb9a616866895d1c7b428718c03507c4f856ff3c377b7320dc59ad2a34b4a304b87409fc6e8d1a745ce2c65b17c0fb6a5af9e120e0ca9aa69a05b5c84bfffdc7ee5384a7da6100d502f3522a26dd7e78a8e57c872a77242ff6a3ddd4dbb717c31bdf66bdf9131e48738806b8657c4eaa76a6d32b479ea392a1d4938e0a727466bb28ecb7f50de25e2db7aa656a49d081bd914e1ab3d8eec37e0b86721499ad2db4a4b1695f99c087165ee02eb31534b066df1a374a5a0e0feff0b94b2f84ea00ee1f486930ad3172ca86bbcdce2f8b5d1aeee64fbb87afee4d3223763f962172f457d5e09ae47ab6aa19b431804cbb40c67fa75f4cec7c76a30857b8d0861d903baf58b57c7fc09f47221fe30f86d53b571a3586680f446095a6dcb16225909648e8fe60f19b4cf0da1ad377d83878da9a2b81f07d0d040ef011dd6d2323ce903231b9919aca3546b0c1777c2393eb05f01bc5ecf4001fc96c1c8f06326b51d39344d3b539b5b6bf2ef625729358960a7b930843eaf69b8fd057fa65249c97f4d8f3001658e5cf0aa1e43588527ae8b7740fb84756e379c1e4d96b92f0600880a5322b678840c55b8848d515f1a92a6d2099b0a9649580a21839729415ccc1da0d4f77b1195d183a217c8a8dd10b5fa8b0b36d35fd8b055b410f814369ea22ad6f2282b53a55b49f17939e821b05a91c954fa7d024f60aacf4cfef9b6e73df3c0db9e57d735fb48c78d9029581fc5c4d24e3456c39936347c43f805c43f94edcc0d915f641b9a21cd8123a58d65bcc99dd5ab1af74fb0e1c9360a2c019e36d93db7338d7552a0498825db351ae31a49edaede36db3fedd4e704bf9c20d3b61ae8222b30f47397edd45d38b9fd414cde1420230bfd5d74dec4f8501981afabe13b45847c2f936a587ec8774e228376e602eb7d828c76edcd142c6c3c30b2ef6e0df1b4c82ba0bf218405db84b00ec80bdafe6fba4c6df7f64946afda4d5d6672b880d30562b41d4bcb52d26b654d0be01d61086d0e228088a23ad05406a2f370448c91b1e8bd9f98c634418ac25b7ef34c756345f24d3f5cc4357cc7aa3bc3d3537dc72eb389e22ea661f2c9973ac5934c7ea0a63226a82c30c2052262d654e43f976aa24e62638c032dab4371e9657db65fb10f11731736f578d07419f7fb70018d89a4c1a4a54d108756b6ffc8f6620b4d8bcdaf13dfbdcf163938491635dc7a995752e8c1b4ac4449fa914a336a5cabc619ad759ed7c677518cc98e8e323549d2a6589b66f888bbf46538fb0f5736a39e1ed7c91833c8e7cfe71be892b89f3b8965ca75314cbd2cf20f3a63cbff372be4abde7c7714d1d541aaba3c10a198f0e3717749ef3970a9efbedafefc0b7e7f90f55cf7135265c2c9118eec6dd6cc0fd6b9968c745f2fcc0b5064af0be80ea79cbef272ff44533a181656e3dc26776474c36262e7d6514ebebb6687e1033c86bfaccfd5d26d1d2b9767906ee64c7a6d2c00a3685d0915a5f31f4dffd0ac82addd3d9b93157c62a7ba9c4dd45b11079d9fc4be9e17c378841ca6645ab11e191fdb42be438e148fe1547d52c4487c842d6421efc01c4a8a8049280850f6665c00acc733e0efad30c2cc2bbef805fbb5705eaeadc7ff72d7f304950353186c41e325476567b073a3afd26475344cdabfc76255333ea7e888c5992e7513b31db12bee7c137e69144e24f45726720be03947d051f225887b9f6abcd066ad570fba90532c83307cf953bc8537a427792b184779b85a66454b58b8520c7d5a540e6ccaa04a74758b0a512764fe60915a0f917495cafa3d66db426d1582270b1490ffe648b2bdb7c0cf2117544faa1bfd5a7daabd1877dc5077bdf9aaafc82d96a5dca09fe9ac1122dba9be7867e24eebda58dba05c2cec8c4275462adcfe2f00aa0148e714abc26e4725da340a0c4397f9e9817b1a442c9c55845916e4135cf1d46fdd52f53141db2522322a7c5bae0ccb784ef595a95a2c35794e5a3c5c2e0db0e8b12bd7a9b2be6c7eaeb78a5a3b5dfe742d5c1e1569020d7ac25373a2888209bb2f45a1784460ffea9ef78c564d3cc53c1a416e9126489fc3c0b635c7945cf11122bed11f1e31245affb53c9f1286200806c2a40d120e7edf9835426d67b9a14ecf2bd8cd42c0d90a70a61d99c866537a8d6fece9d6d7eaf4726034f9daaf697e95c6591c557ededc565624d3fedbb76908011b6c5c5d7e6178e9300d28121e3cc5a7e59f6dc61ff749f5ae92c9f051c4f6b1f516eaded95b4f8a6693d8d1dc67dda38852a00461672f376f81e2eb468f6857702986b7463995e0f08c3ad3f046bac4fe995831c37050f5297fc3dc197daffa9bf8977a17f8d58ad11bdcdf302797e52d75a5fe4398b2abd38c8db21f08c9aa4b61b67d071f9cd120f5f2b5f830bdb7113c899d2b3c904540a1e859aec27fc57a93aa589233ccf5d97f1afed5160305da6914e29ad23940048e8f57d8cd9ca3085fcb2ed4ef256af5059ee9da9fb620008d3b824fbc2a0c072d0379c6a849cc4a2dc8a660d1d274c55aea0e9cea6c2fafe2c51afbdad9b23cc0e186429b9bd5f6f0a2517f096d2c5023ce604009695ac1f3a931682ddd067088462ac15c51189dc6c939403f067e2762935fefaf7df7dfc40b28daf582c8bff785c173e9324c0ff19512ee4ef0e83aa39f0c0c278def314c70d174c5ac19ded98a4f6091ccbf08f2dca6fc4b96aea611a815f67bb58842b6ccaf71f3fb7ad96287b530549d8decbb9d9ed48db1c3a0a9cf36d7cc9b94151506e4ed5181fb970218d17b6b2fe9288441d7fb91dbc541ab3f9d50cee1ac8eea7cd00103ebca5f9f8ad1620bfc5a4de33159e0816189e9640f5197b25e6db514f0b95bd54b9e1487de9893f16a888cda90f40f28f504e773df122386800430942a3773094461408b1c85847d21e46fb3243f525f9ff1612dc574975d5d3488f579cb6ff74ac63d01ccca89e9dc919c74721587924ca5e377c8fcabda62cd2cad3473763669a078913831fa4d375f2bb67750988add2593c3e769ee0123c29318ce547bd6ce533b077cb489032bedf150972b3f00e003dd1aebe103133f9c6bc48732bfb1563a85ad3cb45c8f13f4717eb1db99cb3306a943792c1b039705c0ca1b8ec03fefc65ab0b2eb104e638d93d96c3ee89760675cae20a22dbacb7f2b6e962a106a75d4acf46fa96cf2977cec8e5cea9653ebf1e8735d8143acabb5c7cbdce43cc66e3dc64e4b8d742aa5468e672dc4be7866b205729d5541ef25250eca76bd8a6674dcdac05e563adf96fd3bf1e38c39dd1398809bdacbf2580dd10817ed3a5bb123539eebdde0d159bbcd77554edbf3f1c102cd719b130315e3aca24a34414890e0f90e7b7f731637b73d4dab50d58f29f05d2c194c378976d71278541da85cc15bf1139dc972b070811a5224215bbf4947f413b6fd206870b69dce1b2023dd128a9442b2252296b4a150af8b5082f5b5181c7e042d7dbf88f54939e51df6bd99493314b4955cbc004b67e63be195339b7536697c2b6b751c316e5ec0d0695130479983d635d287f4bbd8571c9e6e75a4f15da7a0f7d4f4caf2776dc5547291e53a2a03027231c5aebebf05b76e77988bef2149173e7219c2d978f79a7ecaa1277a2e6898f1a8ccd3ddb8f9d0eb39b350ae85fcfebd4e801a1fa0e08fa30daddfb7350e489b19539b35bfcfb8314d8f3e0063908e2b0a668fd5313bb05b726ff28a97b08acfe9d449ec610fab4cf3ee5158c4b7f4d2fd3edb9660db47f7e10fc5c3ed3a14bf848054cdd1f6f7f1b3c04b7b041e4385c8efdbdb0d9504049a8062ec271b7dbb17c84a39b47ccfce2823eb24a8c213aee32ae5edb854c865ab459cf2df245bd75f13aa011b8d1dd0e32a938bc424c74fbfb586471c2b951ffb140f67ba956153b1bb4797ea5625158fd26899de9981073406fc3ed3a56617b4a53ef525786a0686d758d930925c94e24665e31494eec8686ac2ccc85e0650767069658e42ded7f90969cb2dc6e609ef2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
