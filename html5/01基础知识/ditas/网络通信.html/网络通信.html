<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8562f6dafaf54277eb9dc3f843a90d5672568714db2e74bf73d46c2ca48cc5afe3937ac1941bc50183c0502fcb8219d05d39666850e0448a5a611ebe595611da60e092b45b236ba40af802e8ceaad4feb9ddb0b84a4aba00eaf0c9219d070de62d0fac9d2a91c7c1c7fb47d22b7ba5f05732c21cebd29f1b3beaebfb82b7d3d1df7f8d7d3f23751577fae16a43d8106686c8e228993eeca5e014b91862e2d80649bc55cdab80a377ff66c64bbd3a90faaa69a0925edf71e5750b9162fde27fef0f89504d9a69691b235527aef4e40b74a4cc53f4aca13ca38584c5877a9613008d5f1bd60e6a4ade772f3978644f227e327d8365fb8689cfcd572dc52060dbe9e3512d325c56829282f94072886041e91020834a7587c248538d3a4f948f69b929899a5f8aa443f4dc8c45238bc7db866d8b14099824866a1a28204a68e8fa6d757d7a812eed6b96587b12baa3e8b1bebfc9f4faf2b9945e2c0ac59a8c99a1fa85ea0e68f84fbd18ca4ad0cfef25539cc375228634ecc475a62e509e0ee57e1c9edc4e637ff21430487ab23c192457dfc4b71a1d21a7529992879dd2b4d09de3f20e8333e445fa6213b092f280d909d7ef3129bdbab67a0db7b2e3b95d901de6e33e01fd1cd7349dc3948be6ec9507245b700459a9704d0a413b8799e4f21f1fe4f88fdc3d8c4dd3e6afa50e0794c768b3f02c795966919d1687eea8c7eaf103d7b95cf403ed6f1fd3eaa2ae2e403fd4c04104b000369068e4598c61582fd1ceefe4c5ac2cb3751be8252538acd930453d6cbad55597a49f29f1ce5506d32ac3d197b08f5e83cbacd48fe9cfdd662fa8b37e7df6592bc0bbfff7935f1d44c1d651f19b9cf9b7b19ed980bf28aa1d0a2014bf97e237241b9b588e51e0326e9244bb9da03971ffb73e8a771c2ac245e7438cd0772af1f471343c5b3df94402dbf8b6ecdd6f0338dc5bdd2e2d0b2a141b2d7a88fd2a92615e9b7e25ebc45833a46f96f7d90de40d4ae6c0ebf6393ec34eea0f41a7f0180ab59f27d9482148e49842a0a077cbc5b79d6da30675ae7f3f751c8bca87fe91b7d9670df0ce6ee432569b0ec48a593851f1cfae285a0a17d63eb8b0f37fcc45be6469a90544d6c02225958a11c1ec93891f2fd996efb4a080c2a1b52ebc0544e81498231f5417d09736a8edbd1163ad60abc2503fdc8244734ea97feea9ee44f6e68d07d7c9c661cbec05c0cafc1d03fe8d15f141f9e443f1dfad3b8ea5f4e755d26fa1d912ec839e915f8fa7716247359762d011b9597f3d4866606e2b46d04d12f0c89718ef8e71ef0834ae97472b0038901541a7850a67ffdc7dd6faa9288a81ca5192be872d6a3be0cbbedf4009bd303885006f1c262ca24483980f842c2562481f2f2b2f3395b3a966f8851dd6dc664ce27f4dac524679fbe3239eab7fa5c38609e0c422532e8751c485f82ddf970cfba66435741faf46b638522c361e0481e7836fa64eb9f979f6cc4d94e3028800862fe8a2c8a68ad46ced588a8283f52cf78bf7bccac1bba51e4417cae6cbcbbfa7025d4f838d2b50fd63124f9b0ddbf0c55bd28e9b70bed378e86c96a6db00676021dce29b10e8eb11fe024ba49e3a26d2e4eab9e5f3aea51fe6283f37cf9a1f1504ddbe7d1b12f92c4d73da7253e8b8bbd7a81cde5e299d00ac2e0f8a6957cd6f1bb3898096a74be94d6d3b28fd3ba6f885ad8d4da9f1cd5c7ae8b895ac1a7a8fbb3365b265d632abc1b1cc6f75d3bea6c209bdaf7cbfab1e18604095c8df19fcf7da41d6d6f1689b61f97ad352affa2ebc4d42f4a3906bb304f0bcc35eb1254d6f5805c5ae5f484c08fe0f371ca56efd39bb328a87d3eb700fe8b43a2346c001f7c45df11aeb5e88572c59b1c2c8e36e3f19ef8758d1123dc6453aebbcc1a41478da90444e0a794f9b3786d430dd9a5b7eb6dcf59cb1a0035cccc6146a1e4e5b1ea5b8e151eebe2797db1aed71dd2a9f8dc67336f9c7b2c4305c14b1bf6e08626d6ceac45683920fccb066a0b7dad125871e2bb6344fe63a4a54932403dbeb160381be3b485563317b5e8813ed966d9302d8c033fd61e5c9668f5ebc72d796ccdf38a13b93c6fcb0ad69250c110dd2827289cb272de3f99294e4f22f576481747a419e3b4bac773f5d2048752c94b3caab43c869859e2991dc0161123c6f879bdaa275c51056f55acb6d982322093573434f34fe729c17758593d1b3ecf5c570413ba8f88f5d493cad4c31988513ff2e1ad7c638e7cca3f37bd6ebd03a289bab76851183a66118b08b58b1c5d941f6a7406f32639b9f5567a46355cdb1894811a20964c226c4e2018581f1f56e701d5a9678748e026a29de58665b8a45319fa94623f1ac636378563bff727e74ee0e72d8023a81afe1104bec6f0951dfd42958e528bba5c5e87bbcf6a05eebe9e9af46069c01b8a4d7e89048b92fba8333cc8abdf1b6e34e62432366734f6f72a69a007a976c1cb0af20032a57fce2c94ae9468cfcf12d4cbc734af0a67a7e93d003cca096f18ffb987a137285817635c6375ba11b0919994576b31090d76dc87ec3ef5812a69252c3b1e556c7d3d3ef40a098d77b5772a2d0b6e1602b52d98881039c89e711da6292f157784f3f3afa7c149899560e9f20b0410ad96c80f4e7d30fbfa6f7ac111d39b421ca357a652fdaeb112c43edf4e414d8eec8969c1c4fadf6f53e3fb2cb99b2cb2ccfef53bc3804b601aff38e48290aab57dd3e163bb0e32cf9701ae6f4f9e5ff3b1b444dd9e6ecfebc9a900f544e5c055568cacd292c2b1484af95057541c6d6c49f6062b92f3e7d6a64ae86c0061636959d2455dd92a653e4c2141879e1fca9dfa5548d236d5864b41af1dbd37ff0688b13a9a2cff51524c40341c10c4ee67bf96f82b73cd6fbd02d1e1351a478cb6c543e6f7955881bd44a1a366bde9c634d2433fdfb1dcf90362a81200bd30f2a835cd5a9398f3bd5a076ed3708f455f1a1e4d1413e28f7b5ce89adfbfb3a355ad80bf278fbaf6a850a3439f1a0caf0bb99eb09a3fff37a3487c9173bde2dd257549138ee0f6459304baef0c978e23966174ab73cabe9c50614dee10a3f599941f2f07088d6898fae869af9631ccabef0a3be1f7e138f63f27165bdd98fa95f85a384ee826b7d0842318f31857429dc757c579be73dbc11d0deb47749f9194797d97b783b77ac4b3da41afe0a1e332317668e33560b4885d1eeaeac1723b13e567aef928c155583f5f7cb19b58d1cc276874d1fa01bed0d476d8dc6e2bd6282725258509165773df605f8b50c344485edd4fc332b128e197ee42aa3dae379c25909c00ab3dbb7cf41ae3ad605e76731c72cf9f6f6a9782fa5678e9581a05026daffaa4fda24a8c7220f02698c417baf6c42fb68f291b8be82108be3ff14fcba3572fbc13ee62b7efe7a3213fb516e69aa0a1789529ed626d1575e22e486254179778f212ae4ca072f12fe9f17e2a516450428ae21d800d9a5fbcc267ce0fa56f1cda3bd5e4d62e394ed5549bdd2f5925304f61cf2bd96a71e15d3317e24af79e498aad3784e2898f5f965776c706e63be728a3a7f99bcc993a5c4b6eb5e9a85b9d30f0e1b05e004c92010f86b827da56680d965031447a61642f834718adc6285bac1d69ece8981c86c85343789790ab2334ffe4b247a6b5bbca86981f4ba9898ffb7cff54bfd367b56a79fb947a427fe3624c8df30b6269d996dfaa2ac2afd99f452e5166ac718204fa4c5ec38880b402fa191191667741b1db0e7022e56cf900bffbe4badb14e1c19d92405eef17fc7e7bfa6a1bb77458ff8dadd1a53a7aedcacd2e336a213a80cc4204a99c1c408f96d25831f302d9a81e65565402bb6e421fa002a60f84f8471567edec4b958c301a73a827c6b948475cbe3c4697d2cd82ca7b04abe9a7a49b06f945f1f76ebd9bff48c59e200489ce9255ab75eb734555c986bcde561fe11bb3def7f0fb5f265e0eee381df317d987492ed256fa4c64c39031e3821775f3a45e1070d30f2d91862057d2c6b5a687e5d93517d3790ffdca73f0a494c8832f816e4d28ef546654c658a305989638dba6e9f273c489b35f88a76cefe25ca2be54f5c3081e5746f840f019a056b3fcad7926e41b49318f589ca5377fcb89d2643ff7a654341d71e6fad0a8c5959ff17a65eb9bcc075111b8135430687b216787371c7516c4459e07475ca18bd54af3113ff1b063843d61a971f5ed6b54e76b27ad00d53ef8e85d99246e6cb721ceff5956027dbf7e3846dc6af0c48c04799b160cc3aff2b275b4aab7cc21d8848c10e3df9ad7134548c63f4248b579196bea668d372398a1b4582f85316925e3f962ffc09e893b08a3c20ee9eb46bb24b1924e552d3ef3eccb08a428b446bbb8c0e95b46010687e36be841cf8e939f8cb74d95d0160cd3e997fba95d80348ac83bd7734bf4494b214d64d3abce0f9441cb6de5eef27f5869a9591e79e56d329e31a07959e68e0a03563358dc36cd4989972d22930c816a28b67075def480e5a9f7a81165d7625d33ba184c3963fe524a3005334831fd99a5ee246e5cf8106dfd71d5801d9ac9f6f68c5cbcb61f54806cda62f3ca7c49c7ccce02da24270165e49e326aaef088191150f8d26bc3a350eebc160d1192ad877d847243c52e7c6f27c4187381b6958af3837670f3b293d8c6cf6a95d0abe7505d5fe093f8ca5275355bb7501a17df5b11dffb558192933a635ab05b218138bceef647dfaa2cb4c344a849624b1e62283a68d7125d59e36802355e9a17977a65975827e8a290941e4aa561d551652961b4cd6075d337b507c52012cdf3ab2c26d6a7cf8db03094d688f561a8e7c91213684251d700d064201e7e7607833d992e7472a08dd35bee942c66b23f7a3a5445b94dfdbf4f9c9e15eaf7f7822cf5bb9d7192ef3a55a49caa28fac0fdbdf14f00e0c761d26c30ad6cf1f28b77950148ef477d2002560b812fce86805cb7d4987b1cee81c6d8774ac1f49233aa6c510543658b334bd9da120c3d2e0b74574b01811587bbb58fb1a915b9f79677a7b16da829e770cdf1bfc9ed399eb8c585359e6143f692bdfe5cef027c893596afc103800a90c7f37d17db61db7b80b122fcbf79595e141c38a710cc0358a018991d2ff630e3b1692292c239fffc5f188a3e50da237f82072245261617b50870bffe3ef5fd3b62d8175448eb399f555a469cfd37856bdc08e5bc440ad5be7a7ca78fa526eec959832cca980f0f0c10f4b3869f8bd31a2217d3c141198a0fdbcf80711c626a041014731f5f4ce7beda7e2d8a635b52f9754e403dc201113b08cee031188c9ccd87d623e96005cc4733efb50e5f7f053f8adbb42d4052deb7446d3a1b64675735d4facbcbe43732aa94d06a46b11f7554b9284fc49ac129d6d84f2d3483d43407866021ba56d3b9342e0bb5ffca17e4dddec73a3273171e34ef298ca6001619c5d9bf0452a3b0f76ad852068c24042444a085dc0c8866ea30376e91d516a7e6abbf8d77c66d301c4346a04cdd6165b37f1ca961f27fa99c206c77a219d2e177c422d87e21e35bd5c6ab07514da7821fb42b36e8810acfc5922c6faec5111e471b5b872004e1a85d2f9bdb6b810c1ec07e37aa0913bbe2c891bfcb4f33e68287f1dabb746145e090fefde493ee65f4e4c571e47b1b1a3fde88803ace6f5e2d50914ec5d73afc7871c5aa05c59c9330b716ae20984e3fc0ba738c72ab68f0685d644bda24d4e87a744a9ab57cb1e5ef42de349d7eb54e3ae147a323444551e3ef4383725518627d3a5beac83981a851ce93b68e41b11ef5790067ab68e36bdd53e1f53bdc09f40aadf955d7dd3c8fe3034d78c10375c8e5a38074b637f4a6b4e36e36469660f46958fb553d715bd035b8f64a8c5decc4610554239b18cd2ed6df02d8c430f0e03ae3db56ec62addfe5855a46ba5942e2c49a0109f59f5894137ab7ecd99e565a240aa5efb9c6e5f5421b624913d54b08bff0f73bfdd817c3f0cb9bac70d7e37590f319d54feccbc6cd6c6858b5e7aa59ff7e3c36dcc963d32549c77c3d8bc6cef5ad2cfcf65a2acff9352df314f5ecfbfec5187bad92f53cc23e14ce565d558a49f5614b47ba897b8e4bddb65571f90211263f9a1f46c55b3f6edf8c0d0b2e163206672c70fd3627f1984665c031c741cf95008b6bf208f0b5381c23eab274870c624696d78ec923923d3ed266621ffb36293f25365037b74a79cdfeb1ff814cc7088b9941587c39236ec2658aa73fecfec7eda1e9f0897c2640b880f744eddb9f39828e3ddfcdcc3e90a8a436f1b1b3feb2723e14014b1af775c5a94a681d7e7da65af73629b134a30c9fc6f3990bb918ba4e752ea174d5b81512e1f51204f5fb7a24c0af6041606f003327c8e9eec0cc0e6b1b935db6ec05d575e4a054190d9e28329d787cf3fb8351efb2f386fc4c4292e66df2690e96193f1feb36ec3d53a3bc770cab95f28510601af5014979b9528883a05d7dcc6db85459e5c65c6b8009ac7615ac8332631901a12abd3f7d926279edb1b095ce0419016ca74a05b4c7c6e257c336a61b0706c23b4a211c3bbb7eb1cf48af03e68a39e1827f17a9aea6b5fdf5b98bc6d7438281885216d3b749c35c35a5b53f4a79b875a823c3b025ee78819b15c7f9e555307c7a81c225eae611fd224b94ab41f1c5bee714799237b9a9d5402f02c95afa0fd55791e36aaa6c1a4f5f7ffe5ef95135b2c4830fb036b91544750d2732150793a09955d198e6aa7911aee566d6a1fee75c7d6841d7dc6d6056710e54ead35d2d86d6f21029c45472d5a86399cc7d18c37dadcc7ea0f3fdd2dd96039552d2d7e4546ece4315f170d059270690ef824657aba070fe28c98b424f2d85de61cffd1c1f959777466d4b006e1080da3b57cf62f8b7198558ee5829165505424b5941d6bee09ee4800b4dacc5e85382d23b0523835a3f7ed658ae685ca00252636641603ad6897af9566e6038e7d8fec4034a5775c8fb55c54e2edc8b0821dd25f6479ebc4a09f4d308c722cd5eece10e2a6efef73a05dbec05f292bb2a7c375b8872a6f96ebe2fd39132410d264f3f382762abb35bd283b3e1332979d2d5efad02c27dc4d40c81f78b8c201c1a4dc8871d203f0e1a2abfbb819d3d630adb733d2a034cada26516584306755d3c476a7e80b82aa184dfea50e17ea3b7e2020463174b2a588ea62d198853417377760eb2d7dc8401532148aee09c7d35f03cca5149582edbf892beb481cbd2eaf596f6456669c7ffd226fd450460b118f89b35aef6d13fff492ed00134eafe325a804474acb8fa37559bc0af417bcf859d90d1ef881b74bfeaa1095c3d822d15d8eb67ee48bfa10f7d2748068b1f5744de5444255373e9d934604311a04e53f21e3ae72f776dbfedc09390b35652db2997b5c52ff19921cf6489f6cc70c2c8ff2f3167302238d049d60a4537c47933763c8a6ef6faf773899237eb824d521c6d6efbc46399d2d62b095b43bd36908d856388c1a6ce008abc98b16c3360093b97f45bdb21ee7a6cc9f022b3e0285ccc4e0ee1f0cd6374ed343c049e074fdce6806ef1f780e0d463fdb42f00cff1067d6ff4367d4d87d34e33e50bcd8a989af087825624ffea247a8e36c87ef3a870d3a91a135434b2217d4e300a914aa8d9d74a3b0cc7d297fd3b16a8ca7b07737489944405a278266d5227c0c425100c065bbc002a1ff5448fb6d6cf4a6a9f64d5efcfc262701b6cd2b2f931db6b07cf25bc4277dea8cdc742e326a035fc6f144173856d202d031426f9269266dc42e74c25b22516c8cce939ae2a1526727c6364e28a4321f6d1f3954f1f36c8f9b0e4d6bdbdef8d4359e5f8e3da9b71977419aa6791757892c988c5e796fb089642202f27c1294d0da638e6bbda456ac61f50ba20189167a1d51b4f86c52895f8e539aa761ce3a0562e1f73d26b2228459101edc6a232f6ce676f2d58e06d42e1eaede63a90a7a84c27540d9cf2088abc007ccedbcb82ffbee25e69bc72bfc7764a6a759d4ad6d58d9c684ec7fafc8af9de624780e3e2a97ad856e0d2226ac2695f7b794caffedd19cdd6f48405ede289751cb8c322746253c01e21929ec0469d0806138cb66e7b868e6c9bc7ed83d13cca954d19d8151b68ef2a16882273d76f51bd4c0df5721d5e3ef7d893ee0bbc6fc1d8ff771972d60f74eb0ce7b1a0670334174d41e3164eba193f32d47a4e51e6f0624353d98b064889e2dd10b394debd960ed19e40cdb3b6c4a643c11e3c0538225413dd278cf2b4fc6a98d5e1545da25b1627f17f740a933a3aa9f3f96fbc8d142f5ee5b7c766abefe58e93aaeae65fa6f3e27506985d5dfb8ca692bc5befb8616aa48047d55ac4a75522c17b18875de866f3b29e624182cb0424c827d6563bd82444b12ec1c6919be12ee873991b2dca12ac3177328994f735e38d2c2c202f1784c9b98efe2bdb07b8dfafba533f23bcfc21a83276871a089acde26fb5f5c12f1378e995f96278318a5d94b8084c9abbf512fa15439811a464b78378c223c61db9d17367b7166ff166eb82bacc84d3f3a60e3b2c1ebdbf917ff88e2a47c55cae0ddf177861005999a3431abc1c6e040cb75f06ded287927c95c03c0e78acb878f0921d3c92a309c4db7b95c2a86b962bbdf9acf00d8c975c82407ff6ba471fdc0e9f9442d94214bb44c4522fa7233a104e5bb3e53dd35274c19ca0b616fb94e265867333ab6377b3c9faac08c2b63b2f7d91ce15d2516977bdfd398ca246f1068c45f3e13bf93ba686618af5ab866a2871b1a3109c3374f307903bc444b3b72dd06ea02fae7cb658ab68f15546ecfcc41b95a02f574e8bb12173600f50a43adf29407a0718b3d35e4e76fdff4d9f68473b285b2f0aa9d4135781ab8147176b12fe46092b351c24ce56304324d30f7faa38e36c28ac7bae979d12ccde236435ab0f9a436e5df3fafa5f5e8664ee85d3544702e031b78f1d7bc6d98921df40415d2fd56ebea60bfa5073cdc6cfc0a7abafef342230b6fd37f18959d83e4f9786e600bd995453df98ff8a290d7444df038425dbfda4620d8395b316adf468659a2be63c525b761c5f689609bc06622200a23eb41240fa57916f4ec5588e2a3d37af98077db42d75f0dc0d96fe8147cb4c158b260bbfff4f765f6b3ee81dec9bc9d19b418d2430cb583921f69093e4d2402b6ee9b5d135a4027b0f87b038918500849d240fd2a033c1fa4b9a0db7f2184b223f1db98ab15092301cd870b175a5beb9bc670e29757406b6a4f43dbea7bf4820dc014fdcee5750f2bb040a7049af9cb2ee6bb52f1f0cba62d5278e17b8949f5858ec4f27932d33122ff5226bd5074c5879ec624ff144c66c4e21d8bf7406d550d33ee42cbf81d28f88cdd1455e7cd6eb0ef4fb0b30abd76e05c3c76664b8aecfa5f1e39e1d9bc73100c0b9692ff2676ee06a6ae36d642392d5e272591add78c909045f3c7815b04da90f1862c58aadf4f06b144a731703b27383276763ca12507530ebdc7edd6b8cff8f1b16251c943ca264d3c291c3621f634082345e2af8eb5b98b8ad467cbdc9c5edf2a3db252bc7d918d6ac4f35d514c395f7ed758566d1046541fdbdbc5d47672a8444a3573108c423f4c8b3a316e0b6139f6245a72397b983ea37d3eea25ea089dd95003533c5ae9af78a52f6b71c5e70fd20767ad40c14ca3d140bf8a2e8d83fc15012cd6a1006acaafc256683052dd5bfd6d18655d7b402f7c7d8196437c4c766eead8f540fa6ab215952353f9ad0469302af166a8e927ecd110d420ce76e17b31b8570425ecdd74ffadfca42ddc5c13fc1ddf0cb7d7ae9362797380880a1de88193de042f9d1a8d04dcdb025d88a28d8bd87cfce3523ba37661af635b9ebbca9bf18016f1d328b31ea91553ff6043898ad67edf5d9a6f9a95f835d5f365290d201c6c19bb2754843cd9beada2cb47ab43c642b89f058b47cf444fae763fa0523fb18b26bd57c438fbaea094a9cb229c218328ca60717c8b9859cff42af43904d8b516f7b1982c12dd2b37ad181c6e37742ed1f570125530d27025ebe9cac7be90dbee5ed629d7617638481f6c8188529fb7b087cd4990bfd8dfd3e2411307db472b85926f3a3c593ce6e65031f6bb1a2d44091078a8f2d4f2603b11a5b6aa7a7537493918f83b896b9aea1eb3f8759a9b7364b923289f6d05d8eb777254662d82489b29c419177b84efa7dd3d96bc69c0cbc54394aa1795f30d6d25084f173267cb2b0414e311b2f448b4851fd262b451cc46bf3728e4f824748247ec419c27adcf2d04bcafb55d3f2064fe9926a540733727b77dba67bb4c0f749d39ee27f687c12ce5007c9dcd161824003fbe32940cf993095345eb72bfb6841157297334aec1b47ff815d1fb9fd9bcfdb729476c9eab50ea537158efd518a8825b766112cee42a495b7544393dc201ac50804c1e83e90a00e833be2f7126d7f56815f095b7cc134c3ed08449589ca8d02b8909685ff9cc69fa422e4bd4064b2442632fbf405bf6bb42ef12657569635b515ca5f3f49f99803f771ecfd75d6f5852a0af8efc2bbbbee073ecaa73937aedec3fd2d00791c7eec44e1041632076b8abe0303ab35e3d38af9ba99bdb2df2a412dd39690cdc6b5190e2c3296a559e379c951d25a358a81de0ce98ef39ddf6cb3adc353917bcc97d74c6e7308f94f0213b5323c0ecdbb7c69e33584f2a3eefc1dca64c75b730f3f9cbb213172c8ba3310a48a6def0b9b99cbaa9145bc215ebbd7504add56fe68f713015b08060f51a08008f7851f5f2b7fc4c812791221289dd30f4989c837a87d4b76802d5d76124f72693705732a514b016fdf708aaada4d6bf175d697c8be42ffead8f0d4300829c0f4c0b051dae1d06e7a04304896a7fdc885a5d6735d618d9be6a3fd08b5f4b33e497f34606e593f78bf8f629c89d7e2dbbbde71767460614213dcd37cd259ae967271a8f125571bfb4955acbdd1c928ec2bc760e5ee1c1d0fc79306125896ba2dde57811938a5027c5bcf4286a8317869004a8f26b1b8005db3f7c9dbbf3cedf56a579382cc9995696f73f98b2d7e60f0c18d594fef1baa721a466304de69282c10f455761e087b08efb1dc87a707143dd7bf7a89232c7bc59b375180aabc967d9b36d8a286ba9ac38ad5c0b14270608d2125fe13b98e0f4ee44e6e8e29b95636299671fdf5cac1cb27a1acf594aa6d7d6e42afe23814e4da25ccc15d11910f96997ff292a9f675eda88c8be6eaa20be8c249c583cfabc4c0da0e8c8204bb6284031501872306e8c51b1ca142cee118d04e37829aac57cd099642f441e625ebddae1d189eab3d112a9e295a91797082507716236f4612beb445083c39ce8d801431d6adf3a1e7bb440a9bc08698cdf6abdf3f841c43341fd462515b66056dbc2ee345cd92c3615dcfd8e3878ab4ca4468469b8964744b5c9befadbffafd6ec33e212b247f6a74e134c79b0d6b85271d90e48fd2ff7597739634c363216e7d71b1baff6d12799e39a108a57f7343c4923f5ad9cf051bad55cdf07087cd5fe8849f0142ab36eede50b56bf917711482553260b2c567f45d8fad7bda745ea5653162945c3e89cdf4ed3872b44afada44053cd27e18c58e05a545079a7efcd9c47985c09113b8bf0a3db9c09308730649dd83d59118f7d254f866343e76a77a58338b84670fcdbd2d0a50935bddb411f6476ed5a7785e46314dfa87e9429b58396ef71a92444f799aec1e9e42c3aab94a4db39b8dd000c4dc2d61ad4fc498d2fd47adf3bb1bb079ca5b698eef52e89acca23a2e45f15f60b720a3631e8e473bc6f37a1abe96d2d862033c994a3223a56f820406535785bc5f43a7a667fe065a1f02301f7ac6dad0e52dd16bbe6297421d4620fc8a15a24a20453d2b6c723cf09b6421a355a78b9f911aa1550f189742c91e7bf96f8604e205d352e242f0844b3bce468e1dd02713dde988894b8109ba219192e3f3b8fcb1f2305edf76fd2e40531a533706bfd861b75039b77ee0abf4e9ebab35bac3cb01e025e00dcd5c15309add37515fe30aa6b7145d8ada35759dc358f09747014f24938102f40998ae6440cea98cf586e944a9c00c0167b073ebccd8c3b1e25f0c81af4324e64c0357dbb4bc551e09faf93965e3650f1f6889c5110e5fd5aba835024664230997134d6baa58ef6671f54330ac2f1c554f5d151142a608c7c8124ec3ba6346b871f5cd79a08584d47f617244d0ed5fa3d041f3f0504e162be98602c33c93936c8e9dc855e38ac3b57896840839ba862323fbc93724a458057d64610998225ac945a53de151c9c7a34de7b2c9f5e400294f719dd38ff3d85d69d7da5e02dcd7e2bd874907d3609210c61f63bd130f2125c7c171e5a1d163d9870ba0cf62faa3da33cc5e1a90fa706e55e05b823a4a4a5e93608ef1355fbcb73e0c0551b353805a19cca266669904092f69cdc02b190b96a79b4d1ac3890398ce100aab780e9b00ce170087f874261b33e7a65bb3545bdf7fbb3e8f2febb346607214b1d218f2440157f5c2c47e58de1b08af4a9718126b15c242d5c73ba2200e29ec2106cf0e2626a790a560cf60357f073483bc7a5b00b03574c27ef1a13aee2b77431a4a469116741214030d2b42d2f14154cd0efb11fe2ae4899ead2d76d40a0a81a74c1c2a2d03c30ba4a12d10996bd86a1a84ee3805fe048ab7842a0fcfdb0228894eedbb1468058f00267a3dcb0f1a45f73eb5ac3e731e56b32a45798741c39e442166ab8fa1af59004e12c85a0b8192cbe840bedb7b550333a7471207e25fff0217585c82a89202d9e652655755121e8bbeeff05e7164a1b5bfc139cf168c212cedd102b0af4741c68a5a25ab192c9b7270eeb2893210640c2dfe42080ad468eefcf7b3d3bdb35f9c31a865e1f3c72088b45ad56c62b9e0f32ee300411fc26229b93ef83fce63193a2d1802b26c886a1c0ccb023d8f1768a5fb3e6bd6bb64b4480ef4ddfee70200a980a936a2ac28450a57d10c22c1c6971eb2298d5040779bfeb35c05c130cbdfc91c0f2f47933822d465e5edb60af8dbf882440b889607d0964787da0dba234934d0aee512ae72e4ead5116c5c9db05c0073eecfe197cfbcdf4a75602bd4721d6251929144b66ac0c8aa1f79f1122d7ac551357007a17763d3b48bf4923575b3fa86c1d3f400967b569bf1ad536059ea228d90391b5cfe61d94af5f57b24da5c0776f891461d180b2622ad79b59ee7b7eb43857778729829b919583739a28d2a23ed19d215bd72ffeec0091b3770215b161634195920ecb34da98f3ea814ea4b09676c1404ef4327046f923ab1e59b8174e3d56133e0737f0b36d74a3ba049f6cc38bb48b5ba5cdaa66e76a5b7c133e414419c99c3f13c2d16aa3f17fdc4bd668629fcd5150e4613b3554becbe7a8119e291412836556a84606a8c94949b75952bc62d67e3cefa623a43778c32b7c9864b6111d58a14f2636d7dd8c10f7b7ac23d3e4399c7f7e96a9935e12813c449fff8d5bc01b0e4ab66bd2a2ebeaa39b349b8b5d54fb53a54716ca2a5b32badab6401d4ba33d7ce4f53e6af574ea60a1f61d470256ecf576fd251fd186d25484c0fcbd7db560d96006aea88fa4a77452ca719b5445b249cf1456e7681814e6e466fbde2dc23bcbb4e3ca2ddfed65c08bbd687f181cbac7ba2d34bda066baddcc8eddea8fb3aa2e14f3c804acf2b6a92685a1bb686e94267057c6bd16aaea636a9bacc890c347408040b0df45a8470aa12117d2e9ab6041f5da5865c5a15b14ee599cf3b3c42940865b072aa7f1f3054275f3c65658f8159a385b8a4a559d549badd4bbc0ae3b5db655d34cb83ca2fbc77d4f5caa1cdc5bc138db9d606d670e85dbf22e208ca1f768634fa0fe72817e2e305e51128f8cf4afb3779a6346e49b75d595344ecd4749d499d50b00b559ab1e997dcacace76b7929f60ad84d5df9d8dd55797cd475627ea2355071ce8427d7b4b8c81246d4db11b63cec2615a628b8bbeccbd3a49204e251b87771e7d4f640df6d930f83609eae18992e42f45e19fa80a8405907d0fef92bab15776662007ad2c4f6bd9d3432e6983a1a880c237f632b207bbda11e2bb83a5471a2a3dd575e0e208de704e615a1dbd402e4ad91d7164d8422eea70d6ca9dcbee81243cd991e215835faba27dc57a0925e1a71466e2c4b1b3925d4c142d46f143c050519f6beb9510f66934332ed38cbea6c2c16e544e33df08b4d6abebfbc91d88d595b24b2c5c5fcf89ec2e3c7738e45029bc15c315f1ed165e410e6f38ddf2d778c21ee076a8c0f09b805bd74c7383cae5a0d7482196887f3f6cd855fea00a998379fc62daf01a31e23578ca0e6cb6df46b9a447e5b04ea2bb0399a415fe254344e651ee45db0bdab2e6967929087bfb7fec80681513550b6e141a6f2956ce1a7b6924a9afee43491756d471d9edda19b89a8f75bdb8d1d94f3890ab674f930917747eccf6f5ae89d30a89dc71ac0ef8e4c1c36ac880d643240cdcb4174806e949b885f0dbed89f91449c61e43d0bf02a7d07fcf7a6bfbe304ca82abb7417cb385eb5da6c3555c4fd49ae510a0a5f0c7e991b31b253fa42623cf0f7e93b4f83739f66ae2cf0eea2a7c418c4cde2c68860167f877d84caf6256fa0020e4d4e613cecc204927682375770eed9051d577f2c1f52a4ec7c537a3db0e2989b65d590ef2504f28eaa8cc88e4915ab72df8c354ca6f658331f24c9a9347153f3f32bedbc74b42e033eb057e71a627a7b286d879d987c1c5b4b37ef6669ddc259f0ea0c0802b15a06cf9d5a94d16ce7815973c4bbc9ee2c438b3b8318e84fbe4b810cbbb56f481d08da576ebea13ee8c9958934116319d46ebc77ec78cc53fc080735d46d0bf4ac08f475b3a022200d6310f348484dfc85cd2740c23b188023598d3c784de771db9baf4e18ecfe7b8ed4a16ec6b309c60dcea920f09805d2b956ed89f6e1cc74ccc73562a95453ea9e7180e62f4648f872539d92293dbb024bdfbe6a58ce404b2a5cc629fd91fb2a640b4735559cc80521ef4014908b7cec7ac40955333d48f7e484e75d0108bf3e16e126808a99f18a38dba93bf98d90e345b7664ef20500892324c0fd3faa7a9376b76f1441a9f6a1c36b2b8a903749ab6c07986f43d9eb55a43f32a99234455fb109fcfe71a6c5ed659b1b331b19940581eec56e90aca5061b3690dc2583a9ee60532455088fd56a2e93c47f3a95a10cde1e2e5d891efed60a47e5dc35b06bf058fe277c2c9264f65babe5faeb54d7c0bcb51dfad5635a3d161e199691e6fd8d9554fd163d0b0e4b6c1b0cecffe1e9f60142fc074a2c8dc690fcc7bced79e55caaf8fac70c8458dbf3fdf63cf3c7bc530db63ecaa1275ea82b7537c68e9d35df11487247b7c75adefdf40254f94488787fc40f271a6a3c5e4c9d45432652ffe9733e4c5d392fc1034373633cd4dcf6bab26775d686d64ce74930a4b2e777a1d807d96d3b0d003e794eb30c51222303a83bcc40e90dbcc4e83468f310b34944f900c78cbd71fd970b91a26a9c830aca6eb9967fce8b462007b0993f40ae5c5c7bf0538cdbccf22f359e65b928d31a135e5967dba0bf061ec18fb7b5d297e05ad42a3d9a48c8ce7d21e62422d796def0330d2bc101d6bc6e733ee8aff43435e8273b1ca90692a81baa6d1b0ba6c9e83401a53140992632b4f8460882760b28bdeef6dbecd2d321065088a7cc6491360b8262187999160cf9de8a58dafcc174db3e9f4a78fcdb69a4879c99e982af56db4186aabf9f9d09afffdf53ddbbf163d2f926585cada476eed6649ae1b9cbf2442cf2e03363723ae90cba3d01ed90083a83eff2c40a3ed4d4dc41cc09847ceac35b299d3b3f12e80b6ebc8f93e8b4ad323ce21ac4fe3d294b846998671e2c880e33b3e7055a11d2fc755322a2dc4a1a4d080f2a7a399d33c34b6d8c7aeef380332d3e5b76d0e31447cdbd55834e3fcf81563b3435e09d232008dd1cc5eb54e03733773f0dcfb68732a64613b299982f08c7338846182e19d5449951d400caf68783ee57871ad576752acafb25266a25a3cebc04942047527c3a51e61815e411fb65b7cd2d3b435fe1a9dc285c99eccad41977c11072b6584b2834b55fae2af188f4b464a495635760b1ffac73bb517a15cb4fd87225b7dff1f0e7944606f876938f6875f292d08a18e9b8101d2f48a3901d667d36d30ef2259cfc6fa142e6e100cbea7a099bfde37266bd1806a8d27ec489ee292159bd26c080cf215171853b7e08fba7c47b95c6a01a08bad954119b6dc2940cbdebea134812884c6db527f292f5c700714b279af96adabd772afcb097f8707200f18c17dbb541daccc346554441154abd26d5d6706087f7a4952a6a8c658d163459f86f1048e59f468a171599986bcbc3011225697614bd731bb3e53f13a1a83601f687d6175cbd36b27fb7b801533c1988b4b90950eb28257e1cf6872083dcdab836089f7018fd30c750f56229c9c1c0f77ba060a0f9e77d584869d35498fc9a1b99e010ce67e90100bbb14826239cd6a248304e654ec314c6abdc4eaf3268fd9b9d38a298d6e2fc281e3a14e9179752a338005f58108251f2f685979c7ba6a1a469e4663a456167cf0e09d624512a2bae1d060ea2b76ff3ef6bd3938d9e8df0155cbb2a4eddf8ce7ec61cc528efdfe9662315eeb7c0c102866a6cd2e9e641196cd085bf84c0e8255eac23b3065c69a95e3b040f3dc204ff5f634ed904b2adeeeed0d95d9872bdc418f62b9033972b3ceae072e58195793499a34b0f49262bb7f6ddd0105722087e48ad8d8871ad0e8c849c654608f3723279813fc4ded67d3d6d098c3f373dc2910dd4f132c400d54fc3245caedabe01f6bcbcad2de1e95c4bd687d8a4f34e1a222fb626060abd0e00be25da72b0a2ad384288b36f4c6aeb15446aba1f827243bf0f0b2ae3c643145732cb89e0b82214801460594e1bc43998298ac31f53cb4571158640fe7a4a187890d94f770aee4107dea38d84de71891c51e35dd3ec6fa974f8ca37954827ebb06f7bc4ce68a14b6fb6391929fd6f408653c6e0cbed650318c52c5be51f78b6b36eed2e84af116f8377548db70e4be4d248501b69712d9b1968a04b1ab6206f550d7611ba2e8c247b4f4f75a655ad677dc82a3b1b2d366de2fd69fb2471077bb33a9245d7454f9e9c4cc4d36bb6b0042c7c5ee53a48305d36e191adea7a34b1219f39e7cba715b5b995e706b3d8ea6e9dead09fa06d662ee5aa3194bdc6dba230562697dd4608a2d35d07f950379d72205a4c696235c30a695655e967e38ec87020468d913a27d5f1e449f94342b0532d8f34b3bef1c201d028c86b44e400c5ba14c80db2a4dc71b69de3be8276db8de2993ab5c43409638dc5dcf534804c23b317c2836b238da165b89421986717e42707641fb7cabb79cc683ffd16d7b2b8f799a26e7bec3a63300e4fb869d1f36e6170db800859b6d156c979cdc4b238413120e256d149fb26d5da434ffa9cf8dd79cee2358cee239b4800b9d44aa6e11d6699287c0f4d643e28a99ce54cd868b6c6d984909b2556b0643af678a4ee3c9b2397795343f24522dc5be06ed9dc7c001f02671a9ffa5955cd96e542946c39594a833cca7eb9df3cc350b632728292f4d00f4ae4635ac42e647bb5706a20b2a178fae6d64afcfa096306d0d0da633b4376d2f573f186d4b04086c55305e9805b98da0c4c17e2fa099e0eb715d138bea56ebc6c444bf1951be18873d3887bc8c502b8053903b69d2a5fadb3794130c69a5579273ddcb7a6b4f8d48fc361fe315187d7359becca962c74984a5e8cb4506bd55a7ba39d5fb6e503996fa5754fd2a213de28d7edd734be7ec611447cd84a157b64d82a135290921f46235a99389ca5d74cda00b494b5b61e4d1aebdced27617b9cf9755ba1d3f20f758ca57d92c8c778d2dde54208bb67037a3888ea2d2faad924060248c0208cd09513602b5930f2ef6bdddb602a19a4e1c1390cfcc6db1b9b4c55f761654e61b2d99f6092f891199c4d98a2b63ea0d38de1b14c1941071c75e014eedb30eb526643462292ad927f277b8c1c1fbf504540225f27cfab66bd8910259d35a328bc55ae050bb670933891d87316fdc0f267279af21b38f50a18b38f7af88e2c7300541af08f55fad8536b21eb16488e4ac685b94a76f5a163e5d1324aeea608c4cb956e0d1eb8934982c58c4f496d43a8d4b35bddefb86138da40bf3294a2458195c5b8de1be99cf224646842fa738547d0749ee4a319da05bc4dbf51bc0dc46038a9b92a6dedfad5487e80baa556e4b5f795ccbc933c10dcaf6b335666e8ca4ab95d58fd4008ed385cd9d9511cceae7268b4babda71148d00cc8a40b56a73f0ec987c5f7e617882d440e042f6d1e675cb5b4fcc98c7f47540299ab9cfac29612c739475db1c7c7da5f8eaff0fb806815842b1c6ccf6222723c5a6a3f0bc37561299dbce137325f8ae6fc8eecd7f3b691a00cf4566ff82e6d4029e7b32ddbe01eb2bbf9d94a48150354e6bf21c4dba04231b7b82127d4b92dba44c17c53bfa8ead355a644523eef51426638ec08dc03726d877cb2db3714e611b97a22e6d3164bf9f546e3c4bfbab161e9fda1bff076eb046c7cc21c5808ab742022e9ed62423b6a9f0606a28e60887047db0802df7d7b69cf5b4529c152adbc8aa3cb3484fd2b252221d925f0c89da7be04816e96c342bd6191809853f41c722678b988eb1f69138694854f98128237bef6b111e9389cb6f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
