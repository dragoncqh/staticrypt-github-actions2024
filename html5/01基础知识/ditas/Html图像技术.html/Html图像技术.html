<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2df2e0b17513d464adb3dafcc118ec5db54b8d3545ea13fd069a5bd0f5294dab604a615f2d1aaac9f32c01a205637e2859528eaa476e574fcd9664700a1bdbea687a1d87684ddc42e786c06a51a7470d766d8b5228741075deca24c1e02bf1decbdd532c4998f0d9fd1914d103c4166fe2d2179b4f4a667cb0e4de747e178f8f5dc508abfc1d17497e3c1cc3d4154f252d60220e173a4842540175346d3fe9baf65288990e1706eed2ac6218ebba817c299eea2d82e75756c22548656fb18e1d56245c1acdd51270e052076856e427eaef92e46070ae45ca73c82d695079b125739c9712c10d619007c415c382130e897e465232524164760e5c62b85de98e454029e280727677213371bb4bf20b2e2a5ab5f5c79802976f733d840c272c7c85e617d3ce0c37e3939ee609f3737b01dfc97b6b23b8f9b9e5c312fe5effaf7b8ca9240b173ebf90fd40757fec6e4e0f36af52b3ac83536eb086a1354c0ce390a591c39bb1f2076f9bb7c2480ab6400ad75a45b40486135d268f03474e62d2c1075f6c0c9509f7d02efe5014651472f1dfa01982cf731a551c9b496701392e32197ce0dbb48d69b9a6f562c28dfb03c427c481ee364c7ff838c394e01c3d49a38dfdb295f3b1c7ddb4434aab77d46a4cc0b4e7789c061d3540393e3b724d274ffc930fef7eb3b7790e8cb8b7859be8d4cb503ab2d8f156941c479d0cfe7fb7c4f4a8cbfc665e9333fffc40b4d8c7847eb650eaabcf220c54ca7bffa262e8f6bf4c70d4e1df2a662083d73d136c44ab072c9aadfc7969ba6553b86d7f0f2f574279aa99332f8dbe9c029512b8dae2c9da9c4fd7a1e7be4faba5ea6aec2635592d802a2b1ac1c7d5dd5a3f09f439982f7d1bb8c2b80e9b0ab812873bfa9b6413196f92fde3b83eb75cc660b20fea979596fe39a83ad5dbb0a04fe2b11f7cf5444b65f75655e6a4d1ad604e602a17a4d55b81141c9f8b648b984c51f7b70c23a24c48af61cd04474e053ec7fba91e4802041ffee6b91ec3a8b1c20a8bb2058725475b1a145360954c274bf9099f5b0163c403c6b6d0a707d1823e3dffd5aa5af1d9084f0e59f64ef40a3b0789bd1401555ec1a397274a635dd3cc776d9741d17d53ea85c711577d219fa904a9bf4a078bb7ba61139ab58f3900e3dc53da166f89bb3b5629811b5dd5e0baeaeeb61f1b2fb0396dede594952560ff06a39ed868515fd378c8b842e6c875b9da90893aebded830d2f7d5e8c32b39aca447ef1f819c7fc83957eb9d8d5908d9a4e37053dd0144619b5a4314b211768a5a0b33b154efcc9f77d60f4c544eac065441eb02eb928cc91703d4b1fc5f08792bdfe964a702cc96ef458b826b148a276403c134c20ea82b3e0146deb13edbe62cd71e8e73aa9f19d3eef92e7ce962592ffbe7b8eead18724d29e48c5b9281bed57083db54d015fac71583adf63610967839278484fd74469d308db3da99e5523f244ed492c1460993a822d540fb7a633fb10861c12c34cf4bf3a6dbeebc4285b658b5e257681aeafb0328f287af0f270f5584e994028ae33c8ffa2ed6964d03c8732f6f5340916b35e2341b666fa39a725df902beb2a932ea46b8854cf9c9d666106c01b8673fd0e473997d078f2217ac3584c8080f703a1751f25b17044824088cfe1fa1ab715d1ecafc8720d65aef27a4e5d667a757905bf7bf3b6b62866c698f4b05d5aef60587f085b1901b9a55ae555d006648b93b1fdb0159026e47c6f0310f233493c7ebde1b8acc94135075887559f52d15b39f64e94a968e6ac4836c9cdf13b24a16c93dd13443e6f1a75da589cd848f016f470a8e8fb2090b889b8ad52dec7e7d44b6a8b8fc0842db9b59c873bffcf98c0793c42113e5047de53a16c587e86b084d3e83d95eb6b3082cbd0cb0bbc8007474fe99051c86089c6db3e20b898824c6bb164ec4e6af38818bd85a4159591bd6a9c4cd76ff542724709517a2e153d834d5033f5d4a19e87df3601317a1b97884dcd4cd3e0038b140926e8e16a7bf5210a50813150eb35422472f9ccbe5ab34e33d0bac3cbe22b848255b722774d9033ff37e13129f9e42c3fa7fcefe0af47b340ed6d227a536049cc0126327275df73e7edd4a82d2527b4b012898e04ccf3f831b45a52017c3b84cc6427a1f78a3c5a8f61c305ffcee86a2ce9bbc49e4f4bd855d81c71ef0529034c1bc597c3e7d88317e6abd7be7de64063f7a7004a7f95f2d2010de02a71c86c7d8e803d049118d5031387b73544d17d7746b20ddcb8f7c3eb55256c6653c58f7cd903d85d2d69445c6c1f5bac21a2612f15b958d2aa90a1bc219ecb735a657bee7d54f7671dfba6827ad3359d056abd5ca1693c031d9e7de9f3b82a7fa86268ed9be6342790c47f7630bc2a57761f4317346ff783a3f35b1c67327b0e846eabd37ddc5b0e3359536009df449f54729f1918d7eacc2016650bd82c33bb1db549507a2f572f2174dbd4e959769847da000b3585ab8774a7d7d85ad2a84616627263ec4fee71d417a4c1cb02df21781bc270cbf91bb386744d41c59eccf12b41d86d1d873d510bce51723a3f9216632fbc179da02a0a47bae464aafe3930e84f656493230b04bcea0da28c46be22f5edd14c5f28d43d74cad3c24ca93610571c05aa9aba36e5f635ebad7d06fa9b61b753b891d61dcbd2120d7321bb8c5603a0f92513e04b48f0e29f66fbee88b27f908a0577dd5b4d461c470be744e12ddb2c5364fb47520e42a47a254aa43ae740813e3e6bf23ddd9c4eb11011e85818ab412d665c99a198327c2ec661107a84a77ba081464cdc0874c501aac3c84f868a99c7c67f2bf82292f88e692a4b59a4c3d6f14a53175d055407cc5dd44ba93b5f113f8d412c69db5a62f1ddd8bbfc1b6cc39342adc1f802aeae7445ce87ecaa296a148b87c8065070b3977e1d66ab57efddb0bf2a0b01b956a31c15cc3cae6eac0a9e61119875e4159a6d11fead31e03b0b6c870befd50d1b0d6b9e7bb3772e4e917415833fd1b74c4cad4f3e443e0bf1f71a05dcf826c2f422239cadff01a4065bd99d8f041d5ef78c9f655d36f549bbc77f6893893af85c6bef01399ff0a29866902c399f68f41cb41bcfbeb24fc4bf76317cfc73b53ac0e298dc945216e81f87a477cff524686ea35bbcbafecb090c1afd63a15e995d3300d8852c7411554b6d14be4c3b5b169d9be4d8c0f0a4345e8afaa1e931a068a8ba90c04cc6bac14f73f1d8656ce7e0d05b51bcb942cdd6a5dc74322d48c0545f207769bf7d0064ecd1d1c9786c76acc9b2690ddc9494c824eebc1d49dd19f78705d6a6a255298bcc0683d34ceed7d7220d7a278f5fe36026b12488e5a6b1a5ee39be4bf5efb9bf75cf8268381e823fc2edc476f64df8760f18d3dce16923a672a6fa90b8cc0dd1a791e4072e4ff5a9064d2018aa2abc20dbdab92e1f39b7b66c08befb1afee5f683c04a7295d9611a1bc8115ec5b2adc724eaf8a10fe90428b22181548694e30609c1ca767062f5ff5e5dd3b93126ec14dd19ee37c3998dbdf05e9477128cc1645efac49f2e43bbc50b323c33e8aba28265d4c82c9a00708b6ab86c9a0c257d0af360a20648c0eed8d2f8748816233bfe747d9345def68afa0c12e88943d1dea36dd3640fe20653e8ea04182b63b52bec0001e3188607d4a2ff6f2994744b5bfa4e36008e6c23a0a48425a3aa768c54a615828b582aef32e370368460e135939817c26dab8b1a60017bd8ac2b99fc12a83f1ff6b7c495d669a300d8cf531f3179bc65d389d833a9d30f2fdae4b53911195edaeae36aa1060c948d22cb338928b6cb0bceb855799eb788c5a59d04dce8dc7a8918d573837a847855d6f1751e35834245f589e4317ce31ae49f891874730cbac4f74d1529773547de666dc81e035617668f9150cebe1624178c3e1e7536eb1198210316772b5999cd7941e17a5027f266e06eb623a8f67b9c046f3d6a08c4d9f147b00caea0137aee802c2cf45716bf355e5e7e25aefe940945e40887bfb3b6f092ffa5b7ea646246050c4ed7b5f2c7194d22a60da714c9264b775c56a529beb0d2ae2d254e2469b58a59fd502317f986e7491c7e1bfb009c99f525025a9e662d4c2f1798b131479549eeb59a19e2fd83397705464a26f7e26d237d435851bcb7a47ed326ba690a8efe9a8641d20390214f668af76c4f78d2db9d255a647637cf386f84b898df2c27a7b8d5e92be6f0e33105e1decbb0d8d609166f129679a57e76cc0978be31235ae91d1f2ffff278034080eb87134572d0171ccdada60c29b90df04c6424a0cc88c335fa7c2ca63c26eb498efa881e2c2e26eedf5a56fa85814ec5aa6ff91713bab0a51735ec101b75bb8a6104fe9497aa36da1a7eb1f50390e367b8b8893bc7c1ca32e84fc907032bc4d565b8d88f7175da8212456abd042ef584911e599f472ae3a8b3b2f1cebbc8a173c78b82e92a1b7bff80fcb27a7036c0376bc00ac2e005fc08171e29a46dc9009d9a9e893a3ec6d11316a0006d054414977d09dc4520f7963c48743b6b799e674e49e35eea7cd6d2cbc688ad865167170014ec6fe03793eb8828314bc5fb4fe9dd4a81da3c6ee8c90e5226ef89b5f72e29e31c6ec5bcbc8f4e332aa53ff97888dd113076692e93539f6c87ee801102191abcfba25051af9908b74ab7e6a9b6f1ed8db70c15c2421d6c3f2ac40e1da192f409ba9309326ad88f9e9e7a6c5ea6567ec5a5b1099e03eb6b493278b5c7b644e41d07aa0e227b2a3292a7ddf0b995be782807b51e43394cd22dbb7d3656c0e8c1d5e086a82908332458b0fa911cdb20e43fc8158b8818e92ec1d6c429bcfbbf9f693e2e4c1cf67f464baac1b95cdfa7a1476120d82b63ed83c722e94aba18b58c76702c425334965d4389013179cc8e50e157362b53eb86beb2a7ab581c3596dd7676e454fd80e0c9ba527c9d4c47724bb89651f66bfef2807cc813ed5be73e30a95e8d5b9b9f428e3f1b551005932ca37b3a441f5050c5a27f4fc8d809095e1158562ff2e51a45b86570dddbc7c01db74044dcff4bbae940785f7be4b05485b10a573a0258c13a814366044c69fbffce85d6bae6b0da25ea02fcdffeb5c60fa3f30f360c4b9e365cf671b67a67b99987b9c678069838375df799229e6bda7e0268601923830ffd0882d394e1f57abb955fb6a025a3da9503a255652292630fe10eb85037063bab2fb33e861296990d220b64c8f3a1abb345d902527fee493909cd9fa6563f3cee78cc7f87371971993191495b6ac7048722315e87517c5760289cd5d5b1552ebe5d6af734f9f9565922eb9eac83c51254f10600949f81c7975cc12f8cf20b648fd70fe0d33e8ccd32285c495d63b7104caaf6d3ee840ebc8d695d721555bf3bf886a58086ee86e291d0be0df21b8dc09d70ab049b047dc09b2357cc718ef2a389b8eca0aea8e50ff020adb131cea2956a8317014d724dacb2fdab609b138aac109c0be0fad389bf9eac100915fc6036ef93d69d4e476ec0af6df5a25b7179a5157e95d2dfcefbcdd2b6579f5b312302afac215ee1b86bb9c0321dbc2e5ab0e203e3d00b254a4d1a4f5ba9b24794a5cad40a95c4d5ec25d38cf63b528bf0179bc3e8c4d345c0088978c58694356d9facf37b669bb7d1dacf8c3ce8a33bf43c86c8a7eb4b5f68626e83f79c94effa6b9c6152694195016db1128adbe4c58bf6a3797b7135c05e04202917f0a2d71df707d581a83e6b8b95453a84a7b0f354be9a2b846f60cb702d41e540ff901e8f4fccebb7f474b9048e33170d66b7d9947afcfc5c267f51d4ea78db3f9dce0951245734975a3ebc7fef0e0345281e415a5db105404dc7aa718cbe3d723329d682c8729e9eefc68cc9979f0d0eec63a48ad1602541e1803790b766070bdc35c0266f97ab9368e9b1d2ee7f7b513e6ac4bd26c92d6184097f37d8dc0ab8326d7ec200d5be7ac1f12a3a0004caf55f96d7da2d52c84140dee45341531e39069aea0954665b5a0c2fa96b94385bd3dc242ca983168f29dbcfa527cac67ccf8837588872db8bec5b6a5de2315078bd890309a95a5a50d16e9e71b6ff202c2d02a37c12e695a91d695a1d1c3741bc7689428d2e0c56ed7eb07a068c8d359ee53949556bba85f2b97f5e806a247e5b9c6ee77424c278de95a9d9434731b0b9f971e0b51f195fdd219ede00a01576d963cbdb42b171a3e65b3948a97768b21722b8d1920ab0f40d7fa1c72c9c21b27a81afe9641563050309eee257c44d683080485f7cb7217d49ecb9504c0508f2c8481cc19d0d6d203317ed19f54a289e44eccad883d492967c345f2f53b8f0cb491306ac9e066c66092326cfb30dbc4d92ea0baca32d1b802aa32516175cb183065085a28d14a3ac315942a306cbd0232fdf4c24e8af05cef553b6ea80af630687b6dcd173ec072a216bedccdc6c0b954c6ca4b3e632e269a4e4ef89017fc515fc53307c1f153545bae686c3593a2f826156716f913bdbea57e4da05b82d04b4e13316a13a0739da3905d5468ea018779b8851ce0b4a463cfaacc1719bf7a5231e1584d80ea2daf08ab2069681b7f28b46183d6506acce97a8f047a1cbfe48b7ef78a044f12f93b9c57435a298513dcf1f9358af049e1e2b7c9be214c88beed56c9da72e51f415048f8147fd2b30a41e4806f59c92596bd3336c11386a968d49c321c81ae62871963a743eeb3ebfd520f92a0d7b269d948fd95084d6b3f901dfa2cb4822af290d3783611e03e9e012b22175d475ea6e9648963fbebb6b479e0d26c64944dcad5a184dbef1fb3fa4a302d4dbe231918e395eac2f06e09277b4d1acb8a81f8fe817482b6405f668928b9a780f363681a8d03aff0f690827905c0541042044e64f094d77c5d17a3ff57f2a26d8641d74d7fa3fa2692658404e0d00e8f6a2efd5642c5721a9c1c343d512a081f052b772fac9ff1f3281428f602b7788991ec36c89f30e2380f12c90882c0615a9c39435cb841b508a752d3f8b869cceba015d79b93a6396ebfde1521c9925691487f020911d8e53f6ef287792a50516210c273ff0a26cf56489d8700c7a6c9877f863db037c0bc300c3ec9dc4662693b016d884d056aa7a85c4722782dfac89a70ff68c20b71fba21fcd4645d90bb6c6e89c98ffca66d3f57c6e5b303b8d4b59e82df29099ef26a9239962b5fa92b0395ae240f382d065b3d40eb4eec9312d89acba925b979525467b68ba0d14287a7d1a0f080e4718a2a744c711098cf7d01414414ec69409bff440cc200562493981876e65c530e8b6a53aee3ca6fe11adbfee02c5211ee54cd9349d39b90f46ec63d15c8a4acc3e6ea91c3fa6b31faf7d5fef5c2da55c0f1111d76f48c228eeec6adc11445ca53a240547484c742bc28177038bee176e6d474cbea572bb365851a879f480336db8c061a6d42aa19faa0728ee082a0ea14d140a7556af5dd479edb17c6ff2b27390ea76174733b7e39ab38753d7d022dd2eacb2233ac8f9f70eaab685cea46987caf080e5bdd30ee3656ff4801dbf11699c6245f83144b646b888863e0d3253629605e990798c484e472f3051cfde45da00108ba83d9399d52e66b1400fcc2bb6614f99a1d6f9608e395848e6a1782063790d4b0678d328902d16511db9682069ad63faf27689a964ab5cf5a7e94842630bb24f5c1643a22770288786b6d6963ee615371df5fb312366908256ece93792d5464ffbb4260638fa35022abb90523618649f47ef2a92af6155b479403557dc612385689e626eb1165df6a27a7c2ec89a6261eae8ecfb3fe375f988795ae768351cf0f1a870bc7220e7db0abc70f6f7100025c2d94863b35a7defc546d90f192334bf33f713431039f084c7dcb36e15f7b7f339f2cf0c85799b6662d078bfbd32ea0f757593044195ae439ed6928f109fbd5cb5704997f4b853764075dc63418989ddf0e1416d94239acc70cad84cc27711143d34bb8247491f2251245951b7c714a9ba83c8e1e5e5788aaaab39c4e011f2e676d72a49d6617c367a763da292d0ab96ae7e6317c49144be7a917a78ca707143b1b267e7f4186dcfe7f9baf6f7ebd4e9135e7247388beb6c693aaf12c5b7e806dd9002b7301fb5a3d0e72a4a0d8a4b4d17809954af59ccfbfd7ee8e451b1c805c2af929fd7ad9b0382f87954cdfe3b68f1186cb2b9839c838e5b4fd3870c96186db29431af088aa92834285e996ed5c3e3a0db5b330bd8cbf52222b398fd7a9b7d27eac247bf72fb4c62230a9a6c272c1ac26e68debf2d6a4917521d2ef6b45b50b50515b9249b255976f6e1b9a1612a6a32b06c65c391388f7dffc3241e78c848debc6e6dd2e7add795459ba92400d30bd128988d4da64e296dbbf2f3035dd16b38da30a0301ba1ef1f5e5146c689c593922b5e6b6189638777988a90ca9ea5aefa3e9c6005d9821067265e3a488d0953c4adc4250aae2dbb4db16d5ea4865d3e1b7ec02ad68afebbf6dead00f6237682262e85aa534ca42a4daa7d7a459b42afcf0049371ec7ca2bb4e765521a64b0fea146abad2c483745bcc19d63fb45901f05e94bae8037d1db846e3dfef45f58dd76b15cfaf7787417bdd569a650c3362ce122ecd0972223343cc483211faa9d0f6edb1e6b48127119e8a1b72370779dc2f258cde7021c5e7ceb0b03d018f42035daf5fa8906826b516c512c0d825445e7553a7b52c28c64a1a4671f1f41417de695afd56ac4beed7ee11a7ae4f08f419b04d45b60f0ce0a3b9e490e0c7df242f33c7a25e3bc2f8b07ab06a6c8301f34056fe7e15850ee0fa7c5155f405820a7116771bbab831d14cada93f64e4705387517e1baef40c13f4806c5aac0a09632f2268b60729b32799244bb4c1f9239fa8a264c22606abd9dbd0d7c12d0206ae50c5fe27e5fe229a6d0ad23fbb7b714316bdad6b58b0065aab84716f9bb97a522015b665d12581e71fe49b144f42036547822c314f5bb593c2b762a22759f1aa23813ad8665cfc6551ecb52dd9effc5d4c91663b1d8ab87db19135c08ec8fd74f7a3e4a0c4caab134fd97539b2498a7c06bba7e276222371e03aae673a84b6278ca6dc7a4fd47c780923f1ba29a8664462a49a33eaf1037b1f104df1a014b4647a56525044787145fa444ddc9be026bf1c8f213a51419d494c0af4b27ff7acb5f4d52bc140850f08aa3ef2f602436c8ffd742fb3c173ac7b14dfc6a4331c0c729559feeaeef87d9c6dc8e5baf4b55478214d835db4c9e46aa04a9e4f555f343885f3bb1a6caf75c2b645fe18bb7c4c990fb93d96dfe1174bbf8d34559d7481dac8c203b8f749db6957231944d88e1b82325d6014f9fecf8c64cb947e032bf82a8c87a23f50b4cc960e93c0b49ccfa2c4ae191361a9dbcb7514395ba16580bb983fea65cdfa4f53e6c5e69c530648d34301e1f1158ebda06a64ddc9b3ca4c9a7c069499bfbf26fe4c81a9bfe5d1ba4fd45c1c2f9be89eb9d08ba5bf7ec27adc0ac8994898cd28e4e8dff9d9acbcafe9e86e76b58853b46a5257fd1afc711d00964f091497da813f0e509cd167072ffcd48d4592a8ccdce56eadc1ac11dc7f463a75bec32c59159e6a00246d4aa35085abc618eed7c7f2df02e8f617b3d9f7bcfe956838b10767a1ec4d4b11d619f42b01d2671432f6865df653f86247049dfbda0e2a8899185492e2cb3cf37d985c1262b59e03eaff151e6d3f5737b009ddfb0d7507ce723c89b480c0e028c1f83f95308bafea93403b62f27a3625f3da4f13e092e02cc5188e066ada928767c666ed19673e3e3e1749aeacc26177151493260697aa4881ff6b68a7aa73af3001a0ec3a6e12cc7b0a645a7d8c9fe4f5ce29e10af607a0ac1ecdb790d98ffb6b0f55ff5bcbb03b85d1da8dd8f9fe061a4929f8734cc4f10cf35b14e0096d1563d6cd127c06c6b6503b5230f55987d4531d0d83dfa5ac28ae8eff5915b4c5bc216213e9011ae9991f33a92d6f5c117678a3a52099d0497d1c0dc5a64455446744d472ff5e159c83010536b1b17adab2f77338e8fd4b2ba70188951a27e0c20bea0adfe1092ae244ad0f61208d68d1de256487871150aba517159c79a174fb13cfd6825090053d52783a5d5c1ffc14c21779c45487f5ab2585f18d85762c7f583fe324b8c0462163546a63dd7313532cceec70d1d783ed47bb56eb39209cccd9d2d85bd89ce6dc4df21e41581b704f106dec833a51d6bedf5122db90229f376c3792c8f717345dffc949c974132e0eb037cd1d421d572ef8b66c1ba56ecf34ff4d46c8f0a63f2fc5e6bd8f17d3c84970aed5817d2c8cb4f48542ca4ab06bd5be105ebd8816f260bd5ed52be25668afbea6f3e5cb3a19600e504862ce7b56e011af1795b4012e1f60292638747cd191f6ad7b294a1b434c0ba092fc3b795a001788d39acef09a3679d8701e22461cd7b23e86ae95f19f50e45a3470640496712186717eb97e893e3647c6c5ee033c6a7966aff097dc9eced0ee9aab6b2ac3e2f1d492180e098bc7b852cdf94a4f9ce28556e003e593f8f88a1095ec0ece4c35e63d83a3a70f3000c75f51922ce012bf0aab920ff974a9d23d6d5a4f574619ac0a195aa417df265049597e5477f798c82aa5458bd8d892187170bfe84e7d06715f6d12754b535edff4d051e0a2461254d658c14ffa3676a8ea8ed2f7189f9ffe069f5476d81057549bcb38d2238fa8c0cf5fd0b8d2a91afe7a9b5dbf2278831e9fd660e1d9d17cb1678d878d55c8d84c9caec9430fc5edff351df4561fec8e90be917cb0d46c84c3d7b8e67448e651e3260362c818e608ca7565b35f139fc165f04c4e873786662af84445f2772b9389d6061e9b6b075e6c85b84760fec06c346596c65c71a773a45c1df016c3281fc344366f94c105d93a479036fee9b7b310ba24bac8b05cb3ed82045bdea7605a91b48d9a4f68c6f7298edec7ed7c2aa6964658f32d5f66a9cf4c131b83a13dca795bd1e3d68764cd2474fc9431c3a25b2b3decb9930d693d68caf3b04fbc81b0e4e89f679817c0522fa091929ef7f90bbf7ae404d313697205433de0a7186be7f1faa5f9de213dd20abf46aa101ad4673e1c37b47cf993e6f621c810276850ea244644df1b13f7670fbf0b77ecf657f00e0428692242ae7d70f0ea604af906125cf854741d9c976c75dd19d9190e56abd16b302a3c2dad155c8c0f0030d8537798f9be40f8bd1f2af7f29ed67635d53c1ce216b4850ed9140265a1f4be51980bb350ff72b4ddd822fe3adc759e7c2921814df8fa4e8044b1aa81172d8a24be0aec7d3a3679fcec582ae061a6eb47b1babfa2eec35f1401d9cc37911007823e7fc227a808cf915bd6cbaaee2aaea55ba5e78bce349b9c82421b44199f9479c97ca102d984588673ac52074ad4ec3a09624b08f6fefbd542265c261502a2e2f0c6ce028ed3cd0d8b3b605e32ee8553d4aac5439b121ea9e3fc364500134effa42040e52e1a67bd1153d8a956f84953ea7ee4427afec7474ba7589484201bbed6bbd4fdf2202af318da7dc680ec39e835e11e092887a722aaa0fd6db0a8968a14b62e2bc28544852df2214b433bac1cfeac1ccaeab6392e2c306ab6233bdc19ee66a3bbe366aab876faf4c77d68170e9902419f67ff195a2c91ef20bbe619224c65979264441bc1e9eb4f57bdc42a33271fa14797476b73152d1c60836925de385f3b4334cff2d53daa43c444ec995c9610049c5c0f6f0a7ac8675b6a54091d834271a06c5c347ca1373ab6770e52a4412c8c1292cb9a688bebc6988f79946cfb6c137c75a737a90ae0a2dc34746a03dda70dbd9e98adfddc95fa9ecdc868f309c763031e387e1629d2ed573264b6d853412cfcd260917ca673e73b66b14ab894265c66475ce9d36a1c953fd7bd55533efd110b96008b77db3a8b56e9cef9831764b9984fed0b734ed6a2d335f1a2b12ed8a11ff1ea232191338cdabb50d6e4ec9f793fe3e6ee20e9a60f1372978ac0e7afbc3482f24026d25cc3e3b063707871075a4b3f64c7a2875664c1b023d969861953bf3d62c4e60c7966b84a8efce26aa67dd1de4ecbdcd1223936f90814d2e36286e10bf5fbd04944f3238af02ee3a309042b4de6348db6ad38efd60f99207e709c3cf0ff7ab6fc6cf4828f970d54b707e012149b42e149185218c7ad96acbd385c9c5548c036474eac37b26a8a68589766503347cfdfacd7dcee9677034f1a0ed2d9301636800e24f284071076ea29e6993baa0d333d9ff98fca6df6ab0d218aa0e02be68cebbd56d9fe011f6cba7cf654cb4fb00d5d185b160e3fc4f618d6ae5f774caae004e3599ebf4735bec7e0789421da6f95617250476a4d362aa3cca5246e2ab52dac0d68fc3371a9f3a04845073fed09fb5cf1ea8c356f1db080f81acce47a6fdc48232d016e98f8acb9f61816ad065f3df8647fec23507e5e5d5ce623a1dda8e75a1bd566cd292bde438c951949272cdbfc45a73c6bdbf6828328a30b36dd682ed46ced445f8bab2243dd7aef4d05d2b641ac95a8d4f64aa51eafeec2148fb651bb7e835638231ca171fbd9229e4e21a9327e1ee7ce0036d453cd5d8a37421ef5fe117d7cce0871a854d126c5d43cb94ebc2f55181ecb5364dd3aab5845b57deb47f5fb9c0b72a9d2d6acd0033f7daa1da6f69a2f4315772ac9888175da7ecc24c8fc4b286de4df5ac7869a21c7ef6122d94e82445401ba690ee763886457451f934821aae733ec491647118cc19a7df5447e44db4c98f3ba76cc14f21d75dfd0347b9ccaad2c4c140c7c006ca23ba0454283c2b3d5983c70a87afd128634a7245d039598a840358d3f35324d578f108b637018868e74c32defff97bf3a55c630b5d58c226442a28e5c3722b053fe00b868fcc1e87419f5b53e5aadfafd0bcb22b64e2f3daa36579c0b1bab4a0aed488e54348161d05f15fdbeaf7b373a8ed1bff31eb2f3039476ae6d23ff89142117dd6e78bd651b246a6503c272135151f34a1f1309599a7b68e4207574ad6937ca069731e96ad2f60e0beec50424a5b76280c64450a544cea3b70c13b968287ed478f603b5e96d5b01816cae07bf99e29ec2ef40898b89aaa71eca446dd93bc33201fe92c7e330a9dd2a9e92a8359e8e04847f6e912ec2a126bc87fbf6dd3503c228b2772d497eb4e722ff27365ec7fe1d51d180314771b033630a63223600804c62f99cfa7afce06611f09cfc779f2c4d30c276079b398f1f9898214735cc449bbfaa4fbdad40bf6d258ab27916dfa635e217d40e1ec627a01c9d03b32ac65af2f2e1a31d6e7dd212497a1b5c4c2b26e9584bef7b01f61ef3344939acdadd9edb3e359c78ab4a5ecb1e57dded36a05c584e9e2890be8dd51b14953d17ef4f7f3ab9a73223df2bfc5c44523c83d2ba690e58e81c65d01328839868f9ffa951f86bf6f0aefecc66cf630bfb108547d0aebe56999a9807f1781cd3027354c180d75587a36784eedbf63acad4d9df15b6b893bdebde19940082bb4155e39d21d86eb2619a0466e70e03820e9604ab64f28fbd65c869ef92d83e4eb9ebd389fbe745cd566131d129778a997c134298f2d8ffe72b86f8e9e156161ec0ace93cd439a120bb5e479af73112955267f3086ba1b0bd94e2ca22d292c9333d96eaaaff65498c67ddc24e46f8cc4e48bd45bb90a3f7a030e4d19d3645dbf8d3d4c1390a50d96e8f84afbec67c47fcf961c4adb69cf2689ddba37c9ae84d8b66bfd5a287c28ffef0b3a9830e36144f62518aa441d7633e73ce166f1306ed1943775287a0bffe6a69bf2278b1cc37d32e624d893cc49130cfde97d68c0ce24af4ee27a68cd0d6b5ec01dfb03689a9097f66c96a1c126a7432ed45912ac9ff14578d7b6dec38c87b6c198f42d8bd22ed136a16ba579163b2a5c46d6b79cdae66a747195835413eba88c5ce6b08686bcc7fd5007454907195f4a52f0eccbe6f575ab80d21b11161da3a466a03d8cece790c8ed9d91920f2e05278b7696039c62d47328dce05ace5a6afe4eac50de03603fd185e2eaa1291d5ebb32d6c50268eaa2337bda7ec20e9af7d29799075d87957813913f9294428977965a7500c74fb2df389f0344126f6ee4e3f5aee935a64467a2247ed5863ecb3b067f2afd7fd85b857ed76c3a8d0ddbc24482d4ce91d52a5659a3a80fce4366fa27af4754783cdf67645a1981f54406b8e5e8f94691a568a1a2c6fa303158180187b3501e0829463d266dfd54bec109dd0a6ec3119bcd107e89c5a30603582ef1c75948bbee4789bee144a35707eb8c16a853fff6c3ad03a29b3e68489b5fab1bb45b9ea7e6865406bbbec07522ac3c0adb81ab66c10707a3870fa4d7308b11348e98ed962fe7ece19dfd94520e476c4692a4626438953d560efa0ff539136e21546191fe3b6d02334fc7d68a40eea5fb77e250264d598d63c8fb6472ad1ac6591d402e2a1c4a17ca229007f31a7f2653d62ebf2c1abbee6a92f893eb399cbd45877e9515df71ad3bf70225073e2b51c2c8e8734083f17f84fd163ed2b88f579f32e258bf7d89c3680ffa852c4937f9238f2eb99a991bca5a132c651bb627dbe3c9e4b49f6df285bd5656674f3ba8c13aeac60134061340a7abd640ed79255dd6959815af6836a64894598ad07a5b0a01b39db6ab7f30122a6f02ac4989cbbe2948accfbc8207cb1054bf323a0b7e45bacfca71d15abd1a32dbfdf16a6f1ab6921b1eb7f429f9de94caecb1730b3ce17c5c58725077eb425456dab9dfe6bdb62ccca97f64821cb24f555ec6fd1c04eb982fd485e1580bc01a6ffba6331e9551aeb915ac2cb98f4b94ad5afd6e0b2fe063ea99e1a80cba8e002a046c67055cb48b57aee377325d862cde838c8680059d911373055f9ea5669b52dad2a5626eb86665845ff51c7e3c66ca837266acb24f584c47c6d4f7221433dfcec25ad7e3be9bd61c7bdc24ca8f85b3ca273d1de89d9cc786d05e99652c865ea0829823672abc9c1ecdd5fbbc08727df81eb66942988752f63f41ef236a55aef927ad2385e74be25c9c82d2df6bf924e90bc6272c64a2de08eb2c9d63b46f82792072c71dec72bfb6543b0a96db509174125ea5b6acfdf27f5a2def87ca152f9f4ac52a2c27d490ebae55566cace870b809c66aa00d3dd81e28539c428dec0f60ed3de3f23f05e3ca0d3b7efda633d883bee93705d3b395656e5534675e42d0a3e49376d6a17b50ab0f5a2039d6d71a2df9572c5ffc1a261ab34dd062c23a73cc3e44dd2b64ede17b899f53e2720f007570420337f4ecd5d9b892298b3467ad0955972270453503fc520331b6bdad60d543f37edc58d3ef72a4e84906f50e7ca42f18ac5c5153295d298f58f35ac986d2c6542ea5c88c6d12e43971e0428ab0fa8c02ab1826fc18a4509888f8bfeb76422f52fb99657c3b6b8813335aa30ebc9313a4b42c0fd05341fb0fe6b625487568bead62b03571f04b945446f4fabcaa281f81e57bbe1c45cc7da9ea0441e2b79083a4c98a4c29591549e7755b574b88664d5951a3b1770f192ac9429a3eb8e20c1659f6413449c3fd4dcd4818df4342025983483d5f482479d6f0c5e956d11f2c84f389a675c1b6fb53c8fe5f62677cda3ebbb674b80eb3077aca0d0f28fe68278c1d985a17a34c3e80f3e7f773f08fc90191892bcce63f7d4e4fdeb45d1bb48d4aea714d8eff3228f44a39b91f63e9b84030c09dd581c68f229d8c71f4b9ddb32b3e32a089637c6f859e138bf7ef68fe5742a9a6cb4aa3df20db3af67538a49ad6abfb52075099536d6127c6400939408646d5cd081165ff9f128558e033d84ee0bcffaea0f3c4e33ad3699e9a77706c80d0e107e64f2e22c6473ed71bb9f61b28aef4bd075031fccf87c27c99340643c3bed208a3b6d99923072b7304686a95a6f26c230359d0503f6a80fb9f0e6f8f16c11affea8fcfe49a1b084ddf0e5147605d4b375625ec7db53b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
