<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c567d96172da4c53acd235e279230193ad8e90a9b4d8c4f748d54fcde30b3dcd78d546169509aa2192170cc9e1332281e7ee6cd2335c34e37a75fbe5ccb5599a53440029a460a9d59425ab29505e9c954294ad812dd7deea0928355cd0e03d823d8018ba22bb37e3a18dd33caf08af0ca9fc5cdb52490156d262608128e949f52921cdb8602d7db8f68bc5a0d88c6d0d78b10d5bc6abf31d7d6c4a271b91a32468796bca3dac1c7da1a1c52ace4ef3bb82c4d8289ac66010bbedc78af9e8961ae011d9694b865c7ea05f82d44694fc909f3ee3f8c87150f6cdb8e4d3e7d909e4384185122f8e864f95dd15e376746e3eeef4c9ac28d49ebe39544241397317f376c181f85b754fcda0518cad1fd4db9704b82b1dbf8432c79284fac7c592cadc605e83ce6dffc8e03da9926a75bd21d6b1080e02ed5521ebd57624615d718041d13861cc261d18f3a35063fa9b8a2a6f490ea08ab168c7525cacfd49ad778f2903b189f827670bc366aaedd497493ad4ed4de11bd9d733202cb72e9606ae4f33d6e2fc44376f1ee2bdfae3fb2e03136cd50022efe40f2e831f4b9f8012fa1e75c83b688b7fe3c328dd415b736d4b4559f58d984b74f24ca44b3d492cbf13b2cfbe1a89c783ee7bb877990a5f769a5fe128bc721cf81847db0f1f76516c57e7a14f1811541a328ce884ad991a849568d54f13d3bcb5ed6ce1af105078b230d9b67396adaf7dfa9a60d9acf3fb273598eac692bcf013f648f2a06a942b5a6c1a90bb7baba5213e5dfcef2c00275add8e67fa754db3662126c916b2eaee646bf47989093eedce77ea20b5d27e8f18c577e1cfa0dcb5b4543d7cd308cf82e78cacb7c4889229b6ceec3ed3e2b26f0dbec6c977f93be9e356632c9c30d4f81ec832034b7d9bafb67c0c54186f3f590264b22d9e5c51e674496d36ae5fa2cddd1bc02c19bf14b079eb15f4784f1de27fbff41397e21b231216f7faace476d983a1199f09d0bc07a94734dd29c13ad2405a1aaf761b67c860efd3e024f5075ed9d964c20d52780f22b6f3c153e9a925b1dd6eef4b0ade5c8752d6c45cdcac288cfe7d56ac798bda9daa3963e81de55fbb504fcb7fba54e98d2884056df67c3a06ba5685f1f4279bc85955f3506c085a6020d9954415696de1f7c9eb3834d406f38fc2a4c6cc1b475798cd35ec4ab6394053cbcbb880a07bffc34c84bbe02c2b245bc061453ee30154593781116eb470d785df66de9c8e3ad3c76ccd423d3549a43c7a68c3744abacbdd3f99625d97c1da52bf1dc22335ad6327564f0d89e3297388dcfe5de982cc9eb247bee14b8c470f3fb259b4641ca76d49f73239067ec979e2360f409c476a7394ef9e90b3a0fa3b035952576da33985a3c7ea916c15a6178db675433be244cdb96716f992e44e8ab2635f523d9dbf58dbe2b1695fea0ea4149bcdc4aacc5a31e489f5bc8e301916ce9b20959f4f11795fb6db1acc4bc64c3f2051a086dad4e34e1256c9464b5168a4e95ed498a89103d6ad1b26cbf6acbb94e4cf25dddd6b2983c2d229e2b79987293eddf542f0d7ee6b7a6716df7f713f63b5138cfcc2119ce0f72a85320c9487a542dd3fb33875678778a60f715580987e6e7272160402f65947eab94f0672c7f89feeafc11e0d14fb34cee3d2fc123f90751961dd9482b53cbca23a06a5fd1a4d24a8293110ddf8c011fea9909bee425dbfdf93469b33a3ca8b88ba325efbbaf1e28356dc3e07a320a270f85d86e8617e0ac6ca8100836f7cdfaceb6aed6af6de2bd1f161e7ded0bee427bf2ef76f1ea4cc5fd021a20175a6e87955223cc35d9092aedd7aef9995d3d5f8a1268aa6aad0b5c56343c04687be152f1b359fc6101ca45079084f3015307def5d1445d2ab4aa0192ddeb517ce8d4ff0abd2d93e8b53f58eacbd25a7eb3d78cdbb6f38ce77b81e7d2c9c6aad2ea06103228d7c87204cf037da196f098dd47eef7f4245a41379fe2f4514026745231c4fa32d29a6e4d420324ae6808b9c1fcc65c6bb4284b5a3fc9e708a5e8966437a7aea54b5f92b32ee9bc51c79fe4c15259ec6f879c4c537b71380b10631bd5c6266d7762a4b82a2052dc9f843245ae30854473d293c5c8646e1bb690a66e9f4222fcae26a3bc4835aefea2029ea34f3ef645025d5300b7937c22ba7401ffe68b208260659817595c0ce470d96475fe6fcc33ae00b690ed727ba12a2799d9c414ce02551d2f50f8d9f48ec514adcf23dc7f611d10e0c5a5f120940e42982952be5a57e2a17c566b40452e14abae231539a8372ddc9256e11b3fc6cf67940e3fb34e8e2b7a9870d0f34e1b55ade600e55f857c32294031a041ade105085d509b761e38cc4b536dd1042a063ea72f4155abcdccc8973982f1885df7bf230431beac6c5619174fc8a7b4b3d12cebdc48e2bd2495f3043af7fc6474c25d7a943da30ebe95ccac1a5595c1d52036d09ecdf422db1ccdd40049b97f1b2dce4e478ad3770c6edf7ac83ae8dfb6ff5b401f07aae77c3cdcff421ac487bc99f6f5c78fff26a7c41472983ee79a3fb1386a9d54522d8dfafda2c0cb79e1aa844955c84dd35f70f6dbec54cede4be4a0dffeb7d8b014860a97d5eb9a5f709c0c6b1dab1fb6ddc92b40cdb2556ed0976583d8440e03544fa73737b77a23b7498248f6a41ee8f276646467d68039e9aed44373f29fdc29b474e07331bf2564aea050893e650655ae10e50465a622d31ab6855901c934e2559427dd40d4feb9e87fedac191fa655a083b3246a3d0ca430457ec3054a6e0a5f1dcbebd73126ed29bd9ccd2ba5db968c6de4d8a8f158819e92544bf32b19d3effd97e810c1fc3f23ddc3270228b5f958b741972c6c76ff3cb70d551a22c50b1418ce54eed44b3c642631eb790f14b628b96f77be7a680c612c13f34a46cc4732e00e2ae3cc5df33ef072bd1411a2c05755775f079a08d709d0955ad3e6f9055fca60f0613eece6d0a50bae4e7906a66ff2b1cbfce48362226483dd8d9becbcc7021f500ab898b1af90bf94b40b591fbe6ac6222c9e68a8748763bdddf0c1b95c9809d68b4bb4173a53914440032ad27c1e5facf6787f51f66f817f100c8d434a63429439889a01f35ff0924290a89fe1c7378789d28db20ac16ab14fa002158f4f838f3ba03b0bd68424398c84f6910f7b2ff6089a2c03107fc3434a4c57d18f899cfd3882fc2c6616393ea93beefb8f8e986cc46ab53e1325ae35687d922b22e546adfd02ccc6053fc1f2043ac8a634560262425044da146208b39b9945db4eb66516e5530d594659a04398ff2229b63d825e8d032f6e129a74c58fe5614dd4e89f2a60d3384035ded7340753c52927cf8a876b903e4ed454c3979bb4a7ca339e52db16f9be8a155e2d6b4c6bae6ff9dc284bf5fedf1e3dbf73766c31965eff5c873c5ecb0430b13741883cab0a23937bc5538db64816e54e26a9863e606562a1a69f35b453045d984982ef95d27d169648f20c53b6906ff7b8ee68201e4afdb6ce257bf2ab5e3fe8cf8ed605675b82437dd6a794eb5797de66dace0edc54768274823212ce848292886da6378dfe39dfc48b111f25ec9ea2fddf80529718f0517b425897e4c84bf018046f076ca105d8643e106c9533f2e045b0989cc59a8871b491b8fe8481af2c3486de86166426e6e1837ab0323f195e3a4588d85588ecd5d725a78ce3c0944169186169ef08bbcc313c38e6a569fa7444046666874b66a181fdba3312b41aa411f4e64fd288d3f3cc8fc7964e2a3eef5dfd68222ba9d644e4fe0724b7d6a468b9d8e8f9e6e2073ef55b1de1448ae672c7e5fb08f5400ca94752761c2a7ec28b628d11c927dc01806d06e6dbff503ce73985085f4a4269060834a752c6f74cc9239b8257834f09b0559c4ca0ce9cc6f17f902cfd27803b4e95a60bac3f329e0593b5e5c9541a2072ee38eb9e9e396ce9f5760f796ebae7f99f9e02cc836246a0fb5a6608c8b735fa8aa0090b4777134b1e1d5b68d7d024ade9729e214088765aa59c821a0f7af2327e4cb2f4112644ea2a0ef80819d60e74f55a49da99ae2f0b4db19cb10a5b4dc59e51dc3d023f82945f83ed89e94281e5d3992095e5ae5af57c541522cb9940bc9cb312c415a7207206638b00372cb4390889952a8c7aacb0ce1401bd4b6405327e8e4ba5868ac86c7cd11e090d55783e999e76b3c32bed0564d7b1bef87a93744a0bfe381a2c6f018662af9a5f08808b3260a3ba2b0ce570508d0a09620e1177fa0effd52bafe626c7c5b1cf75cf02988f83bac54f6fad1ff3268f62494e405a8aa9155ab70d29b6d3f137a6b17944f9b49ca027df428d8c34277a4577c771c99c20ae6e017b5e2d8aba2ef05cc3dca83411ad91351b7652169991e4019c8f38637550defb19b38867b16f6beb784b6e6b5ab4e9c040ad4bac04c5f967b17925ee1dfea94665c2b0ee93cb8c5d338b9020b10086f0b2f34c4dc5872c7a5a30279e797188c27a2aed6266683858852274aaba5c962d5ff8b8416a65189d99c0ea77451fc99201a840a21a9ec2c0ee90761074935ebcf49af728ddd95b75c67c5c68075bc0a5ee8f219fc26b280b1c43697ee818136fe2308a1ffc200683e3c665ad8786ee642b4aa54be6c7069d5ebce91143cf69d885866420d365cbe07897864cfb19bbf94712cc96bf968ff497ac5cdd5bd0e17ea1ae62c1536d0294077043df15a6bb8ab4553b6deb966a6b870473a9851aae58cda5f2ad2761231291bec5a9550a40f0f8c53f5abd75a4fc0a5911b323ef6db5b9f2c065cd34bdc6d73a91388a3eb17835d6b812140707e3736b4d272a1973e9714c64b043aef7903816b0fdce2d3b4ec76edd451f33301294a7e91f49ab17705a4f8fe1025fb9b0fd6f92ad877d147c7e1cdbbf7e98cd0de9419c2e6c00644fedf8c43c414eb238781745bc5cad702d839a61e10cb6f0f058be7c815c219d786d45b33d470d5890ced0c30cd6e944ecac8e39848e8c385c7fbbf006ded5de19a21f3e743a444774f68ba75db99a3315c4146956caa88ec0dc507c1f17c8bba785adb7ab4e0571ca75f8920def78997a9f4dea8f46f629a31ed0fb9492c2343a6337a1d4bd9ad37affd73aa0ef32ea4fc900f154f7115c223548ab47d82d0025f8ef86fb0e1dc03d6e4c1c17e27d4eab3962b608ab2e94ca254e03add255eaf3979a017d86f4b0505fbe9a9eefc78b7214ac331265e936586c5571a404d2efeb7af5065b7e45681edc85503e4b4f97d4c99615cf345c5828c091c4f6d70771ef3b90f5788162b22955067a7274cd7c794431e41d035567bd4aace4d92b2b01710997e7dea997f2720cee549fce5ac1a3040f79e638441b7984ba0071774621fd6c347b8095c2eefc05f5c3548770b37c8bb279ff94811993b7ba82dfb53fabb0d65d1e1c8332a044ef61d483a797eaefa5e84eafc892e08cd82d8f7516266df7ab34a84aa32cb467d3798badce063e44e87494f5076c81b564fb24e6d8139bd43ec402fa78ca1e71cb1d283ddc0f34f09f8f56b79d98df4ecc23e3fe93555047881f32b573da24b220f14414288325ce7e5d319c8020714a060370dcf5f7fde6ae982abe1fe0b75f16874357aa1f4d70054f47ca97797198a687c5541c584180de22984f6cb3d50a88e611f8ce4f7efdc798493ad0e4efe1cf86d601e98727bad91a810566edbe6d64b7e6e641a0b1452425bbdb3d60870a96b5358676254027d38b22a9de676464518ecb7e339f0221ae3ff3e7478449eddd395f239433fd705d73b5b07459b01df5c5cb168cff702d1f2c713dbe4ecf6b412e4c118aebc9aad37f3afd154360e77ccd4e552753af83b8b9496ac041c52c4e4d2a4b6ad9b1d4f64f30f21bde914d504702f816d1d7c28b1e91fe60c2d0144e0e80bc9641aabe51124fda976383dd3b5e4c6a1024c068b817733ed831619043d3ca5ed16f4ec08fd65dc954fd19bee872b9d3ffb656017d646d6f7ccaba32c9fa27adffb9e57d361704d00fe27585a799c1bab2da9f859fb8500ab8f13424ca62ffa8e4a2160ef699ac05800ac5caab606f3b1575fdacc04a951018310a1817b1562b8310f63cd0deb4b5462c141c4c1510d9457b0799ea0d70e50df72a5e64180c7bd9d2336f4cbc9a9d267343bc6d09aa76cd778813301e415c809c5b1b6f663c97dc6318efdd12684603fa5ddb0f7ddba8c15ae531ab40fd2e5e8250b68f4947c9d797068f86811d4348418c625f4e0b741efa646b0aa71d94c569a5f24113842509355dadf51de4fafecd36a34487cba39457cd64e9eccd82fb6510c2838b9c9247573c89a36aefaad3540cf87673cbd42e109e8d2577183ea2931d919bbb6ec4800d0aa4b0870817dd36a4555365895538cd7943e7ef0a935268bab99b9d7fedaae86bb6c49784b272eefd001ae6f6944031a1be8d972cc7811f02fbe82776b3144d40329a084e33af16ce20a72efbb2db8305bef6c22fc5e96d1cf6e604fca339d0362d84f9dad2bcd95628cb29a227f683f806aec8d7d1f0127bd2ca1e4047180dc39a6542058ff8b1692d97c0a9188427ffb3c4dd1c25eee913313727e9bbf3b4528d709026b6b4801c0d275ba57f2ddbf8c17128760f2036d14af6cfede8d42a063722cac10ef5afaa39cd6f92a73a6f5219f4fb8c6f4de571a94866fbf9aaea7873032bbd969614ea5c89dcd7e5b8900367a1ac97d124d5b9dffd054b1e8b941fea706569c28fed0bed2830a7c24281c4e22fcede6bf234e659a20c032336fe7c65bb1c165401fcecf91cd5614563ccb0885ab4c08a111392ad74005dbfe7dd0a0c244ad8d234bf6cc6406830565f363b7fa067fb27da6d59fb0012a4950d0c3f090ec4db62bbeae89571c333e8c52d486be77991862efa81c3508870a0efee984bb660ad13f2c3eaa01947156dfeef6bcdbf9eed72e94d09a53299e77ce3315673f4b95f942d1cc6a4e231fe75368087e2cb74937fcb337e6d89105c8b9f90cad49c7266baaeaba0b9d9cc90417f654401964983a02a4c938e0db4ea786f20764f9c0a4c06fe9988bb629a4ce7036c47618f5976d21e6d07ebed13391ab653bfcdbb86412953d9b8c83a7db5fd0a33312e7f94e4ab60e1d6e4f9a411ccd1f4a08dbabcad8c54082fd4721013429b0317393bd4e532c4b669d75c09ccabe03d3a7fdd1e428beed3d351e06bf23d170bce4ff30fd15d344a6fc0af509636f7b010f906d5b4d7593b8dd2fdb36a8c0bc0c6d8e2ebde255af4ff2ee0f50d6bb434cdef0f3692e6c68ee67a9f5a9c40698eb6e5dc6d5d76766bcd7354d9658933cfc28a6e6fc826ed53cae383b5f042ed0aaa5ab1282a0e70e6db80cd3c2a3e7b2ad36f027f1bcb26a6a1db2e8d540f8d23d353047d2bf2af500618d5b76e1f8cf5027af5016c955014f0699bd8f6e7e68fbf736ad1f7d8ddbc0e9cf4c8e9458b0d07069e2427e0c7b5b240af3deb74473d691fc44a7d2c2ace440e66d771ff3aa65d5b304156af0d6de1bca662c408faf10a274ee489b34902965574bd7a2d5466fd61c7411240c18e815d08e7cf2110a2435fa3c839fd0dd257be930f586433756363f9ec9cbcb1edbb7eccfa8cafaadfa09a88b8cecc82bd0a94829f8926acbc56de705687dadee05b9524635d27ff2e7bc7c2a5296f305a6994f5a4226c0651a573dd32ce28e032b4364ec6e388e1ae754316235e4efdb7919dd6eb460518b595ec1f1e86fb4179cf5ee45c99a8a72e38861c957c82c20f57cb25cde88b2888b1b9d3af2f85bebe3b7bfd1e1f990360da11ef7f7f68da336d98554c77d16770782812509c503f738956e9fbaad4eb4e7cf73da8a42398071f774b4916092bf6bac830a30274e6dadd732445a541fd108b0c3f20892598b3132ea40ece9d063a3b26d202271794937e425482c643b2f6c59ab1aad87347da5ca94590dd85b11e1420becf9240f8dc9199348e84e29d892eaa9bd3769e81142eab7820ab36a4451831f6cc4547e234997aced7412ada096b8197ea42b056e5fc3a4c846bcf25f995d340556d8a429b12c693123f784ae176b7ad4fa96a9ad5bd45bf7633a38afb0e7760e4feaf8293c75e7b122b5c3547c4791cd89282b24569fa799cff38b91d50c099e4a01be42beb75b46719fae31c4866052a5f0697e220597c9a7c735f83d8f702314acaf8bc9300ec5137ca5064181a5088798b5c50e62e55058451967456dc3e05a796bd9547ee7cd126ddae333f6032a78f14cf557b7e3efc2832935fadf330570ab2b6cfcd4a2ff82e3450199fa86254d324e3f05447177f79b997c07068899a3d086e6542e49b0c24a3beaab4db4fa031450cc23a00f04ba89aedae684b0e2fa74e4de79621eb61f89788e800af8d1eb4f80fa24fb0a3efa0a35132f72508ddd6a3f626c2dbb1cde4f50daa1a17bc8441a01e437c30c9d74e72500a53e62c2a460d0dcb4b27b4eab48513840fc409faac42f0ed64fdd5a9f0eeaf1e080e0e63713455e8bb8314015f172c253792a8df4f072ebd8f0c0587689cac76e6239b5059170a5bb4ad5472023dbbe5a7da24dc9541fbace69f3fd9598d5c35b07405eb1d41806348cc653feeb442e6413e5d0b5d8ff9cd16e38b48ab5f671c06038301e008998a27f78356bdda06c32e2e65c8d0254b08f2010160cc44d972a530879a9ed435743f15069b77d35f9e8f0baa12d26bd794f6eda94afa6a5675387e94ec388656caabd9cbbe29ced3a6ea8992dc49edd2392839bdf7974a46ef5859508df1143ddd8e46642fcf778e76f8a1b8c57d5b36a23bce6efdf7878e224dbc074cae139bf46ed51094c68cf82b1b3cef9eb32a126820bba01322c05a98d355cd8abd0b5d204d1ced63a282e63bc1ff3aeb201132b5cb3473248f2e9c94644e46ec5c59dfc691957df4f8b3d2869687eef7dfa33e99b09939c65ffeda141334c230b13ae31ac6c77382727a81d3e4307f22b3e85c18299ef79ac305fa1bff4415ccc4149589f44a7c6e93246d71fc6d95ffcb91bcfbc1a625ce1080250cee502d4d60b3b50543070531c4c45b27c6a6b032e53ffc091b8482b27f1666b84b9f3fda56f81d5b10b0b4843106597ad5694b227e831cc1c592e6e9b730fb9294577638c102230158384e241fce70a9a9eb6a1d92ae9f7897c1513e55925aece97d828cf1c3529ba022ec6e7cd5d7756e80d23a7efd494977925205a7505ad5d695a192c8992b6bc85748bdfb2cd4bd47e523df705a55a63c5ebd855213059120339ae9d2724357d9318494a993d6202af9a5e24711b966f2e988ab16e873a63a2f9f90188be13d53a365218348f504ad4fba198d981b064436436345d758ad4b1966e4a7f3eaa04cc571c4cccf17501eadc3b9feb16c109f4c7b4215a45674759f651d37489bd27081c7aca60f558c8b834529f55e79c3decee72cbed4d8c4ace2f8637ad1da6b42e93da01a2403b2ebce116ed3576c8ab922accd5694da313d2ce21d26a5f26faa94f48c767258c7978a6dfcefe64313923deaa82e9d03a17b63b9914aeb4f84fe88c3dd893ac05eab6511189ae71498eababb0c9d7ac368f416d81014d536442b1d038841e226ba1e0231d188c4d43a6f5f61ef0ffe6fa86fe7a83405b8e16e02e3d6f844fa24de7cad462e165dddeb11794dda50292f5e6eaf3ec5caa103b585cc33a0a00188fda3d79fd146d20d6c83fdfc1fef651d8d2f2b32807e64099349f28a22613d48c35a54bbf1cd5c30fd8cb25a75dd6f4b1588f9b322828b128e6e842d134ea040fc7d21dabdbedb39e6742a94532219d9ef3b0df4ea2db2c63a66738184a8797375f811f49caadaf102b8061a01d10dbc592acb88e063175c5b66155f7a02f61b9a3315aa04b186a962d2c0f240964294bda10e8e5257fdb7c1976d9e1ed80fb8889c007409017083e3740db1fbc65e4f3bedfcbfdd371045aba778786e6e3bca6da3456cd962125756053b5988cb03d86206259e4d9ed5a63555cf63f026abc220b7bc6e2b0c2a9a92a184a944487455f20c7d43caea7812d76ec92fb2f7dd64a5e35976948a0770e1d74d0b6cbb76e08e7e55424a85d0dba9e4af69b2b7fbb7f2908877de4cb6f958b405acb10c28d6e7a033da7cd5fab9c8a2aec80d33f147e06d1bfd38915515f5bb7edc3a6146bbfd8eebebf71fabcde2b7bd5ab3caee9db540efbcf0b7e5e1d72b4b46bb63cd6296b7232b8989bd2d2305209a4fe305e9fae7c135c14d19d2ef182283dd868e41ad72895681d24dddc356dd51d39ff1a2e1e1a74abbf549f4a724a6720ce558e12daacc09fea8c160ed4258b3a687fee18d322b48e3b4bc91d2f77f73c9c5ae58abf002896bcd8de9e86b82e02526330d05e9068e103a743cc7358b0cc1a429aadbc3e6f47298d02c28329a60fde3e53eaecc7f3604e04c79756b60d890845c706d7fd3ae6cd7815d63ee75402596173510f5da5c01ac29c8201564d88666d5aca82cc24b76148ee7b52732e66ef1c080d670067ad55c9f2417481b3eb19e0d31ded12408ca78f8f45d3a06362617e9f91a01e5fa8e8129fabf07c6e2c80ded7874bc8a5df61457778a50da52f86769ebf2a9c196350d2dac4101cd10ec17365aac080a86ea98e3f31ec3f343d2e4eaaaaa0ea906d979105da686f686ce21bfe331b5291454975a9c0ac37de9d6c0a224795cb8a0d905ad24a99bc35cdc7d136370f68988737a6a240e8363a91dc4081627ac74261b536d4d74212c9bb1b26e4af9d042e88a360ad3ff5c031171c27d62e5723b6ac23567041d9f249dad8d64105c7ddb85eeeaf2ee0ad54c64ee76091109b1f8d70cace33547dd17bcb2ca4522e322d60419f4143e8152b6c0073266a2dcf6c1ff001898faf1d3195813a74af9d4ffac421e4820f5e164da3616b69f3aec712c7908c3d2fcdb248375321fb4006a412a5fb80c3a042605dae1e76493f466ff4b4b87d42eed44ca77bdd20d1f5d059097b3ec5900f1ad4acec315cdb331468c3a78aa0fcd77cc88f70447567a444e34de7e3c94d5acc00ee640fe0cd8a9b0d9c5a2c2ab1cdad7f3262eac41da7c7fd417c87029c79153cb7cb16121dd33be3004cff7071a375a6d2315cb6438c601f5b65cfadb7fbbf9a3f477fbf64143b5295b77c9744394739425d045666ecfa73ae3eaf7f7e72e3dc887ed5a63e2b454467ab043e12cd26cdeb7c94f9c95026fc969920ccf10f35aaf80402d40b5f6c5d680bb5dd0fee01b4a332758ee2923c55d9f5d34179d1d9e1fbc451edfc9d0d7b47b47c17b2c04238ab262b8a7042b7f4328dedbdff8d39022afebdd2924d9bb4167121b3d426bedeb40de37241a570d57735fbabeb0280ca0e833a509262f2f2efee8b8c49c321cbf5edac9a585d80e4c48286338e8a1c3732eda1609f8417d8463ca65c66eb6e17f69fbaf7ab4ed9e67ac52839df4babc5fc72885a1ab4a4198492b86a5fbff459de81279ae0f6b0ee09eec00214fd58c1e4629ef20d2c5ec60e346b18f1b24e8314782b050018d6c81395fc1ef17d0073cc93c4ecdb8d5628b55923de8bc56f21a78e61e48466363842caef733354f3d6c066079b72d7a6a97101fa9f73ae5146af1a99ab5c9c87199a332ad9646659a7561151e9f24dab2b3131af15f1505649c2faff5e31cb838fae9e1600776f6864236fa047c2adfd9f5b18a7fd20320e8650c3d4f59c4582b3af21f41a25a83fa46b66d2a2f92e3721ce4fb5d099419be31d54397dca2f937d0ee0ef6c18ef1c7689228283388f394c701d95531553afbfe1bb1bbe0bd31c8d46da12941ec2e3e316928545b5ead511af24b9f3515d83dd063777dec1824e623412862635b602930a981f875b967948ed5956bc49db4f21c28a0e9c1f7b80b2d74fbf345a1841be36d9f667a2c9514841beeb139b6ee774f84bd46e05a090820c097eaad2dce9ad389fb57dc7b58bfa9cf8819254b1325bbe2cfb1003159ece353b85bcc5ca3d5a267fb59c262ccb64974636ea1f3e63f832a42fbbbca5276e5e3175d331d116b435d892a2e4e43028376f824edebfc6ab62517488d3db72f0603efc453b46895b6a163749de2fc2a10fde6e49429ac3dcf5be46efe452283b75042f86db5db73fac45b22c944d442d78e29935f6e72f727f436ed87125309f4809861cb637e276fc1aee0da10fad3ee77302c7e5a930ef97de76dee9c4643446e9984b35cbda4e371dd18f1f81ed4a5e05a05b0d050cc1803cae2d20bb4c6a2082da8a07a4f5fdb1303938ec5de952bdf48f450b1f2b1fadba91a0ed97be474ad68a16b939340b9d860c98bd83bafc7bbc9ce0195eb1a0043a1c355268e2dcab0f6fef508bf77bea732e687d25d706bb290bf5d275def60ff705768503f2298d83ee1a4f4eb4941d8b2f5d9275de03c41c4a2e152e54d1153d77398056c084953570fcbb59379fa85b0333ef5e4adfbe471123b3b415daf2e096655042a11b5a9aab7fea92359006aba9bbd112a325e37654a59a19b61a7659f0b88746a0c1702067a6b45c942818e08c62c0a9da605da3ff77363fd8c14c3bc54edefdd4c54634c422d6d83b1ba532eaf9b6a3dfb91ca8b25ac5cdc5855f98956f67d2b543f6b2d55026ed22ddd6ac7db1d749d45401bb234197b429b2ddfc8f0e9bea5d60ea33b7e03a2969bde2cd752835db29b2543abd4bfea4830cadd5ff3e726c031fb648cb7ebe5622b87d7bfd1bd2f471fbdd9245c727f20eb40850d082b3b43db156b74264ef6bfecd45c941354fb14d3f94092a2b67412ffc41b46bc2662e8dc024a0bc9c553bbaebb34b55f7b175f4e3576625e8438e8c566f26ba300fefd15f961f296f8d423cc49fdc288d2f1753c46b2d82c8f6a65cbeb3d17e12b2c9b2dc6da142f38243555490a7755fed51c65c68e409f237ce46f94bde02300ab3893ac981275d0791afc2ea906ecb8f2a6f2427919d16b5503c0166fb9204c53c83a59317d76058a0a0bc29036494b55018b0d5c2e2b44a8d1d679a2438f995c195c812b169f095adc029bed201886aee1128cf5331e1131b64a1fef978aafa1d8d34c5f934dcc6364f8f7493c3411079fc026dcaa08bfd507a580e96d6d0cf6bef52db17ae8ac41a1b6d5e3e5072f754429badca4b2cd1718822d8e5a5ed824e2440d552bb7ea14dfc83d35a20f79ef512b6ab7bd81888e337e9c78cc6f619340062bc2a2147b9df178b8a195380d7360a8423a1771fdbdfdc32bf942c712105b6865113edf7de20317d41e23f7e34de57fb8d45f9d2c5634fcca58e81c065db1f16295f9bd064ea5f357daf1d523303a126221ae1b1ebe24129c986e26812cef2092b5128ff2eef60a9972fe7ebe477cdc83dd34596b3856703a4cae471e8f493eb72b1ba5c369ec4388414ec3d82597c0827d14351ace82457b8bfdbf079c4d776c231e46f0e8bdecab579a92876ee8ff536134813bef0e425956911170d39a193ed7ae9b57e68c3f98f6bd332185cd5c5554d39a2da167f1850f5d344370dab56fdaf218db992ae6ca20e39be34136a41686afadea0191587fd4691da22e2c5b87c5c0ace6a3a8ea95ccbe8ac33844f07895c63464c09ecfd8937a8970ccfd5682dfb131150cfc1737488ad690e6b121ee845ada912f5903ba98dcc52326d79c293ac2eceaf7e10f3f5abcebb621de37883f59d640c11bfbbfe8fb151b8d2a05cb17c1e78bf055aa6a047ecb7cf746e4e6072b862ea20f75a0097a523877fb41b0ac9d35bd66660ce33a69b0b8539a4996f83685b323456e25a622e27bf9998539ad2619fb0e119d7df807c2760f91f680d5d109bada5593c413f9f060884160188bdb68d64ffaff89446f6b9dc5fa2d45e0af8b0130b123b5a9ba92634ae03bcdba205ff3d3b813d15d2181e0a78356237d68e4a2e4f568b06534b3ed96276f0bede16f174aa592e7b987137349d20f9384ddda56f7ae356bbd8a5aa68325368401763d5d2f51a5b72462fa9cda03a4d271c5b6cd70a19873aedd6f0a558dae9000098005777053a10ef501ca9b569d1c643ac9a4ae2a7ba3ba72aff6cbf42e8583c14664d786ca314df76bc6c5b1584fc72d4bdcd6be83dab5a4bdda65845265186f33c7f37872666d8b3bdfaf63c5ce1643067ad6a1fca749c59b661f6f444512a8614db58c1cff33c87d9c19893d3737c6acc644e429c01792787dbd6fffce710adbf7c86ae197124fcf7c386516c17fea42c870b1e9088a234eabe3d45579f74d23d17f6e58667fb06919e1d7cd6d81df7921297e8c4f9cf02811b23819de97350dd278225b8a737ad50b3c56da96ce85df67028262c970bca0902a43767398cce116496d3c1ada33e211c4532cbeb1f49c8aee14bb0a1fc3f8b43c1b2d9698486232fc9574a718a149738c66c04614c8f1880fdf3981c5c2690e8e4b2a91a9feaa6930fb72355226b1a7cd0af83195b99602ae3ae328d13981cf39f0ddf42356c5ed392c995d300f29800ada57f638d853e21df312ac9ea999ab1be012608e848a387b3da5b4a20482cedbcfee547f05a6a1be91671f06ef290bf2a69db6a28363ca3aeb85dff16498141e36fdc90d57b332690d53f6c26d73175b828eae46458911671a59a55d24edf7f825dde5ccf31f33a38d0fa928ce68653b9132157100c1a7683b1b5ad7414c2a8ea19a5dd18a19e53c203f643506c63491da7a1df6ef03e14e2a406ff2e254b1bcd20f517b40da1e1d3df1f65a953d99457acf108fba3e5261d6b091ecead81e3f8372899837837fcb6286c2712fa20e41630898e205e4141e52c5afb6dc5dbc05e5be994af5fcd13c5abecebeeeab259f74dc8e9927a081dcaba824db5c27dfa89df1c183e91fb788fe222bd60e96e1d85ee353e5690f8776bae11beafda54669044745286b37943e2883b5ec3eff111117862fd789f3e7094b096c44d3a81720401118804413323621265dc306785c964b8f23423c348a851d3799dad34d197aa527dd78fbd3851ebaf3ef7d101b3f468a906e9bdf37fd0707bf560f3c8348f62346237785d9cde0eb28722fbbdceed231e48541ea224ff58a4c946f3715e4d9ac8ceb51056497aa761663fbeea823eec031cfc11cda7ffcb41593e7cfae92c506ad1340b0ef5d711424b9dec8c1531ae491f2e5655bc97537f291e7c151150d8b5e0a875b01006cf353d0fb486be397d6558ceca8cf6c5a9259d469db6e250725cd50ed96238243b85b083afd995203bf9ac3f598c71a4cd59c32cc9e659994e26db0ea9121495d1f94d7bc17e36c48c8a68e1db93bd1d82abac79bb36f9cc0d3e52a99d7ded3e574642a8156a0c4b2c0a872feaa9111b7638cbabf39ec297c08bf63ab4c6797452bed8f976a64c332f1c04c5c335406c701d99d9a804870286e91e829ad48f1225dc7d848190b1ca0716f2475d9a89824f0deac5b1f8c6de2715f9690d768cea6bde77a4a92e542e4fba72ef232eaf9ff67bb7a8a11043919463f0680277895c5db1effbaed954adedd18cce9b75f7791fcee995fb1f5ccf7832a787d5900acea149fb1ef984dff5d61787a9587262f51cdfb3eb381e6e190789c0d66c70b478e7ffa9c66f90072881d7726b1c1359154efdafbc112a02d2c3ef576b4b3446304aaa4cb665be0d084feedf249cb8fa3cae1c48a7140bc93a8a1b5278fca44e6eebf86f876a43b9e591985903e647435ce4121b7a7158482f7b4c0172bb6e5a0d8f19f0e2ac42fc93c4a119057200d54f6b78be6ad0f6fca07042d9f5a086833d32971a42afa915995cdc0bbf09f467514787b01f74536f01fcad9df78dc1e4654fce7ce1e9164c582ac803136eed1cca441cdb9ba5ebcd8c7711e022bbe5bb16b0453423faf8148e66b1b8be56b568c5d5b4cad56ec84354b3a95d90452b0a366d1a0ba215d3417d653534b2dc51d151e85e13d9d02daf2cf47e52fccefa42ae1fbc88b301f3ce88d0db48a404b9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
