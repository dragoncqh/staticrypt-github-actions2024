<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a92679a0b09bb8413c326b32be5fdb651560c8d327977411389ca2172a0036b88e26af703b05cf1dee5132e362bd7694b12a9c5b342e014a6f434a573e84098fc22acd51916bd4642a2f9242441bfcf6d14735df759469cdd0f534e57dee476dca3fbc520b8c90868478c1d8a358024b4dbf35ed590050aa71e3526b6a0691c0abdd573906657a25ae2185f79ec286b09516f7bd989a2196abd69d536a1315993e02d234251a2702214f96af5ef65c7684c9cd802deed1b972e89f34198a134e4b9018f188a4645cbccae71a607f2344f0da055294d46b75294b09a0b22401a22fa67374ea824b35060a6bf38a478f6a18fae8aa7a5e6fe0c761d79a5085027eccd7f60780ad9b495a171b6517ede7eaded5d3a5cdd266a996d7c64ba5ce1529cf01c760de04e7b3ffcb7c890e19583feb93f5000081a70f3d6322d605d896506eb5d49a13d197e4f201c9edac43e624f46adb815179ec08477eb05f065eedba8eaf6c2d2eef82ce107dd2d69f65d747c0c8a8da670bbd756d8c34edcca2efe2072f30a4eef1cec696412d36c7dc82a23d1514af080d795a19f5eefd0e10afdcfe23680c31fd1ea74dd043a9972a358f5a5995fb2758db3d582de82fc1854fdd22e8da945d5d139de40e89fbd4d66c61e12d0dc972665d826d24fbbb49ac516baab61463f41537f2fdb7f6a24dc046dff1a620ae0ffb7bbadb406d33e22d2344809c0cec1304b92ab0a0f306c5e9a251dc9402e900de314c9c01871c797d8d7279fc63f85c87d8a4e13132733801a531de6eb325b973c8532d77961bd3790daa3066ad833de26c70849e85b42161fea742b2b35de68ea6e8f77ab1b47393d639d6b8dd9635860964e16944eea8820f804df38d2eb1c52ac4d90e99906e19fcb15eb5ff9c2d88d33e9bf878fa87760f3da7bd3325e3e1f0d995eeb1289f51fa85bdadc0460832ee646de3e20fe1fa7b1aa7e3762aeaaae56130139decc16213ea3aede25ae1f72d2d2813dec94e3d603867e00c02090430afe78608034c12cd5e358e176db471c520775317dcbd7e66164b0b058114f7483ece6f5129edccd86c8c05b1dd073036559cc503794a7d117ea3109add306462e374dc53585871d500ca0d057c842ef1e25836fefd1406003bff87c9ddf420efb1ac4a9fc5547390a43e4a5d4076a8ec3780343e60568690bd3653fd67964b301b3866929970f641d18c63577b5cddba06afdad73d6c349646b82d18ec18e1f386cd00879a1e2102773790eb6f9d805748b9aca06803dc4c02e379e0a99926a434b9a9a83704904d2b2df6a2da4608a4ca1de70bf73ead63b9887c9e899ac4e8037d0ccf7244844b3f285afdc215135ce10d03c0661b6d001d96224106edcf2032bf257fd9b4ab77a1f137aa866ce19f8b48dc20e7d0d26a1a4e9b9e6caf68beb2567accf0008ebde5e5d0e3f417bdc85fe95505ce9ad79f980ad060833f604d2ebe9d7283de7eb58cc9e9bea1b543bfe9805c215a44228fc6c84507fdfc14c58b37a42c1e8d3b94b860898777eecac62f2000ae475cc9671782d16b365178e712cff148452fd8d3c8c2f54f6f46b1d875c9e3f5b84e656aa51f5df2115039aeb9bd4ab5d6f1543e687d6aaaf3862a69aec03671ac8e7e92d2fa2699ffc4d9479988339d9b3c8f80b28cd015edaa8f841965022245b61cd0c2738d94615b349cb57ca9c8d3884532492852d3396b17de8683f7d6b399392d431f760906660aeeb91aa314826c837715210be8d71e0b2f6cc61acb89c8dbd1b6ee0d40dff3f6ef4253f475b0524d25ef3c6e43947d1b9a7458f2b1e4c4551d5104e53936f48021a11aa757f6105871f36a53492fa2df94b41f685f7f1785cfc8ff362994891b26887eef4d2483f818b3864c39c9a6023880f44efce93ed1667fa37c6ec1313435162f286d3ea8edeac04f424e6631db263e699b704bdb3e7726e43845e9bf4e9f7c4499fd605a377827f1949eed086c9a3e19061d381f82dacb5771aed522686f67fd5e3086cd7d013fa6a2cf82640adfd5e187f2ac7da50da340c98eff03c700e9fef4462406e6bc85c09d072a4e52d2ec9cfafccd836bdbdd2dad0b50099afb930bccb6aa3c8a4c17b64e1643e9d30d05db3809e8336693fbf471bbf8b2d175754dc2ad464e2231ef364157433b369dc4cb7f57448a64b6ff95297633ce6e8388782dec81fbd846f3835c6da0094767bf7676d194d5a2a3f868edc016c65e83cec12c3726fe959372d6df0f7e051fce0fb6b375b2d520f58040e656886dad12b982cb3957d8915b985583ac2ecf34f8223cc9e7fa9087ba360e454ab5cd98ad2023e2947123bec09fac46215fb469afd5806d256242e67224eb79988687736f72eb87577610ac664bb6d122d1a286457187e826f5b7726db25d5143326f5c16f230028768f9b59f447f9a81a3d0fecc6204b4122f8f2cf2b039f1646f1a525eedbceba304592bba831379cac5b0d306666593bd9b0a30db7a28a8c658668e13a9eb7b1c4adea1547dc8bf2f38b212fdd41c4ff9498f830b4d01fd5f4923bca5d351f875cd910fbfb91558ef1e7ee2dfaa70007fa9f97caf2426e3591f64ef062a492f9601c47be32f8a705e527feeb5789c01633592e8fc9649b43262bc75eae5629242a00eb79eec3d35ef6eb1a459449342826df61cd2bab2a3d06158a3a1c882608f7281f069a0890bf0e02e47e32cd9843448e1abe15be7bb1cdd3d1419db966c8bb70f5627eee56bbb06196576f470c375b469c0f7168d58f1e140c80fd191d2a2b2a755e666850e3120318f32d631edcdf25f022c07c119366bb7a3cfa3dc7aeaf1beb113f50f4db44c48a2cd74a714371301a2a05310f1dd7c6f5528b09f0a28b360a6b2fbed967a54404dd5a49466b64760b547b93fd566488761c528ebd41900560a47280fec16bf1e16c79bd96951706a3c809eaef79754c34be66f0158bbe1a57cd3e71fd4bda3387b6eafcccc1eb87ad992185e5c8b46a208d6b75f04d958bc39c616dd30d4ef0c4754429d9d23e991590444485c45ea892d54c80e2dedef043e82ea07b694feb8ed3b43921a9bb1ac80fc0a0fcd2112abbbb89c13bda6f9b2d0f2d560948b99b519f76fec35acfb8a9ade5d7044eabcf36fb9bb9f018d462819100c789aa4f17f2261a33e79de5b7e16c5d1ae06e2e28bda1d92b2dba5d0e0f0c8c28695338554390dc11efa3eef937624be920682461f199908c3605b12b53eec22ea550179ec0f474377bd641a3dd99e93ce50788f9340df52c47d50b6033f0312408fa9d1c3bcebee0670005b9224a4352dcd94e96bb265efa3932a4e75606249341b01fa22693b6a53179f1a5a56a875c1fbe243c921a583eaed11cedda0dfd2d4f4800e6bca41a8958d87d536733b31e843887ba5ed7284c926aae9844e2ac2ecaadf7a0cf0ee69e4352e2857236175249778fbbd476489d556273648a6407883371497b76962f83bef281e8129c3927fe61712937dd3581c53d3fc751236ee5ced5c34258dc503faef6eabffd8731dd74bd1661456627c7aa03e7213c0a2b5c12818129b9b995558f41db4b70cb6308bcad5f64bed5ab447254cf6752d0cf051c0a6da5bfacfe6c1e841a7b4b0e0dd310293f2bbcf40321e86d9a53e9f1831cfb1a12df33e3527dc11a863ae77d22f25358aeb4095845a3bdb7da5cbb585edfda64ddb491c6d24585452228a7ca38c109fe643cfa5a6802b31c4cd5e01e6d502518dce8f825f610993ac04aaffdd9813f59708fb2554d9cfbdda35bb0edfee52b0d6ce0d0776f023a399e8f63331fb404a35c400fe47ad9d4c52b5783bec41a10029566c57e60bdcd3cf5e0f0ca2d97810dd5870ca7a9ebb600b8d175e934c59acabf848195e051a6840e5b9b542cd338f621994ec05a0c8dacacbf638ec0691e215f903709d7c373905d0a15165b9a92618f257d94f70e9d0790f2f4a988753413cb5376b63e2e26d90bf4e895045ea8538221f69f06c1c63533b6a5ceaaca018bcd16b109fa9fee572a5ad1a5ba4312a906f800361d0de548aad8c3ef624a67fcac89fdaa33739a7be0499d3664a0e5250019edc2cc0d020151b394f874474802d3328c04c345c4c5c5842848b5c2308e50c0595e546555f85b5a84ad68886ea05ce4a25d2cf58f75b26efdaf2d48cf8090870afd945b849ee78833cd4c6b13ff6112d33a46b0f080d621648e6c5b1194af102b32462769f5ee7117a3b63b9f1afcd7821ef65b5dab84c9d6cd6d39f59115510909692f97eecefb3e23033528400a4a1a2e22d91dafe0d9d6dfcce1bcb9a474a79924c70e97b4bf298dba6d5587687df2e89863a7f8fefa5a093122cd263cfe5776c5ceb45972ebf25e4ed6ef0b5cc6df458a4396c66259ba3e69eb36f2fe55b2821f0e6addb42dbb902fd803f1a020fe57e7ed2d8a27c6d375b087783b4ae1864fc104e9fb70992cd5557296edac63cf70ef680638b6e3986913dd76aa8c75bbb09ed9014fc001b8b29bec4e05bfcc4e762b0e9455c8c6ec3cac92dd62b445b5ed2f8ae6f30b6791b2058ea44752d4f30025057f87bf8fc427c26e0c62920c6bb95e802f1f37274f47d3a02af47045fbe5b6810472fde850c2798265fd3a726e9a991ea9b1bd9b4502129c96f9cc658adbef48ce34c7c795b2f35c69967854eaa26128e97ae95299f7e96ac210ef627ad6a7ffedcce47f030269170f8bc736bc89ea8f208a190a7b87605b03bbdd524e46a354bbb264669ebea8278a43b7bf8bb4ba12c8a011d87bd8b614f66deadc916d84a18a6ec3084dfe17c76d534941b072026bbb3a34ce237e35969c3455d08bd767afdcc7d7b6e516caa5e74a227cd172bd2a5136b0d406b94e4357fdde2c93708bd548014192630ca201aa777f1da143c13d112895484d256cde62bcbf02c1d22471aead261152251f2e82a6e9c0c4348a8571fd675576396d96c151ffc24698bcc290b6727ff9fdcd4a1bde3de6c30022ab8a1f9d601b05b23a057fc86b2074dcbdffd057d773568cabbfd0b7e605d532ff07c74af0191179c3d2242837e20bae9d97b1ca39afddff217871e6ee8000c7d8894642bcaf14fb09be5622cd3aabea86ffaa0350d8a8e7c43dff0e1a47e95001cabf18980d1bca4c5d61c8c38bd44db5b978a0b947c6adec05ef26b35c3870a61ec27549fe60f42c90cc5bb5c9cde197e140c1382df2fbe184e21a09c46b326f8ebc05bb3c89f2faf211da026640f916111a398280839addc6aa7a2651506589fc7c2878ba772502eea74e15f08477f76eaa2a8a8ae920eeb56321efc06c88ef4e3b649ac0a680a7805348013747842a071be18a08534bd993dec37e141eee8aa66072dd4d2a1cdeee0a23b03dd04be7bb63a83945737f0da77d6923a0b0eb7982da121300b6158c4b01fec788e638200241ff0d551689340c99f32bb9e7ecce5f9289a16606d6fa3e00cf26513c6f2262d6ba4b29a7a77bcaf40dad9dcbabcf32d97661446d49803609881b86d189ec9dc821fa4582739917c43059d1932430098b22d7ce126c6bc2cbeecd7a9c7d3339ea59e48d6150c29c453150cfac0094403c4f50500b32d937d8c8e07d3a1ce9e67805cefa6adc7dfa20fe86f5d3b41f737533ab382a15a2f0eff256e93840b5c0d7a06b9c38a8c7738dae05c334254db404aeb8659ffab1217e334ec17ab490ca418f9a3c4dfe84960542519a7bbee3fe70077eb5d5a68c7639329881c43b1b7b69ba41a1451d2615a7d122d786205ee5de4e7431a1525930e32681e3cd3334667ea91f65c04869c1b57332df22edd261170162117ba985a10717718c45299c13636a9c3c7f1a2259c8b7807cb4a963ed39bb118096a14a3430845a1f02f82b57b0671335b98c7eea760f02b6ff833983a54dc6067c3685b0e846f8f7d6f56d3abb9b556b9a631d28c636b24ce5877def61035aa4aa50255dec41c8a545fc4bc917d88e84327f63ad03008f69bb4a4bd3ef2560c87e64f67642357c51c9709faba7fa91e71ece38f64f78c0fe65bd458ac80be294ac3c2bad60da8ee852b5500d7b4fa446435fee36eb6c1abb686a3ee9b5d9a00ff4c4b87c270624947fa7d2e236567645132271410ee28e9e59aa6a2dd0bc9838c7fd684ff81ab8e42671ffeea8163a75520345fb90b3a8d2c622663d4dd13e1af480c7b834560575a7cd7a8b9c3204defc8d7a934dd5c3157616b0958fe051631553876c3ed327123e53a7773aad9a923faf50265c3504281744257c79220261ea7eb8700326f64b8905b99d669c2008080aa3460bea226f551335165de8356256b170a7c53d0429bb76aafb8c87451d852d8148e864a90c799994503a72a9171f4c9f92d2dbced028cd6ea5970c1c057aeefc55c12934803702b4797dcc9506ff08e5500b761dd83e94e8572a506fcd23a23a271b8eb3e3e566c2e367d57e9eb02277d13911c91bfbe081973cc8ab710a259c344e15b8f90752f89c751efbff262f7731093b1d1df1697ee0a76bfbf374f0908c899495e397ee3ef99f42bffd5426f124abfa62b3a330ade9255ab07ff2c0dc4ac08df17163ba02db6ee6fa0e6e4337ffe68b8f8dc8063af7bc74c79182ad58dbfe5406daabe099f16e76c2c65805ee2d44bb67a74b929dc91eef257476398cedb6f8c06c74de9f6f18dedaefb3ac6e0ea0db129ec0d3f2e0a67cee3cf034f9bad2924421fb10c6d46a64b5c31d76c320e945e1a135ebbe724935c64925a0245f2ee98293758297dba04560065e9b142884edea68a43202c175f1f24b127d2a09522ebc27fefc56dabeca319f733f3919f9c089caf8c138923adcf2be13874e35a1d8a12be4797eb5c0e10a1444db739b8a00432d97f0fbef92d545d1fb393288d1488263f5f1d08106ce3c9610207871ef9ffbe865230357ac8baf75208acbc3da90b5a3644923a8c4ec601dde717f7e45699932380def7ceb238b39ba292547c0352877802487c9b1b6b4add40375d3c17cae1eba9df75a1dba793cc70fa9058d6c09d171f53efcc9a6e9c6b860d6ed2dec3f58b34ed66f1d92f86478f2975c55f5ded0a34078361b738d19f4813cefb18218e291141d989f04db461365a4f27ce510c69c3c5151b825015647e9f0c66570e2a398ecdcfc10d384c82f10b3d20aeff01a789e03cb724d91c7c1fecc5053c736157aedf689c75a60d79615b337a4c6190e90265081d47ab3d43a013f17889fcdd4c914a44428100195a8cb6b21bb2501e54d45a8eb8ae1fa58a4b919149e60e0279600569330872c2931138ff47c7b2cde40ace7e9caad7ee650fcdd636d294fcf20653bfa4a61997eb1729db523ac6dffadf06d121f9fdad787796b18932da7f8abb3dee4a79dd0258a5cf8123fafd0cbe901884c228290f0c66672a33b47d626835b20cb5f97b17c9fc9e96078d3313b503fc5a4c0fcebf90d2edd790437031c1efdd9c145ce6a580f7e6d166768f636246bdd4570bbd88b2df400eae1079a43eeb7be18074e68e0ded094a28c5db96bd14930f2954bdb744c4a255ac105773900fd3d394cbaa956298cb1318fb48d54e8f281eaf6e2fc7bda3e331bd20c0644e55bd7183035e673db46c63d00e58a5e24e4ea5169505b4962a4124c4ae0fab178fb95315051cf7fdcd0507d1d5bc390db04c60c01325756b5a17782089f718d89839d0d9f0163ebd72dc85dd0230e9a5ac2c47d13a499907f017f63e30fab25f7562fb47f76c5c5c2a26fe1315f48b0a5080e90b33fcac3dcaa5c9767e29499d17ddcd9caeb4a0bf1965353ca67fd9c7ec5c25e2f3c2cbe4570a6d7f75f9655ce7ae62333e64b93089df164887f5cab01695f9de0df66ecf957a80dc775fd56be84bfd320a02c915043b18533ebb767fa9dbef205979fd91c85f1e334a2b83155c79ed53eeebbd66a4ee9e27f792c53edb9f5fbf012937a13955f4db883f06b5008be50a9e02fa2c9e83fcce3342b6e6781fec03189b437640f1ba674e623826c0f6474aff249fad4f2d71b9de02894a0a77b29a89709fd4cfafe35612362e91a2175359b979b632fdc0130567038baf2abf801dfa2d0c89f720c8e8dc8dbaa253cd2b60fb27ed74550163b38a5b2f2d7f5bd3ec1ce8a6875aed85da76dd63bc14418efdb924a04e3c53063eb0b949c63766d19fc4c6cff1bded1d6ae663cfe70307da7b6937984f3d10c2249d9ab9187938d970c2dae51dcbe06a1a23f12e7c9d4a9def15cac2e49759c9a6f99e354b2558bc3138a5b153b13de5df958ebd5e3c45e3af444ba43d7dd7c9685a0048475cf7e2201af4eeb68baef6addd242391f80861d6c79f3148439dfef3aa2bfd5b25f91187d5231a5055cbd4f827f68feaf08f96c5889beacfeab9c5ff3ddda060d15707b02089b5e974a44b77f0f517be2f1465704a86aa5cb51560c408d424f4584c2a9e26bbb224786228ae05c7392510ecbee7374e331318ff4d1bcc91a59cda9e7252bd746d43ea93d487d9d82e43c1406596958a3cceac996901a79bec4ef72fa81658c5aeda6675874cfd5682bfb16ad1b55bcaab065b23ac9058e6c77ec59590c7059dbd4540c654e555f1c5e1ca396ce891df720957994bed6a41db80920c39d15547faad033b559de6fd8400aadab946d9440d077c67bd7ed6783f4c6ddb22cd5b9684032b78dbc6744a60375325706ae27fb2a411572cb836adf17971014aec0f66b625ee320abcc59a905b46ebbebdf9bd9fa0a626e25b1b29b23a05f925deec811118621350f4fe72f739f937b23306b4c176d56a831b7ca18ea4546cb9581df92ba46f06d93900ab81c24236b4dcc0ab65781fae79eeb02ed0080b3141216114da6246ff6456995f37a9cee0d91b75896e5e40e257c1bd1877b523032fbe2ae3b91bf617efccfcd879ae30ed8bf6188a717c8bbb81e4e661008ab3c604faab6da9efc0fa8680528b94990513726f34fdc3e08e7d3ae8553f291dd59cdff8135b94ff04a942d3e77b64885f83464705a92c97eaf9ed266e667ee0a90e2caa4848fa60368b6d2845538394fa6b72725d76fe4eb035861a6e56925b741a4218592da609e07476da38d38138f230cb2a95b334f82a3a1ef9d7390b497a9a8162fe51636c5a47fc2737d3c4cd633a4bed4a538b3cf82e324956957bef3baf0a9cd564ea234c3d0350775ee3e0447b304597953ca65d2e69830ef45045e99e197b1d068a54daec3fbd36ad061ffb983dc6405a9a026a69dfc0e80b68832735995ab5ab07bdb9632880512779dc4904340123e31a45b7437b4be872a58fb7942ed9036585bc6efc10c5ae171f6683abcba772ae331c20b55e73885b66dae3d6f727cb5781c2d109ace0f76b6eb604844a925886e4376d55b5d7dce14f7ef196f82fb13b5eca18fbef563a9eca436d2151e06bbfe0db5456defafd47d0152d40d5bb70138b467f3794341f3917345fc8ddb22aa3f8d3a66ffdd3f0a6d5d13bc7217a736b0b770bc529e8e32e9590d65cd3dd8661a220902508b5762f8ceb99cc8ea0494e1196a828da0068e8fbf88c4f981212fc99c36aaa3e0ff8ee933e74f3e7845065fc40ac34a7c77ec7d985ebd8f15ce740fe1b940a56ff6b675451e27bd98f3f739a1a3ce0db3075327331dcd45833e2bbbc1657c8ce7605ddba8b46dce12a0641458a907749543ec660a54af60484525f81de912c7589db68afa904baecd897edae9fe350108511b50ccd931a4fc7d4a6e850328ca0f84f67547c947942a9999152053fa1026cee419847c34177726c799c936244e64a2c3699c49cad91b050611bd72cfecddc5190f62c2b25e7005c29c26445bad83f5f4e7b6978e9c017aa31dd76f584a8ae7fcda79f478b428a097c6f9292cf08d03eadc941b0b8cdac957849685cf0fa81c4c68f6b8425d347f26a9e6af9b47e6ac68305fc76f9af0969773f966cc5b812e0243d29385868d4c1e8a8e81cb27cba97d9c22c643e6d86e077f27f44584ea974cabf59b42e36678a606d72d76ba924903e118227298809e798cdd65a0f3134b44a7f702171159d4f533a536204eafdf35d66ce83d5f3912741c2c7272da916856cc5ae97cdcc95f1a8a5d867955a41e1587f61f9112406b93a34469c43a5369aa9ae00f93fca8df94e2b545865d84d2e1728bdfa05e775b07d85582630311432759e06251f20afcc24689b8c6c648a12d49286c05f296f8ab0e0509c1a3f258f1b16fad735c10b8b6637a9bf7acc8c629fc42770a9c93d4df906cd258983a933b36a863bbccc75ef7409eab689402de0c2f3392e3f06bf11964c22f8a806366950eacdc49b82edb35c47f6087ff3b86280ee72d5e58a86d7c1ec5f41908d5b1c85623466a28c34112fe98b456bc0e620a383936a53745e414e287c90a3f490a5dedd80031524c2f36ff1a38265a942a3de97f68a5d502d3d10ac89a5a66e2c062130ab7c248b3da4c14fcb9b774fbb69e59dd74a293893a05c2cd16a3ac5e7702506b77ee8fb2e78f1e0eabcd75d2aa984b6872a00e389358bc57df621be1723e6307d02b5b606747e5c71f591fb837b5c5722ba712541dd12a2e7c4a4c920bf5cdb16fd2b32ff30b405fe44b118c19b60bbc7d482529fd77c6d0f93d17c4233e86c9e7eb41e50f6bf6d1f0c6ce9ee4b58d52ffe02c12aeb56d680bf0a28ec169dce36d5b6612ac6535336c7fd58fe769b285cfe543c84420ddc96c76abc4dae6ba3fca37695fc09adcbd3dfa3c78200a584978ec2d7c6373991ddd4afcf3b0c18dbfc4641f1bbdd370ab9c9cc60b6616e3531930701f4a4abf3b1c503ba090d968f02a48eb33c1474d3d786c9fe157cdbcc4cabe2592e907b934ac64d671783a96d58f36dee882e99303456093611d156f6f5b7cae5aca82d16158bd8d4eca0fcf3b1f84f1216912c312c68d514baabceb665fd8494f538334f52f740be9c04dac490e4f91fa184f17c7331fbd4ca7b89e43aa551deb03d76ccb871c37f48061b7d387fe1189ca20802bb1c34b4fc38ab913729b41f69292eac3327ace94383230b2514d375d640f7d7529adfc329da800266bcde4e17143e41e68f2cdf24394845c60e0e98b0675cc57bf4d43b915cfda3919a4d738f2d0e6312a450f8a5ffcad67af42b08d8b179148e66e0f880e89db71aeba74e156cb232819f1ee73dc02d1d3fe5a8e8573593d7f8195c2d3a0f6305c9b8ca5490ff25ab96a0a96bf7b3fd279894c9d73c061b45d65a93935a3f33eed1404253dd6fdf65821cf0ad4d01ce304a58d2cf7c6188af6d6a0e049bc982ea680f406b2ea8a5914c61a7b1c81c094a604e8148fac54085792b7632a9940686a39de63aa88c949f98b04608eac28e1d8d30a6ab443084308279f03bb50cda4112efd68b9907c39b2540e1dc143a6c19fe866c2fb880bedc87b41dece65f12e8b7d33743c5405a51e7573d122ec7c53667f0ef5ee4c6747c730478e67f7e58d51c8e1912557b973565e5307aee1f99c6a533d933c89258a517d785a3b3ee716e0e6055dd293a0aa40f86535c5e06827d97a9c317039f21e36f8de0297d53b251b518355c2e10ecf429c8ad7235db8533244d5146122172bce88e6e63448dbfe8c00878aee187ff3e2d51727f57ed0bc7e9e409bb791404ed09303a4a66a63c27fa435bdb1f35946df4a3c55564f1cfe7f47e5b6e9b5a00248139585aea52c032892d3ff48ba4310b0a6dd8fb5b44f1bc02955bf60c383ac2c939a4b3825783d836a380e310516607797fe8c868d02e6a8a3468837dcc2230c727e54ef5ccca4983defa1aa882c4fde7873ca552cb1bc724f2e4990ebc3a2a92a6b92afd85acdffd84b1545dabf8dac4337382b2f949dd4a5c8ea4b5bd5785e8e6a3cb715155b67eca526a557ebb42a6310ebe36796465d6211dab87106be33f8b55119bb4696323a81ba0982fad34f60cb74191c2b2a0211753107abc58384389be976b65a5e521136788851cd8124d6f8227a710d38a6c18a3fbfac69a29182c9b94459255079a83685e62dac83d41651e5e6af05fe1675768260bfca679d2d7fdd949a6bb45f8eaee3879dec3145611d72749e9664518b5805af185d50beea85186a2b6e807113bc64eac4c6121622a2c27242aeeaec40279e747996a1d55e80bcd23ef572064672aad93059d67f3de4c3961d75d1753844e825f5636cb73dfb8de9dc45165b1b5dd22ec3d093f47b645941ad1f8c8974a5d96f512c07d112d638d755c9d153ff12f95ee54dbd379055c288906379818e1b7a990e51ddf44d1ee0b3c6629fd63f942adde92d8eea8b0a786016c6deee178a93310ea1747111adac6cb8b961a68dad8a27058a8509c23ba646bda8287d07db757a7feb18130a6476d1b465e02564d70a2fe08956b38840c92789f61ceb78f9076577fa7fa213608348651b3dca094bca884b375ac0a81b4eaaa4c2b0f6aae0f4fe519c3f96210f614161ef77748b4bfcb307082fcddc97865451217a3c2cac0052b9a6be38eec0dd2717ff8b326f89de65fb1f547d36c29d889f449fba5e18c882165a84ae65eab2a8e1fa156477a06398d8919e360ecf0e59466e764c72e771c7ecf4fe4b664690c4a0bd42e97ecdeb55e3d1e27b7d51ee0798be17072edc0d3a0a937791d4809715ba8f3be53fab23f08e0316d9f6ac4f39384231a43962017b2b0260dbba65d40a297948305242c926e895a622fa6ed1bb4b7dbc36a2ec9a7f43ec0819e652cf2bfedb6801c46fd303b9c590a178543174f2e0706bc9e2785fb7002ac44bccfe49822d3f634e7cf0a801a3d4aed9d715afd2b9e39fc78b8db52b16019446dc4f830ff5376d9498f2c7a25ce915ed961a2bba77eeb4f9cac75ea7b3d6aeea00a57055e57a46c57cd1f8c368cb497eb7b3570488c615d02afa9d74d105ad880c40a15f02670a8a94d5a39f5f93e63cb209cb619c21d2edde02fa2eed97ca0fd85b41b09422b431eb801725655c854fcc22ecea9cd214c0208683dc981374bbf96b75e67ff405610bcc151d23411822cd9bc3743c2bb178a992430176fb98bab240f5175cce7a0703293d137041553406ae81ff869b42cc79227fb2feb68f123ace77fa587ff84a7fbb02b1b871673b17b716818da6a54f073850d83cd393214cf619c95c32771a555894f0c1a186f1d628f3c042a9720df022d5a74861b679bf1662b6951793093004a7e3c13d2f2f8bfef971de0fbf01ed2573e308070839a918f544ceba17448749b9e6e81fcc5b09fec52acfa6dd08c3c61c5043b90d7b66ddb679e5d05f15b57046c7a98145bb686fffe3f1bda7ac2308112cf40d908cf4a4edff4fd898ccea3b6ff5a3b802aff72c4a63a282ca8a1fc16863e301d1afd6ebedaadd1be3a5499f25d94c15a53a0a3d643544e714466ede7a4fe0a1006cdc46ef628039d5dfda6a740dcc51e4e8f3de177abd15253e97cb11f021e208ee08081b7ace946946dd5100e19e9f91b918fb77affa5262b435a6081d1454364543e347e5837c86ce5a0029357e1791ad254caa1695d2a317edf3142a1b1a2c6f41fff535fc19e468fbec98fe4f6bee0335439cf59d6fddbd46b00dea1817ea296390f1285124d108877787156461de5adc9d0068fdf26819954e780aae53c2f394a48baf9699c66ef9cd715aebda982ce787945c8a2f44e79e3a26c35c26202294c3dcae3d55b4235e0c74893064b199e8d85170532c5d05c8763e689660fcc25380f35506a20067c572298867985007aabe2a43155c6262f927ad8005fca24519b2a4eb6fc52fdbc7c7686a10bca9aa779ff94706f502d1c8ce4ebd773c7ea43dcd23ff9f4af65f9bc779f705b90bf06dd0a8e29c20742ee2800fec5a07fe1b57baee1b8d9dba887824b30a6048f271ca2036c5e68940773db8a9f4ee9962d3b9e9cd859ebee93b31a30ee256689d7b0f805c0dcc1244d45519660cbcc6f8d2971719722d8b99907fe5e4537a5fd6cae3d61d389ed9211c4cbcb5a323632541ea8009e72cbd1f8f5b19b993405de9cc2e64e95727930e0cc5b11671523ef767c668590acd814962e078ad35a5bff0b16b86754095dcff1d94dcc283c5711a0464f52ab578d6c03ca280300a7840fe1cc36e0e1863e7f18e23828f670f68e6e7944747ad883acbd3780384365d8b9042aa519637466c08d52841f9060882996ae6b13747f5df81967aed39ac211677d6431bbe08002f0ea5d781ed6384c77a56d96dc725f8543907724c32441155a7dde50a3ca2384f887b4fa488430e5e09bde4ea6a351ecd7aded7a206fa32c8899eff9f2b11deb51c8daa2d9f7a03a50a2efc8c73fbbaf5186143dc2c9ca2e534acddf7474546f51fea7bc584e57eed71bdfdf9cd6d0c37fb46a8e8863f0ca1a9c2a814aef88c28bee361f94bad1f58b5a2231d87f41368f3868703786cfdf4c795cbdb84533c799cae315ba6bc0cae646d6442d965fb9c54bd804cd632bee3db5578f14d24aaaaac64ca1c13a167e22f796f8b2eb16578cb9e399e576dc9d3afcb4313f5df4b54d7c84d35f1982aa40f2401acfea631fbc9a2532ae6264f43efaa4f066c93c3bdc6106e11789f51b1efb787b2f388a300d940744eb41721caf5f7a0bfbdcb058e083f872aaca35e40a2bc2a6d3f9c9b8c90fb108e87386632e8d4e202da694a50a52513110255367d04d317fe8801d0d3dc36094acfe3429ae06a4a2106cd2f708b4375b6e94e8e8a38974fac4cd9c7da8e874f50f02e81c1b52605095360b557564e99061ca13114aee94d2f8e887a2cd3486ba7f427613550693884797332b9c2ce24523cbb0ebbf8be980338e6e352d6864d12d2dd018638cce321c576254d4f34b6589ca590d704575081f18a7d41910b47cdd0bf7d6b9fcda14dcaaea3751e5397acdd1331592de53673e3a3c303d4e746fca102c3fb401e44ae290a64e0d1617d1a39cc6f4f23c1e4b695b9e4d22e0f6c03a4ad107e32994275cf61b4047befa22113051d0c18fec89d8fdefe07a52cba25c44c153371eec814cc5f6d7f3881b8d56a0e089dba97060518cef096900239e1174a4396b7071989b858f8f50f6411d183577cd73704c1c97f7ca589ce3a2d60e75c944767343f745e097f456150d13a0290922eb033f0e7d251b5ec28d3c79695bed53be082e8f53793adeb0e4394e37ec1ea2d9a4bef5d18f38f981d5e1b6bb12601d63da7a2cbdea61a105485be2737f9eb80807c05bc946082c883485417cf540d8a80e4dfc6780f999642c32e60e73bba4bddd5a35b94ad474b7c33dd813690ae058ad8df2a998329f544e3dbf8e00be32b9a6f00aefad0f7605bab153f957f4d0a4f6ea959871c5e72a02ff9114b2edc668e1a5f671333cce2ac9c9a183ab2c530a5946c26f86b29e7ef53e7afbbb2d4ba8d382a5a9537bfd84342a409cc6ce05cb5217d79bc9a8da786463b880a73b85d88077d27694865438e0f1293556d16f3d833968d55e9cbcd14a87df484ab16c1b9e4b363e4a570b7ebd6caf3c2489a5acaadf3d352f996b01591b9e5b48704581a29eb79421a654dc1d5af08f5ef3f931a0e3c2b2d43d254787bb32e0a116891f1a243f8c3b4fcdb466802131f97c44cee49b2030dde673db6d2ec52118fc1df1da79251ed7552a25f5ef7546723aa57fafbdc94a9d3c6ff9f38dcc44a521b9aac47a6dd5c8358341bb7a9b37b70fe141e96899e0852900af5af1cb483f0cbf10eca1f681731e7a4cb494f1c16bee733ddb12500f3291f1ef7168286cec0cba303d2c03b27f55ea40e25aa5918fceee10445465e4c3ddd4fff89e4cd9f978091daff041db49fe33a269c283e2df7fb0ae877f8c6773581b8cfa25f45b65fd0dfbc006ed6144d3639ca8f28b19a68b90d534c8812f62aedc14004f90ef4a71d18c3e9c6221bd345b1386da25b8c1c485d22338ef001f6e2cb81c1ee8347d572b4695ceaaa3c537539b41e3e6a4cb69450af8a49b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
