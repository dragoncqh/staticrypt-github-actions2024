<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ac10fe573c629ea76ca61ec9a3003cf51c05758df9c834fe65f68103064c8063e6e08a237708cf8b8118c38abf4302bc2d772732b12830d4b24acd5f66f0c0ea7dffda9980f02538c9fcac4a20e4cf7fbe25cb029b176b2a8edea9b97af95f9dc2c3eb346156c99d99372e283e3ce68b7dc172dee5de2b39e4670842cc36d3d0a33acdb9054445a17a060d2660dec66208d662bc12c6ec229d6493b05d1dcb46ed271ba73e6b73dc2872675b61a3b4842ba122a2b05844fc87eb8102f5ac9c202d1e5f14d02d490aa161ed614417dcfa60a63823a900509149a51fe6eaf7208b4dfa99254d63bd2dbf06acbaf075e4620dc590191041c69878df5d7ffb6567572eacde88c3ed194ef8a5947e5d93047870d7d7b15796b32821586530a7d9a16bc679399b0c3c1c5f9b7b110a07b034c51456802d409015b2b878e73b5726be2899eeb941a71a0c0bbb236f3f0875c421c4eeda021c575861fbc91505983c5d11b5e74fa6d90a29aa77dbc1b89ca4f654777e3e26733ef2be12d6952ed7d3f8571ef5e73c2ff30f8b67740bf22751926877d5f03901c258e5006ea0a40c40a95d764fb2bcb87c6943de5e77fc348370dbd7fc000113286f44fef7a8f64afa2bccf1e6c0aba7c1f2e5d464a82a0d569d4dd3be3002a6092f94250725b88a87496775159bc5148d619b9c91adce39d2fbf56880caef9c44f7d63cef8882ebd922aa8d2a2f62f8b6d17c0f341e29aa62c66b4dda4fa3473040d5ccfac68ea4b13538083942b0ed96e2f1d73478a0e07bf4830ab8d54f5105d56105d61e91f86f8d6eef67673a32a4d1f753d50921d89025cc7d20ad8510d5eabb3cc1df1e7e626078df48bb3cbc794959aa48c6efa43b2d91f6eb8624302f9e4c664a43048c54e38b93d6f7870b7d5e57f750a0d3b4cd2568de916bbb47b474333888f60125bac8373706c9d967014751c6500d55defd715278e71cb0ed4372804fd01ed598d1d55ad2b3c78ff4e20155501814d58dc3e7a4dad773eb85e6cda1e15df1aa9c26dbb7c3be59c09aaaac70267e118708f2b71e990dc11452b8a8bd5f2ef54d2638a73a6e86f86c18d780f2fbec169610c2abcd3fccc1f590e197a7024aa33365936c3bb0a9734292a673535c7b3df548da05bf5f98e09f3b71dcd36414cfaafe365a942d849792af8a7d4d20a3149857fd575c84580876b5ca620b2d0b621367f4a23cb51b8fd1fdc5cbbc69cd2aba15d57f24121ad454df34519ca3203c0eb04335adee9298b5f43cdb8539950786770e2c2d215aaff26fca54b23a73bb560b2b7a62570f25a2cb7f29d1a2dd94cdaea66c0de1b42d031124abdd363c65d859f1d9e7da27e4294d02da321885f857351dabe6847882c3a62c9535e52287086e936029a5ec1edcea429a8531a20b7832c246197557bc112b4cd01b0ad7814e050e28fea7da9f61739ca291fda574c9ea3120bdf74ae213adfd4aedff60fb922f28131aefe8be8c77ad68bf31c12d2bdfd9c082573de47dad92aba6ca593c5f9ba0aab8ae617116f77f0bed799479e9c10ea6a9e82b25ebb51746fd7cc3df569ac905836311827d49411bc28741e2c2b2aea168aa2ec92c7ad8bf12809ac107a2b9e63ad0d7bcb6fb0db62a01653e83d1659c0e9585bcb0dcf02066062668a7c81f49e082953fd31120b834f10b9ca6739da746b52f96bafdc9205e8d200c0e98f3ba6c97863c1e0434a424c79428878997ba16acf8e8aedafb9bf380c778188c7ac994e74131f59059a5d9cde651f98b08212b18d49f1255b57463f69a104ddb2f18812e0152a25c16e137151c6a88ea8317df6c652ef2442a053a605a5a97bfed3fc634762a312208296c41eca26f0a7ff19d3abb830ed918e5e921d6b73646d857fcf9bc37d6b7ba361eaa18223cc67246582b0fc3a92895d1186348b6c5cdd62a73b83cd1506fbc50532187c6f242576821a08dbb781368b8cbf1a476a5058359e69aca189bf63e6d5c7bfb489b635fa649f02df11089bb83b208c3deffa886d2ffcd010c83bb8284ce44ee5cb33225b5d004a37044577f333cdd90bc2bf224ba8f6ba06d9bccc58b6a8c8349abcf9cb45cd2e3d678ca4f5d67846b32084e069dad50a65a114ed92fb1e9b367efccaa018d53d319515bfed1dcebffc8a1cb435db938d8cf95e9f97c568ec9ee280eb3bd4289a935b9830c2b134a5dfc06a0c63d71888cca3a8a3fad1c56f8425a6c66d15fe0d0217273f6d0fe001cb31e1d134ef886a2f7d80cec7101235a93742fe15528d24165cae77168c244ee7fc0506b693ea30372799e433946506d02d0d389b4fa0d9409b29c66a08d1038fa31ee02b08a78c92f841e7fb8ee26f708312b436d172479069c68e71c142f7c4b85b2dfaa262eba5c0ba9a9c3ce37a4e3166058546a378255f784d434065e8d10fecccffbfd48957f764028d2d2f62551c375301cd8317fccf95c33701e8c58216e346504b7000dc8d6e6facdb2ad7f5c037340766f3d1f17f7698fdeb4a3618f74f53e2f308ffb31fc80fe74571e1ce35a3ef9e757a4f1913cd2653cd9bf29672364b38ceeb6756ea1227265fed4f7bf95874a541648cf892eaff9fa455527c3450c772e8d36acc0bda26da1af05ddd5e3043e511b63f1b85cbe7aaf029587fc3a1dea2f82ac14cb61a2c1cb9c215a15c874012515dc3727ae2c84e004c65970b1586f699133c5a4fb7240ea1ccb115b21d31ce11fd4baa047f696558cce9fde1d999bb9e1f78816af773712951e43a3b88a831c346975df3eb2caf2e187db913b9a27b6ebb1850b8de608be9ced0a8705e7b4c0e06559d54a8dead6de7a21342c293eaecd946526571779bf5464db7a98858bdfa2b814d1399e9f4297de19ca5f2e3dfdaf3021edd126262c2333480eb54cb75678de0f07a1fa5485ded56e9e11bd2825eb3527a59c56fed3fc267f9d2487638be8e29c782b274d33593b23bcc8abe91c2211d21e731cae44f1eb7c8a349d4cdae470e75af634a1bd8cf5785b08e693dfeedd24145e538094c43ba805262e6809773e228aee76e30715111db8a987f53e73f4ac3fe0c203ac3c1b277ff1e327a2b084e27257210bab97fa984e21b05b9f840bbd4868481ff6d93ed71a2980aeb3b7ed016e772f6f8180e757ef1fdd5f57d79da2966fab6a6b8e37e05064c9e4b84e85f1deadc3f99e53103f19443a88c213fe27b701f5849b4341bf4f562cdc1a3de04418ddc230a7582a6b2f844962353bce9affc27e8829e47da7c5c711cffa728e7f3b6328175af6c468871f3a68a6802646e3f7c4415e634fe5674d9bcb801a9b2524d4f798cf29653c40816f36ca7f4ea311f890f32cb0769246bbfc3a652e4077cd3e0ba23adb7dd9ba34d52c7187aaca774bd75ec397b4197ad989b0b5d188da7bddc108a17a773bebb45f92b2af232492fcf437b04dc89af33cf41501641c5dcb51f1f4e15e5582979954a76e53698fa52da86b7669621e5f6098c0dd991ee266cae56b863cdf9788939f8abe8283c8fbb2e6e15de3b4f98ab685f3da35aa9cc416a9b53aaee6f47e7a21a8240048248ad204047988355217f2ea924d84f3a70da1b5c3f5fc3ae7346fcc16705a2bb4a4446414581ca92a8e322798976650b09e846038e90cac8baa008740975af7a309a5181eaf1243304a180b67d0ff3a8e8e018d2e99065271b7dcfd4d939b576da36d1dc2d5035238db456967bb3917d69f97e99f3d74c49bf59c51d7630343f360b4c436bd842caf97700ea948651f02477da8180ff2543604b906db2bf4e471130a455453400343db1e7cd27263f8e10c521da846f88d4686a3cf2dee57cebbf5adf3bad5870668446aadc3f0642f0b06c7f7e475d2c11a4cb59bd8983668a8be1866e00ee3466fc76d1a9c9c7dcfacec0b3783de353984e709710f14a42b45db3e19efb9fa2f3f94dc7b1f9b9118934f4d52360a1a9be269b55f25fb8727fb391fd377bf2b1304b2c90bfc37da19584b038a518549997f16e35a87e06ec3cabca23cba7760743562a9437c4c464bbf40b95dd4375a4cfdc1a5732f7c106acbdd8fcd4415d1550f9e05e52a5b05583b2978e3ea26457a99b8e22f4762872c24d80f3ef112d511c0639e6faefcd5ea924333fef1d45c8fcc130b398e528d61e9bd7c004e249785577b4ab4709ce965ec04175c1a24cd3435905f72b6cd45f7f9a72024cb0e47b48d49a654c6a7f6b2ca7b89f4c1fabccba4218263b1cdde77ccb8effb1f0dd5db4819cb19cc4fe100b73f478a57f419b507a8b6aceae60ccb7f6daba01cb191354430cfbe53ebd7a6565a008ed68d55d873a8f910c864b76e9491b32af2fad0e3450d2022dd698ddcfb665161ef1367f95374cae999899f6173d26a2ce5f9b69f9837b848552bae654c871acbb8a02a0abf25135c073ee1a82bae0960df0a0cf2ec3190b181ea9e95c7cc18dbbba88dcba8e925f4d1b3567f82e386f7b45384aa8385ea05e4fe27bce572a5e0e9f8d52e9a8aed134ca152a9f84a3cb828210cba76102490114981a2c3d800f3e56e0a34c32d73dde66289cc77d10590a21c6282662aa50f6a6d5052f5984c41b86a799e2e30c50f7f551d0d4940a57bfe84b126f6b7dafc4609dd8c074d756742702f8e7cf5635ae6bb576cf3ef89bb1b26f9bdfe4be13aaf57088bae8c962771cf597a47915ad3371a52d6646cb863ceda3de918bcbdff51c963dfaa469b531e3811e57a6610d18cfaa6758e2a153b78ef1e3df034cc427e2b0ede516e695e0d962cf40943789d84718ffd1e71c2323140ee0639e036bb523c350276fe7157e0bd5f086f873e5d05f729eb25956859dcdb8cb36ea8269240bc8377371b45c01522e9e421e832d7cf1c5f37f6dc96765d1896d9213e9a910109d57b35d6b71bbb061acf4be029e3bbe7e1b32c2eb18d9ba7bc0f461fd7cf02cdce5670e470323db442539fa784aff1f5b9240575056ed7f9b1d3296ad2d5b890ef6fdcd4253b17d33cccbf2916c139b28722108ee99e39858500e4b6de233a86f94a8fa846ac50994829058c36897add8bbedb7545d21a4f22ec1496244004784d60d17470fafbb4b6cdae7a96b9372545e2f4560bf119ac7052f0379877d47ed0cecd6ad29ff5f2751889d0a872157459e08d15d59ab20a9954e71107975d466639730e9b9b74ff27e2e8654ba59611aad97abb7f19effb05cb0326ccf7877824a5ea62559303fbf13eca403e036a636858d30f227e71d2d6975077d9803821aa77c251731ce6cc85db456bf59a970e92357f66878fb12e0cdd843c7f8165df56c43f1ce3fe9fda3f9d5edb09670ffd38e12a51ae8009e1d5bf8d1a416fa00a68446e875811c0c815b0e84fc250618ccd49219906b3cfdba7d6dc13d0cf576c1edb54770e8a96c6c16c6ebb61c658bba659e10f180c33e70baa07fbc154436079bf48c52243b6d1774450a8789549f985c17507892375db40b4d211656c991f8afd646c7b194b92864e5a3957447510d6db91c042e27bdbf0a76ba28d9e6004eb5554f965b9568bee68c01a9576a453ee2f1b986b3f4adecd7f27b33be86715e4b0d031538ee9ac9ac869318d3f20b70596fbd8e1591b3bbeecfcf2151e6195047e1804882e69cb4339eb9a471b0b41b6297d004768bb2aff3dc8b87953166fba306adefa2927f4fa645ade831ef63454e651a3c984a118b17222b1495b57c88faa673147147d519f9fd70b1d083a7bd05c776ede163664d24b5be6be04b5f72d72c538be5137169b087e42ed471a7ba2d3eea2d2e2c87cbc4526526e1784377cd0ba271d0623fdb8e845f48535d5420ed2ab27e44afb1525c95ae24a57ba46208233330d8f5f349864387e8a8a1e03459b431f4abb6e8faa644ec63c640d638e5e5c8494fd7b723db1d8d28e1cd7511c9459042ddae450037d29548b4d481b422a0ec9f6f4f66625cedf2d2cd6c0625aa4c0223b76fc1101acd9798a1d50a2fc330467a312b5d3522aad046a3c00ce6649441dcaad9f7f7687d8e0f7fd194b37e68d46f198a1118477ddae2a2943c54cf80a7f2313f91e93b3d9b11cb19117cf76eafd90669f2d1de72497093c403b6e7a2e3f583e45c555a781cd936e80d6d727a008fd55190562e462072e686a6a4f0efa34f37f26018cb6d6925b5660b54f3f2ddd1ab813622fb574d09b89480b35f983bbcd8c82e850646b688ef0f8502ec161650b3e949b69db0efbc5c671019890de6efc1fc346be49063a92391f967a41b9eb771f3f491bdf1fb68bd67d909ba586de1674f89bfbb402f9bd2203542edb8f5ea354d71eeb767a071327c9a77d41bd21411b6ae2c7cdb8d3088df6766771e374e1a6bb868952ad84af327f7e86d15523ac04c3d76b010c5e6e709c0fcb57dd4fe16187dea348c3a1ead61060f475b4d633a481fe1819df66959eeea736826f176a7b38cbd7a8bb89b8df68bfac0e3ed98f6657440c20eba9315edcf11dfe54dc884b9502774eda1e664f3b2e8ceb685bf24e3f4f38fc3b8e670495d992c489e56ae3e5a96d75b334eeb7580d21ae0ae92a6e475d83777c26ba69727dd693507295c165baf5613dca61c5dd088a7396efda39edee3062d95e2a47fa3d2f55b75517cdfe47773f53c4048d24689de7e67d6d570cf451357f003d9c8bbc567b9f665c2e1d958ab7367658d4a993a57496135ef7ca142c0b10331495f3a2bcba2e85224644f5c73fba65a6b749594893edcd521c15d3e785f037a206f3722436ea5538d4d4cd338c19be2e04bf6504e5f32d6b0378ba539b705a7ed54e9fef65a8a5a02c11874f499abf5dc77ff19a567b2dc239129890f5b37267e28bf17cb8a7786d39e7898cdc5cc7910018a947da63e37caadcb18749297db4e88afd55703462670f8ce62cf07df92f4be09f2eeb4a61314e70df53614f09e40bcaf2767690b2476f817fbdaa6f11df116e6d4411c168f420eb681f893f28fdb5aa6d5477121a4af492a5f299e4c62b5180baca4fbb8f93de88523e033fc98ea85090f91e3d53bf4867e3d2b547e95178baf0ba35ca87cb4f4796590fc2b3d3674fc8b6fd02ceb5b2702fcdc0aad913c293116d948bf9ad458ace50041632d4f818f2bf4b259f342709d95e15c78b15ece64f9a6a405b090f6f7c755f42150b85ac97140a85b38fd584afc76149f0c361ef0deb4416c314865caa4c774a5fdd524861e6f73a956d3b91e88bc1aafe004d447c9496dd79e30d32f9f27d4f910a549e481aef7916e48ae1defb62fb9c4d0dfe45af5a1acfee724fb8735ce11f659a0c17efd7e7cdc0573c80991d1480da7c31026f9421fa7f2ba4cddfed5e90d9252f3215fbba2d78d77cebd6861bb488960fffb56d769046e6019b3a390a87fc877f4d296f989f2e665f2de5ca25a72edf3cad8474cbbd7105d5c9abd0b16efef03a18cb389a51722ad8770758fc30c42b5d4eea2b6bab9368acf873768a5dfdc1b79aa5ab4e48b70034aed1d1e4a38370f40566208997e54b9758546dd9b8727f2d61e1feba1972861398e431defb6987aebaef2c7f0c98843b0d30c0cda0f65bb17ddaffcd91153c59fdff2e10eb3ba9db9abf04c2a25b6eb6ddcc1ff11ac26addc0bc3c6d3b9608835afa8664ba729abc7f7edc8ca441f34aa36a263e5d2e22d1e77e90d31368523b9320900045ceadf31bc97e874ea116b0c1bf379ccdf51875607ef4012974306545d15e4cc437d94cb2413a5a9ec4ca3c2384e2876aa323979a2621cd0e113ad36f19075b05bc6805c7f445749b64851e68a4399112c5537e6fd263e8a50704b7a29c5e02cbcba1f45b84f3c4b8f53c52b0a6065f35fbc754d523c52d7643b324385bd8caeaffa36b7951e6403c6a50335a3811a2418b99a00da5a8783a79f92c92756d4ff90e0704024a0cfffdac55a9b61888ffb5a13d9b2c2bafc5e6afa67a68ced755a8057a57a18f765799f4e247e1dcd082c523d1683eda89693a005bbceb63e07851dcff24e43e03fe65d0c21f46d61cc03fd5efae16de1275ec12f56ea51a838b5f07b1c05a7469e119c9db06a53c24403d5b69b6cc4226e4c1ec4f83a905b1734235a7696d10275de314c7614f4509ad97b32cfae364d0b7b28ebc01160d289ce43d2717d1268d5a875b1c8dfe147280d6a83929e37396ba8fed045b95750066c798bc4c064173d1eff7a87f1463b37883d4e63554b4ed4c11557e8ad39e3d5b7c0bb6df24f094f0c362d93b846f4577b17063931eeb34235868001fdbd2bfa16622dad41c02f99232f80c9f976e01bd4c3f5f806632bb1823be1d36db5d57058195828162106059a3d07dcbdfde0e956076a599e465945d47859e4fbbb9ebb185f1f6ef8d7eed12dfb7d605ac147e7a945ce829fa87ca1fe1dc3a8054e68de76b53458d917524d6913eb136b4cc3d21320c45128988ea6c2bf3f30bc8775d9ab8beef5ce265c35120f4b36a6764ef2b4615ff0a8b7bf53e53a03b1604344e2bdf731c72073e2ab1455a373b3bb74dce5637da47bb01fc4bec1a994d285990619ec741a559dd122e29b5e0831c5c218afae92e0bc7218557627aecee4cf751c8434cba2d29b104e31d930bc310a899ad7b05f04541307efe1a1d4cd823343dd2df736ef846bdcf4037f81dbf6a445a4fff58b6437ff4bbe4aec5cdec7bdc6abca13a4304dd9a006a0db2b51d36c4b7f764709091e10b3c7219c765885d90adad0df36fe803ace432710f911d908686bbd153005eb06e93c6960ef60cc36a585a8cc48d9e1dc638d725fb71e3a5926185fa820b9903d107dcbdb1b35845f6aa8393e77d98b243b1085d005aba726b7a0e380a841b006feddcb56cbefccbb7d0c5bbf8d87ff3af1f0d10433774bbcbc18dda806c7b054a0181335f9d531368e88482ae5405eb38606259cab204f5ab61c063574520d6a6f751394996807fe8c589ca02efea7613bbee7dc99a8b6406473a64496f284a546f778b1db90289df5587f84b624073cb34bd5181376b6136beddf71bd6bf3fb9d197ae6f94e1c4bbbee17b826bfb9bcd9c8a4df303196b649bf95c2f518a7dddecd790802a06d3878dfe137d43d37c22683c8ae80f7d88ab2ba431115004db552fe42da6166747db2afbc5bb6a777d78e96debc215b1778f23721ef2be0889ae5b1b7fa4db6c0b1976ca0f108249f9d7d4752ee2e67418dac0d4096c886efe53cc1aaffe39dd31296695011860dbdd0e44f8581bdbfc3657356051bd7890a1f7aa4b92f818493288194e4915d155e9d7fc6f187364b7d88f4e30247a531c5a1426d756602db3dbdd4eb37626faecd57e8bae99c17e33b6bf3e394813e7d200c0671d034a7aba9ccfdeb192cc407e31c4ae40440c35a57d5cce39d67955872272ec5c588c2705cbd8026c98a815299b537f792d51638b73c2ff94099c4b0fc12c689e55a51cac680a68e826a3b2bff1ff09184f318b46457f30353d5df0e6c2b03b98936fc16c3a816924be4ac1b7a7acc3bbe7a0fb50f5d68e6cd41a516fa819afb2c04056bf3d8eac5fa54b9aa10f44e484cb9b42970e39cb4f1e73d5255518f12c14a109acb344aaa3d26a8ec1f9ce1f7628bfcf18e2362a80e8e9ce63769a7e8c9bdfc1175c7cd55eabd96038eacee993023f7b80173ae4f5023834117045d9eaab64a49888b0181459873205a2c72def3f611943a04689f0aaf6244ba26c19d8e55a581897fdaba230a2ced8df639a9713c222e29d94d29da4425c4033562a3eef50e5ef25c6a8b0bed355da27400d4175aada05bae45f9ca3520824d77e4d3eff80821e260a32cfe6addf2416fdadb553b31ce26c36fe9d8a049f5c8c8b0cc3c9f1479388645ee005d9228795772bf22431fd8ad863517b85e8db29886428870619bfeba0132432b9536c0697e00f9001fa24fea4c4a0d1cfb2a0c05703a0a8d292fb4bf71cbaf5fa490640555ea7c2c58cd62ab41f83adf2024238885955196cd944a0c28b0e8c44233f884b5a28d005712f2b73d1aa3af37fd85251e32ab29a87d6f1218458ac5f77b268d3753d6761915e61b09c464fde1c21cb2d1448c06b22fd2fd17e583db61a5b0196c00ac93ab5c95f42fc438919a7275b18dd1c26795117e0e4a1a8483eaa857e9f33907aa8d7b573e19b12c9e2f7f48626ea19e240bfda28e4ef6d250acabcaf44685d424e06c017e1d1ae0578cba57dd4a0bfdae44953f933c9385fae75d9aa73b0583560e153c9fc63c22556d5570f321699de6e0e58060eebab792e7f7dc9e86ba1e9666f2d6cce8bd7187b61abe73d342fe1a8186d33c35c990f72d84949df23a49d8f9f114c6040066bf094a8793a942b8df0a94c963005290b9e44752fe173aa1be36cdc58b83af8953c6f7b69bfaedb1ce8c4769670f7f8003eb01b3bd09468c41f6ab24298afa63dae80c9b0bc6bb073986559239a2a317098cba3f99f19508487d0881247995adcb56c241eacc18457bdff09d3f0a909127fcd84552b8523d5a948eda13adac88e6af82ede18f489f2e5fe2c8588484409bccd4dce3ffbe882076e9ba7ee361f4015c99d59d13c00aff0ba1fb1858da2dfe32b47ffc19e62b1deeb4c352f4aed440cfe757475f8c26613016d41d9445a4dd0a670852e34f2d52c35fc38659747db3d07d1301fcdb75784480a8dfabb681108d1dedcda0165531f35051ea84f0e57b6dfbd111cba09c6355ed8dd704acb0c86fd30e9efd9580ec7fe2527c73986b560c74364118b7f21f7a95a72b14f9574bd5b2048cb910f649d81275ed6d050f72cf97cf195da649469105879b9c7653eb680b6f44ad30102532797e8b9039fde3c5d41d99d483522a2dde2d678611d49c9e5ecd343b39f988d286e99b010f8e1425d1fdf2bb264ec1150284bad13dac7624f6f7a514b44b434bd2aba2e51049b0d67eb98b6382fc3a32ee04e66a718bff3ca38eba211dda2cd1db6e47476ec55dad0ec69510b94a6fe4ff48782e204d467a095ef6fa6b6a76f87b7ed582e26165cf1ce73800db9fdf453d75a3117d6a9028a598d56f38585e5fbe60ea6e67453a82112b452d674e6e0fba87814647b8ad1f7c499fc8ff2cc0b86a187eabef582bcd5a66ef96d262982f950a1bfdd5c1c104a6fb2132b3c146135e33c8e432c0cfb39c064fdc293352ce6182c3730d28b63489a57b7ad6bd2385bf915eb8ce27f0130ce8ed544f12380e556bea1efa79a4d1be380d6503e655c8ebf6e745af845831a9e736b220944efa5d80cb21d061bad1c5c91ee7a7868a53b78c341b69d3a3c3289995773357ee762707792547d14fc1aa5d2c93b7139cc06cdf6a418a16f503d5c2d62fff559526c8a16fd8fa53493cc1339b0de9ed29270892a7ff5c57c713b4a4c3e0c3c968bda06ffe485eeecbf980613eaeed753dcbecc8174bc3f859f039d35c7f83d7bb4e586c3d0ba90be2f62005c2aa1e1ce902d0ce5e3e5464da4247b61c406f4434297eef67155ad38c5a4b7d40770497a3a581ef7daac8d3896d7cae5ce7313dc81ace47018adf9a0089f18cc47c8616fdfba16fd408c6684c063ef810fc8070a0a7744460d72bff18148e32d3dbaf89c36f6c431f24735b05607be7356fccf62397782a90b787385e422257d603752c6bbe4dc27522a317a669cc37548ae1e191ddbf9ce80df3774ba7da3f1f0ba7027ce211352a4886a514f95c347a549675e00d7597fcd42c3bf017d0fd543a912868d64c2f7880c7064e0a2f1c37d8137b486965757f8727ac9f4513f6f0acb3da11dad1b503fb922e4aeb587665dd1f8628a7a2fbd2966ad1b452c7254607098fb471a05772c9b14ed19efc0483a07f3f8fbbddb29c03d4315db050b42bd352d85426e2856fc8ef7953129ada0cea4233d1adb72482fd5e58552409bce26d05ffb59290524be5a31ccf669be45f64bed8f3bbecfa6a073e65f0bb7605bbadceb0dd9035c03271192566b55fae098a1c10210001a90e40f0dba4d4046623b3516c5c0c742d4c7903f280bf95a9553003010726be4644f3d5df01f4fcd40d6e2981824d90b5155e55124f88af80ac5dbff9092adacf2937babd7c3b1d2ceb5a655eb88ebbf9117d5dc3518c3b1b86e0c506f244991cdfa82a2975f4eea246c0920105928ad81428328a722fa412e4a5a3b79e0af83dfe201a38ca74b94da69336d8ca79229bc6ac3d99d06b1f51dcaa92ee59e0a8a4682973eba4b42dbf74972997d32fc228a7bf9dc75b414035f01da59144478d8641cfa2714afe42a392078cb5755b16f9ae6c8ec4bdc6fcda9eeea40d14cd03399ebbef3eeae3b326995848721518568bdd5c0eab6e74dbf3e22984a0bfa6d79515dcc9702cfc0f56200a849ae5c1ecec22fc0ba178872d02692065169b50482947942c7c9fe6cf073dce2a926a488d2abde2089e45de221f960173e74eae867701339defb8e2a46b7e405733cf2d4c1f96cbdd3eabfd0cbdb87280b9571caee06efdab0ef7be48c9550510cdde7bfadbb35836b20f3045aa6b4afe55b58fbee47fb8b6b6bab43250dabdaa0324ebe057fe5aa1d74114666e436a3c78ca1965ffa7600f1ea0ed25f90511867eeab5e14da1932200157bee7c509ab0f8cb272f95cd02cd7ac3883b56561f86a2afc7ffb7210d53705ee29cc1b4cd4dfabd058e5b21f8cf0d9adbef5779b194624ea8e0ae1f4ebca758e235a27e63dbfa208ed33bfe86dbc9eb3c923b0bb4400d72c5a4c06cd8b27188045c9be100ff2e0c7b9ba48f4da605a39ad054959844dd637ea93c4e94715eea9eab7b248c66fc4fd37e224824ab772786ef66057ee8da73b7dbccc590edf6b735b611a99fb388866dffd38658d433e04b8a68fe5c20c545b26de857fbdcd4660a6e30ba2520d03046ace3daff2b5a5c6e7b4f501b469319f213d54309a8381564cf6d94de9eab3ece302bceb52a430cff8a29c16cbf00d551dddab7456fd601cd0271a70ebae16dd70fdd554cef7ec2366a755b09f78857a036535b11c101a78c0e34bd26309e8294825778875231a526b494e2be8aea1e1d63cc4d7a820e8068a2bc67240e536db977813efbc0a2b3d7f62d2df82521da5abc20b0a84ff925dbbd2f04fd5a9348eb242f6cbae9493acb594796e56ed6e8b932aa0f98a1569fec3a10d8c7175f94104854bee810dc7d6371d261841229d3f87185ea059c8c66dfffbeff0d3633ad778cfa1b57c80e65a4353511ce4b48b4965f63f754600c52b25f5ff3369c7df0912903ea5db3c174aab4293d01cb2d2d4a2f10426fbad7d793550a1cafa41f2552dfe30080072f3e724172fceb6e3b0aad7688b00d022ba4a0afd912823bc3abf5717ba8aa70c6b5e05d20bf9fc33c33cdadec44e2d7bb305411e9276f0e23527b1fe890d29c589d849c1b584035c0e4c76a4836af5295c171f450d8e2e5ac62b2baada18e2bc254103adbc38e9b8ee7c5472ea56923ad12c1be68e9893bb2befb3308df5f23d3e988e265f85ce21e67f0b5470c46a71beb41f75a6bd909932746485a0d54b2b7c844ca2d8c7d0b442a5888938884d2b105092031e428718dc0906507148e086693c525b066823ec72055bb7587158d92f875f3c617d6ac9b657036497b37a71fddb24ea21bd20922bb85da22bbdaa05d4e091cbb9045a7a4ee3eb4888738ceaceda2a92d8fdc490ed3b73904903b21bcc9d7f4ddfcd48afaf53138196d805b16fbf75892a1f58209a4661c3b40cd9db8ad5753a2023fda89063cfa7161d920ad5df1251beb2b8916703ebf4f528a2c2a6c5218759ac1fbb7818ae0586fbcc743f58d13b012f4a1209a5c52ed1e12dae9b7dcfa042904d79cd8bb4e63294165016e0590be797b318750a834a19c8144cf39ce782b0b1d6b335a64152d28063e1cdf7c48b8880a457d7f9795c63e4257c9d5036e450a9578bf6010e598bcdc26c7d2d5e5a4d78aa86fb3cc20314ef4a7226b09c0cb6dc991b0e5e9bd7c2200c0289b7e23a8da188508c426fb45b0a1161d3124ce54d24ee40b25348b4a7fa2a165cb42e6d8733464f74c9e49f7364b363d339cda77e0ac5090268c0ba2156230e2dd698aac8ccb1f5ab17d7daa6f4ccfbb03b4fede930f4ee33a1a8ed0b8ed0c97697e137d4b24e0556c7ccd8dffbd6c8583cb8883b19d69841bbb6ba852b6992201792ad87685d95a9d4be589ae856ddfcecd95bfa76fad2fe1c26e6b862ec77f6d01d4c52fd3d1fa26e6f4371083b6a90bf9b9db2d3f777d002191803dd2e48f7fadff893bb478a34cb7c851183f714c5bf193904d58a0c4906d4e9e274113601c1f3fbbc1fb54f1c741c1adfeb9f2392f4e27aa697a94742662d8331cc57c2a2532074a836c8fb95463303f94dc709efa323f70f71e8d5f76904b0f26077d0aa89763cd1ece4b0474b41e00c322797dc1b8e12327d40ae09b3f680259e69000060f0c8cd2bd8853b971b8d05548cf54d1da4c5505315592be92df3737780b3a3ba60fe34f23c023b0fb7e12f5d16b7196ec80739748fd298ad2a77d2b9c9b102327d554f5fdd69a37bdc341ac36fbde76ed4bf72e28bce55066e7918f8fad3540a58d4455af00122f6b82396e6ab4a6847d313581ae8f69564e182f25240710679b62c32aaaca3d6842a3a11360d2ac963d7a155ea215bca383e19065d15386cc6ff7b76691e24bc6490ac01a823491d98b7919da705c5552afc9fa42de6dd700db33f2d0582ba0835c5b32c7e3d8c36cb582ea8d5c6982ab147840f1326dc8f46508ca8df548400d3f27114be584becb514fb2313ff47d05d56616832467f03ae94e284beb3e858ac6853dec852593855035cd58d3c840270f70cf277dece57676b36a445ed923153535c04dacd1951da1712580a18fb54333428b6e7de00a6ef5b629590548cba2c7b495d729ab7581778d8123a4e86be29b974842a14300d6aa7a566084297c75ad6020dccee8de1c868f8b3336142e5b279b5646be760b1f09147ea3549348cf048d595420161d2f0a7b19b3aef7b933e4c1673392c04e7ac9bb84ffad8c7772512c5beeee59aab301724a6645bb9c6a91364d67a76ef6b07bfa761780722bfe3986b2ebf952df64314483272163fe3f7afd51f5b417ede714a7c60eb507662a2860d8aa1ce0e9b53a9b3926cd3ed224a52a324aa28c642456e40ad21d96179b96299898195c57cba5c5ca038b39d3e96ff1393749a08a8bef79d4337ed9093bb91048895522d4a21acfde4ff5759e85ba6d0143f064bff8bfb3741b793b1cf7c6f09e580c70302444dba5b952fcb95bab77d05cbecf4e78deb970844d8e4abd8e83e232ce6d066c810ba6de599297911b072a092b87af3a1a29c2ebcc06d8e9b9251bfe33f2942951632004d23f966b02ad34b60fc2c9d5dcb037913dc5a0290325ba20e7a67c0c713884fa2fcb6839512fd315772e70ea614ab8758dd3bc4144a6c9a3769f93ac474b3047faabb0f3434b2dacc79a9d97061a62cc4d1f26bf21c446c01f74d26d119daddae47e78edea1ec75f1dba91e0407b5c4607aeed613076f76341987686990e0fd53dcf16d0c392d42fa34ba557ddb18e4dda6ed335b444b371e8fb555be61cc3fe6f217d3ab6721c01fdb501c5933db7f1871fb041a9bcd45c79997b2cbecdc578ef2f8e0850151a11ac0ffe5dca854da381f50a4b99380d3206957af7f13258f8d4ceb57e648070307e09a72e97d1437aed2f6a4e1d5f58b75dc6d25623c23a3012b372179004d4b82ef2f5b12cd0354b4a3343ece08daed7091dc135200c2d7ef61a557e1c9f34d4db5e96a235d12aa95547322c5b8a45a9be213a938f688075bc10cf339717e7522497c54febf794102cb62bdcd1e5ba337a179c0a8bc5e07ed4e32bce39c3bb906979f520766e7f36a70d289bd01050f3c9a727bfee24b0e9c093761c731bb743b3ce1aaca8defd97429c8c97451cf768db20143f5824ed3b941d177e298506bb688cca5dd0955daae2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
