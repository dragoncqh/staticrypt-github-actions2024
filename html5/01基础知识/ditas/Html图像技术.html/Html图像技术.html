<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58a08ee46dc4687b09f62a2218e7f971007d4a4ba7c3fe7c05bf0415e278dd6a43f33ab12c09248486f7f38ce73f20c23d0c363ae4f69e913d9f3e8af194aea4050de446ff03980d132e0cd1c435dc39cadbf2287ea56321b48d069dcae0ba4c9831270deead3e3a2cae7692a20ac970e5b85034da9cc7a776510a3c4e0be4ee25998832afd92a0caa5b19612f90b65455752ce9621d86ca6ad8a26a514eb8e0f020fe45be2d33bc5b1a770cbb3e6390606a24e5b121413422df524ccf905d1f2d071e969d3aff5d5956eebf9c206f4f9bd1a46c7b2c7ca23a17145e68cd7f2e58f9fb8f196936eab7cdc0ecfdf3da8c1838472eedf92717b0bbcd8aa429ed44eb8fdf9147249b0e45ba4c8e8bbe4bd92becc5b3b34ec5f1e20a7b912aecd009f75aa44cf23818bf3ad4fd08aece88f79b40550713dff2931afe8198b358e0baa8ec5e862573f2a85eb0545c6521640ce8d5ce335e67e39c5473287a41877816c3640e245ef72c921ef3ed018222a1433553cdbabec4a8ee735196dfae4a4c6e3c99e41ddaf53d416fa91bcfd03f40c4f92df6e8fab934d92864de8b2b7bf1ecc1a02c645ea9c64d3d57877a9d58c3f8a29f48259841ea712cb5332335cc5ff89769a76a85e2eb622b15f1bfc0cf064ba8c31f66802135addb31179441a1ddf3ee83db4bf78ac5bba65b0942c8a8a96651ef8daca57d51af534c5a4ed7de736f2b3221d922c4b779883eedc2587faf96e1b42cce1bcc72eb22c6d3fbd2d5ca28b9fc8c23d6e7595e04cfcd6604e9ba86cc3d9b9b9325af45d2a551f5cdc70b66a34822fdbc58ef0fdb58cfa33af67228392a25be06e3b38730faa7102dc1d5ed943d67ec29067d3606befa4085a1001f0809ece3258eae1de38b5d85f2b10900a33b4960242dc4b9f6b8c646d8d1fa7c53682ada40c821160a99cb45568ecb9f25ac502dc34543d122b60c79c5f923312a3731a3d0b999e88ba034eee1f089cb895ae30675a504fa4257cdd5fcac74b3480123f11ac868374bf699481e1ce1ea92518514f5b589849a868dfd417959e5d4cc16e9483265030586013c33c7bd45745966d7fef44077b6deb5be78c67ec4b291ff71996f6f09aaf802e70b051970d625e96ea1149c82e1949a1230ac025d468642e05b7c727400ea4316e95783f7818192bc8a6843c1e7fd615098788154c5dcf4497965e987178fe7434cab18a44657f68d1846e988646c209574567d1682451ae53dbbbe06272ff779bebaa389d3d25b6da02835b5b2787c2cf8ddaada8f695bfaf974e97f5e9876ee0dff86fdafc030fa88e0c5f97ebd16bd74c66ce5eb0f4c2ee40e72ee847157a5fc7ebb56a011d2b13c203ed76d9e368a838effe59a87e4d501babc7af2c3ba9b97ceb9ce81dac10b6c263856bb5039d86774863583e055413142cf5b747e67922d224f50f071817c5d2ac06b9798d1c4292bf12c73f075e240874e58b0d5f2d348704b08187634ddeca36d3655fcfb1ef6ac85b89ef959d138f33bde946701806a13aca6498b98d402b20e1ff5e5b929e7169043b6698bfd789340efc5214a730a5d7c59f34965577eaba2b8883a5d876b0c9bdfab96ac4c59dc44bd7d7e7fb02cba1bd73f51a091971a4a4b6504f425e48ff913fe7cc72b4e0fcc0942a776bb87509c0e856d1170c6e6bfa015893caa4b9fa2b63d2fc3b0670a54086b2a82411e7761344ec2893e248f79e27a0b9291abb8081a9e715482cdd7208d151fe83da7c48cba8b9f0a9ac1a909daf2761651de6d153827b9ac6d62a4fae7c68281cabd5181e7584b9daafee6e57119f4c476243cd6eab8961bac346bc4a45d64241ecad8b9c0881a6894516413fd29ed11c0b2abcafd11215420e4ea2c62205a26eae18a1817c796ab2f00e8c65bd7f92e04ac548f22253b4293a7add990628632696303aab3449154abd7746fa8dabb2baff0d763a975c2b7dfe25c9bbe6ff8fbcbd36da3de5cf639ac1b6599169fe5a86611b17de3fafe0d5d24e8791a0737c0c0f487101b8158584bf12176be985e972c8359a4200cf89a22afe6e1d7ea9e66d8a2af5e36692094e9351dc942b8e1d8d5b94a26181ed94280f9463aebfa90578729344ac520f1ed95f1bd727f30e98d74b9bc7e03b4b3b0439e23c24cc1dc4ba2c9f9529f32e4018b8775ef2f41ee5ea7c14721ac6dcff856f959b9f767e319bc6e48c2f46e06e17e228ae5fbe902055ed99d78afb2fc4642c97c76d963df656f7e1ddee1ba36e1d4d2557514db90971c123af39e78aefdbf0b2b85c320f2aeeda0f0e0c79450e3def2c30dc0f5fcfcaa733094251a80b847131e5a5db5f6ec0b7887c165d6ca26d2e88d0b8ed04cb9db5fc7bf57fdf108c68018dac7466c655b946570e6191a180f75fe57033e03e34a7105072832c264b53c8551985073fd0d4ad19ed9f6bff2e00d5e21faa50c7314e0abdd08614451ab147b83e091d0609e7f31620cd343a9f40f73fcfe19208efcef23287e9fa52ee6e6cca02b2baba4b4ecb32122cf44fda04fdd083fe4dc0d63aadae3b92dc96e9fc91c1b796cd16d55274a7002223fd167786e07c7e8a17a277a6f05f8e87dc7faa70c0e8703b5c01c565225694b9c0c88190258cc5a8667c9942970b2d8d7e20153154c93723a347f5be66b6901067917ba7535a0016caeed32b167219d912203ba64e9909fec43c856ea26a7ebdf8d4b6cf38026dce39625df474cbb95859d4d01f4066b10c887ae673e61a9068ea98d72cf60a36baa789bdeb57e7405014038cc9e6fdcff160fc55137209bae669a2390da89b1734b0a054e274cc9f7585e627f625b9da87a8602457eb63feeb5afc806c44a9784cbd77a6e1791409831eacd680fee5f5b781ca8a758bdbdd0e47a2afa581c1a85327d2395862304b1494c91fbdbeb8225d4c066b67c4798f6e6b9a419cb81d1118444bb7e2e3914395ed810fa438904d92072f85c41797bfc3e0d973c8738ab7dbfa92bad067f9f9728c666e296dd549a0b6d95ccf44b36e44b3115b0fe16a6c4933eac8b504b85c90717e2445ea201d63d3b2dbdbc43717b1fdc10db001d03a0e8c230d81046dff7d9d62c8534382b2f17f378140dfb60ac5fb818a93c5ebcfef43fd50e7f1671cf7b99105abf8ae165e0aee15add8657bfbeea540973214ca2fa0aabc794c935b86cdc11599e6c0d15210f6c5a28034b7f7dffa592dc8972dc9e6c5270963eb3f8e3b947bdac160ba136d925935cf0c143f813594589b36d1b46f4ae58445500079c90987e4b26bbf574ea59c1b69f3193e2271f80c96a3b8616901eae9f9013145cf2c8c6a8a321360f52955d0bce606a8de93be52da28474cb09da969138a5e0c23109757945695dbf2713438dae1b3349e4d095bc837550af90662f44d2d712803fdf4aa569f356104b3c54969081cf4082cbb0bda426982fcbd60a029a17d916176ea5c7edb5f5a9c8546060621e642eba12793a48f58b2516ac6a4638462c522663ae7a4b3b6b4b2856e54e689f6e5c82e9ca26b614d290b29b9d152fabc696acea854ce9ebb88ae4ed918e5eda0a16e91e804df7453905771d3bf17661aac661f8c71d4cfd33fa249da0f568edff1b2333da756eada57fccf672b47e478fe3b56c268b096c1c31b1c66119ec6440b0a56d207eacdcf36083f765faa0e2127f6fa752197cbc06ac60c19444f61da4a411db7b08bd8fd25f0903ed3e05af32202e0aa33d5765cfbc99dc0ad6d6d624f9201fdec68283066eeec7929ddd7f554228b3754d65093e54151c6a7ece2c0d1308ca9ad23eda34c021b64fa6c6968afca70ab0de2716addcb6d267f370e4c0cf2341dca0e1f8c5d8ed49bdf0ce0459f29c0284a7f334299a831106cb273c530d1db12d8edb87afcc9494ea5db2b8005746b49a94ddabb31f30b029f2db968543dd63363cfb838a788098b5a65ca945b9bb8569621dafd938540fc0a4c928d9cf84b4e82ecd8b5d5a6438ca92310ce4427c6b17b986c0f76e99423d93a6b2db078307bf304409ad0d9e3f8e14bf18b2fa9282a8c9e0e533c7b6a5c27e51769e4f5507128ef830c9bed1894760b0a45c28f309a2a43f5d263834404be5b0b602d5584a88ccf80e0c6745d70b5375230a33537430c1c57d619bf33333f6edf3441d9e7fa0c1bd64796632104dce2e153734d5dabf4733cccb59abf0597cb364818c06ae849ec4d7d0b1283926d2592b3d51b10cfc2d59ce22b383e7326467b6d74be6f1031ae6869f12d600eb9c14ade88baffdb7ddf18689416453fb4c5d849ff9cddfe94c7e78a8858d7371e2bcaca9f73db34465ffb99f494be928275e6ef8bf15d87e5a174704ab970744c8fc4c3a03063d0624f7f28659532d3cc6624f7ab3b1c14de1da8686379969c181a58519e52e73afe47578f3643d72361b150b986c67e8c775b16b36f2076065916d372af4c6388f7c79a0c917dee2178989a16ff63d15f41618cf3b1c0d3de23769e7a83ac5e09bf6d25af66be6262c07edfbe8a9c6706889adaac62702bfda7f92fc43740834ed15460d83072f56b96febc7dbe11b6f85b47ce830c87474560b90ada0fbd2826a28cd54f1f1fc3820a2edf1298fb657dd9c45ecc635fb1afd991b5d83108318f07e257ad9a9e2988788fcf0614279a9a7cc097e824a39f5296e79dd8b52d8c705bf593b560d353588c0f6c4563f0dfb54f1f419352398bf76a7230693ab4d75b3379e170e4d1741f1863fabf9d591ad0c522362d48cb518c794a983dc9b05d6c2e71faf4abfabd1e61cf993284f86798ae28bed65bb6fb6eec14483c6070fb344816f62a16e96b7dc664198f34d286726d4664b6adc1fb6da63eb171954759c5ef9787d695514f61eac81afc0bb4d7ae4f21952a61068a64c389c3a9a6c5f9c66019a4450eb70329f738c8df58c47e3dc08947461c7b810997652f12e79bf5294d459067ac0a56219cac296465c871ac9e0fea303ae12f6a413252658c1846b062a1e1659ca1eba8c6f43e7322d5229fc96308f599f77f066514fbd3c5cac6ce2b46bc1b71da68bda902f39baeae4eb0daa8e01bec4e77ae7423a2848b634f89b40c03d19a9b7dc07aef76265977e8d8d985fe0c5194f68437f7f4c49300ffca6aea9a6979cfb225dca853d9a850e3e39ec39c483f39944a8a8f6b3f41a4b5f7aa7b88c65524481c881637f60612e16865c7484c8b109652bcc6f128e8847304cbb52e2d8159b99decc0ed5add4cb12a3e2086a02a33eb5c6ed6c800654a332c4b40682f367050c526267bf07f0fbfda6fe22bb6e1dbcb8f96a1ca81df582f69ea3079aad788f0337c6e9837f44871bff2a276a5f3732ff00048be90efca47880175b1a0da3f773511f9c95bf2dd67e0ae33f3b187479ba1b8b69cae1b96ebcbcd8c40e99b81d3bf8a9a72c4996ec83386128fbac75e455697fab42f2da4c439779a79866253248fd0773349ac554ba463b07b24073e6cd20a6c5aa0f125504fa5fb202f04438c6a10de15df4b70891044266f72b8e14fb754332796d3a6beb1479e2202182a61a838cd76dd90a8663fa99060dfcbd4afd51cd823e7f29c22b6a8872961bbb0c6c3467da2a4472acf6ef1be4b5a3df00b073435753b8603a9c4da9d2fce2e74dccc074b806f355f4dc3512640f911d2c271e6c1996286ea918b2acc215bfb61c80d7f854ff92244ef9eaf37c9b998bbb02f4e0c1ec91916923375d3ea3d659cfb162dca6090d4569b9e2c590a8159c4707d56d2d5342842cb835f8e565983f2aaf0aed711be17fef513ab10e4bd697a617fef0ad359e051cccdb2d449da00d60b5b9d5b5d82e16d9845518b528ebb0de2b777bbfc3d2af7468bf8f7ffc50e00fa3b7cb6813c3e2a051a23d6cef1a92736a5992f460af90e7c70172c0a5aa3d3515e275bc329e1d96ed1cc8c41039b9d2b5596c44c056a1004304402618b4ad5f0c4e7334a2c9a12803329f000411b2426ba3cff9e4d89a0c9719b8db7b99aa0671d2c3e62bb9d3c2aca437379343885ad5a53f45c8e338cbc10172170b0bd1416a27eafb34ed52730c9beebf30160159c230a10ccbc3013560f2986d656d0f055aed04b112371aa704cf4cfd90907e42afc88cd759a5c39db9bde0503aa3d1425da69c8e89571ddedb72044bb575d0da61fc488675b529171d7c3b63ef8e4f6f9d2ca1ce61bbef358c97f6686cf040b7e13d96af65d172043a72ac725f6d1d4168d4b9267a82d29b7ef21b9385ba8d36e1c36dd5345da47f7b44e6fb3358570073a92d5b5257e711905231513128dea50120f6a162ee51ea87a7212f5f84c780510c1cbc2975fd050de3b9893431c6c9ae61a31f44fa6404bb1cb871be6112c7349a677273d0689b2da46a3cf39461c1048599b6f5ede75e875666477356373bc0311c0463d1aea83ffb97077bb6f3075e8ad78c48c257057fa4b546b321a9c440057747f8755fa767b215cb1e693ffc051d63368b173e9a3462da6116533d1e6b50b10d18ef3e5bc95f0faad6008e0c61168d8553c2e29e834ba474e86db29884226ceafa01bf921848708bebaa65bfff24015c63f2d35e0ee9d2626a61cffeaa3bd2103f670f60c7ca267f38c2cdbb8ba852a01e575c8e93f9aaa2bfb8a2bb5565af74d6cbd3fd030ca1cd0e41b1a38300c36197c04ef04f2fb3dbc1c3e5dd0cc24610c56e680230570b70a93879dce81b31284c898972c79e726aa872b95f9ebc6a65815a2d742827d253fbc7ba1f8aa7ce607baa2853ab5317d5d91fa669e29cdf794f4d96be2b1753ddc70754afaad32a6f05d33af4c4bb4b1a01e9407cb2155d6392374060ab55a5e793ab495e7da81f77ddab47a3681939aec4f76214b63ec7ba9b34b1b1785a989d69f0d1b1f132ff63bb9708fb7d0432e887cb1aca486f7fab7ff35b1a9f0198114e4c7173dd429862591dff66ede26f5a2eb08b4aa5246944a738eb56ae88b68ff36077d3f7fc69cba625bbd4d9f03ea419b830f2ef750ae12f930c55ee2654b62daaa2436458e5576bf8478a4e228eab48836d6afd853856810f9eaffccb2b142eea28d90727d77778149fa8f8f42067959ba9cafc4ce56d6753144dcc131463f064960771c2decd2a3b8bd8dcfb507be700844b98cf8235f0423480ad9a65ac0d2107f0339f1aeb2fe931fbdc961b373c3a37357db2f4372be277a3f9617d73400b11408ac4b347b9f40089863b9661146f315651c1fd9b3be8eb340ebaa5fbf543c6406fc8453e9d0ec35e654b83feb3b58c758fe75b753684cab0e3efa90fb110381d7b3321c36942bb8c1e67c44e338986669ad0d7edb0a40f42e346a5c7840c4366d669e9ecdabc9fdcc2092a5797ec456e9eae10fbc04283fbe5125148709fc83fb54c439cd879b58a0bf2037e7aeea8180966e9cc1f3d15f940df0de8b6ed73f06d3e99fe7efe021347b9feb31fb6e8ed049c838d1cf782506f67b1241305a7f0cdb6dfb26ceb1845a81f852a48b3a58fdfc9d6d1943cc893a8d2d58ef976d18ab2106c2d879709c8677e8930127931a64852701265d0d9c8ffa825c7b5043b4c6d5f9601ce75e3adf4b7dec3254eda99fb2ca857112c87e794b63558b0068b440d03e0c7508c3a1b9988dbf12b2f5aa83c49cc74732465a85822b3d78e96527fff96430c08bd83588abcdeacd65b3ac7beee53eaa02b1ad247afbe84dfe396558be1724c6d4f2813de7a562ca916b3a73468c8a684a16b051081a3575699aff37215a84c9270d4043b711bfbf4858a713abfba5d03c60d6bd20e79d4d78a1dd42b6e7590c806940d416d05c9d18b8309f0e309f9bbbaf9241f74af463bb4678c105d120703d97801f2d0ccb807576c75a9c8520292681e31143ebd50eff9073dbb2ecccc880cee6ab0e5a5fc296972101da18471dd9bf33f6442366331a28b1b4c59d102c7d73e4beae2f1218f27c7a8c051509a8d7c6c99aac7c49070b6a897fbf0ac0d4ed5fd27efd097176619a5cd143bbdd4204e574d5948a343a58b2f38bace95b37bbc4d7ab7c164b3f979b7c1e156cd337275f57d17275ea4856b79c093c64e70dbcf403dd5b4344bf30fc3673d15252e6bb692a953c54c6a5faae7a7b4ebfd57733fae31fbc31d6d3a5edb3d88c246eca86d036a87ceb4d035c37078a743d750f5cfe6fb70a9f3e6cf810afcf5df3eaba642e734eb32a85a91d2495857996bfcc91f72bb6692724ff4a2741822796988c39d437b0a106b813d90d279488bd27be4fd55918a0220be2a24133799c36cbec2db9c6c8784e84eb64207e5b8e30dc5cc9d37c0e9844a1b60759b1e07c7d69dcd4c67bde3782b9420b6378b05acfab0e7d87a61a7102f237994105477f52f91f6354f001a1cc08da6322aa38705be6abc7f4f6881be4b6ae6cfe425ee8517c53048d4667c51b0e87d8fa93dd9a44f5b3a5b81ef182121c955da921e659fb3d361c65d9a96039b649c840c6d296d522a2d2be63bf76871ecf576fbcdb822e5abec6a3abd7396ad33836d725c1977a26f72608a522084b5f3d2c28f98353e1adb28b7ae5b16b1b37a6f413ec5afbc25b6a1186c7a9d97ed056b403091cb9d35baa75471a24f45af9ba9ab4b697c834ca996e94dcb5699c6e156e4ad7e197b16eab4a6fdf49ce36367aa353b729fbe772be2637b334eb12f32fe5ce07cf958eebc7cb580b1702fdca2e087cfe8150423d5e1fc6986f8a55ba24b97fa682b2487429dd315a149b657a516cc12f2d2430b9e4a8ec2c4abc5a8ea8f70847ca4c328d66ad5ba275c52e87723955ce9f669a3a33ea30762b7f443cb1673c8b67bcd00d9e38a19303b9aacf27c80b81688a920f1aa754c3016736d846f69ec2a4a1a3bfe9fac1fe193b380c6b30e4813a94b68e1c9970e7beee7d65f25320eb3a29a7f4c5f95215cd3d45e786fc7a7dfc58b3e3627bc7207383a20b203918ca1419d0df3181d7f4db1dc9cb07d3c5c68d8020ea45cb78f745109f2ffd83629c3fd453e469ac0334a67e8f7d67f85894ba01ba2e346c72109f64b3cfc7e4915b3ed4ad53f18edb6e6704023a9ce4d7623a5adafe1b7e87e434fbe43af7e1be6c59afc79e2c29681ad7fadfd7b3ec6ba3231977b2006945ca033d6bcbd78c0cab0d39180a67976d13880aeff5f38e39fea710eb0dda60ee6ebab0f6b2f0993a0a04c27ae85b2345145a9aa8205bb5f0f85e17703fa207217c0141ebf7647cb9a597764a31f7769f8a6a50fcce36049a2b99a2d9add43c886e5d94115ad310e2f9bcf76c68f99edf51997718d8e6240edaa7765821cf5764e9f27d96555ddf1320deacb6175e4b4c34c200db7f65571d9551806714a17d112c2cddfa43b9ab2570994903dd60ee53d0430b58f5741f6b74c30e4ba7f51d1317ba55717add68e533295a9e950fdef643a0686beb35ee48b5c17620778d72ec16dea1be8b5781d9d34a4470a53cd4fc77e88892f25593d5b4646e420e41eba77f3de811822898e846f5a9549ace6571f5f632c2c5569504fedf66b19ab73f28e59d6fd3eed66d17a9381eafd1a552c1bbefd071454471dd0c7180c16655d5cf1854231521251b830a12163fdeb0c6c364288642207273f02671bafc22c13c2c90d4296498e8ed2bd2d7e4e8018bc8841de78a790f7dee5cb26d563c924b0d80383213ef69c619bf4f762ccc92dea5cd3c2f3b8cc00a193e18379b0b9bbb91b10337fc46b167ef4f069af0e4734216ad533271ecf05ea7e8f1f9858068c6764dbfd2da9b4022e9840a064e9dcd3aa44d491b55d196ad5cbe1a6dc0092d28d7fa4d2a8303f1f339d592376b9d0d5424deb012ff96cb31130633beeb9394938dd70bef0d12bb857761ecd52b711b3169d358d4fefc3608760ab5f0723cab2f0b802e012957f3d07f05b5831b085a02091de82054cbb60dea4d334cb8441e35de652028a9701712e114dcf5fe49bdf6608467c0b80216457faaa6589ae784fa9695ce49a26a9687b8c29613d9789730c7c0bd4d1aecd57cc4076f9dde6cdcd739ad419b30736ac895853f96d180351538c1b571e9a2dc9c0a4a7c38f3e9446003a164b612428a4eead186a46908bcdfbc3d52e26a3e8dbd29d54a66726b3605e3c2917679c09b41de9a472474fd746158209a22ebbea41a8d68b881b916c7d68e5dc4fb0e3431482fafb37dc605d026bb96a72ea869a434521c7faabd7795345439daaa1b8e503c2d87adc7618bb28e2d755cbed02d8474efa6500b07938a0120857ec354b0e780947e76e39ee0f126460cd27cfd4822a67cc49a3a4555cff3cbbaa913e11a07c9a69421c4303f16f3f93def4443d085b302da354d45e5579e807a00f7b5dcfeb1d71036c6a4ee208e7eaa081678aa9acb7d842b083c24d16259c3a1c38f6d05772bc11275999ee488bfd16e6e61354231930755c37e395f9cc8c0499c58136083d303c42b755fb042aa23cb46d90cb84fcee5e045f93fb0169b1dabd58b3766b5e30489b0de78d2a995ec709487e62bb5704efaec11ad9971d3c3e8e06b337b4a8707c02195de982f22e934cac547525224252aff8559a52cf70000da78715a51a8e66bd0a6356e754e795d376010e787226387a9bf3dd6093dfa2b37c4cab9b141da19feef439abcbe2cd5d63130f19546339bdeea78d21a5934ee3501510123b00f6c454c2c6de429c801d3344681cd29b5b0c46f56027d60060287f34cea19d703fd8d5702aed0839675779f6613d32319cac0258f88f8d31448c6352a39d5c8a0d8fbcfa5bdece3db2b6b0cfc61ce0ebdd987d6dc5ca4eac8e530d80db772a63416c406e04692cb2422bcc0df75dc8e6e49aefc6ceb9d765ed675548e29def272671e99c1cae217006356306336c37c64763e925a9995c2e3227690007d13b128b4ff3de914d5b3a4f810c08b4b78cc21718028a21d0b7ccfe301cff39b45825340341f579bc998fa07ff926caefb0f21057c5e058eaac06dbd426c2a6f5a943ad4cd16f6991aee06699c71fb4dc82a7a887e3996cf149c01ba2c6c82bd0f1eb92a753e405aaff7ca30c9a8d0860a921140ff5576410ecfcd7139325747202b95a81b3adf8e60032eeabc2b53836825f48ccdb1325f57e055c81a74a4eb4a91f40b18f5f0aca5ce4dcb42baea5e690254b5a982c3b88bc45f5825964e569b16ae0fd97df3c3c8daff8a827ae3e45d373655b2d8bf2e4b1b3d94e7c3e52a92a131d2c740b875980e7ba51554e2caf2ed6db159bde81a4933fa8598106d83874b5c515d92f4d27b196aab65a3b7b16c0c6664e2d4c3ccb61bbf458102dd20957ac8d3667348f71b7772975445e8ee2ba6d50ee0f34187fd8ced7a5b1ca23f90b5dcd57d57dd0537fe78634539ec1d3962d7ace275b1fd7f95cdee0cca1f9fd68c4c599c0b2b529477285edee2cd13468fdbb18a4e7baa8cd3e6c56f7a5ed366a83c75e526af05c96df555ef2cd1b9dd5690256e38a4146d870789de2294b301fb30e22e6c53487810f2b1eaabd336efed0f122ed32927025bbaa55ef39b96e1e3b1a979fc4505411c2b09f971bac7a7da1f530c5cedf7b6e99499b0bde928ab4fb36525350c33638a3e510520cb19f51ae248cddf0e4123eec0a47b6c9272e821d32588ee9f6d8078a7a9c381196a95b99dfaea63b6b2a724d1fa75598f283cefcdf37ef19450e6093b8dee65a490eb24228309406c7f7a9a01374f9af318125c866be7cd3e4d377010a06d4c0d7201658bb7db554a1cfcaa714ba0d1c5e67e2fc31e7ad7f4a38634f73f54f501855501d6a8380e780478c74349a65d28074921f6e55230cd0ec09ef8f01503b8f01e089a4ef304fbd651c40fa49abbac3652dfb367f99a8d71bab00602c52e53bca9691bb72de11826e3880e320552f209a03b72be47c71c421f1c27e2096e748790964d3fc5776401b7ed1f0933a3708938d1dd38eae67b84c6e8a9bb74f9fe3339fdabae92a4aed76de43c9fcd063185c5778847cf170358667e0e2ab6de77e8fb7afff724f558ca040ee79698daa1371631d7bd07b5cd5cac7c80c9bbc83440708393d32897bfdd93747658f27e42d8ece0247c516b266a522d2eb454411cd048250b13096e214b8bd47ebd171ca16aa085d5e111056cc08f7f2a307f8754c7b451a530d88078baa70e44c7069f38abe4d0a6c03b2783d2d4e0c1d4c5de311a03f3d9133c3d75229b042d46407e444ad33085ee77be68b648c9127aaf713cf33894ed54ee6ad54c6365186dafdfdaae97989e844ccd0fa1cf9f65584dce5bf7fcf9bb21f58843fb7d1d4ab09384f22f341e8c1a91fb8ee02750f952b732ca03d17bdd24a27006776a08284eb88af47e5cc8fcadb3b4f8fe0cd44c29b22681f593d5584076b25487931147fd2ca530cb125c3113826c718c5710b5296fa8f0583b740fbb6afba8dafda5580b36049afd909b31fe09ae32045b5982ea191ecc72c99f9d036f279df1c8f65abf220117d44236530d0f980a5d4d422f8e044fa71d14c521ccbef5112589bfa7506723e16bd2b73510b5835c7b90bed6027dcc440695690e3978fc03cf292f7d077dc1aadc87942ac0fe4242f1f01882cb0516c5445352c79a95ae205e198261a2a04e586bc090a239a2b517dacd38eab136279cffa232854b2e7d57cf81a4885dc29ebe4f0784c54e986d79cf221bd06f5b7d4149383b9dfd154022eee56ce0c70b51162780c5fe0f8e6d15d8c1e86ecca87be52cc5dc287830eb427b6cc9d157b4602eee861107867a307588a0cd1c7a7ec92e1f1ac624502251ec7e2ad2c734ac62a9f3cc6c784ecc39a5ab22f32775e3507d3eb712e18d092de734fb10524533b1112ca633d1169d7372964f9717f3b77d392acba9291bf2c5d51c3bd3e8eac48fe4ffd52ceb6560707080afbd43e7238dda286a515e4b5d6fd6cacbdef498bdf563b7cae4ac54b2a91d2fdba4cfcb1be1b16ca83dad685aefbe9435fc736c5d1b6c376b849bc72ea249d7a6118cc779485c333b8f2cb3f90d2622add6929375496c32e1f8bd6e5051f24eec08db0fab8cf292e3360b810fbc5f649e58f8f8eeacb05b0d727af00fa2c9961c27872e5eb5259c7166813093691b5b779fa3950e92019bc57180386abd5f8b665eca6f1a65d2ba16f72d107fedc42ad2f09cfb86c706fb03d18dfb1675163c4f64ea695a123b04b2b6ea73c09f91e4ebadb8b685db2235354a1e5c528abba1ca699804d6539427369d3984d2662b185854511e57b7e607cbfbb7daca3fa398b3d4be850e50c3af8cbb11ad3e2c83b2a6eafe177c1303c07740b8dee37bf272ebd300d8dcb0023387bb97659424975618c91bb08c355976f0c0035b5512a536b1d6df16f16a1d3b18939418d8f0e01f632f28f87278cea50ba3cdbdc4b7ea9ebfc2ebe61b109467a7d96da6919f83b5fcb72a3f98ddd0436f378bc387980d4b9069b05e8021662b2251968aac29c204bcd89ddb099da9e1fb496ed8a21f16077c777b7839c4be68a16c0461103f3aadb464d95ef7938e6a41a8a20a00c211159d8964c7510b112be1cc64a7290b5483cdc767b4402dc02def0eb2ab4ca5b7eb569400d2090d10018fb1f6fb4bcee46f0068c9ded6cdf6c3a9f0b1360374df3ad5eeb7f9c411ee13ebd93d1e66cf3b32f673b076fff2d1b6179fdadb4367e088fb3a2aa2accf8ed759e0e81b022a3b8ffa130617a87f48ba0a1396d3d71d43b5f92c57fbd79a5b9086325e42d0838ffb268158a4d1c42d536dbf128b696ea05f6ab520f2889d2b928db02d552b93286a73479f427744f108c5d29ec13f50b2fc96478982f703ca0d1ef014d7afe4eb81f9a905d31bc84047a4dab802c565ad705f970b8defb5ff2d6e57d5f73ad1f28dae1d955ef1a9843de79d26066a883b63879fa1fce0ecb52bb5c36736877564b2e95860bcc9be2677cf6e13b1ecfd0ff1ef29506efdc79cca78771a106adfba149a10bab9871d5cf6e282e7f780b7d1497876b192ac2d45a50d5af68f8292026ac6fd4e04fdc59ec42d9801f8c02cf9e155b8d58d0531947a8f0dd842f4c93f0353c5c15e9f4986a65a66f2105d90bdf4727c0e2b4d40f097226623eace230892dd4e233ea4ec77b3f17904c21441a559171ea0a75634ce624f1f59b31e0c4f09107b8a89c5427d91a7589b897be0b60e520cedfe6d3ba31d43834d96efae39b7c7cc8fd53fc0e5ea29106d671a3ed3f5e17f8a02d29ad46f6910e49431e99c1c3712c0020bd0397baa92cb000703ee5942de0f1b8d39be62c68211c94b2f5ff648e3a671ea81fd7ae69a08586f9f164030ae585d4cfa9be55945126fd2cec9f4ec65fcd5d9dca3f716d3c244bea47c4cc0e37b03e461575b0960b07dd93e8402f67cf8bfd807ff50dec7861798427837b2d7d0ff9699b476fb1d55242b53b5d9055eccdd9beaed0a22d5fb7ef2819aae8c5bc84ee3f22f8d8e05028602d84ed835b652e24fb19ef2de3748c2426499e733c6b852b225933f740941f2765b05aa7f897ec26647bc04e59f374dc47288f88a5d3ad2791e33ef4b0ae951ad158b8c599fae4ec9bc2f480a3e3c160500d3432f790b8b4b5808bb114828c64dc763ef51958b755d4c44779270da3f79dc0ab54aa9266633e12877b33c3330776647e0abc6f6d98b72a23c3d1a6d472bfdd5a0d16cd980604c98b5d0d16391f189108e0d71978dfebcfededc2a9cff48da700685867a252b9c846bee203c4f4fbfecfe757d9ca68373d4d30a0145f6dbc725a8f73b19303c039994e8f96c6cb6c68ad0cc30c34cf057bec0fa566622ed06888cb418ef21a35cf050c1678313f64b04edab0ceec91b13c144ba9fee2f447b153045ec8cf231daf25e0da2efbe372ba4e658c31aee4f2a2d74b794a368f3bdeab27d937efc5f2f37bf9fdb692ba757ee040677f584d577a01f40f82112433431d6f7871e1eb1c5b5f9c164e4875bbad9e7c91198718d6a2f459134750b4ffa130f66315e9ef71b7909a89b5d002c5f5b9e4f84d561e907d933a6ed22607d656b874eaa511a501906cf70e6a984787898a3991a6be24144271b2aebac6377e20fc0567be5ecbca0a9e118b50bf1bda409988532c9dc827cd605ccc5eaa92a420809fc497b6ded3bf9a817a95df549000b79ee68678c4fe97aaf61e7e61fabfb0f6e023a7e3c40f9c385d5e76c807febd5096cd311c9570a93827080543fe836d189ec059afe1d882afe065215376fb0dee64a39c3e3763a27ac2a3d3a881c492f4c3230994e8c676a0b41fa51e2fc2c11432a339966b10cd3f486e2adc88de003ebac3f2ccb8812149c73d18b4daef71e876db24b12fa14c1aaf375281e0e4c55f4c01d062e8e2c088ec69dc8f5af3003b402435923c1e883d1e2de5f12facfe59e0e0674b6578b45cba4239191261011118303ec5f8c152859547cf4efc61643f852facb7e8a7328a661306f09198683ffdb13c5a298ed4adfd4d28a8a179deb7d53b9e16d81a9645155fa5781f479478167887633f24d5cd45dea7a58222e78036cf40e26bae84e41233a3756ff892f04ac8be0b5305abc569e7b742ca24748ca285d75c30cc5a13b205dd2360e628143ff83a9b011e8500567594358a2ae971d2c74be6c9dfc3f561d4a1f56e68218a2a1f7dd39969e84bf3b2db5cc7b26d6f64c3b42dba3835370bc92718e64a578107e15511621a63b2909a9fd6f68ba02b1a3d4688bf04ecb53da3d95e66dab5f69e97062b8d012ab25c348436b9beed38bc09099898f88b5b1840a9e8451ade313d9a89fdb754cbbf8988ea03b12e3066ef5107220747bddc6400567c518070462869eb2ab900f71becec4b4e41db17d4c10355c64fc4466512a731a326c5b4ee2b07342c9a2264f460f263302ebd26dbe2f411337a4615ebd2939d5492c20aa589f366b8224059b0053a971b0e6dd22d0ad36ec48b2dcbc45695f2e811d57a88c44c9781177c55b9cca519a2f377946aa65b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
