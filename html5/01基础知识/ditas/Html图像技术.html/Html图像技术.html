<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6dc76ee34fd9ffc317fb22f7bddca0b04a22f8f51ad07b73da11142f7ea0eede704c703eae0613896f136f94cd8b9c3204b806c64e97ac83549cc0c6b64f65ad5e4c84e67eb38b037131f9e08e443df9834bd68f4cfb97b5dc9a1c69348d7cdaebbd46d5f141704471c2936643c124a849ec8f58c901cdb53510866c65e05296c3f86ccf37fc306a1c007e15a0d13f9dd88a3f5dc9f69a1702a4cb8894a4ab6dd4392687a67f042e96deea6c79afab3ee654ab17ae093b5778cdc028bde43f4e811f319e0ba17846f07f290aeeae97cd6ba9bebf8b2adb6b492cfe063df278a6e4db0fb632bbc8f857cc9123de56753c224bf67920aa81fb19ba7ae81399328125b900ba4ad7f02cb4dc4ff87b756a8debae8cff8cfb12eb40ffa2f28f0525276fd01fcb3a5c9457db864b6148c6b6a8d5e7c057a83887950b3537dcc928c7ab8e2001581840f9199eceac364df6976802e3b05af04bc51f5b412219e9366497374ed61f567bedf23d71311470e65b7c0cbd1a0609b1100dbb5c8b9af442c13614c2bb9290514ef14b973bf4e257fb51d80d182856339a5e5df47bbefff6e42428474f760890e8d0170edcf125e8c3aca949bb25fdff01a4b08ade13c37b819625abbd2b67309a5cc5522adcd88dd8cb5a8648dd1ab7d513d03104d3b998dcc3b620addde72c28cec4d0a2648addc9513473bd0b1ca4fb6918d678a37e1ef9513c4223a00274c6209b8f985011609bbd95355d2584fd39f81b9b54a77d250047db377c1a70a0f9c3c423fb239fab433a23aaa99d7c0ae6226943a80c9ec87fb2ce97e1354e6c3b2e8df8a7e059472f50fd2bd0a817d0061e9087233a18e87453164908a969540e1de7c39dfb55731710062ac7445086de07971a05cb0f52746ccb9f7695e9d324ff6953f33c298d139a2093b9dccb6d1b499fe48dbc50dc1e1b125fbf63a1777ce01f606f3bf16f20417497c1edb72ebe84e299a61fae480acad7eaaa16d06d16e6531b3c109dd12587bd4feacc41579a109203dbee2250fe1e9031c2176bfa8156bd3d82f06d69c8926130eeadc07cc637f901fd0ca6c8f54ab9adf1b2a2fff56246106b601bcd9e5189ce04b8330e8208dda7bc1898de754c6cd369db745ac38fc69db29e91059f0ba48a94f61f9ea234da74e04291a1117dd45f927a970d892e3a2a6295e4b343390388995e42a39923883a0d816f39dc16b0d9abc249b32109d35c66f5fe58ae533fb99d91a026d2d0a44d01a88322525d48e92a31720939e488fe0ef51efacb9e36c9bf5275be4f587794620266b1915d0d349007d39dfaf2c997c0c4868fa7198de2f6e3dee744ca5eff757dc999c677aeaa85e7ae56eaac9b98eafc40c847ee395c09908f8b67f74c00fce7b70809f3df4403c32718b160b76b80665a14af1e65d7fc59830b5cd7d704041665afa439a51f64516e0f13920584384ea669109b1f724908eba65c917f157cb1f1f2dca4498a9a1205e0345dd09dc7e9fb56cd220259caca7bf12cbbcb6d375630b2b4453d37115c1220f42213336e4d0ac9c675abaa4c894bcf4051f74e4f90b4c6a16ff395c2aa764d49539365d3095616ca7a2d821517cadc4b997b5ef45af580d22c40c5ce58d84a4aed4045652ba6d06a8f544a970aa910fff4544a8f8aee791d086ecb039325aee6e34b24f629bd7cc3bb7e7e474e7f4d59c0db5a72f4b8765c3bdafcce16f8a1ba427f608a76ed9c0721056ab976b60b785cb63f00971f5aaba1320fe856322ea3f049a6d1c4992bbd71590cccb5c55430d3235eb198a3cb04092dc205ef3709bde4d1af4f973c1da98a19df9cce6a1aab23d2d1c2936f340fed1b9b57ebaa5b86d56a8f7f511bf71007afcb80b0af8b1ac4600edb59dd7c3cfb2fc73dffd74d7fc74460991551d952d8718a6af0e7cc718d87ee65624a80497aa07dc47d5f2faf10975501dc59450b44116f1cabc4b7a1477f5a07a0ea082ec6ab60a14318ffa76f2ec954c71b951742bffd4498397163548948ed698d2ced4421483a3b22e4f82e2b214ac9ce22d076f8f43a5b901f6a8a39b0831d8c1f9b7eb6d1a7c3906b2dcb3ea6d86c7b29c9bef82387a3e074f2de91424672984983b3d3985c00ed141bde3354301eee2023e3a896a117b43574f25490335ab9c48ebee4e7a88195d230fdbe9a6fcdaabe0ca2adf44bc1afb2b92e88766a64fa0bfb6858465ac784e2fa9baa69750e9ebe94adddba37474467bf0e7789462db2e87524f4c0aecb25d016a8b248b37bd94a6d76aec254df4ebb06ee1ac82067cf6b92b789d8d6efa9da0c66950c9433dca46987a882a3c9dcab31e4ef3708af13c3f7b97505793cbc3af083dd8cde1d763ccbcc37f691261e630e09a17b67e0bccd02de7c7ae6208c5ae5184befb026d93bce81f977bc39d95e15382807a824baf7e997153aac94a5529a6a685fe231484a058c4ece39d37163a9b9af047cdb61279fe95143cce36c5def3ddf18f1d77f4ed6c5537e8b3812ad65ffea7e87b66cc64a9a63cda1d2fb48be9024650e31a7fc4866664d1b0f93923acfd125f99db10fe2127d26f0da651eb87b236bfc635baea7717b412b7bdd9147df1da3903b8f4a10d8bb4be412cdbc478b200f76f2d8a07c0a3ebdad0b4b121c976ea2baed2bb4b295642035c0453dcf0a4771fd69c2f4a05b06f35c2a46a6dc66613c89cd6f536ee6a99a7b6711bb2b257c4d877da410293fdc2e8faf4a48fae2e135b47204a676a275e93d3d462dae7d143a71d4f65308f71061fd73427951c2cbc612fcc6d62d202f1fb2cc6dd3c39cdcfcb15d9d72c7b044e34de5528369d336a84a6b0da3a2479ebcc647cebb2d5046013a085f22df6c14c6e7bd927ff601a9581b132f50a54d65a02a246a0a14edb38fd20f462126a61f7bbaee2ff262335ce57aeed09be662eb1e474476c5a8f52a50eb1a9b2aff1e2dd6267c90d31d41695986e7f5b34afe604cb1b98bec1106ccd0cca946b47a7f66eca4f362ee6b6ace14ea475c3cde9fd0d90e14aa1e13503ec01db13d98954a9bc24f2cfd6242ba55e543081e22eb0d34f678ff37e61ab3ac7e9ae0e4cc79e9f37600f00f6ded488f61a1653e6ae1b974f600c8e90948f431155ca54bd3829e6bde6a273f837d3ac2b7258712cc59204972c99d1fc05c51f5b40577b493f7b6519084fa0fd1476b2181214b28651df466f9a085a5af0098432f4dddd55d4e94a9d47fd859a198b38c12287e263936b892a36137ac8e5ab9f82288cb42a6a021c88273db5e50748cd70e05606b626de4d520d9ce58e293afd39f96d704ae0c9204f342c1060ec55f439821523f3e8015b36c09fff1be06c931f32e8813443944978dcfcf2d813b2003634ed6691e591ab7b0196ce43f454806daa79f1b2b583e59d8f2183862b113b3583bc37aaa644956cee57b3a8145bd70b029ff04c1182502721c29e517a5cad81c18fc4918d47441d8bcf44bb94606bb8e2a68157553d5424f0a91eb9024505bb79a5f877ed6d8e82979f6a8047e6a14e2d2182b79879d9c6c11fe182eafb06d09b5931dc7a7a9fe9ae14f151de98ea413fb2dc26e3ccbe013c0339d28e616028e0fa7c1dbbd21aa9bec9d8e6dd6de28de8c952c4962148614ceace8a6eab9cd9ee0bde4fa053184e88426137a21005b7e5dfdbcbc766f8c70d9429bedf71dc273f888c5771f689509f8fa0004103664b0b57296dcb9640ad92c3b205037fa1680e7d3978620f9c32790958443b03d7ed803e64fc6dd42e7b50de886fce5473860453dc7a7ab884eb6f1fd30caaceedc2d4323afa669f123742a2f1d3caa450bba5a08ffdf200155ff80e64594cb64bccb0cab9bbd2681b22c600861d5c4b5f44d84fbe23e20bd799af75226eb2a2450509ce141355ad6cc1009e22f54f41de0ea5ba26fdc53fc7a4302a8a1e165ef374fad38b74e37d600446111d8a9846268d18b5e519b6097f87129c5675d7bac771048fd12cf6472e37401c21933119d22341bb13409dbd41dd96d8a3d8a2efe825bc950a7723ac468314a5dbd9514d2d428ae81c13fc6223555f56118fe9d54dc770e0aa1023813c27855ef9ab0eb314c9db37dd599712da8c652231c32ae3882c8f341e55463b653b8386efca5afd0cabf527051eefc3c7e37bd0a297eae5d13225f25bc91d07b7a97072c9446ac6953661af962d668f0ced47bbdcdfbc8c64af254ea8b2fcbdc7e140ff7feb0ce96c59695883a71b9f578e9c891e0fa438915daa253bbc8424843266118aaaf85c0436b53ae66025e2a635cfdcdf64ab4aa5bb1cd3e52b91d218e0975943265e7c72c4b3c866bd03fa936a1c9ef11a6a0e0ddafd0820cc9f612507adc344c9749b439acec90c14fd7b7d208a6e08cfed38992f866d15afa6b6885cbda489caa0a3b57a1fbae6450b2fbf07a6aa492affe5c9d847da1cec00df0a8f8f5a3f4bba633dc8150e8db774e87001a174d697bdfe56fa8c705117bbd9fb280e01dec8b0b31ca6be1be09836c917f318b692f576ed7e3806b0282d02f35cfaf3061817a6ca70fd45f5d2e2b1b56f81c2c06606ca9b724c2cded1bc0bdb220b9de33b62d4d1fe61294c45ecd745e8aeb032a904268a58ae39099381724f007bd2e3078d6e3450b558546c4e856895e021501ccc9ab622324c0a410cce29ee625a03d90bfa31995c15ea9e97f170e89c6bb187aefab4e77d55a9880aeaaf4ef386dd7e81fe444a9c1ff85c5055a8984c37bde4a92f60d35fc89758952c0c1924dabadb9466bee787fd699e2ecd887dcddcc4901b320e918ce4e86dcf0ceb6704e0125000fcb656c864c38d834b39a0d9fec2e75c63081487b501f267d843432f13ecec9831f0d248bbc75fa6ff9e8d46603deabf6d13995aecdf24188838918e49ad9c48975a02d7f928ea058c839e0aff36bbe825322a5fc83c26c0062fb9ff57bd3ff844e2b832f7c865f6603371e76e751d3d9252667b880f3f2695d82f761ef14f84f784d241f469ed6cd96681261c68e96c354ed0321a1369dc8de675f2d8fb82e5f5c422b86302cd3167eefc44db867f9a29132d81148b4dd829cb58fd51907d91311dfa84767a0511ca451e1fd6f9c519db617472ab639bb507d93cf6cc12d4994c181359f8848e418602f1d5f3b0c3eae780a96376b7ea3fb002336fff11232495c27bfe923ea5cae6ac87e5be0b0f3fb22538edbeffe8110e2fd0ffcc2a09c3e7276c6c62f067ec3a2cb92511b1fdc6f2e1bf08cfac8e0ccc9058ecd1034df096bbbbce20548ef5d57919483c0e7d4bf0f11b821bf5f18bfa36bcf93adca3d665e80c598266b425e74f4fb4aecdd11ba5405fb88f263e674f493c265496d0428437cb61a494005e3f9fa9d717aa1a40c379eddcbfa6588f05225ba29f2ca4d75d3eef899a617d3bece521b3ce1700e13f25f9a7d8b64c395d767cf5e85e5f4967bac2122ea79985f5cae530109324a98be320f63544ffd065f465e8877f95e854afa87d7af6485fb111240b005efe4b3e1703108ed459acd46ef91b786a90f8f7866589d76ba6536fcec45425f187ddc6d4cfdcc5cf9be19e39268e44c24adb05ddbe602429fa1c56f3bd5f21c3b5c2e75231ac62bab0920b3f1dfe9648fce6f85a5546b705dd5766522715593e07b911df3b189d9e915d359e461ee4ba1607a805904ee5164b9e348b8f7fa67b172fa31ddbad7d89aa792607db3d5ece8d7c07420da5871bebb8b68448557360fc9dd5fae45f1cf47b184eda124dedc5e17e2a317e3c6a287883722a46383527c4d6fdf48564a3fd7fa1a14ff5fe223a860056e5443848e45f74fed3a72027eecd1df1973e21ff3834038768225b5d0a080d4346d84e1589b4bace17acb38131c618d417be9fb1e1d059ca43f692d23ab4be1b176dca3d11e0ed8d3c4e111fdb7a4156c1b2c91f079767f16f76bd5dbc48551649e91efea81f4aac25da585f5c0321b36327ef0f2296936a10ab9e5e4b5917fd196f389d5dd3b240bb088752e9fdb7cd6a7b0ffa8c82425d02b2764b9864ddae401e87922e7cc06fd140efe513185b2bdcc0f8e6ead3db560ea946967d75ec2807454f88e8982bcf82c4e890cf02139e948aa3d359a2ea1261d656d2988d39feb1bb2d3f569395097f2991e7fc11f6d2e2b519e2b30f773ebc63133f9310a925e76366cc3dc5eda3f44c59f5204f6e5c5cee5bf2150747fa4d37c8a461c655f24a0b2a01287746c2b1ebbc81e991e001a6d7e4f3827e82731307a1b5eb8c1a7471600cbf87875e51fe1ce47726eaee360d3590b192d6ac8dc59b729386c7226022f16d1eaa8329d1c55150dde5804b967e16f5cd44cea709e924a5cd04d86b448c0a42683815d1b5225d3a7cf45fb0eabd9a4b4066a7c9698b6a1bb6840a1579f06e72608d3b14e295078f636b8d9a6fc3c6d3d0729869769c182ecc6ac76e2320e431a2fd6ca14afe3b322c91230e33123ab6aa2376a8b610355dad6789e5d89222df9a50d3ceb481e253541de8e78e54ee2a23d1824f4ab738a4d0325b42682dd16d4b739662d80b61bbaea87fe355fb97aadeaca1ad15d4150f7746e5c62369abf97380da9ad3d11248a02b68f785b36d809dbf0a4b6ea616c7d6d41d2a7b036a267a95eb81a0f7aa26b9e0d1b9c36296ece5561c2f7e15dee98f433e23aab87f44d7f3f11bfcfcf5da5f9f3196943d51a5133577e912cdfc2fc3d26c082fdb890154836062261b82285b9fa558185aab67bfd3eba7943c295302e7b4b7e90a0dc542c9c97c5023b597f1c269b21060ebf2bde9a2aab4627a843a05e98645c9a714c4dc2b25283598f69b12e1d2c206092209c211fd1db2ea8b5c9a7734883f58bdb9b0613d47101a37068ea300b3e06e01542289d30b7380d0e170490ef59d95d87ddaa08f3485f803a309e6e31b379eaffcc977d8a6579217be81ef5c5f643ae20c5830c0f48fa73d00456bedfcd1b7c9f377e11c6eb31ff4778860f1614c06c00e345d89e56c8016fce731957fdf955e45dadc3d1a170f31de4819b781e13c2b0be3fe6f67bf4625a535d18325380f37f271b73e4d6913e5b690e5629860ecc8544e90842197c7a0a90133da62d5bc62fc1333364ab192e2416690bf5a0f05fe0599738e6b980c04600855113676d4283dfadad669ca68d40cf5c630c32690c309315ce23411973fc836efef2f4ea3ec05fd117aa508717e5b37380e1ba50fe03b09774507a25e36830330231f9acf632574765ce1ae868a650570c080da38f74898faf4e44468936a488520b2a9224dd770724b5998974164de14f6d823b3344988486ea0ac77637fa77f00ed72df59ad63e98eb9ff1000e1bc3db9c5b084f239b5e9949064a76d98ed1c7f80e3e5ecc2267bed214f794e5d74eed1ab5179044268f026734d301d6039ffba261fd3ba1fb11c62ac26483d9fe1ab0950c66b227e8f3396649e30d91f9d8409715e1b3892735dd63c04c6fcfd2d210b5abe8020202105ea2bd046d4695c3b23494bfe3fef892cae0ddaca81220c08a211fa28bdacf9edab214900983b4c91ca3f72db11730d627c976a051504002e5151291cd401c9f7f606878dc081346379b367057b5d0d9f1e9378002949351036e6cd2ec89cee735b1a061a7d4b0f1382fcbaec622d6914f406660d2526fa416dc772b8658bbee914e4151ade28ac6553d8fd8d9d67dae2822f3263216d72fd242001126f559bbbbe71fab24139e301b96f5601bbbe0ad7393115cbfcf3ec45223c98281c65f498f0455ac3ed9103389ed65e860eb82fbaebf95347df3be4cefb66599e7457dc72b014004e0c9140c5b5858c0e6879c5705ad34214e73a62fc4b30b7ca96c57d0d50517efbcbc49251acb798857d1ec99dda9b180713689b69dc72650b3d93b13332c228550b674239b0377f95241cf3f86479f73116116580598e54faa49d15def8179a27530cd447d4e0dde29067f807c4c10ac27759b9c1a5b40427cf96735719e861a089f73a609986bdefa0adc1149cd7e28e19fe42dae5f20749b23287539eeb748a2381ccd748cf5f0bc564d01714a0b9c50b147dcddd7c04394a5f00ae76b49331ae9da692ede5c381388ce848c22d687a9fd9613d27f846d5735c230cc3ac29528de7373eb1eec37346d8b08be427073b749ed9345790d8d49777c63d2cd73c937f48a0a84ab38a45d4c2fb5e4f2203e7ab92e67eca4cb9d6e7e4d41bfbb3fdc766e2ff94f798062fb37d2ffe6498f4a7fee441f37060fd487225feb670b61d746e0cb1c8a9cffe2e7307cacf60042f40773329ba5c6113fdbbf08da64bb742ae72acd7cac5e81298e09cb787d6efee9bdb898e76a2e47994bd3cdd02cbee81267e74515ffd41b9d90968ee386f89bcba6f76308a7ac044ace6f013ee049c0b36313ac505fffb940c1c800dee2bf5212b60dc10a93f019cdacc20ed2ab13b76e317c2f4b8b1b4c546253fcef65ea5e3d3402742cd75dd3efd80498422b94f8a7cf3f92f0a15423ec70ba6c31419115822b5bb0fdd9219d5c935ef761014030673b977198bc4d9c441f500798a26c22d63226e30d8a4793d63001bb0b0847a1d48bf1cb570ce7d34162069f32d48a302bd9c10fdb1ace297e29263c5b4b7a6513c970adbdaa96925b39f6702c8c305ac450664016fec4cb6c175a98537a1d2fb7486cf15d3786064dda72ef81d2a1e6926d06f9599323c21cf18a326b9e99fa14e2db655c30d425be5498c0a0c9ef36373002aff583c7b76a9a3cf1dc5d7f92971c7cf49c58469b42e79b460a03c6c0506a22cf309fb4bac4c2b99ef1078f6ca4dc39737ef4f231cfb11f6d50d45a29021b21928f68b5efda86ed2fb7449c85931dfcd92b36396bfcc474b57c53dd734de70b27d2451ebe9c7455442acd74889f9c40a1f38025e964ba8433cf4dbe5a50d366f56f36fe2ad697614472470acadd1da10f510ffbb7b8d61524543ad810cef3541876da399a657b56289f1730e7e7d7be680cca7198ce579f9b872417f9e5e1a4381466abda9a127d60cf30811fb8c2f881402414b82b310f6af08501d07221470582d4cc05b8fdcdcfcb69a13ea75c8945577627292a92dc0f41501b7d74038b89afa0432ca6a0147cc7da9635eb35f54eb3ef815504d2fd15d90c957390399b958efdbaca86c6323b3326b964fda7c728c8424f2698efffcceb9befd8bad512b67c43ac75bd1e0990871ea66a4264cb7e516ff9277ba3b2788898eaa4a5709650203a54f691ddb3ef5187150b6e4e6b71cce2f97ae4355acd7093d6b11a62a7fc3b4092483576822c0277d5b1d5ddbe4e20e7e3d29d30657a8f3004753180e6d1875788bb5fd412052b2595bd823635af73d9f34fa04630014acb2fe950f86a1bc70839f4a9ff887f921a879d2afd8c45e5271a9f2dd56b923778c1bd551306d9a2fbe399076ff1af30909e5b91597b437bf15e3a8787c79ddb0b16cc417d7870764cdba7a21add6a2db226dbf3b0fcef024c929fb7de4fea958b05f40e78824850ba2a5a49dad1d162b485764abd279821bc70591750ccdb342b2434a383424a5b717cdb632e21e8d17f9c5f52fc0af5b638570ae0face19e1ef31d7cdd8c98eae12674e59e412a47940304380d900a8efebcb370f7fb9979843210e1c36c265b576f9b8c85575c251e6b97e70c02f5a223ce86b044388943ebcdcbe529e96876a0a8cbc3e79d860aae1598cdc8f7a9b311d924a99a19fd10fadf8183be7646805bd53eff90d5b3352c9da14fa3cfaabd0668d18fe619538fd9fdf58ca92b7914ab49052a712e7b008639da3ee109a39d71bd0908381003de10dddfb8e19fa7a945055496c0fab51240c329ac9aba46ca3f4dbf337096c643614c6a01ba8280dd2ac1f91b6a6904d4e5a6f4e3401ecd1bff4a03a35e8db3aaeacfdbc032c6cf0714c3902404b8dfce72941851551b1bcb9cb4201e7a52f6276f3ae2c596e94840e29c115731a5e4981ccfbb5235b50d335a7ec873eac8b48af0b8adcaed9a9452843b44c91dd5afcde85d1c28d8702ec32061e285ee3eaeae161fdb61501e680ce587abe1d7710725bae2a65fce2b13585373acb876f352497d0d05461efc75902ac46f2a19ab79b316a0ed21a194c2a4715fd8d50196270eb0571cba1c975463554c18a5bb307e23d357daa71d1583efbc7e43c47a811c3058faf21ab618129adb8dfc08c53b8384e1b083ebe65bb3b22371ae3beee0c81cab184f551fbf8f256f320013f9ea0c72938ffb58900d17d64bf491b98cf039b8c094d438b6078ea40f0688ecc7663c4a5cfb4432893fcb3adca4a927f7a0319c37ee9648ce07a557bc1b2f8ed65891e4c7d4abff3ba38e3c7274c0fa8ef4079ad0505dcc6851d53812044f30f711115e3d1406cbfd2d33989e48020e7953090fc109e4ed50e6b8cecb35382fe19a2cb97279b602e0d11c158f36ce5f052267eb4f2983609daa4789d80d00ae3e2b7f6b5444db1b21a528cbb60ec30c8f0ae4ae2b01b30d7dacdd22276712adbe92111151e46fe56eda6156349517e453f6ffb13fd91117629495b90ae3ff32084294c0247a3f9e113083b036827b6ab0652b974a772a513e45913ac4f5613cc768bf95ae6275347b585117ceb40327bd5b7bc3ec8538b91e77b3ad82f5db25ec304d450517e521ad3df745071b56d7a172b67835bbe6dcb7180335bedcc09024b7d6e5ca0b1b06cf8743905caed9c2d21fa3a616803a0da24adb22b56a6748deb3ba017034596b608e92e627d2f9ef299fad3125c8155c189da89136dd18de91bd8d0dcfa32e86de84dc40ab6162b3f0255a98710da84ca6511be39f610527dfaee5627a2e1993463650236c7f04400f622f879d7834956e779a2f4bdffa6e4970120b0619fba984705ed4f0f0570f852f73cd047428716fb4d6285cffba286c219089844ddb5231a9f1146655e85479a91b29e75010da7307babf42274adeeaec9bb87542c2c16dd49284e9be15fd70190ff3e43ccf3a17ecb8b6724e3ee0a8b03f333bf984c042325b4645ddf2db93c4676374e22d1f37b5a6cde64b50e6fd939b1ed7c0d666c919f4a4e0609a8e3f8f7f99fb3792e73458a513e1bb5029c33d3c0e8078d95bd9196ff55847be0a28331d25afab96491816abcc0048ef77813cded8b9427a29b91d96f9a544fda0f526bf4e0231d4bd44bfaf9f3f211659db32220e0c0dcd9ecad553bf5f7dc35b4bd41b13c1776bc7b2e23d9c7ceadd519d69dc943d97450dce7ea6d87dbb9841912cad37e3e05181b634e5f88a681bcfd54ebfa026dd89d6da15993d2252c8a400cd19863633ee819a64f6a370c712c1ca652398bb46b73b70b49561385e69e87d814bf5b015cd05e60a822916727323dced90dadbe35e3b8855808d9f26c50283030a1f2d7c6dcbac0996b513a646848f10e0878a52e1af52de8f64ad89b018cbfa6d6c59c35e90938d8e536283db025f297ed928b7f44ac94e1cc98d82da17612cc8ccdc313d83076b2df4a85ce5bc62e2bcad16ad69a3e8474400aff940114accdcbfa60805c495b73b230b2298c75ef862949ed35146a9bfc471dcbf353db136b2760e9a778601182b576f4de79c7fdbd9c3a76472656e0d68df4a39567c724de75f3ce67c0af2866ce860e06f203752f33a8cf9be4b546496c81f7fedadd37bafba06be3112dafeda09b1991c6d0dadae2bee11975a9896af4b9deca95d0c754d07b465c94810dd0d84ad07586ffb145f2cfdec52b0bcecbc03a237a88d0931b8c11477e10f2d4d7ebed8169bba31d8367f137f60fbc48a608f570b6bfcd9025a1b4f5b8ff7b7aaa1ded2bd47518bcfd1f83e0bc22fa8bcc5481e10b606154f590087d374260e5b3c7f7dbb015817f5c2ff97172297c5017dcee1c556ef0a32d4fb488c3ef0612504e7f8c3fd2c3b9edbd1e1f1caddde3276c771cd164487b11a7df29b5f09fff9a9660e2adfce1b67c8e4c75330861222005a91f5056aa131e21fb8630462ff2ed1ecbb28d6a12f4b5cb799904b0c42f9e3ae0840f0e2e8cb11a11308cbc5ca70bfb6366611e05f3bb7b63964b800bbaf9b893ff92b0fa3ab8fea92b51509ec786048f1665114ff4ba923d640b6568c3dfa8217f1adf3ea1cdefa9e5985dc8485faa9749806a1ab705cc483dbb0694e372ffb7b58fabe84d9959f823bf743d72cbb125bab3b2dc2ca011ea687d6a10d0f56ece34557e9b61577607f20355f409f6b7e96ab39d4b901fd28890eb579328cd69d97ce73e142513ebf9be541fa4847b334eddcc37568cbc215e0b480e757b65a1dda4c25b39fdac7803bc02fb39fa55468ad60aa4839570fcfb2cfc959e00a463ae4968a062f82909c9fcaeb80cb0bb842c4302bfab3d80fb58445bd2efb35f7ddefe2b7bb6c4a64577ad93d6d72e1dd02836d433f1a88ddbf525694525be2325103767fa6e2629b4aa9e5e98be6d54f9e9dc52a0265492b3e7b6e70cd10213c9900a00210b1b81439f0cbf5f7817940e5b23c58c6cf7c3d7f0443a41e754a529e584736829133e112ed300c944ffea16ce54d3b0f2b52b2b31346c80504be19f4d15e10e5f5c78ff26df634ca2c8b72fcd6070d36acfa5f698405529ec42ea4048b1979923648922d297facafb0c24b904e551bdaf2333512c423c1d4094d0f8020d29ce9d5e75579a6f7ef0923da442f0de49be0459151e83897ca55f99997a77e2596deef9f1d52ec4ee3e436ebd40a22334e899eb7b35c7914edcb1ee0ee43983f8f7913d4893196a124d923751dec7334f4eec91652e6662a16ab7a96244d0d4e88ad3812e963708edfcfe1f11d5b3258b995e88e74054aa6379081219b2e16098f1edd1e9958749dde95752305e250638e3c89a4be4b42be5273e87a7bc6a520f0a65244d922b0cf6ab6172723929be6eabb862ef1c3fcb3e9870b7e5f30af018e29716926af763247f551ee1cc07bc32e156f23716bf5ab03e5cdb487b2a5f6006bc7c8eb3d8970c33759c85bd176d2fb9c907c3d594835b57445f9db280dd9acded1ff3fec0183555bf89c820c6d6eb9251a035b7db3a5c7aa8428f2aa73dd9b4ccf3eae39953b16191e24ee6bdbb0ff8f77a1899a88b2c5f0a8c3099da5aa6d075c99ca5c06a44762c2a91172a58a2b85352134a5bea2eedb577f12bd2ea652d7d0c8f7083df46bf616cb022aea9e989a1b8dfb32efc74c4151ff512f0ef07ca4475ef7a586bb825ddb7347e6ab398a3cbb1efdbf498eaf4991e0ffc4266f162b8e3292333285df5c8994860f8c91c60977bf6dd984a92ff0c8191b5986bb1d90d85f2c6926e99911f5eff7330624420442456c8d58cc358a5a46485fb8e2523669d9d4a0d34eacf73059f10d65844aed1299f9123cfb1cf7a73313b37c84825549e92a156fdb816981c4f8f0485707494f87479017705c735b4224f09c5dfabc5930bfd9598bb0d6a53b07a4f192d76a461bf82093c4a6894d85ecd42c92da6c08bbcd8f842ae3a3b78aaf8942dd55044f5cc74c6ed9ea75692dd7b37f1358f2abc4cb4961128443d212c1a7746acb4a1b9e322ac0382f2de75602de319351034eb5f4d735c3f283f6a1c53a86cbec0b348f508c501c12c75b6fa7cafd578aca017f0f6ee858f3dbce968fb311876e3525fb1b2ce3cfb496f592f1d1e45559268a97ecd8597f390ea612b6420260e56ca090125252ed4dce932046c406a113195c963ccde8480732440f60d6de565ff3ff0400549ec3b5a29d2df44db92c5b7dcb1026622c28a55cd664a77e1af4407e30f9b82f7898c8bade6dae609dc8eee0e53084b84ad78d0acdb3b0ca84d99a2a03a7c6676e525277928f442e8adc43b47ead3dbd6d77c198a4ef3698b6f3c0a5f808740b1589cbab718b77bf6034289bed3f33c06084938c9005222c652fa4ca243961314aae1ed54af254165f1b762edfa069cf1a2c921148cc75e47438c22c4985520e76afaeb52bee32b857f5ed468f4eac00e0da84df739aac0c7a3fd8aa8cb7e4dd85f5d4258e3154b368ae96f56ad4b8f1eee211ee284da06721dcf438e30473e86a03eb038bcddfd86fbc19b9efbf6428f7672aaf64382e7379d708a992693190adcd418d84ced1b16105a06ea9c6dde9c1e6f395191773bdcc42871cb80117dffb1aac7ecc76911be85c02a98503175320be8cd5fe2e88344b5c25dfe79903e86afb440b15650853f74810a91c311b7fef1d35efd91b5c44f44b7d14559754b732a34d64e3d68171ca77bdc37a3c940a71fd71b731979ca41d0966dc81279e8478d411af0c2249cf8fff812a130982a607c33066ae15ce8f81639688d721ff247868346d6a21672673cbb738af905ede72316731b58b9328f9b7be97982468177d1f12f48245b0dcd2222da8af8eecf7008a358fba5f4ea42ed823b1c0b484323d6b8436a580164fe9aec558d4987e74adf50d5fee27782662d498e2dfcc9ed06ca6c48d0c52e477c3668d5fc532ef075ded7f04094fe0fcee663038ead41a76fb292f81692c7e2cf2e747f13f42918b5c718fb59a063d1bdf054a17ba48f83adada61c335cd58da1e24159e90bc6842e69cab3f18f2506722769f2bfc60c69bff57f5f02feafda6a4042f5e972bffedea97caf691afc3bc7eaa3b22ea4376c1af89a40ae3c395ccdabb50b524b0b2ff002bb522154d5c79af285bcb716c56ab0044e9cf30f7d131a5520763c6156585fc6657f40697e591ef3b0c119686d65e7b28bc76930bcde2d154c196c04635539c2d19deffeefbfd32344f27054ef68bb500d067d072ad28bdb8ccc0744fa8d279473af8d959c6d19c9001f2a4f8353e6b2137cc163f20a7d10528dea690acf7bd4c0bfac618e61f456d142133f61f2c174cb3c1179b692ab930c402efcd4bcc4a44d8453476ffee7b5a9bdfe7b272101bd28a3533a931d84db23910e66d03df57a5a139b2a1851c0fb25e20cbe75e66542fcc747983e0fdfcb9187f6ac72c71326e7fef2a99018028bf246fac45ab3aa7daeff9f1b400bd9c4e74c6925e75363360b4b53bd7b09bdd9c557b030bd6823fe2a4b91c9ff11023998704a19be8198c721966bfb06f0713bec4fd75e2a4e7012aa94af6d4be00bf4a63811033e36010279320829f53b23e2674dde11c9083269030bb217fcc4fff79ec0163a76159c3a81c967be2c369c362c2b8aa95f60c6c40e52d0ba1b9c68c0b50f9d722c4a9f93854ac53d9cc9bebf97c6fb1967f8135f84967001bfd8f23b5ae9e92b671ad0d46ea7381de07d103c251057a26b73cf89accb8d8a336ee7b45af317fb01aa255dad0a0105274815c904e608e86fb5d126b128291afbbf46d0951cd49d2216554a5132485106cface8a3b9e38a4c28ac406fb4e42ced7e8f01bbcabd22c5f97f807c53a287c7556bbb1d10e50d10d9281c60c53e16e7420381d1c90b528ae295ed36456140b706ca85ab419106d54bb6d644f872b0bd91c94d1ec0958e5df2e44be45f4987cb34ab746291d12d20f6524e7835ee2b55efc4c736585f8da6a9dbce5250c07796eabe228a4aa855883c01060d4a4890dd7144b2e6f23d0f6d7a78654ec21424d096d3f6c3b0576c63e9d7f110de89dc82b25d045f7884048df50821c7991515e7395691ca9c5c7176ce13e2feb6c4affc3527b7dcda3587509d2b5f0ace32fdec88d0623d338bc10ad2fa2a1d9cd5a4748838b461450f07214d491958b289e6cca12e9ddc31fdd5be0ec0a2789a6af72390d9913242f1d4f44574f494eb58c55a68f93c76389632e1959f75d975551d992c1094e9022a75b5aaf506cf0904a8848e192cde6314a787246e5a4c76f37f72b22094ad497ec73f596c24c9dc5a559012a4d72eb798a20543a3cef2671f6a400f8561f622df30f852a99e8c0d931d5d17bd7d4654438b4f082da3740e749d95278e3193a5a7ae0929d577cab911c6b82e900bb31cdf6aa565341734c7d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
