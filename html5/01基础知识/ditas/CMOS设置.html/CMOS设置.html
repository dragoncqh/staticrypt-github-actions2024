<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8652001f6602ea8c9aaf1f0c41d27d1ff2c3e508c7f74c99e39ef88c9230d40b55ae25973d80a18cd45d657fc412d46f4f81aa97ba46e8c7b4d99f181dc81932318bae11b31a09e7d380fea54e0c420848ec338cbfdeb8347ee6b55686b2caa5e38e92e6c48d677fd7b263ed47f4347dda4a754c270ba385f4ed646a14fd476508ddd7809b084a1e074b9b4904f714152d8e6f5c9dc97956eca9dca37779987e4aa2ee260a97f81be9fe44d6b9677fe8b96b0c8fb2f2f1e86f69fafdf13aab2b2472f08152379a53c656e582a9cc71c85215d37fe3c30ed88c261e64ce2bd22c480a8340ba37273068f3d378e4e5d90b1fc45b8ca43b34ad0269e66883caa5ac4248dc7b3583ba2d434907a6bf783f422f268ea6894512f76f397d83eb2097b564a0b01804cc7a7f7047314263def78ab7918cff0bc7cd2f92e22a8420234633c518d6bf30ef4bb63c0cb0a0b5dc87e239ea5bf1249d99f36c213531c1c402ba384ab8567a2562cbc11a3f79cae8c36af39477047e53f5fa07210cf6f3d6274f9b0c93cad97a168812f3385ee09fb7491a89f605cb4fa61ea450e6007d53bbb7c6a3835c0c724b02512360d3eeb7e50a0899e7be2bb823d1cf2d2a9f17a75b0aa1bd71d44a5f2f02b8be0df391073004a0495a3877effa6709bda9604e080034e26f89b7aa1e9e2bb9703de09d1b3e0d9ac63e4fbaa271e2ce4ed4ebfa99fbc5c239f402063c0add332f78a5c7b257a1d0afaa5c0dd62f18731cccab0bd6f3f97115b964ca05d8bba67dcf134803d4e4f721047ecc941eecd2ebe143db0c60822e317ab0c7dc9c4e0a0eb8de1c0bd81c23c11b22ef679a2a4a2cfef1dbc13d10d3f7c708be4d178451045bea8ef6b94c1b159ea9378ac98f958ac90c75d925e2f837945a32566559fcfe3f61b4ca6ec2304b84f650942e7bdcb02fa65aa4ed0f0ad40c6be01e44a44def22ac83146e75b4be3b52cef5b7dbe37d0edc527c4b9d6d32f1b059759be8c4db7a465c19900c547d3211d5a038d5538fe7c7d29010db156b4461edc5ced467421ead53e418a5c7c0b31b95a933b7dcc4e4fea54c28accd68f33819b6f1ed38c2723029d48ccf6274b3516d5fc1710026be3494d4300bf39dc3e8463ac9c8b25be15be79552c9d008a36093906ee725f9c84947152a68ff9a87ef63571baddc2ec29ed0274bcf5948414e4491a7d7aa933ecad4b540b87719edced8425714273f25f4f29b1a28d6fcc27177c9e04d0fddcc81a933e698f8ff8ae88b9bdfb779af958844bd37560369efd80878996c1282b82e4454cbb84d77a56a3f4392b1739213844e0fc79a3ac64498727ef31faec46a9372780019d0acb8b6d465da91124fcebd0685bb8f840941d0968f2e5cd84a81f9833e06f6f2ed8d99134ff21918304461eedba7758c0e831c329d9c223c0dfe7005161d5b4ddc982602eaa8cb5dff1630236bb5ec684193eed54c7b990d5515de2446b2ecef3c115ed42da2718c99379774103eb4876afdbc910d222a5774d1efd79219f8767fb752754533c89710903532906ae08cf3f3bf3b3df1eade632c24261bda2d90065a30758e50628739dfcaa796e73568df7a72715e4882b9228b0db1c75403cc57e760451413d60517ce37d458d02578ead0d1c800b5406dba2cb714c4e7daacd683079335af6045815c7d2ffe1e84a103e163dd2245973a0ad2d9f8be2bd5e6ecbcf0e0e2e54e9971535b2a0050c16921d138fe4ab3957dc6963a0cab7dcffb12e022266bb3cb52b7259b4a3c8b8d3b9c9fa47f955812bf5ec44516e62cc217550e259d705b5bdc4abfc20d445664c0a00af2e5a843729c90523293809d0d4b68d3145fce11f8f158d142b289721e1fd17718f7b7d53933a288e0a97a53575735067b2f12f23d8ca7922bdc07dbddc2a46bcb5358f0b422024c8e879b8f06f88e0f659fc65f5dd9e1842f02c9e330084a2030065220dfb91b6fe6f86dcc3edadc12637617f0b76841f2afaa7e5cc72c4a4a537e99e3a9069ae8d829e7a7f4f8e9e7f9918730eef33cb578546f15b9b3a99b418240977a66f737de32c77f01eff130e2c6394cd8c4163d944a9dfa2218f162f54d3f491a2a4cb7374841115945f540a815807473856c8174ce02650e241ec50794731c8c4d213e8f5b9f70cff87d915fa1c4da0ee3912f6179e217e5fb02bb27c435a1df01f5f03b228869dfdbfdbabeb7d406182d8199cae52a49990fc9594b0aabbcf2948d2bcf3db3b0e159feee593be418f13e39d9c87535d76ef58c6a5209077b2764794a803dc07f4c4cf6f27df5f94523efb4cd6d155beb0092ac3f36b5281bfc4d861cabcdfd0396ae43f3a6663b519bb4ba05b21c51107229b2c6a9882a0c2d6028b154508bda0eecccd610186ca248dbf4b95cc40e385ed5df6c7799cf0b9208b982e04619d92e55b5c1a21474dfe4591d3217ad1cd68fe850c78adaf98612621fe4f7d942f3ab9c92cb59fbedff01edeee525c1c1e8b314978104b59e7478167e593598a4f4733a8efe190e6f8c38bb98635830f88781a22ba23b2e78a1ae4d9a8396491ec29adb387cc5fe436532ddf3f95448f1b31a3add44b5e54c28e087f3dc1491cd1ebfd35e740775b6c7b553bd3e1d8a53e34eecbffd461e56665056ce6f95f6df8598e651e5f1a2588077b25506219ea89469f0837a9990094ee443e758539c7386f1ab737b6dc45b462066c324b5ce9c2ed44c82add717ea34e681651e114bcdb88f5f15bfcf68ff79abd149d45d424da8aac2d84c542fe2a3a73f9f1fb8572dead3c9e4291ad73c1d43832e0a4a101f4b1f7de13c3834fe17139021520d7c61629251b31b8d234ed707f1e6900ff83b86f0e3b0d93205f1a0d62d960786b057cf6fb6e3e4a48fab822c07e3a48a5cc6f919f1a62c1d6723dd93c7e96ebf4d61a0ebe23f6a3cb432605066f17d2539bc83cf83c425aba43ca801ebf24bd769d8b570274cd76a05efcbd006bd0b665e8e7a15508c4382b2b3379a3e187f5c30d335012b6214ba5ff4589a0866646720df5fd09e611e51177795b0c37ec226912b3972881509817c6946eece5edde64a10a08f79c035a3a6b98b3d712db73891985743df90d2a53bed9e66f9d6e049b5855b1208aa9ad880f6369fbf399a5332e074fbc2b20acf9fad5df9694c6cd6ad77eab08b6380c97c2f0510f7c17696eb9ead887a76544c5122b601e45d97217cad36c298eb164104ceaa93e9c78a6648b7374461c3550aaaa79af93f76e9432e1fe9cce9a1369108e71ccebec26447f81ee9ad6dd87a0a7fe24f362192c50fe928a0304807cc918eb49d37236b4bbee51e2d4d5d0121fa137a5341c09acafefea0671f50219181334515dcf07e4f7bc779393ec10a4f111c0d3dcf87dc274e0415e7dcc3afe22c46472a489c94deb564c16f9aa07c66aaefd8c2d224e2b68af24725809d6e41e33e338c161c26afd4e83c72b98a911c39e93a52c293c88bc5b52f2d6ba6051f7d5d11dbefa984e14d253cb29640680a2ee2636fce9baf97698cdb7313e098fb21d4ccd7c5a4990968ad33aadef11950dfbbf9bfd2ffa3b6d4292d583c9d2ad2636178f9e506b30945beb02b30de4ffd7abc4b5d6460538fa333522aec61751bb6c1d94d54330970599facc9c93ed5a151453fb2bfba42adbd6af5abc6ef2d686504a7a70c32b0388bda8eb34dc2ba376af0027b54d066fb30bca38bf115b2124bcfe27af108ae8c681afb25917db735cd7c5474dd4039bd320639ea52103cd496c9a7135f7eeec5e1d3035ff33ac6b90611447a80e46d09742e6a7bc29f58e7373db06a8c7e62d0fbdee0bb554e7be566ff0c28817e445bda2b9ce25bcca9f16b8578da7d0fd8bebabf2d0c8ce60875941c406bb42f41b1b974c0de74843580c587dcc2b1a40563402b338765964a0591ff68eb79f050ef83bea0364ad47b3b42840f120722dc3fd3960c225d96b22372a49304072dc0b8efe275bc973c2525e0d33286e7f4b851d552bc76e62ad31f64227c82f0ec8437a9251fa95a4fe9dcf1ff892a4f9c3d91a14d8353846c1302b1cb598c37463c8c38227086515cd1fc93e8d4cb46d89e2512543c7a5f7b4f5a84065ce1a0e1c31f3952d235533b9592287c5877b5462361cc7a8bf8ad75b48b7467bc73bbca0cc77b74fb3f230ba366c4f92418232b5189f76e2c372b858240cf003f9befa282e9af43c969bf8dfb9687c8e353e60457b90eef85342bba8d6d99d7d72299e9b5df34d87c2a57570e055c90842bca5aeb6b027668dcaf03746d624e176c935fb794624a782c39e8ca9becef78f889383862fee6729c2eaf7d4b7c4c02643a2bf7c4ff3600b92649b123c61b7db96be1b5b505410bb6e0263aeaa1c0ee9b6b77601e440c0cfb36d8ba63e7e8d03b21348802b55f53876de13a376392e2a437fc7e4a7c99d29874131e5a6a702470cad3048bbf58faffc3fe91846dee43d9d6c469d21373e9c28376487f015b1fd863f489808322ed20dde1ce28045ccf669cf6b4e44c1b47a69e519f2977efc3fb08b1371896ddc31a8c3da2c5e20333ed4131eb3ae9f8af3e47c481e8e806205323c403f8145017c8ce520db53364867a16ae8c4749d77c19d44692f9aad85fbf4e6476374b09472928c918d5dda8534094408d4c1c7ee4edddd6ac63f19c09ccc67c5a7134fb5b7ea2e3794c2d2dfc7aa509228b30ad83d94fad94f8219240d6b7a59547afa3d871792ee33cfe11a24effd6e6378d37b56e7c8f95e5e35ea42e8694798c0d81ba807c6a7a70b24a88f625e4cdc97eec4fd396747070a9c825a073e21570e39ebc3edea635714d8efebb598651cbcd19f5abc10a0060cf8b3968963295a70e074cf04b81dff5576ee685916dd0218edd72149979f3b7bf7727a7494d370b30a56e699307f4fc2d02b36090163a01bcad4677ec48e61896b7f0b03a1ef171537a96b1399da561c576aff07ecdd4f4376b62718e992dfe70d3cbe5fffbddb521dda7bc132936a4053aa8d6116ad48f53a33827f253ebe165e2ef108a50886ba87422d56ace96db10e7090b832dc64a7f6cf3169c8867d687eb9d1b1a218ac94e28e54498c6907ac8dc9d73267d62e6450fd965682e1fc447dfb827f474186aa8dd316d4c5391496da0b80547d5180c01c4cf672ca6a9bc3e46382c7eb2e5b9e59f4de2dfa881d23e2d9653279db666f97fd58598af1f144a68cd37b20985ead2759e3a10f193fb031a7dcd690a77e3effceaffeead47caf8d12adccfcb7b2c92466d91ad378f04e5e8b46107cc9304ebd11d72f015397d697722e18a910ccb21ed7b91583842153de79cca899004dbef1d437e65fbcd9b34797e048ef96667b7f47cc4401e24ca84499e8b55efba9c39da14aed7fa528f483eb4dbb73e016f78dddf7eb315c4b80f5da122203154d75282dc2529d2ff6278fc8712688277171d9e7c1e5c4890f1cfa48189c3290ef0bdd40e6fdb3682ea1d68abe2e4dbea6d1896e176b0fd179073af2015c86aa76d4eedea1ef6a8e758b4e1c8a1390c01f76ce91c701a057b91ae8ad85b8603ac473a12148de6f465a284a1ffcf006e3658263825d12ef75312ab29430487894def3944658577070bc0ce7847930ddb64d1daa144fb080b1ed2c95029a62ed28d3fce5eac42f0856abe8ffba9f5af82b31a6bec4308f135236deb397cce4da5c273c5d446276bc9781ac205077715190ea1b4106d8594ba692ba90ca4d2457dc24bc10afe12a2a2ad01d786e57cdeb5cd4ac7e4160e22eec5a8391bf778ff6650b773df7267eac04472f2372f5e49f950fccc7ec756c54645b239a2dff9fbdffa29527676fcaf458cbcc34b5a16bad0095efa52519cb5bb2caa63cebdd09389583923dc8181d70ee194d0cbbc33179de25b0b39b4bfce98b12644d4c0fb6f25159fae374ce9b995629e4d4ac9e23c24b418551e9982f779170fa9a21491d2cc4a4a3b449fc8a17a64da95ae0b2d88273d793cd62c4728dfa748e4e473404d3f27a727a7b7afebc1eb54c38069b53ee6a65edbf2ebe66b512d5345fe2a7e83fab456709d644a54615b05d0b788f21f48fad1771e56605dcfcebc8f029e12d12200f10ac8dfc6988ba3c4e678af1726df1fd77de6c12bb935aa6ae70c0f0d11c8408983dd8666dde778ba06463b8224e03a0ca5c1a2ef987cc3ba92f79a80d651cf445de5d3c02d85cdb93ff6b03383ce73897361c25bab195617060f89801ff629c56c12a5ffe00b65f6f4350d36115b6d836e20e5a56d499f0e82ce0ad2fe1a5bdae6939f3a08d5fc4ea0363cc353e51dbefafcffbc1f62430a41b88e8c4e39e0abfc9a6c395534ca1d2cc0fac780ab78b51a17568eaa1672071a0d02f79c65ddb791c43a965c3d41577ff019eb3c38a65be8626888ca53813fc53da1c59f6f1ae45572de43865b5fdb3c9c1caa0d8c5e110b4f4b6220d1c201aae9d566d58382413e89d343f0649e9dffc51a04ee7ae20cac3c958cd3601ae825104d1763c1c8fc7dbf24fceb10a8a4fad13e6f2566e584c612145b6ee1d32b1cf7d95067eea3df52a53cc2765db01d5abb1e434967d93ee7f9afba88e3f049c3683ef3a2ff7951c77e0b5dbfceb212f433270b747f4bf283ce8fc1cdb31964ec31868b5d6a002520198feb1ac74aa8045033c74c66fcf3380981f8454365349fefd71bbf2a9e17b49c9cd576316656e8d8576b0a0e025e8a12c2fe188d1ddbef78df26f20d1932a8de84ffb1d436998f5158539d24bd62518c49865263a84669a20a50819bb5330377c66aca9b80bd399bb83464a8c846f99fda29672fe5442b48aa72d5b45b66c7e3c2e4c151a62a7ca8986c7cfc7440aafa9be2832fa361f6b895137f6d2b6d6e7693d473ba1c1594c8986221c4fb64f2d6a41478be7ba606980b4a3b5bf824b723a804f8588ad1576f1b266c7f43028fc04a3751bdc2c83663d7563460569e2759101a320aefa810ee607bbe3ab8f62a0e44a8fb51861c612e675d05c4c3f7a7bf9ac2a0e40e34c297c8da5f0788194c3d79ad871792c8cb1143ac646bc5a1145f72d6bd225e86c491d09386b6a87c3215b96d707040402ebc242d17f74d472fcc3e816c1f2a5f2e2f6c76eb2ee1810d8d00a43308b675d8c18cd924418795dd688dcfed19b5f4d68d1c1b0e4cf9a5c1f029a34f352e42c2290df60c714b83fb5c3910dcebcc0bb08c53ed9c997c49873b9551b3b8a16b9731b7bfd4deee9965809654919ac90b88c3903b3873f15593d43d2b24c372a3c1731a21b9894abeb3191b0155e53482d8b468cff3410ae38155459dcdb6b7db3a4c215aee0a18eb19684d92ce59ba3224f744634fd145d3e9b61a363912c02c11c50ecab8442d8901db8b76ed82703cfdf43c80990a91d2d7f680afbacc3766b01f23ef9a71c5d29e8399447d230fed8901fdc471564ecb46a170096cc12b9bc08f9aab8a816b67f772183fbfa2bd1c6a319d778d11ab57a25cdf550ee91c0a23940c44c14882bac2f1d38b84afb355d4e5a60f6189a5b20d785ffdc5cc97133e80bf677e40a2c984997a26973fbd294dc5d2ebdc46a74087c2cff8d581d72a2bd2ff833ab4c6354847648ea37d514f24ffd24b6f7af1ec6d9ea8e41f893fa37ad2444015d430134b8d054ada8bbd20895e125504d4669b57e08921a7d5ac878df4fa9e31e625d3f2e6284c5d88bab60faf9e9da64f1cfc20b4e0b086463c6d9367f5818640bfa8f58e2f12c39c4758517dbf31f808a60fe46e28635449e97b9249e0254955dc286b2e9af9478698f7378ea2c6a3fdd82a38f861edd8f49735f48d5061b5a0aa46b290c8679c0e7b0eefe018a68b44affb805e03cc2c07b73e07393a5a0420efe1ba535815a41f0caa356d6a613f625ef09e4aaaf3ce845150f7b9ac00e8b34b8163cfdd7962b22da6b4f18295dd7e06b8fc47a0c0bea00bd2bc88144652859d3f68ada6af4f0f8cf3744f7e2dfab29bf07520033ca3e8adf7b03d00b95e8bd01b0caf2b474743f3f6616760f63b79ebab40300d7467fff62e61499820f95e34cc3018565b06a2a3e336720fd9793a4ae7396b2c4f38ec8148f2f65d504969cfe53e438cdc6da1e602cec4dc4c396e3b2a3301bec68bf1028db4cc3b57969347154b70c82e5bd888bd9cbc4e062b7fccb59cd9b721dd37ccccce6d1a11b008124446494a2f25f3592cbbc363689d01fbb1f3d4b14423b004423deec0e2f1d70ddf47e2afdeac7f6dac89f65766c742d24a47cba60a746d15c42e3ffd381111ee5158a85e831c28e1cb077fff053d4971784551c748a8e7636b81f072d134387ca581378b6ea95c37fb45ac7f5ffd30f1a53f6b493db0dad5b38ebd49dfb1b80fa063f0b4f3d1820ca4e0fd867cdfc15016de850a02a26e0fba3c166371ebec959f15e4947bc34b10bcc174d38a72a599d3872c9fe67fa44ac426884dd7f37d987edc898ce8ad775c119e9b9214ed8b11df3a8043af630fda720a60e2c6accb1db9a97046adeefecd4f7e98b67d7456c4ad324ab37e700f03685d0606a634901510808bdb4a0a9e5b8080a30db792a92d54a1347eb14c6af255f4d8fdf4fd7057c1f1f3b982f78b7b4b48cdcf6619467c09e37ae897ce16c48f7b6f2c483dbaa337a3ce62fa321596144277abd0198084344ed5b4f101d96361a18d613c252fe48a41a538f919df1fb63db6c6e4912e3ea8717d415a45f1f4be6ca145b4916fa5d5720ca00ddf753741cf3a9f06a86299926113824fb3f426d3998e78ed89bdaf6858232f02d152821302e2817c09316d5331e9be847cb49f959c5bc3abd4decdf4047a635fbddfc6e8d928461c5c65d3487ee53185935b5acc9e3822b69ec65ed8ad392c66937beace2b0fb35b220870eaf085b4354a905ffa1b1ea1a156d63e69b922c38a641191a32ed69b535db5785b9041ad3acb678e903dfe319250542ce1e5ffd13d92e37de89088f69e76dad735ed200b6ad96d85c9fe82c28512bc8a9f07aa5c82d6da01e4c7cfe4223722c827d7cfe0e68c96254fa5722d593a71e47b27a808adfd0c4c7ff4a3b236711c64a54f90ca7cb40df22ea53e4ad31c88d1bda9ecd0bf1aa37e692643512ad65fe98102b1e0c491e83bccfc79ac62cdedbdc011a1ae46999da6914fe048033d9abb3ba601bff21067c5341d556b1101abaa98e4f087ca30527609d11cbf61e7e590534ce5bd5c52aa802bbb3d2a01bf01b49270d9a038bd1cee3c4e2eb130914bf3109f14069d937d2b59f5586058bee799ca8ba6bd769761da5dad672e0930907a02a5da4a8026de66624d8fb576e8c210bb077ab8fdbefe4f4ed8094674fbb131326bfc49b4a21da0e6cb6f0be85ed7faeba1d95d2bfabe4a73d32cf17d31e614245e00742f2ceca5c84e5ceb3084eccda8ebde3dc5965c1a7ec14452528a8330119e5be0b545bebcb918f9734d15b90e41dfb3e561ffbeb743d1e95cd32553ed8d6e9b334de5c7dbe3a4342531138da59a13f3f79048b18fa15baaee810998f18a1baedca98f408b4a036711daee01ff05d943e9d94a1b4a533a428eae1779cacb7cd7e04c6dd37e607dd42573c5b8b557b1719c612c7b6ca0f26751bc407c948c611d8d757ee7e6a97baa8714f06058ff3f24b45a15328f0596c297f8a6772513caea6dd3c1e1051d67cbc18af9626bb3840fca3e448088f8dd02614d95ae23ee9c81a22d75117de2b6ac9e53ce5434d76342f93ac6de6054acfd8530b014f66fe3df3f42cb975be001ab60ecb3fec0b85c87bcc3a3455716bccb55e97fd88e5bac808727e2475896be22d20b2415d2d0a0ab0ffb208b263eaf1be9e964a99a77589908af726a49798f861a538be01c2426bf2edaade37589086bf3655fc93e307300f5747f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
