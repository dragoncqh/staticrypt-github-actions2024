<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff1999a64534bcd30fd4e7f7522ccb6b45faf94448795b27945b6baf68b6173edc8e27cda6f4f83765e23067486ec3837d113db97ee166cf6dec85cf0751cdd1bbfbfc4a74392ff9db211ce37b36bfe36cf6779932cb1110cb8f93ad1c4af819300d4b341c98873d45c79006b8bfbbd922c5bdf77ec72054ff72586e407501d12381b7d9ac71f3f3e564466bc07f06caa055a7e3b2f67b33eb4d901a786d22fabb713d30f899d53325ba46521e11066ecc2099fb069fcee9444c85b19f062867aba187699988064a981696952f20a9fde439de98c8440be436382bc491e9d476898a7c49419db20a9f6406333e77a102dcff8a7b1b72532dacf2f5739cec45c46e36dfc5c55bc77c89e934a0ab46f0949c2088c9c75c9c2032786e141caa9ea61f8687b443de2ec829ec2479f7e593d9fc6803b0d9f51007791ebccee86d9404a02832220a5bacb5dcb3c6bf50bc5d28107b381547d94017a591ed7d10baff62417a16a32bc9c8da9defee06ddf3f54b2b69c29e62bdbdda0be73c421e3189824a57094ad3b187751f38ce9c17546c192f9054ff345414760e27a9a0ff462129ded94323895d186895e76b0be607f81b6feff527f3466e119f7fa6b6c4852d17c7e3e7ea43bbf6fee2e5ca50537dfd1f5de4a66578cac9e3f86467f971bce08dfcfe944f26380d8f999a0de2202c490b58c1f32bfa7c4ed45108348676b5d7f8e265985dbcebfc90748dc2a8e2dfa6b1005e22055c633c1596e82ceab9076b1326891c1e029c792b45c9e4d22e1a2356cb22064c5d5adf947c0e2ac3c59fa392bf18d4193f5a74dc3f27127680b987b88996df640d3f88ff18a8f3d2b832f068aa113b2f3256c00037132ce0858d30ce5014083f934e67be4136540f7af82348ff93056ad79596b6a6415c802615260a312eb5757dd37edeb0f052bb70ecd27003355f339ab9519f04df7d03c48d9b728a57d81e2faa718ec41cf80a573ea2d93319e22b896aa2281e27962115c1792f9b550ae2386396788a054ef7bc43e09a1e6c2e085517db8cb055f51ef5c769ba568e38aca00890e847856c3db4d1a181bc20ecfe7a9b3e0c1719cb46af0bfda6590b92584404e4a3090238fe67fbe40325e5afbf695952704fa4625e379679d034a28bcbc623d110ce50ea7431c6f4bf651517c50844e3172e3a5f92f34f4140229c7c5c7ab72f3556622c6a38ab1f98c1726053dad2fbfcec440ab7e91b1c6ba07eed40926755473956bd9b2b297b88f30de655c19fe3e8c5fefd6969e0c8b9247bd905667bfba8772e3e12caa34e67a7f17b1cb30015f3f17c45565ee92ee6d5222b9a17f39b6a78e47f54470a35558de2e15d225dfb211894957f559834ab18b1592ac85d802412c27a0cd0a855a07bea766654395f786c9c4c0fb899028e7b6b8806eee349f1b0bb3ca818b0eb0990a3e3c48ab66c41b8225336fcf59092df60c98bbf48c3346fec1c6cd51579feaeab7ceb905432bfc688890607863f9ee74609c40d0a71963605ef765f3f449b889dc9b926d250d8150432ac297c2227589a4997fd449b6df3417c9d2498074f4da9eebd8d1b3a2f5f22ff9211dda76cdd0252677322218ef588988d2a02361f77b599229f2acc838d221595e4c619ed7f94517ceccc2ca94b576af6ede0e2e6c1a758fcdb83d6f9e37133d1f3f4d8caf04e88af5b44636c2064dc2fdc896b631f3912fdb46f2cca7851038041af0eb3abe00ecc082aa6649b7169538930e28873f428c2775c4ecfff150ba4d4ebca2627bcd65bfd46d07054cad399d3160898f9b5ef5a6fd2fb43455d299c33e11a8f46658c063809e3dcfd7cc68171d7f6c21695254bcad9d0d45d5dc65590f318dc0574290aaba9b37b5b25d2683bd0931c4958df9a2cb46baab3bbb221afa0354956be2b726bee917b5429f62b309d12aaba3cffb7b9a767124eed7b499741f630cf1fab1922ebd5e5bc95e4f311d48596d2f96cfb50412f45c2767762b2c3e5108f3159e27b570ff2c7f1b955294a4358e35d1cca976354b3ce6e1944f8bcfb5f95e2d0445b1d5688b1599dff3bc43fbdb80fbcb8aa3552fdc9d7b0aa3e03640ce2b939e9cf20b6062b34c84c639deefff5e69a25a243ea4f594734e11a35d7efcde8d9ba4848540f18dcf642397d95d52e54cb97bcf8c7bb84da1f74396112558750c8eaa5de5299060fb8c226bf4bd83c46305db6518eb30a755f18b0efb53741330e2c74a0cd0659c3d4fbc3b543e8a8afa2e09e8063acdba704dd531ec5911b4b58ea22fe6f7d2f41cad11eb18bde10703da9d92201157079bc6e66241cc085060fff6585165c47acbb3f32bee78ad3f9cd7fab63f9b84e7910ed986d69674623a8574e15d2d6ddf78c444795477c321ff87319fea3cba790060665291bcac82b02244298987448f75138d3d243031bcb1ece157ccda63f4b4bf0c4fc7740be302693b64c3f57850e287e4668a8293cb7115483db0ecce50a11cdaf34776d532b90e89d2feaaaaa097c8a849461abedc893bf2ad79dd38412fc93417057ae82e1a333024b9bac355cd108948b8d5d9d8ad2d98b3763e493de579053424152ab212a99a0e699c09be45c8224e728f8271dd8d13dd063b019d89c3da0a0f37f473eda8934ffc46b99eaf3685b11c347be6660ccf09bf3999e9d37f9fa4e493cbae288b858710714ba17dbff8d634c1cb3a5eb3fca788775df2c8dbe886e4ea00f772211a2c132c70e071fa0dc454218ea5f5df01cb8b6079c9ab0d8e35f51dd1b54dd90cf342c2e0e65acbdba7044cc8cdd07d618fb7eec32455dc9b01c5a3c8ec1e85171384470276c56473a23219234dcc46070f7ff69182e92b89ff1f7791caca3d87b5941b1c400b9300a030a58c496fcd3a867e98cecb01bb5ab0bf854065c3a6d946978252af63b5c5063a7d5cd444d13d277124183af9f62c6dde4af2f700655b280ba5e6327e0d6bd38aa60550fe41e517e13b9e4d44965c66f1b577ac9fedf53681f1208b845d5fe443244eaebffc99966c7a065007f795249a4729e3894e8898862cdbfbbb94704ad631047c2eee15741404aa72a4a1844bfce216140ef16d707b3c4f1577e1cf11f6feee114df40641c3960e069fa4b1530f4de16a1c8d5cdf09b2d8d55b1ad0bfcd132cdf8c66dd2a44595f01d966418ec0be3b015956b3a82abfb2bc619b834e0ae83361b3c27670556097f8faea5fc5ccb8cb160c9018bf87e9549eea39946fe7b94cadcf8fdc1319fdee5395f92abd4801c418bc44c74b4696eb4d6fd4c6f170ccc50194b750025baf3e9583d7a3fb54dd4ff17d5782d782675d1d8567b08e1207333c142b231462ef041769946038539d58365ac06dac87056f35eb63f7aa2691984742dd213492c8247eaecc4aa47ed044b4773cc92efbbbdf33d40f4bfd07c9c918a044dc4dab8653dc0359aaf90b6413b35b26eeec20e61f56eb25949be8a146e63cec1f22644307f67ee72928a44a33557290fb100bca73a48f54b83bd6a8e06ad9943a476e029fd85539fc314ab461a28d60e0d0c328da2aa30b5eb8648a370acaa4ec44174c03f76e09ea3eb9115b03ce9515a3a54001de4181495475dca1df763f98dcfb358538989db36799658925944c029d51bdc89631fc8d5883a04f79e0ac43cf8f638016505ce1f3622561f03e5053b0b3f2f13ad66d788c1e0d35693b9a1ec5a286298a95220125bf89ed41f6df59e4bb286ff906d50cca3293f579b3445832778da10fb3ca2a1fbf627340ef9efb790fb2384f8cb0f1b95bb3288dd78111275d9d484392a854bd3018a515e99d496d758de9269ea9c4439c5091f222652af3edc7faab63e350cafac61cfc5fe097f766855bef513b260dc1a02db394ebb89e94813c79a580b2c5a92672b0d5a00d750d2bdeb9e5dab284753e30416de3435dfa6e06545d85f512aa2706b77447b585a74a46886ab426598331e10b13b3e34ef3f25ed2728e8a954331a587e7dbba6dcf853388a0cffdb2a1b2771524e46fd62d9ee7082c20513a85e6990162886e707abc22ae246f6b4f55541b0c276290a4ae59f121e67ff250a8abeb705c929e15ad3cf6b8623f00571ef89741dcf70bd42dbc3d570b4317509c4d27347f600eaee94de4017de66e7060c460d0282860bca1b4e8c000bf587f99093ac47e4c546858615208fd394d96b737673bace2c0cc3e982a8024df3dc7ad4d50c44a90a890a2d932d760f135bf8cc8ed51d28aa1b791ab0b0136b9e2d29411c9f9d55c545a0c5220e333e1a3a849b253e2be481dac8daa1d2c9b103a7582b51594d60812c38442d02598caf2e9ece2218ed03ced6b2cf3819f2ae5aa5ea109ac1f750c458637f0f3b0f2af04536d45103a287a0100c5c8209a332d5f2a4386ff3a902a14535ca5bd142c0b0a7edf304259f2be642ebb1d4823a0b5c64e5f1ddbc87463bf7aa341fcd56d0704558315c2a58709687c2e57fdefbf429595535e64f53bc9774c88cba329287231bf59880efa9885eba076806b9a6446dafbff6b8651197e8f6f731271fe3fb6a22e8cf1851c4fdbb520523a37cf82e13915428df0c49cb9ada1448bda2afccb9076dc9f577472a8fb5d7ab65bc604bbe05fabe152cd960ac6c1e39aa633656e2a54487a620fd5a2f3e27189e51658aafae6530c00649ad0ba224a78a680e4bddc5f549a813a6428946026422ecbb842f1ea7bc0ff9f6ca6371e65f18a010b58244680a9b162b026204838a41cef46a8e19deac2059e1bfc7598e3dc4260f498c3a924fbf4152c1bf06106dcb196daa6758106be98733d4bf94a34bf539e8f65b3a55c4b89ae8b8442abd869fc6dcd1b0bce79e2036d7b35febfc7774f702ede8f65be722fb044bd1f3f878f10d50d4a121b0db48c7f8299877d661260ddb09ee8189ba171cedc4122ad54967a73fb5d8c300e7d5ef9ae620a395b431890ac0f8061173e65715bc18c0ffecc1fdbf92f8ef5b38b34abb86c3545037efc462dbbb672692522dec90998c989e8d0c15e94e31cef367084d80e2475cdbda5ce4fcdd5e500a1567df39948d97b9bf0d498e35dd4e58839b62f678b1f88c18a645f2b0e851dc52564f0ed7bc386575b0be919e345ff84363abb75af44d50d743eb091d95fd3594ab64a09d4d789e9b9d7d1bb80094271065e2207e08bad1443a61fb9b229c01f6aba1fa20f1a43144a684c373e5cd5f4996c84ed1b52a7f10d21c4c47fa3545b3026eda2e520bc273b22c8107113502f9e1a2bc556526b9aa45a7ba532afaf0168682b38cf35f17da39b6bdb8dc11f0391c419a72d429ab807ff6578c4360e0b740862e2baf4d811868c1dfcff274a84c27b64f782e7b5f9b8e4b8f4b104041c78178287afa4420fef02d2d89ac3ba4655a83bc0e1828db0782c838ef7366841191f976d71497dbfb5a2d2a628f1eca8da41a85ad66b876dffe7351c7821893ffe7ec605a762d1c6c46ed4c2f427a869f31a0d35c21012de0d9bd420ce03b4b6bdb7ad439ae679114e2fd9c372a188f9dd47d4bfc5216a8164bf931492b0730a21f975dd0b567327a0596c2d3e989537132ff758ed05ad93188861a5caf9872961a39a0a87031d93675abfdf880fa1486e4520920d37cafcd329f60b5bf780a1ee775756e0a0b37903d82dd4bb8d0fce2dcc75c988f9128b29015724dc5e3b1728048cc4eec277d8e81617d5d1c0383d022a58a8c66076df1477314f4d89c9316f6136dd703dab569582a253da666fd45af1c893910d8e2630c1e008f0416dc1be7290e7adf733b3d3657f572ad74e5a91de5c9e28165234adf5f22cef43c74fb13d583cb2c232fe0d93e3fead651a8844327c5ca6c0fe97084c18485a6582dc5997c826ff7cf1f97383133f51e083fa9cfbe0eb941600af65c12b50a411abf80b4fe33a0625b50d1f01424094adaf6beda1ff7bdbe87f34823478884a3b9e7878530776c9afc937fe95049f66461b1caf4ec2ce81c54a5becb536b5fff7573207ea525d3f74d5071c4522be069f9ad6b8ba16331e4f5a8bca2e59d3d946343fb0144c6ad50aa59f8bf4d6abf8495e69c32ec6a578a7f07240b0facf8aed58d2c66210993a3fccee05d0f314afa13986364e086dae78bac968ff4741821cf14060b7f4caab226fe4057b19442aae8de3cb3048c4885bf995a96ee4e36cc9a8e7d75e4a278df996b2c5971bab459d894b6a7b600807e609df15e6c36ac802f259630c8c27d34512d73ddbe0497bb8b5da8c6114f9e327cd19b7947877291041b5319bc98dac448eea1d810b78027c3c2d2936053503e8b308cb1ef169eddbb22e7d251ef59e8bfbe222c5cecb597dedf9a1204a78d406f04bebef12faedb09ec04e5542dadb627447f824682418ac90d2fb0c3bbd8475e3ad98a68e5d79c2bac7f68e02b186eb1dc523d0dbdc323b7b20d925cbdcc3ddbde08f667c383d85892b44343b18dde56a16826c619aeabad8f762548b860949f690912e39b8fae74c931493a13d8348c4f1893c513e7ec722b6d9fae46458670d411ea3d6f5eda9e04b39426286c2652bc33afd1bdad7a1f3d0d99f67c0072ebd4b9746ce1c8408082d1236e3adf490b55ccebdf4a0e41d9ffd28b10c286a1b9239a14ac280928fc60d1c11c9311a37c8bf5ba27d4288ec995f465667b31d7b93096316ed1ca447a90bb813943fa3ba7457bce6a43e6fcdfbe37cda504d77112e4c8842608175e660691c872c80d6e06d93693b01c3fc8be6b56f1b5dfac9eb72adebda01c57a4083b5ac120915013e22b2ef770e1fcee973649e002c805c416b9e33053d093e7087626763f58edfb35b8985b5938778595f4a8d544eefeb4739fe813ef5a5c785018bae04245ac641eb069a2e0512601e310ef52d51906748df0f9f959b6a72c7787282b74204b1798693aa811fa176f1fce0089012f40608fc2b6cf27062249192385efd60baff354d6022df0964ec0932a1cf301ec750d1e2db20434225733a95b066a6b4832218593fd8dd3a1201bf29bc30488dc4ae6d409c59c522a3f2fcc84d3d07195fe7fbb1f640d139f5c08733475c05418ef3430f5140cfca5be87e7fd4854a1d58f600c69ff9ded94b2cd5e3ec42c978c091b80e304537f1b8e0231a1a78c1444e7ec311bc1e4015a23e8ad3e1c647a9529d8a7f3d0f99147791df840bb5f14f6dcb07854eeeb43ff3abf7ff807cc5bfe2fff73014a79283dd0ca8a7d71c2b3dfd1afdcf626e2f6fdbb2ba2cb84efaebe2c8fbe8e3c18029768f0ab0026ef77f9748ab34538270adb4027bbe4557cb1ead09476e9eeef13af79c4cd5bfe46edb9f9b69111080a7aedbf3d6159c0089b5e097ad003e3e25a8867631a280f5fa73acec56a55bffdfc2ccbf2ffcd00eee568139b82efddd3fef0a51f0078ee9c09b7c95e16125527c7e801df9c6815c1e64b8e4fa7795216875aa6a1272958de199a2f92bb9cadec894d13309c1370dbc89104ad52c065d0dc61a7ba7579432d8221d39bfb0b4b0145708fac31ef46665dcc36da4a67395ae4eda5274dd6d501fb810d7a70f0d005ea44a4829099ba97671a5bcea9c97e3cfcc09e7ac7003d1597d0d188bc5c53f2b31d78feda10d077a297b1bcf99055720038bbb68c8f0e5335308974efe3d45219f6b8b230c525d701e16e8764f2e3a63df36af3ccb171531bca2bb73aa4ac47d3fce8cccc4eff182a469d3d4ab4b865a1df636785d2f7166661c89da95d634bc12c33fbadc50324601cc04832a04c4d0f3a979ea25c803f303ceb25e2fc06921c6989275188f99693f4abc452c5a8bcf686641d177118387d8f890dad719a2050dbe1cebedd04ad45b437f812311f1eb5f8bb7211a8d557cef2d991caddc24c211425adbfe8bb007c75443384812b2a01680f0a7782e0ce829fd35f0c45e44604dcb7331e4e5f41741d73a48035ee657a938363e6cf9b2a916857c3912b237f0ca92c3e6265687ddf7e7d2d46f20bd1f6824e5fb02a423c6cd46d28a006b1b5486a4347992948b93a64a9c3a3447ce88d1cd94eb8efcff87e54bc7d3fdbb1767aeef9e1d665c22ff0ec44cb0526f2db4ae4186641c90b779cac7ad079558d0f5dd228e1dd82e04e88c5b6e965fb84f6b87e6b634ec5b957f6a07a0bd8aa4c84705e41e3b69fe86bee8760c711c2cad4e4d6b7d7e2989e3ccfcb8bea954eac530fe4fbe04dbd58e6390a5f2a846039fa48bd5649eec054a2fbcbc45a2053e50a662bf705d594a3604ea0d278bc4f347d795cb6e95ea02c27c9e276b1deaebb5460fe8f3502023cc70870177ab132c316c723035f397a4592f80ee6392915bf45691eee12392871cf9f1aef2c5a8547ba415a2962c3e2ff65749564f4cc148049089cad9020aba288442e642ddaf3cd4d29e7962d89c4e6b733e81d6746058a7ad0fae2672e35105320e814a8163669f8ee2eff55ed4fae5e739fb863fb73cd20b8a06202afae363fbee7c14708a11ddad4ac4df01c9176160c8d8b931b0902bf28d412e438331c7d9fd199596d072d4b7592159caa05ddf94484b05114e2212d531e6e1d2d7726da6268baeed2757bf0b7263961f29e4b15cd34e5c9b71d7c76343cb26d61bac28b46ab1cc2f9e922ade63cfadb9f3ca575f621e0563e92be845b63d0b412b8312c0245dfb825459e1443ab8952dbfd00088bdd03d3e761aebde6533985374f07ee580c1509675f6ed0c996b7b319e51879391edf8fd3cdc33b1aaba10fa3c62bb06f0be37c5f372e63c064025cd9b5586143f18ac703e1192cf496b919261df552986ad70c7b6748aed42504469ed5c7c7d3fc749eb1b411d47350001e753bd6826320543f2cafc037a9ff9b1a84b03f61e64e9acb9828241ff9c32777c884d1c602e7fcf17b40407230d29767ecf3920d12e44f2c0b140375a1884f06841346599f3857e7b9aebce7372bb49b9254874af08bd206eeaff451eb43a106a53a7e483e53816261c8a3675818fa39061c46455081a2e1dec29a61694da1b3c237d342d685f92385e9ec5479e03c94e7a1d8395805d8f3b354ddb5c4541fe3cc0466eb33163989779968e188aba0509b2dddbaec4246a84870883dd72ae5304ccb462b3f60a182d3a52f49bbefb311c42b8bb29ec703ce37d9dc58a3810ee30567525381582712a5eb14e99cce5a895076b6d4161ffc362476e209e90807d3650ed82c29b7bda71916351e096c8ebce64448cd75124db2b1ab5c790cb54f8f9a77f258fbbff612b475e01e25b05e3661889239064d3e8cf0bf6d4ddc770c3f1439cfdb8fdf370d263de4d1adcfb3b11477d7e6c37cb1cf4270494c170ec7938e867c204f6c73db0714b19e8c6075662f9d679d74ef9895fb68b04ea1573791283782b3a5f1e38a002bf1730c42aaaab917245cdf9703511742c30b3edeefa04563707be9669b1aed124bdb0320a7bcd7c5e7cf7b6adc15d2be5befa0571f1400ddd3c2c8624e63b8e61caed90a519e544acbea1edee4fe358b9d34ad4e14bd4758ccc1e196f909089be30a35c859d2e4e7576cc87930a36460511338dcbde40addd8eb91ed5078bc7c6bbfc415a2a24b89828cb185b783ae4a835cf0578de1e77c813476759fbafd8784652be8f548147b17fe0eb9039094db24b89a88c89788726791c6aba3bbb7296c3cd8f26376a17cb8e0b8886677d258782a32652e6980ad144acbff411f74dcbfa9cbc9224620b2400280913fa0d8d1e7e2eb4ec07517152c1aaf495ce03efe0db8af7ccfcce352935fe7c24b7d89bec7b7c21a4c91ceba623ecb0e49866e51643242c9b82e8904a75b67b987a424b3f35c66dfd42d0012286bc885b8ddb14f468e7e9f61e570c29f40f26e4e7eeb669e05cd85f474e6273e77154661b3974bc06b977f7717967f5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
