<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e10f7333ccbf29b938e9fa2714d1b11245dc251b5e09bd1c65bd70b53986fc6af5ca8206757bb4c0302ddfa82b4b92c0afdc27b32ff6e92df2042244d8d9abd2033468945679f77ddde0eca6acb4d8a12cbd3295b28948581c8020548e45a1b73628d924d4b7a11843022391aa39789bc7799a28cf8a039b900912a0d682535050ef9e315595099cc11f04b27b001d61dd14f0646d3ba8c56c50110aaa0144f487fca0f1e747efea1ba49e901fdfe0581fe25888cf39a996f5684e1e0fd1bb9906d102b07de68a926f4c69fae1edb2f0bc60f1573e45c27d6060229981d19cd88dce6ece516a1c73d730b18e4132196fe211e3aa6119c611596f5ec6e9e67e3acaffdc1d18acc409f6870dfd35708c9b6695ef9bb175bb1382f8010722da3381c11984a80622f6a8a4e148181c0eefcab6b160a70cf3d839766c692df17436b152b516d10feb2291dfeecdaf6dc0553de809e69fe81f476b41a739873e2b0112e9e20c075f52e9f4873def3d1abbdf47b3392c130249b837c05c9199627723a036cd764da80e5646c55d78eec8523cd36c0f7c2536c80a84310a6dc0c64a0d2e65632bd2d786405268c87612248ae77896ce5ae738f12abcf22cf11cb512d3ee4f1f2f9b87362d6a108bbfea511b8f1944d3a70b437ce5aa097ae2c3cdfa4d8856a9f766da8cd4fc785808e9525a41c071d56e946670c440ad5cb031066e750d2c0b87aa576e292f51528c256481067d83555f7d39a4ab9c4aa9f27634bfdddb39b081ec1aaa388d13d8c15fba1709d953c06514571aa504bf10fbcd37094c6df11164037a8d82152a81e231dab313a6fd0f0abc91c99b34e4f04231b54a9e40344c8d1c3d4490ecacd588de3a9c919ec22824e2e9b94f0e4dfeccbded32a114f28934f2452a45c3b561d3731332c85730cfad8f3f87ec23982f2932446f73c0a78841361e1de950e2b89225a528de412a596ffd1cfc9f4335697a7f7a89e40032b024cc9d7b786b522258c017c7fb98286aa798fa35d7cb7268377827f6bf730f22f3158729f5d22a74688236001f16e2ebb5895011d4393fbe4c9a449ab97e8c5eeec412f740595e440a36a403c901645ad5ded65dc66fc9654e85a3de366ebbc7fef23324c0098a01fa9ff78ee5b8e20e39fc1b1ceff417f111f99ddeaf6d3ed436f7bbb0651d8804d8b244a8d01b9d6551f69a6e3bf7c6d152d6419e877029830b7d5b1de9d3618e3690a365945218a9d5fafa56597b430c59b296bdd2b710817fd2c24a0be53aa372bdc867f91ae1d8d73e41d93f90171283e9c0f0d41dfed39782281e9d7163a6d46d1619de673255c34c2e1f6b5d0f37766922acb6aed77eceeeb1d812d4d1f695be4f09592c83197c750fbd33833a9a5f4113fc6c7cbc524cf4258986551ba654624d55d869e2f6863e0ab6e8609356337085b9854bf0c56fa9e0e603286674da59c8ed56342d835a05ef6b6d9f2059e1d56651ca0ce8f3f01fa98411db7e82e26c9e0ee063310de43a42465e0696fdb069c2d418d7067902cd0276c9689c339d99128ec33d292a1672b9504db0f0f461e4b276643ce610b4b363d9d1940e373a00deffda69cf9fbe390363d8134ee2a2ba13f17b65380e1935d04b6333ec9aa9f8331ab094c44de074c5d0b48c9d39f6482d2e9b237b729c2a18b7a82b3940aa7075ce6babdc7498a74b3f82691e08b7b5be0f6dc7787b525a8bfd9732b91c3231b30ad9fcbffef0684d5d4c7b46af3dedb24122abda9963aebdc645ab10b08bf53d113972d994d61155ebb762580b408d3340ad78c9e271e31afd7d013e270419f967c49e207f4e32e07fe7898977a08677ea3c391ebc9c1af0d15940154cab5953428140931fcc86dbad4941136dab35d12f411dc8100d2c2f7ebcaf72cf47bfdec301dbf001b24bd0ab0ddd4237695f95cf58865d85244c21fd068979e084b994a0a4fd86a32788cfa31f213670a89b5a1d868cdcd4d896304106e8d5f09ce0729dd936827681261edb4a9db4a61450f8dcc7dee08206fdb78552c5e6a1f90b1774c5c7b3b0046760688814ed5b1e83f274f0b628ecfb52330ce215824d6dfe1a081cff1dfceef147a82a4f6440d3b72f6b828f50f7ccb74b362707e1be30c04b84030efaa858401c5a9bbe92e5f51f48534d84600dfd534847e03247ded2c7a4dcf0fc71a5e39bef56a351096a005e806ac8bb6dda40342b1ad90ce586f5d1f2413bb93f57e5bfa164a37bd11652da5a572bf0bfc582bbabdc1a5d30e8428848eb35d80ab8935dec1348f8fcef51903210f4c24ba0c30ee710ad48434d1a765b10e323b8ddc0b5e87ba4fb45d93a8eec45edb9db1271b9dfd8a537bb95b3ffdd640780698aa146d225c81d15e80214e10fe2b47c3c040a067492ad1e72d6f9d8e84121ff2d445c9fc703b2532d6b0547f87385ac90994d4428b05d6c1e3613c7fd21fdf10cd6415d7f9cf8a4694c6ceaed7d0c854c58be6bcf9cef2b81441047de3fc7b0c85597f3e894087a8870d50285d952b22b68a67255ffbdda7e4c1ac575b21ad6f5014b78d3076c20a2d74607b49322677643ad8fb9ba8a9fe192db9765d288e50134ffc721c8fb94ec87b92b83be9f4e97de46e2f1aad623061679c9c5c08ff2e8cf37693273faf5018d1cdfc2a1bf9336f4d7580a8f4a8d810129edd3ae767d581cd947d193f38a8541d6e0c7626babfb0bbc54d296c9daa7f3bbeece4b36a94efc8789d81e2425189a88c13282d0f0508ba9cc6ee564125ef261ee1742f5b17bcfe0fafc80e19def5b2b3d87c92ff5dde7964a4ed4468773a17fea46f5e26565aebffe1404b9f0798b2f1577ae27197c693b3d7127d7dbc382f4f40535bea8b75c06ce54d565b00027fca4947179c8ba70aabf91a8fbcc0b6bc75effc5851e1f5e5099cc81ac95d16230ea5544aecaf7ff5e01c786137bf7f5e84ab4e367513b426afd5458c85d6b827193e9277e057ee8503379a6578c93b35e5fccc9e6ec7b10116b73758064f880ebd10cf58cb5fc4eb115f4c3531882b3bbfb691d149b083de512ab439fbca715d4964e379c8d12ff5487be41ef649fbcbebd99a645df69dcf11009495fae184526ae6cfda7f9caa437e2d699631fc79ab38a713a79e5d07029c70ba1d56552807212ebe19c2c63194bf1ce39da94d032757d26ad228a01358a95c5e91ec040af7d8ea7b18c82e62771fa4c226c53788852039098033a8329a6837514dda6e5bcd642aa01088afa88a6cb747c9bb62538ddb2f6056485bddfbf6ace61e04b901829c2f5c34c6d367828e8afe32838e35d2b67767c5bc3e953e51aa8e0a5cb2647292ad23fe71f6e592bd765830215ef0e59e8993aabb11e40754645dd694c6d2df78dccf1dcd71d969d8a0fb02a023fb95c9c01242cf8a5dbfc558c304c574369f75c4badae2e9570d8506df19e107681d0d4c8275f7bc9eb67e0257e2ebf2bc768398c210ccc74f7ff91a9ae9d127ebd6c9af17db121d34a0bff067ef7dee4462ec499cbc7858ead17fc198a90412be1365e34501474880f1cef86a18e1f880cab5615676d27acd90be406b929095935306d7ce722a32971a119a723f2474b5cfba95d5e5c1b9e70b7902a21262b78a2b8fa6782e4229cf32062643f71da7d547194d2ab83ebcec624ee9c4a3b6607320147982d22000eb446463448dc1a5dc3b929e200ef74c00ea84dd5ce60a14fe6840a01c8ab5552423aaef4361adfba4ac15d35eb99d476451b2a81c8aaa3c70051347a88ef1f23d25d63fac4275783ffaea6bf55bb570116d39ea0e1fe26c16350cebe450f38b7268dc4e47d0724f069517265e5bce205855a1fbb4c7414bd4312cd27e83ec8c33c7bd7d14b6073a57d2306bfa5ccbcdf3ce606ac2677feaf78b03e34fd95d01ee126979337a593bb800ac75481469a08a8163ce0ebb33799ed44d09d910ecab3f3cd319e092745d3aec29d39192992a56ce16a6c8d78fad358cfb6b92d0eafb675e134a6899077bea3a7e49bb311356c6ad6dfc90934197ad52314d5fc123f1ebade144b3d176056c8007a950b2ab30088701f9ca143a3783a8711df0646a13e4f83f86d193380571224693bb3193625c8f542e8ae63d63faa1bde24ec1332011dbea47b8edd36ef3d57fe7bfc93206ab571feb5c101b4700c005fa08f96acf58905389af5b691877367ef919c5f2be21f277558ad4ce0a3bbcd668221d3a56e24966517bc3af33b81547aed1991488fd7f3430390de179c69cd34421a98239446da58c6a65b570bd397d554df1d49c43844b342ab1a7c0b6cdf1fd422df70a0cf905d76dfdf23df1c4b11b256b5231b5dbc8328e619dcd180610986fc527a90b76d420ef1ff4e1138bcac2bc75465abe6a0c95fde2f7c9f176d777bd8f36cadf1a92044dd50315338190c0511ec9b409006d4a58cc6b29cb4abc513c95418eda7e18c175d8d9553a58c5fa996b10726e14258a6270a47bdf8f22107ea7854366eb9f647f88802b9da96bf6eb8d49dfb41872db3fe42151da0ff87615bcf8488ccc98623669d889dc9c6332f0e24464c2cd6e19fcd12afe3db0769dcf0d1cdcf7bcc130da13b22cb33a5867d725675e4fe1c3419adc9f1e02d664e78ae0d025152f5f3c788cc968caab33f721cb58388a86f609887613b0d90f0ba42b04aa395354d6527b52c9813aa30621289a434955572b59fa827a20166a71e8b495b458efb67fa3d0c907983662e9f0ee03a07bcf4587070a33d31a4c3259f12816fd5c836caf840946ced5f1d4a87174fb9c6b9217f2af641eadbd711b2f26a5a5d094de58f5d68f342581c3a06a8f4eccc8889b2243dff9773db274d097c1a1aaad183cf7dd80987f710341254b0ee174ac8361c3943f44cad7839f3c78c4c9c60f59655c43d2db5f09975f4d7a3437b6b94b2c49f10ad75ff813719a37440963d2d92b4ef21b3c29c6b3f3f6ea17c738c871d18fd3c4243a4bac4beafa71d3e8401df17c322a81e0b8e2a386b6038eedec4932e87e67c02c305b5654adcf1dc3d17d1f9cc619fe5d69b02e1b91a03e0adf36d6db2bca920093d7434ee15478b092696db89af98e461b0c09f6e195b2e23f3b8c62a919c3e41c221d3f20786108789df4518fadd75e5e8f0037c9e3515bebacdba37bd6c469dc1496dfb4c49925a4986cb77658075bab36e5d7ebc116d2efb96f141560aa4213cf3d8449d79a6f0abcaae64294b18bcb859ede4d5edea530335871770dbb61db3c9d79583ef60ddab87f70f0ab86640ece10610256399427815a0c8b683ef0e930dc8e5d0e765208aa96019859f1cd09e6d5f940fd71e988076453fbd235d20cbe797a7bbfeaf919d2ef59b39a62f77c10f93dc4a452449660fa03d87cc59526e12ba4c695dc38ace7348722ae2ad2b2ef53c4d06c89e2f738f431970f41cf5a8a9ba815094cb78f7288f44a7537d4993a3021c1cb4b2f2c9fc67902229c281c9fe245a43e8ddfb29fad06045f45b534241ffd708afc11a69d94c33297018095bb1f2974be517cfe27c353cc5d7ce964778f527747e44302b156d39b0dadf49d79477b13fb841912d162f1ad227345aabf9725391b347e58c99a079e5eefc4181613833e7d727ef104002c96077699de7a7dad1853c4e97ea56c4820b77072b86308f81863073f677c41d6ae818532fc40d9b45b455b16c7e256dc348e6a3af65df00d39a06e6f81bb8cce6995a174097815b2e5d80680291506701cfb4f413c0ce515c41793a8c2e4937cad5bb186c8839778b627537ad957b69dd9da81fad0cad444521d470f01f7d6c3f5be045f11c977b0548136db67ec1444858a8a164b58d67d9c157e66f0c3c2ad71d10dda6f1d72fccc94cbb3c761faa5c5c3f7b42fdd9d0d192358e5ddfe39bed00ba71812be9d2aa1fb2563879ebecdad992f5ec3d4ccc766d6e9a07d64dffef0c6f4f208846a85ec78220f40d3a5fb56c6b6a0b8d1e41d5d6ebeb9087cd9dc1c1c4c65b70e1ae306461b2bcd5d1f713ac09e3df1b7d8faaa846b24c75a2cff48e462fa2e54c2e7469aaa3efd6898621ccbf6d96d6c88b5bea4b147b73369f6ac96ea0c142da987a52dcc2fb3edd1c53f493ade7763ef4cac4b2c3e505eef22e4abae7dfbeb4d551d8e1c057a5f7732ea1e39b038c43510e5a03975cec98117ab9eff6f538a043a02b53a1388fb08da3b09bdaa10b007efcc0cdd6273b9a402f8f8fa0bd0799b3b5acade44372e09db3e0094317753125fa1b3d87d099fd954da74eea25f46a48a97b566b00fda6911364ca87349826105b9ac1a142f8c7c51a7b946ac0d5fdf8d3d27fe251330904ceda2d854d7ba48ea2e955e80552e6c3f30995ccb2961ef98e4d6782baca07bbfd2018664003ab8a060fadeea56affd15e3603aad85dc305b8d5989617a117f194f264bb951cecd633695d221afaf4c6f5087a419459468abcd09526cd6466fa91added6a1cf4763da93d078e32ebcb17d20888b172d6d021ea8b7cd62abd993916f78a1765a124dc569c06dd2ea23966f5c3bdf1c6c5bba23dcd46c1e38a6e54e0f1a92e7996878179544350d9558bb8a8889ff1ccc53472879ad7ed28b958d1ac22dfc5142bed7796c89a7d77957dc2eeb85924aec5500a500f799a94c8f31ef169a38b73c97815aa4fd0c75eb8ed171fbe7261a6b2eda34bffaac53014764b099af3984e66d71c506017b500a426680e58de42b1938f7e0a74a0a2ca4db34052b4c8278986538ad9fe6a4928bc8e520ed76195062445955a2dae4cfa2e2ba00e514620c05107ade2890e42008c47cd9ceaae7c5940a25846b14c6a959e0bd71a96345060236e7fe6e9f9b2573fcf19b7e6fc75aecf05c90761fc493a45b07c7f90aac96d97b96c950e4bc3b7128f8c5a8030c41d1f90828425d4f7e3d834edb06b9584d6427782a9834119b846b3605f1af2684384c5fb3d503794b6a5a104f129744507377e636a9dda55cd62936b750435aeac7f5ed076efd99ef526c98172a76a33f191544b4dfd3c2a2ed486e16625aa4bd1b41a65792f3d03b1f06f9342bb56860e2707c8a2d0f5635823f8b1f10531b38c9b069fbf621a9b49d5130b35b6f6be34b1e48a6bf6cbff9936b8615340c668bd23bdbfd763dd30fa839e5148d67def16a81f4ac2de6079743c49a24c5c1daddcbc0011d81e5d5234d15826b53c40d7961c8b2c03c789db4f305e578a6d2f4e0aa109b62caf41614fee628f78e40308990b1cc2d4acaf3a76e80b441e0a7def142ced18f2720537e008dc828406df5b221db986a71039c6220fa5c3d2c690666911607a23528f22b93f96c3805ebf04e6d4e9e4f2c70bd864930fe08d5cb18be767faa6f2b867a7908758223c2afe2ee59f914fe3ca5e9a9528ff4f1bc1b8456f963571045f892a746420472c267bee9193ef182d85e97599ac95fc3ef3a4504d397ac178efe83f772c69015c99f646af6e2e6622f408b37d2aedba3c5f5cd9f706944566b714b339b9556f2e19ecc2adb122c8a4dd94a2f9a6878175f84437791c1f4a3d25d86cc6a411a866dca93fc3dd97ea17833a49f56de0a46e1a7639d41bfaac8b3d9bf64d8a635a1100d2b6f79e948a8ba1def5063f61c519bb3122bd2164f852e22273f3770d4b09a623ed6d7a7e5db34d9e9a6ab4095e7b5f25e3183c64dc74108983eb1dacb2d5356624193a7448f0263e52a9d04cda219f391dc1cf13b6fa0f89db9137283683518f1824df55be85bdfd241d306abf98af37735de98f7f33f6f058f6146ad6766b7bf163da6e5943a6adfa3b510ad4a12c47aee7ddb4495f84b47ae39718035dd7a88786621761b66062994e37d1a7b15b884e835ee363bfb4c31a938a90558e1b19ab2a318fd220768267a186c590bed728704bd4590aeb1c8fa9bd8c4f979ee59663f2cc9b24def189056f9889b1a87887473f65861dcbcd4cf9dd7c2987e4cad859bc912d4df38dfc611b0ab77cf10f938c90e51666558a3fbc0ad9cfab0ec6ad1a2444515a17e17fe80194fa2821e26f71fdb7658e81a9a17aabae8818334d9d5c3582ff684d3af5f2bbd2120c1c69335840d777d6ee6aad9ce3cb4be9875591e12d5ee541dba780074d6464be38cf759fff7d8f6f64eab6404e9df3f4288184db575b54b6a6896a221407e67381fffbbf8165a156699fb0f8f222d28c24221796438fd5147f7723ef46c6aa9dcc0b6b8fa9e7dd9842fbfc607da5cd03b3d8b4aaf4df043446c2f45b51a61638ba1d260989698ae0c9c296a343228a43c9f8be4104cf4a80399f14a02279687d7c19b4af62f2673cc0e14976485ce3c0cb5227870501d6061cc69fb998ed2bcf58ab465ecd274b47141ce07add80c7f2cf95dce8e40eaa8733b924a0b7bcf659086b207f45e466e7432853f6634f39f17b3c546abac9fb7559834cd19c7ae31e3957e7f805d98886bd6ad89b2b2ebe6acfdb2ea76c20b48783f79faa22adc1f617ccbdf4a05b06e0920a2a1e303993a1d77fc268c0b658d3a0c95e61158892179dd399f73d97cf3218374e0e37f9bf9519bdb5d55a4603f8ff3a116321ca6227772e8f4606bc336fd704e0f7979e0808d00bd3eee6a4e564d2fbeb39d93a0f106bfcc19912d2e6f03062bf11efbcdf32b36397c0427a829c6d4e351de648f8f840cd9c31c43576a0382e96b012d8e2ac0c11b75979b735afb23705495b06f1b060f22032109ecb55f6d850613b7eef6cea64f17d88517dfa68f9a3f98828facf3c064e699891060b736f78afff90087a1eb2fbeeed0999180f6028dcc78cc234dc926bd9126cb575f759927b7ad35a7840a396e4a74c8be98105bd8b0a88e5dbefbdfa64cfb6391aba1f74d3f9ebf7a8b11ebe62c24c3dc3f174edcfb8b1282d38324099726c97c8013cb2075943176bd70634b136102dcdf5685abce33cb8e0e0fdae7a54d19f17732c3537552225524671d95222af57eaea6f4f615f89d2fc48f1f95691f1891a1b9eb9c6a439bfbe19a4b3b247a141be659466192fc1c544cb671c15670c19a5bf66610367806946dd78e3d9208eb356593581e9bc5124bbcc02ef13f4b6be05f077395de319a93bbad2ebcef0023bd4732845ef9d028e9ec5c7752e0bd0c01adfe2f06914d92792426667f773411da424ee5ab39921f0f99aba733453e733111fef68d1e05cc270caccc390409c0e7fd4f8023da9d9da62b64b1bdd17a41199cc7817d3c2c6dd3e4462ead309987cd258ab31710f3742a2d11e95e9e5239999c9de026f0449558f2512825890a14830f4b40b3361451f9d135f23382ce2af1e9c0bdca8a68cf3b1ba250ec4fc79232cabde14f4871ca7d5362036d045e4c95d38442dac0b5ea28621b5aeb02e65028f50580f4818297177063142e89c7fdf59bace928343ae841d5078ea12bf25cf1790d4fc569fdceca368fd92e8fe3d60155158031fc1f30b721ad5617a31c63aac36ff502e24960db18d0c80aab3c9dd6b6c922f31fbf61c191d7b14488cc54259fbd2ba7e0e1323145ddb100c44b1ffd92a9612beb348be2a98d6baf8bd74a3125b894c2964be11b14c56999eda63fb056ea807ed7a9a89887574872cb4edc36f566c07d3d7b90ba1eb993249220b87842332f61f4677dbe01ff57b51d6bcdac4799358deab0bf08fbe2d808ae019ea2a4d1e270413abac107705d86c4b0dec9034730e650eb4120dc2c742dd02b995c143b8b51af76be68a094b984e5c3f0920b3376d65d56ce6e6ce46cbea018e10462d644719f376b960a8c869a5debeddd8a46d95eb5fd484503c0bc00393630eed6963dcd54f5f207b7119e9c96fbfa98359822d1addf645c62f11e8f45e82451331c570d5cce97023ae97c189ed716bd443d24ec912751c49cb257c8a77200f8614ff4389","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
