<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d64105ab3fadb612a7356bab60e05719fb358b42d5bbbd011e8969fddfebcb46354a83c93b987b66dc79b733e0c8df6f9d18b442a4e68978643cb50bc93f76eed187d8a028dac3e59c23e91dacf417136c2d9163a8117558710767f29c164a7228d7a4c89c5eb77f5bde783e6876ba83f6d86249a33f0f08dd664ab74d4c3b6462e1a34d0d396a681466ecdcc5485c5e43e0e35a0a57def0ddf55e3f0b1610805941074c061eb1a96d30efc44b6aef2ade03a4396ff637ad6b35822a2f0f2267ebb1fd84b07d50b5ca1b02593d23d801e8a136cde0d2aa383560ba30a060d18322125b6cbfe7338349bc12fd93df94bf724117f8125b6e000f8818e397369b54f32e06ca7f969f51dfabd747f1b0ac2a5cda46015e6765a6f261f685037768994f99c7c80144893070012ab1b70e815ac3bbc77fcd246953bf79425bdbbfc4b3e3c4f159129b8e21e866822ec6d45aaaee9fd1014c0d11f0322f6c3e42c0a0164ca1fe62cb6cef9f5f09d3f54b934dc56663ed4f86492fb4f3450970880e566d32d1bde22e91a79cda88ae7ef20b5b394e44e5d21a244d1bf2c0ee916176189ef0a150ec804e132173d388a4184c1547660159c47e4cfa57f058c8f2b15da06d574389c7d0c8d33fd0c97a3c7734b37335bd2ea199617497c773a22d063b2965f8bed5e0fa4aafefbb7897fdf3873834ffca3c709d9f02944d0d1d97269c980c8ca3a1cac0ea066f9af7a5799adfd74213c291b7dd86250795bf3e9756de233904f12313d95c60ffec9d7f67763d48e213953be6459e82d118917fce39dd9bc987f3db090b5a14d6098de2cac0d39b051108cc656a8fc63b52a582f7eb5c41d8e845b0abd881563dfd02f8326b6bbdb5c6dc07f410bb8480400b768eb1cab1e71cb36b9a4d5ad501a625713c64b0e0c97bb4269f2ae2039dc4ff285ed2f29cf8d102dd0ce404798e4ab6c9de67d0a64f38c96e91101fe40623e92532004500bede0b98cbc4f46b92c006ff08bee0c8bbf05ca018e049e5a41e4e392c6e3b23c7ed7f0c004782e413d0648fbe2724809d9760b51e10f96865f573b620188d145c6319333b9d82bac18c698b547adf9ffc8aa2f719d6297c962b45510164ebe279f76c45e7928e805405e0510bf7a0eef88648c431958d12eed78bfd04952cbc5ab345f0a857835dcabc2676c7146a939980a5eb5402888fdc2d692056117a1ee7570e31b30b688bbf8617178871067d945e650008d6508364d3ab4c4f50ab2bbc95d245b17939d09c3f6c0c51c03156040b4bcae0510e226353874b147e8c2e6b7a07ebd8763f8e49f04ee7b592b1442f027fe5f241ab52b08549564f991e64cdcebaac56c632069c7f83e6d1a5509d8bfe5c65c1bb5358e1e30456653ae9851e005987ebd019a631a4a8a99e92b19cbf7228d6dbe8af7440d7eea47e0526222c98333cd29097080384f399e89ac81b3862d4398129e42fb8d69ce7430494e705e9bb3720051a2fb78fb3b9c6734aecf508fdab6779a91ff3321f32391a076ca7c09eb8544cc46b66ac555d3c1a22cb9f18160f9b733e0bb19b18cfe24cdb277b20daf182b7f94636c9501bc1211da6e738047b9c43be9576f6fc00918c687bad95da0f1609daac72ae9e1df489c223078e618175b13b282c11c4fa952359d67957690b9b04446924cb336347b7946c7e028f1f5751047cab1f49496894f04930bc0358d7c17629285e4437442b728825717f8e9dfe3f1f0e532a077511ac613b54fa30dcdc81b3ef6dc2c9af3164a19c003e7078dbde015627593669296e11b20e045689353c5c17561763160d517b67e077223dcf6e49abe02d1dc16d3fbf8995f02e470e3c821d72646cb3337271dd5836c88673af58b2e2800991fe9fcfc62bc1ccd4f9e26e16fdd7a785fef5d4ff1737e3a86aa20a798e2c9bf35f40e0465882cf8be294f2ef5bba29383b65f79e9d35ce64474c939639ac88501219de265498ae30045e1944a5f913bd03ade31d58da219411f1cebd77fcdf9e233603f9c0968a99b23b165ed6e517625ba859278f30a7f4f17bde59b5de4cd3a1a72f9b8c02db013524c6fb2d219a7e3f863bca1875bafe49316f61629a36262edf80ea27238519829e8e1523510626a4b0697c302d1f96a7b6eb174a87671da14e3607fc7854f7632b7611f90437e02956bcc20063ab090973c0eead8655d19ee9963f6c44146aa16f804e456e3db4228ae17a1b447698ac3490ea51a17177e819fe9c51212e0d87d82b3418268cdef3169c98f251304ec5d6b412cd260a07f887b1bd1b9b5e1b2f6df4459cbd616adfa79f43f3e99e02e5157c3feacd0599d9b2ba3348ba0db96072e3b2efdc56e2006171816f93db894afb7caa30af52cfa7cd261e5756e07a88a08aff08d550cc0d5c134b7831c2d30a5c5d6270a0c33ba978ddf5cbbc729095615680274a61f6063ea2d099a20311a49da0c906c53e61be6b0b049ea5815d44698e75609dc53ff0e24808313684cfc61e73c9493ee33095c6448356735d7244dde4dc7727a18064e0344ab5d17f5f0149227a2cf82ded2f82234c4fd24659aff4877de41ac0105c8586f142a954d1bcdbb96f4b60e166b0a0433f028b0c08751b0e01ed34bd67f576ae0cef80b11b2391f4f864ff02d734e058be8d14335b344ccf645d90a30d00c04ac2cb56472bf16e3934eb58cda3abaf05386942d273bb107bfbd28eb0a4e0383a82c6f4e11c2a2935ad8f266f238ba855a000c282ace52b066c906bea3d1c6ad0714d574c3e5a87035d727fae529eab8c8f1749a8de758c66e64aae51be5ef259053451165876adc56eb127c4485f6da50492ff4286e8ae6daaaa6b31505cd86d63dd23f32e2e37141870596f0f94138c7cadc760de19600606812ae30935842ba67b15e1639485849973ccbef4950140d2e038f19e487debf8cdd54ea6915f478424ffa26b4255f858be6d37e3c01720d6261fc7fa4a597f136ed6292474db54527ffde9e398e71ffb939ba5ba445fc235a2a5851058e3de033b1c9622dd5d48cb024eaf2a9fc6d66425d04059ed1f6935df561245cb59dda4fcd373dc933bbc047c72ba937964cc8c615d8c797d4a5fcdf33739c25ea3d5fdffc76a0a51c9446b053e9b6a0f9b2e2f4389af16b535c482f2f6aeb0c652d8d429b6b69d7a853066d555da420f6eeca7a210428304100d6ae995bed3e7c0bbfd0ea1fdff478b02efc0375842146c2197cef72e268769cb759f1677dccf2d694a735823919d504e57ac1f86bd5cc47480a5cc2bffe68e3d84cb200479f39fe5961bafd351e236d948915a1857eb31139f2b215a9fb12332fc31eafa4f23460303460414e2bc485103f819bc28449b5c60350a576dc1f663d6a698cb9ae797b528dd2ab864c84a210e34970f7b3d01326647c45ebf1f28bd3122e0f9798bdc2aa2201b30c0a9e14075093f168338075cabf6c049899c5a6d79a184fbfe1afaa5eb62d77ee9a85a161f783cbe1545a2b6e4d6b17bd0e76cbe9da0c1b79747e66404f5dbe4ad9854d6a5bd73d3ec5cb9f270c1fb5bf64f69f22fd275bd9ea8d9fff95f8ed07e5fc81966be66b6e1f8091d20c81bd77d0730454ede062acbdfa0f59c2b4bed66978ed8df0e113c544bb054a537c736731f84bee9fc7206d5b46cd59a358884f8103d8675500f60920736db1b29ce543eeef312d7b4c1410560471abae48fa85b909e2cb4679041381820eb79cac3a6d82340e1423280d40fde41982685e8db2f8f50d76602de8d3ddca4da7e03b5473b4c575dc3783384c2641843d32e0ce91d80fb895c56d03ce753ea4dd39105da4afe05ef90f3370acec668609b12c1cdf5d21c6c52d98fea03bb63e7ff369bc097d5845ac1a9029cb1780075c3924896530dd1841a27af7afba71449250f451e17ea066b865b84cc8bc90ae0c20fd43ea772d734e19ffac1608650186417a9417c0afbc9f4349ffc97fcf4d9a1b10b441b47c5ca85873a59d2573c6a2fd30593ee59723920bd8b7ea578d6db8696bac3b91b7e5a12346e022f19736dfa1a1654e039845460e94b9346473b7d3216414d41f84f0d600e17ed1b5b84ee33ee43800527eb25cc9c23ae7524c485944f8d87024fddc6cc62092436dec7ba7b878e02a48fef32f1bb74e58896bbdcd89a74dc56d7f58948179ffd961df373e8b68a78aea387dc044d3d9f2d1b215d3df0a47a189dbd0eff9147c7c4943791e88fe5fa10a44bf67a5e1e67905f1e76f035641a3b96fd0bd6caf8673e23ee6cd0f253d6edbe1673718b3b9602b06e9799208a8b0fbcc3b54c8eb644bb7d1fe0d421077feca31a59580410a4b3ffafc619104a91108b63ef9e3d48b2eaf671b7846bc9a9311af1b72c63771f1bdf7fae50e96b1866f39a1ed34ec65299dd83b9db1f08ed024ff46a8211ecdd5ea5562e0990bb541511a195853e6cc90affe581bfb5632cbd6890c74c2139ad534e3f4a62c7e0409a3d8eeafbce3194bfd960fe5d4c11da99c8702655bc0fd1fcf12f8b100caecd158a245f954928d27afc4cb4d60fb6f0e0025713b5a95a71224b2d8f33979d26b74a73bf8fa82f9a168613f02d41c5ee3cb38e3e1cdf82bee543e76678ed5a231532dbf6c13cb1a3b7e96023a245229c46d2c075616e3663dcba2387a0e625c481cc2b04b7c8b7b592c3dda08f72a8811e4067ae07b886ec827843205154a079272d1971cf4b97985c17bce6b4f1ccbe9f13cc834045717bbd3560b6186d9f54a4d59466ac478a5e1a6de9bfb02a869b394e1ff1e29e4c565840510e980fdae392ffa27f6f5e5c9ea550d114c8cc4a9d3798df38ef3e3889c508f5c87b4ba4327633bd1c85e17f80fb2e866a6ac5effd32b5246a56d57c1dfeb7385992f68c914e4e84c6316276006461d4746f2435820868551d6ce08bc552f97a67fdfcc8178953b076aa00cff0fb7e4aabf9d7bbc8024d12ec8a570c427c38c926070f26483293ce89aa9040b947b0269dc67dc0f6602e50aec2b7eb518bb4d8942025aeb0554a114f9ca5530beefad71a4f9002a097ff5ef8fb0a8771872857d5a3ba66733507fc2b8ca6a300dcbb93475bd33332f82eed392df801138ddacfd9e30a6b80bd8fad37b973639375bb396ad626aab216edae54a99958669bf9b67e3fbf0edadccc4ebecc18e98d84064605268c48f64e714aa43442d48e63d2afc970e31584306e1c2428e6982c96ae392afd99f35b5909f0a0d7b03eb1024726b55014d6682ddb1030b6129b8723cbd7d57fa9af9ac5d0502635719ede4b7c11d5997a5c093b5fc30931b9f25e6db1745e6bf4f31507122683b068e6465dde9ec398a91035375442ec2d83f961eedb2677b504f0e76a79f365adb9f6a22f9b9e1825520492f63b6b20f1c7325877be7dba23702ae7a1b58659650a550d8e59412f12d74edb23389049a19449355ce4b0b9a33adda2035640800fcb607ea2d43f96f553bb03e17546d529da130b0f8c5e10166938709f63513eb3ad1bb416f4ff2e8ae2d7264366d2f140111e44d38f646d17a6a0fe75e210acbe5996f27f7466cde0a444d89a88ad9c18a437b1edfc02932deedc31d220559f4b46d6e6ed7b32c5d420a07252c9e62e80adc8d637784823ecce5a0d6be32098976b600c37d77358eb339bd0f4243c4bd9f1afdc1c7f67b15ccafd6aa3a2f37d4a21cdf6ff97b8b45982e098b096d9b363e0a739885866c2de7d083f062c09c9f7d93458f2b72fd5b3ea2bf7306909bd6833d9526d35b41bcae2d319e1c15c3fd6d724a587e9ea66bb0246805a0894e0de16be9d889cb93302e82da3e75f7076f7fa1b904d49e635302de6bc506bbf8f0ce3a25692dbb269edb99b83c66f0dc27e587b893a026b1e59133fcb9e073d63c70b9e0fb3211ce0aa918872bcac592bc210e760dd466b922bca088278eea48e40aeea640093a266b95422a234cb45c6b62209b45b251e99197bd89ee7c189a55917be8e0f9b8cc4582b95bb8d9893d298a7cf36ebd6fa0ee535a317707aa1ec484ab7f89f962d4f1f1422ff8257d7b009e62cf5107377e2053adb14197e67c5780bf24c8a89dc8162f55d168fda7c97079b8d0bd2833e29202fdc6b5ff990b675b7c30024f128ba82820c5fea8e680e3ed9e4aa93a3358710b23c62725ba7cf5a374cacc58242f982e04513534fbf4d4ddfcbf9dbcc3af4cfddf469c29889ab0063b8207a0fc277cd3724eb567835f50911fe6f68d0830a9a84294f3636b1dfd6a1ef1186af2ad9f792b94a41d99ed456d8989fd0e8abab0909c72c683b4faa8265e45edd18e18e0f77eb20226250cc1764e2d86cd0d0e69d875729d402a90b51e6da2ac1c37e34782487f6222b3e07c4e22b91cc64ccd4d81967f0e1e0dff8fed7d7e8a061eb16c86adeb9f2ecb9710b185145a98ffc56a2c90bf5ead91779779284b279054ac5826514d341745177f8c7765071a47d87783808f40d1fae131983c0dc937da9dd5d0d752be8d38d8dc05fdc49c9100cbef2ccd5965e30bf9412cfa48923b7b1ea31162b2381a16931bf48eb281712992ee1f6ba8670b69d139a3fe070903a6fa16208c383f56d3eb9da0c115ff628677448bf128e72c98e5093096495699fef3ac2476fccb1b7342014f76ef8e133ca0e38db5c7b135e96bd9c91704129c42ca7765066c40bd6da1821086c6d02821d865838913411fa61dc6dcb2948d7b7a20db7abecf863feaa8200141d8ed79897f56ad247245c87097be5affbffb2a4b784fc2af8102a7d57581fa999a80388c63127d710f16b867934854e6e13b4360f4e279289f9bb5da4d7ca193e0ad84911fd386534705b7e262bf10189c30e47b4ec4c91021fa9dd8695565e95c69c08680af0c27ad8180e963a58ba188db3cdbf565a166a1821bae0e37f8b1e954c94fa426729d8c0ad268d5e313544b6acb433942483a2a7e93bc1522c7dbc6fb23250b673dcc85d3abd49e87573f88e1544393d6f756c64d778fc62603ec3dce7016df012a70b67f3e3424f1e78e71dcfa9fd04362cb774dbfd5d0f2d36904561c864e6d0f3302522a1d70b90b5a3b3e5494db4706c84cfd20a6f08b8ec43c0f7ad9c35d1a60444c9d908d410dd94b58113ebe7bf089af182b9186783494d360cd0b666ce72f08a1186b6e3e21afc1873e7a3d7656a8099d80bceb9e8b65cba219ec9e4d583654d06a62fbcc58d1b81acf5446f6f15de0ec83b43ca9a0cd5eda6671ab36cec83ee12dbb9deb825ae26e91f029c2232e6740fb31514662a536787dfa1e91b81e4c4dec2cce349fb80e6a3cf1c73a3a21dfec7d9a7e15508ef6077450ecb3cfffae7ed2c86c016968bf8f82bf6b19d749d2130c866d1660582fee59ba7b5f41f2c4e2f4970cda6beb13c4536574f6199bfacbf286555c3c84a72e02ec231dff44255ab42b19d99fefd3209afb1b1fe87922caf406476de3494be3621e47a2955d3791f5b9a6e6fb8ca1c41a818a0a47eaabc90864790fd291f8d0aed013ff3b3c1dcec9bbf55c9a676e1b5dc9de392d1441d0b6d36df00f37b2b4eeb8eb15c8bad31612290c7d942d45052788f7101c7d63c69ada5cbd4420a125730ac4adf294783b69ac0876b0992545a0e4bc9e625c9a2195021913132e71a36b79d64c48c1edb9992460cab9b5616de53eae8dba4f261fdf1662c5d86b347a60f12a391d6c0c2ae9c5d75a62d44b41be812195428d25168e51560fb411ed946f6068c849a033f7ab06d33e6d58eefaf134b70a888b3864e0eaf21787f9a51104bc9d670d0212509ad8c72eabc15ac971ed415d096970bb85dc17d49469f66b20b2bd62f60be6eadd668cd840d522b38aa2be38dd7b830d82775cf397ca158d172d893913afe39bdee114224992d1d5e795609b42eae23ec816e8579d01a9f029403a324669ecb9bc6987e231eee53fe4d4e47f4feb0dda659e8007bd6c091f3fcc9ccc15326392486e495305439092c5f47c44a332d9600a88ab4155755e22e4ab8d7fbcb295880293bff78bb99f687a1c68f8913557323e4832ee4b8e1a603cab508947243164a9a5bf73d65ae121bc03c0dae6f01d963cc29f3428763cc5fb53054107e9d7c2208201d473e6a866c99cdbb3e1aafd4e17790d33e2e7f00b34f0a562753b54e149ecc99be2df2b7bd33f4cb438d66f57acc63ca5f7efad891b601c248975dccfb732ea6a4366c80e5aa71bc9643b64008bcbaab268be8d43ef8d3f6031673a3d684333f47100087478c6f5e252a219b72f887fb16a8c2ced026dcc2726e58cf61c2fcfaef7d0c0bb975fb998fa71626d5dffc13358172264eafc954ce5e1e5528c418c4884d22056faa029766dac7a7e3d7a970820225a705b0e8dbda18e7112ffc399a5b86baebb9939874c21a5e44048e659d348b79037e3af5acfd0cc94cc025109f077a8b027a3010bfbf81260d2f4324497ab364e893c00bf0db7e1fbfa9071c046a3a68a06712d2b838520e0fa6fc9bdb2f0c69ad910c0c52f077cb88730b36c90c06f86f46b2efb6d91a6a4d3ccd0fafaa07d1bded438bb241c95aba29d29eb9eddbacdd113b4ccd24853ee58d3bfa49bd43f41bea962ccbbb441ee303ba3f2ec53c2e3d4afd2d0923abe60d918fae66490e232cbd87bffecb4f8fedeee24609249317bdcc296cddabc996d0812dfc3b996f433dd580ef2ccc20da29fe47deb766d54f6fe821ebc02ec532005ae84fdcba32181836b33e7821b5d20724b9d8daac3a71824ee73f1cc0a936d0735baf32114a226be1239950f86d5b2e94ddc28ecc30068b80c212764bf024fb619ebaef37bb1789ad6cca3fe5e58af3f2863d844f858b32ee9f88fb5f555ddf12ec9575acae6451ea12dfa4e43a8fb9cce4719630d6a41a07930a996f016eaed73753650a67445b9e09b9d24a4cc1b9d042e656ad447177ab3f0cd43c18cb81ce09ee226570fb553474f18c17e2f6da5c9a6066d546ccdcc94dbcde27756e4742a78753fc513edfd3bd1bad9640b2abc567a7f2dc531af2dcddc7596a6e4bef37c5591fb6a5f4d54af5377b34c5048b777f8da618bcf20a8c51191d1de9980e86d6398880c07d254024313034dc14a392504ae8c0061c44d6b2bef97488f7c9520a8400191158cf04ff599e324cf2fbc1d46a6934e325f2b9c0f7e3d1b7b93fe014cfdf4e2fb5bb7c8d5b8814ab5e07c25538d7be2922ff0c7bd6d322a39f9e6f6630080e8468c247bb615d537365c3932f4cb3173e77bd076ebb33ab4213c5efcbc1e008acfa29c0baea22e8822e440df933958646b3bcbc541ca85ae1906fca1cf375d94ccb6bce7fbfea0c9c1b0c17cc01776af38ad14a263e83fba7ec9b16ee40e8af7fdfd2d8f6c813a7c64d345752bba9522033176a5d89d632dfa8f309be8efbe8b51dd7713ff1f682b4595465767f352e19169d75b376157e60f9eb6caf2f05295e57f3c05d3076e1de7ac09c53b2cad2ebcc7d58111e50e3c96eedca4141dd3458fefaf1462ec8ea71c0e1047ca231c6478c5b9b3cd7b9b39bf9db9958abc59bf439b5f266032681c9b40f34e6b1e2e356b9981f696839ca502d3006944865c60caebbbed17e1cd877b43b8a7b4f93a827320fce66bf3ee3906b94045d6b9ca8861292de388e19d7fef718ad53a1df31744d56b79428cf002a866daf73c0f28a064cd5d4b20e9ae612f7a2b2705e675ecfdbeac2d53349af7e9f6bc783fd006866d724d98edcf39ed2b99c0adc78f0d6f6506028633b41abfa9435e593dec9bd5db6d7ce081caadf4cfb15c6a32528f2119a482f1d92dd872f61b52b4ff7b56ecf1642a6492363f93d43f79395b5a868b65fb73e31f92bc7dbee9ae1d459211abc43c31b0c1250eea88a9ed642f579880d6bb32dbce8f96441ccb75ec51c3a76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
