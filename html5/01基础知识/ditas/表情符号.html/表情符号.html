<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b9a8ad163b22c3b28d85b2c0e0b7542977d4ecefffd9584371587182f143f28b45cebfb99a8e637f5204f6b979796b43f4c6229d3c7b82a5cd3caf6155abdfe1b7997be3227d27ffba16b839cb10f8b120b3decb09706295c311deb2e1693a8a09bec58e50af334a249ccb8da857d4a1dd3e086992e0fa30e65abc8123b534cf5f36799a5d7bb836f216d584f004a954ef3b36c69f82d4b82a7335cbd0c5a1e092bb76d4b0cd6a8768b1017811bd28f591644bd754bd7c7c705c59e8f5f860265b2e81e254ecf092f6a0050725b6f53bbff10e0f0ee3b70648365423af5518cda6caa69bfa53998f2a35794737edec64b0fd730596b2cb5f003c3864a62eed30aac24cadece1b6e8feec045a7efd5d5d6e0a522cb4eee2ef80ca14ad7eedac46a3d8ca631837aa46d87206c555abbfedac14d95b4b3e3f7ae924395596b6587727aca36a276a6b5a605e9e7165dfda6b33b49fe7d682b81733ba56688ab9510831bbf9a3171cc0f486b453e698eaf8077235b7300f9efd8a118d6950e43457b5399eb7dc5730ef72d178d01789d6c1fbc75c2175edabaf59a70817b9fe9f999c5cd97a7b3793ad43172c425ccf09902b811b61f780ac8b09c9e551be8f3b45722d449444a20db91eb79f241c85b88fadcb76dfb1adf9d807b980cf57acaca7d74985f26caa609f56ec6ec1fe615f959ebcbbbd251e147a80a35c856907040e3b4aa080dd85077b99fdbb10b9a50d0f9c7b8f54785e78c710a64e1f0f56784323ba0d7e2f7bd34abfdf4cc922a06d5fe319b91dadf41689afa699a7123ca7c1f22fa2040f79fe90e1c192472a631257220da20a2f7a8ee59d19fdf94d11faa9ffb15df4beabce70f0300e76ad2a8573e2ceeddb4947b11174e90fbb5eaa30ea94cded94fcb8bcfa5b1ed951fe1ed26b70e706255ac5db7fd07fe96581179cf2693047c575cfda07e99cd2a8589d460c3a5b25ad015fd39a0bb37428860a6e8f90d40d4deddc747ce53f49bd47e67487945e39812f86b828119c9f9a3909748b4d76323bd521d6a82fcc54f4f52e4c761b298f1af9af60ee5d3c4a004ec626392276503c93c1b66903fe254152b0862ad8a70e2c1a618be5175364d3d776965f4b5522207ef02dad3d999ca69e67d013a5a14921fccb8a5913e680f97105ea92c408ffafb60c64bbe391d1c0a87b9d543c412429fadf1c945e5ee6db6d2286de4462417026c35fc4d75b5d56ba596df6ade11330edf711462467ef0f704209fe5d95cf5e46a61b422ba057e46ebf6ee31d117fb452d83506a8282af5bc6386c3862567db200ffcef24201bcc64d40b6a2d2d8af7852a3017a2f7b0b7effe1bce925edfdc354b63ed42eed176eddb028b486411138922f208ff58baf8a11958bb0221043b209ca82021e15da6470853bb49c80423b7ee72e3b7c275804dcfed54a6afb4a2702e6516664625a72557c849e586258ffc940554c6d3d4c0d66e747976e60b6fe2fd5f2a16491810ed4f879148903f35842fead02947ea3d67cfdd5d71c34fe4bec9e5c77ec1977064bab37cce5e2009488493162df63a6f74965c5c1f1ecef448991c21673cd91c07b462b725888ef691d67a6c040f69a935ce40a48b8c9e453461a7514b7fd9b1a21e888f5c38dbe5f0516b73a7bc827411795e911c25beabc3c0b07487ebe2a864d7f754c661e0b811a7f593d26825bd78ed15822304ef2979cb5db1e36b38ae1c91e47b93f053408a6997763d9f3589e1cd95b8773a9eb0407e5fe91ab4870aed7326892c2aca24499ec2a63c7c489e982c47059d356fe79b901aae145aa22af3c7d863e1dbad5500f44068696a27171e34e9f5290d020d37fcc8f5b14a52d4d74d66f84805a20b9a60e70c6470707fba32f230ddb949a3f9149038788f8c6b42bf2206bff14dedf46e69b59a752f38f7e76b79507425f7409e21b37a1c792c55b75aa8955f2045c4d91af9741b54c59d7a48f4d9d648e76353177f964b9313e4ff6778ad98642609a7beb0c4a4b809d55ceaead6989899c614441993a9a220d11b09398ae8718df67dc655db6c99a8654fce3c25ffa1d61484d78cea579e3c4b14b1f91e207c4d1ecddca44120ab2d9b41667c53cd3ea50eaa33ad60e40909a93a7b391415dcb383f86c91629dd0301841520aa78d366d6d92bd10f76eafe59a81f62688ba900b1c9860ad008a83b7abfef1707f2458fee479e3bf2fe0bd22ae4a16444fd1638b106079954e268c6631345e2b54d4bcf26ccfb0b42fe8679341659be1e70bff2f2611fc94eb9452021e5b7f8eb15aec2f959485959c5350190ba4f2f5fe742f136f78aade46a1d5d5a8ae36a6dccb8316908aaa878622075675694a7f69440149482605d516de78468fd585719706d0b15e0afef5bccdffe5bf59d32710fccd49fe5751a9ed3e5d4c68882b9a46081460bfa2b4c129c74be7a595237c0805c74e90a9d45fd90843ed7580eef99156c102f14449f0baaf0131a2f167f5018b18d8e704233c399ce132e9e23d8d493f6e6cf1381391cd6ec1a3008496598699c32999b5fc1719ae50b44f4b73504daef1e6e0da3a1824573bdec79d0078f466bba032776cab5e1db7fd2ead34955c0237299ec528889a52090f2d017b7ab199c198ef82c9fef2354bb0831fc57ec5ecfb6e32030170ddb9f28d416a7d5edcafe472877e36a085f46c01b54011e1ea69b5003d48756de0addf9b1ad1942464d15d26d1968a170b52cc5d36b17ee37a2a2d3a32b58ed85a700dd382c97069485881d31be6702a070ad91458d52b7e245e939b0d6d787363d5b3a21cd703d26589a01b7601c13b37454f4e1ed2a41b3d3096628826036ac8d1e6770d9f7e04767cee79e4d5d714e699eab6c3bae77a6e4813f62ff7db023d50c3bf6efc344ea88e9c4165c49bc3b887790282ab9943f6eae43b02627b1968ab609cb967838da505f73ac4fd0473764a351cad31f71e8e9e4328e72a0c0ef7f1ee08489ff04c068b471696cfa122bc760eb0fab825b2d1e40765f443f3da9a0244418f2e22ed77b778a725c4b095e4c585548ea08c1881e8c3c1295148cac8884f1cf4df960232ebe99ba48cc69ee0f3c80b5753d698592dd7a5c6927ee27d530168ab9f35c36c2af786911e440f6312b3c8b9a1ef347d43e9ae361d9ee7d45d9a5c337858ecc364ed0a69f04dd25baf5a976be144264c6f1a63a88db11ca99b29ac8140a26ba149f41ca0b6b097304ec27854ae66b3bf0c2ca60c5b30980a5a9aa91b1ea3173f3fa6d647f34b9b7c3aac43f0626d916fb4744a7bba0ca380da8dfac18b517716fc80110d314deb03bd22a07b1714f0234e678d7fd552af2741a51118cf17a34ef55dd6cd674796f796ffcc35098497ffc9cb9809e871316f5df76abf33cbebbe7b929debacfada61f1f1a0a42a1efac67cbea033a15c9e5bfb7026c073cfc09020881c5d56ddd10a7db55d312ba6087c901f98159d9c697fac578441c16c534f1f89b7668a4967b745ccd309d87a649b4551684e720b0d174cc062b1804ff4c9f76b0e1746e200373a7f71b080fd3b722e2902354de0e021340c301563367b94eda87e9a2b6b12f99e4ebc311002bbd6e0c6bb3a1e53269f97538469fbfae0285dcbfd2f47327067d45aa222b570305645cd5220bcddaefa65319a557e4ea6e6d59dd7dedbfa9ff8f61fcbaaab728af39cb6b79b06c807134596631d61d2ad118c0b515df94a289bf61351186d48c15827f5f6036cc0674bf3283d11932191ff73aaadd58b7c061e09f6b179ad8414294177ede506d4897d30fee8b29e85d6d4633b315c8a942342c45e23b289ffa062ec36daf45204352419caa94240506e7c90206186660b5644e8b0358846a563f240dae7e671a9dbd4132a2e2301f315578eee209b65d934cc6306dbad00ce5472018ad127ab16467facb54d51d253aee43f7917afdc3fbc2828866c370c9b79377b8b044704d02d9c28686c07c325f7f63c8bd93e5153125ba1b5c76f7fac58536ca4c92cdba3d292e9110621d432f0532ded38b1c0bbd7763704699cf849ad4df7aa03428a360adbf4b2b92bde2d0e33bab436f7fd171d1b24db6954e0f18e1d40723b90fbf87ecd5aa7e358f3d88c5a51cddb4be73e15d91c87a77f78f2a0ece8ed3519e71cd6ae8a830d67675318ff77e61f5676fed270ba21a685d2e5b42a5eee2f86c3a7f9b0b6e4fa3c8078144be84bb117ca0e6b016ec3185524ad28570ad9135f3a85442e6a5e1a88565249d7f684b5f681f1c2f409eda24aec4cf87536304003965959cd198c59d6ce7be89d36ee048fc8d8fde7ce6eee64b234bc074e383c6f7d3351e3f857ff3446c23b97e37028a8d2f62238dc983a5e981ac5a37d3f5348662668f62f1502eebaf9196cdcc9b3a5610d08ffe7c3b82842e81fcf2baf3505172c5b51e27613694c6a1049445e829d333ef22e2cc94b0a1ac75d959338f82aaf907985eb4b7226e47dcc62df303a2230d318ef540293882ccab47429fb59509ebfe4fbcab996ae4019d33c50d4715f4f9912943a90d715e9045f3704046a73ce224d0dff0455b296467771c2a8ad2916db3b0206c39c3b7859703d92eca99d4a2228ff4017b3afa6bc67f8a83d5e77640da95283ac437cf2cc193b9cb3dd9d30d72f82e0a5d30bdd1733cc43c685ecc600f568c783eb57c31667529bc6f999777d99e8827062a31381ac2bd2e3385ddaa34076e3da6c535dc211a267e52788ee02e54c11d50dfc51ed710d0c8f59889dcd3218dd370ae00e92d61b66c38a47d89e82d0535fb981b4f561799ab1794b748227ca7c447ff7abb5637767a6ac04bf742099eb5e3b45c6e78f622a195940cd8d790fcb78202393d08bc74521a87082e21834d7f3f98b4af8167535452ec656cd1a238505b6f794e5aa4121ab8fe902c0ccb63f4e381a234178a3c2fde6f65479db8f47b480b0a3bb2027b98ecc94cbebfa7468777bc866ffcac8b2c7a233a7b3f0d5eed713c449ade436677295eab665ecb501a8d3cc1ad540a0ac61df7c6faf2bfbf4025aff9530348544b863b59f48f7b7589d18b5ac65c6083725ba75b07f70d1e2b66da7f56b0e958d5794c9519343ac2d1020d7dcef1cf77d32d40a6eba6f5c6caf33cd2b79e7c47e329bfb603a37fa3d69d0c893568328bfc144a2dcbedd9c89733bf1bb14d67b669bc1b81ae8641560a85a53f4b49a7c27c0566d744fdbe4e6d7b2feb9ec84fdfdd1a2c181cc42fbbb53456e0ac2f4f8fd721c02d3b81b7eafe2ee3376ce9debee588f1334f6bec029882558a1b7bf2e568fabd2a698c8db67b66b4b87da0af4e2788ed134df9c1226d92afb34ffe3f69604af1812bf3adb322ec7b707bac7bf9532db6b3ea7e592982b1b1bd9d675d9daea402abf847a401e4a4b5e550e7eba8881c050fff36fa32052f8c0338007bab456de146c67dca0e17836d96f1074bbf19216ee4640425b249df1a687f931696715248ec85f15977f1b17c060cf51c7a5dbf71bdee8b24c018c9b2f1ddd64f3a3f195c4d8e88356f7d8cb2128c46b4a433f1bc2ba480405de88dbb92e55905afe066cc613e7230bff799d7f2fcdecc244fad23c3b2d7badc9f522e5c60b6f32eec2335dc610f6e4ca326dd281dadbcc8513635b752755b90135a17ee003218bff46cde974c9618cbfda2cc013912db14ea995b48e2b19d3672b899614994aff1f521a431732cfb28fc5d74a199d28a525dd4993b3f22f104f8642207a8a8d9ac46756e22da06e9df3f7a9491a509f3eec3e21e427c4053a9c306a860850dece46562e369fc97e0380700cb60dd5363a097575b7e19a209048015282290b3dd79e11bb43b01d9c019635db6627d19ccec6637cd56ec6072a1b0f7e2cfe8744a3aa462a7776f93d19e73cfc2566870900babf8033b026e1239fff4c659569a909339069eeec89ae6fb8f995e6409570f73dba08b3f1fc9ed9f1b2790bb86566b057b77be6846acb49c9e1a6374e68cd57baff4d80e51ed17cf01d200af2b01be3b72595c710e04dbb76b59a61a6a1e3f7e5d0cd27042a2a31e477e4742ab714e952f457bfd956af70d2a65ac4f29c3f12b9aafc3a4afeff890bef3fd3b7b01c7c10903c3470f98be8b3ef56b3c0f72d1e9a2319ce10b9e0460b0c8179277fcdc7a2a656318bf605626d4d705769df32b1687310466b8087d09b83716379a77c4bcac6ff914960e94375062fd362e84724d41a4507f2a411d165b98c5650cf947ee9fb490394c360e605140f5a81bce4b5bbac89c8783f4d4ca30a903dde3bef52f30d99638fd7a296ed8eb5204c8ca3daa935655959ac49f52413adbd17c75fca9f9cd53ab43805ddfeb3dff87d9a66ef3a15824a62cba60c85b3815327a3fb068f2cd0cc630c63786f91ae2038d45ff045a2039c9512ae89432bc03e1339ee25a52d678955ee3e065a542833295236cfa494f647a5495eed0f89e8dc46aac398d90f453bf5cdbf298a09ea5d931f508f12dd38fd06f4f1990489cc34433806878e6d3874e547f4936afb1d8e11a21676e96834b6463a9bfda8f47ca70a137bc51b39e5053286cd1624f7060d337ebea9f5a27736ceef0a29eebc5dec015cd7b1e0195552136e4f243810b2cda1d5f1b1dc43602656c2ea248a733f246cba5c4e7c8e07a0c3d56973ed902f024c6d363e344d16f3034a8f1981b8abace16b63d677bd4362456f975f1ebe9572cfd37447998e65e21b5c0f3fcc7c769f667f47e0dd11c62da526aa2cb5907db440064437845c34e33cc3588cdb94ef45d22c9ea57794fbf93592969f6dcc1156de6768ef78f027af09f2031201ca765620b4c5cfb6474cc521cac8ecdf9670bc42c758db4fc39a8cf5eff55c1ca4e5887b93cccf45967acc6b53aad87dccae2fddc6e22276442285130f5deb6910f34aae2622ce122658cdd9f039d343230ef8b1b503574ffaf7af9309302aa13a2b7979d74b95ee2f601bf43f6e5ca6b368343cb6689fe8cd681f22206b7a59abe39141b14372e5142681a3ddbe3dd3d20930bd44827925f0de684a498080ee9045c39b23d31c3ec93a5b0dc2fb8d7d7dc4d5050506f90ff1d741aa7300071b708c47c1ef05f13c36143e32981441e0faa19b976fe7786b40ba77bd115f560719a97854b75f9e49efe1986e6608ca37cb904973e1019d94ce5b52f0c6981a6189021ccd2a4df4a746084e458ff7c81d3942a094c92fad5caaa5c52fce702490e8284e62643d3efca3fcf93e25076dc08ab5ce6920a939a5b0eb7f467a339d59063649ba60ab3c8cd46cedf81b91bf0124286a07fc8029334c93a59042e541be9f733991187819f13b48f496ee268230e32f494b08bea01eb62c2557bc4b367f568978fa7645b00d0ad832db848c7930e61c8257eb4fca5cfa5320723c4369c5f22e8411dcda9ebc2046cb5fe99da111c9f5797510a24906eb4ecdff6b392fca07cca2ef75500e343f2c9f68f8aa1e07b8f7f31d53df0cf8d6aae805561ae14764c7cc0a1254ab1a5726fa4f60d8dccf294e648862af64652e3a1eefccd9046d013a56c52e63e07c745d8386b39f7fb3ecb17ddd25a5082f5428d286629bbfdbbcff7453baf5a9975fea7aefe6fc8fd863f0e2670ba8eef09390e8507ed7f61c2495bf83108be6f0c899300479d8c86238d428c399702f24aa6616a9816e9896ae02295230888cea6b4faaffba851080e13e9d010f0119c76e0b196b30be2865cc9a79aaa5df15f5083e081dedf90b68043ead37bb5d387840383ed775d124c8168ada4c4dfd6de2ad4a37e12dfd7ff86bf9ad7cc53ba0eddc74b89d263ff61693ee5a59a4e3e7ca730e7692b57fcfcd1e72db1aa5e2e3f1b94689d2ce5fa31c576498f6293ec4ee9c6d8f0490b22226f241f64e8182c3e962b4e44dabdadffc2b92080fa3f3cc5b5dc013cd614b04875fdc906009fbc12d4647403faa6d4b785c043a0429dcad23ba5e7a5f3656f99084e744aa9fbd467c15ad3968065cbdc4e721d1bdf1a76e7819d3706d12cbadaeec22f8fcefeae1dc3733efca7aef5eeb0cad6e262bfa11cfcea2af261e33035fb540851db2fac07ab5801c46903e3c3582bc1189346079bf17c85a5972b7fe9f5e7548e63a26329314d063d8d5888d333c451a30bf1dca94698e04f6f2156de49b2f3d4176e7044d784b67abb8202ab92d34db0876e868d054cfe5ff1e1fb1ceb8bd822878d9be98c7d671a667148bdbb910a8422ed960957f43628e98d0e7917e5d398cc977c45d6c08c93709fba259d777287bd0fe6309736f9ca8341e61f011c4a978fae961d753690e6db187b59a170e77a01dc50449c3d2a56edc856ab86c38f006e996552c82acd4e19504a9c6a412436d36fb5d59fd5f5a0fd72e8e1d4008fe30a5b53ae7f474a6d5ac5b95486aed2bbfc9ac3732c065e7b4390c91a5eeffbb0124c617e966dbe8d03cd9b35a402cb0b3330d8de79d2db0ae39845f567cd5f79dd3111c058669bef6de292440d001d1ead886a703c3b2eb463285c2f1c1469545e815044bb463680cb2506cf7d04ec6a2c2786ae694049490a7a00e965b4e28d16498d1d52df470d83d044adbb6099aa71487283c11e211513099b2c580911890e8ec0411f581ece86a447cafaa19949ffbf0e80c04b6e146c8e6269d7b17734cc2520e1666e3455847faad9f8ff5a5c71a1dfa4a083432ffd346d0fad8211ec28c3793a3e41cbd21768507bef3dcfe33a05752ef88bb50c5c17a4ac230b311b3eedd8b093ebab5d7988ad71778d98798502c303d4bc0dd89b7b9cf7c004dcde414e4fec521e0d1434a6eb3e03b7a6b6ec050a599792f871f3d73b00b59bf6ad309b712c99e8ef2601ff7306a8cfd193b31eefd07093d4738a037ca05f3e2c8181daebd74ede21791188b35259a8ed4aaea7dbec888e1d359cb56131a26c8b54d0f2ee0ca76ba5bf087a7c490fb49b10761272eb68a2650b71456c40f1e18dfe80c19aae0812dbab59647cb9420253dd69fe24ff134195446c3cecb37bd78132c1e014e2c7f1f0aa960a8498b8d7a0baa5a4eb6bbb7a810385233aace374176aafea4c9e59362f883c02e8aa8efee42f840a40ab17c4e44ef1e0c402798c2eb72f1010da23f8e6160107e2928cd6c993df3f35bc7f4da3b980b729afbb4a04ac5ee4119113f92c3094883a0999a4afd86114b35339cd3557348fdd92b6c02142002a069c931669ece12f87d82bbb1a9f784c2bfc36ca7e8996530887de85bfddbc0ecae3dc1e06d120d705bdf3ae73b78d3313a2fd2682e3ffd923e8d96ea0af5698d54090b8aa895625b579b47caa36b1dab94a007a3ca27e48f1f51e62813576d7253cf3c91fb55cc43318b87f82924827ed2e0d2bb56dc25e18fadf158db53fc46f3e3f53fe07d3dfe32f78d5d7ba514639154068eab270beff4343b42f1d1392834d13957014a19ed1b1a2ee22dc1e5049cc56b05ede5464de1f704151213115b387e28f24feed58db0ab59c47ea78a917846db2a969aa85aa3b26ea6ca5c25ef21ce3aaee53e3274702694618d60773e3c9d94060318fc50a46f30966b89fc30a2d8a2faa28d9d2c5de238ec2f58e462d8a1a72b1b1cfe0d68c5b65c0c67f17319cde9c705216f3acd50c47a3d55de89b49c0350791eab4875c7d6483c14254406069d9dd3d6637fda2fdb9d798ae1b60a4499ffb12d94227fb1f1fdd50bb3400f55bc4f4b9327d58545b35313f380bc7b383e8255164c57b4679d910eae670a0b9dfe9d8c6731ca46269448aa25d8db61f0d07414f07b0afe363438d4a56531fa5fd81eefbc2f0c730ea82ccd405f70685155d2a0cfa8ce0d1b156c846be4ebc9f88405abba217c22ec43871a2ebdeec139dda2edcb294f078f28fb3ec3a4dcbb22b08bb226e3b34f68295012e7aebd803078e0e3922775e50a13aabaacd5be4ac3d822a3b7f136e2725f1da97fc8822093eefe2c9ca86dd553f01c661a5d6201c51a3c314bcea38bd0f5994b908b2d7d6d7685b9cf363b7da64aa46108c02ce1118ff6b34267cd265e8d76c1e1641af0b1a6e93c8099af626852213e02e04021369460e23cfb930d82f14d00e1f261a7f095d1a90c24adcfdf5ca670457a5468b2e029ac96e9630f1b3080aa26119824c2b6d2a5070b190a6f63887483a6dfa0d201ba71a37a3eb86c218a490570f85032ccf3e5fe13b1cc99b643460cf581878c43a05ebd462415a1435c485748b4c9295db69cef1d57ecd0046f4f13ecfa1b782303d195ccbc5896c61096645c24683a7a4a46a70c6cfe7d9c6c6c29e626e9d8ec28be083b00342971e8e13eff5121ca5b0ceec5e65f037faccfd7f96b962002fcc8527813ee4ba586ec442b909b6c2eec1964db4b46e960da23e389ef5c9c33512e6d857806597cdf14cde0bbf3e8115c4dbd0fce50b63338bb1ab90f2af1e1fe6c38dbe2a16ad97961d7bb7c67607cca4b71c885bdeb9accc1db81ff4d64b1b82190b3914f667a67e88035fba59cbc4a22f29ecc755e9480bb2613d7e2ca1e54ce9e0b5e39a5043a46bad26ade73f44c6af311d8aee84ad99cac34383b2216d180d3af81a167249e99480c8834f71f7dfeb21dfb9e30de89c7a693a1236616213ff3fad206c0957f4ebf2d2f8dfb234e1c461eb9b88c21ebd3a2e06bd600a582398b9f59856527cf9f70b7576e42fcbea3ffa89577aa94aec9e4170257cec89a70c75e4013c26e5eb41c7443d33ee4179aa3af54226612c2f5de0837ff47b4ac62138326636be08d778153833c8285b229361fb1c6c22e8d92051314924831dceaf6cd49546a33446c3e78f9f9cd5ab637e1af0095ae097a5365709e5ab38e4a27c582cdad61e686c239e5b61665072d7a2e200d9b7373b562cac1f2f53a007cd434af105cbc51841aea0007d7f776dc828c62a6d58cea24de121e5135f747ea63ffc57236b298b0d908d4c3372dbb3801ac90174adaacb64faf65020ff69cb5a5e6466e7758735f4d6a0cf4b56933d65a05f54b7c1b92a95c92440a657d5d88ac4e196c05c04295cea405ea0209f365627b0de3c61e8c9ca50efae0e8267da1e6c8fbc27c54126f67b9216c41ba71cf18e11f1e74e9ebadd0cc3b8e8561360fbf2911ebf7dbc18c4f8d83a60448e1edbd450a9af9300a7fa8c885cca6a11813527af49f5be93c95914ee10ef70d2447535e1ecdbac1513eaf99fc45b3c409f7b6ec3efc36f9c590c8816e80678974ef3cc000624a18a4eeddb2f6e62d338d27f498a35834153e37766ee415bc24735d4a9579b6495a3c538331fe4ce29f581065585a4ce8b26be63f4cd5c3c33a0ed5405be6f9f31ba97a7da6f4118598f6bf8d38daa4e0298c2097060612927a974f1cd2f6f44894d3de833fe8d6c660118656229382ca76b4fa929e2de19dff9ddc272adee41098cbbb18db01122c5af0ec27077d5e855a9aa167ef1da4d7ad6f55ee0902e9fe029605acef148edd5a9bde51637704a1a21429a84a3126d4172e49d90ac1fe0fb5a0365b4bfdb40b8dfd2d650d947ac191df73229a984e124496cdfd8b9edcf486a07bddff724877a25505041c699f9cf0380a9a1be334bedbcc070cd8b8c43794b12a69dbcf2a8e4ba6bda8b3f645478944556b2d3b6fae114fc657ea7b8a54e4c488a6ff41699b8d869dac52fec57fa0af6a36db66d7b28ec5b6cf8baa10d51d8bf7d3b00036e554f13870b1ac80d26c8152f97cc7ab7d7e5359ef0ee28ec649d6749bcd0139e700a683b17b135aaf1f6a456f6d6b172fc229216c8555c9afb3e17b20d66ce29b138d4c002474e5c7edddf52cdd28785686ab1e7ac058ddb52f799beaa149604e2f1dc1f42f508101b2905c032bb7410777b233015749b0da2d617dafd3dd5472bf60ba3df9a354dcb66906d4fb305c78f0bcef6353b1c5bd8ff840cfc75018b3c780279a0115a9134f227763fbc8f5b26434fdadff7b70d371fe75ed74280f800491e9774519fdc61a3d908a21e35d895737b7e99c7ad70d4c5e7cc6b4d5e0dbb7b00f76c9226793df6d866bcc6501769a0daf5483058b3b08b2ef4d270a88ce92b6c6189324c697b2b28146bee1443c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
