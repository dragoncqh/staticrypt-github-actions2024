<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e38734436631d2e3ce38e58d3bdd5bed3055a0641a7124c030633ede8b80ed3a61dee3378d803131bf4d5ef3852605e39cc98d28d5a745c21880056b2ee1d7874254e83e77c31a5e6be14b6791ff7d296f8977209c404e7b76991150fc532abcc9c80fbb79b4bd3ee9da95a1521c79f496a2096472b7232e4f52161262600fa5d144c45b4ae61efd87de21b07af13dd4622ba6c5332600c0a6d5943920906758c6711bcffaf06e38f7718c0053e0d187f95b2a3a6ab7d2c1b47a0d500b8dbf6f8f76f56683d72bf945a08a63a30fde54289e20312e245e1acd70cbdf6c9bb72dd577c3cf5f9549b5adc77f21fe0f37ebc14b0abc105c8a0c1b7a0667fd96136dde61e880244f74824590a7055d51dd61e03032a9100c869632416825ca1d8e6f30ace2c592d8cbeda3546e5274e4d4bde31f5f5f674678f3611db087fca41a2fc54226bc889efecb65771a93e8f1ba190621ecb5e57262bac3bc64a01f4de53ec5897c6fc0a943078e6725de58633480a0a31b7b3d45b9fda785c869411c0107814bd9735fce3c0385f1ffa748ef7e2746f5d6cdb165543c283de3b6b54d98e1473d621018baeb2e22f5f35de57c62343af526e850a5c8a50fd8fde38ccad19368ec106e75a6657007e9720c159f0fc682efcad71ede30e7329e0c384a7f9651a0fcc3910f357612face2ec4795d28a0b664f43c1e225eebea606ad5f4dc36e08fc2a6ef1eabdfe3b7819103fb6142bd7a88b0828cbc43b551516e29922549825809c04f32707ca1a59551659aed82f4dc819e0ab2e6f35f27facfb0f7c2e4e5db9de99ead917b0acbe6bf9b1295b39d32de38d672fbcaf24ba98fb347c572bfd17281d847b46aee09a9b1935577274294c582fffde9cb289b60fb8d76871ad55227221c80f3b956700d84862bf448fe3dc4cee57b297e8960d9c4f40657513fcec8e89458a61bae56c6e48a0fc69db52750dee3ccd9b211cf73e8501db60a61734b715a1c999d5eaa89f81d0afd7981c2c8521d7b5cf3619ee621e7ba6b1a3d0bcd967d19ba785db3f386a739ffdbfe0e016121651634c36de4a884804db9f351d026b1d15202f1fd65b8726d99bc617eebd6636816c341b5734cdd35c129d7a5c6164ac39dd0d43602b814b8172c04a5298d1826edf8216df3d50b2c36a928ecdf29aafffdfe36808f57fe81e1516d598e7478c1260a764400554b5ad9eebd54c96c6d21fed48d9281cf476e736fdb0f76250ee28e3d18a423034961011e17bab98255867d023e8abdb808f7f05033ace7e626c92a946c39a69df98257e1a137b8e32172c0580fe87ee787f879ba458655c18aa5c14a50e4e2275a4cddcd56ad3b29de519eed5523e93000c6a4bc303a0a99a0f660896b80adc870778656d1c4bb974ae72febeb11af9ea6679dcb8dae348ba46bcdbcb669004674a9fb0719f8cd30ef6bc1b86ee77085899044fae9db44493dedfb8abf8ffda5e35f86504a1d132b61bd43b8927c30ace935019bb3d987af2c24858de55a50001142724f67a6e0249baa9c149842211a2846a29b3439fb19cbf32547818e1f929d0ba8172e7fc4dbaafcf29b6c3649d4a6349f43fa982727392e8ac4615fc31a8084124830f643de94abd31345374281f5c4b4b82fb57542135da5c7f0ff6b0f8f9dbef068edb326b9469147443159c5063d7968f00fd2321f8367ce15d5c861791584f22cf81f42bb9c034488aec6e7e56a667c9f6a2f4828fb6dc8b153ff9cdca3a0ef386c79ca2dfd1fda2130b74a38416b2dcb8022ac75888da0011045edfd3dc231700dae167f5bc0f0273e5ca063ca33d02aacd4a172a5fdf82c4b633d8ff771313a654f4c5d20877398366ad2e1ae375fe4b04e1c42a932f45738cbd0507da4bf708a6ed2cd5aafc1469e3337bb6365c4cac581f1ae11179065c86ab70b4cdb1cb33c9c270b30ece390cd8fecaf79043075aba2d6a01e2d7c9099017e8b6faa5cfa40aed4a711f5f726ac1d20e22284f23af29cf5eb34c474ae18eb5079cf8d70bd4dbbca3afba8331afc536fa9da955d6894f40f9f2e55f27d5d8be65bc6772923840adb21fe2f3b48e107ce9e9de61c64996ecc473d6f719c93eff44597d1ceaf96596782a62181ddf693638392955ddd447676319cc61b3cc5290beac5bd9854c290c9af65537b367cefbcc39cd664e61893a7ee02f1dd160dda0324b2350de8dd7de694d3001207dfcf00b00f1485a9db0aba439beb0da658e0d341e4eeef710f3aa4c04948de44027178a48b41c216df20f77e59a5af574e28a66d730392e019ee337968c1850e64e292f4fc7aa4e481baf6a97c29c63ecf6541086ad72f55e9b69ec6b04a9a2583ccdc2b1071040b05e0ced34797d8b41b82a1c815df988d717aed788d5ab39154b8c38fadca652b919af919cdd0a1f308304aafbd148be5f78ae8eda6bcbae97e072668a288e7c26d10fe12840e22727db7de9ecc36e91226012d8a66faf9a51ecf9ededcbe5c5ac02f28d1fa50a29b449f627cc3a2da6dbdb857484e0c6101953378f67d855c7b626c629783f1c4b81f2daecc3890ac6ca8d291d03b036bb13c88b0329150b6d4207d5b87b18282045448e0f89604fb9793647b14e8d525dc72432d98dd26d69e82f2beb58550ea3b9ed7dbe91ff5ac83e73cd38581be853725c626fb33e828c81f70dc3fffa635fa2fac8dc2155241990eb438f5e15e0bba8794c9e62c234493a2bad79c80574b545895271160f76d7110c6a4cff021d7183d3de140559b6ae806f985d64cb052e32fd7e08c77038818074cf80f8fdec4e62e1aa54fa660aad7b32627873e5c1dc943a928c678a63bfd88a550ba5ece220ec59f47a025814d57f8499c43997aace8803258deda6c4d65c509e30443cb24e3cac68ea14e8409c4bbb8d82d68206f114c5ff789e05683a11d1255828266fb545d17858f2e07f884194c7134458cb1f4bbb434ab93b841d21c587898f52200f38e27b837583e257955eba2ea4e69cf1d07acd1145e63c0b9cbc211c487fbd74651de69a14e4f4c19d87226dd41731cdc60dfe7f58e3c57c8ae19a45506639cc21185839251b410492dbacc3c7e15295362d2acd5e9f95d4d5814974a1f51897b4e5da6e2580a69df7ff1baeb9fd92d829d304129818a9a782520acb76eac220ae214c8feff53c9dc2bbe0abc986e55d87c536ecfa0e4b3570a6b5cf0b5006d629c261010d2501259e845e07aaa32205e0006d82e88713cdaa69d852fb304eec04216dcf6b24d3ceeb4d39a2e697e41fa636a4dfb5ae21c9a35ba87b25c271ec7d3af3dc76e2e0ea7bb2fe076e9aa8b38bc572733276b4e336b9c301d0264aec04edafe420af60eb2ea907424d268f1945a51794ccb2007d57915a57689b7dad9d62265b78aa31aea955dc270e2555d137fd04037ea2f1b89ef282eb9adb5501e2f11088f8730093f8ddc2236f325192ee5c4b54201a1e067124ac741865a10246cee0f664f79c9de79e24c4d9160e0c62364f06f921f7a537f04d32297f3e72151e5a0d900b95d5c10f633c4a939798e2440fda4c849f58a8447b1626255998958a4f4390ca16fed81722eb349cd875aff0bedd80e2d162a7af2b76bc2fd74c6b524340f1d144e7c3b0dc571c63a6f072b2c9ecf27ad33c486ad8ef80f4ba44ae4f996cc554817c229fbd9d7108cd38459365241bd78df8b12b96dcaeb02b1ab95a7290490252efd69b1f1aa15cd2c3a582c969869e58e5e9835057875ff5012572fb6de72f6dc7cc66a1fc54ce28222948961a7a2d12982de77430f7f62e23779542ef18ba320178c9181de2b8bda9eb42124f2a44b90e04a9f4be1852033556b6525a916bbc1283f256bdd67c05c535edfddde548e59d8c72e7c2b6b89cc532459730b121731b7f2ecd69976ebe123fd1a052f8b25c25aa2414bc2409781ad19264e9975dba4d12de1796cd9eea1a26e17614af1816a19eba5679b35b51eff30b613cb78c4538d1360c468dd3a5e2cc88b64c0e27fd4b6144dc66fece3b9f63946063121d234c1ec72addf9175ea7113e3948bfbd604ad599843c0b5dbf3b5b6a8bf8b98b4319ddc13b5b6a0be1b036437493da119b4432e7d7f97b856bfb5b2ee37fed242944d699f1c2bdd0fd944a0a6d507cc2f2d970fad44b9f90348ef85e5efdf836fb8eb83ab6dc3846a90f773b8480ac7758b7558dbef286994697c45702f8433d46eb6de6de2ddb132d3d4a515aeed2b623661ea7301063736fe18e8d2e132f372e57bb45e17f5e84c133f0730cac067ade3728192eeb16dee9b9c04e8c8ffd4d9d5399461cfa20b4d5d3a94f59c572930f2b978802744cf187f1f9134f3fa8d8a0f46e12759460aab6dc8b598eda4b39aab3d11487913595920e9a63c2092416ba869f4982babbb5e6de79393992c35e8fb81aa03d9cde37a7bfcc26133f1262f52ff47454c6f66d5b08472583dcc0792fe92191731fd65be1bf77454290177180df4c3fd256651a7ffce726ff9befea9e9e77a16f70795c0f9917dffae96ce659a8764342d1551a5d97a4d930e36c9c64f75fa7689dbe3376f385e392cb8b5e5991a3aa022833da45d41761df136bff362c6951e70d8aa11cc2ec470baae3efcdee7018417a3934bb472cdf3164deed68a4bbe9704dd16c78acef8818600bac6968faf8bb10e295f9801b2c07121114e206d0f77acbb52426f12f5ae9cfc6d8f05afd0c9f14e6ff0e4563fdde4c84d315c4c12e9563e637d367b0d1dc685c5148c0ece3880ae57981a40a69dcd74949915d8c0ca6f9b52da3bb0a5d17e4975ab500c734d75bf31395bd80490d0133f4a5db9d1242e3fa6d4778c2edd6ba39e9c1f47e9bef9c80d4b781939238be0fdbfebb1f01cd553778bfb4754d190408f385f14f60ddee70c3c4ee521a392dce7ff43c826b4edbe06c63059039661b4a6671163669c534f7d9b40f1f9accfec0f9d5e601a48bc4288e18061090b091356f04d9fa8b89e1e4f252427c610a6bb5f4d5d09aebc7287f4ba3bebee464ba600f28aff14767ab534a3abe1a1086e476c1219c794db73238c8189635f943a8f55250d0daa896dd8591b17414fcdcec0786c759db94acccc66fa893cb4ce288d34e86e58fe9560b7ba2e50314a17aebf1a082c26d94772f774aba807f1b7196b5083d86f382790f97ce34ced86b4ab584edf866579d816dd7d16de25ed77ce5165516a4e4e51606f37de7d35d9e83584be6f98d57afd4821bfe7b5e262996627a36f49a3c3879b5e5462646e8b41908f415ddefbc7dbabfbbb019775a252a30e698a7add8e0448c16b69e0ec1f282fcb72d71dfae3bb04be15e8ca4c075f3f37392c99d1f513dd2fce961928c9094f9a5993284e61f8f75d0d14d9d28e84a1a774ca21815e61692a3f4c0ea7857577b9b84efe26e069d75066f46bf4f3256ee58e7ca33c7b47627cf220789c2533ce2f64dca5e78a723a13de19049785bb5b7ad0edb715073dc9af5c5a71681432e669616a1763b109db10b099b3d0171820fd80c0eba2c8f62b63ad5e4ea3e836a2fc13ad5ff0595435b6b732b3c5fe3a7a665d70b1883f32e4cef3979e0468f968f0cd7d59bf2ec315185547a9373b7d9d7fba88ad0603e077a59db96c10c946e9518614a3cd20cd0cc70e6f5cad78ce4c0ac9511480d650594526a0d00293a16adc7762a8c952804b52ebda9ab7d08c334e0f9f3a5ee0d5c6ed68f667ce66235435a9158d1b0bccb37279db0382a5298098dbe2c8670467e563971c587917d9e7687ee03352f9f534c1dc4ad5f0d69bb7eb50e4506c224c776dc2665dbc30fbcf0afb38577554ae04b96bb8b4c8dcf47559e6409f22ed001215849d795a4cc84f18fa434f151db722c92e10892f79cbde8c775f52a1b06d440b75de49e815f7f0545e0723c8de0eb13accce2b5c3bfe1eddfbf9652c457cbe001d3ece8086e6614eeffd31b69812bf5f3e4955e0c1ff731346564b1d03197d91dae7d55b3274ceb2f81329497182d4717a27fac790d135f2a096bb2052344c8da2349530b90f40d2d9cd59bd5ba3fe3e7084105c98ab0f8fcf319f7b53099e3dc187affa7cf9355af35399ccf7d7d94660ee61ebd160f2683d6de741629efacae802df4029a318a0038a1c9dcc7e6808b815cacdc7cb227c40290592daad78fca2aa81ba76cac6c22fcf95917d912790a26f29ac9a27c81657aa4b6ae8ece9db8bfeb6097db3f46ab3d6fe1c9e8d23732261329dae38064b0837fc5e0954f16d6f3200454f6032dbd53d19364f4c81b23fce35d676ba1ce2b9e4df12e71ec838abd9b1cedb261b0ac6a0b1fc321a3af782e30580bceee4bdb4d15943c7a137c16a060437bdad728a876ee9fcda4037b5ae79ebc45e6c11e30128527ad508ad25d5fe555d46a6e08b761900c342e153cd2bfe5a0aa5d59d89c2853e5473d8d2e446a6f12edc5331bc36cc5d31a8dca43b8eb618b5415f9faca48bc744eb39058ba13694f1fa06c1eaa74d8da76e8db39c4b4e4732b26b43eaf6e62fb4230374e640577904044d3f52fbced7eca977c49294279bf6f30143f629e66b717216f4cf7d0d61c95883afb7dca67bfbcc163c0e70b4498b6fdbc69d566512c3474f016d2c3106da2e9c38a16cf6c5d028a7d7f64d70c061e07405f6e5bdfe8f1eca1c9e7208e1ed3b6781d4045ca8590ff22e6b05964ea2f7400890730e1e79af3fe9fd2ff77bb1f6e3c511e8c93efd9ab495f8e22a0134fcea17b37b08d2c59056a39fbd9359fe5a33a9e8662afb08c6e645b9d5f44e2b0e6ab7005698c845658c213351b72bd11ee69598cd10762204f4ae1f455cd0d55c3429cbf87b596437b97ede757bc24f3c090a2388078d38d32d8d17b222599463d41ee373369c5b74b6b71bc1ccfa25b67d2df0c38875915f85a0eeb586219686256b46949d7a5ead0aa4f5516f49e02d5551a0c66d3726c4b160ee4cda3ff1b4fdd58dc154a71836743a7794c4b69da087b05fd499f205c3260835237244c84bf4ee3843aafaf7167b5c424802eae2e4840b232d1942260117612aada80923cbf3d5a8ae09f3d9ec6cec6e3b72da8329a24d77056ea9bfb5da1d162cde5165e049fdc8d0dfae96f420e675e674c062d2f52931bce24f7298b0589f537184579d1fbd1b3a3d1583d4ff77e632d4aef8e2e50b3e7f530e32bcf53598b44f2116d624a83c96764f6a770fd61d95fa95f3f3bd94beb73ff0a3aa371eb75cb989476cbd5c1fb9eff5bd2b858bf0e4b81c6398b38003297874bf534158cf175dbd393a59766d72536437921c2f5dda8cafbf4050b71ed8728c909073625dae6348c4548bf3ae8df813ad02b0d61ec451e1b0a5586e2829bac31b756acfe80b30352881f6efdc9d2d384e5248941c7399f33dc7ec7f32bef042440d75b4e9b250c94d68f6aea9ba2a4cd4dc4a37970151d54a72921849f71cccd66c6e1a800268d10a8b7989ed354e19a886a3b707dbe4d44f5503d2463367bd5dba724ac5559a30c49b4565a62a385a4b595253a02999ad7f374c22f4cacbc5b604531ad731d68ef522e90cddb7967fc37cbbb6c213da8897f1036400f631f7bf6fc445b3c501bdc9b1403b6179bacde9ed8d4fa2ac1ad46c01836eff9ea495bb429672295a8fdc138d3fa910ce3a9f4748c2d19e8c6cf5397236ec20576597b3595154ad275f8e29fac64e7cda9dbca111dfdea2b6674b0cd23ad7f7bdaa6df5a8f7ee2d388d60260d32eff03bd63403d80c141bc0293b0f75cb43c74069a53f368623cfd7e71d624ff59c647f6112efda787541f7e273c72148cb8dd42953199c52a94f90edf8abc78dc92f99452856c1fa7ee912c8147bcf4e7d4c410b812ab44e279e3be7c8b0c5fc30655564e8b3232eb1f9bd5f56f32c0623801293292a0539e2f4a93edb5acd042c557f3903821016356b320433737754f9548f8d533dffe0a80b3e053324b8007b084020e04255a6ff725a24b77bc6dab51d8a5d601fc48b3377d67ba0e33eacc6ba57fa3369b8abb7f6e6248187f30443e9a97cd20afd2221e6be9e19b9b0142e0b4e6d1df6a1a20977b422d82326a4f02949189ccb058289dd2cb77b03bba4137ad8a37f0eb8a98001a0090a098d469d740e211eb3c62e8f8afec177d6326c701c2d352dc84b5ff4fd526ecb7cbff82fb07d3964e6e36b67f13092021261e814db0ec1872744245f534dd6cc5c65aecc03d92fd9e829a50c5e1dff75c7e4b888e8194ca5d94c60a70cb0616539be75e203a61b018bdd4822da121bb24a0b7398357eb1d055a1743b026b2a45c3d162ee6daa6c8fdc44bb85d1bfd02c92aafaf061f749fed047d1e1675bf4b54a5510e0c434023f0348d95ae6601f6c98a29e11116e26baac77a32ebf59048c8f2e03f3f2e6f9994f67be41db39cd8affb0ad259f245080dcd9ccf624a6567ecaa36f67be3fbeef340ba327a1bba7bd01361b45bcb34816525cd851377ae8f60cfbfd2eb78cb99ebcc1b8f3a2d050b173f7a94794e077b38f29c1e4fb3e80a992b22d5e8f1b232f135ccf66f38d358eb4ff02e59c67713ec072a8c19534bea6410921a0d8a4c8df88e88130900713d0d0b2443408e576973b5333b8982bd5ad6a50a9c2742e3990f099134f100f288507de297acac02e182afc07b4ea0ef421c0be48ababb4b7761b8fbca1815b8cc8ac6a7c2200cbb57f36e10759e564a0cf12c3cd89f67ebff476d45d1a2c320328b07b6e49986de9bd9e8080b48751f8c13de32aadff2637dbd3e6dedb8c6206a1c99da091de811588c3bc3b69ca9b2e101b2b7e2c0bac5d0eff32677346368229375a6546bcfe113f7066de7c0f924c8a1e9288ffec00aa2eed315c293a9227cc77ae3c87c608a90e6929d2f95ea8687389e787880ce32628c1add92af2d1889a0bac49d5d77d31f4cddfa0c0f093c9b4e8ca54b5bd51b7b7646448006b4cb122ab6132383f1bd4443d96c59154cb09ff5e4ba094ab575f8ce597864e2aef88c94ceddc8bf65d1e2a5ec12f4997f646f7eab6ab93704f6428bd56cc09bab3f282caed0108d23d602fb15feb6d57cc58b2e0a68f100391b5072de0bf19eebb5e0982714eef6427b1ff5f47027d79b7326ba40b04ad803310e7bfdcc092b23f0f295676807c8034d209bce3fbcb696bf98eba57ec057ad7d8b569948d18753fe01937c51415debee1ddf4f2a00e7291a2854c9b8d367418ae6f96cd58b8e32e84541dbeb0b757468c7c71ffced8bbdb5b630f67c07d4143ae09a042a256e53e88376aec77fd6b60cf35124b50aeffd4daa1fabf4259ea26adbe86c3ba447303e307a8f1bba7a954e229182d547dc9a346eeeffa5b388571f21502d6bc6f6592fbb9380238ad8e03b649a1584ba92832db50c2b0506974eff734565b9dd1215be916027c1f5ef161ff6a701c455a02ff7ba87e0a81c5120796722db81419b0bc5b12a552343d43787cc70f3dfff8342397b8659a174123783d36feebced96b99fe97349c95d78d049ba3dfebbe3c875748467ea7d63af26c539f24eb50757c6d0fe4c910c6afdf8aa7aaca7668ea624ebed0fb8d990c0b260a54de87bfd0f5f27b32286eb398b06a773237f50e39f3dbaa3d797063bea7ab450b7564aab88f8bfaf7f65d2ed38b00fa34bdd62f2af359f8384e8dd598dcb41189d9c0601188f167d7c6057a77f1134cdbd299f29c76183ea8957f61e8196d5f5de50b51bd909631dd4f7c95e53a5ce4a71290a75e231da3f38e58bdfc525bd8c874e93479e38b5a3090df4fc17f53a230c1815f3e471756a19474f80f081acbb672877d23b96911088947a8501fa5ffca5c8c101cfd126099172d75dc69ee8d328816ad648f8b0a6ff21a1efe640ee77ffc907612339afad202cf549be25b98532aa6f7f6d381e1434f22d757a2bb445585f3402d31509a5fd5102d11abac6662e5fc166acd3a015083b2cc94e81e53f2bc00c17d476e9adae70c4653b6004c13dde622bdd3b7568a18cfea56fbe7d530a28f446a3235b92a5cd2bce8275bea1137774e26af61db0fd060bc3c2d9376f22cc50d9c3c0dd3adcb40cc255144a5a037b9de52ae21bccd10351a61b8a45866538f763b104403ef6066051cb9ed455935012504437b74a644e5f825a9ace78a6cbe99f577fed982be76cee257e799b77886df894dc97099261feb3906f9f9920054276141b018d7937188f2f2d97863df879bf117c544957bab220f81d28c4a6e48e632f1db254695bce992863926090d9d3d1b6f55c1a46584630b922477be5217ca9511ea99afea98c42bc3305de216062df3664b770f4df41ea4f867cccfe677120e45e2531b0afef0568a141348d9677b68d12e17f6bf6d7881823e5c62a20c216c455c11349ac82602a4363d536cb99b91850b94d00cc3f38dfe5470b022500939ca9b544ee239c86c5d1efb26965a3073b581cc77455650f494859af685c50b0c5b51b073d3eb42bd3d953f43519a302f5c02eb8297f5c2216090f3947e9bda9f2f22ba9f069fc72196edd4b5f6412aa432d656e71f821a476730cff92010dea4faaf8b5c7633fe9ccab053ce7207dcf99bb9afa1ef69cbc3cca0dd6212f99fa1e618d05128917f7b698e64c6d958c1ff4f66d91ddf452f1a2c90e5a2a88f7b5bcc1b21afcb74f62307f3bb20495ef93f28319da7f4845515d4e4900005fc277bc871470631b1cc2ed4b0ccca3abcb45938f54af5de6ac4fc34bf9a399e4169d3c8e94f9b878c3cc5245ee3d23a244da5b870e46f0337bee3130a8eb80e20720a78c800fd21156d6647609950e06b986debb1476242aba244d78b2f5848488ede74ef17a3009b01b8fdbb5ad02f604c95f4788ac20796cf000c9d8688d61169917cee86b2ea43e781323674e047a73e1b4319ce21753d5d8a3f28e57dfc16796446a65f66d8b15940e7a505698706288ed9e38be90342952d34707d429ff3318c761e3cee40d2a28c96a18e0cdca42dc1170dfc50047dc737e7da6f6e79d203322fbae12f3b84dcacfd22979040a281b27191d5768b8a4fcce0dd7f926c9a9f32acb05ec785b302eabf6c67c5692d2424885a5da12990f8a4595748cc2f4f9a949a17c5f31bab43f5c5b7b15faee5ad5b8d9f4a819a3a281a0a39036f659df634130a937c58ec040d753c6a97f402d3b06d9496beaf4942c83999b45b345b25b8abdafee177c1f8cd3f4c239fe69aba054f3ca6b1782c8175d52521264e90afd635443ab1257b4b87b6e2b54ac0f7b1e4f39f8d1ba4e360be3ee2c7f3a38de64b24df0e0102e30ae66efeea7157ee6365d6339f3e20aed23d4af1429a0f5413648e1408ea66431fe86c190137f452082380440d9f109db6f09d5bcb1053f5169802192bf232e2f59b9819de563774dbfe03581ab6a0aa21b3a1bca694c653d49ffdac7454e284592845bab8dd95ae19dc051f26f1350521a1814ce8af49004e79af986589c28c92f40bca4c83770474ac3f81bb6264b330162d4f8fc7d3ce86cc48a0c591c396e389867c858b77447a868f37d756b4e47b7b936a87ee0c20e849ae54b72aeabf9dbe259455bff60e2bc7a70beb2aa23a7f01198e6d954930288e1f6f470235485618bc059d42e6c77a7ba17c5044f923772aa94c560df411b04bde12065ddd41e4acd119d45ec1934577f96277fb01677260faebd117c3d5062e85e535fa78e70c8727911f1f9519c03e82c2ffb1d4a3df5248603697591e2473185c782e8b3217d8b019790cd032eb0f864405b9032bf1ba109b7f19a62e1ede9d2368ffe12600df9f9145c4646a781273832a525f73dae6b1e7603f5b30e3341d5741a0dca7c49bceba900fab75634b1b6b408d17863ddc4e2be9bfbc57d8dba3a0840a4bf9f7056ecc642f836beb79e74fcc84fcddf48319fda51fae1e155df668336a2b203e4395fa17858d10eedd35ac67e607a9bbd7f70a16e5c6fe3a845864c8cb610c0ef4625181e545e9b9669a326ca6fa473274d633117a3e32cba9d08a30509ac77284fe7f0dfb8bb20a8f3127e5efcaae5ec0f3b83832bdbc26fe34d30c4d1a4e62d3978474a36c8d32761890c62dff592221021dff0f1c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
