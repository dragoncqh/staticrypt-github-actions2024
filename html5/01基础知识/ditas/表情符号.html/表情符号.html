<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82acb04a8abc5ce2dff883b80f462649fb00f99bfee1fb9142db4c892a0a4f362b0823abb43ec9c04160658c08de6f3340603f9a3edc3cbfb10f2ae7cf209b30ff642da7a089aabb9d6806c9fe3cc3c396884fbbb5db9d44d56272610c60fb6f664038ac2787d541c2d67ad0aad2b922b9f2124827f8e883702d96ff48ebd470c77f2ed6515d6235a7b052a6b5a42da32d63f3222f0e79740358111716a1edaa8fe47d5413e0210fe73915d9439c174215aeb071fa6a74b770d395a3babb706171ed7ac3c44f8d524c3ec9bd34354922e2faf3092813dbca2692be9d94d2e1fda64d2309446e70718c7adfa75e9f603250cc3a151bc748e0138281c9877694ff4406939b6f1c0be578505f64f512b4a4c242a5e83d8775761ca10a6e97cf4b450d395d539ec9f019a9b71c24cb6f03ecf03a6b3812dcb890d4cdaf3aebca39c7c4607600f15f044b4b25354a408400404e03c6659671c8e93129a25ff420df400996311f83b6a593fe2975121c9dc254c343b4036db9b633bfc1c1e233bd88af6f2f7b9cba8bdc2629156ce740efa0ecded0d566ae6020ac16cf900881ef22af3c3f5dae0bb6fcea6c58ecf51e6771c99dd6cd521bcf0496a68ad6a515c10bda76ebd0bddfcc1aab671f67c5e08abb8ed50865af589d28809cc1a2844dae355f449cc83349585befa17efc452a395fdeacb9bf68e25c6f17afa77d833dc820733c7dac77369e6612c93eedf744d93440c75f0c23ad4365889f46c865b6f59dfd3073805ee9b1d29267f7352f6605ecc7b71109481f44d4ff55b8ca791febc7b6969cb41818acc8380ada61c4ba60b8098a43b1fabac01cfa9cb58f5804e0ae9d36b548f102e79ccbb0db65770ac0daa26bab38633995b2c62ff63e0008c11f5357eedec3249589d3ec6ba926fd54f52a5c697188c36c196d3a2d1445cbc4e97b97925848a3fd536d082afa30a67d7b2bc1bcd8da26c28cb513d08bfaa9a23dc72af1fa43d646d32e52901034b397c7ea17c6c1f25b56d3b115c8e12d1c0da87d58bdad11e7ebc9554a44ba75cfda5c835cec4b45803812bb6aab23d8c3906cb2a714b9874dde5c015ea246507228f6c29ce17697a054138c9c2f43493fcde213bb22a5c1fd4099ed894ff65b35bd4becf2e27a6e83c8f5b2ab8b84b91d5832d8ec49773cc92778b5f8956b6108278b80df94677bc367b321268916f8620c059a00bca1455c34b1057ac299894fa03628a66c280e5d4854431f35b8602c1c54105546c24a54c3b28078d60add294b2249f16ff599dc8824c5153720ac118520cfe793ccf2712318cb4350cfaba49ddf96291ca387a4d3a1940638dec1a324a5753244b4fcedddaaafdf7390296dc73faa458031d5744505f75cdb8d9cd126d7cedcee8f57b56e05dcf028343af33ce26cda2ffbb4c7dc5d4af437624c93147edbd40b21ce5599af413a30f9a65d3967ff4e4e33a9a42efbe5d7346d25a3eb95a182e9d3a6c36e282c5c64110c72f3edab3bf59827d57a45bbd7db197e31a1578a029f5f70b28841b8e75ffbc4fcac0067a2f64c36a87fbd16eb0d78335e869aee67273cbd534b243a15ab6664cdb3b05d3b1f11e1a1274d6e2ca7f0a02b683a77728d09cdbfccf7a6df231196fc37722dd91e1052cd9465a4835c2f62630e103f82266a31dd5f987a7eb4ca646fda14b34f2d13e61544b979d2edba362e286c959056d4f1920adc60e933f236386d0db9a3bebb190f55fbc0cefa2488565fe0254975de7602e285a740fc99d29fd1ddac962e3d94f1814f96feb2de0e09f566a329e99126ea7e2c89e43f5c464c1a5805e062ac6b86781fbbd18b4132997fee6cf2bde4dc5ef3fc3f86f2f2271157e008340c8915295a3d18641ddade306dc6765ec02be20dcc7ef0a048c8540cb62a5cd9d269e8810a6cdcdfaf01e87d4d45444aada1c36026faeef9af06f0d9433d6070ff3a964e16473b2c788470602e2dccf6eddbb58cc0148ce1ec998c20d034fe1d70fa9000045cda2746ff1aa5e808ac2c84434b1cf3475bf6e7ee48b9b98fbdaefef9ed1e9105a3fb1aba665a69ac64a0b5da1d789855a0962ed4acc6aab89b8e437be6071245690494ba544d56c1d11215228bf03418e9fee6bd237c8e947ae9cc2c1850b88811592a36ff6de49d55353756627f53206174537c1f2e09fa0605620ce1cfc4362770e6a8ca5677d3e558cec46ba7e632c3237f18691277ae4ddd783aa8e3883bf60edd33873c1e82e24a57dac43c62cc5d6e425436722ec086373a135e512dc518d4a501a876c6e126cee85bead848ade64281cf54c4c8bbc123a5f92dac529dbf9408a8934cea7ae9652a3e5d6560550b33aa7467ec0744a337936ffaefd2050dc24bd653080550ac4990558451b2a99e7be36bb01495b50f09ab2775fb90e4cc42d60bf2b1b0544013cbc1de72ad292aa00d8308ca3b5bd2dfde834ee051f31a3e59406004025eb61470d01517b99d2e1af3a49bdacc58d08c9c30fc8a1f118ecaf62be1d7dcc19ca892b2880df0906e9ec2f39016a5faf06a4dd8b84ca01a8625b727413e3a10416d876d5d66905f62f8ee883e9bfb84805d4a72ecbccd3ea90e08935869caf5623868f94d0d63d4494a7e0f4061aef2230f8643dfe6db5de67a197b66eed13724e52652601c00da6aef936546a70f20e0daa5e2f78380e2ac7891fab47b7c3616767eb9d3b5f91ab34e361f192e483982c7796b42921de38cccda859fea7fffdbe996770f321ccc0fa5355e88f1a978c2b81c7c302ecffa6d362c0111d5c27b730a648f3ede8d9745f0287a37feb1fa505a4ca5f2cf47334ece113b335f6379f9f7ad80f72018a08d151fa84135e152aa321171df40b5e08b6a394d117c527c35c460ad1bc48dcab317b3f41f6ba4b472ba8ebc5acc4852b7e7238f0815293d3fa1f5022b83fa2fd89b7d45390952b51bd103110c7bbfb99e561e16c0bca6bc1f62c5928b11786f07e4e472f16a80c0c307f0a514023eb9e1bfa06bdd5d2b111cd8635abd9118d1dc01a28d7c181bdb126aa171963a611ae3b06c0bedb71351b54c84ce3810c2fc37ec1aeea7a760439e6584ce6422c4d1ec6446f8369b4b3b87758f21c825beca3a26e6829810c7ba134912eed90b16ab3baeda7e04a2ba4f734c68a6b28dad23fb48c86c9a678784df5a60aad387ed8f2a8bbebd718ce8705ca7cbddfcfad9d8d0e6e6c6620dc53c4a05463c5d38c493c5aa25c2de1673985ba6835736fc84a1397798d61f17d3d685c361e9d426e55cd41029bcb26f3b8c08828f5bef3174efb8a3b2d4f83b9e47bb234c6a1f6ed4904849cd87c1c72d0947d55f2cad86a24e4680ae9ea4fb35130ffbdf60c61bdf1cc41ddfc32d8a5883c6e2b49b2816092928292ec6281bc561d5bf6003b48b6c01ea8e287f46a7876be955b51cd4a83320368909cce65b7981a1dbb457f60a2a945a5fe3cc8fc85cc59836f2dfd07341b996ffe5202945e31e1c5002be7863db12710495cbfbcefcfb55c18db24dd7450cf99f48efcb8483b43bca23ff443b569e4ce7a041076265caf73dd95aadc6afb953a6ad7747621cf060570494c43e1a09127599009db4096abf77ca09abd84ea7159f57ff7ff0b8cc8649edb31feda161e70989651fe4c71753cbde4b0f08cd9be0a4c36e22adc1a2aa0c040253d4d549b4782f4db29df71f90a7e176090aa6844994e21eee5f294ec194d7b43bbef60dc5f606665d252db81a99b597bf2e41f76e1099353aa83cd89520e4104236161345c9654e13c03a54781cf6a913f629693b2fd18cdd3aa73685252ce2dfd2a343662a3e7d9a05a09d6d3d64b4fd4f57f961b5ba552ec5dfd2064d1796dfaac4ed71b17fcb66fd69191c3de1ed54af0f6b1b7aa3aae4b1b49ce81c2d2f131793b040a582ca67342dcebaa76e01ba934cee664a65e9217efa78ff4593a5abdd4ce4c1a960fb3937b38d171945adf987052bce3eaa1aca4aa38dd001d66287564f4c40151692865b0b21e81cee102cd2ee947fcd0f4de35889f7b39ca238bb07a0e32eb563e410b574e365697d64926e405665ea1faec8c00b80d0b38e0d165b184969b06ca34fdf7d7193d8596b7eadbba3c1b396bc5543a9006536d6cd00a86043e0293ace24c0a7997ddf1f2f0a9ef6996e2312e50cb91c37cee0a5c7e8d7d97612415f4d6ea878c9855a389ed09256330bdf96f8d2f29061c336036c6636dbe00cf63d1ef096fe25194f02a290b2b442a0d609ae5287e21b76352d4f992e40312b8bf8a8d63f7f08f4d4bfa396dafff80d5d3496fce2750a973df2a8e91b17084cfeafbe1b74ccae3969b23f3e29c0ecfb469e55eac9e95eb5694e0f5836cd48c2b6fc0d99ce102952582d28821f4790cabaf27f8b211f4adfa32b01e7e6392d17fbb1d0a05c99a49f4268e973b52f1be87af9bcba17e6bed19a9fde738a26767a31e50185c1522bef72b1329c6532aaf4d15422f721456aedd2487a78fd31f22cd1884509334fe15a12d1983f2799d1cd5d3a59e94b9f3b27a45e5a5db188be944e6feb00cd2c1fa2014d4ea7f4d6e7773fea5fb7054194bdcd3ee0b25f1b8b98ed478d9bba01a1158476c859c5137a1206793fc1a79a062ce8f8dd1665b4dcbfe1e1a34e0ef34f14d170820213b4d128e5a2d2895c9d260cc076da2fb66f7b23f66870cf2a8fbfcea3be670f6cbf6f18c03a9b7106a56864a6003e7129bced9712133dd270ff6780e2db6569bb27e08d528f178a7021de85b2a4731340afee6519b6f331995108249a7514053e7fc0cae4f337af1a39236e86596c16c08aa5682573af81a665e5d9c03d61da85b58019783b47cd53fcb63281f5a5f802c37dc088f565a40c857a0da01649e57e8f30c5273f830ecfe2d46c6dfdfd4190bce28bcfbc58fc1fc7fe3d3e65c54f44e48c4a5c15d2ab3cdb8226f31924905d34243fec04cf12bbce511a6019058cc5ba277376583ddc15105d2f1feb5080cf4b3ec856ab5a47579035528213c0cc2a92828bcdc1bb54501085e4146599ff9343f6f547d937d091ff6e6fe664ab5b05bbd17c8da4c2876ef2bad793a0327acaf1cc37b54916d49e1560cfe77c062101cece8804df5b92c9bda672b772a570122409e0ed3fa01d043ea644aada2a4676d021b4f741a8dfb8bb46e329f12aff55b90e46ec6ae61acfea8b21c8500c9ecdb9189bfd61db9d2f7c4a5488c91698662287f4564fea9dc5d9a2295cc2042e44803fee4602420ef5412e06de4f0c90758ca01d7ea0a440d71d507414bb3ccd767e24827959ff3e493fec8ee13f887a75b3301cfa10b6040b1eb6bac9580339bb5b01fb425bf948540b13d4e9eebbca8c8c0ed7f90bd3160077cb51b0acb0a1f968e0b23c5d1d67b6d059536c152e2abdeaf273db1702cda0b2dc5bbc737f9931c50232da4e372dd04359e6594c6342678a5d7c5e2871f35cf4f6a9655f6fe46d418c6a8ad042d878ba40f7da32dd3cc1e89394519aae64f807f52c01218f94c6b528f70f851e18c248668b37bf1f7f13694db18885a78571549316fc7a993d5e8417fded2882ec3b9ead03cef1609cc405c5cb26ec94cbb529509aa2da791a6846c6fe62a503a31e72ec1bec6db36440f5281f1279859c083331fae0ee694b200a34a887b2959473bb1e6acb84a7e81c5ef263992f7b8dfef37def3dfffa677dc2495dc2120b77c3e7eae218c8182ebd41590d14fb5990d95e2dd0db7bea549b3bcc72ee35b184fb9b552a2be26c04c0ac2630741fa5e1a8e220479b2ae5dae24a09b42524547f414e697c642749afd814232b77f35c39da66ecb7851b0292deaa610b1fe108d8ef3309d5d8c827f9761a34d87857d316f51fcfdb78db638619fe61a60d5c147cb3ea96f73cab81bb64caeccd69164ec9f1aeb6972b28b31850a0a955ce51f4f96ea0f5f2fdd9138e089bdada22ca59c40db76e7e77d8a4d0cc8038cdd53ba26f8ea027aba48666534ec7fe73bcbf2828a9cca9dc74b5c70d61d0e52d3b8b68740344baee22c6b54d05847f46019ebba884eacd192b5d517c0125fe8b275e1f6f1c2fdc2ddc653948fbdd497fbd4ac7f3258b6b9a0431b8d246b1f2a5814c03948218c4c9abd89dcbe528ca069de616cf4ea268dc1f9e1a8a03ed3238ea3bc8a831901937b586175a3e5320a894612f2ca55d2548fb06e6f385d2ee605718b4bf7ce37c592b1393035e1e28fbe1223733d92aa0bf53b230c07087f9aad8cd0c1d76a23b5b196f72345ddb01ae702e1e3e5ae578b243306ad99a9f935f754ccdf6feecda31268fabc34d9abaef13b9f24030103f65a9454e03efc6002da356ccefa57113f492d00bb3d3e8d0ce97ae66ae90c7b0f18f9b9f5fc6ad1d6078262e73efb0455979f948bebdde6db4598f688972745a50e6e49af9073661457573a4aaafa7255841f1a3899356b6b0cc0899ead9be419a62a1b7f824ffddbb0a8fbb5230054d5bee7104e006df9f4c392bd871f5cb7e98828ffa34efa0e606cd665fed7d9eac683ac21c9b01eaf77d0f40bcc38da2219267904003ab046587dc425e4e4ef9795ddf97bfaf739678de26f030db29f25a94b6593b7c49ca8eb2a08e7a49b03802e0d0d894e47e46469df938d0189cabb37df467742a39c466e4b7724cc098d62be7cfdfc7e457158a29561ed7a45c975f9667063b523a1c68c16790a264284d446f914a775c18b268dec9ad1c47ddcec9cd177a9d8164fb7af7cbbaa4be173b06cc8ecf90bbe81dede71d7760e3a552a8c0e3fbfd8254bc4eac5126c4b9cc38cf0b7388ebe977cc673809c2627192e253887b96ca6f7d6de9dec7112d3840c7cb58d92c38a14d34b11eb60dbaeac7c51fb6bc3d02e578c699fcba3a662409aedf63c8bf375d90aa27d4e7558f4fd441781d0524c7ed4a007346323c9fc2fc4b48b937239b3f6e73018c1750cb5393bc74a60efe8e84929d76141e723933f1bc20707da0975825b421eff4dfd76cefa132ae14306dcf221587e2671a2d232af43c01e039c2c220f6128dc4d27ad30e75530102212dd2362bd1412a2c8a22ce4d528ddd6e4b1f36f0847c4930e14d03dabd59548782d100b51446eb09b0bf3bd0a9f36a0fc98dc36de70f37301ce47131142ad59efcb17e63aa66aa1cd566199ee91651f8cfde7eeb530985a6cd780abc7ecb9a4f1743b1af860843fbd5bdc3f7597babd348795689436fedd53b22270e05fb22820afee9f618427812dd316148416ee80d0edb2ab4a7149bd6609048da86bfab0b29b3208fdb9df5fa480119d6f43b96a4cd4f3796181c00a6ccc5678c75e41f13d80c66aaf12bddfb8c506f2686543ba5b94dee27070feef9d077931158484dea1cd51cfb01a9a3d28d46db1aac4c9c8e83facf52ee5898a188354e95f4718148908df9ad4875f8318fae47b71bb0ab5d4a9be74768e1226ec42a1851ea870e274b9070336ec806e956d3fd5cdb9ebcb43830236470a3daa1c7c9b18ef941fecd82af2d5202547b5e1524749d31574c9e23fb908b6c886b37f9f47e9a8fdbdfede30503d929def7b0dff816315892de1632bdf905fe8dd8ae0ec6e68bfbd238cefeb017cf0151e2b5fd4dd36e48b4add85a9242206958a8c5ac0095caca29dabc26c3972ee44379addf9f844fdc73e7d5cd2e5dd7e2ebcba74634ec447c8ca81ce86eef0235f576c27d02100f1c9a651dcd1781971600528fcd0778b3caaf5325f79027433456d9477fc2dcd769785b8e0301fa1e40ee245e13ec25e5464b9f322266615ded02f682b46cda6b4c630c42593ff67dbb7c0d4f58b7f84d65b1ac44008d078ed308944882948dc00ea3b08edf7e656ba378174e58f1be6d419eb6d990737b47299200a3e0f1ce77d23d6d996e8c5fc42adae288035e04587e162de526d25bbc5256acf37d38fbcbca3c7d942f481220b096ec64cf9b88f7281af2feed3cc8c170bb56287a3971f1d52009bf32e90a86f37b199d71667dc3416e1a131b8b0a3d3a79ec39e37cbfc85b29ed6ee9c507cf7f9a0ede4ee8dc2f1249560610a1b29e0d0833e27a1e3fb176d60f27acb0ca17192743866209d66dd7d358bbfe94c55343f1cc7b42d7a497146cfac2a7aeafe616f780e8aa67c5da04b596b65752d83ab9d0e6b24799f6ecb1aa9458ed4a152639b4a24d4d9811005632597eb6566db34de60ce666d164113e824cbb00c0005994e2d04981fad14ffa538d3d734b13b3e3495275c08e8542ffba38ab7d2fe9ea8d82fac324a5f595994c3d91de37dd17c6e0b256b9b9d2e1ab635c3b95fa6aa8895ce8f06cb47a4ecc93547771add7e3f4efe65356dc718188b1c4cc905d779e5fac48a1c95ca635937a99e14990fef45c88a7e881c2c422ec3650a72ca64401ab2505bd985a281102dc28b3faf756363173788a080ea4e11ec2a081c568aa06e6b97424eeaef9169992361c904aec23828062a0107e8100369c90771c70304516ed7fd18ba716de659f3f28c5cc119a1b5d13e48282ff005b42a199e13dbc1af447128754769feea2fb5f26fbd53f377f5ba42158f21aaeec3d527fdf5c8d89caa635d56ee9e11eea56e28ad08b20654e8a349df74b885b205b907ef73f51eb6b442c6301f7e0b690a19a6f612e0164817ed437c0948960e494a67cde558e08e2215f6eba81c9527eed1d7d9a00a61484028ac9c3ea8acde2952db436f90a870ecef77edce9dabf6e01cadd98ee95367613c13f5a62b6ec01ff91dbd8877f14e85d582cb613cc1a90c3ea34b938c48d520caa9da9d313d7c1b7e20425aabc7dba0fffb15680e9e09436a6a1d809bdcfb1fb22528decfa69661f208a2bd5d609d2250ee924efaf4a052aa3277aca74517dc9dcd456912c442618661953caa05c36da8471956fa66f6b595d860db51b1eb614b16f7eb2f5ae7a964fd63f60bd1aaa6989b0f37504711385cffbd6460335152e2cc64b8f1a1884bb68fb96a2e2ba4c28d2b6bdfcaff502ccf09620b42a71c40a3983048c04c326d203424e68f62d0545b3cd605987c07cd910c86ff5e1b543073acc95ea45833ddeb36b9eec4d87f5468cbf8ec1cdc7faf93ea511895c39670178026eb0ccd595ea5fe5497f74039acfead629baca9848295eeecc2215dc9c4b0975b92ba2436bba0f61d6191167643ce00aa74628633eb97670432e9dce80829743f902e8d59863f11228e7cf58aef4fe467dfa9e4b7088d449ad218297457c72fa43b9e1ae4d21303248383717954659449f18cbaca57f1f06c75aa52d1472999202ffaa76d55c2bc4df7a8be17c8e6575caa220951d4011ef5e96ed64c1fce0c7a76cbbe0812102bb0a06b316a173bead9684e78a9f00cb01ef4e37e7e2e6a7c1efeec697743097ceabc920f2258a9901a041f87a5fa6d20f41dafe45ba4596a9d2d0a1114969481aeeb1a0d1070adb094802552a68ba206b4dc0114557b4ff88f83a1d7c1f0c2ee28fd8fa9a20f5bd7987c95b01c9a76a03428630dc1792ff064bfd7bdc1bac3d1f3460d0717a361b243cd9e705cab98feba5eddd30cddcef6787a8503f25436f05b3e83fb7720870f01f0a83b4fd243a0b20a91a7ddbbe729b9cfd5d5fe8c76194bf79068ad43e6f87209b01512f6121cb093ea55b88ecb69fb80d247e574b1e0da19cab84de19c58c6dfbecbc6af95a58ce882dfe340d3587dbc148a135540b46db287f249477e9e9e2264bb5ae1a68fe37e065517f626f342a8f381b07945bed26e962f42f1d130097e28a030202fdd989a3cc207b15c76d02592199bbf8cfdc3ea97d83fc4300f8f2519acbf7e69d12ff74e8c222a1b965ba68da66bbd8806fef014c98e6d51d6cf653f8fa042cd8bf6dad9887e71976f79fe14293eb1f5c49886736cf794aa232d0075e9240f80672b79f8d9d209c0b7d821c843eb86ffa19700ca53c982c2c88e61179ea5cd69dc5af360b6fda8acc8bdab7fe72c57656e07bb5819afcc45b2956e9760a667dbbf84a84446cd7a4df3848da5bfc766586bb9865f11b8e999f55cc79e0fa16b2a97d77df08e1edf990a978101565085eb08577f14d9c222d0a9c7bb1c285d21fe67c6f9daa69169e9e3d7451faf366c4eb54b5334d3381acd9759a93269fbd8e1b4ce45979eba0f699fde77e4a2d9e5333c08d0788fefa5aa9c7754a01e7b281ca82c8fa6499d48632df63364a8ef3d054341d220f4d521ec4553108b06fe5a58ef7f3e447911ca8f5a5fbfaa59586fb2a18e0d4ad17f4fea747371e620bf8d4cf1583a75c0645f79ed46076edc6eba9ae47bbac714be9b72e735ad0aa33e80e28b5bd9abfb32cca1ae34e73dbd61f0d3d33ca51720f6433c299a9e1e4d8abe1fe551218608d6f0af83fc231987d449956c0369e584b6a28788d34f55ef0c87e33e7a10a04f1af4d0fcb23d7c2eb5e91cce442c860ca075721f1f7d5c60ae1a72a3a612deb3bf79a199e5f3ee3fef215f9e1c45ab5bde18f75506ad620004f7be2c19e8c3041f5a618ffa63b1c558c290f8182f33be0c1df01dc3dc7f146f417067a5303ae0b503316bd9a3fc215591e4679a3b37e6121ba8497f4e6dd01b41ae37b3b910b174cc006ada9366fcf2038cca81cfe7db59fda89aa073b4399d50e9029bf793a84f63111847416e7c425ff6f6c8c2a566af33a87f94a30692cf6640a8e4b3ce70d85bc576254471567b1e03a4e412b6d78ace741742cb0dff3660497cb9f5bdb09620075e4cb287e4b2d1ff96d31c753d7b141a83261cfa7206b561a3729ab5e2084d6126c9133a403754c1d4047e27452d679512e000bc40e83f69d4a778da4540b22daff0dc9ac1688c11570125e5e3b1b9532b2703226cd36da32d449df529fe791f029a0b760f0c49576febc01c5db79f2f577418c92e890d878608ea6de188559d2441b10fcf937e25a692233039657c244c153d8f74ab46748a292864ecf387277582f4f5fba23ccfdf0a9aebb6bb383d7996b98e8393f7c844d1de54df8c255c93ef1b77901d9148c437bf3800e6a0e368d473142a0d4b083b945eac882d6354577c36cb942c05a8a0ada756ece1631c207af97c82641ad51e5517c23474825c611832a1a56afe0f7f090db4016939041bf3066b46c8093d3eb9dd1085114ec336360002d9dcc6724bd4d3a31898921b14a4d41a612c8e5b44ae6fa6b716062539fea2121ed97d43f42cd74e45238c915a2b738ee3af9cf9f3f1c94beaeaf6186d5a99947719ec4d4ab01cad5da7ade573f738580dce6366382bece9794e37c53fd5a24979a9351341d7e8c3dcc9913181a616de5e5a31d1fee7847f4927e33bdf82284fa5995674de6f77ec051cd00e992ad851e1b7551c27a8d4aee1512b71d22738491d5c4979c749f4cb3038dad904bcddd380db897f4a60ed87d1494dc13260b485395a1442adbbf209d142e4f28016aa67a24c6990ec97a7ada7272bfde8405fe9bf2fe043aaa98d227b73d7375800bb9b0fcfce98ae58c7f94007d594e5c7c643a1238502854f6a589512e6ba0368749d6af3a409dc0c64d8698256788be3b3de864ecd9e4b711802f6849cfefcb03f8070acb7ad5100745dbd724c8d08c4ba360363e8125dbc1f2600cc38beb9c4fb04fb3cf8c68827839197577f10283ba3fd0eefa8c975e6dd54ab9d4ce1149e76cb22c3bf6675eb9288615283e30b7b0ac282deb036c712629beeaa0626ad12c528eb90600268f3563ffc09f066bd0b094f440fae83e61ce5b817b79a047391b11cff4972ea788b2eb3097b06b59e7911990b4774483fdaec047a0b34f204f98956ae5a87a71124df0654c1d761788a9eacf7f168222c4794c5c344829c7cafbe3f85e5fc11dd69bea396047fef1ce308d2845607c78e34ae849742935c26e8b7b2e74e5f54c8da3912c3c23905e55814622f72d3fb35d8f323ac9621294d4468f3079e0d200997e75e1c43c24c8f16073d4197e70046cabb6f5b54447617f9195966d5f7534f90759de30743425fc063045940b2da69e82860391c98c3f54f390299e13561703506f58b7c6cdd3190a20319cb41a03fc52dbf31a361de8647bbd8e22d299bdabe8d13d8bebe18d4a189da877ea21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
