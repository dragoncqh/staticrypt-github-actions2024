<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a69f1ab0268e8fa67de74a1ff2cb6ed3e40c71f8c02590a8a9fcf137073a194e184b829311fe496c7c96039c6377a955bb9388fd454f2298da1b2cd3a162d6c21f6799f98fdf02fdecb9e4f63f40d2f9f3f570a6927d610ea29646687f8b9c6404e94217dcbd39dc8909797e0fb508eda41558fec24c53567d09f6ebe22f8af9428c95d672030b1fb0773039ec5f44e9fb0d1a99cc2580d8737aa42b7333c99de9da5597807442b1f6db11a03ae8b6ab77b348389212347cea8f5f2ed67f829f5b83efc2fd2609378e405a3557c699361fd122b04d89d6e3bc280f4aecee0cfa19bc95f5b3c9b99e276dc0477cd35f5e7ad70e3c0c502fa3054c2ea721f567cad7dc55a48e0737bb6287545851b38c1c98183d42cf3d76059002e7413d97ac27e7f626cae282d459d49ba7556ce327f709a51eb54272959f19952bb2b725a182dfc292b35b84afe649ce81569b8c2e3f54ae42f51db5b54c324ea771cb06e0a3123ac6d7d6cb1c6140a1f35ad2b80fb9d8149a83034829537dbc0fdb879a0604885ba123562ac81042be363cde2b89db644e9e308abe0ede3c0cd59e918f393b2b352c1f95ee7efdb47e18069af1ef817b7a4293f6a7f79f6b95c89b0db2bb57d47d4f2db1f1ac7dead3e92a56efbdc141b175a15a84f6abf29064fb794a65b3f0ade1720e3cd0f7cdebab4ddf23cde7fe346e0fa09c3e76b54543bb99861d07027e0a43e77cf26a94af153c762fe51a6fcec13e35ea197c14b24f6dbac1a088c0e99c7baec9a8faafba8de1126ebd3d1b63bd60250da8a80aee69c55d193a02b022defb78396a4d26bcea285549425884648037f0c7600ee31b67c2c89467981f18917ed8d067c64c2c26f2ab25c7588c6d7286465ddba347a8aa902c6f86267637942341d78614bb596f9f1d85c3bd2715462d227a43c9554458dcdf65d8c24852712fdce6043ebba7dcda69cd7a96eafd291bc986db1c8530121dbb8a8354f0976f4fbea4fc77546d47c458d197ee49e0fed1a45fdcf331b501bdc6e1e3ad9a6e87765f2e7f4d6461b6ceceeab9c97f0fd1f4db5368131e9d8311aa3579cd0010477e57f1782a10a74dc9e5a2bb08ccca1997e11cc337e36198c903b5ad9ecd48267ede9bfab3e3afda0fef8bb953669581a54e0403b05a556b3cbc2ba1df85307bb2cc85dcfde3584e56f04afa8b7248f8fb2ba2a284ec4a4a00b5e1f02f9ff863c80542208446d59c17ced1206f03f76f5c0191ab98b41a12ee372d3ebce03245eead32ec31c036ea5d8d35a58122ec9036833dc7e0770da323e572e94e197c1e0de7d96fdb4f21cb0d8eb064876469fe22a6042483c545fab82e7e0e003d5bd2a7a541dd6a13048121aa4e19a948dcbb9864c29af1f269abe27be674b325e75c25ea1b2f7ca5dae37ab4227bcc7b84352f5e81983acdbbd5394bb50b88618279b2a36a425ff3315d4d4f48f4e8656f62a0a712342590e4a714b1c32aaf0bd9a63008c77916df576b19a1d3d46775804bf0bdfa1865c64e6df6c5bae3da17639d435fa2aeda06e13fa89ca97fa2fa0f50ce0b8af10f348b8f6c9da8933a649e54333a29183aa33feb3bf0ac42345cd0bc46de80ef8ceb89f56edb5ffaa9bbf219905961d06402353b3274bbef53463fee4b774b1a5a76409b514cbd1f19fd8949e2ebdfddc391c5f66317498460f61cb3bf0e41672bfe954872dd837dff4e639ed65238844637c0d6ec42a1955f32da2bb213dfea0af90f9bb24f1e6699f0ebca1fe0958efd03204b7a2578012598263a4c88af674ca5d3a6be45ca7a432791f608a721f95c8b645684aa45b73ed35c43284b31556b92a8344c40d8eed5b86d75df53dc45bab13a6fbe5a894ae997edbabb8cd2e4cbb64e0b78657c349d9025d335d285e0ea6ba932081b9ce00ff3e60392585c63c96b0d0c4d35ee68e53df3f44355c117f6d0ee6dab31696ff39986ef52f4f271f676e04be93338a5eea9a9d31235802ef35cb85ffc3fcc69feec2d5038661afad04183bd4741c21da4f2dcbc45c8bbd0115673dcceaad46100fc6981ec39df481075790a440b5420921993a384e75b75862476695fdb9d86e1bbdab099b9c18c86b96af5eb51e19efeb2b7869bdeb1911190c012e5fee3de76b1281d0099e41375fe75b4a8d0fcadc0bbcbd42dca294c95166302239b44f72184aa0963c797e5637b038e01eb1aa36c50b19972e6edebe0d117f13898a6f410d23ae0950be2f857d81653f07b90466377da367dc4b2c3ba6f63acbb624020a06b48dedfbd7dff8cfcc992c5dac982652551c4b4dc1fa40792fdf19762958c0907447ec7a440a8cd8a5f3a2d2f5c2c400df62fef93c4a9a9265eae3c0924578879236f9e10ebf31a08af355f7c2e1f5c45db8765f084a8eade87080a3f78380facd74abdc9ad170fc30fb98167cc7ab8148525759ad0fbbb977d872ff21aa885d9ce67b316607eb65346f23431a8802e35959887c6f71fd98b8de7e4caccdf61dd42d1aab447e2359b47b99a9659f6b8486645d250f5ec68053b3f69c6c34afbe3e3b39dec1c2936af9818670523f843e2bb89703e60ae7eb088d575e2ec4d1d7e2a14e251babb6e08485dd97ee849d9e3bea64e5cb194aebab9beb0f6a6998a31bd76dd2dcb2e7472ddefe94275f03ccf911c854d0be4bc4e83b03fef1c0b65e1000c3ece99829083ac262cdba95a010ae49584adaac816f3c1eb582a9c32c61b266bfbda69d303cc4606af2390bb174133281bda0b46393faf4b04bfd2ec36bf9b722d6607106c072d0747aba8cc2679e4bc70a93b26152e894a0d4f986fe589d310d8059f8c0cae3380e9ca0bd507a5ad41ce3c5b1a4958b35394e4fe206083ec4fc0f7ce2636853b5276f5fd883afb60fcea73820b351a509abbba801822386dadd6e697563466da06f64cfaf246d0ee98c1e1846af928566296b7a5385d7c7e55a7922fec3281bbac33348fe501ebfb2451c8c5b8ad3738e8eb1520322bc47fd4f33f930ecf57c434b83c50bc6fd94eacdf39f65569dd2dc7a74d4c55d7c4c6905fb387079d576b688c5f1f3c081609fe695a894041a3c8128c91af388c9b05c943335c6eeb3e5dcfff0f38232325095ac1ed6ecfae938ba133f88dcf640fea0594735cae14ffc6b0308355b1c05a01bbfca39f6f244bfeefcecbe0e4c5729e7c5cfcaad0f1da53a39c364ccf02eacc0bf857052bde1657a23f56416ddea16673703b098ffe0ca13c8dbbe2d5572cbdb8a358fffc3e44b109443f57eca2019e1c65436deb9b53033ab31eebdaa570e8ac945f6082e2e321a507a48b3de190296ab833561abfe470de6318bd6a17fa7a66b461b7e712804597c7c5b7715509174edb82c88ba055eb29223074ee12866526ae04b580eb684ccf410edf7acbb6a80f34502685a5898d82d89857c96bc386d406a50b7a04723dd18801e764a6c07ce272a695ee6b4ae7e20a02220838202abc4d93f1f34760836f2fed25c525171e5b656b5a624cce69ef3ab2e82fd8c1382adc6b074cad0f746e2aa98795fc8e14b06d7a7f067bd735e8725c24c64986d40b91c69a66e70442cbcd127d17648018e3a03f784733b67981d4a0b1f9f42b2a619410691815d74c6460676f74df12c7830e1126978ceebfaed66714c2dbe8258344bc7cf78dcb7ba93def5f6f477702ed3cb0d48ae8dd020e3478b88b44024664a8fad31db5090371f5c147e426a0a820571c2e5f61a23ed3d4db41ba5904165343df0ef9318293cd033d71747a95de1c4fccee477bf922e74e1df09b17fb1d0a1bae305c6f90c0de1fb713aec593d4569b87ea12a221c0f7630dd808ee4ff7fd5310674c7e9bd08733789df988c65da86d70ce3256e0b0645fbe378dc13f1d162965744e4ab35eb7e1769f2c03d5efd1750088643534db8ff5a9ce18bd8ab7a8c0f94802fbbc13190361318393115e413d3a65071feb94c376d76b146c9c781fe0e2d45df99a8762a3ac4a571ba86f2812331756e4c8481e5fe0ed45be4c5e181ca03c2d4582413bb9a8dc49dc5aef2c5e48b78161ead008734d2c92a9e02b8fbc7601b670351aa5f74268913302cf6410b43f10f4e87048a1db45723701ab20314ab5b5ea9582d13928cc950245e782fdd4dd28356cebe98d4ac6b1254aadf303c1c9afebbba42efa1cdf502aaefc5d8b36e6baf07e08ff6d8a7773af12ca77ca3a8bebe9c02bf538f9e11dc204f05779b31717a8ca3164aaf651d2452ebdfffca501272b88d8423d8b69013423d60d72fa9c335f88fd53124646a80d44e1bbad04db38e08a49f2d5bf2dcd348ad1a253fa30f5c79eab987005eba771426cf863018441bde72c5a6db2021e36f0ba995a6e21d7418d1ed1c35174ca3832cd84bda3ee02cbac4be06cf3b0d72aa3c480f5ac296e9daf87bd3164e47a8863938fddb5b7b7abf978c7013ce1611fc1c348e0adc46386a80d7ce6d6db9f4b02c00b7d66cf689fd9d6a4c41072a88dc3554138519ad7a4d7c2d552add38728cda6e031447c92b41d2fbe85b2391f800717a3fdbbeaaf5921cd0be5f9edac8dd1d22837f7a200a7721a437960deb754ee45ed1523fc50685d3b8e575d4602b4f06fb74fb3ea65cf8f9d5732fc5865363c20aae5143b6430d63956217756d9a31e643a1389a080402e1ab805f4887e5866eee81b888593e444ff78de6597c6ba84f07953208bfc6a3f53eba88b13a77817dc8498d67ef43cd30479218d73095a315710b99f03226b849e3ee7bdf04117c62dbe1200942c1a57094144e86f8bee8d9165a82c53cb6060f83aa10f376672d3ccf0e03290ef32ff59b4300bed3961e5f98afb2da8a64394591a155d9b91d56e0e05917203ae44f4abf1bc3457aaed2944c5b6af3a346efdc5ba17043cd3fc495f7532ceff2861db70294b02f2e6779eb4544211dbee29273a887f49cd7a766d8e314d9d75f5229655663ad1ffb1288383565c26e46dacaee658587dd8a90e31fe6cecf43f80390740818d4f2028744abf6413004cb7a7af9eb2ef214d73e12ea39c6bbb92e4a3db6dca1c41fe4cdfa3f64dc6a97ba17639a8e1ac2046406224625c5ffdf5d3f76f05384428dcc7ba91170641af2a8dbe0e79a5ac9789a46bca4e8a826aafda5b2c781a7e208997e67a0d3301ed47f01ae73e57494f59b73397d9138a5936740be768950fd50ecea07117e834ddcc1a8fefe32b45de3cb26e909d7ecd9d00baecd32a852a0b859eaccf8de66c212f7a303b011ea16c47ae3dbbd9f9f510cce2d3892ace082ef4505634792320d5b9882e4edd9fa9f74d249d10a65cd6aec44d29e6d1c8ffb29e243850582b0c1a2e8ff8fe48adfebcb6c33e513214d0b74ea423a8a62210e822fe847719c19201bb833d0674ca1057f5e50a8e965e9a90cc544acb45a259c5e96cfd34e8172294bce2685c5d5fda91b805a5df536319186be67b5bc1f5fb18f0b03fbe513fc06a0610dd04cdebff8859edc8ee916b6e036e0088f1ef32a1ae0aea97ea29ba0a5bfbe0982c3724255feb91a1952714c4fe7df98ee9e944dd93e136eb280d4cf6f3dd8cd5a8816837e18b557dabf4f6ca3767010880d17dfd536cd0cea741e874c8f5fd12250ac71477e8a423f9e0c05a6781ab6658f7b4986ae5e7ab3b1a97b1d73fe93aa7e82fa97017a4639d32d4e4e6c09646e187e999b193c870fcaa3e3fd78abd845429d1f3564a473ba5272b87a36c30a36fb839b4410fe02d1971cca70a63f389d45445a92e32ddedf628b17d84b37fa720f2fcdba553fee5aa461dab0736da4c5972b98701880e79fcc3c8b6ec288e7b022a202c63e2be2d4dcceb11a791f5c7b9cfbaeb50df1c83aaabe4fdbc7b782d2609d27f086d4cda64fb01b852acf022812963300b237964ad8048a73c9a2dfd8f68f2e90b2ee78372c66d9f604e69afe37d53a902e2558e0227237d426c1ba48f072f44f554999cbc7113f585021180b74c73a2a05939368837f10c444b980c2aa1808bf4daf7da9e37909c22e534e361b97b9bddb4f413c6741b6ff9f2d56d73f8871ba332a2bd9014c3d008ea434746ae5335a9b8c4328182a097a3fe14626d5f7aa707c2f960cd69fe32178a6df93db4d369e416541ab8b0791787ba3c072f683e135c879f30468a3e7e05fdc1d45cfe0509abc0b90fbf9bd05313e445603d6850a42da73c376c7a6e9ca1dcc21896d33581a6da6c1a8d3287ffcd0deda51449a29d0a10293a292790875c5efc615b105ae7034969d9f1df7e7bc6d1449ab4fe65af8c608675e54ae2786ad20734730c65de72618009ca64e48e29dd47d09a83752cafd8a97edd0a112a27e8062db7bd2e4cb5f5685b5a31a4489dc8561a751f04d121ddc200541263ee2fbbd6407f6578575e979a9b2e38bb5362941939c6fc9d68e95afdc3629b419f04e735027111923d8169d1571a03e52e5a093a04677749bd1826b0264e21fee834b87b2057f234dd2e1121aa2f3ca0011ca1cbb500b552b44207be237fda0352acea0b7287af996b48042146d4ca62a92123a223585c6bbde28ced8c649fdda74f6206d1e548dd4e8ea28eff887ac8c7d97c1d74f2d734926af9dc6dca2a911b58aa9f0228775f10efb372e6ef5f9cb72cb301f12e9e34b62f873499c816a3b3722d958560aede141b960bb135be3ca48132fa1a9d4330fcc32682e12ad1849387d11989db9ed431169518f5e8c675c6e68099b959b012d03d104783ab2fe9926cb6efff84427dd027c0fff87b480f563570878570282da08064ee31e06b897943546940e77d7d394939e88242f835251f066ea398f951c1dd559f56552d1da017a197e39def96fcec155c5be490a93de657656f7d1d4eb5bd269bb433f62475eb94d8f4fa8be5535145d7b747f17f5e96d386fe21168bbcbbc6664bf2304d3191cce2e990c8f66b9cacc916224635ae684d03fac2278a8c4470abeb3d09a8de5c475e62d89f3073a89ceb2986f96c532109d2bc56d8f86a5812d4bd05ee6b7a4f5dc5027396a150752d0220d32e5c3c130a4558327ff4e0536bdd4a250dc47a157223f1aa98b2c43724db948720a6fed1282cf1ea44f714c08b70f75243b2398ffb07c6815c0ff528b10791e549c6818f74ba761f97a21ceda63517062755bee83df33956e7efaee974c807b1c90c451a9ec7687afe6e3674759ec532b459d5bd0b61bf298938536deb3ced9d5588115e63508d8aac9b38ee4a0702f0bb83f6130a912b18738272831ec10ee01b64308e0662b8d7a0a755400ba2674096c5f8492c55034c481192e7a55c011f6cde6ca1e157b2a3b4f5ec825ec3bb1f98dc6bb8a57ffd8f68f9da5f9aa417af0ea2fcebd8f8cafa5caf9a55110ffc3d777e686f1ee4f2bcc8a01602ac70be06a2f4c7abb47195682e1f5492f4af3abe28a41c73c4075300c591911404694101666a6f250fdca692353abf137a86c5086b4c85539f80c1544246406df9647b97fef2aa5054c241aaece860ba071117d5f9a020f8c94f9305c91ca68bdd1b79ca068fc31a534fae48941cc2a9bd6c74cde0d626f6790a2390e99829e20c3fd9e3e2984007ec45d9050e243d2175baa6d3fbf318a6a5dbc46ed8606ed61c531352327287dbc205a3ba06b094342ac55e24bb6afb97a4fafe7fbf68bc60b69441158d8d9cf79a51a9c6f57fdb063b287db2bcffcd7d11f07db08c34a1000177e10e5590d1f26d136965d44dc939798c3026e63e30815cd72b57c3d19e5bb2f717a8445365eca1ccef881a9fd5006d16932115faf756e7018bccf4db8b6dadf064cf4411d74a9c10b1fa08856bce7b099507c94fcdd676d94602c04a07681e2b191941a143c610a3c997409c61ca00951a043e20cff77ae0c940cbf6df30e75f4e11d0181077b726c950bfc7d920af8e1541f50d063867a703cca9d68712cb8c4674367ebf75826bc17e58e978c4e8dc3833bbadb705b76162964065f4faae105d65a7505091166b17f77f3e3cebffc38e03ddcd71f523a90bc1a9deea8fdef1ca51ae805802fc7e29299fed089edbe0aa737c9387f929baa9fe5223d61a6eaa3bdc348a115bbad8b170fbc950db4187cf03deec6cd25b03e62d89d3cb14ee96dea715badf2f344f88be305b41493d531e51e9cb0b811a4646548f9ec157699370b1ad4bb95d24fc20a87accb383af4450672aa9b26f5e22c306f03dbc620c655e53d2cf379198801b78896b2994c0459b4b38396bff325321bf02676234eaf3cf778eac14cece1f32657a0f27cdf01d719ce026159f11b4fe971b04f1ad02ee66da3eaf7d5b294d03d3134ade4cc298f40d0b29106d04c5f09c135be081703d0be8a94b2c8809af5808958f4d5e7b8bd5e1f7a6357fbdd9779330a224e76caa763259bacfef19a79e79993af150a32be2b8d49ca3740bf1be88e88c1660caf7238ba8f1b266a121903404129cbd7fedc368f982d6a0d5125bfa865cc3152d66ad86a16e886797a16203cabf8051d75204d01685e798a2597821720c1906bde830e5ad47d284f4ed3dbbf612c503d71a1b714bbae1a6c37b4eedd3a5a99667c40b3ae67af7ec3d3fe03b52c7ff5c4a2904a517480a8703a57df51d15afc0913c3dd311a60e4877331552476046d10547b3fa4f45ab43e56ffa10035ca27669c6c9224018edf2dd8223d40c616e245f5bbde6013cd751f83c664555187b3e9913f98b148415388c526021320fa76a7b6debb8e3a481a92ead392b97b610aed4119669499be488b447417821f8e459bd6e2080356cc042a29c976bf56e0946e4b71465c937f41b60a78cf156bf54e83b0845af32b86731933f153eb096173dd26a9f7d1b59de461186770bcbb396def660ad6896e912f42cd152688d9b173b7868a3688618f9a22e28cda56f921058ba20f945b18447f389dbcdaeba2c7e795e4598dae11807aa94849f0c1f934124b8060804110136d17b76d363fc91795ceb5d9395f15a4f9be134ec334a6c3d6ed8dc053936064e4d27bde709d2064b46d190da392af6073ec5dfec9e52fbd114fe719ccad110531f6353ec97943b29973ab460daf25241d0fb53f5c202e7bd1cb47e5497ea0ebaa6641a39a05a1871fbda7d8a0f841cd4e761de195ba29156a8089416cd75f515f2b08d71677e3e926890ff5c6b775234eca7415df35eba89a5b31e7a7bed52e4bd36e7ad772c5060e9b09389fc5a275e89d14556984c6851f2694604882b7d5adc286ce41530a53b66c524ce38da2d38cd70ee30442ea190ce8da4a67aa12644bb6ca0854b52be127ae0eac2ca5dcd875aceef258c80dde6da0bb90edd3b42f64a35f932c764f1198a7dec7d92044c88146f68b2668e521b30d60e269bd46c2498b8e8bda721a0cd6e30cd8b502343aea3bb588963009dbcd29a790527a860c9ed7123e5dc3c6a08e92150b910add5e3bb0a2c2f8961d3609d720fdde2c9388c733f9af301dad7862b0e17c231175140989acd641f1d2c84f9505877372e77a25f83898bf26eff811d3720fc93e39f83d267a3c981cf1dd07d795bfd6efc33127c1f70f58a640b8c3f67270cfa8554ae60d416cd002b5d631c14a22fff0cb4e4604a002b11c1f431a9ec45dbaf6890c6bfd6066c1dfe67659e9a7b93868d8e43b5421e8724e4016b9e94ce8d84fb93f08a5de860524b49a47883e8c90dba5f5eeb877fe2a09873d14d6f6a92127e98eba6d90f20ab7daee88c00a363b05faba5aa60f871c63cc741427520c722a9451e57d75f282c04320da55ce5ae0ff1bc67e7bb22d410d7095ab2259fc69a9ede35e842eee884ad81d8a1cf0a49a35d2b29ce52db6bf4abe5f73406caeba86d8426737f89fc2c224ee3d0d93550a6db7e1d6abff60a0c22e781794b05340c875ee1b796dcd39f6d5d32e521515f9f2de5eba4076523feb594a16a37f438d155e7a72cf1754427d5a4cac0caa8079e91aac59a2ffeea82005993678474fc56e8d0f0acd3410e59c44a157cb8adf5f7c8ad76a31e6b35ba9515ef97a7015fffd0e3b1b00ffdeac2f55d74c86e10f242bbc8c83b62f0d2f43046b0c63413b555a429932b3e8954c3500f2e7a15f57423a7492f890b05b2a7a7da9f202b6ced1ba5c3d5473feb63db6f8a6ec23a82d3c35f6fcce8ad15e14ba7c8052405aab737d9393e98ccb5f6ae6dc7e16c1e44b8961478c680ae5fd45b55732b9cb6ce84a18f07cfd7cdaaa7c512b4d8470dfab315103f68a98598ac9b477962d21d13607aa6a68bc45079ba09dac36b2957bff40aef9cb247df84d3e773b6f37bff165fda40183724627a63a221f5ea33e5336ba536b8e753ef3446b7001f51a93dd059a72ff13c6799f78b2dc4177efe16573cdc6d243fe26b611377e4e22e73f627b262590eb91df2cec11326fd2dd10c56ad97eaf984ae6236ab225acd732248e6c84d54809e5ae335ada86f04276a95b1d63f9968296ea3fb57a09e7457b378fd890dd6076a219f420b8be53a90fe9b63ef9632a8cfe007a205c496fcc3fb67f4af9f4ccb938b9117db1904bc5ad4d93206899bc79db2d8d10d77d18fe97adc2d1c0fb03d8dea6b9b3315e06d6025783c7667647b111d063f26051d6d38616f2821a5f0a98e06bd9287541b41ea762f72f724da732152f0072ef0bb7d1b4bb26978a10840845a1bd9592401189d02d71fce21dfc26426db7d3bf4a31520e9a94e798a1256979c59dea02547b96bc2ae95d6d3da11e542a74db7a02a80e812b4265902e2453f02bd15e2187153bbc3f0ba460d613c93e59f826523e9a091bc57502a83ee2539ea78b4b5e4da57780cf9b63490baaed448a8a173f8bb1d4d43d4217d41c3cf729c2e25a4fd74ac5ec3e64d95e041473c9f72b1b3260ec2f3350dcba18957770abf091881d046124a917d2f5bb1b99a952c203ed258a1f9f5767843fcbe1ff5cf27a8b8c67069f9174c3287112dc25233a6019003b8ce41e326507a4e2fb579c563966b29454655e1c41fa1186ade0a759ffb9c2f93fec594363ccc7fa7a5d7d320dc9154912102e264c97a02a054766d5ccca0841f1e4ba525c45d941213b1f5e9240956caa97aab5fc1967efd3ed3a137167c6c467932aadbfe25359f9a17bff53d5baf7eaedfd60108f26c452363436f60c73017c2a7e4313e7d8c7cbb1a6e740f6c5e729d1a42595d7c92738b2cb943d875728f265021f967de3da4675ae5973fbfd31b17d01e0a3474294a670dc0b3d5df1835727dcdb3ac11f1bc1c3b8970f778143dfb2fc5b2192028abd3b5e287ebb664bfb21ebc5184a0498e5ec89ddcf22c1f7ba100a84642a1fda50af0aee58e8641220f1a3f889b7b69190fe3391655add5e2d443a8616a9cf3b39e571fdaaa8d437b8f0c2f63a051e1a38954b399fed998b42ff4a9d3ca3649daa8d3e82757a05f4fbc949096e5777516fee7cf471e7272cad3ee971ca6295a80739c9c4cf8aebf66ff67de154a36171518f17e4ef37b57688c2d2f83bf6f5f4a143622fa0ca949f104658ab15ede50f0ed9879d722abd63f58e58f8cd0d060cdffcdfecb3e8c4bd4ce08b15bb8d72823dc93f15923aaaf5ac1c5fe44eced3ee4decf07f488d1a26637ebee35a992c661f8c06958d60d49cd3710c6ee1cc865c5cf1208a7bc2473b7a7daa36076899334b81d35e11de7999831b866bba07315f28a2c4ace3421bbd126ec3ef278c9970b9ba31824d65701dba783496bf559553f5f4262f6962581838fa1ca826a1a20cf452ee5cdaae637b91bb8da5e4ed48712b6cc8a85053a885c022af3dc27568ded2e8f5739529161afb839a751f58b44a1d099ef6580bb692d1d75c1507b5e706e769a0b920be8c1e90b36c6a7a0cc85559b29c6856317333a683af5889a97e51c73295212f8563abf058e973cb3ef3bf006721b414e945ce91137e2ed96d6a720c22e2f272220343c6dec6ef388d6bd0b6c5f698a1df4b8b592ff1550cfc7b9501b23ff379ca7fe697d27432df5fbc7394344836ab30c3539db59079f1360bd2815f5f43efe77ecda16ca097afadcce0e758372fd23ef9161d8f7fe66916883238951c2e8ef77457c44499fabf3629c64387cce74677848d17986888d1551a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
