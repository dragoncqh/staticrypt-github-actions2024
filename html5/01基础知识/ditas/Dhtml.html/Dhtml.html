<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"740ef3510b2ac3dbb42be73089fda082510c23f9062ed3800ef5d10d55dbf21e85a47519cf41f0dfa94f28874ce30049132e74ce7e3bbf4d86143224736e207e920dfddd3c0c5c3828d62f96ff4c8468cde557da04bbf9214e19a181bb97af010c4f6e284fedbc8074e6249e3b7d24a361a34494b982dc5dec216b3e7ddfd500bbe4553f355f97e1098a681280c59ac49376545013bba1c3f896addd0d17a25b19d8742dbac430a9d0ec125b3ded30e385b6c9077c3b9c335a3199223fa66f799100e27884521f37f59745b5d7e8ab6d6b9850e811d50e176d6e9f7bcd5b5bb08ce1f2814548efad7b895e504f1121b717b079bd9d1254bd9571fa90727b54c9ed1be36e764e9fb6c51311fe9e3d473e43a25a72049f17091d15738f40210578e1bc874035ddc4c9f169b55050acfeb7a6ff9bca5cd6fa5e60d142e34da9e47fae484456a3e084457de90284d245afec888720fa262dcf30cf0f0f862366837de9d2d34628ffd0d7638e1f15e2e3a37c3d2c8e7701d2cdd6337015e830b7e117f8dc6c1450f2a43ca82457a46ce555f9c5108575a82584aa3e4878f52501bb2e8da0277931d17641f8b8cebac95d7aebda0cb09d55e13c7e6f4601c51a34f1bdfea3a1bfa7b0d21748c6b8b02d72f72ec47d3c70fbcb97304479116c9374358f639a87c0f6591e60dc10123fafe626b2cb8066abd8eb95d826cddfaeb5f2fa089b14997c48024d76cd92f87535070576e51f06e3302f004236865b8ab80abd9f2ab5a97e3b51a70943157f0ae1ab2de1cf83147ab91ee9ad4d21f9862a50daea303a460ebf65a7ab2161a7cb7fcdd607350df6a3bb9cd8ca32921c9411a9e34139b3d55295b9da13833eb8e55fa06c5ce314b8d2317fd1bea66321b16c2e5acc58bb6861b6768488df76d137073d5eed4842e572f3574fb83c1b9af887a873218b9556956a88e60a4e98ee246de750fb93945bc9a5ef484476a07abe74d59c89f17b8a52f775a802793d555cb91e30dc987eefcd72f35d56ea24a43938e2ca5625ae90482a279fbb0cad6b75c083705ba9061711d16578c43a2b8cff438af6d3c9269e2e38fc60ebf6b00a646bab6698d76337596f249696c59af467c374a16c391b7ac7de620c6e7a50129b399bf5dc3e4b10229d78138cdc77cb510cb3ed7fb61ecc43ed59c61a81971d54dc06eadefe2a857b1736e8d02364b699894c0c25948dae6e5e3d263d035ad00d3504e53930f757f97cc2cd0342ef75f2b1ca863b7dc72e26aa90f64d596e1e28383038596ff0e88250cd77d9e4e3ab8a910245e15deec3c8a067cb8bf537fd0e93978f7f729485f85ebe3af18583a6649870d6103f088eb742998065e23b2a14ee04fff0204c7b0f60956add9db2e8ad96f47a84bc3cbd2517a830a0c455522b12f0fb84e7a146238f572455354554c80a12a582e74fe0b5ed5b006612fb4e535a17c71373cf8c4de57be8f8b198fe81be1638d8e0010adc4e0a3a3940f8b785fcf5b727e3f80d84992aee490a8d9e6ed58e47d3236945788a8d15d3e9f7f7b6fcb6af7abf1677baeeec523d720aa7f0f775c71606dd885e11c80b81a45267397942a7fa2df2aee91f4bf06642b28730f019b667c336014efb84b6cbc09ec8c143827a603d90cdd96b783d3437110188a9ef373d1351b5b4c7c0e637f1f4fdd0c0a6de32ad67cd6fdd8e8ec5c7dda89a9dbc1301d257dcb4964ae96c8876df3ed88bf60c15887380cbd45aa46bc42324b4865604dffe5ee294fdef3ef2c172002da6af6eb69bbfc9a3f14f8afef91e454feece53c2dda2f4f0fa1345437ed942521619e20ecffa6a0212a841239b664111940d38a331d8e9eb12b65d67a97a8610a0d19a95a651f36037990389ae078d30d77115f142f33b789a1ac95801dc186a83fd933d1ba4ab1361912640af131340aacbed81d80a30e2836b3577e4214514714d22c29240fd6629f954a4c2b80066bb7eabd3b7f1b0efd3c4d674d62e272415d89adf214127571cddb1f76f67b59cb834d130e10d9353dfdd932c31ff5d7ac3e587fe1c3846c282a2993f3ec8d97e7dec68e42bd7aac7ebb7aca7b19b48520b75c93ffc4945b00a7a9ade7aa69a5fabd0930965c81d5cd40fd5091239568feca2b1edf0bd22f0ac736d032da3b9cbcbb19b3067cf2289fb416cd44b986886660df1f8a863cb45ba3c34b2365674da9a37f303cca22a76001dd9b6f7c2551baca933999e23392557d8366790d77bab8c10ea8a7d49ed8f60e256db6814d51ec5d8ad14599d0cfc9a8b2a1d4dc5bfbf27064107b6b13595021b3e2b99d0c337e784216c4109e98a94c781712bb9b25192b4e8acd59b5534503d400ef957e4532b614fa52591ba2ad1cb4dbe7dc184fc3d4af8c4c1feb2f1a86a730675befe1ad8175b54176ba9f415c59a5a1853c9e13b6e89979985d45dff32b0bc87e3a7d182dbcbd405442d2e8dd0624553769c3e7cb8408f5c8f5f9239bd1ddda1e10cd61b3c8fe0b28ca6fc900f6fb1c45ad7b5f803976ab09a7fb2d5ea804ed8bb06ecdc5a3855b94bef77d6db1fa553fec8e0b371ccdb308828ab3890216e6f5d75177bd6833c4f9c7f3c656af9fde22ce0029320218f0a8fecac714b2ddc334acf8a5f7bf96a0aac6ed0e47a654d0fd631e9a11987f6a7e231f22479eda4f23c64bb72eb356109014385e7c01abdd7263b80e39d4d3bbb840fdc8072261ad6e13b365149df191ade5d773d99b75618f005f1c9ca5e6c91372d9c948f3033467ba7cfdc0e47b9af85e2bdfb75358789a9c9dac0fc63f3feec136ee09ca3a653a5d7cc07afc7db6318193063cfb37e385857fbbd991898013c0594353a79b09f026e773b19dc47fb0cdc6317f26955c5f9a09abd9c7baab4171d7d484e54110f4aa969f24ce03ecbf9475c6d6a641824c2983ffdd984ada6890dced87a1da7b4e356e4cdbda74560a50a70ea49bd24e47960a807cf80ba8ef46b992f7d2978f7f121af38fffd5a0ea1610ebae1bc21fb742c3df22d7cf5d44843d2143cca82c186faa0a1155059cdeebf77af3168efb647ddb7a6fe81ca6d4d619f440ac32b8c79a1e96c0c7540ff470f1ab7f5795f6c59a5441d3267832a70f60ef28d68ddb8bb525722e552c3dea51519c72026367f380d1cbc35748429a82a62711ef0a0fe94a23e5c0f29177e809080ad5851c71859fcb249732f123d9d514eb5954b6b3570f4f51b781634e9f2693e3dd02aa224cf309303bdfc93b98b8c2516280735824992f68619af383ca54e2be709d830aa2e34d56eca2b55aaec1db346a1567884d6e1b06fb13751dcb71fe6df65ca8cd18b4c0aa9bd7cb50da75725527e535663f55b30e977153d121b249c62882a1766b340760ba9ed49d32834094a75c35bf6068449e272fff67ce636f4bacda001c6471f9cf8cf8d687313e18519d86f83351e0f2a567bddf33ab57a6baab1d709e48d2b17c550b4d8777562401431882b08f48fd06a24da567cc3976d36350af93eb7da3d0b577a512e08975ead85d1e841b918b5229613d57d1b83e9ba3ed5eb1eacee89a72f488e423438ebdd00f7fb06763925e8501850f4e0dd96021d987d1e4312f2dd80c752a2aea657fa104098881f0cfbb1ca31408ed4a491040deb3e0719a2068be085e77479df50528a52d0f8cf6802f48b50c637b41a46a57c9f79510a36352d0c5a98cc0f46d16cb946a4fb67db59fa5758a4264a2f65e5437b1e4bebdffbd3a1fc8af52c62cc71da08408532b57749f214597f8e808aa04fa8caec58bbaafeab6c3cc3c73a62351671415af2501d66756207f94b7bc4283ae91223a4fc76571bb3cf0a6ed587a45d7ec158d75a7dfc9a6328a3d480558c1300fd33de5a37f73fecfc31f2fe9a3c3b3817ff5dc7ab3051d8a1e104db0cee402e893edaef6623e519dd98adcdcfa62bac827b9df81c4ac6205686b02266336c50db34ec6c0a02ad43f216d9935c957d13f553401ef94b42e33c13a0293ba1b87c035c866bd365d85426e84ab5c9c51e2382eb00adf6e243260ddbd743f1f99b68b7d2a0b04c5d37968abca73ac53c9fd92332b130a34366ce6024286c609634aac1beb8c733b15eef40235a3103898cad44d32e249fc325b3fc76e74e1048ceee49abf270b1a53da07f72a7c9854ed5770d17c65df34471e599a8165790467c2aadc2b555e09b54985ac6e18b9437fd0b475406f3f16109c555f85b5887461d635abe659a2b78314e9317e47cec0f546348360d416a2fb542c1c131d85054d90c9369c7dd95ce581df4bdfb1692358f06a0726fdacb579ee31827e83e5c0e2c430724d37442b0160f8a79c31b367039552be981a88823b822c2daea1f94e57c1642181a21b50e48950087c6805bc503c91ad33bbe5e72ef29c9f6f5ec5831b10da21fefcd9c77ea80c12bdb2c3d5226920bf56c9ef95945bc82165227a2277c44b3983ceba9afedce849423e62662394e5b2df32b1b34e926d79c016dc865e4312823fa55ce1c87fa77f6b48422830a0e4cac6c425804027fdb580dc1b88030c399f4dce69ac93ff6871a3c3123ad5eebf8a3a498954d9c4d8af3383c31f42917411de0bf57834ab0c4454244ed6fc10020c87f4efe5de2f7e18bf575732009ac362a13431bc38f31bdacada6a47cdfc1515d4f409570f2bc9a73b5ca80c15a3c4f99c647b2b73db543c2b7983dbc334765899848be8523170824521a565621da7e2e53cb3296e9145de682b0c81086c76425517a2b38ea3583bda654d6be3589ffdd0b2df2dc55f1bcdfc9cfbc64eac452132e056f24d21f788bafafd0bb99c6081afb4ec2a2798f3f5f66ce3e0d026abb20afbaa92a3bf3edfc411467babe790ada0f02150b6168575651aca162e3052ec92227f2a02ceefae8ce5d10b6630c9fbc0de9d5a34c7145153fa75f5a0e46dc66d3830dd623517af44f62d3e08569294e23d73a3398e21c93b98e88851cca926c218de172112978a9426438b57f2bc4547eba99c85b186e181169db2cac83c925c166efba6b3d3ea734e7a8be73dfea642400f575a009bd2ece180d08bd1575a6aadec57cf5ed344e21d44cbc87bc64d1cce9c5885edfbfb209bdfba947a419fc4a29d6efee0170ae37cfa20c16a3f5fc746dcf56bae1f46be7cd4fec13ae76c32a6f85e9b59cf0d3f474792f9b688439471123731b47a19448f7a885359d3ebbc0fc235810ac180fe136dcc77e0275deac76fd05537782a36abe24f8e3a33ecee0366edab749beca340932bd9b93ddc61ceac1818a8c35e8ff39b424f85f3e1fee80e412cfb8612c0077cab535caea093f263b96e5941b027d337fc534a4e908925f4541359f77b3349aeab22089e4bac264f232cc9557813ff36792341a4eeba5acbd3c49988dc49a1e051b6276a3b30ec07389ad501de5b3ceb5eb2091ba100f338ee1c9d7ec32d3d2e36b2c60acc43aff3c9b6fac5c66839e499cab0439d8e8290f149eb60a3814aed5b61f940bfeeaa3a481bab4fa81506900a4f5e494b617a485f8a4a801a145e9a85c92a4a50e3ac9dc2788f3767a40ddea81d01f66eac61119c67dc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
