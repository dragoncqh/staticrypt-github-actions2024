<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fdca75d2f20ef09e1ffc3448eda8a98c7ef8dc45f0e3ffcb236c63e71828fcfbc4d81ca7e01beee33b3cb7ec348f37d2d68daa6e180029f1c4c52a1380255299e1ce74f14d00b9fec102d8a147962473e5789d02220ba6636cd41fe220cf627f4fbf37361dcd692e7f43df628a077b9bfeec660c827c820e9fe0a962a99c154ec97a67f483ca50434a3a0f5d9574c9763e8fe54bc46f9fe98652ca02f74d3c69c757837660e11eabe90455273bf6b58f241fe0fd8293cab455370687fbac45c9eba703c5b741a1d5c95e82258060080cb496928799d3c226b68cd63aa3ec7ca7fa84c3015f3fbdccdffd43362470c4566418c0c4ba458ecfe417937638bad02b9de0e04ab942904fa69b5737ddd27f1703b27a54a5a3d8ac50694f2e652289183d107ab61fbb1905fa377abb25eccbf4e529a487d59dfdacee8ffbcb3169e2f8fe62283190989572e4b87d1364146dbebf6fb610543f9feb61d4ec65d1e40ee36a7b0c406aacfdff480aad3d150858942cb3ec0a45a0d4af131704ce5cdecfb1446528d4129383072389b95b0f8216cd47bc4087a129980ad5c030a46cf4ca22853f3ba95733456804914735e5612d0e3be83a4a8633ca67e93c312051814b51db26897467e661df9e7fc3f44220b2fff159b688d5a2cca15c48cbc1ff9fd8352919cc29c2434a131bc11db3d05a767d0476c4fa4c89fab5d6bb9340a344232fdc89244aa5dde7492c57f0c6732ed70627dcaf0b5b73704c3232e3a3c949b56921b0092b48defb7f911c3567e1974192615a7a72d987214994a0e091ef68188fe736265ef270cdf4e0b98ef46254ee6868ab766305a237ddee86e27163912e5e811a2c1332d84937c29a68c301834b16251f02827ca4be52deeccb7ed8b0a43b27aa7d1c1605079a811444130baee89641d53ccdf5777d86de039e0d552718b805d71bcfd7c9a6b6a5388bacdb79655090eba06ccfbfd61f1849ca199980f6466ab5ab14e0dd243894960063b113fd739b4e2cb1ecfb2e7d26df36d2c405e27c17b743e86421e21c8eb8ddfa1009dd2053be7bbc2595241f652f83b0929afa4c3e6688f222028f6f2a1eccd1fec0943cfd16677b95f39cb0459e6979c27f6c2a199a4c807c192b7a34e9f0186b05e48027919a9eb8393d31da164675de0fdd23b4d65444c65670cc56a995f8b4c3434385120f6efb22603baabf034faef224c3a3f0f286e1ef38d1beae22b51fefc5844711b934239b6df63548973d5de36abb2fef102407f839380cb3ee39b507bafcbc9b26b92a7b00ba876cf318d12e99d06d9cdb4be208b79c6b845af31b950e19b801ccdc62c1712ccd4dfd93e6be33bf4187f7a727bf8bd7376a8bb4e54de7c57e021a470f7f9bd15c01a54001e1dd1633ef4ef5926104b8304b682e62fc066636f4ae1fc2af62a559b52766f06242b373b4b9acb3d54a4fefad73ae97c692cf4d40aa7f5716ac66d7e5f93e8222650b31bedc33d6d3c79d9aea4b9870118783b9568d8f31a11483638e868014aab681d82305cb9647f8f13dfc37eccb6553575c4ec999ba556ad9fc191bae1427fde6cfe486af679bc537de0a5d757fd2545c1112e9c1f7c862a95cf0cb22c251a4066ac939d86694d6354bb67c7afd115637497997567f066fbc0de4eb255f8e8b46760db01466242adb46902f9564e799547e574959fb662c04634429aa35ffa872733efb7f5b8aaa33c06fd345f222f0b0d958d9c320733cdeff066516a0555952c9da843f9826099f55f6393839058fa62549530961f76868fe5d5e7524bc8cbbb80f162f77215ce2af1ef9d482e8494462e6b5a4c9cb25fde92d705429747c0576c2cc71884975218de68626f3e4d8607060c5dcc88b668b6ee33df9dadacea52a77600c29a00194142e78f8354582109d47841b6f6fb2615d513741201869feb69e83497574f70de688ce60ffb6ba1934ab0e0b162be8b7b044a15052cae70783bb5b5d94a890118152f0e9c73fad4dc7f74279adba9cdefd3f05ba6f44135a52a13e2eb0d348583779419b07b8df2ff6a4d09daec933e0602c470b11e4ab6897d3e05e5400bee5c12d02177362a255209fe54f4e6b32909975dce9b14857d8f3072a3083ebce6e07dad4a9d1c6ba37094a23e8b94b9a6fc8124eff3f7b3475e2a91560fd2cbaed344d66413d818b3af96ebeebf558fd47c5dd19557c320b7681f093e892c1d426d12fc1fdc6e8eb23573f8c19aba29a0cc6f15c80ffc702c0db34d2ddade8b26c2f7917428c413a893c7a40e82ed22dec8c6df258a6fac0275e375388f8b4e6b56f0b228d282b24c3a8c223d38e4d299884f868e6e4af9eeb9c33bdf6c0693e787656a73b2942b7e81bd3adcb636b34ba19640313b8dedbab621b6553428b317dcf660a87a816166dcb1ede8ed889a9add72467d58f2db5b918dac44008366f216dd1421e99c2a4b8ab4380540e95545d23feb553b075438c64556d38eb3c05f760979e3b9e8f44122e0021fcd9bfffc00cf45a1e67f1fa54aae9850243269cdf153b2e74fc714492186d117f64804ad2ae5324b999f8ba256061d17622bc787e5a7ff689374437b3c5a4ffd5e6bdbc912faab5b92d788537ffb12bf5947bde7e78919fca0954b9cfd7c7f98714b9ff09672c89d68d2962b70c5faff35d89ac3d01dc56b02baacafd4650d55adc910d73ff513ae73314b6932de8b8e774beb20b20232b66eb4d2a6241e4a2c85c23ddb02fd9147e75744c371a38b15673b9ba2197b110bf58721c06e8088ece7e5caf6600a5ceab3047ab3118bff474fd820b4ae7ec9c49977f257165777b4ea9c5b686bdb620c185d07042a7e13c6a4e806816d5d64c4c1639e6ba709a35ec122eb09b150a491e897771f18997c5d1ce6673ff6c4699e381d5eb8ba452fa6b89a1310a2c1fd7c95d2631347d4090506754ce980e9d63ed5c9ed3cc410dc16dbc77f9a18a2d60fd5fce0a5b4f2bc97c558c5e3e5b58d5977ea93b1507ebe67c7746a80495b8010339f52c52b9a2c6ee626541ebf50d4e3e89a559679181c2322c82a95bceabe76e7279821308e03aaac867e3a752240a1c39b771892bd24bbe5369c5df1573f0521551a2c54dc07440ff2e018a191ab6cdf2516b8326190e1f13b213a242fb5c0a356fc488aff974b0643164af5bb5b37588e0a3cc3d17c3f6a9b36b5ff285a2b27a043a6d2fdeaeac60edb732e852ad6a58e7144487785eaf0d8f23807a531239e89aa16c150e7eb3a6dcf660461e46e66575dbc589fb6e37b1f936ce3ece0222545d600a765a68eb4fbc153a0c9dee431c1140619a7d46cb992974a654699962cfcf979291b498404d699a2970d2318fb1c926ccfe2bf2a3005046abea594e5ca75619f187519184bbb1ee82a9a37aac7f5040e331036b1de5cc7c0b1e9f0842e7257338a42464c3a22de974e4cba60b995526a93d27fb2eb7beba4a8b514e781d3ed3706ad380a5d911a46f783c31365ebfb510152e280a3f2defc66c761ed9a74d5c44b035af478766982980ce59211ca6c1e53e40a0bbd976d4a3c860870f3bafddfae14540c07a2a01d17127d2dac9d1b4484598b59c9d61bb37a031703184aab73c37835b1ef9391f290ada78aa74b6bbccf87d9eae4c978a54b2f1e8554df787c3cc81a8e8d14844d2cae3d64410c90b45ad750eb786e97fd3623b9c50e96ff48f15c226595552efd090105e7188bcf5d132e8f56ec2d7c6793bf7f21d4b7696a8d780fc8f4c5d361ed9cb9a8b7d47cc4eceda0751894d869a8e71dd0eb1e71046b67eae400451a09bb573da346b359e67eafc9b4cc35054fda9e73347645f162f49ad079e3503652eeb2352599a77f3dc890ae8f23ad4d5995655a6e42a19e671718cda070c6a7b389b43af5a923f0c92333f678794c003752ae64219edfd6efff49a5803c130ad0ec4ac24048a6571c22f1e92fb2bf7571af5ad53884a23c2f46e8fa5578f041a44524dc66f64eb88bb5605e1112743b4e073b5838c23a424b12f23a246e2275b3d0dfb5d41afa22abf97dae174a846ac9b44dbd6ddf90cafdbb7523de9ca0326b16805b03afb7ef1c7d15ef71f6b6e321246858800729fa59aaa35e416b349f6183ea6bc4b8ca50301a80baae2b62a3cb5a234f76fb2e3fabe417e6af06566f4a9a4df09bc73792da9523965a23d864175bb0e59cf325c25772f79fc511ff9b232e85b9f6be64eacf99e5ae565fe3e23814c5ba68665175d77c6004ee75897008e539b40f75b65fa4b94f7f39b765164ec62018b7d94f966c13c7ea7225327a51ea2a068b0238b925ddcdd1571b9e515d976513aed053ba57a261a648a6968fe9d0af639a7c47d455984badf59abb49d42a940f7bf6c76c18c0a9c929b9a9391c5fdcf7528b145f6a8d14a5d3e6b99409a5e77411538ea720de2a4644e1c059436c823c39c4c7bc48086a44079e7ccbe98e0ec6f8fd7c869f2901933f7bd2368789a02def2a172f69a5d65f163b3580fd1bdb3809eebbe702d23ba47edc42c96a3f453a5ec1f9b204b9c7814dd24bba4bbb639be366d0a757a2ef13ea7e4fcab4fd3d26909340c56cf6c6dc1afd6ec7e86f3d356e52c8a9c089b3398d48a27a63199201bde8080954dead0a10560b88262ff62cd5f314b688cae01d0f6fa52845cdbe3e090f7ba3d7ee8b7d36a406f54aa393e5859d84712fb6d8e53719151e6e52f56687b817eb54eb7c1537405f40ed8a08c209a138ad6d90660fa3c6756cc6e028b6c37345721dd354e62c8bebb29d138f72eeafe0cc6c05a57743349795ac4df628f1ed1546a937a4fca51b40830bc306218baf092f2f0a1c711e884171a3171b49e561d89308ee71c1c190512c1385dc534002465912f3d641fcd9db84ec3d18ca1cf0c70074bcbf244e387c9f4a54059be0b2cfaf6cc18734dbbecd0c09ca80513c327c44a25be2a745625cc13913317c486d19a5b8397a5343c75a67f990a83d3a9649f22eba855c1ff07aa740314c565d98c95d78ab92d21b6736a27d1b8249eefb6582bf9bc61ecdf7f31f412e28c5780b2ef86ba50f0e944f38f2a3daa5b40fb72d2456a942308a4add12a9e0bc5a7c0351f7d326cbc80b97636d61afbfb4432fd653636042e541659b37dd06f52ecbb60af8421e7a4dbf0c9f2ee707e832d7f7f5fbf67510db787ad58e6cd2c71a07053769c4c7c9b8852c68015049513c3fecb103ac0ea6886dac955d9119e98ad6befd4331e5cc4fb6cbad0cb967f00bd2003f32d2264c738920d9a5c3be92a9c972a0da491030d9cfcd72f0f5612e26362e151062d9ee2644aa770902dcc8879bcc9a4f9ef02d22d9bc6feb2ed0ad7ba57aa16e463a716ac6ffc7ad5ab890104c87f6cbc6b68247e1ec4f456cf2b2325d6b28ed9a9cb04cababb80520d46dc3f830097e9a86e3b322db7843898bcb4f75e4baa10f129906c7c00fd5f016186298766f03d6220cba6dd536499c333a171933f920dad7e1ce57771cb236aa93b81b9cc32efdee89c2bf074bc447b5899c74fe4a4308b2a517f5fca816019757f63deda3b43892fbf214464845e27d8d046503c7fccf9fbee6cbbf39fb8d98df82b07f02259ae4966b8235cfbe6c9739ea2928f2b5080c2b4d5cfc5fcbe79eff03b3dc9d7fca2607031333f056e9bc981bdf05223efd2a8a736e60a5ab6db02f06846d0c81365d93cb68c590eed47a60f12267b1bbd6d0fe156628ffadc241fc390be7450442312e0a384e7426f39402869726fb2af3e68d96c62b045725ba3afdbab66302a891968c479058183b48260c62d1348fac362813b362874b742a378d62143a4c01a8e8eed59f0e8aa56ea24b0a1565c25a14bc53ee6c6febb47b9ef496280365c418ef4d29c7fa621f0f53a3e284ec747bd134944fb31e8d654f93f929894a2d773fc305fcc5bbf2d97d58d3b7044e74e1c6df402f0b25f74ed30f486df6ceb105b0ec6bc3bc8764dfcce1edb8d8981d965e75513f9b59d5902a20f53d0422674da24c9f67ef155124bf69b03ea63900a008de513833e3442d364b2d5c92b438197ca968360ecb2414d433dabb2d009485d33da0821b689a8186873e9f04a4d241ef1883ad32b8b73b334b0947ee458610e6b0f46ad7a7d134b0601750cf8a0bfd24a28af72270a98c221a7321fff88333e819d9d251cecef445bdce76116392a5cf282fc84eafb6b5197f39a50ebc4b57e764f5951313d2541f738a96004553292100095ef8a22b979818572f2dcd07666989560fbeb6d5ee39c628dbdf76f4d41dfbd894140935cbc24969549da459a4e0b39eb74a52a21ab9d6c9e54d7a4a80cf047909048cec691b7fdd5398f06b5f7a3e93fff502b85b5c41a9f6153d9f2e5d8aa79dff2be4b2556f79da946f898d47f4cd9085ef5ebfaec1f5c1680530487064cffb2a465179b8b76c4a02b370a1b9c674e379b2bfcad309557039c7a1e636cedaa36f25fbbfe97f491fe36401004813eed6a7cb37149f60b3408ca589738233ce6c94ca872a687a043e195fce384bef3d71d34765efc835437e2cf115ef6ee0955e5d473b62fa3ec1024969cd3daf8bfb6c57e644b427499b987907f5b1cf52b700d50c164f9d24434d91cfeba552d81c1f73cc2f67dae6e0078dbe41d737425f5628f18e87003e55f04dcaeb66525e92124d6d50f74b414e9469a487454b0ecad4494644d6f02ff5c7a1c1a429085ccbc33a8792bb37be324584cbd0f35e009c17d6b07789d528de90fc8662bfbba330042fc0b1bcf2a2f93bdbec699929db25b8c7df8c5bf0d2c5ebdc8ab663cda879d91ac29453b3c8a299445e0da35855c6e5ce46c75ec924754a6d854d5b199c4ccb3505bd23276aa7db78e1f1838a390e76ca4efb9e79d9fcf3210006fc7b10cf4cfabf137ce650f620df04824b6d835092a2c960034403ec6a3aea0221424b3ece2acb61cd860151bcdf1f0640b67c03464d76963c4a284419f4164d1db7b04dd4548b4ee069129c1f91ac026ac55064f789a09611610ba9d4ad90da7ba2bc8f51f27be434371fd4860e173e565179e78f46ed55b58e051d03c3540c5d60d82c0d5b2acd0bbda244c7a2c478db331c010428d9176db8ee047d7ce97c2a0f7b944b0c416157ba33d90cb3400ae6106ef0643228530acbbaf1641e23c914d2e8e24886acebc2d9fc0ed9b99286dbc4c4a6c09558a10498788a7b5c87536ab523a47616f0d6c867624f019ff06ac735b5ca9046ea27f824476f47c8156147e5c4ba6ed804aaec45259fbf7a90ccccf86e2abf992cc2b3b39465c45c52d009aeaaf2d1f3a3da46db7113e168a44f3f2aae58e86d9e5bd24ef4c515ef14ac67e5cb51918fa16e49d0e4713ea189a72442e4b4b32db7d4c7205783c1b0028ac6b659c47f2db587025958fe8c52bcf089658776c36ea33d8479870c78cb2ea666b3891dc9b35d28d59317af8ae8e6786fd00714570dbe867a166c9d05b6fc2e0552eedc98ea97e3b16e76f30218004e0a814da3f2b331e4643fc689d9e35a871aa6a6d32f33d20796838dc6d86ebd7e699f1571d16c10b91761ee6f9bd55c0de111240a19cb9f5e9ba9bb74589b689dd5c624a7c4d991c121cdd2431fe96d64701fb2c902f7a15ce91f52092e2336b6c4f00c41b2c3bfbf4927cb865c1a486e143d338d284697ad6473700535936e50b5aedd6e8ef57a815195fdd19061d50df27c854915fbc2c3e23069b5ab3eb8783f6ef95f4e74d44356cd9b3301ac1be0a8861742f32d035195db78b5af8a630558ec12fe1d9f4debd7901ec046a4608979df41dd02a1ad3c7ecfd858f42554a2612c04777ccb069367a95c4f889c5e8ce57b4ec39d1a7491ec11ec6b17e5c666cdda3b8262ecad495dd38e5d54fa46b011908111ed13ab146640aac58cc3ba083a1f4f957ef1820408226dcf2f946a886479f4ff765b0c9cc403151ba11ad9a67375085b49df224fc8314838e3241bb26d7e71928326ed277260a6c289f7fb9b24f830d9a1dd4c6eb7fe8643fdde8f7dfe50266a5592a997335ae53b0c562e119df96306f630cdc2709dc0a3977441eac0fb12d0e1048ea16a72f2b9a58f00b103970986769fa45a1c97d0cf5c704cb0cee232b0d9465c60338482377ad5445504ced9d3754a27e7827ce1e443d483af409c54c400054893f5037a27856b3f1144f0a9f54a39c902c55cd95274730f15d422a3255a6f11156b8ae908f3872aeffe6d01606f3f019ae7731a44ecd4cd8e445c6bafa6d973d82c16ddaa9a9a28638ef18386a0431f67ff63ff43c527a817b1bcc269abd833278e802ddfbd046f6336a81f3487114d940614604447906a3e8c3c3732fa7787d48b34c7189d7d04a42b4b8168d94ca600a814ebec31c3a670494d03c99ab4ed2ec79a34a0e713cdd3cafff4010c26c86d89543288d9c658e6550517303e7a5c0af824ec6a64e99b5455f2b6b06dea4c7e7ac3a8cffcbc120b1fd4b4e2a5719d0f41557c0dbc4a56378602506509aac7a09d7d4ca9ab04b96667870f7605bdaf2bea73eea311c957a98b88f7b119bbbf89d1f8292d50548dd690aea869bbdad9e740d0429e4c76d9745a430331f7e041a09eebb3f06f9ccfa2e0cad85b6fe9c5058eaec041411ff248d4325eed24e89320261f93dcc27bed4d3b5e57ce6401037ce9d4536daa074a10f04df2d4d7a85faffd1ae877c5945f163a752465772356b37d752ae41276dffcebfe51cd98a8855e83ddcefd72f624526be04106663919eda333275b192114d3bf6d2338342027a3821a6735cee8901743772643e142308a75bc6a768108444d4b18abf21703c8f38d22b3acd79af0e37946b2056c619698d37650189fc2795e411a45ac3af7eeec78daa71d5f4cf8db80e2c97322f15371d5a58192840583e4da4019399645c349dfbc4801e22d94b08c06f5f949f57824910e032786c9dd85142e1af56320be35e3d29eb5066feed709a31e22a6a79dfdd579f9e220d90eecbb7ae23c222cd72850f10cff63cf0eca1cbd510e789449d523b112c219bd7c0c72ae72a73916dd84a2406a88422630e0947a810baff5c3b91cda78bdc1ae62b11174faf6ff9a342debe79ec90a29c6674a2f4f99255e96efc75df8dc4cf147589959e9bca5c49bbe3051028934e97fc75d2a8ba0bed4b8986d55683b9201275e1817e3f3701667c76598e95c4fd7e586ba8d9834e13828c73f1d3eca5409f5ae669b57d45c8e1d25db2468cfbfb7aa8c0c0a1ee4bb298d91f0525f05dce3c89180beab72ddf938e9c4c9a64789ac4734f5ad8c310ae9d0fd89b094fd4d70c9dff5f275586ea1287fc75ef8db64d533d64921be5cbec79c9b60125f4cce7089c4b8d902269cbf24da7db8062763060e82eb45450d7ac7b5cb4f74e8f8d3d38745efb5b2861576b95d25225fefabde36c98cd4c9fffd56c49900f59ac11d77c7954be72c2fd2642d58cecd46b9cbbdc5e9243a1467efc835cb1e560d51ca5534997ae37e5efb06b956aeb04b83d35155728cdcf44218597762abc1195319b86f71e6558c2591bdc2fd989744e6ad7c3659d3f76c02df51599814e080ab38bf89bfe9abee1e0b0f17ac72a52b909d3b15e353fb731c03946af91ce6c605e771b64ac38606b230bbbcd75b17e2e00adc219aed2b09690298c1e740c89e34743d53917a552b2a5b88735f94e2cd4b36381b4a4e9e871ffde12757730370591c8cf3b3e67f5e6fb22f5d72dbe7c51ab3cea11bfea16a71e141ba73ed9f4ecccfd9679c13726e389d48480d649cd0f02c6eaea8d5fc80fee00d0391f0a8088ff9a943d7c84a1bbdbd66db8b01d80f3a3ec67842f772269642313759f4893b6e0deb0062b7b3deb8dc20fcca136bafdcffd17a24b295a8cebf826f9ae95d94a10539d4ba32651dd6743199ae9dc1158038336887a37deb22df4d2a48d29beb572ce1985f4a837e280bff339dd06e3239c02bac361f744d83f6ee140f984d49de9d65d4ef1898030630ca0df9f5963298e473f650745970b8de83224a0153998cffd4ff82f3048ae2a847e287a447981e129554bb5258174cd329c80d40352f9193fdc05e4c21e1a0fe45bb85643399eaf0b359a0d25643ec44191287bdb9b55191d8fd642ca386e0014f0ca507a14f31c206bcc461aeec0b06145937c6270ad667e853888c103dcc485d45beb2b9cc0737668a5bfc66672c559588771d6f29328628283284adcca5b7370eea6c1236a6f9881f2352eb3bb875601479883145d1316db6ad682b209d8a58d6a882a85858b7ee53fd98cd2ce5b5ac45e457c0170c066830532e1bcba00d0d4f1017a293b472d326d9325982fe5e944c3fbe5c49021f3d4116b8f84a49ef396dd6f8ba90c0c06e3a910f6d21bf2492b8ce2de9c2c1cc743d1035c9a0105af8cf630a0525844d856550c03144c62ebd903db9fbd8a5d4bde049a74bc31cea06a0b7ffe3114a288d2e2587ef40017d9f98c7c31985057120296e9ac1965e88792df185db3407e3b6b0f373bc84c852ee93e1259c0034dd924035968923e6df2377ed94b19766fb42539a012b94470c089aa366bc6cdaa6d0efec693629057ca6e4c67924e8b6b5827c04686e5ff3436ef59a5710822e50c889a118106b40effa52b53bdbeea15d315be48bd78910e853ff50f5e477c2071266eee505ba4d14746a13a184ffbe0c0965bac816d12961f1bc8765a729db577ca64f783c5e9f105a03772b3433e6e9616d1958ad698039245fba6aff74b7cdf74da48a6741c5ea8a7eb0f7449044026a40509407fc542cf57f8f9949598bed20c5283fdac3469e53c71b345a50c85b01a5fcba5f84cb1441a512547ceff075716487d497fdc20ddef2325a8699ea8ee5b9a3fbd3516963de7e33e406f2dcce096475c96e5304c6283cf83ccbda11d9021c8c94d3a88cb9546a9747840fbce61c5e7ed257150c5f83ab313d09b9fc210e1ecae6cb0bae5cace3aa0781669c198250ef144174f5940b290990125c5733e43be37140a363f9f1fee722e0d6009578f7afc7bb5b4250cb5c2be35e4d63d1c11405a8214dd665f1b59015485eab48ec1c40b2887085cf78e519368cc47b71e082d72938591285f4f14bbbc84c7b9255c767eec6e4d682e067f0929238a4583531951c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
