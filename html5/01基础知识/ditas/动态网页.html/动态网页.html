<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"555db9049eb34603d7559e73b7d5a6c16330e888b3e25560fc0d9cd1910f3df38466a2cbfbdf715244c5e657d46fb032805f45443dc901aa821f44361d4f336e54c5c93a1273d2e9d48db20292cd855983b9facd63afe773b2591259f557abef0b7b89e040ec358d4195eb4ae5727891d9e133ff29d3eb4ee5b07b3272de3c0ebbbc11d69fd131924310668da86f3b176f0a1b0859c92d86295f5a3e52cba428f72ffcc7cf6819328c0a696d1f4183e67e9cd266fd279df76e93f4be55ac7ec154986a68bb330495d3e303e7d1d7b3ef280cea2ae7ff53207d0fc88a2479fe588cb0530921c8e656d04602beaa3b6a5c9ed2d340755b71c782563b836f5aa612b87f18cf381fb5f244c6e5c843e6a32759f4d6097d9437f3661fc1bfce2c95d6b02a6d16e552ceb622182c0534323dfe95fb3a1c197873086f8d0f6a25693bc9c6da2e3d943f23edfb4187d9afe327df7ac8924bcb78a6e66f85622b04b029cd44d7d556bd46cffec58cecf0c6d6262cacabd3d426180da22f026ad9dbe03a3f2787288e1863cf9cdc6c565f3b4836c633ade57a30a82162cad433886371ca0d8423007cd9b1131ef4f383e15bc2ce2ef421616e77131bfdf9c6465a3d4fd1798d12d3e91fa8106e50157a895a6448351f5af274d7714240ad24eed3aeeb1c3e4ec79c5d9c550140ab03d2b2caed6c14109fa5d60b4ecc6624fdd31d626217bd33cb714bcfaf80d6424a21d4202797b89be096bb684de1cde17c121ac3ab69853f50a197e35226a4c08dd58aa8bc86d1baec9f6223f6545f316c69c348ae549c5c8f4c20c687dc0f7267887f425ad158c7ceedaad0ea7c7e8d764c68f67fb846a4aa3a509f4a5808925fc74340f24b4503bdc7f138e4e5892dbfaedb6acb24cb8e425113f1bc08825ddd80f0d77c9ecf7bdd004c08381f6bdd2f7c049a5436a077c4d77fb83ca306bc6046dd7d1877b4b94c4c0df3b6e588fa20cc3a9bedf6ff94ff58706c06d2672b405d4125f21b0af5fb0e8ea88305f37f84ebe2e430cda7508c2d96ee6f81dda3afc8ec1cd9382a57178fb8390eb1e23df08fc03a811f12ac4d3ac11d1dfc2cb16716a7b484439c1219c903598c76c5acd34408dcae9575b903f35f8c34dda36734d806490894eb2b7a01e4e3f2a2ee1465487caf7075022dc6339ca8468bb2cbd49d7d3718a86beffc003baea4707d391e87973977c59d29abe653da76b5fd7e4d86e50ab49fab547222d3d0c8e885f2524b5f674094ea970cf648922604b4ebe0e124de51f5db6de702fd3d9e7b265287758d1234e28384e46da1cd9fa0d3be98811e734a4398a99cc7f8826ab4cadaea0d4a8775be850f25a73b94dc3125bb479558de9d80d227c31e29a42a777752d37c11a19bcf874c922f3250dc567403fe4cad869ead936c8b928ffffcc99bd9bb95b97cb7fcaadc16551f4c0300b60b2096563ab62f38a6cb7fdeb28c00e6d99c9d0244b318dfeaa05b490f36d9ee1f03c85cfbe78ee714a9ceb68a80dd1c2c7f372653756ca2c29d798874dcc8ae73a799d23797a18cf4ca580f3d13f94a6ba41851e4e0a0a2ee3268e52c0f4253014549c5ccf96089bc444518734784361a14132426ef18c8e5b07b37fb2f4bf9c2fab09bb698c92f38083500ff87b60b24ef26e887ca434329c60815f4af48f70ec79db0e1e2805284dd254705eeb38c8f38971984bba525230cd7124aa3e19f301256262a350f547e2647579aa00ac58da744a7225bdac5c222c603cd5ef04f394b51d08549839268743c244354594bef67caca42ae0aaaf415a01713d2a52cb40ed18e3529bef8697149810f15214d762f0ac52b457532c1593983037d1a0dc4d06174ccad2985e83eb3f24bbdf667a035c8e131d802c8d90989ab290faf3de7785e750b177f85d0a33a9b8468e1d756986bf07479a5b2e89a0759df2ade8e0c5dd01141536f114cac81e32cf1ce0011c60e6a53a71ce794248454a7c1ae2e55ff1d0c075969139bcfbcfd465dc8d86d1d25f91c5a82c2b7acc9d78eb12c4d4cb5ed93a531937890ca8665cb700268424a4b719fecc7718eb71858f74334718151ab5f8326e6643bf0c3f3ec322fb170cc0648b92e4be076a22585c9a58ee9c222320ee1058fa8969d4d6fe26dfae567c3bcef5e246a12e934867adbeee801393b338b9ccb5e0ad6e35a063514ca9ea7c3022cd6abcc2a7abca1ac9943eff94e99f5c05ca9bbb8d4a86b33503a30c490e84801d762c411024952acb9b9d9b1168bf1e7611a14c1b9c2a4388bc3de21067b58ec45aa260f2b58a52b761bdfa1b0b535c789047508312e4497419abc2f2d61db83c2ede6a74fda450d8e44d9471553683522927999787ae5e2affc91af74adf478202ed99cbbf5099bec106c905e36941a1e9efddfe8bd4e3b861bfee32b95782f1edaba3928e23128cb1b955fe09eebb65f13cfa55bd564256f2f80a029e199ab20eb61bfcd6f2baaf50ed4b06494f17eb1b9de4988380333721318a2598744f93c5401dc4c6b29941a70b749f41efd6eb9cdb54cb86ee717d5a3b3883bc650c578d6bc07b6325f0396b80bc7a388b8783ce322718887b3e0e88aa2400ab4d1644e393190e8ae449265cffb5f1dd4640a8116f2eae23df7979b9a8041dfcfb8024f1d9b59a45d69855b7718c3a19d6bd8a6e6ce91d9f20b993fc56fd83ae3e66e7ab00ccc4ee44059d23ef49dc4fe94a8edaefe76dc8f7e7d9a3483c57ba961630b19033e017313a8f74b0c4797b7209687caa178f84d8f9b9e52215ca4407543d1883bbec27d79f67eaf12bb6f3492f7f18dc65d33f8b22b34b61ca1664b095d3171347daccd7d6e5ad7b04bd402e7976ffd8058c58195cca67739ed45d4d143e9ac4a8a8f9e9c8d0bb053818964c0531473a4394544242d8d95e41034c9af95964c508b6a12a8fcbcf462863e0dd4b746ea52797a8bb81afbe6b653115f77ca591ad9ab788565bfe5a52f77aad5be789ff9b6df8ce737f3a5b281ba5f72f0efe1e4dac4004b180759babb3117f6fb2546b74cae0abf029d6d5b182246eed52bf4f7e507b5c27b938475b3445613f59ea0994c2d45d48fa36304b4f7722e7e29c0b029057f5b6dde86095a747f4e51a11ec23885cb913bb69646357940ac62b129383ba8a6c732db1dd2e8125f9e9a8e25d41d8abc70af4e85716040db9d23101e73ef2d9f3caed34a4ebebe36a7febe3f55fdcd89140786c4587c9ae7ea085ffab655e6601ebe6e7aaa350d28f99d7f2c62cf13c5910e5afc66526169b57f3d1f8b6f7db4fe6bea07a9983a83d5339f3b0038fa7fa01ddfb0bae38933e7a1e6c653752a0b4ebf964b8ac3d91d67420c0cade196a3d77bfa1eebffd3b9d391e86392eb651a487e89762bc90746685c6738c27956854584a512ee70a0615f6aaa81b5ac1164435f635b53f6c5b8a58538cf46d3720c36872471e0b8997565414d526da86b8c647b99b760b4553fe870745158a8b245d38413ce44bb4cdca8570f68b46a3f5707c07c44dae2706261c71df9bdba3437c18139f4157995f4b982011facbb6333cdea9d0b8111e5dbc68b70f9b39cc3bedf9d0013bf13d789401b39d0a1249ae220beee17ffd78d5071b80e2d21c5230ddc75c28155ce852882d0e9ad1d96c2cd08a02035d543a533db18b5fdec907ec7f5e274efc7780b485bebde3f192639c04d6e90df6c818af372a7e48734479d533a137f17adc71b03aa5cef4fab357dbc1a8f078c37df88b2eac779486d78e636d6db08b4f1dc4ba9c0ba958eac7dede571895691684eceecec7217afd2ebb430a6f7d5df0c80650f94128f0b3c1ab0893314c69deeacba5dbdedeac082997900df2b80a58f19bec7b27b9171510122535261e6aa095deaa81679facf9c635327849977b9488e4a422421dfc0cd7811ef33552021fbfd9ecc9d14ded32f0c4c5c4ed833815c22ca5c61cde3da9150842ee64161293149d026369aadea4b922d2ab5c37e1d41e842b08adbefc5aa16723f4287fe29deaf618419a57a7f6dab9be7238d3fd8d7e9b622970238a918cf4680dccdf9f678b345895ed229b93e1700b8423c8de496c4e8f03c5f8aebeb9df8904957bcc0d2fc53d45dc5e3a00fb9a15dbb4a60df2c29421d605f6c925cd42db9500c12aedf0bde4a609fb142b62a0af1e13e720d6c7a33558d7d2eafe4cabab0130732828088c8d05972f7589c8a03485a6bfa8624849b6c1d101081a622add63396b11b1bdb04d4027f52cf78c987ba9f71c4f8b0fbf46e63b1f4fdc6d901419a9ccff114efcd6f7769a8df9d4037485848922ca9f9b1e3edb389e5755f69f98e35a62666488a3b7b8f7eb3c4da989ddca21c725d38c8ee0c9d42bf45ce4bfad69312d8e6a8ccc951de3f2cdaa0f6729f9c29dbe5d78c3e0bcc26dad64128cf45f61e19053d07c75f9e8f1b0d3159b8fb1eecd03fc43aa9470413b77c603531a792208f474c4467c27bfc3c6c79a13b0d2298b13022f193548858bfd4c8ef2069aed30081106fd6130504551db84db6e35f053d4580e4484b5529469d20b3ff72a7f62b76640f9fdb9c758c0c36afe5c53c85096679fa7f27c1f84fc44f27ce018620c85fd3c69c6234db32129c8969612ee31534834c33c78bd383edd6ab96bf877a383bf64c167f2f1b736b5c2653a09bf6be83458fe02bb1fb8c3fef44f4ce640f1f21d5231b444790f5b39250f84d488bc52dddf19ed3f37b210690c4d8029482b730a4d07a7f8765dca3562e8e993e9a3ce6369d6877b5237ecdab788e55584cb1c2ce99d8bf47a67d5409b8a7b7ac20a47279a43c2f8a0e11c7770474fbad802418780c0734a8d1a3a3d73d003222926543940cf7290efb9c81f8e45ffd9983800c9277f0e49c9846894661ddb0bd35cf127fe1c355fea917fb82760975a4382f0f0a597631505cf7f626360046fdc13ed296b87087693c7528583a138fa9c64c1fc6aeccfcb58ebd5c944d6f514ce279da3f6d8376976762466646ce2f4d4fc5d11c79bd4c69e6706a20b103f6f54c06d62db45e1ea4ec7be40843fd5d154d154f8dac774e4e98ef0182deef8e316bd2134b86a51d0509f840d94593d1cf71dc1778126c5d12e2b5986826839a482b89f2a4854b3bd684f1fa484102b764a9bd661bbe2597a357cdcf071fd03b7b1547aeabff428b94b405ffdbe681718da51d19bb4c6570847f8449b58b9255d46b253049bb1765aba28bee116c44b83879232fbff1026e072cf74fec358538b2becdf112eaa11b89f4621c89f6b6ab3ba0891505a6df47cd771d87f70c1e41fd64aec14661672d0e86ad0788a6e3ef6f578925c138530891a17c642c3739527e99325c85686692f3f4bdb4a3d3cdd500a892a34ffb77bd0d7d55c30dd2fad4b1648864ca6dde3f4867d69f9801b0eca132e1c869782edd5aa386691cc731fe420e1c1de1b7160b0ca9fe9f8fcb3e683cdff33df932cb20e35be3eea8cdddfa84c9cc577331b927e49804caaa3ea1a428f7abdfef5904c42af0b3b0a125fc093403cbdbfc8097698659da6a22f9e39b41466093a0cc8f40e39184f72628e28e5fd3ca6abb8e32bb9d007a356c482b543e9e9c69e8bb64eacfae51debc5f2b81c3f6a90360030ab605e34004a27a1205fa2f0bb0966669713c0fd32421da799eaf1b8a3f99c6bad06d780361581f0143db5205c92aacdaae5467985a3fff333a76db5ba37a8f64a79b0cb4201feca24d1e00c8b271022f54c44a1a32e032e2a406dcf988f81f918512106054f85fe434648a151b2e6a9e939b786bf84c12102a45d8fad955283152765a752f06438014d9362f2ff32a4ad7d50fe74f58290110d557c448f52b3092163f1d83e1307fc1618c9c2dda623ba21c52850fedbd3a71ec240c1fd3875b737e21aed8ee398e86616b5e8bc23e9f1ca90806eb013988181cd8c599813a18e8701f97b9bc836fe45c4ee1512f717367e5df5babce5fc0d2f9d15652b487e7434e5925ad15dc6e6b983062407335b982de13c5a60181317b832efe1d44dc9e199aee414ecb6be53e4eb768a88d575af99b01890b98d7146eb8b53613130930abf5e53f1d6bb1abfd7d7e70956e2e893919b7a16c0aa52a83cf00616b1131303cd954e212b0e229c847848fbba42d4fe05159b125aff39ac11c381a9c60949d1299cd3cb28980c013938db33cf261a09728668ff199f16189a35e98c09ca7578ac3a26bf6b859f2169c1b143618eb2095f1bbab4ba77a7488c8c347443977375746f6d2dab7c1e8630fb7b52f1ddcd815696bbcda7eb95a3399c7a805dd3f900acfcd4eca283fa3c17950cf6e21acc5daf1ad7840e4167c5d598d3822c4235dee48d2f3737eb686a34d5e39f13ed6a5555aa1ab07fb6bc7c4174df8a3e5e0ea10b0528ecee0bb4951bcf63b792f8e0b1a4989bbf343dfa179b88247c8c4cfdbb55542024e01dd13abccae941c0837da8cac0db35cca5eaefba52043b95be72e67e31ccef26545cb2653a5cfc494a105398499885bc76bc574615eab108ebac8ea38325d9ec4769826e0e328ba750c9514496aadd1a24cb5565fa157f5f2960ab59508b563162aa2e1b2a757fe2c0c46356dc18f3c332dac127bfadd3149c773b4891ecd2c80246a4a5ff63b0bbc1efb3312cdf05b6ab5bfe3d35224495f29af7161ef3c8bf09edd5937f041b3d51848eb86310afbaca84bcab1578470b05d8bbbe4c78889a0bfae34226c721f39c82f9820018e12a38468ad9567e12d42e9a87f08915877a4622e23c59ee51d61b07db29be3ebe7c7e177e876c124ddb98ed09723e012dc49a18635cec6a3ead99f4f89fe7f607f86f3bd677f6b8ec6d2ccc9dae8cc5b037916b3a8c82dfc646fefd0c65b295ef2145bcb39acc9496008366e8706c2b0762869afbb63b9495c2d0279e54148a7148f3707ca40dce7150a43962a25eaaea17691213a27572e4324053b34c39703d48e9ae9cc681b032e871c9fe341d2350ac6f2d6dabec35169f16b4024fefd6aeebe8b6a38ab74a96328fbfbd1daec37300d07417e6bb6238e0f3e98a4f080df04d901914f0c6a8af1780a4760e02d9a520a74c2e1a00b101348992d12bfbc33da4039a1226e1b60f7b639b500960eae727a7f1d3ad1dd68f13f8a8d4e7e52eec899b5702628fb557d8f3715fc8f8e95ae045c9e27c833bd7ca6e4dc898d0c875c3d515f2a29022d8bc96868e6876234aa2a5c78e8a5d5a37db9affa66a6846dc128865c33610999e0412dfa0fdc71109e62387d6fd5fe9cf2c9b9f948eda5770bd1304ae1f49d67b2ae56b0b6689e04a819d13a9497499bb9a080f776563fe57a0f1ffdf3435f31af0ca3d83691bf2c125eb3f9516f91642b51b753e2d838631b588fcfc4c64cd908d8b503bf19b0b95480d0e8bf6b84d4a016cdf5fd699f623e26f63f61e643932efb15b75c3fc5c729c4d2489cf8a47bbdc73b95bcbe8ad49bc6c064d5b9c84068dbbc948c65609d6f28151f239cc04ebef8a3b9abbe9c03ad63b42c590c07eb01fa8d10ac6b843b4aa2aad7ab481fba5b361d1e5852c43ae1ffe39785c406367a9603bbb2daab75a891e2d450f2c0b47220a19d66c70b44099716f72dea5f8c928b31afc540368a56183ef8b07865f2e11320f3a08b2f483934560d6346b3dabba32655fb7fa3465f5ce541be344d26657bb76214e82ccd21bd77969f674acafc5a68974b0777a2283bce78d121e4cbfba08757ead4c46594d9532f2dc2d8b95e1406df09412669f7ef21a19ec3ad0ce0e6b663d1b4d68593cddb3770f8bc5dd4f2a4d7ecb61f104511c4ac5b7fa22a2d2b64bd255aea77617d6b5607270f939d98472492b2e0d2d5fda678d41bd56bdde1853a280fd634d1490be34cd7d1a1b13af1b8cf043907864315fc6c5125fa6b88d8f4679f1ddac1b9a6ef0714906a21a7cb46f72ce6413e0d8dad2e92d3d40b16ea3ca76ba89c683b19c5f7923a2ec7f00ab8eb1a68e7daa5976931cb3adfe98ac1765c2a13b95b2cff29403a1f47e69246c45f7b5d6814fd0da09383b18754801e84f7820f3869a175aed70ba46b77cfb1d904476b1241ae89b74c3be63152c305a8d44a1407c34b16536edffac35cb379bed9937b75b022d2b5b90f3bf4e0882e814637218ba4b28413553f902195ae39871516a4d62b758c3e884cef796866986772830c245ef74f427b419a2b2d3b92789c8dbd76c2421cf045412af1abc75c98262a5833162d3832c196a273cc673a278ad29b994ff192841f4f5206969385224837413de839329d0347822aafbae756f8f276983cdd21ceb932e565db1434d27931174fcde064ae03b0bedc961e30d2397d78e48dbb784b8a1ad4a1bf7afaa190612f620359317126b8e0bba69b58f12f8ffec5d6594a3b1c450f42674ffedb136a618e1d086c36f7e6f7af94aedeea45962394666c199e78562e0ba14f9f0e7cd5798df3446393237a5d80f313239d7472ff29ddde523598628f3229e8627ef3d2bc7ae632ff0a78ce45c3aeade2a730aff09c0f669f9253e9367b4ba5b8efc1350c56b0e7e6b84fc24b4ada28eba1d93c4de4d9a665d3b8961d7022f6772cb08a208f6a83a55c92f279c72551e6e2c05135d7bec4524c411a553c3bedeaa28527e68cf0e76394f7a550e4b38ae4f939185ace8a167177d6a00bde874d5cc7e89868ed2650f897500c0d92470d1c04023dfd0e01954d5c6b59b9dee9048b11a67395d4ab739cf808c36edddac4da49c7bdf50b819178e1a289291a1e93ccf2d311f85e7b3bd45072b72b00725d501d6371d4f72fb40d666b2ad918219fef0fc124c81ba4a34b575d1f7c30733857572fe9f6a770c027615c89e0b606d28cd55db185b8d26863ff882de6bf5b3b1b36c01acc29a30855e9926bf7d60454000006ad5b91b0a9bd42638d8ef167c9a35e25ce6427091cb902648589755d1ff1c08b9f8978135a9e01ae1cfa78bb72f5fd1074c92e7fd27f3e76b447257f8e619c6bd9ca5af5c898c73093dec5f030e8c87f375ff733bf2983ce0919bef7399aae1f980313bbedd76cdc22e51b662073cbea3881c3afab6650923b5c004aa5c6bd6b32e7ca9a8608713b334b4ca03bbd93bdd5d2ea488e3085934da5e3c86684ccff5ade51d42982b7afcd7bf20a2e46dfc2b39b49e5f8935ba72d452172d183992ce8958d666f3941176c2e720c20406ed0a54eb07471625092abe06072cb38795d206e286f37281895d88f785600806c4b2b3d4695e3a1e4aa55d5754d72cfaf13d316689e47db624aafc3ff89d67e9d5e7097bddd3fb3f6d723b9b5ab890ab372d0ea2bfea818db7ee7973451e59e22ff3ffa010eed2409c9c44a622675ac6243a74041f4d713c5f02576b57550d681db881eba7b817e3ac5b59b18f122981d1eae71ddfbfc30cc0e269d3c23f58a8aa0c19a51cf1e64cbde36eb14694dfe7888c9cd75bbf8a03d7599153873c31bdd9a746656380ec3d49e3c8c4f45bccc202b911f5a9f5cd15c8d89e105e418b3d22da2ebbbfbda1d0ee4a7ed9a7a59b6362862e9c19bfded0175635dd9ac6927aef282a2be5d9cf2c6ea8e1586e1b89ffc8912f3231ddb20654863c2b6cec325e12d447f60d8fcecfeabe4d5e27a54bbbf814274ede8094866c49090171305b9b008a594a150c23eeefbfd228a5a178fa124ace83486358364007c9112a22d16e01e1429050ec7aafb00d4259bf4d879d693bfc373649415d067bd505508e80de0b1033e3b3ac4a5ec6aa5dff94ada6306a71e130b32b99dfe8d601c6f506db493c7aeb4e39afbce9e890315f342c383e5b32adab0243bf7bef216e9dcd59426e8866b511e70e707775ba8c663e3c88d44e8f56d930358844478c60673e4d004a7ccff545c0d8150bd377282a7cc63f4ad5958baf8cc4372a84d450bc382416448aa525e759da3506947df68ad01c6c2646f97d215b287348ae015dfc33c9c1c3a5036b019e923f2822bf9a011524cb7812bc35ce58468c2eb8a455185e8b0186fd8bb1bdcdf0b16c5f32d923512ef733a45ef9353ad4e2f5215c9dd6df0ac9fad3e6f0f8d4749f57bc06cbacb5f7eda949a0b55d6f2ffbcbd7edae4c26d45fbe5ec837f4d2b6526e6614290b24a8974cdc0a748f11151845f82cdd9c5e7053aa0a9cf932f7683f2e87d61ccd394e0d3c99e2a8bc1c968b96fef8474ab930d5b9b3e22d587a2227cb3f3eebdc045f22bdc072d7ace627a8e71a3b08e8b64ee151600a8d0c17ddbcec80fbbe25159413de313b019cc988f7ecbddefd6bb388b82cff8170d274508133b2df8d5832b5960fa5195cea27e674d03076c1e17f1ba7149e6058fee78425eec80143331c905174c6a68c9f16c0bd7aaada8a4081e0e15121aa9dd7b16169db6372845c6538e9c2d2c239973187cfc2fc011a5a6cacc01902b4e62efc2bb6b26c3d5853aef9554dcab659a474d00aeacb68fe65f057cc7f880e50a08756ee5c522ae16e0a5e6a952b2073bf99aa5a7bfa094d6c7c8899f4f21a65d1be910fe1c44a149cecd170e308c2667ac52569189e054592463ecd86930cb6283a4b6fcdb50dc22c3eccfc53fe7fc7d7b1ac511a2594f5519ed86754f310c67ef2d56fc49a5e5c9c1a55ee5ab3b56d9be10848559ce9dd15ec54dd71cbe4f433cd17d382ebaf4123e42a47651ec7bdae8e3c413c7d4fe5e5740d8b60f6c6252b33fa481aa774231b5e3795b9d873a90e31b1fc8c607caafa5787cf4b3296d67d883baa8315a33f0f38d58604298117fcedb0f6f805bbc50411cf14548465fd14221de736acc7b218a38cf1f88a6db1e8881afeace7dc702b95d244acb12deaf2c223359e5786fed5afe60c73434822a191550a7c064f6cd43f379adb7f32f7b189ed09b547fbd11bd291611127da96045c37f242b5d0b5c50916e0836a2abc42defe4a1aa9f89bf7ca531e8afd215fdcc327d0702a930af03c671b99512be54cb887088b551d06bb01732a9eaaf6e3f2a70bd2394556131e7764e981573e76587fbe4dbfca2d60f010ffff4f3d6ee3da80d94c089438f3999e03fd4f7c336829e264254d9d97aad7a6da3d3eb52b43ca934cb2895b2b3f1d09a8e5435bf7f615d88993da5fbbfdad7e7f57ce31e51e4ecb43686","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
