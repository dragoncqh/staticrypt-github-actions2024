<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7185e6536dda92a76a6ff223c84e30350d7cfbca0bd81e603383b7320ef5de57e5edfad7accaf1ac00a887e07d6f5e2fed0b58881fbf58629117b3e22a106a5a28d1de2b8a3eac1cdd85494141e00ede5ea2efcf65346f2fd9707df57e65c3a9f6916235841bd1b0b20476e8c348c9cbf972585e91f4888efe2187aaa6c7349bb7a8e2eb65b7df57435aeda31332276b95e03580a21176f8a7ca851a3ffd26a6bf36e0787d22608f4936ed4355419592e1e9aefedb5cf020943cd1f05c6000e1f345dd865de5e5a7a89f678ccfcfd574e5a7a380dcd88535be1f1331c109b5e44ecc1978e91e334bd0d04651ddc16d9d0a6c66e451a635816b7de1007fa45aeda86f3fec0be2404e08a3b9cd4f3ffb768c478fb20e6a64282cd928cbfc495980172847162e76c5c939f636717825b1ed09bb4f9429e2ce43c81a077207505af554e9019310653b62dfe7e1bf1a08e497fab1b0ae793066efe17d16b6f3e629c57565fe7b38946b707896c54057d5b856dc17e903a9f2d0a6d81e3b8567c5bc7947c5fbe3abe9ee6767e79a971675728306376ec9ae56b561ceedfbc386d2983b0b4b2912e9c9219d9f4b09495ec3a33799fec7e67679c9aa350f70e8168634ce339c561061cc06575bf42f35fce01a595f0687ecdae7597669d9c53a30e9bcdeed0e3dacaf29a382507763f1f7da6ac6a8b95683833e19c8cf4e0dd711a671d54573505b0366b53ceec38bc1b36fb964e3c1934f93698c417a76edb0a57070fb245ed3bb32b59e9e43ff36fc1537cf6d6f993a6988e9e0b1421d8fd888bace64adb66aa2d8c3c3231941f14077dd8e519a89ad87b62660edb50b1bb984f3155a954612b8ba77bd47c7fc0f864aff7880a3f2171bf18af6c1c26a41fdd6e6dc76a78a135f8a7e7c97c20894eaf37c40bf69b7f33b6308f0fb79460f733c87c4e4029e78527a2a192d56e100afb9ccca25978064985c860a1069007b0e4346b616d8a388d0ca03238e96f8cf2d6f06c52464a991004d065084a9afa3d841c73a907577af9055246f93fb9afefb4919305a427ddd8fb4dc2cbd7db2c259f1a5297a578bb67f330a2c58377b6f86a68f38581de1d9edc9133ebc4ad4cb6805142f48a6e811ab4e306197f241b662074bb244574f3c2f6cfc3a60d7a74101ab5e1eac618ea0bb12d647a358f4905db84364f2a53edeaeaae54b7a6fd12ea58bb83895bcc1c0ee192a16f24f5719ad0ef7b1d3f5e01f86770c9b1138d53931538c409fd4506874add4848e57e7232d887c3b527443bec1e4c3ad1ee2646a97c7f870c144b0696ff5a7cb91634a0717fdb41bdb73b5c9863b0d6e405f8f433909713db703a2bb6f051569ffbbf568edfefa8e938e588553c06df08a7cb12f644c3258ceaf139b94506185a8440c6069c83364dbf54e0496c6919d24d3aec9c6b5a91f9885cc727af5229a469c2bbaa21ca6aa49669a059c55f08d752b72cf10cd4dffd769d401a50e1e12f638c24050d3ea9be4951da6bc119d1902727952294451947763925b39afafe8aefb177c2aab5064c40bfc20bef62efc56c0439da993e752c5b9ccb02ea730c5ddbd3ed8be9b14d89ad3a74a62e587f5e3bf758969138669686857d63771e0696ad2d96abc99f7e04defe3058fb0f76872b4479f299338496122449e7014369ec144edc8b54cd7f04f32311c71ce64d3c559eeacd58fd697e4b73a57a8a300db9a0cbc650cc77df7bac72373ea6ae423f32ef8ea134fda7cc7cb20d6f3cb33327ec528fd5ac1582d22d7d5fe02cc4d23b8732fb012cf68e0eb39e9c7836192d3bf6f5f880f0ea9213b84a10ece98f9d2206ffad7acbb0c84b5217d3ca60c6bc70ffea14deda05d9f5bdcd543d9e8772a6886c0fa5f7aab476b7c87cbedb757f1e358c6ecdb3f1bf29c0340a008a71aa2ea2bb30a67b72306662448dcba21bf2ba4621f61063e6478d6ae0276d25c4966ad953e5cf6ae0b977edc166682901410124e43a4f34390f47dad64fcb1df0600fae1c0eed7bff8f30471be994f39d6eda6beeb2e4693194341458e4ce8447f77bd79c3d877321b9cb677e23f1bd8d7bee7de127f1332a74c9962ae1b7fac898907941cdf36134342a840c99d171ca4bebc11170a4314179ee4a86536f8dab409dae60c5c1163fbb9d09eb531956e1ca0c662fbc6d84ebb1e4640272714e5df8b3ca27bcea28ab147698a40d45bbd7b4f5f7e68f781af26ccda48287dc6dcd2d1b2fd8427b036fc9df016174b284a7793fcccfe87efe87c11e9d48b38833fc8cff22668f6cee5d286f606ac7c3a679d17481dc3ce006d9479b416aa2897a59745405348dfc01749eeac1af51f8b99239111913e9de4074aaef665f224e5b50d0e19d4c113328cfb120aa03b5990e79c715c2089224db95baae3ef27073c8f353d0cd742167280fc06f034d790fe83e17bd5b5b3c05f7c78eb284f45eb450522dcfbeadd0e071c841c9b6a101c158658d3ded20195b175555c76507c0ae7442024b73a1f0a04e6de23416c19d3e8fdcd21b901e6e379cb21496b6bd140ab811a39061e93897bcef0ec562a01a9005c2cc65cff9562d75bdb694136f1f629e611bc918b42af15f98954d54faed11bf92cfb325158ad7faf3c4172448f42b6c412873ae256dda67584eaee0dd381839bed67276678dd5dcd272bb236b40c8ecf11cea07eb67e774da38ce7668338bae39f8686afa87909d4da736aa7287e6e9ffef551284e2099331241e7dd1c0bb40020f774d3d10887e06091d2d35463dfd628105ab8b4935fc39fff3053e6a4575c5efcce1cf09b020d7fca0d73dcb4aeb55a7cfe21e41b4fc58bef05cee087d105a1d10d85dbcf70c9b8304f7226c594449daade37ff2ea21f0cd0d4fdd00e4c1af52f2f1e7266fbe1ba82f7829881e54cbc3768a3782742116157e36a9eed1eb7745f08b8ecfce7088267e0b95a86f254c5dea10992452263ba4c82a936d8f91d67a54cb3c9fec53d519bea77accdfde7aa376f5d49cbaa853b8d90b7213d5aa5a662986d81db697e9c17b72d09bfb3b94fe6a00aec7b9ad32c1fe704ba33517fa4e3de534634356b60e6264f1799c6525b90374d173e4153c661134cabedf15d15c4fb7c5870072edaaead807ac2e17b0b625369ad512bf8c3ea6f0635d3756f8b20abcd6ababbd83a5e9114c2154c655eb311eb1894da93da241422e326d8902c0e68c0cd6a3507d2012e04ac2c9605b8292c5617bbd5158fca24115c6020f2b4ff612669474959189599fe89b67457d0a926c0d65d2c4e55b7823ab9c380af481b77f714522a5c77a797856e74c025c45274ab819b46902e19c7b3302e2ef5c6c634431f6b51de4b89b30b12d72bd975089b5fe999701b66829523e03c929609f9d1a518d263f5f6cefdc71eff6414a06910bd9b70f3faa78c2e29e935f713c495c5247ac702ee2fb547c4ce8a4533f765c169533c3c0aff4a1d5901ba485d51185c78039cdbf2c14ea274668f87f771554569123c5880eabfb67b3188858b31daede6144918aca97ee4a167eac4a5edefccbab085a72bda79986f077c35da0e475e6a6606e7e7bcd8b2c895d1dbd04fdcc294c365cbfdd9d2dbe04b18494b4aca64414f74f2415f32309b8dbe4f300e52b8a236af22f55d71c0d95ff17828196901a967e9e65f012fadd02dffb7a13f94df6a383250330fee1fb580e4ba8b27ca9c2e79262f7cd7162d7366893a9f5d95d786c2d2d226a42fabc2226c865f31b0fdfa78c2fe80d3b403990426a97f316d97821bbaaff71e436df88b40e7418a6102e9c25f41693d5172949909170e2042ba31511472553c1237e5b7f573adc01ff5ef35c753c082967b074872d39b453218e316144602743359f4e8cc478602f56ed8dd8020032767c248735c7f2a0957f3aa3e79171581c4f35105e8293d32037743d4d7f724f057c6a632dc1feb80aca30c00d1087473b4300964772a228dc29e6c8744a0feeb62d0d26b86777ccaf15262d6d18d92beed99070ee005cdc258e6ef11d72e644048b631927af8d8798dd7f34f831718819641096a7286b76a0f3f5239255a6c5c137188bfd702932c710d8d86956d9079a09b941cb64bef4477b924aded3727262e67ffd8c90cd776cef415d0f85d8a524602f03573f0fa60b82de1a2c1a703ccd1f564bc776f612e499ca07008a2f27984cfac57b94c088a1e3d324c499ec2fad644aa5b021f2d5775c1c0c4a9dbfdd715d64a8162f9300a582c5d14822037111c887ef3a0bff6bb3c3c790f7eed1d43880b2e28703d21425e577d75a8382ffdc94f7d052a2f6d82e8cdde020a401dfcb2ce24cad1ce75ed3b93bc727dc6cfaa03e6de1633952caa7a1a5d6bc8fbd776b7aa582bae57d60e466de5bd38e23010f6c8baa24df8ab3c3394b44bee181c0c29abd82a8009495056bd042e862659723186a266482b944fff9bf962822672acf4465ce31b1b84391f6808cca06643ce336e74c6773ed7e1e205bb6808e14ba1f772d26aad894858b10056f67ad2cd1602881ce1d38c7b5001f9779cfe8d073e6d70024f357de199960b74ec169264ac4613c3838db2b2fea2abc93a95e1092885b66d57a5c1628419a1a57b34221d55a5a8e0f87ba3dd7d62ec379d15f7634275c5382f135cb256d1c612d5a846138ec863ac31abd57cb313777b308b0b911d047cafc8b1766365255f1c630334cb7f93cdf5106eeb6175ac805a7b4d38cec25bc268226da792da9de8e5b735e333c4846b5134d370bd6ebe55b2147195a287a69fa985afd15f684073c1b95411c2163bd20f3be14289b4435ad8ed6469d34a28c70d6a487dab68842c0285f4a6bb47dd569aca6f05b70f5dc2464b7b4a1e17f42c6e5f00a50a6968519a2c1484b0aa7217ff7d988f71f2ed6b7c80470a15333cf6c513cb1c27249fdb4d3534f32455c1b73bec9febf9206284ae3be44a48aea068956e452720fd790ba375ba85885f2e94d9183817cd0ecec0daa53270bc6b88b8bbbcdd325a491dce7c4eb276442154ab015531f3a7514ca6c104583828ec92cf378be9504818eb16e679b20cd839c7b79bae2333624f4544cd233f538cee09043027c3e6086c75cfad10106eea146d5abb40bc2075e65601680f6f1e9cd4d85d2fe3f7fa4f249581f7f461e8a9a874baffd0ef9c7f6c26e16cc2d00cc0b21d33addbba16c67849bbb6e20f6bfdbfe465c89d756c8fcf5a706d391af8c7788749131e009903aea2a47a54620e7b6a885e87d32de7585308ad205d2c54e6395a6436cb4f028caef7cee5a055ef29c6a714c0defe3fc7598eb636b5804d150e0703d0a16674d3c6afe1f35debbf4d37e417ffe97aa6fc904b17bda98554c5cadee595a5c54f28ceda9f1c158ba1cafdddb8ff4225ba043e857469da89ce54b82638e80b037a1263b9eac0be9d6fbc7e8364dbf43780bc522e92119c2886bd78a9b138cd96bc925bd852fcdf5419f17ff3200758dbdc8c52872fd1bf18c4f5c280001406d9e4fbc61ab9fed3869fbfb331706782b88aab61fb68e84e5154706c4d47caee89486194f5aaec78a1069c45dbe0b9fe2c942a69535219587705d29282077a2a7480f91f592ea47be8ddb22a49bedfa8849eb7bee737d8e1b5b5372852d7607cca523a149751ed78849bda4d300d1d25081b05fb291aa5f66b2728ee4a0ee22eb07fcca98adfe4a7f9ddbfe389217bd7419dad610a54a39bc28e17cf59ed33ab9104abd3be057bab1f8d6098a2e7c17cc321f28df60b3cb9634a5ef40bb0cb1b68fa3ba2365bcac6fbb8dd88ad75932231805829ff7c70d490dae7d92a47c9c7ea6d5cb7a0634a3e58cad8b26f0c74a36094d88ffacc6b797eb50c7f566c4f5702285796d9732ba80c4aa6360c3c42f6ec136390cb27202c82be2e48e093eb62e83aa5547bccdcb6f372ba07baefae205ad669140fb69a52be32016095a3d1d34da798d067469ab0374501ecea2b696b0fa90290fd9f2aa1f85ef0ff13ea053ce5507e8052886da7de7ac9de44d6d733929ba2d540ede6fcf36cb5bf99acf5269d6ef98834ecee05bf2482d832dd2bbf676df58fd648175c86e0bd828d14ad9c33a260a7cebc26258aaa6c22f6b9ea24ee46202f55f9bf194f53d0eebc8c05fa317f0378d7db7c3214e3817376916bf8f9523cfff8ba7ba4aff31976fc345965ee06225c142277ef9d236f6c0603e0aaa5fa4d70035b892f2b1d3a24dda9569630b67b738c02e25933fde9c21776fa761585a4ca9c1e627a3d2ff007ac47e658c7df28b961f876f802c35293147da2ace3a49ff5e40d798246a6fb95cbca2b604f44fb0873c7f3a2951a86e891927f6f9724401436f869487526c0808e5ba59ee6f5ad83e819ab626a3aea0ab95727cb6b5c3559b21447f0ee7bcdf01f92173c707194d88cfe6d09ef296822a995d8d21a1f1ff95ad71087616d9502184f7252928ad179afa7b9a923ab000b473578918eb8715f7f38c71a500af96d0b58bd0a256cc69c96de1733ddb09333fe8a2a05fee1f0fff9ca89be2515548e401001ef103073e9cdee0459f167dad38998748f931c2f4415a4e34640324a53b851c1d0e1bbbf85ad3338578b7b39d1aec34dbb829509729a4a96fc0705c3df7712104c365416246ac2c85f44075ae3bc79eeebb245b14a211460e8d595d3ce8fc6a385de1a4d52bbe84e9e53164c8ca1eca5c5ab12bef90e245a3813ead0d98054a1469c9a7f14c9213b743b265963b5156be6cbcee858e2f9169afaf32af97419868d3e692f74c223fc4dae14d4e06de64bda7ecf3ceb0007a3ce25ad70b003e5472ef47340042bc98226e7ce407e65833dd9d5153409364f8e446801c073b4dc30c95d1bba8926ebc7de6d19eda128001fd13267a5112d3bad1348b8977aed3a439ab4df5135d4d19e9242a0d397d363f42baad58afcf2f8148f423507e233e865cb30a6c2121fa49ff0e9c1432f4be02fa605738242fd30afa1c67c3be623c3026c4fec6e8ba3ae4b767b691e9a80190f9e9eac678f4afa8bcd562cd9a7a86c240da346aad48a8dbc89a6857648606f8553dd4859e8f54a1869941a8cac55146cc95c8b430a6e147d4ccb98417dc03db16bad17fadb6d16ce035a0d692d0fa89cd0d2201e0a83d0cf407575d5f886e8f8d58b580d89c5b7287f048ce5037c909670a0eed1a840f56b6f0d895f135a6c067699efa5d1a5ceff6bcf54ab74b8dcc504de8b040ad01997dd4ae6e14af36d9c5e8a4efa3545e18efbed27958907c4dc3fd44906dd33321dd29b0f626e71962ea233f645ed8e130c2d29b1bb7923767935b83d74ad6e8dbf8a1ea1ea6b4818f1ae035482b55384ace89ece037426506b260f18ba1123b94891ee7e4ff737169a1bd2ac61115959977bfed6395dd01557440d163ca9e4958c1c7ff151ddc5355d169e7174dd70b97df37ee2a88a1539047e0d2f0784bb89c04c50a53aa1fa26bcb32d02166caf887703dba6a0e7548e6c8cefff0b134a9a6bf77f2e11459847e0bcb5d659f574c1fed3f783d45409815666d0f887eada00b82e88a620c36092dab9cdcb5bb792777f8d14ec72367a355efb9049e3c92598e48d55dccbc15ea249d6ecb7d4de16d3108ef5c3ccd702280480672b5f785db5cbea3909ffaf937abf1fb7805ab9dab1b5ba79e7e5e17315abb6aa1fbac42f72bdd9c8d0b9e24b0f72f94317654b9e5063eea93420ee72a16497e2764507539d01c827e322f1a5c947e0165e9818d79c71e56a0f19c6a054e0228d07cf781eed06a46732644169ff06508c378eda772dad87120ec3915f6db18e93060acf346625306826086d365335e687b45352e1dc2437b88c47b424432d433471235757f14ff9ea499010021e4cb18803d80e1a617e2d9707cff87f0787b9602739861737d08260034c5b0c53dc1a50c101eec26c9052063742e8ce9c0d309c106ecc023a67cd61160fd0d38d721d1c613e352cba6ffe62b8df0846c684da868559609b8f9274bda5e3415a7de710d9a2a661b636031b2b8040db8e5ba9743d5651beae07ac908519903e08b1b6fa2ccb8df51f26d5a8ccac0068d248d6f77d960076cf203c38787dea9f2e4fea65cca097d7eb2759928a9c5ee1295ff51787adfadb17516cf6c74d69f963382648a658e6f2d6b5ecfdf44b1ede79516c211da3d100924dbe6bfacaf3d17e7dd1e71dba5baa323f9d2aba727917c56450b77878dbddc30ff42b6c2fa2f63575ac35fc5997670245643000e5c10f5c62ed37871df9f682b7eb8aae812defe33b15b63dc87c1644f9513a19d4c0705c1951939650539b421d145ae92ee2077893fe93992b8f0cd1881142645f7df390b58f113a832b7d620f1b1b2fce02b6195fb00a311a05b1b19d22b5281b8888b3c54af9ed2a37e55b39f2b24c92209a2590bcfed4d59da7e71a0b8b863584227ea8ab3af35f752dad05ef30264d103c151e91bddfae23afdeb523b60f6431cd84e6b256334792b8c3c15ea19916b3f98559990e559870338c06dbded0e5f1f744e308bf25e989373f76682e4efe2fa46ae0a1bf4be4762e2b8e5ece8fed5255f024915a1b3f870cec7d1740430077d935483d92220a1d728033f644fc8e7d614cc783b23c93990efe5eca1e7929fdace2dd05249e70945e5fcef6574f0aacd34c21d5cf57f0df58619fc46d6b59be15773de8e83b293b04902d5c8eb314c0a61ac6c4401f1c6b56d8106fdbf15ecade517b0ab5369d2679b502b462c86763fec85b8d70711d9680b70ac9c7934e7a4e62b009dd81032d7ceb0d20178978853aae22f58f43cfefc2f1e84bbf7474b35d5d5aa52acd39ac53558f6e8601392755bb5f60237bb9fc6b33e92006d800506410efeaa6adccc6c324356b1f7870c2b74b3f418602ddcb664c0b8804f3eb450a9a088817e8fffe62163e732fbc01abcbeb556cac14382776ba9441b64af805c942fc55cc02c83545d46ad5b6e8fd1d2844ac91d17a532e8d67edcc5801df1984299a58e9dcaf93bd98eb6db3139e47cacdfef34a6a1bfb6cf24542e30abaa1fb4684d8771b0015056afc5aa70f2a782946047050804af471410488fd88419f0edf2b7ca8f23e0df1874e06c5a2a67c08e70882b4d83876bae68b690472e1158ad7f3625dc5dde5532b876e24861e52bcfcff04d8d69a4a8b2302df33988a395880046798aa8cbc5411c098623a8d5ce24a13d82261e316e7667339efbc071a110e253d7818df0e9c222b026182ed5be2bfcacbf4818f93b984715d4c5507e83401ce896590923ed393875a3291da6416900e7e49ba9a0cd66b7e1bc7d67f6f80184f7369f4c6d9de7fd8802271e1ef9e0548cbcaee44cc36d67d51271cbd3a0b312790a94dc4a5179019e7812ec7c71850f708df3e82d16d4cf39ebc17a683c73d2339e3a11474a5281a3aaec52d7ad05b213959dc60be669e075ee8d02a034f135a1e30a3bcdeb4e17beee581e9827d3e1d9c8522fb7dd79d1ddc01d50e67d45cfdd9594053ae599a76e122a69412ba8af3d626f43814ea80ce914fc01752ef191a6a939ab8c4a7ab249f50c3c387d5b60b1e63f7c302c26904503c0c088d757c581839bbaf13f32a29d39b591ac41d851dd3d4f83f84d85cc922c085b0a8ba0ef20e335bf523cb0ccc528c78f5663468e5a3a85f405e0071b68a6cd9bd180fd0be64c462842895713fdfd6f57b4a373d3ba331de3a9d4cf88148b21b9411b0ef9a2bc761155a4d79f08792db9c3c4d50e0c65e4dd73e01e14aae82180a249d52177c7a87e0ad0005e0286c5b43ef5efd16008219f035d892f951bfb6bfc76a399e2be59ef2fd61d5b436e7c57a0c51afdd755992d83e16519b90b5f4872e13d4e3e151f71ad9156c731d6b7540d21f0240a6bb7f36f2a35ff45e887fdbca125e763a6d45b41c4d3e668853c7a3fcbb45fe7021a4f7ed3c7eb2f07b7d6b5e08706d1af60e4ff29a2cc6abb482096d0a5403d6a3fa0e7a9480b65adbd86a9da71274b551cc8d0d9ca9a4950fc8e1838f4a4be431809c1bc000cf70fe9dc7b51a3b7385bc0334a2fb0f3f71940a5de00aa4292259f06088e41e68d30446d118e8c47cb30c59f83ec3a6fb62e5986c23f32f0ce0413da63bb1503bee186f93e8e4aa2879d37f2042c804d168929314b876bb54d01a71303f7ff2b63c59fa520814d6c8b7468a540036b9379fefe915c3b135cc0f061aa99e17b25dc3baa5a27e8c63a2d3b56b416d4c396bd80c64275a8ffd40617967d538a723fe54fd4fcb700ae441c533a642284e95d3b6298661e4528aff83c29df7b325c27b0c54f479ed00293a57ddf6e82d5bd5c31822f4a083ff781ba25dd1f835f439170935bb92fc7def2639753d47c774e923695c5b7e489d44fc45a1e47d0ff014cf7543a558d43a453d14328b8371a5d433d8def75a39cbba40b0da755ec40304c9c36b11f0d1f4f6b3aff523bc84d75356c4aaccd2fd635d99b2ba8c3e228b3043b66cef23c27bd84f2fa372d6019abb2de457fb7a1c2f31c781d933bd025269f5c0c70809b8fc6e10dd2d7acb6a8d5f1d9bcf168e2069a15f44b9f5c5c9ea3ec4553ec9208b1b1114627a33246d442c8f660d9b3dcf815f13c175131cd467fa2f040d0bec232b5b13a9f61136b6b50a100ded520fde8463f32fa5129c5c6fdc080de713824ed66b1d19cc88fe73462210ae34354496d3d3d9175edebe752783b234366c13f765cb501dfef4775326eae491685ab52245b988d6b084d5d533b1e7a82fe5802a5e8e4bed905981dbcabbfc93975ced8681abee9935369cdf289ac09ac3f0c81770e471644beac48a316a30440c2d427b9f686dabc69d37fa3c632ac3e1bfa8042d3ee2c795cf5902432fcc343abfb2640cf46046342e0af075dc22731bb422b9b9e3ee2be3091b119635a6a9ed660284ec86ab312c5bc2d5e6c0cc7d58cc8ba053056d177a104eb60ded3a2e2b998f886324f6eb54d449f29f15fa3c38a6d1c3b1fd3c14f33de150a0e97891428efb2a2a88a03c3fcae5c18c795e28921deac3fb1bd4057d98d7fde650f6d593af1e8d6e7d710bbb5c63bb434a871fb762f87a177f22a6f63c5c30a5b069b61ff6d30615ad67eeae119d3b8d3f8a7a5d895109ed81a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
