<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34f3063c3b3462a329a7b1ba7fb46a64d283e6b4e89f4b91fda82aa3a12fda4f84b79e480ee23f860e42db9aea2da3ea01a66c1a884c517e4d77b4d337b8b5e81238b313a24d3a8ff5f718f029900db9f14459e4bb6c9950416b75528110cd30b0c5e0fa9eaa863aa0b37e6cc14446e1565a1c61803ffde29b820cc4558989161d09d4fcf83bebcf7e65fc45150e0f9d0d4e0aebecf4070833f78b59886db4731a353d335b78e1e683afeaaf428ce398bbd544e343027545f7fc6403b596862a6463d0645025179721a9620445ed4b60ddaf9617a92bd6868057ec9027b682ca112b8888f92d5cf065613a93cb183f71ee38a7af9fd4ef51c0b1d25cd044a2c14c7a849f79e1b00ed610e3c939e77b246bb1879c2db0eb90e5552717ca2ea8b7d15d4a9e793e9c7d08a61d16ed8ffa471a323247a4f71920f12004d1510aafc62bca08f82e9d5ac4ff997102ccc39652661a004106b59389c4e1386c709b4f547b8880089c17cd8dd8aaf5c9a090053192767ef467bbc082e9586fe301c83f28f9d691c6f7b812508c02331e5781a3e2138ac204639add62bfdbe4d3996456f5ddf0b4901c5195b9bee398e9cdead8eb809b9214ac90c7345268173b74932584e22623bdf31f7371bf04cf1b6d2f5d76fabb2c8118cb784a692673e6d31b96fdf12690ac21d70886caf63211a5226f5c455abe6e63b4810c08490ba96b28ab3d53ae3e62a377ea1d5b216362803cc2285487a7322f0869211e51522bf20e59c2c27b7ef19dda595894a426d129cda1f86449b3dfb59a66ba301ba881c3f8a79f0d821015cd183dcd5f23e5e2db9d991f7e90fb8454a2fbcf7468de4bf6c222869b7564adf5b8f213f4c4d6ed9045a3af7e75a1be3e3e5c79fdc8864cadf250f4fb6aad08a7427e640577d2edbb9a26a3f20372cef4d26dba2fb22d9630673b4671727f58c868316b6025ea3d5cf56dc80e963a8f57500c54da72854923662f845af2c019dae1a455ec2a4dd9afc66844bc9696219584825e05347e698a1472d916170ec8b5024a0e2aff31de0e157706edbdaec81380ba0d06289fb7f7b65c575e7c23c1d851033f2313e084830225756df62bf02012ea30079bc600756ee78a44832c6b9ea6eac6108c048cb9e7f8b8ebab07c15eb7835dcec526d3c7239a72c2114d20e33e7aa7f73ef3451677391f7f91da8507e599dc4afa9e268ab455bc8016960e31bbf6a9bcccf451044f4f1c5417b6529dcf35307ef90b805c9ae77488b99d1232a50039532f8a38e0589d547384e2a4eb263244cbff1f209c7b3fc8752b7add03981232bb8b116bbcf1309407074bf9858eee64e6665c932a4e0291e53f104c067c1d2172139d974a2158b56cfdb80f027985211d2d85e6496a836d9185230e503552615877897080ee0bb8e0001eb09f14609fa96a57e72c1eb72fbdda8e698b858b4ce000a66c2df6984206624d42b6ade2f8bd0b2f52237590d9f211b0ba286662926fe29dd08e2d1cba54fcad16e51080d902f9b8ff5dab2f320b96dd6d3a72a2821b1f8661739fbca9e5c0c00cf62f8c9f7cd48d74ec4dab6e48de71ed16aaa0e357760480c0570ff75ed2021203b73147ace21020f33b41d239de65a50977952130941789201087be9b887da987f5718b5f39832cf3713dfda32edbc055e590bcbee450bad8c9eed10c079700cdfe30adca2075e2cc9d487c38e2b5cd2a363f32a985014f6caaedd13fa6dc3e3e37a146290e4e60dceae964ddb1e9ca21775ecbafae31d4e288cec68f8d03516b14a12cb948784113174f788da260ef14ac5ab6eb088f932413bc00959d4df03aac36ab8f8be13df4c66867daa28460b814ed27a9c14a937fe5b7f5b8f0140001c4d3bc84ef15f3be9bfaa8014847c6d9b4204619ff2fb866102fc2997d37fe75180f22711c9e65b3cfd8d8404d50a335c2851363f2ccc8f582bb16e06d29720e3565136eb83773309cfb63ba78f76049d0361cc6c6cadedc8153e85b0a79e85563ddad1788deaa394ba132d6e795e23e90c1f2f9923d7cd2c07c9708619d4a8f4a5dfba77812f75846abdb264496cae351518e0c448d18dd6e70bcbc3fd2b950c54dd76baf2a578abe5e850358b6aa2fc5e1eee92ab6abb2253a46e81e7e32d7731eca69988efd32e5f870d99557ddfb8ae5a6de51ab59b82c0797b24b54f43997acff5dc4943567f3c75298a47424b09b86f6c6aef817778329ccb2a6f7a046c730a8cff67d1ed8158ca27b64da00d55446de1706475385c99fd75cff7c155135b33cc75c4257f2abe988be4d2ac543dd6310369540ad7d2cdae34e73ecb6f639faed03e55b9c8604c556c3bdc1d6fc991f97bf8367d7e136568f6fe4079ce92e2881650b0db1500cae0b75f29dfa990ce689f322f7179e713dd21fca36ec2c9c4f2562ff88322d61e79a0a74889c417e91ce592d35077ec971a6bf00458278459f99104112d6c963bf96fcd01b958cf062ae747ccb5ce0e40d9164702985898647a7d610419d131c5cb76f42246c410d73da7659ef828cf4de319d0f20ed5efbf62030818620f8a794c7612ac1bcc9ec8f4fb7311c9f7c2fd20bfc35947df7c8bb7119cd556f6fc1e466157daf590c3d477bd3a723cd743e4bba3231c359d59f83ee2c06784ac58bbfe4d61c611cdcb0293cfe57f15de15eddcb96d2249766c4237772612caebb80219e25585558de6f6c1f3b8616063e0d4c86066a4e2493dfeab06255c3352a7d89f45fd40025b413e3bdf712f9fb9e2cac39ec2e497163507d3ae41f6aa3950498943354e33dda67e5b8441e4643e20449eb8af8cabff99b99e0e7c349b8b60fdf19d2f69a8071e74a37c5272685607969574d64c5ebf986e84b63ed2d6049b78c7b7ccd3323492795f48970d892d16f16dab2f1e0cb16cb8bf60861ce59d33fb759ea51d45a67e621c9175dbadd0e655e6e041852248bb4924441eed0756a88ba4e82b470e9887fc9f0fd813b98862d0c6bb764f5506066a300182f158c4c98259202e2e628e96822bda09be7fbe9c9fedaa191f5fa82801fbe4b2df42995e78cfd263760c5b9f2d8e504777d49cd40fd4954698ea764f3d5a5adb79b90acbb12e950a4efcc3589926ceeb71d6e51703513d4b7b3410015ffd68ac3a30fe5d4ab52ef15e75ff9d3d4cf3252ed51ca7e2a10dfbec7b4ed0e7d10b4f9278a3b71ec016d5ce51e512f4f8d8276f0d620deb3f840d6cba44a29aec726412b0b782f266552ecbcb62b4c5cfc4b947782bfc7b750581ed2b7a579a1b019a44f609b99e082e5621c512f573373d637e74b3792faedbc3d1d6de6503062242bfcec0e502bd0c959c9fa015345a15ad11a7982e58c903a504e8df4e8f9862244ebd9046b5f4071a4cc23d722f1ccd0dffec2b12eb165397afbd4105f95603a7240ac2204c30a152c66474695ebebdd081af11bbcd324ae12210d0ddae58d51bde49ffbcbda72d60db9d32e396b817a3d0566cc8ef7364da3bf0bd33d6eb180f9b371a99a30ccd399b53dd1be990fab4b615c0c2003964724bffa8fd3bc0651c3df7d5e83d82d1ea144c05ecbc6042d20e51881d0805f07b4f2d32625859a59eac9bb9832666c28024edf29afe173a9f907567a89da513a44cff2a04773628fd70377efe5b2ea5e84910e0db84c08358c07523d747b41343b4de250daed96dc62cfb7a913b22fc7f13ae550b98cf8647717dec1510d076fb79a8b33fc596aadc866b75f3e0ed16674ab8c2b776c3b13de3c36b8e2fdd3f4aad07e9a7dcd027f615210257e51404412509aedba156d4e403113b0685fb5c086172b452ade508c1f417adcd4c7e0fd8f18548ad9ac41e9e3475053eee45edc9e18fa4501d5a76ef07afefaf00291945b7adb59f2a1247cb2856f9cebee47ee50420aa1695a7fb66a4bcee4c8bc5dc6bedd45fdf449166a05dc2810c407ee4d206698dba0a12d417797164dfb69545b14066a3fe02112d0677eae76d0692766b3c128850bdaea2e737e8f2faac4e09d50d09e26463631cb0d86fb711dc18a5b67e77bd8bf3eb20fb96ac9706fa91be6a16f7c210065079b23abfcbb0475e8cfc6237f94c4725d106b53802946dc70ae18030373ca346e855ccf7b7fc15dacad61bc5e62d66b12806dd25c0158434d0b3ee6d40ebf81a055fbae97501c091a2c67dbf55b10342365effa4f875f8c31937514a1d2ba42c3e0c6ade4692a47c2cb38ef95679f44f8d964029a4b6af7587c450154751535bb12fe0facfbc67de7bc8020d44ee28a7e26ac502032405f191350e010f55bd8f729888f95b64334d56e4a8d682cd301ee74a274a8cec7c8bae0a0475511ef04ef8c899b10e9cfa647920d34abc7eb21a85489b9aaa6468012530f54f71c4a12ebb21f84f48251558d7913b4318936058e412e1b7305f91d839661b4eb97bc71eaa2a99129dfeb07899edd2d1ae6083ac1406e8fc2d4cc4fae1e8ce68a8ff69f03857f12f1e3e78effb2bfa9c4148136e597e6174c99157d1da2c4f2113db6b1df30944d50bfa24310fce4f3cf55d12e4412bdfc7b4f851cfa00465f7b66df91be7a9673667142e12f7f60ccc26e1029d42bd9d92ebce269ed5d4ec2db39538969492acad3fad83b21f346621a73fb5128a39805cb29468c6489cc3dea897d730e0e7cf4a13adc384c34291ef5cd91fc7b37e907219dad693e375c21da11b6972af831aef5c421872fbc022da4df0165ac6b238e280494ff44db1619eb56e3c6658593008f33c886828c7875935a48385142ed4db4b6f9122869ee030bfd41752328f8d0b7864b2c074ccc34c85ff359ceb8b83ea341bcadde6036c95667a2c87a8b7e28cb7ac356dcd6f9ab6bee1e05d5350bfdb6107ed51c1f3bef8b3f17d15110ce2811f13a44c1606e7ae5e4993ca081a31aabc5587724e228903194c5150a28cd5b84071647eb5f67c5a741ffe1295f09d0640ebcb5f08cb923cf4afc3d65fcf5cb395d4cebc9954f8027ed05e749269c497aa7056e9adbb6ef278b47059f8dee2dadb7c162110d0aaca90c07ac2ffd577ee39801b36f1dca886db7aa944cf983db8323dd32452cc6abbf970e131ec1e95f2faa58a471695428a80fe50dcb1038beaaf1fbad5cfc74ffa851a2ee061a87c474979c3166da43e532bef030f201995da0d884db02dc062dfa1bfa044dad9b1e5ef9db8ccb2f926444a9dce17e167e9eebfe27c537aade1ff454014f43094b3fc29c382a8f238c05a58789eb3bc8da518b4895e9bc465715f6298024c9a3d3bba53be4f4ac835512787a545276b6b36ddd8ec7e05e6c9392e27facd5da872c586e46fe7fb2b2e0d46ba0ff3c19a38357b198121c594ad460abaebe625f5c9f28a683f0d69beeb50dac45dc3de0aece8c61b75d4157e39d9181faa370a00e88497070f9886cfc5cf8b5fccd6d62db913c69fcdbb382c6ca874fa552a6edcf4af13476dc51d3bb2142a22f7c6f9537f873d3799a31b00cfb6c18a77c10fdbcb0a39c891beb2609bc37b82302f7b2e463442cd63d783dedd056ac416c229d50437fd4289ad87ca556bb0b1693b9f2d7127804747ac1040e2f4d8c37457ff319c0496ad3f34e6cbcef5f3c7386fbe8f26b015cb7df9659d6a73c612f007279cd4937fd74e2a1018eb95811334a42b0e818877e4c4fabc80c96f9898f71b036b381b8a97b0defca629af122d42ff37624f2070cdc7a68dbb389bf550a084641161f20868f56bcbeb1a8fd469015463ae995e3f85b57e5fa14ca8a73e343ef15051be5b38e59fd7785cced3b2b9fc236428ae502b642307f123916c6e231e0fc0bf8e910d86851af5ad2e742b57ed51ae0bb0a0a4be13e293ec5bdac8a1b209fdf78f2aedd2ced15ebb9419834c632f2d9c54b430d4686ad46a32dfb44ef03e9864b1d8d88e56e18e624ed8db2cb68c97b93e1d33f43a7af4f02c6ab9eb4d3149c49c11c5b404a390c0ad3c19faa1f9f997860b5f4cc5f3822b5263e09c3801afcdb76953f76ae670263aa352eb794d02f360ff8e709838611903081b9940950c9735977e0b25ab4404d0729faba681a8bfef2d8f9aae8e650ff084d96653e52a2f32288bce697b1d2959c3b12ce7474954190f93b2e55b1bab457456011d9709798c9004bfe81a78a76cdf65d74eb0dba1be962360c671c2786ae17ed96113a102d772b73c253ceb93a92a8c9eb327cf2b59acb546073df2ae679b14c73e5b736e47a672f8d26bae0ce5a9752e63926d946a831958743ac4f60ccd6fe5b17a634c87558e3611dfc5ecc79fb3fbeafab4e79202d2d4068e128fa92f97ec39b593428e839e9dde738e84779870db4dfa4fda0965b84514d1ed5c794c1e0fb1c30a34c77e51ee47ec257e81eba4783ed2102d141fe46a43700f2c7ae06e6fcf17905f4db280ae41ec63dc570789d0bed31037e6c92d48c00b11f39af17eee961b8d5f2b31c7a3f6c0e732756f47fe2bd2af47b9ed7029c164f263ddfebc459051dec0d231b11fb2ab3476d06d8ee8b0bb9a345901d43001328f09c8ed2430b7f7937bfdd3f68ed0878b58e53526cf1f82cae9a7ffb7bc702d18b008c7a8fcac7bd919774f49a7147303ca5e91853ca7168cf54f9e425d2001337668f103838f765678d889bc68d20d2e2526a5acc1604fe186723613503d18fd47a63796b5486d35c1be352f3e6888aeb9f06309d277a201329b8555985144ed84608930039f63781147f3dd75340aa64f0b11d3ad52f6fb76fcd45f72f6125ea0f9aa80aac9ec261b66eda22c31e87f4aad9f54f75ce686fd34eb3752ad1916e4141817ffaf07853f10acc4c3367c6acdfc884a6498014ea253e0c8cd8802a5c4db06572dc665e48d09e11d33f7dbb5adb7cd0bbff6d7ac8ec2586984c43a4e9598647bb935dad0407706b11c83a606474c0c9bf1e39e4d4cbfae195962f6089acb5eaa22e31d502a1552f3a0d1b08026cbd556a12d3c3c3b42f1bd0d3f4f4e1637309a4e9c6e827a3bf9e4ef947ac73b5fd065b9e4567e82b0216ca7dd62fe54b1368c56ece787975f70cc57f7f7dbd11af1e953c17110b284cec9bf8caf22cb2e80d8772b17530a1fa9c44a42daf5777c472de5406d60262f2bf1c3f06405638f665dd18a613aedb4fdd6808e1670818d9bd2a2a2672d43a9ad9472343cd1f0d32e6d363f3290fc6d5812944346bef7d8ec6e253cdbfdb0361e145a1ea5a8a6398d1cc81bb393ae8b879f46ed207636e97c76d83591b59a4c71a79b09bc0787a175f3d5fc10254c1847cffb347a156573bfe0f95f817d213fcad9e71900530cee579493860c124470913e0ec832812e638da7affb50069ec2fc4cf60e106240fef959e2b75532d7041decd2bf3f2ac39e1e6dda1ee4fed1c494e61fded8031f511ef846ef7adc684535d47e0e534fb61977384240e33a068e79246fa234fd12bb64e74f44fdc3afc97f8d93e1935e4b28e2c0b948403b5057f31477e9a97fced1a2d755283927984a131e62ee0d61a14c04225ca88b733fb18001fcec094015429a3e8b575da03dd5fc0b2aea3e5714786c47fc20cfbe8126c43fb54941a862537453049e81a6c03f2cefca622929ffb1cee3b7cfacd063d7f9936263b85970920a9e3f5f7ea61994fb42e1f1b2f51d93497ed8fc31e84fcdc1b4dfd833bc2d3db7d3d7f28af28805b502e295f2c5c36fee7c24e67576069c4afa176c5e567c73485e9ae16f742c732447216732cc1884ac2f097ae3f56ee34dd7d2cd847fdd6458d088afac2214ff09afeb9aa14b864baf347dcbe761a3b68f11c1f68c7924f26634f53e3a3a55b4a7f600bddf35278c24875fa3d489d8aec7c3329015d110a5a6173f65d1b9d3776864e49e3800890f33057b61e099ab9d3e18b6d8958d08e57ad45619bea5bea96f2269335bd09d9ccf9c20cee14b9cac1411faddaf6c7482b9096efa3838df26f463c2f1a312b6839c51d15139c77766cdf95cd4360957c70d4ae82808561e16346eeb166e7cacebbac396898d448e2405da8e213ebd212e27d2201df7ee1d8cd571fb98fbc942149958a71e12c84c02012fe574abf31c795b2399856960f509fd771ce9b6d9ac0202e5520810eb836dc9e6a21718cb24a9f7ef26007a6fd29a89e9999837b8a18eab003df9b094a9bb8b2b15a97c3de94806cf259567d5c698bc0f94af296c174afc42697676bc1fdd3ae081e12392a0ea9b747901eaf6ce1c488b7605a9721ea204bb6ead606f0481cfd06b0e33a77fa4ac53957281fb5bf9331dccf6c7593dd8162f34f56b306b45c7a5835145ccb79f76b4d0ba0b6b03e747a59228b2ae6431f16d619f1a7dc813d15c62f9b1e861648bb1536d19c5624e98977560aae7e62009f9f2b016b462e850d6f16779aaeb2e1ac930d1fa72bc2cfd3c61ef7be1d7fda883691b078467731d0ebe1e8c2aa5df413bb85ff7819bd9aaf724b78cd68eeb192d31fac4a8b956b818ea2364485553de4d7448f82dbee2253696b1d02b0a8de0f85644cede9221d1d5d697fb7d37731a952faae91db1e911db0eff9f89a3257a95fe89a5f755d0a5fe25f0f98cdd365b61b7ba488758b23d0a819af45975e71c8ce108357935e0f129c55646527bb1789bbb9b45c34d11dad0d0dad9d3e60ec05bb8876614ebaa84e3ec08414c8eb972ef0b4915de68bc12f8c7ce941d38347d4d8f58b250d43d5357fbd7750711f4e5bedb36e45b1f217a24b847502f70b7792c09c14b7110b8e2e72bfb8ed0974d28df1f52d018b385a1501ca3e9762778452b0b8ce585bb1b5fe520eef01d076b76825ff55b0ffc277351fb9cbb30bec2c0f4d9a6ec68e31c93a2a52e6829c72c1024011f233abbd33391506044abfe9d970cb10bb6c2acf257dc2f2bfd45211b75ec94037ff0fe98973d028043705825fb17ed1ad2df8f30a910efff87f42197358754c971225f7e60e57d2eb858898fc269d83d9159fcf554a98a6580c37b483b4a3367a63ff931bed3f7521d7cc01eb21fb7e5814778d4a355bc529c6a2049324be504fc5d466b2711ad92526282f75cb3b84669b737c3a2cd1c3396545a1b017d44b96fb186525545c0fe662ec655db49274d90be6301b84ceed3926f3682c754c9b017db00a6b73381237f218d7c24114a4102c4ee61f5e524496b6d5da22c331cc414f2d1d7c5bb11a10751ba31d81b946bb1f266f42438678ecee69729aee66b4c1f2031079eac7749b89a185d6f3bc66799274ecc226ad5b35b862b2fe8cb67edd13651996a46bba28edcb6a1e82f321196aa2b00e215b192b88da80914639c7adcf5614d2ff3d20ba917b62bf86122831204e073df81e154394ffa759305f58f143ce65eb9d4da2cb3060337cf9eaf64484543273bc7f981de9f28b94e440b8cefddc8d387a9ca315c4b0f04b1e3b4e81362302bb7a9e33921e95ea58df233d7a92e62d77761cffe575534e4f0744d18193c2db228b6dffe21c0480f78e98030e2c55fc816d0e41125bb09c41fbbd4592a03d4e21a4a4d67953ed7a2c84ba36818dbbad7cbba47853cc685da52fa165c5572cddc419f4b2c2545b7dff6ce4dfc4af6487dbef640cd078f26969a189ca84394f54aba6d2646a7efaea00e2ca361a13eeaceb868bd0c304b2c0bb7c3f5150db100f989e0891048e02223ade7a64c5674911ca4c45901c38b7d6db7cec97a47f73b340adff75ff1462881514dafd4ad5c0d83026560e3995001cd75c053b4b1ff78b7fa9bafc8f4081ad734f26cda59bbc93b45fec60db7a47e74b615a58141a5377fb4aab854ea9d98616f91f41f9a90f99cfdaf27f5eceb0669ab432eb0910e8f25de3b009fd2942ae811f34c78d65bd196a1be1327274fec7d908c51a2173340eee6145cac8d84713743fa590de78e1eab25a3685db7afbe502a88b897aefb8f01d9c7588b51c245bca77db5c7ae0af2b28bc4a5ff2580d8592c66e9bdd3f6cad2a9d8d8d1237442b4596405b7907002336042440dc0592f48a3b5c11a1187123f448aa770405198ede815cad1f9dfd966f253377cf024a41b7da97c0a557fe06d9bd267418e30c7e5e59ffff7093bf31448c7066be1bce0cf18807fc317a28d3c9df366272a01e4714bdd36530ea47dc30449032e4333e564accad8c5b9d9b93742210e206934c6edd8f79f3a844f35d7db43fc28eed21c56bc20441310858b2398ab787e2b5fe2eb2b00bd6def00329dc51f5625ea6f670b9e4cedfb55a71ac7ed13dfe844de73df27ff9d669b91a79ed144ff7c541248bb6ea94e182dc5e8936ba92e3f4c068aae5aef70d72bd940b6fe8cfca1f8194a0307b80f6f5166c080de0914d6f02973f420a004ad335c3ac4bd603ea51c19987672cbaca7a16ad3798c3943c774e30ed4a56b22466f0080663b141a0e5e43514b02759b76d6f455f10b491fae978cf89d33804163fdad851bc0eda4e4f7cf58c2eb4702cb6c3e2adff5b26eacbf35bd6d9750fb3cc85e2ff1817559bb5b7c9abed5d98d08e9ed4f6d135fcc59255ff3e97c9fde537129e0d3441c166247fc7d8e7b5b55b7159827633d68c14664c9134449b515a430fc291e950ba56cdc04e6715b70d78b3ffe1cc3c5564741f507ff06703175881e31f08af0bd377045508e229bfb619b5c6ca1d7bf872133bf5b682431a183768199f59659c4c4916ae5d2031c63f5ba529e90be7c205964ec73e568b4413063e2d4e8847e3a7999b0d49dac04f78de86980290c646bededa63d9e11ba8958d805da94a9c0d4d588093cc3be9e9ded225a2259b2e10ba917ca749808e2ce5f8378398ff9b835623d89086c804e5131f1958075e249cf517e7ce1f5950f53523af06b32a1ae4d4a93d54c34013352a0d01aab3e70d62c13d07bf079e709b742434df6764dac8b504c7e4d8969e12eb059bad01219a093995b278cd278eb75fd9c90c52c7fb437b9a78461020a7d6492a525fc1ae5555201af818c3f5992ab7dfd31e5a0b3a96cbf3a34e6e0a5476fd92d4f8ce1e0e99ffeb2ef9a34b917b8f1a4997fb4956036090448d694292019bfa949b998909102190c329b847df8eed4fc80b6edaa4aa1fc86581174a009d33aa7bde182b3b52216a6c74753ba9b2f255b73cc04fdbcc65bbf32529d7ac958f7412ab77f8a5cc25a0fe5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
