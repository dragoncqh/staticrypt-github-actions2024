<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b9ca752d07ff8d4693861a0a757559471ceec15503c0125e009e6590fdc5c58d21db68d5373c66f4cfb84eda941f20d1066ff79820a32cae1948326d3e26eb42fea1da58ef40df213aa40298fae51a2dc1a56b376be22cabdb14accb41c8f8c45aa481abcbaea42712e7374b77aa6dd3d0fac8eb05f2257b199e73cb5769d163ac2faaa89466db2f1139a7ff9c78185fd98f7e7f629a29269c4f8cae0638baa8be8acdc44e790856d0e6d599239311e42e22418e6ba7b05e0b3b9d00cda797a9407f2df58816beb01eb878019a5ea3c4b3cb7e8b3a10a2d875a43449db393bfe5b2e523cd719a75b20ae19376915e0431da6cca1f64481644c6b42460dc62abfb798308661aea24675fa2720d72e0f1c34e7874334714faa249528a4bcf20661fc6ec07619874e09553df46635914398b232fefc6364d9a0a508409de6246f76a05912dd8dd399486e330f92c269494a909a80d974bb6a9654a6290a46291e9b90bee955cefdb8b5bc7fb64ef2930022005c2b1d40c49d14a60bfb7214d6c705dbf69180004cc80e868dedb5846fe59a2285838c49ebe4f6b43f8f6064a2e5c969099d796fb2dea6e25410b60652509561e58ab9a3da4f25f74b90b9ac24d28d55aba0c16a704312ad9b9eb23d733a7899eb5d442930ef4f8a7d3d6aeb5ad02ef1aba178da2e2c98597fd278982811f031d6a95df3b55178f115ea1fb1a83d270e5021c5e5933e624c93df51888787d19f3e490ba9aee2fadea68908ab51a629a8daa9f068651b08b25ac8a58a3053401878f8ba05cccd3abed013f719a05188dbe87eaf20893528a5abc23edc4dfb2377b1930283e560d04ac9552fb1f60d91135e1df43f42424560c80257ca34c4542ec21f310b39f7743d310d29cdd983c81c3cd3e048e5846ceb5f5e2013dc042a1bf6b23a07f69288caf5e04b0f3430d2fca11f62aaeeea0d21edffffb2adabcada696dab24f9da0e8823bdff5c8485bc740fa64f2c822368d7ad934ea88dd6d0d90fbc2fe9b3641b49a9df85d778bfc1e915061cbe3ebf6d3776ea186bc8d7c9e8bea6e3587a12039707950b744e2b3de9ca5327f4939cc356f591357ae3d82f166d1ab99766864da2f972a4c463ddbb417e76e0847c619c315b1f6b694350718a4a80420d3973bfee824643ed4ac410a5873bab1f2bf5450f98370643e571a6fe1a305df1bab03002279cae2f428397ea9729b0180e97d019072b9f273290a80c42e9d019c2a0eb5e726a35da911509f3a57f15e43315e9e06338624dd1dd8e167a0b10b4686198329c91f12c1b391f8c51358844806eae4feb80ac996182e78eb6d62483c1b5acacafa692c421efcf36395743434f82857cc6cac2d16cdcb3a0fe409e56de2cd4a12971be162156867ad843e945e754f505e96c8891737df8c2d73c8a09cbe57411b731c7146173958ba5331dcca6f733294093a9bb47703dc4bc86fb5664c9dff2ee5db55dc64f56f9d1bf7d91290ec7591eee5423076ceb7609c1f4355d3263a2e8c081a8d66272f791462e21e5fba52a716d81af619dba76078350215e25b7f04432aae82db80a7c6dfe3e01e12abb6edd692df82566599e11991c5189263d21c4a23207720b098f549be75f646adca5eaed7b4d6f5585809dc3674a037bf4b4bdb331157701f3a24803bade1507714ad287ac7a22ed1671509d0fe8594ce44a1146510411f1f4b1f6abae4ac2b6941d691380868ce98a66e8cb3162e098f358b0260c5e3035f8278cbb365bc6c3c413cb758de76fd6259d981bd9924a020d28f4ad9fcb9a0fe40e327f7abf99ce446dd34095468e614322b6e98c4d8304f6ae49ea32f3e4957aba7b4ed9188dd71ab8fdf7d6cbed776dd05522fd67e5030576ceb6fa6cae9f20f76e2c5e7839cd8556be30d1bc954d011b18bc1ca32f9015aa9b0de753a9353e87acdcc7756a77d189cd718d0919a2e59ae38a8c43b73a2baf04de8ff9086e4f17f5ee684fcad788263de6be8657e063cc2344438b9f078928c61c6c9a812fad8a74c3a6991905efc5c73ea8ff02c873ef0907e55d5d2c30b5b1de0cc41046d92454e7a8f3caae0a5c6710fe889e2e138507933df0c5e9803d00be007ebd150627e6719618676305e1f0731adc00105470d32bc2487f71e8ff1f1f372e1282240dc4fe00d5dabf4018ea6ed1e68eaeb3b9ff925af942a98cb6e89c0c75d4397f08b6d0781f63d3e693e44f0e64cf79fb97077c7eba4b6a9640e783bdd88cbc82a31d448204559e2bc83c7e2cea681e292a9e501ef5b8544a01c5f5e99745b0cc2b65264616d4f38628d5ef6c9905c54a76ad28b6c3cb07dbe5dd7c7478407cdee8739bab78d36a00b3d4b3bd378a7ec5c70ef52aa4ba94157f6562715c2f4f6a92d96f248b6a07ee495cbc6cdf4a555207d237b46de5daba3e9a558613a4b1b3aa800b91e7aacef5cd9ad5369fcca6a0929ac52fb02f4c3dd15615c06b89cd2d375bc885004fff083cf988d700023ad693cdb7cd6680c9672b4b13785441338e796f49241525b909184a0c49e3e1fa3336e11fea2bf4c9f4e8cc68d8cb10066ac0ffc07c9d2fce83001ffa64e31fceb313496c70f9490c811aaa2266f8af6e1192010e1b601c645a24cc1e9c530579f5b649acb91092d8cb0453fb18ac1a3fd38d8eb12d797c995f7d0b675976988e531a2f6ab7f6acb23944025fe4adbbbdd5ce031b37832a0b3a037e492c7a285b4d2777085e6b4e9ac22e59c2996737380fa23425546665d6452a50a25cd3464c51806f284134eef701e1748da6fb94dc0f601477a4fc914bab49bea74dd5b6eb161262656678c31bcae921af525b2294482b266826747745c5cf41966044f10f623298f4158f483790a72e33ac35d0d6f639ebc677810502dbb928f27692b8d3b526d38f1131bffe7797c54be7a55d28784014019472cc036cfa6d338bba7871d2e97a3c51c85c3bf8c48b3165554a74ad935374b62262580ebb2855fd9206bb54cb8d36327a51c4f7552bba73c29ee55a78359e24a6751356679116a5fe375768cc6f8bdea03a250bc7f4f1ca9ac10c035fb5600cdc8b0e38c0a5e545b622a41ba05f79cfc58fc81644ffa685c79355f8315f0eeaf1b3c03124a338228809d8106cc3f8e72704e1abb1a5d90cbdc56a11f0b96274a5c1a931b1a5daa91900428106744e7b454b5d56430925bbb0b7353ed899a32c74c4a5530c3136f0a5951d3b3255ebac7094cb36256c5ac5de84aae7a87ddf6b8b8ea2fb3a4c23808bdd51f4629c860836764fb02f46b1db285da19541daf2c014397990550d6d27fd7ac0d15382c4b4389178806da4008a74fd89a51e9d9eb64511981d16ceb97a207c90a669cc80014a8f723faf2c3440e8458a473dc0afbc66deebc0f6e4a63e77c11415487c1247e99cf286417da984e9da61f5d21a717a89c3079b167bb93ae0895b2aa6c7e96475722add67011541047b80712a9867086050e08229c0f0f320e314c75d6c98a900160ad8e7954376a0a87af96c50b0959d859f225d275d5b5e2cefa086dbdfd8f00c15b20c3d125893e6c41c107f230e0dfe441d0d033ccec685478dfd98e215bfd5001c39f7b31f70876e986dae9f4955a23d8843947b3465af79ff7ba55aad6a8bca209f853572b031cb46b024c97576fa4387d4962fac493aeac8a343b4dd9aacbcaffc643fa235edf8d369908a5a79b50103cb087a3448d7c7944777bb1d00e827ec34fcff58e37407870917d46c8f916ee3fdc457b7c21b7d60df5e6baea0fb48a3fe0c88009dc40db9fb7acbea284de4de6a4e7d68f4a1b0ff68e5f73638e4be313b77dbaa2c75533ca6a04f79a015cd27b71d2f4799ff4d27c58d3cc854232efe7007b9002304e8ba6c87f7b1cc781aeb913818fd2b3862a8db484b566666fa7be65c38680ce73bb00991aa554c7cf86d7b6e8de1ae27ba3bf21e514089dba39bc436d7d719eefa22b5e25166431976b78edfaab0885d912f3dec29a4afc3e38bd3da148c039ee4326085dd988bf74f937a0fa962cab64132cfa17cddbdfb78c562665f2e4c1b9c405c45a7150e8014929d462cfe687dbacd3e0b5aeb3d6b068edb5d754297adec658b8a7317bf935c7a08974c7ec81ed947cd9b48c76dd45082e8ba408d736bf7e1999f42813a9b318923536373380df74df77f22940ee70ae03fd4b67b96b41a736cc85e81389cdc35fe969a39f294d83ba04e871abb600bab73976d46b5f495f3225f8e42461b2e6fa175e0ef77f8f1234e4627d656a18d437d38f2302156219510af5872ec1ee9d45b72725a3e752b7027749689368e442f293a6f5c004c69af4dacd7f00bd3bb5b649b2c1ce41f08c4805b2088ac76cf4d522bd3303611039e03052abdc8519368757f1077bad288e11e8745e7bdb4ea5ed10212b76f823b9b5b564341112bebb74acac8ab0f1b170e58ce9451453c83cd632aa875bf1069345e7c31325ce14562028c94574d03a0b9db9c070ecf7a0c494bd8de5667a69ba9438ba5032308eccf74361cb7279c8d405b10e9c71d47e6282fda5669e94d47bf9e2810d7236ad1a67d94d1bbd82124d41b2d70fc2e870e9a7365ed2fda9af8eb133e200a692f75b0d6ed6e12aa9312c3a595504567e5a5a5be6567941dc7a3ca3e1a4ded2a7dc10c43d79c23e03b54ae0f226ea61a3f2247dd4888c6af99ec8956a52df7c9d3e22a65f01a84625f7feb7c74edd9296d084c23d494ab419654edf714ede0916eaea0d9c15aba17e9107edc3b018f1df94a76db24b2707df949db55fd1149363014d029db57a51c31300f9353fee5fcbb2f418553f2907cc3290d8e28d8eb79cea5c83517a9b3c36818530bf0be83bc97eaf09c0f027760162b94abbd6855dd68c53ffa9e0f63c3f66b238e4c64e920d7cd5b1979bac0a7805e5b8734bc96f8bbd0f26533b23dfcbf3988d858ef270956558e596b60b202a8402219a83fd984c8bf071f4e6529bddfd7f67228308235e3cf6952c1a5901f8dcced1dcd3e75699334cb2afbf63bbe8b91e0b0bd4adc5070e907fb1e38bcef080ed91443a84d7e9a7a07f6651a7909a1460229c49a6675d3f2d117f876cae6f08d686d91f25fac55e9403c0cc33511b1b47bba52f1ff9e531f0907ae02416aed4298b5b0f93e651b9828a31e39adb46978b4c95518018169444d61379d9f0b5134c8e9fe6d5eda2d5059ef4f83f4ffcebf296b4e4b17aa98ed06f6817bdc1bdabbc119d4ed959d7827fc319420cd72b7a6d0c5c6047f52efd12bdcce31c78b31b316f185d43f60d31101ecb37dfe098006ffa768eff59e60e9546054aab9b291c78061ecdc115e38005fed07c65dbd5f8f38a2f50f43d5c955618b817f0736b8b1cc711b877a623aa5bfc6cc03d639e56c774fc4166cb8058082c22311b8c19fac02cd45b93d390e7ac8a274477005b0ee62284209dad3343036022e4b941d03de44b33a1c0c8f5915aaf9b5bc56b925fbbd29fb06cf0aff9e4bb2e16de4c32ad01e5154bc8896b9fb2fd0f7b5c1ee81720ef9c289568eac3be57030cd9c0456c8213ce2fbcdef76465bb9e1766610f870b5f12a5faa05080ebed195c84283231fe619fcaad2d2362a8e1ef1e3a50e2de6ea100014de7243ba22340b80350eb9f880a6c5cdb5615227ca454e531dab81f1389fd883928d25822eae34a53808ced79d89f1b3a39415e34850fe34a40abc989b2682322eafda0b6e144983de60e306379da82afdb8b49296a0a21fbb2514199daa919e3bbb9492a51ecd9a8098cc1e1d86e1f67be4d71c4da17cc1aa349f42337048b7fc5719992ee047a76c37e42938e16c7e85e577dca8b189a518c4b8b1eceeae75d8d0711c6702203bedf4d0baa995a1aa189fc83bb8a2262d926ba03328fcb4307c600724bcdfee4c331dfc0dc6563c9b8a0d91722e4550ca2cd982d78f0b7b3f74c5ca6d2b6c3b114f926eab31aed0506b69e96f881fb0ae4c4ace478bf1d4b51c8e739395da13d44508e204ee0999bec64d87ee15eda8d79ce21cd6d018e7895503e400065ab7c372b6f627db31f10c085fd1c079456ae789d197320fde9661760922de35714ea14b3a0f3424b94d1575fa8e183335622beb3a3fe9057e42778fea026873518bc00e0d37973f6b95a4fed2b01961e434d6c7368d220e5291d7606c4ccc41d471dbc9b25b79d042a40c98d526eeca0db5ec3102a0fc0932876fcabb24a6c19aef6eee98ba5889c2cc0de534357dabd17e31fc395608717a31acd7fa8bb32270ca24ffd6d1f4ad09ed50c3a99f4e103e8e8d267678687af69f6301135bf78b991a6fb3e3abb642f891b68974cae827e5f7fd600131867f63c836f4c71434f553ccdbe1abba5b5c966a297010f15167559af3d60efcf962dcb34a9c0c1cd4e82427c915832fa85f16a73f05e57749c1b14621b5bf9c68273197ee33b2f66192893ed3065cdabcd854845b2f30376fbd8e010bead8d6295718c9d1b523756eedc81bb46f914d5d119c6c2cba2a23643bac5ff72b103d8a0a335ce48fdb83bca283a6eeb038fe0c67992403bb96b479ad0cc9734c18995cc0d78542c722ee2d9d50028aef3ea5d61b88d3949185bca77fc6a74c7eb626fc3989201ff5d3e3e22376faa5f7e8141093b138afb7a5f1fe1f724db128c73ceffcb1ad0d5af9a342bd422124f73f5dc829a884aa0866cded7eac9634ab52611a9f4cc547c01360915479069ba4a915a0d4d0a2a69fc9816083965cc676d00f8d083e12ff10eeebd218667ff3d121540b82664d1abd13475c7cf65aa1cb81f00e61bba3be70f5d835ab554b528275162e694d8baf2cf131a88b0ce2b5639ad0990d674cc77a612ee2c2408a5ecdee131ac2766b3e67d1b847e78d1e2034e24d5b75556f39845274559d59141ada8942c72b2fabdecde7f41d4dc7c5eb109cebb63053780fd736ba571e4b6b86595b3edbb4203b9f3d1c0bec50fbf3ac425ae03882a9c61294468a9d45a001fa7a96e84096424806f7b8bdc3a1fa23fa77185d7c8a334fd57af2c1665453373edf0bb8156c48b3f586c6146719e40b2b1ce7c22796b5845e2c0c5006c92e38002b43365220d280fb20711bec32a9b6f804b6676342cefaac2349fbe129c378ca271c307a5114e809b5821f860d469924920d8c3d7a82b461aaa53b716b7d52850fab025be5240c22484e13e367ed38bbd58e4fabf8e1f587e245b718b19b5fd4fb276a9480d0cf28224bbb0647f846686b0de41f5c97a1782cc40c63dbff60b2db2aef977f020f2029924417e5470455bcb2e86870faa666bf2b4a5b3218ce35ebff598fc3f09bf52578498f8104fd6d9e6d3818c674eac541a3f90742141f1aafd52baff776ba0f13f94a3605174b8e1eb465625a1754e786d1ec6f2524136e6fbf8d5d08111d37b9cf7336a56419c6066c202e07ec1c0d2a91edb5cd3deaaaa78f2044e983c2a4b815daeebabcb07e1777a9f282cb36a0947f658cc18a66a7f40aeac2a13922ded6166263c09bc1622685faf132359080e0cfa91bbcbd2d0a25e72e7a72899f07695cec25c788e3ae5bc4da73102d307083e3e98fac3c4ad7ff80058e55ddce2424486206b497193a79dcc51ea79e90293d8198f6949b971276a95a108","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
