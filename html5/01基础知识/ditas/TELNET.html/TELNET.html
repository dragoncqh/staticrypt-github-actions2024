<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e05500d46356758d8a66ae7d36712fe0eda20768079b8ad06ca73993f986810e8ef3fcff336153a1d0b956ff3c2526eb9cada6706d698d6d9f026dc2640e63ad51aa09b31b70dfabf749c871728714e55dbd9c2d12495722c230c341608ada093c8c5a241db3d974b1f870c8388fdf48dacef89dd34064fe9cdde858f19433a1cd9c2b0a12b63e342e4dcb546c30706a0333b2075791fb7d7f14401daa1281ffdd914bda62662a7daf0bdab267c68abfe13aa2d19fee78959cf73f7f2a4280123eddf3bbde9897093e720ccb369635112f6cb60346748d25f7798f990534157fac03b47274b626ee8d50f6cb44715bbe2d28624fc4464b064b0ee9a67f12fe41a51a2da2aaf694dcd8f924ee5ee91295f45e365064e2e23288b5651eb7e016e6dbfcc9b8545e26c455f35e4cc60017a91b8a8beb98afbd950d3fc9b8e8f93193232076a5dc227a23a97d1e368ecb1f0035a1c93639a57764206b313805d09d4f32fbb30dcb70a0b4318a8e781bc4913c3ade69f83358b65ae8ca2559db88693e52126b79458039adaa8a9ec26271850a87ecff1c98db0b0f9eec47271dc6384575c1ea1fa8d9d2af11d42f9e74eb950577275e9f90416b9521f272a51a62b422d32df86d01a845646e7c649ff7f3bc137d05bc08c5768d33bba73f670a25082ca53de763b48550093406dfb61b39a74f79fc7465cc2febd0a3c19f21d82fd3fc8249574a86063d4de964d179a594df96e7383778be1160942abcb4274b321e46d6cf06be5d92cc5168b37c873d74bbd58f8588ccaf2962accd3bb90ffba9bd69d39fe229a94c4f53b70a370b3b53cb7468a347dc5f98c79548fc44545d8e0bbb577d190821cf34d62211c070932ef63cdb5183413c1e388ce2dc76142502d443c10743d7c756de173a7567f7f7eeb19d5ea2982076aee7eee1b64b7a2fbc53b781797127bba902af97b72655020da2e8484a518892b74bdcfafd6aae8a677cd1ab63da8b64c6b9c766470bcd55274e4d406351d38ec440f6c39ef9e2b8fda1c892ac9a6cd0e4ae24241c4cf63ddae40c814c27f90a55dddd96cd7ddc2ffde372d602fe5035c6393001ee31ea25012eb1cb308da772d56e8dc66e39470743cd8851ee77f3b3ccceeba2081425deb17cc2b8e7dc3a5f16cd8057fbebcf1b160d52af9877f0fcf72a8aee8138e72804c11d3c66e02731b2dc9365b56c44f544f915dbecde20f1e27d980fb9d6a793dd4a54ca379ff542087d84ff2c740057a87f862ffdc6e6a8b95713e38deff8e4e9ae7c5d12de5955c205b5ad7926cde99d0a788512ef5cae0bedef8b251a9608e819655a6946ac798eaccc6eba49043e9613c6944b4ee2847983ff29a96ee6fbef2004329c747cca28a31ed2844ba951510060e12e44bbdbe10a7595f7683dac582db956857dfb7f2ec2414c5227d07c8e101455d06438fce64188fff1844023c499bf2c55742e940e9cf6c9035cfc9e0a5989a494df0d8af7b83c1f05b6f42be30fce143cb93f75cb7218077bfa52f100b1e6338d4141896986689b06397d361c9e44966aeeae3ce5866e00f991c518bef49b5918b03eb5bf836539abd6ba48b80bdeac7ad62b4fb657c924cb23c3f20ef162decf86ab32675b7618f95aaafff0e1e922b3f0ae78b055dadc6f6980ee865c9c3a865d65ce5fbd84b98de0a9af40eaa1c75fa4d95d492ce50aadafcc99b3d89006579874df27879f1a679e20ca0d86f55535d1c872e515267374f14f42ffff22fe7d83af2bf8f4676c7c9bcfd769a2b3c5a95e027421825ef320ce96e143c9ab6874cb8ec6c63ea2c2c666a3e6ccf537228b141015cbdd96eea5427287d069f993b67d362e8edfe83b98fdaf8c6f71b80790694c68e16c1fc92968461b21abb799d418fa1de536c4e3ddfde807c4995ed6908395c339413815b6a68d3509f3e5f14d82d0ec816614f634f40fc0690ba9140fcdb983cfb6afda77587738489b009ecc360e106fbba172eb58446f572e8f1c3548dfdfbca56537459d51957c6a5b2b1ba621415b722961089a1833e6e10f23dcc8f3e9b83ac94d17ac00fe2f36705a7d277608a6baaa11f7beeedae4347a2f2e88bd095579cce7b4e29b98a60ad1f2067beac2ecfbf0b883eb4fb3a2bbfc67e4a2ca8551e65bf8b93623d4a13f609c2d2c4e802c5cbcab606a9d03429ff2052be438af7b07c08c1a08298251e22b7ad43b619ea5d514a7b75fd43e5523a2108ef53cb389bc919a7fbf4a011398ce2e16308dccf930d8b7c05ca162b5d6800eda154e4263dad6affc1ab6cf798590f3768647f31c658e37c7d5d8a3251ed85680a8441fb844ed43dd12d1a6fa04d1546a92cf6b6da0839bacff18b22bc11614eddad6fb50b7c4d073d9f044cf29ad9472495f4094e1df6b02e1a1add5e36a40fbef8edf54be723c7742d4d6314ad8dca930757ccc0c02a57dfee87334eb0b2dac0663c436f5dda9172901a282c2bb81dfa3a97896021f9614cf413808854977cf46ddebc84790307488377bf29820113e0ee3841d7a1ae6f7cdddd9d739c0c08c1c2e955bf34b7cfc5b2a9152f47d0879543d73246de39a23015e87277d38b9acb0feb1183a8bc36c4fd4121309fc52167434fb32bdf3db4e0a76ff61b9b5808c5a0c9044dd0eec48e403adffdaa4e43a18eaebed2388f380162256b6507afb3c0ef2ea3751b92cfbb97ed6989fef0464b487c103260e2a65012aab454255cff98c9d3ae5a9449c072dd499f32293a3bffbf832546c03d9e69c5ad8f141fe201a19c4bbbbb05b69a4eef9460659da2bb6309f398604d812ea97265b2c1521971b99236ad022961621524a9cc5e1fea3aa2bc0a971bdada0572071f52248e32310ae2d7ad2040e79dfcf0cd589e358e9709e157f7ceba2ca72d41087f34e72ce0e50aa6d528bafaba9056cd9c7d0b49c35a65cfebe6f8f3a91a283e3ca527210f4cbd75d8fbb0a5ee833333c93cd293d17b2088ea35ae2d357e96c820ef39909d2be9966b320abd1b9403c3c2dfeb34db94d9359a9da54e936b3d0c7a060d79b6e37c0698f0e8059cfb96cc9fee4db37022d2bf050bdaf75ecae0a112102636412ac4bcca71cdd46789add5b4abbabb175aa65bd3c5f60efd3e1941459bcf333ef7e621e32de3811fdb9d16ee4cd33b5f5209f1a94219d32d94bc4d2c9e204c00d7b1df4c510d77aec9706d2fff775d8e4c3ccf9f7a7dd6c44444ba46d8182aa02df76ae894d341b9271e588ee031b3d4bf2695cfdeaa78161c3400c7c2cdd971ad563569052d4077dd1aa28502d23e09a175ff7c0540ace3cb88cd8cd65b11869d90b6bdc8d7b6e09319ef90199695a274bee039a65953ddc2cc71b4e5fda7c572be8cba71c20b4e93f61265eb15e48ee6be37289bbc7dbf24bcee3d9ca1494f10d6cbbbd113ce3d16a60426399bd437911af14f9258246fb8e1fabbde0579ec4fbcd2ca30b5d2853d9c413d7c1631e82436494b47dd2d51cec1fb777f0210bb7e2bb161565c0baee75b733f5f2096d84fcba96ee460df7a6956d146d22610edc7e1e18dd48e22664a9b54d9710c173ebdc5dde6433f65202f948f6c58466498d2e8e2cb44e84ce357dbee528cdbf06a8e3183ff3c5bf6e733d93c2d9e525cc62b0465eabb80d4ca5c11e028aa288c23fb586577fc43d9e2aec37dc6de3f227439fb2b6f9ee36bcbd81a915109d8df09c974f28801ae0d4fa03c5f0c38e2e872fa99d180b4cfb2ed2d8bb5579f106b6176cb166dde851c652cce0b8abc975f1fefed7a0e74f40b1e50d07190c03eb9a4e5708e4c2239fde63b1255f49d6d74fc90fda401b329e35a417707230e7345a4624a58465a968c797a02f62a7219693521584fcb99161495db1d38a86f5d2fcd56d98de963a5e41a6ffdb8cb05c654bf2d3bd6afec63c8bf83a0b8ea28a97c1b61b2942fea874e8f4faf87fa4263e1df3a347ad45fcbae3edcb650195b98c0ee350f2998efd76be017d2daf29a713f634f1bd2575508e9f15685f5edae3f5ca97c0c7586e73722058525a4156d35ef4e3fdb91bfeeec2c8f2d2916ec1db65ba7c91cf43b2ef895ce4e99fd85e128dfb8eb059890ea47f099bd0e48090b210e6c5f5e55fc618f1e868cff3c896276beb90eb78863bced20e9f659f37582e57615667c7451b48273df1de123461782ad89a5e9fc613400497c2cdf1ed6be0c9ac2f362115a147a5f0c7018a1b0267656ddc7c12063e52563e74d61bfab038d20a1eaa4c97883b26c2eb147c65dc16266b5a65f6b511a2512da7a2af57e37cbafb48ff1beb98954c603121e982b9eb4427365d62715e0abe437a6d7a249e18473e3e1c703867817e71ec0200c6d83d32de6d759cc7eb46241983c1ab806c245229ff0d4228f85a5a39be9e2d9a8814cfd1eba4e86f3fb3755ce59b4aaa6be80324ed7da4d7b630005ded5379d06833f8e9be59841af1fe9b11a04e32958677b94f84ae3c9e7b5a713d3fbb5fd29f50dc68ab1695a31d35deafff4f67fcf32fcea05b425e49a63dcbe5107e54b2423ca47a7d664a7993617f2bad1086aabdd0e5c0a78f73fb7aa25d9b64674b433011c8edd86213642fe81b90cc2f5d9d4c71246637482db94bc1efcbe90b351345342dfbebe5651faa5b93712c0022fd356600027bbd0fff4e87e4d5865e078ceaad5052b4ac3585735a2b67bb128c299016e3adf1a23a5b39eb4e34ef5bf615ed9271ca6ddbcdb252a3dc750239a5f795448e97d83c6d6867deb523111b5f15b91a2ca7082e19036ffab32c7672fecef73eac6cb3ca16a3e050168d27847f5efcd5bc96eed5b388d7e90ba638a8caa1988d43df19cf56974681784d9cd9755078db471d69562f1fa9c9e49335e175d3ac5c130d63c31f039101ca3ca07f81c601e4edf3bb039b552d28e2796903ea8d31964325b57249c98e768d9f889d8f5c0038b222685c3e60d05e6c6939069b8fc5f3062532dae448c86938de14a251e3611c930448fbe21d9b862e04095b7b2d9e457eb3cca59888358be6d36ffc70d5beccfbee2ceba54584b399bab181c29a33ff36b4c6b9e81a9cf8d6e0249b9845048485d103d876affb640248e363b7fd73c363d509ee465ad2fa406972a66f4d4dbc725abe9084e490c871166c84e460323664cfe09dfde9d6f3e97c977b4dbee6759369c0b4d12ecd0dfa25303b81bd25a0c182ac9cdcfd865fce2c40a99db5f7834fe119d54c88bb8c69c9b836773731f008b2f6047cb0705594345dcaf296ae06622e815d3d17b597644ef66bec8114a6e48f5e5fc6b211d28077681f97f4fb0bfd370097402350e5013ac68861c31e94f7672946879b1ff5a7ebc7bc88741b74f852414b3a4bad80f26e40ca1d6031aa3d24338c835f7516d656e13d44ca6eee3b0e5dde938b195e061721a92693b033201efffda4d886a24068ad9538bf0fb48ff1a5613568e6bc3cba519a61c025e9d1c448994cf7de33e376cff4a4e3a582853d6b289b74f1546ec32309ec701076d2cddb774cc494ed2ce5101f3fb428d02d2a555f38d88abad8eea4575b2d393b39cfb3a2c12dd0bdc745776b1047fe62b6799a41a47e7496878bff44ada5b3b7536bc253f27cfdd7fbe09d03136deedfd0eeadf12a82a551062aaaf6b97834247617b434b62ce528b088949d643c37bbe901ccd7c5a9e9923b3672aa5add97ca09142286ae731ca429a82b44cbf4bf61c4d6a5c936aa11094b4e0b4dc3d2a7760a55a7b14559f636d9a51d1b51b011aa16d1f77b66fd8643f25a5212727e0f25eb3c3a06af4ac75cc6b4fddb9031eb860d4ef42254889ccdb4d2b9ed8face575401f4fb9274f2050bf72664bfb879022bb8019003cb325afb6fe595fd8f18c6b5d0238011dc76d2468061b15da9c4ed85178be97a35ee0ee0e61f94ea9efad7368fc78851b844d86e28dfbbd5197c1023a2822fbdc99ff03b9900ff08f2829b73c1f3e8529532197750e5158831fca94d9fd9acb1a259efa7a0c491f464db7cec691fa1a801383f373da4467e3add5be7db88afabce50f5b6a923a226605faf5ccaa90902e78b59d859f987f0752180c0127cb1f32c43ad7ac72047f06440e2c89178a70dad358e8fc1046c81252dbe95fdb6a08b5c23ecffa4023c27e77e11a2fe06d92f9e37989217870830e55e4aac8ee96b3daf6dd87c0f96d89a5669936c64e2f9e412e6bd90ccf6c21efdd77f0de1d791aea9dd0465ad67dc0ef7960e281a4229c0c165eb6dc3bfd05f7cd74db197be07ac36ee4447db6dfbb3544f607130b7c1a81ca124d459b1f761b5bf0c0db43d52114b302623b5b4ec10274e2f5a3cc12c52b6cffd056f992d5b0159367e0a0f9c7fd50c967e0c14da3f3b94566574295738f601312710443810df36f27f140dc06912927646ebc70890356536a815b0b083595c575cfd55aff9a82c4009a761649e7f44b5b838da626be3ca2fb25ac56a9898a6ebb7857033723186fdd4d32e573c60a543d5644d1f6b772a20d0b0ef8e6872d49aca84e0a6259c80e1927d69fb3030e1a0a1f5ed3ebe8d608d6ba1ff0c351dcfcae13f16e95ec0e4ddf2f857e61815b2c9bd016e926ba874d4e17e00c706cbfc2c55b860ea61d9cc5bccafd50999e866fff3bb0824edd518ee9eae27b48734be5b184ee52543899e4b6ab60bcd19d77b4d806cc40ef5e2c5e039e0d27092537ed0d5c1189c7d3a69d7016209e45ec6a73c6e2868d1dbf1b99c2a4b6a4d559904430644b9790af910c90f00f1882ce67daa357830f037c0dcbcb14210738a9eea6a0c8b4fb9f7a57c6a74b70b6e357721d9e8d064b44ca887f958469971018d9cf4d2af6a9a2a53c4b073860b2e5c24afc47135b3aa25975f563a72e291a21b54daeadb1165a2653163351b793c1f546a730c81432d50248761fd687bb8be97fac62b3850ae28d51338ba77d8714c49958332c9c41f957170f3884a7e50322d564d0ffb624dff6437ef07471a07d92925650591df5b71d5d7f033151f11c72ed0fa79d8c85e907143e139761d3a186244de1c1515846f8ef6286477f3dba744e1b725e26f864aa0bce303c9fb86f22309056542ef7af882c62495c1d044b7c90a1235d437be90dc21036cf2d68218147daf2600d16a290aae8f0c2b5a3232cb65c141d9bd7e80ec2d20c5a487bfbadbc7b6d0a0c507fb8c144f9d75fb80b483a96e5fe0007fa6234728ea93cb03ffdce5cf72c2971673c6b4eeb7342f3588887ed116f01ab89a66b3ef90450028fb8de28a5fcdbaa9e10b6ec80d67821d3dcec7f531b126169c1b829c7ab61b1fca4b61593bded9b6a06cda53124607bad225899f4e812aa8a8df92ae4122273426fa98a5c91d04bf679f719d55be5e777cb0fa8272d0694514195f850d311ed88aeddd316e70ce883c0d1db4e470452efbb950e6111b62be45547c8fad9f5b0b326c1db717df0e7881676311d89123a9358289bc8e478d88d7cb48e8d83a8fdb50c2b2cadef1eb05f068300a76e42924aca38f791fbbfa264d3114cff07773edaad4ba1680a00a68b8c2a49ef12f137cabec0233ab897347ee7cf70af611cab751a197bf9050b027a8db0f1503dad90bd8fc09537f9973984582ae40bd1ac164822515206fb25a43b542ffd5cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
