<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fccbb9d7448ade6ef6c5801a2ee14f34b5e1d99264d927a754fa90e4bdf2ae266cf250afdfff2d146d199cf4a89cce93c9198c3be0541160099bedf385237d3b148f335a8b8871718545d1b3cf3decfaa6ff5c764ccdbe2a9873cec170193cff5dbc1df61b1c223ff832839699d983c6721efc666ec899577158de6ffcf936625ccdef4fa7c9259cefb8793b079916f8e37ae102a38e2d2e1a5de6b769c01954296b645ebd9962457005709aeea0f663fa00efd99ededc1ff18d6fb7821480e9b0507da932bd91ced7c775aa43d3e20fb3839eeb571f6f1141eeea4bb032f81a61a81229a5b4bdb5bcdcad33409db44a4f179f57a229c62214f27449211c3e0d3e352a12dcfcb87d926980e65910be59c54379568ef4e41ef6a8155fc91265f344b6e9c9a5d952f6bc1ccbe5ebaec45206ff0670c90100a2fd82f8301a174a779e4d37898fe155d3f6f81cadcb14762f6c0577429ad566bc42753ecc9860a52ded162fec0a6a9babb1f1ce999c0612e957615688e8d2a0cc2fc7806a0ff24693c8a54832fc1231f56d461ede77782463cca5bad35fcfe81293ece97e78ba45549554dfad777c1c8bfd8591dd398660ebe8c7c629696ef369c080136711b6ace65d7291916b9014cb7bc10733ad7f86500efc0638f7617f76415d9bed4c7078a6fc875b22b5c5f9b3be1f29eeed024d772acc880255a3a33057a9882e6ab69da06272f127ce52e00132c25844c1e45c2c8303d59ad1160639d3a8a7f867352ea00f948a615076f24dfd0a886e484a4f0b68d466714c0723fe30940c0a765996f0a11337d304e363e619d9fc1c283a3edffa70bbbda58503b3e5321b5befc30fdd3c8d23ef42deecc78f31064e82b10c3ff54cc6e8b0d34394618cc88d2e5e5fdfe193bc3451e58b4f6a3c0f0e5bd5c70a65aa6e2ec71401a7378d5501ab3eb6f66569c4cf4dd6d4d960c4832d0b00c255c42c1d2476febb662963332e2542b84f03cecf3c9c70eda116906c4d86d273b9f2b5d497f685017272fc1ffbc5a700591089a3e451050cc321a8987c1e8790f409b6db4b15c260925bd110dc1d74af04b29764eee1acad8158f4efba9bb562eea4ee2d30e22a2b5e045fcd6bf1a64eb22da8c758099d224c3b301475774dae46b920aab9700b55b162c5aaf4a1a3625e99fd998e0e2a93102d494d3a49b188c9c56b7b80bd1cffae09903521829f1ab42a7de95e0f960e5e22855969b2a0aeb433ad18a818237ee39282ca354709f2c396740ddfb5af9a54a35f1d9d58e37c46566486e616e785c0ffa555f5b2e064bba64abafc8d065c85ad7c26a3c649d5bfa77ccfa477da52949051dba867a9695d79c0cec88430568f3d45aeaa3825839b24ea22e3951a6950fcec2cd3c07b65f489f7109fbcbfb204ec53bb7c40f4007071cb21883bda4635705b0ce8090e9d2aa4b5d3bedb1e126b42dca3e6fea0cb33543d8c9d40aabc119c066256a1b7de5f78a2c74b437eaa5a3e36b10fadc985e7f611c1ff036119a62dd4431793cc2f2de538b6b45ce166e57adbf0ec5c1829f91441eaa4d0c7ae748bde21618802eab665816c89c8f5e29ff75802ea2717b27b63a960bce058f9b7100c1ad8fa95ad93e9cc0068bd0a40df74965720e1ed31775bb3605bc124823b4d21b9b5ebec5ea7a492bfaae6196134d7fae5776a283d44afd240343d364fe40f3205a36e52bf436855aabc06972b2ed453b69b5c0dc8debd4598eb5df8737b229bc7890f615f7a99b13677a0c731764920aebc3755deb2cd1e99a4e12c4b6c106a7e80be4e432da6ae509cb856444e561e7ceb1b944acee20fbc4bc4fd8f49a3f200aac56eae564174e904f391ecfc952de5c2f6ff6ca01d2ae414de31d7b8a0c1e8ebe962283bef7ff6e7c2e4c0188c7d78e250d6110b8f3a7bfe5e7426abecceaaa1f5ae91cb9566a53e61f1b6399acd5839dd818c0d1ecebc42e10a96ce310bf0b6356480ffc57ae424f19cf9c2198d207ab48740c6029e3f8a7e818d40d617f72a470c586c1df34828455cddedbfaa1ce584869f031ebb3c021f584e9acea39e80a6ceaf58cc8757a0a30c325456b34e3a88a30ec176d6d43e518d4585ca877ebe55f1069f5bb552f7e66c2c895570e6687bc078bb4a331c77abb4fd5fc96240236f77f51cbde8748164ce68ea1e38e69e5f66626e0de628f7edc86dbea03aed168de070d683db907131aa9f9acdf6b07a20607d2331319f1f628eb1e0de7064ac607668dfcb2b90b567998c45b8bc69d0626744e75afb003e0475366732754236d10b0bf772ebed3c29bbece35a1e090b87955d4c0d8b3749eb8f442295f6d9cfc2340186d9cab89bc3d984a59e822d3e20fe09543c1dffd0da9aee79d6ad8176307e45e13833ef2b5dd6c8fe92687e6e023c5e583fe46a7d913a5e216bccefa0b1dc9e7b42b157d25aabbdc3d08f2027d9ffbafea22d563a19a4ded3663a468ac485884bedbf91caff56ae053b306eb2ba8936bae425446507fbe76cb85f8b207b810ab829102ff6f143ceaf4e68d65afa5c30784d0e8bc77622ad5d6ceaaf8ff2081cc7853ee17395d4991e96f1c9ed358431f82b0a21b85ed3a4100faa94e89eb68484d4688c407316f00e6d123a3a41bd785c996d1e1440a42cdd47d4a4ca12354abd8514508d191d3fbd7e9827a7d600d9bea9f3f07f0a40433abc163387af4cb5849b384618e5d5c4c4e4249b5aea302e5b0fa7287bb8af1fdeaab6411ac4efb538430671f7683e4861ca6366d9ae4385880640a8e88b7e31fce3303b8ecff7df39484357304da54bde5bbaa916340c925530fd4197cda8461bf41ba364f52f4e1828d57cc7847828ac455e6ed20329dd3808129ea9c1f5babc2d36edbe42db1c7be140e8836cc41d97b868fed3613236c14382643efd94faca8acee6f4e198afe782f84212a35e0db09e80449f4cd656e6c6b0c453de61637617b6226e0ad91167731f6957a84bf8e2b8cb0343f694b7dc555dffdf9f69e766ea9b9918e56e322921126296802ccb959b5225366088bc2d74920c7e841f1bf2d993998a212ae93ae3c538d073d44ffbe4357efe08a4fe88abe4949e4f5e327efdc0b329f15f3933c5e3fdf0a2c41e95d6b1cc1f3d3b759cac27ffbddcfd58e791a17ed520bc34a2ed3178dc93b47b84ce4fabfa30dc14022d37368e670b3bf3cc522f773c91a34a7a3a8f3d0b0200f79f5cc5736e97a675b4db38e2788cc49c3dc1dfaebbe260591cb24b74e65cac236d6379e170e8cd059406d3d289a8f0c84d1b90411a194af1dd1c0948df988bea3571505c6833b3234ecaa867838b2e9de4cb588d6e98e75325efa5820ca72fd201ed782d8fa5bebc46bf22f738bfd63e6883557be3baee3737aa18f6a24410f6eed7f2ba157149e2b7b1611155cacbd7359757ce8e1f40a40652a62e3fefed0cd1b18406605cbaebc51ff60eb2d4a2d5e529326248a28cf7ec5a3b41b2ea488454f2bb44be5b23cd1be335cfe34a0782cc389a4a9904b019bdd3fa7827a03b3fb030656a99cde360ffa32b0c87f5b72138e04c92516fcda0acfa14e5846c09cbdbe8ba874f6e90b97775ee2201b158ef4ad70e24990e18644c6b25335fc7e242342641ad1e62bfcf0756db3c496df83c86877fb5c7ac9ba7e802701fb972a902855c4608463316c5b9a53016c39b769c151b254ecb875af22d42ec12daa973cb19d8ec14fbe73ac4c42835ad5f4c58bd53b03afef77376cf3518c052b7f88e5d06f6db15657fbc220dec2fd73288a511a8a4e743db6ea3dc38dd138e5aee838395ca78ed58feedcc0eb37a5d25fdd265970d0cfc976edf898a9ceb678af0e701476cf0420f061266ae0b6a8ae7897d6ed913623e9ee63cdf68222fef1b7d18be2f46a14819fc646b1d85c9af68cae2adc705c27337181fdde76a26c6e4de0ba6dc0fcabe456a6c87177858e11e5b2d2d0ff47fd86b69fe6e9aea8b7a9ae518c93ac190fd5aedead02ac6658435f81ada4ad9ac5c18a439738b9d0774da756a4fa04c3698e5bd52d20071af038118f7614e739b343c509940bd7d01f264e99c2d601db1dc31436b858bbc5e2b2ea8422e30f58aef8e147331bb2a9dea0cd044d88080b308fe4ec711efc99aa405de68283d7549ffe198596ab46fd28616394f7e60dfcb4d5c29d2015f7c822fef5d62d44c597e04ffc90aa4d73cb266d457f3eaf84509bc767f139e9b0d3d744e9581bbaebd46578c884f3b1a359392ecd652591970154361645c248c82f49953cb14658c157f45eb70c0dbcf09df9c9dcb6af92666f6cb068143deb8f30b0a3a40114de9c223d5b0d53e9dec72953374efd22fba65f27a28e597b86d39145f2deacd771182a65026b4b258ebadbcd60772d426ea448363b82898926fb0cf3d58fd177d9bb53e96d2833074d1645b85b07f757a1f9e44d8b45b2a806cc48b6e1dc4ac5193623e3128571c0f05f868ed49846ce0f410e3402c821085febfaf1390e3848f1d550496cc125806e4c273756411892d7280a17452e46c9044e2267d114d914ed005585bd04bc1bcb3240db7d699ed9c34b7d58093f8a03341179c06e1d1cdf9305cdfe6d56a2586bc14ba7a35cee9f4c3dad1aa7f2a34d29338e46ea55ee5677743fed2927c3c3ce0b46985fd51ee7249a786cf427b6c1c83ececa0dd874d2d7aebce3e6bc6cebfab3a5010475abe0524e345edd6aa282e7a8f680429e8e170e85db49c7bc67a299fe3791b943e2e285ed9a55d4df100d73dd3dcc5c85e0ff8b9397b72e54f68e02475dd86a00e79142c0b133217962397db1246d7113c4ce216b31934be0319a0734c09557677975d21cee0414fc04b2c431ad6b0fe6f277ccbbc32f8edcd2f51e72d639ed4e5e9f8076654e5409988feb1cafbcd798c7f689e329ace4e11207b4916ca3c132c08384705e95556c277ef2d35c9602ebb1f260ec21eabe278b8bf42cdc1fe880bb588a8c3002bcd7f03bc0c5102c80c26aa1beb2e24813308d83558654883fe64e1eccb7e7e665c9b00751c921b55ef23e88de7f1b5a6afa5e9ddf776fc4d83e4bdfe4d7e334853f15e3a2df7c425682bd302eeae10f765a6083cf7ddf05c18bb6691337f1e825930c54d9bc545d02ce248e68e350258ea8ca3174351ed5c398e4345a748b368f0b54a6ad250e8cf001876d72d38e62a2bbfa1168f91689c5bff003bca34e3dc07fbe0d62c388780473c375c1fbf904871e386fecd972b49759947f822a05ca1e844040256ba20ac03e1497a7527970c49cdf3d19533d3bd071ce5b49f6b8fc17e28b4ab287dae31cab3f8355d7ee811ddee500c2782bc68c90107a63e21a20a124a8eea69c3085921c0713d803364469c6ffddbfb28fbbf343b453b5aa6b06b3cacf44ff6568426abc4a1286efc4e0697eed44d7d8fc5fd265e439daa09f70a473b0c5b3657cd4b600fe78a682e2bd3a7a8f7fdf75c614276a6629db853cf9fb98b525528dd0ff661a7e2ab7c68396c97141adf80a8885a2bec297c44041c3efa8c5d0e188c6be53c39d29ae616ebd3ba23566bd5d4c3b9f79f1b9e10faa029a318bb12e68397db1cecdfdcf6f7f5bf071534ef845e9ea76311ae8cfc7eaf5b638ba1e37460187d0c6926f53111f2dc744b0de552658d88c3a0dd7fa997e52e63bd85f71bc1bd55f55df9d3a74e43dcd29214782400c28d489c4be3af6d9d89be545ed865187a3baeb747f6eb70394ea29e6f986778321857dc79db6aaed995085783fad624305318e623c0c8d0a2cc1794a5b1ccbb48803c53c829a8d76ed2c811b3784355b9a3be45ec1ca528fa762f91abf3f0c1ca9c245da192ab7c7346086807babdea826a2b08c0192db112d5ac8270bde66676a6da435831d74e501eae4f80c1900b428e2c8d5dceead35ae34489b735e4d0142931e9fa264b4d521a4af13a2e0d6030f8c89a151818244fa64ad36d6cd2caac0112e7c58d50786a15f6d7f365170b48a4b629904fc193bb3c5cfadb3a67a3406a379b8fc2f5c5101cba37475c39ebfa66cf84a6ee834e79419aa2113d5d755e92be3e4d3d97d42eba0bbadf11e83512b55e4528f739d06e3d429ee992180f4d4e891968c4c12339d310c587cdec3e995f7469a7b05e27b46e143c98acd0227ccb5a1f8f8e91d224213cb883772fe3a97e0171d3d093596c77adf65651870ccb2f063ad1ea7d440d0e45e159cd6ef00ae432c7140f33cf32b9f814f231c3f64705930790fe1e58df4d7fc5cdb358fc8a634b0572ca4e9e5b2308909c010674fc3b410d6d54810d20fb519f7fb0512842a69216d3164ac45f630c288c47bb0dd7c6a930b26cfb74f8b3fd6fba97a2547c96e0ea4105fc3958fd11e90466e23baad417e3b3de8c2de5f6deb595c1ddf61190b310c262d175eb0e0dcc373551c85d1391cf4836d21b5be14c548e44ceb10401623c69d88d028e36e4bc63b6d7983b7ac4e84c6a5d8a0fc3d97153c41079d6932893431e659d1583dd12a13b191a36eff90263c71be6b168e88969f947626cb9ccc240103c2169c185c3a3a2be7fdb09628516c0c31d66819aef2b6db34d74290bf7cd053b393dd46c83bcc7bbf922729cc4c14a3bcf01830bd245069fcea3afa6b06ad8ce6b1004b9fb37b97eeebbc29df38cc8b2a9f34e4f6b292e3602807b50a523b38dbc9c5a81e79cab9d833f09a7bb042f06dcae06b767a69aa2832a89b19aa75dfe834d37a2296d9a681e73f8747df2c97f7a6165cd814b07ed7bbf403fd96608312fedd23fe0d2b883d143cbfcb35d1b126b2bd018483479375f173262e2ae210b1f9959d6e6e96620c4819a5735e6e43436ec4678fad186a25dbe096bf6801a2458fdef81927f5c18164f3e9bf9f7123eb8051f98befd2229b21b306d213bb6eeb559077653d161a3ec309071cb03ee2fc880f232123020515ed63ca7586f4a70fb4fa5be1798bf2039503c8a807f913b0173edde2af49d46da8c9422c1c4faac08f8792df1faec83c269398924ad72446d7034506c17a8083ba257d0c8c14739be683e526326f23d0553e0ba8b4076a6289d94a806ac2eb64a86a9014b1d89e9bee5dd26a4a7643f12d91cff0ca0572f874489a42ad825764b914b02fb37d173dcebeacca7e81f8b60f08e5ea155cfd147e98aa625e7cb063b1504bb34dd88b3cedba64bc48313bcee4bcf9c85833def352eb563df173b8df9dff37d4780d5c7e49bbcec72a5a00e4a2b1999bf14c9f3bd8f03886e6f14d83229653d9b4d687be513be968d8706e8430e5db1540fb82ec8a6a29eaab66cac637cd47005724b051c368d59a803098d1357c78ee15480de23b7b222d84920f49c98385d970016dc1fd53709a08080e29f8657b2d224e22ebefb65c0c742533629f9d381fb64a8217f3e33499312fcf3b9304764629a573c70d3a0bc20b27af624daba85d167895bf4178c1823a9c84af46c09639cfdea27287ed3dcebd8817222c70fe958528c6ef943cc2f4d8d27267a2877d4d03cc962af6e31c25514672a2061eb1f287e8b05a744015cb49a67e40fc1ed96da9b75c900edd0bb0236e0eab4251be975b60148661703e68aef21cfc6f427c0e95ca6db7f6f3312e7dafc2b71193d385e9dbe33cd91ba1b78e071239a932134f2b25f9c8abfee82e66b519fa4b511b50273896d73d8bd927c9afadcc3dccdefd52b11facb8cc854746621e4429189ea5dc3d2929cec6788ed70cc28c9e86edd1a779db32eddfe412e5098b5e1a59124f846bc2c9f8a09e4e4ed87fd0810bbaf579f237c8c3b3ed5d70d278e2595ebfd099c38b3edeff3c43b78000e958ba36237d2c7dfe4d6867ee62e45ab5dee3c8fe8aa0bd69448f9072b1ec1e33596121412cb91d0f96e59e10624f6f556c906e4cc6acee35bd526c9482f055838b9c3ed6c5735c0a9a579db01ca2940498e79c6b4a66408dde4f64e7431d3604dd5efe9e7f06887eb6603792feabf6da3498bd32b214ec10c9062f447b0b0cb7db65c59f9b37e1b367f130761b05c20da3fff9d7a0604a9a612c390388fde05267ef15dbca1847b9b2baf0f3b75a3e6e3cbd57d18cde9f677a4224b1641a8731f1ad26aa8524bd92b0437eb616f48bc8ac5cc4105a6c2003f2a33124c610301e3aad74f81b51a2c9b912b3e34f5d576cf7c2ecc2a720f2c2fa3dba1a7ff416d5d5b201f9f5c0e541053ada6d5c604d9469522a9861085c6e08694b81904d0347531e48f8744cf73fdd8227f128960d972d8dedf5b98e33a1aa8b0d11a63e5372669147761708d9e977e4620d608d73404416a41d8da22189cb0337ea8fc90c3bc9dbebbfae8cc5cdcb42c07d423b7548203b29ba786b028c4a5a316dc7ff381a2f81d4f472516a26d94b2508359c99e68cf3154602e5a2fff12b8680ebadb09f9c64fb45b2130658b27316ee11b5bf449c54e44e68d414e0bea1bc5a71b25b939e2eb85de2d44233002f41c67da2b9a3b72ff12ced7abfc110c5a912a80428690ace4c770b467e91bbf55918030ca0c9d931c9ec21aa1c3f23a10f43a3185712a3611d0ecd564ed1cf63bc05f509b1b391b8a8801c43a7e9db1d84ce63e198361e1b5cb8d49fe6b54f262e4e60d8c32af0d42e5c241dde99b6152523e7f647fd34209fa072bbce6143c20c2f6bc8b3503e989d5830a9655469e942a5ac90ade10e9e93cc49f8e31efe613084747e6432d59fb68ef3a68914fdb6327a4a635e493aa26cf9d1e6d0252da7b52a01760d961f705aa5be896bcdab0cf26368f809a4c459be304fd20a293b353608467e270e7b2c0e4169dc6fd9ff1020d458bfe1dda1d633dc5be579e2367fdbf63c7ef3d5a670f65388f3e72852eda16c49011c510fac2bf53dc4c759056d87dee8262497258c21a6f3237af1a9e29b8f2b1735811ccaab927c9fd80341e73708c1043b706a9e6dc66bb03dc8f33935aae3cc4382555a554083a821f5d841f48e5e3ba833137ce730c95fc4ce7813c96b201237c0bcddf75825c4f05837811e8e919752cdf587bced54122ed859f85c91d2158a7929590dc7ae80f4511d4b8c4be1160ab6c5d8cd1bbe0e9cb5341ece662ce2a00a9c8026d47830421365fc16638621c5735e75f86a9c9a74afd4675ed33a71392d6fb23323097924e36bbc18db56ef1f6f34b448a73717169e5a4ff9e763f4353424642a98a0687fbc1faf87d972a41444f4a72b2ff01ae655996f7f31a0b6d511dd9488c751d27f9c8770d2d12082b2e679c5b7fac8511fbbfb27532eb14e31ad8e312b2d3e31b25f976185cadd925e67c289ce97348de05a62adff0b7acaac8bef873ddda1eafe034395460c0a794f326d3a7311293a68752b97c5022d09db907f06f96965fe3ec668cdf60650a06d86028be0967ba7c09c57e6f45af87d99d45f3cc7ffeb607c4523dbc3dfd43ce02d39965f67748e8d54e4415f43d4abdecc8c9123bb08483ca3819f672fe4e080df00435d2d2acba1361e86ed1f8790043767b9e1e01950b915934b70c9dcc82ad8987917d5f30e2c1657a2a5be4df4402d9001e0e90f12e0d78779df7e251474ce38fe23441d9ec91cfacdf3838d024131f475131ad6c0d11366446f30b9fabd2e485f9f0d8022034350256bed4ff354f81dbd7a13736bd9e6284859e1e2ec44d415e0eeda295331ba04dabce04849758cae8ace1d35080558ccc4fc11cc83cabf352a8e77b8af43ecda93e7fe847c0c0f3e0c2c309f20fd94798eb38cc353f0171ac759939682c47ed063b0b4ef9e28ced88d08bacc4137e8ecb7a48f60ef9e3f4c35402700060ce6b31c750552916d2e6ae3b71a8485228610baa7fb3a0dc977900f61681d8c11d86bdecb8376801bc26ea0c4649bf7b8d9bd5d48603da09bd39f4ebb7401de3f9bbe51f25af9e2a725c48f93de97208a405685708833c719ff929be1c9b4838d1a505c10fa36ec11f3ecf8a07c96fd185e8a852718dd22d03689818ef3ce9379daca66987263e9f591b23f70345a3739a214b5dbdea6d56e0e1e29f06685972c42b58e0d10eeae2fa4415ff7e47b931deb1668dd41be248910130f7347b653c2eeeb79ad540807091fa4837a8828b7190975f73b6526a46f3da314b63b9ab2780f5c2e105c316d909ab09276a1e2ad93dd5996acad7c14ba16ee1d18a6c22fb7d718f232c5d7d3c606273802c9477c0bf8514698e9aa036dc0aee7bb9b2de89ee8148dd353038358679cad6ed07cf6ed63445d9d777953052a4e35d04990b7ba97fa033263024cc1fb25933f4af1ad7e4d4ddd6b30b2564edebbf8f5a360c7f045e298095bc0e39851f04b14d101b146a5e339e25c2db0657376d04c9a04afd7dbf075f09db7c46a3f2cda36044c8a1f7ed6a74e71d67efea71d3d9b1f231a87abc84fbdaaf232f1eca757f5e64326b560ada1dafd7af4f666827da790592af1698fd99bfe32a0c030a54d5a7f879ccb039bb4407a8b554f8d19d19b86a6ef4792948aca44fa4d839558b23d8deca479e580935f5d76bdbbdda112f216b887d9b4cc5773ca82ae2ee1aa7f4389d0c144904107d623eebc7d50f4673fe560f9698e2736b5297479debf374ce83771e785628108bb44cb2c18bb30842f703e3c992dad6bdf62b3a68dd0cfd2eb810603c9323f0817afff10dd2ff794a87fa9d35e2a352022faf86549f30477e31f338fd7a8e81dbbdd0c17e4ee76f78defce751ab1c80e6d9fd3b6baa1a2314ad6827b696dafb1cd9d078b999654f6d549bc77ee60d275c38a61ac3fe529c6f5424141927964d6ff6f3974da5433abc04a74265f46a78a65bce34b396fce39a7dc6d206b7f76d5a1339b0555f3e56ff6df407cf11f1a96f41a6d245b22196269fce57dedde841ddcc41510a57e622b179e6942759c6f0b6053887db71b6ddd1fc1c5833a88e509c6c6192cef79c24f5b92a677db662f828114ab0f1852593b63f78961432b391e2fc5f55f9e0c4f571a7133085341185bb29f95a09c0e538e6a856f1e10c4c04c00c3e0d77d77aae3f5cacc19f58f1966de1c0eeb0389b16b645a168444c90357c00d9b778d52fce2fbba9f49c7dd09609ad701e7063d0c35b912e73a5f56f06b110b2d56e715b43e57b5f8563878dcfd21e7487dfb80c425bb9b0dadbb0ed37acf84f08136543119c1c880e9f80a7cb42ec611f12c0c7e314370a2a590b76c043e28831b265ae966459bae579a318c1e96b299e214d3c64eefee39ac4993e9185a9a6e750d8ceee6a43ad5a86048f2965cde20f3b5cec1a2fdfea3eb999015b8eb6d27892380a9e285a7d65cb0efb6c08e423daed133575f3d4b5a5dec9e4fceaeeeb5a6e7f9d110b41873f598e244b311e316e78506fd16809a9c6a66929cac8c10c05625e8414862cd0755bd033852f34fff2b1de2090145e2bc4effb539477e595ae100ced3a331e3dd4331a2117957b3176e2b2bd36e41597560beab688ca6d9833ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
