<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7dc61fdb5401b8ed67e7b42f9d67cd8eb23a9993297146c309acbc169814a67f07cd3aa287dded10e188d5f5d33006ff0da8c457371a9f78de16685292d65fc591162f6325660475cf7be091d94049c1377d36d8f1aaee92adb534d4ffdc4614baa52b212b758fc957fc91c5c24313d5b81fd95140c79d68f5cd73b91a29a9da8d5f307ece68c0a452f70b0ead22b52771c57963fb16a9094235340e5c7fd1ea488b30b562070ad1c35c7f8953285ad894ae0768d2debbcae90990ac7d4a936ea22ae00d9973c145c6e68b5bd4ecaf05cbdb81d33eede138631bf02663f256a7e62affb1cc808817a4303bfdeb7007fe71e64ee2268b07775e05a3cef4181e4059c5f39470326c0565d8701fa988e5dda0c6d53abf60a5f91ecfce9ff7fa5c7ccf928728e35658499b5a559ab2d6ce22c9c1afd9bb0efc8fec4e7af0fd48d2eb0bfad519718fd73e106809483bca1ee67792b3948f08348bce479059193667faa4cf158f92746d20a18df73ef597c9d69119bf72867a3063c2030a0bb2fa605e40c03f9a1e42f6c82fd245afc613031b179a3d9b886c60d3bf8517279a52637f3bc3eecd7de804749a78c6594db91db2bd702cf19aa5358e79c4bc511536a984850237dd56ab6c5817dd7e6d0de9c9d67ab1f4b3c935fe30d36ef9c49fa3849e0c796b0e587e3ecf17f471dce1a279fe50f588098c19c7e7ea2d116bcf7042a65062a3b726f8cf967ac49e65b089765c741af9b65ddfdc080cd859ffdd6d537bed432de74518afe6b764c1bf9505b31bb32e6836301b5cddeb6de23b70b41bf8e5eb0fef470d87db79d402cd900de0f6b0b53794e70e45189967084178e058e37e9159590f0c0c3a5e6976c176146901764265e6420f38917e169a515bdf9c9870b53a03eecbf47c44f2cc39949fb2a50a18156cf83c40dd992fe55334f7e59a012872808f9d798451eac22fea1706783b830cc418018501a394ae2e7373f91bf22e98d44e7dbbc3042c03758aa6e78da732424ed0dfcbd1e8c69207487ea88f3f031581535a2c319109bc3d2237be4bc71ceb1c4fd0302c82cb5a1162cacd04d7e5b4660ef9e8a2af65090bffa3176b4ba0c36345990c04a7f6fa010d753006a3cf9d190ed5327cce53332464f81de824adb6f719889ef1eb2cd60162401d75f97289fe1aeeafd4fe3bf6e2d57664be722e1a45d8550f2de56a0d5eea974d4de6070e3f366a156d59b7a61026b860d7f17cd2b368e2ff61a18e2a78e8702515d432890f70c88f175a82e975fece6d418cc0830be5f38b43f49fb73ba33bef9a46d09a98e01707bb62c9dd5008a9fc978b3d8506649c4a6f2ef3cd9211de381f848a1b18179157c1c6e85e1966dc35b2f9f6b95bd3894e84fcb6e9086b73d5fcad941288b7d2a3b77d628d7369feb6c615e5eaec74900d8162f3ff3317b404922ccea59d144756430cbb8c5227c65d7668fc3031ca9c090223cd62d983f1daa0ac85d627c5cd287b08df53e905b37a5ba518c47511c7cdc1261e031e3f0c9d3b119493363a224e99004c1f7b01b8737b33a0d829ba68dc7e305b3bad8f6603a57fdb08dc2b32bc33f0fedad142e5342e2c85cdad18ffa81a1dafd8fda10f71b14c52277ce8b2bd4c1f3ee562e06d4253788fa98b20d85dff8b8e9a2bdafe19c1ecf9663a83f2f3069e7cbf241a197d953315535836fcb1159e5eaf73d8f007899144f506eeff477d4787fcd72feb36cb4ed41e7f41c3370ffc75c3ed67709625f9a542f5d37d23f5e4d84401a68c3cc7febebe305ec9232c37088d04ae59b193c008ba285fbd9c8971f99cf327cce7bfb70bb90ac1097ab126193ea467ba60ffedb619995ac493e417f5675e930dc45909533d55c824510486a98aafdad6d92973ad1191d6f72b9bb42654f87e20e6320db55fd150d0e5ed5d0fbcefac353cd24e24af5be23a1e8159dd9a3b9c2259b9c7c3e226a575f7693576d711c27cbdc021e90dfab6bafe6b72a53f17c40d3bfec8cbf58c65672d1d644c80de038fd596c31147b5cf9f1c5c9401704782cac299bc07ecb09aa01de15b40b65f14f815e4fc46cc00646de42d4d8a5692003fca70054f18d1c2cfc69c3ff2a7b35337501fe6e79bba7b357c3ffd0ae06722c6526f64b53692842d9fc67f4ddc6b824cf8000db3b9309193811c1d031f02f27ba3973dfbff1de61bbf65ec6ea4efc74e4600be8d610b30b842d83a01ed489631269d608bb41901b37a7578c966b4f84e194bca48599d24372665b2de5bd0ee78ec9e49fc476d4d345132bd041f75d3e0b260c28545ab61ab965c35aecf6e588b502db23ce9aa68b01055b7931855727a6dc3a572fd9bd048a6cc048f57e4e8d13a3602d99c80458d92befb12092f22dfbb875912e3085813b255d954bc6e0e490c0a117196c9367b4c48e74d89fad79154bb637976108839490003bf1f9f7aa0130369ffd3a8fb6e779fe2b2c72accaa265ba2f2ff8e3fa122dd6d26afb88fffad9e88f34644955dba292adead240d40f08c4f8c8bdbe02a3308ca0d37ee1ab2a5920ff2e9bc4708dfa0e87423e8f6d3f22b1d0f47dda7a9000a2bc22f2e03b939050a67ed20eedc0cd2b95f569bbd534374669c46b180b65a046c651d7c1355ff29f399295de41da0cf36e3c94752cdd22acb39ddeda93893653135ec4084d5024202abe5e216f305b730841f7f6094e35b6360bd65c92fca1cb8143cee19dbd926bdb1efa44f1307a6d0a7b478ce4f62811fe6624f3b4c63ac3dc78b65fc6beebcca6093550517cbfa091f4844a509e7f588cd10d3b5b6b3a784db5f3f1bdbc4fafd5732e9bebb55f910bc839568d37a34a35c1131f287222f3f809d5dbce9250273424159a1b5537608f08f988ce8a5f5d034b5bda78a275a7dd6d8c6ca060e385a31af3bde9da160037c51379e814adfa05ac7e3fb1c79780a6cdb3f2df45c86d882aea63ac5cc6d875c1cb1cbe8a8a78c4b011930392144798e2e99b8d67cad9ba882c8c4eabb0d1d4d687fdd93e30130a027fd328fd100e8a9c91be5df6ed1bc063b2e8a0822ca5f50537c7ffe5d7ccec4bc40bcf96290c3fce48a5f853bb5eb87ea319c03c0be3e6e9f0f13600cb3a92921c509db8c613929cace46c23917bb4f98911329df988adb7c7e27d997c8f3591a22bddcba335d8826b0f042d73b9214a48d293531815cc9c98055e15929769965f5a84267fe230778e52b922b64da3727803fba1d1195bb58e0496600dee751ac6b93ad528dbf7f0b45db7020c4f5bfb96d059ec28675dfca477ac0b6cae9521ad321871a19688950a0a297c3516fa4044d9b43f21a9c20acb19d3f6dd6280d73ad21ccb552c84079ccaf968e81e17c278aa1edb2ac68d23a7855d956a883f7571c40050ee2a48aa115f8db9254521283f8e63cb9ca2e3283de05936ba77f21fdc0edcbf9ac42b2fa67bd3d53b61104670f0affc295d3ad4308021b11bb82a237c35c6caa13322ef624a0606300aec9fc14d75a3ebdb373037624b3156ac6e53fa2df2e1d621c1f59ea5727d35d50458896f711eb26072703b8937dabb3dfaad0264d45bab92f0b0bc1b41d4405e05a331010d6c3948e7cba16abf259e8f31567ec1c32bc779cba4b2cf9a31cf1bf7035820c41d754cc60493e737529c7cc3908a8580ac1260f7fa6224a4fb244555d3d6591c053974eaa31b74dc12232308f0d61f86e05374eda571f267d2aec3fd0578402c022835d12b33eece0cc2161772e5204ae2b4e7b7e0b46efd4da41793e27f87e0dc492e76364349d361e7bea2cde8cae60f43498e16566d875b01c676e97e216a1388f5afbea697e2b311c9bbcfa5346e5b15997380997f50ee629ab6115ff029bfa5b4f7c9fd2831f779cec5c99c2f0d236d67d7ef3f164290a9f88a02802d57b947b2feadc57f2db88916de4521bd3225d23861f364405c99206fd404afa745170a1028a0974880330c1cccc900511780ede1b5a864885b4e55eee8c13bce380bc628dd2a9bc68982a3fd38afa9154512cff9ee9bf32a7164a6019841402f1b8310ce26b94144cb41ac99a1a60c69e0eb89e3d2124c98a7cda9d2f3e96067c7c8af0b4a359f48c542a80ae47f75e3b04d2b60064df290d1046a45e78a9cbeb51e3bfcee7bacafdf2d33d4602599e43a255b2092e30428e659d7deb5a7592661334c471e9166ea904c8daf23ece2b78355ff6024bab9fcd5bae85c80295cd14890de6339f182f90b296cfa02cb9e35a5ad4d769979e6509ea3ea6d050a1922899e2db2c0eba65f4acca12ac1de1b1b7346bc653656725216ef1b545f6fc72d48400fff4e0d1f03345cd9a311ec3d0c1495ba1cd9ed564b767f2e47d71a47fcda9a80f8913f9f6d57ec997542a439608a278a67664812b95550cbdadbb071ce868c4172cf7f311aa678339aae2602e4f1fc260c3584adc960b0cc7090efa6b3ee34d1e7ea384d1e8c75b77feee39e495290e3c95eb7f5d37a1aeb0bed81c68b2bba0d5f0ee5e7b8e199303c8c1bce7d94b9272d72fa9e74bc0fee855805c2867449ffadac368344f82c7b74c0751673bde94e26a25b52f0e7e38e18a78294e4b5366c2e16a9bc4d6f48a0cf757ce82ff30b1168dde90ed964d350e4b3757fefb50c061d7d4d4a6d20e49593697fa3ded2f56c7e6a8d0ae5a07e6d703f02fd9db173f70311ca17f10a22eeeba9e65b1cb07fbe48b39601b107b778f9194176e16a8d5b1797d159dd3b8478e714e534dde1577a6f689352398ec8c73b5546f117a93dbfb641ae777a87fd47601f589f4acb7b8ab2c670a680f947fb3b113f6c9ec244b6f878371ec4eb32abc14dc684972b0308729071583c76dacc48c235f56cfcff244f1b317f7d9ec70db6a2d441266195cda7b21d76adce659310d40a7be1cfedd474b32e86d9d926c204c8d982e69a1bf14e6248465f5a8a74b1cd3bfa94c45a0d4b0002825b547b7b44bc33b409c3a5a2e64dedc89d0d6d9110712b4274c122ea4a8992d87bcf989166cf33c9771dcafc338971092f9e5aa90855827994f13b526848d4790bdc7e561a250a3df75b7a0d81cbcbcaf27219c7a06fdf3b25993d3e0c1e5eb0fffe5e074c6826fcbfbf88a9cb2d229940afa7708a54b2831c33081ee287591e4eb6113a9a65cdfdaefced1ca8f20c5ce162bd9b32434b5d51decdd2c5a48a5d3c6811d89536a338ef8e769d1b47578ce2112b94c3821d6711b1094fde2aacce68462e6196a53c867aa17ad7d5cc6aee169c4cd1c83061646a5444fc27637ed426afc746ba43859396b9bf9512b59793d56d0d769588d1809176a3cfc241517951155e00d60b81aa2c69480387ceab91cdcf79f9f6cbc48d62df1345557ac5b4c3e6781eaca718316e65d2fafb7ce59294091370e1ef73503d2c3667fac4bd926582d21c7fc989de4e9a6dbbc22cc097829f2961f2330d8d8a0f081510053d2e8e272fa226a4644e91e80b91002353762ac3a136507815305c363516e24dfe3b3c0cf4db949d80ba672eae4a63454b7b6707f0116e11e744e62a223c28625566d33c99b80a2516b6fee23beed27cd945f9e33566a552993a0c966357b521aff5018d935865d5530877db3ed625c9049abc9851655148ab9f4db547eddcf368ece74c9bd0dba9da2646e10beb884d533ced46c8c88bb9c9f10408b9df5449d8f8420fe8d08957c560e77bee30db874cde05db080c64c5fb1458f120493bb94bd44fa52f6ae884a3c470c38532cf2b8def05702a8d89d010fd02e1dd8b34a0487bc2ae1f24796ab23f4826810dc20b36da9005e8a73daca5107481758550a40fe355ff4c173b5b00cd1e0f54b76d860dcd1e127b3a4abfdf6fd7f2e4aa64c42c5aefdd69fa9cce08ceea9b1e9bac28c694c1694dc18a77fbb22c2763677be38a444846e73aa9ca9a6c6aa55e98ebd18ff220b0771436a5b4ddcf4068df720598b4a8e03a7372d6fa0331d9ba8792387ce6371f309a7b8770985c0a73564321f4eb21b56e92eef84f69ba87e8f42bf01d7eb177317c96da48c047adfda8174b95c5da292fd3bf7bb07dfcb5f8580b29ac9c28c57d3c119e7636859c4160c2a595888e078960cc1431a104e0bd5141edcfd18239bce4b1622c661e726d14ad2ffcee5e7d9ea359ff4da119270871dd44d8f0c95a498b39e55a4c3986179a1538e0e4b7d8cff5bb6201c088721c41259561d7d88648b43e81c83696ea043122dcb7f324ac9ebce03d6f9e8433e430ff7d4acc2c3f21c606141e63745db2f7971b6cdd5d166c5275645e959db5b5b7e21be1199c6d49faf3bc13ff82a47ad30a280f08c135a00bbd5dae2a4a07bfd5ea1f1329100d93ddd8a7d00f7edc2b73ca70f6273b9ca87a8fb7201039817f65b3550f46e1ce50beb69f819d30986ad9fd4acaeed22e3c063900ca86b1eeeabf29ac3c9d13b3ec645081379449af4769df93522dea0d7e0339c9f00ce95bd69447e730a87487033eab69dfd55c11817141aac1b784860588ccecfdadfff27b7b2633b67a0f3a5e8352de89631689349cd646b5e5c0932eb8e1ea33f2b00290344da93070c2d6b0612d2d48fdbe3c079691c93353f425fd2f44bd809cc90a866d04d41e406c23c7ca77384a7318e4660f51ce77e073d9a94c6785f624c32bacb32d1ce73569baec68a45a65273f35c19bbdc9e3442d3da29775235f718ab016aeb2681627e4ebe27c3baf12e829c571a7e7aabf323d3d89fb7b578869740e50aada3ab51c550d15da52964fb6e1645502b950637cc1fb3b354f46fc008804f30c474d45645ef8d2aac415b178b134c6c2a823f2c981be84902d3b34a0e63ae6245ce52a398eb2fde842bb79625b93d6c2b762b71c09a80713365c5ebac507e70f4c96464c5dca4bf91e3539113da3dba8ac6942d9907264213c13c4c1a77a7c318cf5ccd0aea055e84653b3955c42783765eed205384ccd34ba44c3661d798efc4360d6186b75c1a9e9f5d102305a0e0d2772a75ce0a8da649a9c8e26dfc5d5221485b75af7ed04b95511c2a6e7189d2860a12752011f280259b861570a8b50b2bbb657774742c1d8c7d4f2d84867856a1ff2d5ec0f3a7c450be584334e5aeaa83a995927506d2fd8fdb0e1a63800617b7deedde3192088f89bb2a96c72ecac90d1b06800b2ac0979888dddef79c368ed9c56ab28ff21f34ae8104036961883f5f1a0a4a1da4fba012e54968f04645bc97f381fc5269f74ce7dc01ba589b92272278e55e14291aa599c71f4db1603a8f561016c13ae71d2695c610a57b2abf134ce5ecd94ebb67949ba20f4af2ffc1837fe52f3ad0b97e85be0bdaff6d93b1f051e2fedf71fbe0f07ba8ed428b5b96f2a29a4746edfed619628896a0d2fbc9f61276e06b6dd4357f770ee72a847a247a811e5ecb79133e6b5705520353151eaec5222bb13a51b69ebea67f851a099ce99e1eefb3682f187ceac0cbf7daad76ebd71e5b3ef62a06b4e77015efd621591badacc31c199e797386f1badb3091380e1e75ca991f7c71f96041499c391d5530649f000d26cc425f4a3d3e930f447f537706cefb7482b4b0166cb1f5f42680d3b9b4b37ccf2e7dc9fdccd853cb38330b10098ff493af38dd0484557fed23f948f4f4eaeb47b98b2406f4a54d9916809b903ac3f37a4abf4ef1b29f3250a95fb46412e6f8d223c85d912b36aae3511ce7adb7da3845035e7ccde39374a22bb4848238435b8f1c0852c8b168ea5dc1bf0a72d1caa01f70731b814c1505f3fc607a0ff8e2e3f5e0ec3e4386e3a86ee3fd3230eed1eba05e319b6f3fba1bddb9efb6ee31137f5708d263cf277aa590e891bf5846e15216e33933075ceedf5dc613f8414c2ee1f018e7d378b5157c38b27316a4bb6f67b5492e4939d1fa97a2689af016a39eb1466b1ac90e72bbbcde3291ba4113ed6ff2f66fcd114145c2c7e95d54ada431c5c73607d2273603a5e5bd9e53b18ee0d3c58abb4864f2d0b469d0e3f16ccbc1a373030159279b3c1a30c237ab0773da416260d1f3e1f8608461e17593394421dfb51c89782114dba45a918d8077c879c480b44c654552c1f54f2fd151410edce4a13deea988aca7d76bf02c6247ff646a3e3f408970e594cf901104559c9e0eca7c93d0da6714104edc4a643a076586239b7bd1d748c2530e9ce5f9f4bd7165eb0a90945b3198c30f5fb858454c64de87d46e2a80794eb6f8183a2ed8a442a0ade6d05159b77939baa9e61744a607b321fd27668423decc8fc67289ab88d234184c70414fab89a9ea9e788713ce8d0aa4d20c12c78a906ef7912343a1e9304a8e0d18ea17014a2a7f81f92dac709dc1e27960a6403445f9db4d97961aa0e382b8768f3016df620b169c8871c20a5aee994bf9e4a1c782f893710d2a704223c4ce262902e3fbf521905e6ebb0a32065b83e717d9791f03fd691c7dba648439785e2d7a0b2a3b1d781c4eba6eecccb89c44f1fd39ee148cbaf9c265c070182e5733ec589df2d7bbef02a60dd25b3850f609ca2b4567e1f2a4261a58d4c8947a1fc71d88e94759cd1c37fc81ab56989be4babe8a01cb7e8345cfda083f436377ffc4462d90126ca1e0a1741c930b89390e790b8a987e623f9f8ad8ed48477ae8ca4bcf0be7fac39d25ee05ef67a41f3c9241eb94fc3153abf92157cf0f396c7363a6aa74fb7071196bb51dd7310b6d834d0bc4e3e7ccf50be22e2818757f7d6abde07cfcddd57907bbe83d5c3c9cf7321cedbd87183b86fcac6b6328a13a926ca4ab533e2f191451eb877e7452f73344768fa47c271749ca933387e687ce4f85176d39614c929efd037555908d0f6668582c5579f2b8f626d51dd0c8aa5f1e70a9a05149e8dad1b4bf2219c3fc21eb70eb62e058668604e9f4b9d992ab43fd437dbfba9d0d64c60ed97e73d8096e0754dfc7302a3f1b72d5355bd5b49e0bcf4bc11f3980c6416d5f4b6e1f839f9f7f860f0fef8d35c49a6e36b530421d77a603ac4b300edd3e2c7f6ba16203b868e76240c32f1f6566bbbfcc790149d6e7bc824e7a73e85b7d3000a2fcca56c488b5a25d337f7583f663657150c4f18e5c4b48f4c8a7f6a8639c9ceb58329f2baa9815e3618a71e4c344aab5455dda34ad518cc03314c08ae6c458566326d1f4d1223da563e50c7fb3d9b7fdae2f78895c415323630b2409a5b5dbf7d1b8311c6271057a4d4193e383af2048f370d41e97bdb7d4108d1e76e6e67623d9b3daf60a1b0f8472d264fcdefca142e2d056ef6b9f3b72e480d38e7fe9bd8d5c92c7550573a19f40a6c6b44e45739b286ce6604c0e2752cfcc18578751c05ebf39645a7009724cdb93c8f84ea60acf355121e6793cd24fb0eb809066a717830f6b0456f56314dea96c855febd5e6c3adc0ddb4e9390bae85b168a5a3c553b10053a9d3af68728afe13bdd268933260782ee0d524fdba15e3454b328c3f90be0d96efc9b4f8e418e9694dfb050053ca4ef467144f52ace8384691cddaf0422a8e0412cafc21216df601becd2cf85334bf287c0aeb501e2439fd8edcfd887c3acd3ee47323aa07a980dbaae9c451bcdaedc4369502aefa2b2017122298351aa213453e5ba65b61da65244bfe274b093589b6568ecec7cb44b69cde8d0e868a7f5f766df876ffcffa7dbbfc574493e3b22d13d3c36954b217bb9ac8d2a4809e3b14a56b00c34737ad9c848c211769959f5199ed58fb65645fe646e885896e4d1efce0fada110ceb1a72d895f59349d4e5b011af98f53667f134d95286156b55af8ce58b37fe7545aa4ce4a6ab2a9e629b02892187d9421e8717388e3cde1092099f0e8ce1f749549467cdcb112ecc9ba887e4aa37826d0e68abdf07aca86d0be59b2963b32dd1c130979f8024200ceba5aacd977cb0e7926a892930c2f78f6abecc04dd1f22d1ccee1d2ae8e4a37022a424dc71047c47cd1cad6ff7cc6da47182d16fbb785b5d23d5ff0231b2fd27dec9d8cfb5c5ba0ea3551ec7938963effea60661dc02e7561a7dc2ade9ada618959a3b57ea78ce8662dd60446ddff06ded249c46316dc4a651eaf7e35f0af5c5f74b4157abd39c78e774fdacf5b055cd8909f87fefd10bd785d254ac83d933385074e8f5c64ba56ccca061c6dd333a6def429d078eb298484ceaf420466effb9ff059f029ba71951dfbf3c97d942c2dc44d65e5ef4c2313a4747586fdee810306d9bf008be376ec0f9ac8736446ccd0e0feaf6f11db4aa0bfc3d7b742130b22b0f9ee76c1d8db12d179974d18ce9961afed91f6ebe9fb0577d16da4a13a14c0126ef0f072bbcb6810bba5e852c90bd06953c7742b78e63f254ddb000b4b14f040993ad7667e55a4dda0587d4520ab3f71a3b55870a34ee2c8d887090a386a4c74c403bfbe54a481f30ad52a24ee481e91f12550ff7a4755f13251cacbd22ac59c42428632575b7983c8fc553e7c1a04859e44bcc0a7231b894ca7bf4f85f87c7e5c96ec7cbd87e4ef309319d39da05fdb3933cdc24c5bad0013e12e62efe0cecff74f401917cc5183e6d0e015904db107e2e0253002fc839fd218f09c8d6912e4c8cf7913d904afe2d38e769e8d8983803e567b0328502d2734aefbfad925e47b520a219ef0c45185106dd21cc01ee7a50d4f1da13efc1199aa655c168fb2f5b258a3c870b58995c6bd93af0495f2e6547a8f6c497100f63df070b6820caf601e4b4be44a0e64a073d68f6c3012f25fd32675c331d55582c49763741876be821341054de678db7c09e42349863ddc0c5b69202ecd95b1d3bacf271aef79e4ccc93376fa8a844bcf8a6b207e18f6af6c3651186da9d6bf9279549ebe9ee295f76e0aff73b89eab352d80b798ed63c3b02497fc3ca7964106ea5db6c3254d14725b9125c492f9d29c09adab1b399121b42602383f3a265fb185ff147b296b3d904bd9b499cd8a41377a9f05dc8d5ad808da3521dd306e56acf36d1dfa5453985135f4cb2e6853b49ff927ffa7ae701d61f2655f34b9f353b20ccdab2aa7808944e5fb15e0101d94d8625faf2ae90beceb7662188c4b1d87d360f276a87bf3267c8bf2be04d27202249ef5412a6050132ef00dc5f1ad0f40b2e43c4b5fef3d66df7630e77ac06207ba621fbdd0fc15511b81c1dc50572dee894e3efd98f52bbe333fcd94e28628bf238fabfe66ed722aa515ebb52000f234a64cfaa8bcc54a0f9af7b008fd9665f100a4b64560de55d238b654def538442aa254905fd21e0d5ece5876d0758b04aa0fa026393b6061cf07b9e9f69d4b146502ccfc4fba7d47174bb5285c562523e894c08f23b930dcf0f25d5a552f13d6fd69c033bb935e50767f12109f06f7cdb2d6418d123a4262548b33e37f3208516b6ae99df764ef93357aa9d1cefd1148d91f85dc54c7ebd030c7fdf286ddc7e6e15e7ce5a2830fa0d3eb3b4bac27b55869553b65bda2a084d558fbccd78e9299e599323aa6909f58894c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
