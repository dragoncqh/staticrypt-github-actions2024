<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d3c2f46fb8b0c736a6b06d03e032bc83ad2eda7eb9feafc736effa7ad6e93fcb29eddedc296b58bebde0eb9ff7b1245d99d2f0ba04529c42a739f4a0e221d71297c9ccc5169a92508197e240170a5faeafd8c3bbe970462dfcff823a8b5df408dd4b189710b2e06c8f204dc3f5351e81017727cedc6a7be59b5066ab83bcc17aa19a6f0b5211328fe3896808c77c389dfddf8241abc8f09de87cd16fa231469471b584a73a9bdd164bc6f37a6789a40fabc122a65f8bef9162792c99f226a31828c3d777856dfe50f3a0d1ab84f814585ae267eaa7497cc62529f4b73749a5052fa27a45cd0dd7bc23c0bf38974d0cd47e505e681a79f2d3ca08b2fb19eb86e3b90ac7450864548870a1bedd0aa1d75165c71c6dfcd0067975da734477e91c280bed82e0ae39b9236fd0d4a8d12f57a5f1b29401baad135cea2b322382c4dec51bac72cf941df9d9b34a8699fa9659d86f01bd0e8a9d47ee879c51ed4aca81edfffe5abc6312820759452c138b54a1bf18a33bb3d7220ecebc46990a1d75714f4687ff67c79d112274e39506ace551d6621bd9ae6511b7d287a3fc8efb169b4e9fb13360880029d22bc6b8271d2449538dc2321c697b8f091474ec041abf842721c2caa178c2dca9a97ea81ffc13be66bbcf891dac49eb791151b856e1ca618a5fc8081466c7e2baca7fda9e929f0a4167fcd8a68fa60b02c2cd9aed019f5279914530cf232d03a69f208651d3d75f93f5e06507d959c7d9e01efcc48e874601d52861f902c94ddcec92ef715bc79c4d2454e5e83d145fa6ec97adf27b4ddc10c3cde6cbeda6e6e121b411496c10f9d6689f67733f0f2b2b680ef49a7d1c1595529f5c542d1069d6dfd2ad2ad280ec64253ea9969e662fe60d5009ca9e51555ab33c84487fe9f9ee36494583fb562e69cb2b38b720c49a8696d63e42571961032c7ce019dd3917222c493ca90e145c135d4897ce36534ef3a9b8d46b660962ebc6bcc5c0ed72b296e16a00a5ea9539a482f1d160c61c4c56b59e41319852058ad67b618cc9806dc1f548b7fbe03912ae687cb3eeb6c48bf241be87aa956e2ff86811ae90f319928aa3ed1899d9f793fa04a1cb1e9fa355202a92c1b9b45ef8df45f25d67bd7ef923ef8b4c185aa230b7053f72fbd22b2361acac6a267a4b9efe8163e901e28f1c520b58ca339a4300a1e327c87dddb41ebfd2d54d0e1d4455865512a5fd2ee08bdbc3ef3c248d7d0c8d486b70960b2c18a44122ed7dbf9297278deb16a556c2f522246292640d56c11c1ba9601c64b63a97bcaf0fbd6e191edca57f1744a9c4ab0e3ee931460abe1d5583c53db8be07e8d623ecc195919a5ac97df86d7a50f49f19685cec3c5f35dddaa0677acfb8ee9a466e6a6bd5f23264f38948de5af135dc1749e7c358a54e798cee2808b98a00d1fea105dc9e0ff3c16caaa9b5af30bba0e8b61feebef3f48a3280b6df5cfac8e02277739d89b78541f2175fce04ee1d6e01217f8cb9dc2e05bb578665dbac046ea4a179d81f01fb002e66372a9faf27487751b7117a00c010a00959fd99f044e01f8b6617740bfc9464c9ea837b3778ab199d628051839cfd265b717151233b8c2cecabff87f3f763d0320e593d75c61bcf80beff9242823daf29e36a225a5007cfd23e62868ae4d446b2f796b088c2231a7a9dbec7c2702e9e7b704a42af62bacbda4cfc023ad215c45e5801a478e44852a09a5ef9d480029b2c02dcffd5bfb9c0f6dd86a2a19132f1b7500e12ddba8ba7deaabe4be9762e52698a5fce25c26f2f5daac7eb8bd55a0df3c34f7635eacb6bc6b530525ee13b4cca5558b627b0bb7a33240f712555d53f3e8c15667b50ce4e22b6d2f72f93bd557f03b6ed9537f55972574bb88bb0670615f38cb1244ae3c9af3e96b8eeb98dc4ebf54a44f35c929b97d3bcd5127cb8e5f93fb1efeebd333fd9b9b64a06071c34963b92bfa6afd8b52a95a26ac300d48bdf6731d5614e843baa7d51570e5fca5c54cde9a59ec57a11ca88d81a10187a23aa8c3615c0e10b4e2894eadf45206b8bde20dae3578cb44b28d057ce59e2b21b916768b36db931fd4cc702be23bdb9f3b5bafe271072cfa8e59d34e3dac1ce4cb6fbb38a21587143b31d8288c9476928321fcec6f5ac03a580e8e933328fa9f736ad54ca594ae6c5ccc7c6cd56074525ecd265460f050ad140415a6c50b9177042443c02cc4b7ef04b03103be1cb0f4c9cd14b691e6d98e71847864371a2b03e40d6a55e077cbd26e20eaafc87f04563711e3f53735b979808a392fad3f7bef185c5ae65e839742a710e2755f1dc1d18460382e5f61630bd6821408e7b65b94b9eab55abf760ee95d751bafb6ce64f51e62ca7b258afc6044536e031114709a2d629e446fddd0a221b446f45395eef8c9fac468c65c3845a4c8b72617575b48e53122856cbc5985973fc6e07312e7d5e63185c0816b89d7c529e2ae0d536ac334bd4a3d2b41022d17a1110966ae5b552f82daffb81895be5919ef0ab77f5c65a938d7acff566c85f0832ccbbe8573b68a423eb1340a37127a7846c9b2ec943d397ecfb47d078e3856bf411a6671b941e4e86ad1c494c9ae31b05f9e5bc7b7f0acd5eaec6573fe22c57120dadab1aed48687d6d95e4a094352edada7d3bec53271120ab3ca86c58aac10416add8d875e6699029f448c85c5fd9157aa8be109da33ed8f031005445f229fd3b259a3cb88b1ad6891ae91781f8b646f60a04d7e6766327ec2e9a947a8312e6162c6d46fa03b2ff5a7222e1dfa4e6256f2fe13d06ace844ee56ee2e1b8a65656c8b4e4eb0e457c4113f441e55ae8bc558356690f647ab6b0b77d76aa179a82e2deb8b943a9e0bf9176ee1d0993b6c2b67c35df25972cb221e096515c2ef7481c529805635171d66b5bada5aff93ea54985317d51d41b1ffe36bd48142f3f31c7a362bb60d23328ff695bc8fdf644204071cd146ab273ace2f6a640bf658890f5fdda1549f1bbed0de7c274ae87b150684c39e70a78c27e9e8ff2d0f2a0217f8afe07db040c6c7e268cddec833d1a8991b6d70b2adea6e0d95fa1ae3a921601d1910f67bd63c3558038943e29e94b7df6f5ad1491c88b4dff00c2b0a772b84a3aebf292dbfc0f164725bc0507252e716cf270052437e3c3c2c073cbd0238cabc35afb9044ef00ffc62c0544c933eab4f6de7da9032f0b3232a2f4f4fa29587582b72ee72f2c8996b308a98ff5187b88637393482231ecc01a27440902a0de098d9c0c132e321d9974b0283ca539fb6e278a8645fe31926f3aacb4206b9aaf68142d0b210b9d56aeb7d85ebd19622822c7bbaed02257947baa6b1300445cf95a3f16cb82454dfd654d6c5bbddef586106ba5f20df4d3a7e9647fc39566e7f359cf41f227a96b0594ed35b18b37ddd03fbc6fc1d1d1265c6a08595cf70b654aa5d8da9701571dd64baf7779d758f440dd3e13f3c9fded259f71edbc1571d0c20482b7193dcdfa56adbcc0ccf84e82041e350f50a59e0b8ead333c625f02b28868500aa64bf74a76b20e44342ae5979a15441576b4ff4862c9692423dd736c980caa5a9b33423420d1923f99019097d039c8c0b623270fcd417f9d1088ef6e02949c3432006f23ae4d3a6ccf89510d7cc5d652ee96958784a1ccadc23c676775f665246f4feb1f7b1837c83390faba15eaa13b34189d93d077343115ec75744007e6bd138e4994e55b01529cb4acd2b6568532bceca2f7a8f76837a665f01b2a27eb3a808f2cfdc06d362f878e83693d6b645747c1e2288c304f982eeaf58ca2b79d0b1f52dd4691af1e73176503d0bd11f51b7adc295829ac2b54b6f1d807d2d0fe7e4dfd97dbcb3dd8e9f586ed86a4fa09cdcf1c3b9515c85af2aaec9b1abf344062459e0cbd823d20929d5a9dd55df75d860a3064edd198b14a8765016440bbbc3fb4b74ff78d2359f9e60302bfc293d8988d2d57e80f56f94402a82d6f39d742959b1ddb48f8a6f513555b7b6639bc05c3c28a6deb890193c3233d71b4f5107f03b3338b3fbcb7cb3dee11f5b8308da807db607f3e7257ebce59fdf2bb1b5c4061f312a872cded4a90f43ae62150f4409763372852627f018130cb5b8384980b33bd7f596000f75ce1dc80283b9247d1fffbef1acd2ddd43395af7a77eb56d53077687ab858bfd588f6735ed64588213712d6e4e2301082a4771a60c409b220a98f0ed972e676bd237569b7a653162922207fa9ebac64440ac47a6aa3848b1a1a4bb68dab79363bb56655cfb53439f6854ac64b2a619c4994e3e2732b8c2d616dd5be6ef59745dd498e12f20008d9cab04621384e519515643d48cb9e3d14ffd535ad6ac3e769e314511baf75450bd337d30288988b31b2479d27a3465e7a031e9f1f65986c3acb5ed820c74a47b0e37b097949e23dd111b78a19f04ceeb5dd7915e073d1c34ee1fc54d8d9beb6019d5fea4731ebd7e2424bf0e380e94dadbca8bb0d326d607534430f480cc4f2ee5bb5cd85aec0e904f0f7f3bf448341977d18f0e75c431e805f2829bb3c6d155310d6ab9aa954f361a52b68956ef0707d6e6635191e2a87d708c351b3b94ad85f45fb5834bc480341d83524e06665402a2b7e61ab9a2638a5dc2e799f132733a30aa0dc5dd9009839a62ebabe41a5874b12ab0205d9fdcda16b99cc7dc23e081cfcbd6678e482bd206e423a7b1cb991017c3c57e47ed44b09f3f723b2d5b583593f9914367167b3cbbdae0c67d681859cc00ec9f8fb3656d9419c40318a9acd2e5db1bf5547d3679be8ed7950e78569ca81b84f99fe03be681546c5d6129bb8545afa293b6d1f95ee30cc531e414d316f267514b8eb0927490a9142d102b558556fe74e492bda62a99df946f4053194dfe72f96003cbe77142474a37f1ec04eb2bc3dfbdba0f672ba7ad1d92ad89e0c05f5d86025e8401f44239ff11709b9d0a935ee5a69d4dcceadf382f2618e6e648c09d238b9e803bb14ad36acbdd3127b25248df2c64c1149892e4ac0136313de842b02343c9312a7cff57a66c5101660c8ed89ad50a12cd89c464f360bedf1d527df1e10249efcacf8f3bb625e077a5bd83cc0ea17757687e5acb0ada13053cdc2fe931f6f2e0b7fd2d89d2427de2dfe97fdcea3e0d4ca5c4fd5320c6487f6c8de1fe7a25fcc1d640030ef5f3e54b5b524f9c3f96802cfe8cad7781e09e9f68bacb89da95380595615c8b5104fdda58ba9751ddc58aa397c48d07e801ab91ab77d8a1b0af772fdaaa3b52db68bd2c14452c76fcc08940721f15632fe30952486b1d7040f731913af2048df5ef8cd134811371aaa56a7efaa03ebe0e2f96366fba166ae3a4c7856e7fe44cea6f93e8b199dc05abcd338ac1af909216ee5762e34f8e37a8d0721ba458576214fdadff806c962a545e55ea4623061292bd1f25a06f37084d472da986dac25a884fd85b6e2a1704c8d562e8d30ed61e28c0641570470e7b487d01ae752d6cf1edd281a49ac1369b79ea9cb61c186d668c0c17cc4fa6e0311c6b0fc964db6363d3a3f5d9eca4b4c257f1b6f83fa1dcbc5696ca96262ca3ad224093dc841fb2e119bd917b685190e74d92945a10a4aece35fc39b21d5f5b15c322fa38a5d7544b8ef83dc9cf12e85d05884851291cca22e9a789ea53e04b034262dd287dca6b8d25505f6955efd591dcf3fcadd54c3fc7f89be58b5e2768640ba730b5df269870163ae7f9d1af95b3f3b064eda14e27d0c7bc111ab4f72b983e0e945a49fe6eb26f82f7011278053e9bddfbfd4e1f8d92303b3732aac0018c07d82edffd4c9e0bc4c803af0c7a99ef1c08b0415f10ba032e9ded5336b6998619546cc51b04b885643c0a146ab0ee0a80d6bc10888c01dcf5918dce4e8013cf50915e6632a8802779234aef71e5427c8a3209bc8b7483b683982eac8421acac198ec3822a86099f8e535316d65d3e611500574e8c999e2a5ae996c57f156b61b50be2972d574f035033e9596fcd07803aa16b1460ec280af7089d271f21464780b4f8478c90e128fa87624c70fffbcd99442676dcc4db05b0c5c19c00398a90645bc8218c3512c93b9b3bb8c2deebc67f5f64d68980944fe6c740444fca6b7d7b8170d3343d44be89867187d2ac377ade4470876fac451defd41efa6a43d259ed1b39210ebb590486bff35fada10dfaebe256c1944e2338a9cce9b4e3870c90033072a8baa5415fd7d40b704e93a69e44820cad26b866367461ff2e504845a1ba22daf5364770179e5238daca3888418515a11dabd3db781046152d69ada8154ed3480a3d4d1190d97fa79e3020fb7f53f346420f3e36d6c32a5e478a7cd4e8871beecef9fb342c8df9c2f5ff12f7e6fb0c04be13a6da091e19b22c8863b368b13e7e3e6d228d32c8aca93605bb12e5bee4e5aa43b5008b7f85e608d535abb03bfb0cdc1ff3326a28a765c2d084895237813092f61324b02b7998737172a8ce3844c9cdb92d0278f31de12fe87771eaa72340d7a109fcd01e883ebc6b81246beeb0fa59d1569600d48b16f26696ea3bdc1ec1b2e62f130b23017fb90c55a2893ca0109798be531bcf5fa48dff49abb4717c0484992d55bac58d1c63257ee3842dd9d01d76433d2e172481390ed5f12739ebd62adbea4bb9405ea4b92a633a0c35a2506dc9fdfe72cb9e94794b4d9eeec8c7b14fa62a8f1c384bec592e6ef54dfbc89811e855843d9fdb90a8d824b45bd66be11f768a7ef3327406b7f3389b89d67326550052ad6dfb4e33f0bdd09f939407cd9cc50c2f046ce2053409a180612f46301a0148cafa6b7d2a9c5bd5a73837bca94fe22bde5cca4393dd5c3f1f452d8597acd8636a33a98481dfbd63ff813c1020a309a37f9bfef1cc5577518e902f9d3c7fd68ed066eebe5753c45c04195d7a6cc11e7f151cc8d298294b1feb01768f373b2bc5634419f4088dfbd4a612ae9bc88203045faf9b5338e502df4eddeb280efacfe529bd723c45d5ed2724406efc9604ae5fccfb489f6cf242567e192599f3b5e7fce60a4e97203a1188c46a2011bf715d316502209c8095d3dc77e8c38bf936707dcf541feb3b6e2a6e6dd7be78b9c11918d66c471157bd69c0a8f7ee303de1747471c9128caadbe92eeaed59e9bf8199ae5bb0431371a2a61d32fd0eeade506fbb6c4bec6f908fbece50cd791501550cd3e7fa11379ad91072521d8b9da727478cdf87d0d764fb67387d0c50763a5a11598e263b62f12e153bff693eaf9d545a0ce7ec713cac3373e4df788d61e451b3c081edb50331d056ef28eb51af2a6ed39ee13b1e479a4fed5206ca56db8595788cb786f5c51c57cbf1e246112e8f273682ae635fce480786a60346fc744990e613f84683dd25b088a4b6bff1d9f467bb10bda8e947edbd65b6193cb253bebe833870d3e464a07f294eb0c0dd9d04910b234c386c7b3f79457abb6d4ef22e0fdb916a0289d6cdeefce44b2b5c336366a3a739753ca0d33a6036697f9e5eb4e068ca9955aeac01944ab9476be5f4260ce8fbdc9a3824073777605986aaa73f8e52804bd5b894a6a77f5948ab7335a4a3e8f78165a9f1c4a8357007f9b7aa90e5b06df25295be6df61c8808fc8f0698df75f7e19d628fa3833da78b5594b3ddea2763c0995a740726500bc8d4e459505f1bea618b4630f6ee91bc80341fa1096267394584608e024e5e3176c12c4e535b7cfcb697f0ce562c8e13baf979bbef7ad4385f75da3a66490fdf0e47c4b6d8dff6a1af1cb146ded4def019ae3170b3188eee914a0b0b07778917a3b59f712d88164dabb7519c3480976f53a47860d1b9166e67dfb9749685c6e8b345c24a94a58d875c6789df6edb63c1c7746e7b832eb2a6d65c37136de72287784864d4c6efb178641900164b05674331798a601eea87d1f5f99bedefb0e82c6d6f2711fe9e2b546792e3469c7b07d0653a53bc79293b516180df600c3e0d348b8d11c38b80cc15b370a2a8538e802e05f143e98f4eab5329c70e60cfe12a9b5617aaa149ea79d8c0e0a2d806eeff5b18caf05534eafc7c0fc8170e6cf21f01dbac994c0bf59db3cea0c7b7d2269bc9fd4f1835ae2e90aaa492bc194a74c9b979d5e7606b3d2d9f55c446deff1909b492f09714d11b3faed459a9e84a4f307f777485589c37e8380bf1087b8edca7ead3178571ae4f0d9597bfa0f5dea8633f96af4c6f5c566e40007ade5672ad0d69287ae4a1bb1def743884dbd7820d5e0051e97551c5a372c36a3beb3a593806ca81e8c6bcda4df227a068636592ad552a3456246ea5ac65f58ba4f2e7ff0248c49770aa124b836b25b606e163d64262bcd02f188cd8d7f62ef5be5b9a252963ca02c310047f68b765979efd9b2a9534b102b86d99ec208c5a7804f58ce476dcf934814639792f142f2359d44226866b2d30b189cf20a40fbf28e2be4b1f4b5b2913a2e01fd1afdc52767333559df1bbf5569a0ddbd86acaa70665d0ef7a19ea574b4a291cab92632cad2596dfaadb7ab52008af59431013d263e2780f871d2eb83272035542ad9ae6158737509b84526161364185ca77d7a2c4060736fa5f8bee1886da564c665907442716f58c07105d6248e11d8d3c59e2c97995149a75ede2f9afcb0fe78a54d57fae92746d6cc2be2761ba9b7f42e494d4b2cbf01e32f524395ae006d47f45157ab44607ebe073506ef61734c7ecd55c096eb932453561f1e3ae12cdd6079483f4323adb8bdb45ea5e8862cd64ed9f34cf085127eeb0a5c4f05d840dae036b3110e1041af0fcb165b36cecd05e0b392cff6e834fce9b60cceccb269ac35d56e2ce6c32d89766131d6a76ac72f08e3d269b619858e24eeabd6185e2999ab8fb9af373fd88670a3b52a5039bd80be20074c495a7de73a5d234c6877f9e163a50fabf48e292e4b113085d0547d481d4c8e34afde3cbacbcdb01a459d4d240256edf75a50cf8838a182e3af9983ce645fe95e997a27e2bee46248d21b0db9c5aa9c1867dcbe1348f34412ebe1ec79b36dd4cb3fa14376569701396554d2f9f8165e9a9279fb76e38543402aa27a1f2e69209423f4ea37823c808905723a07d64dd092538ad60ef234be987b78361eaad8750998a5494de2f7cb792319c4585e1d8745006b2ade8e25cfe10f015b28110b84800b9a659a95b7c9d1757a32550ee67b243590e351a32909c310bf3ba5faea4768793652285870a57feb12fe975f6400f149ce08012144f16ae66663f0da4db0787b94aef28cd83db1cf31e11006d267101d35e9c0d145e4b38f1d49a8fcac7898c0a799b7950f5e4d30c35a143c3f40e47641977a7a35cac756b17fe9230843f66cc0ff9ef28e2940d632b02d2565d3fcf19756175d1d85546430df7d6b16e4eab0b93e02bedce5625095fb9b34263c6191db6dffbbd82eb3898a968406702ca9bec5ead3be9aa18661faccf9a7bb497405bd4e156b55955d0c48b151090747b96496dc7bc153e1e64fd5d806c755de4e92ab4aebb93e9250e65a3dc46b2a6ceb99894fb3eba8db040f9cb77d87dce7b0822ae394374cb88cefeb469a8328f9b86a68248a5a25097f8e0242f6c922a9e4726ca789ae1991a32856951639c9d81853a3352c1db0b8a5de84458d57b73ee9e59c675f8ae9785e320555fd434706a098fd909e097fdd57b5aeada490015b52255e5375a44f6af7c4f26ddef00dcda18f0c305acf4a2f64c45744a7ca2776b07fa111a3da8409a80e5716f397781a4ab87680297cd399421d532447f9a6471f1671869d855f90d98fc4d1101cbcf87fca277a90da496f13c7373ecb2df6b49ddc4b7968c452b8c8cde5c4a9dc56d0635686b4e01de8f16e51a36ca44b8828700a5c410206297a2dc1dd5c92e08957ab600afb7486e63cbb3760846624e5c7fb48da8ef1281fde38d4f924724acf4aff7d900dd245b7fc4e827ed5aef311a0a2ead9a3423dedbcc0c23c0ff5ba1882db9585229a9d2a07b3994ad563fca188327ac164034712623ae71c0e0b10e7b04193afec1f172196cc010c995813f74a8a07f0a7e711312e2b867cb36b15ddfbe3971783f5b2d51855c1876d7c94190adef87565ca38172f45fee20cdb14e4c54fc44feed599f8bfe8934afcff79abbf682d9a822e5fc4a17b63f3c5272dcb10e7787da250ce99a3a043a30c4fe6ffc2249b48692ec2e0976a0bccc9421252294794eafc6d2c2137442de8aed929483a15d1ef63edffaf8fbf5572923063a6b029da0418dc47dbde7830796eed0e8302d095f3c0368523e55fc65dd2d3be4fb4297bd26521a426623cc4bdbb30f12196bf328eca887b298556e2dbe8392fd3ac88b775a93e1ba89f91e9841719512a3da18f03f1f4b138f37e27bd1fe04e08df77523de80315afeeb37856894162cb8215bcc69b9739c8d36b06347f4f9b5cddac37e27d798563bfb0dbfa0e55598e0658df8818bc1b32a202e46b2cf612daaa034e3ebe1e81c872e9d5ed9c4e58cec898b3dfe6e84521a4e74dda20af67dd5ec560dd4d5befdd99ffa4ec1106a3fcef664b26bb8012dbdb17fbb326fd3f6c466570ca5628d7b37ffc18403d6c11cdcdae20a43f4becd469cef687432c4e105149dae398bc68a13976149cf5d70ed492f470cd5deec8a67522a6af14191cf084e06b504f0ac97f617f4332e88ddc67faba2b07254e1497f412f004f1941930913b4ddcdad4329c404b881382338d60efe8e6210a2c18e282b875ff249bb9ebca931c7658ee259d0c5ca5ce8feb2af67d59c89137a71f9808770f78449139698da00ac8e652d6bbdad0fd3795ea5c309878478e4db72bd338c4e1b8af71301e247ab37e48e349e83c1230a562ed3d84e6af6624e011932dc3d29eb6fd98e33e4bf0eb4198e04d77a7b290ca9e68c1a7b45040f2c71749ff40a3171c4f91c90838529693cd46ce831e3210492c4b2c1c3b7fbfdd0eff6d386f9e86e9025e076f5f35be8d0ba76c6d5834b529da5ab8e1d62b318d94dc5125282b02252387ba395b74c7b44b1f1490b92b5e1c9692e36ab6a45db1704adf867ba59aa28ca0cd9dd707fe4d1d3477f3ab8a6d18f89ca11e5baede847031cff3244d876d4cbba40a9f6132e598b535e72d3b202160bdb9fa67e33292ef2b73bfda7c7323d12d0b928d68498c613704e248146f6214c3b3afd192fd1565bb7d1ae54abaad9f8c9762ea2f684d1ae88e02bf282fdd0597fad214b6e78258ce60fc041af707d62d4a06843d6c89e4c007770e8477778c01bbf39aa661b3dc10fa7069c783302be636a01ef9d33facb1a98a8e8c44b110bb688e24cb9a93fad6f8a8af237f553f2285a0177f50366991d1d121aebda30c2818f3f7867ac309afe2ca63d4923e84407f8577adfe1ed1e6b14ca60ed4055a6b1d29f1d96af7edc55af22751166279c001fca755fb18db3bbdf30765b5c66e9c7ad5e3a52700bc3a20beea153c7462dd24f26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
