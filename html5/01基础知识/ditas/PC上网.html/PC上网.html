<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78bebf9ccb97195f2e600607ad9e5e3fa6e95c6a86fec1de01e258725cd8d807e1395292b3a29ff79c21e0d35c33d53995e7e7793330cd59441bd998f3519294d662b210a9f17814c46ca181ccfa905749b17b6506cc61329bf062d9266b35411f6dc30ae06db76e01cca05234c6a911519c88e04f13020e84e4de6171c32b71bb61783941efd4ca2b7fa73ee51d2331f6dde8fc1a75d3382538efe2bbbfdc77fb197c03d872aa6080cc8cffc07a814e07416afb63b6d249a6d73f5fe0bf12ff316afd3040fbf8b4aaa806ff032138b2a169291312f34dcf41e1a223696529b6f1203837aa2265bc195bef44e549f65121c520b2d673dc9d09167b61dcfc8a7a974a19e2004d4ebc67aa35e390c9f7b1558562c6c02c0192bc29a450df91c44a8544a83b93e7dc8e4cb8976485cf61a3fdb62ffe3e5416c85b337c669e8fec1a2a3f7732ea19663277b58395497d48e5d847b17a136c86fbab24b988adce6844f8d7095ac4041390d5fde5c211344503511a2d0245e76ee343b14ac4ddf7bef4befcc7605c0cf1511b1b92f97c540b1f412270f723a5363490894284d4d9b05d68ba455377e953d7f6c0f98aeca7bdad4476a7fa9a4cc48cfc5940f0168742f8a5b5599fbfc3e58dc4161c766cb38a368857c3409b440e6930d4679019df7dba5cd4b2653f7c17c39f26e3a5e89e09e4b4dfbb7b75b0c20e992867fffb7ed54e38c4ee54149bbddd7a7cd5f528e74d8b351f4190f53205cb27492d62d9ab43fe7c030c7f90764e7420d7a585a029cba6257762624fa38fa04bf1fe746f4c5cdba22b15dc1252098d01ed067bbef1b5f0ceeb236993781005e5cfa29cbf050ce1bffa582cbac17b85b886e1dde25f68c67b54af378354c3cfbd12b82fb81717c03f7b96b8bd58fd143465659f11083b3063b23604e8d45f3e4043cbeb59a5092e475683c77b1f58f72aeb3cb5e70f95714370b3c308930695e7b62c0f0b071c8a9b8badf7997d828ec76f500130a0fa918f853bc5e02a1bd1e239a4e8d60a3b3eb03e720495a15bbca2e339872d8a2895f7cf991eaea955f32319ee19e2cdb022433526de1726878839d4fdfa44e03c8c3e96a8abd395226fc40878ece046791082549febc7d3ce8adb883f4dd2046f3d6f5d8700766359fc23f961682dd5522f39e8188485bc0f800f8f58aeb54bb81cb92afa4bb8c2d37e68061c3806bdc9cc83268a4a62636634ff66622baba53f12c8b0d01a29bc865c21ab8a61903e9d447b8c1aa55b0ab7ca173d3d58f8f28c4c8967b539f1cc26baa97b1587e3b0f8c1aecd2e0527a45a2a940b001ec50a2b827a71f95292be1ef65190c53d3d923bbe68e0a3e569f7f0dda7396ab9775b823b9d97d72141806dface3d7388343481cf8763acc18bed484eb9626b1b4c96fc3ac8e87e587ff5730165edfb4dec427830efc3eac0635a4c102c71fe2dff6343e80daa7c14268b81efcd0e269fb661d83f6cd52b5417ac50707ef9847080d0dc65086141a09ed4f727fb4d6e035eac8c687550373a53c99cb06d3545d8da25e4042444365d140d7740e23795065f2ca82fe5be339174f1ff955164a05a0ec5912445810acf0997a76c598341eb2453a37840f55a5d70e416678714247517438dd5cf8a5382a23bb5828016b2065c69dcd88678f1ca19e2706a0e828978e532433b9330ebca5b6a4a33918d6d4841f7c70f651621867bdb08a2f63d5af791334544e22c823a6d43155268d394c0a183db08d622a9a63e6e1ee601c3c13bd11869160fb9f6e2b38de39c57149a0c00e52f061b84695e667e85059017962d8d9ace0ad04d2a7efb2c95e6131efee2505cfe3c67975eb2a2651d02d8798a8c7cf172da68629a35147000abdd35d968e210a4d56f32c6f34b78a531d542282f375a2990937d847e583a85c8bc95e6d330b0f2179eef14ab2f2169a10a4ee3b9494a40b842af9f018c1ebb4d72852e8b4d9e418b528d1a457421005aa94ccb03798b09da748a761b21d4e6831de39ef9f00adeefd77ead081044a3e1bf5951430240167f30137161c2a07be7d2422008addfa6a1bab0fc497d8c484e4f72e2b21f71a3d05f64a3a6a8730d55c7b635319f362e2e027e367c548d88894f7865ffaa8f2e91198f94463c631e7d2daf4fddc1ec2017922ea763123ad4e3cd6618dc79e0ed0eb099f9ed2ad88dc7eb5eec4e6353d63b66d34034e92556536be2f59698661ecf973ef87c9cf0846a8477785074bada15192d6ebc9f9d466e09cb959fb4f964fa2e6e50d352f8f4db92f64c4ddfe39767b865e0e16f245debcf7e2e25d73311892e13851db9f3fafe708a7f04d76f37a30caf73708ec852884437e38f8d7ec1e5efca4f54f5d087e89e8c07238508c88a7f1e93fcd372a6ff082afdc89564537c7f99a93aef37d532bbcf4e7c985f951b8952c1ad14491607cf8d7fbbfef78075f9d470c23f37037277cdb683092717a88f661bc8e78a9267f1191b066c998f02b7f5d8494c7e2c27baf5aeb305242b350ce339156b475a099249ac8e4a153b9548cde57ef920589335476cbbfa06617d28b9cefd32b3302932ed1c7cfbe3b8d45a3129fa83dfb29e6c3e2e7182936253957d57690e58aab33757a76eb8d48ce84be2fe356677d7bdd18114bcc6e81eba280a51132d07569ce1257b8e42ccf62da18866996568d651a3e2896243fdeb89777bbe31d53bfcc8c4d285c1541db605c64fa3e233b6780e8b6ac37cb94412227e49c8c9b23c750a07ed196e9c769f967f7242f900c2d2d5127c2794efe7d6a9274c869d7105f3125309c2c936e50c0b6dfea72a0790fbb2a1c61370b90cb826b987d8670629b582533a5f3902630290bd68b15652856c5273cd0ca890abd9050895ceac76ed8b311f9d37712358ccec904f2b2d1f79143aa9e65cbec3009f7d7b6b5c4aff664d17554b45641b85c0cc629d7dbbce81821f7fe7f45f61356b44b07d97bdf6e00e321ee8cde81d2cbdb29d0b74c489829fa99ce4fe363442e96cebccbbad7f9fb5db49d5e80aa4ba87f06eed9c100853a7d7e81e3a6be0d6b52e597102253405f98a9a8cbd8f5f2816e98907bdad509c89d2d032b582ee8195a7d31211d1f2345e0af9a7d075e2d363d1be7459318f1d590c349e1cb08cd330566a73d293f865bd5332ccbbbd9b88f6060c6173e2b5209e4b7925f3f90fd0a9c84f28470db2035ade89ec67f7982e01bf1786c616b722233e97644f199cb33dead5b45ab4ac4843a4883371a162f2936c6915ffcee89a083e302e22ca579a8f4a083f8b45017daca2de4b6bb23a5eab3605468aabb3eaee394a0361b2f0ef8407400be0b6c4f87368911aaed44a37017e66300520c992a4e1f4245ce3b121e2e2995ab7f0621294844ae26612cb8793ca75cc72c10b65a93a41af0e62bf01b918bfb9b9f4252fcda9bca9fd3654d80bd6499d9c03d2e6fd3a26316ceff6b14938ccf66730039015220f6f52ecfd2ec46151e2206e28cd4707015107ae28fa991f10fef97eb8c6fc1983a54b55adaa1afdc18721fbb6f4fd9afb401fc64445ea407a1d8796dd2c720acb2e7579dd007bf58914d07a09df31a4ec593cdbc052fa3bb89ad3329dcaa204ffbff2a035049c90afd066081b64462a495a1dee58da3f1e93edf6d61f811c72bdcf6d67f5aff41e8b0221c768ce016bd0daa92eb5b213f4bbfd6002fcf13b72466dc01885e37cec65d88849064ff1f6a901cd960717e248b938099487a139c8a211931b581a0900c3b8c590b19641190f2eed511f7f4104a15e6623b16b69fc56ff7ffddf1d9653623ef4113777dd3dcf000ba9711c8614ff52e43b601f004b07438443e5c81d3a47da5b6c5bd96ea410db50ec39861a46b502882de1773efa8da804bf284525f6a7ed1984155217031605f69b1466adbf7860fd848c2fe1afe973cd7f3212fa6ac6fa8515812ba56496942979f11625cd05809f8faf6a3135463acb4bb4d7f2bb4eeebc77d3cec1a30dfbabded657ba43029b4a3ac604918e4fa4b5656162e1777badb338562e79346a54acc425a0b62cb21e39fd2742800beda78de92174300f4cabddd3a8f6e9c7b1c06e31fccd44897d9bca419d8e063564110230bec0258005e7ddfa597b74195c9bd7556baa82de79f041969ff0a82e1b466873ec544ab9a6a15e9e199c042132173fbfb85076fb7285933c83949cf1cad5b9091179b163d5733d9fe97b3af34d0bfacd39f32ac81dff602b96f025b521abfdaac608b253d04805b01f2db7d21d53f69887028671dcddbcc217734c2b04cd7c52d023f04b28e2020a49dce84bb50e4666a5c01d210ba447bb2b2044c8f359af784b53257813340cd6ca0749b4f9d201d6b5074abbd73accaf25704eeca1eed92229c31f5bb5f8cdef48ea2eea509c48bd6749fbc77f39dc7bcfe0b31ea8add8baad73270382dc38c1cd5c9d58e596b59b5f7a90263d320a5f1f95526eea26d4119014e4be7d549e14388a7f3558193c583ad989021aaa04323b567a695e811fdc141fc7109212db72593ea1dbb8a9b8c5ccafed8b3df4c504cd8de47073bcaccb85deb301c8451cb67f62779f04f9d5c6404775873f791c5ef7da764e1162366e82d878974293f79eb46a605acded3e4b0e9ad747a4f6feb71c73744332adfde0034e177f0c8cca758d35448c262306cfd74fc23de317c6a33869e0fe7837acc119133c6f8b3046266b4cacc36e9bb459eb828941b091a9b25d2c3c6d46ef15bd74716dc4dad76be573dd176f765bffc2f9444dc4c596c4fd3bd93594bc403d7dbb4c13ca19cd6228dcb4a13068e0745929b0c91ede35a7ce8b1534c834747e57a9792732817a1db684a647f8c24403686371ef49e6aadf7ed4839541cbc2d32213d957eb49b027164eca975bac6051d0979c005b176b84e8f2480685ca5046bdec8ea460e730a32eae2eade233bbb2a985b4d74264e958d9675bccf8ee75041e6f6f7571286c8090194a05b9d20b45fda89efad3b08e8e7d34ff0fa28f0afc4f8380948bd92bdab5b38f08ba5333a34bee1631bae4b812dbb05437bf8f42fe90eae45587c68da7fa2f15f1d06b147dbdd38e0008ba96113c9d87283e2daaa7438dd4326008aad6c6ee332b16562cd88c0718e727100f06e5dfdc17b1f521f4e1a34ffb952281505960369565659db777095bb7b990d2c3d5ea4c0f08f12814ca0b23304172f8bc080011f4455ff59eaaea3752a368858ed3eb40d65be7b0020b400c18f73c6092e3961de1ecda0d79a8082fe43b088bc44adef6f97511ae706d7fe7ca7403780d2ad0d64105f4398299fe773fd82f6f110e82b316a018923669994b85234266e0ae24dc1685695c584fad375ebf4c54cd3ca2236fdce7cc67a2387f6359c720fbe5597f788174fd902ed344245c3fab52676c28e6123281f32ca305eec132a6f2a2d89f4b732ed850a8b2e0077117343a15aaf516583f85606d0efa8dfbf5480fbb5b701d01abd0b88d60ef3c55b9c466329a201bdcae3cd3a59edcc9eb626d539b15ce508cac6afe73f413dccbe24859eaeff52cff0130c327365272e551c510bad2d2b28d0d95d090eeaba75aa6ae62ab4479f7daacaa83d7378dcdab63b628a00c38ee87d011e7e92057391045d878e872ecf31f226428dbacae676704b8ce70105cad38078bb5df78a441e140bc6a9cb19d1df2c4d05b4b31ceff9b8e6f83319156f8b33ef2b26a42693b1a610bd1c1d7ba423a9a45c342f3f8e63e7229455e702b4fe48c3a4a5d10dd8a9b9f6c107cbf7901c737bd2fd2fda476a5f83b7cb8697a6ec97b24f2a2684ac8978aa762d4b3f5e92dc3ec8df547cdf000a789a6bb8f95e270b9564287b1090ecc87fc482975f5d462614723c5dd6865d26ad95d5f6ac984604cce209644cdce71f3e385febca45352b8673d0934545c48ecbad4f0eb7a6b9522b9d44ce4e2123addc9b7fdc38232244341de5b6254a525e34de0c97b7216c9970a2277a156feb91783aecf8804e075c774a9dc53a78239a9e958fe5ada8fe8c757cc16390cd1add112a62db5201437d818f9599fbd2c22653e00108fd127a18e5c601e01885692f5e502bd67dbfecb3dd3cd6c60af2a720e9a824e3eda748d99ad55c47d450a2aca61b0832400c98d968e4ac7297a586a2475e459420d4623df50d5a2036194af0a463ad7c89c8c175066dc590b899aa97e826ad2032f0e6ac6fd5b77a8c6e317e8cba808c58d951b218910bb38c5089ab6abfb088fbc9b680bc93fe5dc7fa2b99b662759193635e4aa97e7d24ec3ff70bee87894d530d918bf3f898975187fa0b4277b22dfbb3a79dbeb463f39dead942c386a52c37db2648e24e9db80fc6c98bcee7217687b346a6e57f7a01911aedc5a2bfa176601cb8dbd3e2f13e414701c553f26a202aed9ba846b14d95c47910d6bccf257cf811f2c8bdffc8391f358156c98683bf079a763329c3206c1f7ca432808253fdb109bc48b3f9ebb575a8c105915a27ae9e101dd8a9dccf4f66ed083326c583ace2072ad07da4f0397cb3f752e1295d31f9acf1b32cef27e1a37b7ea7adb087d84a1142a90b5445c50c2a0d04e17ee119dda4df81aad914723b1544bed22bb4ff83b1f454ce84f0be50a7a34ac61d533517794d69a0eea3d56e2d6796c0f719293fc4c2561582f408f59b8549038acaa1f300ac40a93a0cc2a8222e2398706578a8f92e51212d62decbb4cdd1e6c5709098615ed78c437a8901be4558257494e2bcb8331d0ec5488a1c0b0f73b77fcd341ad65c52181d1fdadc278f0e53d453e361303cd9997a8f320b562b5a667f6720b4171a53dc7ac1c4ffc6896acb527bfed316de0b9c8d47710cef61c16e13324f4a82efd4db870b5358c884085dd3d63b6417bf23b21bbe4d2c2ddcb50e2c39590b2e7a6ed39debbdcc037ec75f48067d7b265b61b0764b27087d6f9a59afb59046b1ce84826db7057d8a5a93bfdc8342a8b1c1d0a71cce86a450a55452ac32cc79cdc67b8bc1a05344d09640fb67c1677f309d3bca8cfb9ea4d23213470160891b7fd7504149043b091fb53156e4afd24fa3251806e054762c8fe3a9127b5bcad22f3a6248b7f99abc54e0a2efb7ebcbf5c7723a73699ea72c9c4a64e0b512c8292672f35491004acf1689215be69d3d2e3dcd7f41dc695275437d7b10a92e9177cd0ed635731130aa5011ebf7b7700aca9dfd7f06aea6c2e878f895175abe93b93e293b693338969728e19a3255aabcd05297ab43d8bbd056ceebb410ad4fe840e35cda6a4fc094ef8a0b699778667ec44ff990ad68edefccbde4bc8c2ddd8526b54f8d5693540ff80626ef5fab14f4161909e139be2e4e7bae7aac481f444b5c627f4aee8d184f12760fcff5fa439cc6a8b58d25c22ca7f7d43e59bf1a7f7c9d864e7cd7ceec3e64aab31594d7fd4d82219a10e9006583e54018bccfd43e9830a70af8e1751c58e69b8392139775133403d94a2e983897645b79284d1db0dcf7115235c4b1547d23390ec8abc64f5650a87201ad5ac69dcc2f70a5672cf4a004defbed6923854ae446008b0b9983b953d876c78b6393a8d0ae8ac930521ed182a16e8e5a8db1cc17732fdd8bfbebaa04ceb003c100949fdef321bcec1bddf61fa01c3742295d4c5b7dbef4f6412c509e7151a389dcea9c884905f87b625256e6a242f20c65520a1f471e955e47564e18f60af3455dfcca18fceb88d13d18a493774f515edecf1483b798025130809428153905af7f05d61dc9897f274cd8d95013d16561ad644eeaf75fd5fed20b2be2534515d60403032c0a261caef8fb8bcb54c57313709ba78be3d0887b48516920ab091fb0daf288869187bac12a0c9d1a058557e32ce8ae98021b34484a4e4ab05f3d0b46f813f4caf1901f8ed4da222030d9aed1c12f183aae9010018eb935bb74bd9c0d0bbf898fe2698694ba34c09484d8c4f85cd77424cc754bb5f78aeabf7cf850896475fecbbda8cf5100ef7c2a244b7df4f885f16ec77c5ddc8586276662dfe8d73c06c910b9d40202aad629d549dfbaef7ba2611f4c9513d77dddaee73ad79faf81e6a05896c332c181dea8099c305ef08efdcc65c9eb54d3eaf2be5ce09911acfb42f28a70c473dfd53e1b1ff68488bde77c468c2e22d7b4fb5c1ab41335541dc8108f222eec94f4debcd6e6836cdc8962d460be4d8eb846023f872257a7673ace69d8c577f05bee5bbfa26bee2a9e606a44413c75222c8de85791d5eb6e8e8755113787be3203117f34639a9780a7331bd5c3e760bcc3fd0658681bb4d862354537c222665566e3a8129356420ad0a436623dd12710c52778ed4c212211411d5b6d21723379268109dd72b494798fa1e7bda966f5423c69bd92aed95ce2a075904909e020ea9f43cc5738b5a3670bfe598a6367216d0a89d2af5cabee9da966edafe2730c918709743256bbba9d6edbd33e8a6e7dbef4ba652f721ace6e87ac75903d33d944ac4b422fa6f12f4e3f070068d0d96d0578c211802875211c3fe643d697f94048a6240c3fff4926b762181fb0ae28c25da4c896f76a163d957afd6c6f8a319c0644dfcc3c9588eb0b61f6f3a902fda4f0c6f0aec957561495cb05ccde19a60e71142b8ee17eb307d570a72fbc7fc9c72f7ab0886a45e468ecea433c562bbceb380c95f85a43d90d071d396ef0bc14c76780e06ce0fde22a6b9d3b1c6c2a475c7c31a9e74674f6bdfbfc309fae69379e0c0e8799ec2a4b7b22b28835c0043838b4a1e478cf206ba4783dde6c77aaf925cbc2309cbd497daaa42cbb88a4caae5764a56785355d52feee8a11413f504147f8bc37c6b6769e0bac545fcd520ea1ab8a40bcde7fa72bc601c433902c8232f6b0e81b734b540a59c07c22165e7936a0a577a90a31f9491cf093f8f6e3589b773b85b775ede06d1c436d78941aa62c3ebf967a17e5818ae4b187c0cc5afed251604d2fa510f66a4f3a98248de0c36bf2ec0370988f96385fc9024de9fca8f9378286adabb9bba9b1aec0722734b7b76b1bce165c9220cffcc73ceda840a41ea1f0fecad8beaf2e205293666c93f25053bdd1206c8a69af74ad44c9764b800c9c729b2ea742488f72080cf3d17b392b1bdcde451910a4375712d3b9194d7f48bae03d3da54f3090fb5ba9bccba19413f843deaf049fc74460518c496a5eb0088385ee3478e8baee6ec87070136ff4cfa413df803c738a6bb1b917a36ca68b3b5d842a7963dc844e57d55e786410c2953d89c6c60e92a9a4d3e5b740b1416fa7b7ef9ba82b78b863c118e1e6629226d043826cf55b79cc8b23c3119ba095d4b67758c55719ce1980a6eced2714415a58047870b1ecb5f86fa847b14ae9d80c4e43c0893bd2ad70cdfe48de96437e30f8f6af5e864825022703ecae0cca665edae6eca89644e2668b7c515b22a339786393f958c18044342bccc6369a40372653b058424a815603abba1733459efa165e1e6ff56d8d707129a33a755880222632d46c88fa5c84d201f9a254cdfc709f791d26ea54d2151016da7397f5385e3108076606ffbf29a92fb84e35e00589dd140fc6415d98ac06396568e29884e640fc0fd0d3329961e8dcbaa75e8439ffdae11461ecc6a6c71cd667faa6720796eaa665146421412d3a21e14210672d2e928cddc65b93cbb31c58d3ce7abb4394cb69a8b59431ab7627b4eab580c88a9ce03ce5a6e179fe7fc7c2d20a322f0279e50f2daa43d77dd58bc1b0195807dc684e9598254c241fe138b844f2a8a4f56a87b3c3f545e5dcb4ddc8882e68b88fe9b1c324a04511ed81f8164da1916fd4b447a5148dfd60ad52b34b2caf70b468582ff3a94910cb2f73de9131ba465649651a64d9a11685709e43e5b03fc4c09b3ef2be354d17afd0d788b428dd2664f1cf4531ec827f22043d27c01efe5f9f02a1429b12e774f2c1282069543f24c5e7868ce222d92012932334184a93223d0b906ce18e5510f0c64b884f10d3f081b1e6f24594eb3107bfa0c6a7790a0a9f0c2049b7811db11895bba79be11f3e6cf29b919d1bce43598b59ed9f66035d22cae406aefb10e1707ed2991f93fe4d4a4dead995cfa64eb596317af3f3273a4f4a1bc2c5b39b1f274246af6e5617527ba6af517f5edbc14c6dbb02b43e9837a0be721c6288707c9fae2eaaf50147a317be1a63ec665f7d675e72abc56e7eba4f8c5f463d7a2a221b6e2fd1da9e247ab90c2a69e47028bd9ffacb4c010711ac2a7fdbf405df8409fcf2fbd72df1619c85609350d1b64f813f12a1856078e9e85a30fd3adef5133f963fff86b899a63e9d4cbd22c4b8868fb3656f68ccb2db8ed993f3dbf57c119b9be27eb72ddbc919ebd3fd407eccdd5a43fa7d02653fdd89e7cc462743b5007aeb6e8e15ad2866d9718b2082e3a0e74a729959e9ab41df82f5a934c02877561f4da42cddf520921a05349676cc1a180995aba59cd3aaab0d41e51fd3daf9905c858a369592ad8a0396ac86ba2199f567da72cdae62c81590d6d88a3ef01ce0738bbbaed9980a17ab24c9371d882971ed2420c85986945e1270363b2c54ce3ccfae2a92ec4bf8be05f85353262f68555e4ad495e3a2b7548c55f471e75d58a3a058c0aa72b39a9a9765f3d5c671fce79094556ae4e14c0f9f827053ef60c6c7e2de228001cdb439cbc934abf24f929ca2a30a607c44fce679925e31c008bd9bd64649a82e2b687d387db92dd631f78e130633513e39283a4fae86bb0e99f64884d18a3ea0013e23771b7dfee743da6e298b5289f9f4efa14331416b97373c8954b8162a2f2f7b890d9426c24bb660651f1f18b97d46375432513119338056f3a24c68e2f196933a5d125160fcc9062996cf1abc29fcea5e5895f6e0e7a1b1c98d45652e40ba2e72ba305480deab64a4f7f7e702999b100c4fba4eeaeeead0841b8ada2d5881b99c63e4b9b8e564b22421e7c92d5e74da4dbba6a3751110519f34481b232d2b9b6ce688a34c9717374b99bc653ce14cf86838395586cb90aebe141757bd8eaeec2859e5a0b21ed44dc5f5d51c6b89fa7eee35447a16d7d051540efd5757d3867a5b3ce581ba62b5dce77d27e3be5e953d54e2246e61ebcba0c846b1e9885dbc01bb7687ea10fb44ebc296fdffb593e00c18100bebaf683ebb6700d19cec588f9b045ca0098414f45d41dd43776b17ef1b998e2f86e64c7655f3355d6cdf239bca3335d1df068ad4cef6d52b0105604a6507a53535e731b4a09751dbacbd8da7f7f26bb40fbb34ea136fea11d91702421f75bfd690c976b179e6de67212c631480611686c7a6369e023e5e9f190450080b9dab101907816841532015645ea9f2e7a0fda4bdd2f121f1b8e09bf7d8b7f8994b5f02613c8d0398929292fa8ecdb1b876726ab578ee49e4bfef78006acbcef93ef795966987c1d3dd3e661fa093800291a1b508f85ae265bcd2c0b89b90ae50b6fc078f1b9e1d3e31a3af33ce7bea2019e3cc6c1c12a3dfa5a5cb4d276bcb1144db6a61d7fb2811990de7c528887b44e585d2380c573cde1e8fa969e49bc48c4aa205f869dbed7733d7f28823c610f14e09a49e630c0347c08a3817bf06a62e844ac3d6894e1c1ab7bda636ae3891f103b9d121a765f0798879efcc36a26b80bb4e53e1cbd3dffccb4d38c5925d4852119b7efe4bfe5f6ad65860d2f4b8a1b072764ad09f4d51b71c05f7bf1fdfb682ec631bf2877d56241ae13153f73ca5d9b71e9761e674b470c38e712c52f89628031bb41c8032cac8ab3c402aa75864b15b7c1e9a77da82ee07f5242d9ff28ac4d2bf6c995cd9af8c9c749976b3249ebd84a68cfeb8511553cd4d915bc6144add63332cf4491334fee5fa75c056274b1a186cd8fa4a27f66604347b27ebc24bb914d3b5922c2356c10f565c2c7b34ca40c5d70450b86e1715dd464dd8dd9b86c507c1c6fc2c2bd242d153c4e863446de7747f2113b23176e4d89c9f7030e05fae64eef7043f1871e6fac32bdcf005aed66c2c31bfb7476d381c6feac2da41898a563f11762d8c14495cd18c517c5647c4150e2ffc044a6ea9037fc0ed0c217bd7c549b195b4daf3dfa8ed73b119c3f06dc3abb7038b2bac33abb096350a9ccc0b950aa1676ed95246e20f75b4c1361694d2c73aaf6f47b444e4e73eea6e7e0bb5bf056609d642cac15161cbcd9d630183ee44e9b76bb56d42d69acf7968611cc2e7ba1a938e578bfac2ea55f0a0bac0bb72a20bf57ceea32d11f22b50709ef9c5512b349f9ce6ae502d548a045be8d717e78e4bac4b07f43cd6308f9e2e611cabc064c43f8071ac812f158ba6778931bf56a647610c6b7bc7b308721bda39e0b1087e4764fe807568f4aa4f6c7b3bfd6f493d41c721e25f10b67a74b2c7d473c8303061c66018edfc4f783ff7b70daa3bb83f45f91b6c90f2ff82343157bc3cc58ef70a8738b5b67543de2d1f14288f7240151c90796946aefa9830fb8097e81c1cf486d23e5589fdc7e8ddb80f57a5e722fdd74caf8db1caf81552848b9bf78b28c12b6eeb5a27e7dc2724d8841295222b63c34dedddc08d3be7af68c37e80d10351192c84a4616c850276c2c99a779420af52632265cfb4cd18f7a3796bafa34c6cb946e4fcf8ec479a57f28eb82450288df3c7f20747feb9c697c3e1c6e44542e0e64938209e99b9dd803c69cdc5913d0a7fa9c14a3094604abcea1a27c943818d453d757c3e37f1861808a96c89674716c717a4dccecc17b0b25cb73223c5cb8c0cc0d226f32ff4e194989fdbadeba80a1207db582f341cf0e422207780ce0f7dfea891526055ae296d580dab4aa503337d318f293527fe38da8e2c295d8117622da75f48173b895b789ae95c3ed01a3539b216f6062f90629c51bd226c5fb216479af96f4ddc2cfe587e8db35fd0d10402e842191843a4c659a7289bb1f8038368a406b9985dc8729cabf2301a19d295dc285db537c6f3c6629644c590da9c89328138f353b8ddab285a6697686821d01fe91fa71f59287e91b53f92bb9395ac1d920aa3cadbfca63227b3fd1f1f10d7aa729cecfb506dd06b0972fdfb72e9d8720f98e3fbb134438edf69c7dc513e56a076aa11a23553abb2c039303e5d59b28708e9e1ab6080c72ed58eea1399c977ba50e49640caed105042923e7dff3e809fb6971ded0db9d9490f7df51364a66e1104268780c55a3f60e9e6b9bafd90de407df966fd7b55e31bf7fcb9413157bc60fc2cfdb73ddd25bf5f40f3de0c1d52a33c844644d87d3148becb576a4649a842e5e7a5b9187a9cb177f1bb2093a918f3614d25ee0d97ac0367a1986fdff471e3c41cf23bb17b4be6cd092c0a4e5db566b02085eaddc6363c7899c3395445a301b8dc7b5715ff90c26ea6c6db0d433e5f7c7c986a20ede4fa2aeec0f384796b5176e4f478516ee9f0c94daad8e73ec70ae70282adaef066d7486055999b806a692b60df60992496f1a8fbb8e8d4bd308285a1b7694079f47d887974398bfb4ab0505d8883a06e90ba759634ded6c3e30c68b19bda603f637edf25aa61a0e025447ef9d82a55271c01b94f6a10adba7ca4c30d541d71ab2cc8a7bbf097e91a16832e85d6b0d98bcbf99b9e52b546e8fbbac97747447016cffcff97cf6d981f4c1c031b1831cc867f10782b53b2c532d3b7f72e2922bd372a36c955da434599cfb6087fe34688c577a97e3c77fc7e242f1f06fdcdb53fa3a216501201e180057fbbc9cbb42a77b01e4458c9eaeb2dda9f5375161859d78e30184fd8c303d753ca33a21ffa90cedeabfb2f0eccec322b042d7613b2e9ad5b86524e65cd8b0491ab9a91f48fd0fba25d8ff58261aa50e58522937ba24f72ca5bcaa90cfd9dfafa856089979c3b54f1d6030402ef94a6f37b0cf9bd9dfb234db8396a455917b6888e1102f2774bb503d17eb3c16380c700a0daaffe295ae8eb6993bad5b5a9e3da386aa46119e71a907d1e46c6c439f6ccaeb702c9cfe5564b2d7c8e1626c01412de11388504b8d1bdd1581a4eaeaaf9deed3403d0f2456fe583146e818e5636712397984661a61e78d753b1921fd9a2d108e3bcfcc91114e14acc8895a5adfa03bdf25a549416e7154f7129cc1dae1b655c696d38e38cd3102bef91de8e7b41787f1170a25a3dfda7e31f85f9fee25db28c5834f009b821baddbc2ad8c1d7174070f192bf254f1dbfefa1203ca5ab430961af10020797fafa2040fe906b231dbf49deba864327fcc910ad9a7078796bae43aa6f48432dd685d5c81b2f857b8ae3949bec83fd6845e887907da499d2c2583968d4895f789939a3ead9daadfcc4ec7c4724cbad476f485e850238b3d461a05d690dc6370f5024ed739217d129702f0d38dafb1c50814de8e9eba3620608130f7cc8932098c692b7d1c1e09e86d8a93304400e1f07b501a9a7e4a27adc1f2aac441cea9940d2b0485aa2cbc3819bea742098217fb0a42f492f3df37aa8217cf6d0ab15bd8bdea2a0ea6daff5a59a24eba803a30fcbc89aeb42901d65bb138a906df0707c457335a66a6e7fd108ff060584ef565ebfa1388","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
