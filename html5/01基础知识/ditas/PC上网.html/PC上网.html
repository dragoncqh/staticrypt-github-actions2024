<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25d6dfcc90fbecf8a08aae1eea6bde7f35567063143070e1650aa470f8ccae1ab0ad9303e6bc8c84d5cfe9887b905fdb65fbabe007dae21b43992e07998ac20761972daccf7e5538348cb4557ada4bbff0ec72d11a161d7980724c1f6e120bb615f7670060126656f536d5689060cbe41555d00cef767454e6517b8dafae51546a464d8962d1b3455b40fd3c8e153d618871926bbbafb89519dcdc6525eb6c1dd411c3da7ff09627110034b9d7800e3ede1c7e7c6a1125cb78d3c9f27daa0fb0eb2e9620716121bd3c7109354a986738c453966c628ee20104e0208a722b5e32f00c6f2caeefb3993359ea41e826d99ff5a3a36a7d6c62814fc710f13e5276089efad10aa0275bc541043009544e7ae25ea6ea5a136b3e7b3d9b5a728f8b89088faa2473b452613fa26a53cea8c19b1e6ecce47d1c19932551266777a8006de1af245dcaaa70c3149d77f7137772c483c8133803e7c662f7bcc8ad695cb63f441f12042db6963e4a2fbd6fd078f7fe84697d38b23d31a64c0b8262dbb57da4e4ab825df3a1ea4ce5eaf66ed5637be258f2849e639bf805513b0ceebb2d588bd117808a3dc4e021df9b051d11607475591e5237f38e65a64d03f4a71d263d74d65d0f4b14f159b7afdba791a515774d81ee0c136435fb9ed234ac78b9ab9aa01eaeea1cec3d7ae51d3ec36ea7a77c9f0f14ae27362a0d2212ef4b9454df1d8bafb3b0b2000322932b4068317417143c77f1a489435b93420712d7708c5c28521b0afd6f327b5f6fa2f47d347e0a02cbd1e9e1e90813a6ff9971b651584dc60addd30464e753bfd0cc064783abd520e7446778ab7febd6e30b924887c3046386cffef27da9f8171981eb9c45d587a63b2591e04d603b41b313f9210379afce3b76731f304cd4faae40025fc8f9bc97f313749e37aabe9e1d0a227fa0fbef2e1bcd88124a4c0d31c255be0fb35a6edc3e84c6845eeccc8f3134ef3275183e6f560c28cbfc5d2996db8ceec07f8b7a2fb2c36f70eba183a77e4a204979298cb07950d23c540ade448d9da7ae51498b3cf87139eb1f4371e8e6e9ff6ce59ddb3dc14d3f52ecd5c0a08bea1ca94db08f59602898d71a31a5b32436360151df8884802af7dee9a078c8a4ee656ad9a893f1b9d68fe2989bb95da77f8170074b5c4d64dc8a988bff34fb25311f9ea385f30524a8d359f7b61fbbbc61abb28e5c026d534fc6cd5a92cfb0171b8cadbf7e6b726313db16c77fef4c7c284aff67bca5004b102607f9e12a0df3e56ec68a469cfc15bde87c5e24c30c30c45477152195e619310d0164c095073938a911cc9c14b48f2080fa11e3982a9b9c641886a41f5f560003ac0ed5a75eacb2d3c6caf67cdb6c2d22c04519727d24cfcee069f33f60950066d25b6342b83a69fce5265f66100fced89a4b0aec498dc9ce6b87d08784313847d86910237d83f460a7d2e6d69220e0dc83a19b65238e068d4b6f60c9ade775e19e9143bd80474aa66c0b02cea7bcb436f0e750bba555092cbf135e40374dc0e35044c7c57d417bd817257c94cb4d98911edce757226064458c76a227930917b1810b7c8a8bacdbdda68c04561668c8a5e58f6a00dc918fb588871c3c710b171637575bb6f2d305978e72e5c2f875dcb6aa7561e55e46b76aa0e91eaa3bd313d91b20aa506adf12665b0da3b1318f12af7d469ea635cc63cfa59b7f23a51268042c5c7dd07a7eb8479f7c87ca8bdc959d10a9b87d7c5b4529a2f0902f2a65af3cb23a907f18bad2655c08307db6ddc58f3c96657e14b166f634de46e6ba3ec6c3d5313cf36fe83389b2e0f6c32bfe730042591d7388c66479c9da497bb7ed7d6c678e72aee7f0fbd8e9fb28b17d75cbc19b8f0135c52bbe8e724ad81252b80b443717da130794d5e18f95ed8c0fda2cd06b1a09e5b36ff0b56be90c69871863c8fb5d99ef9ad8b6cbcd0e15debd48eb59e86b3ffcb3a21dd3d5622e56d54e2d20b5b4c202d1af47b3bb6645f655d0f63481fe12addb1e97f34ee41c8b0703362b571900d5b4ee6dad51e44931339748bfdc0afe66ae4d519fb7c23c73a60e4ac6a8195fa915d47bb892e535a92a50ec4c088a0dd18cf6b9b9f2d750f69d5868a65eedb7ebbf199c3072a2c4f441072bafaf322b53a0bd72f9bb7fea67b904c64c45c256ea7c4fb28fe9c29df864a2966af13d6d1a6e853b53e8270f6198a77de523eb2f33ade2e987a6a24476fbcdef3d5b3cc0d13f7c6c43214fcc19b1e86190b23869bce8b8b942af54017b37821fdf65f0ae2c55a95f28ad9fdacab9d7dbf5bd06ba774d378020856e7b2a41784eb67206db6cf795e28e79585b49bc8f7a89dc26792b0779b9b1bac72a52232c97bca3dbc2595b5cabead99033fc1c0d2104399f06433f32716dd787d87f9d04e60b55593e3c549add709fed722e66b3c411d1c80a436fff01558fc319e2dddf609271290e9364035eb13831ef9348a5032bd3dc04f2503dd5a76d18492fe1354e53ff121fd1856b9503575a50a0d7e9ee9657a7020150d2056c092bb245290aa0a6a8907a2cf90b2674249b63e386b88dda7fed0d05ca9ca1bf0194642b71d2c23929e686a8925531c1417e8e5dbbb87e25829d88e47235667befb6291b2e9b7a307b94fe0e6ccc2cea22a1506839e1259c398bc471cbddb1f0546e56580e78926ccc2ddaa56e0359927ea000f47870454442b6c16d460e8f5a82480c278115bcf604db7f2a77569ae6760019a82f8a6b487f54a45f5818ecb4eb0af55fc40243c1171743fd8b4deffe924b34fe59737f877ca177dea04cb7abfd9bffba1a8fb6a8bdbd7bb3c7e465963850c890dd3cdf98c6bf9ec8efe0cee852dfa02d8b0ddcce7287157ceafe68b5bc4cec1225f4a32b17362588fd40d5f1bcdb4e47754346ddec45172896dfd21d5f8195e92bb840cbdefb28205ba491e74001c958795d66c682de624e0180ac5717e4cfc1a681adac157eecf053782c49f48ebb02565bba8acdde61aac353224927d046021b28723dcd0a7ca0e04e366f26090e555478b4ee961baf2762fde0406ed0e46960adfb08d374370d3cc0f841f9bf56eb0fbb9e35f54fef1cb070260ba10cc83464817e2874c3a06cbfc40cda0340085c715e1b8805fea468ca220cfb6c208e400d7a5b19bd9a5f78ac5df4507be04524b99f205eda70c4802930fabb2aacff1a3100108a50481ddfe5a015bea42576b7ae2bb23b83f22ad5f07fc844a74029d86c856fed39c085e2f4a8be428403f23302855d5cf5e0b407d96926b2b3d624a58324f6c0ad1086b63c92b9fd5940ff78675be1f6506510fab0782be3fc10109ecdefd3d73899154b1495cc0e7532c44a5e29337095c459e27e3115c9368e643bb2ff50aa9c853d769e785fe3576802e30b7cd1b66faa9a5f9e1fb2f44f7e34d6993c05e89d6c256caa1618a23ed6c58222a44043eec55885ba153a17b39bd2d4680bbeb984f78f2a39564a0eb0d75945f9ff39f6446eaf74df3ebe63a88808f0ebff31daebb9b6eb672c30398ed502249de74ff038526ec8a7e6b452996a901e2819fa615c09a0c10462a48f0e9c7aff21f1e4b9f1217e4cbfb676d50c8717061b43082ed708df7ce611493ac71e2b02f423fba0ec2e59232fd63a132f37e0776d2ac76894e43e11634e3773ea45365394d09ee8f739cd06af4bd2f21df8e71bd79db1ce80bfef137efdd783f7e48c45fe174f192c4600c710636e44fa2e0aaffe9c40a5b555600df4e23a7d96d381c435c0c7867fddf0661e61effd01b066f32e5943df34725c4ea2a86f2fdeb2c9a382205f2918043a7a42f1223bcf0d2d559848a0f5eab555985997eaad33d834e38f6ba7bf96bcc34ca0106c9c03d47ea5727597e99dc376f9451d13d0ecfde7daa96f9b1ebc037583eb09d48013ee77b34c10dede714a31446855b4bc4fcd0dbd9179da3fe0772f7d779e5bd99813eed076dc52567cb40dd5d93a4b7439e89adc8e80b12496c9f74f2608ba8d5f43806c994e47a2ac3cc71049f825e46b55a25adddbd693f30a1c76ea0f31ee34c31a4f2aa6cf5ca75273f19b2bc6afc7540c31b423416398a15eec35e6af82ea67300af444c93c20f49fb8f40d781229b6ee3551dbf16443b4fc67b96bf15298a2fda2c4e3a20643afd8e6d684d63ef267999cc77c39386ba5d8fdb538158ae3468bdbde81ac406c82792de0d9bf04b6dc08ae6540dabc38cdc9de427e111e3b88cdc36992cacffea473d32972e3048457ab6f91a4f42f2cd14b75010b22e01e30582c00b93b2f94e376ae641c37060ebcb4b28a2f9386535552530c8a1c9fce51bf7c383bce15e1be74f625035bf746a3bb667695bda39e4bd5ae49d589b59243832ade44ba2e7aeab1b8ab1e1e9ba0d159cc776262b229b775251b925c66c86202a03c0eb17fc8acb43c03d45a6154c847591e885cb71e5d9787dc2ea3eb75f280c12a04ffa35b9d70db7e732f173010a2a685182e4ff4cd9312d80b0c84e8ed35cb5c0020a9b5598e2e27f32dd8af2e8926b83c1a18901d43e764a80e76fa5abbb62a5b0d45649926bec69d4d05f24d49b216bcb2ccc08cf57ef34c14d829cdca07ff7787ae035ca7a70e6d11b44b0b89a79cc71f3f6376ad33c11c81abe05b54fb84b74b9e6509eb705e0b205175fe4df6c150a81d7725696eb8f6d5ff742df1b493d0e52023bd9fe9846e99e2f4adc9990d771855d5eb4a26fe89fa246b6b1020d5984b9507a823a04f482001d6091e59cc75bf0137d4fb789fb06894d00336cf65c41fe4f5aaddc12975c3416118883f1b07735c0470aeb01c8b28bd1a397d18a2b55e6b5859654a1683b1eaa5dd61272e9289a96696d028d3d95527c6362e08377b5dfc23769e31ff7deaf841572cc8594bc132bdfdabcdd92b719234d24ff0d4e0adee46842ad754757411caa0a6d370db14c34f8a43754cfb69c31e8fae7e9c0fcba4c0c482b9fb8138cc8a8ead4e618d4e03c068ca21a4e49ead8c56339822dc6d316e3299ac5009e5dbb024bfd0d13f3ef74917316bea384a90ef55a1ac6758bf674c69860fede445762e5c105773ad16e90ef4cee805414daff70f1d9c31a594bcc4698d48a0dc4078d698c649049e7034b4b14e644b5d56fd07703fbb1ef0b7629cf7daad5e8b54a409d735241825955a55f16ca7b2a1089d7cf40f79abe848289a888fc5ae0c2898232cbfa512b9aa53dc435ee065b688f1a531b60ea56879510a0efbfdb92f3ce4cb40bda93284f0cf276f967ea69a08b49085a7a113dd6cd19bd21799eb474b1891a12e0be88e307b2da66916c5dc70ef121b9d1dd5891c979b6a1db520430f20f8e8a55acac96a3859f19e74990c424680d97559026bfb97bbff0adb1792f4ea96fed0fb2eb518ae1f35e3eb834cb9e058897fc4e4f44f343c100ea5efae47d739fcb5628df944cd1af62e3111e8956db1ed7aae9ae817a8e804d233a2b5293e12a812f6f46f9231a7720454e5565770a84d0847792ff0cb1d552c7608cfbc41ddab8dc4082b5dd76d654273734862b18dcc455c26258734d0d9bbe9479caaa6cfb80704e53246b5649928ed5c248314a1a5798febcdaaa3f328091e3d9a9be70081b9dfe9dcb223c35fdc434217e6ab286d0b2952666bae4ebff681bb10d57ae72af0133a491a09f073aa49f1d2a0b99ff8d59a61f6ab81254c1c755e6e8e14b89ebec7bb58532cd84985d89b67ebd67a9777a10f5ecd34ad4eccb4552dd785d77030c0fb3bc9e2e561589628b4a378f4d633f5a7813bf0a09a44e7364a2aeb50d90bd2ca03de4cd2448c83b503a7b2a9e659916dad5c105484fe8d88f9b7e9a5ee1935284b7d68d3e9656233f6929be9009c99723eaf6c9292dc7150871f30fbaacb395690620033bfd3b47b81fc4ac7ab8c47cb7de63cb8af242a80d8657219f54462e3922caca97814ae8cc9ec9d033d061d2fad65d230eb2ee0511c333bbc8600226a90c4565ba75f10727273ea25dbb302659c1fbb911cb0f0480f340a087bd1ba68f3eb655d83ac6bc6044291acf68c2bf9019162968da1af67011f8017461a8fa0e9d1992a1f53f680618f5e9c81bf229c3534a61ddb2e0c0baca60315c9110392c3afcaf1366de1932cf1e1d0486b6e288516b009934f93b699339eaad6ba77bd834502a0dd61745bd207b010296674f7e24356c9fa904a9e61594e62f1641d3432031be5649835bdc723db44f3f0e3b5ba7b840b542df95fd89d0fbaf08b51f30c5280b7fb0611c67e6a9f2f4a31484a6e0dfd76787afcee66dbd8aadd19146cd40089a8f90aa79c6db08caba2469bdeeca17d04c75c6eec14330cd0901ead1b17bdbe36aee4d03b8e14d9b7e07a96c8e7817064b19a2beabef3c06ebc4c2a35847a8fa3b4f46d9208058008f591095a4f2773e304576e40372ddb1de9d56f2d4285dd75e6ddfea55923e2ae1974574beb81f6196c53b1f3b61d4a87cb4f66db7f2e5808f7d14552b1f6012ddf3203b1d3949c367c253019d6d6d06bd065054c02659636cf1cdf66e6b209b685b86eaca2382c09604a591f9748f53a4743eb2b7661d199a3dcb39bbe04fef3f228ba358533271ebb22a106135193e84260aea4a62864e918a8bdc8f9c03692d26627deeae065fb00173ae44f2c7665d1a19d21b0e91248c460f2124d7f5b11f5289229d8555112631065b161043d1d8dda31dfe2e971f5312b2a340963b38f0aba35e45c56d2d2b099c319ce081cf0240adf2d5d0284f8571e4ffcea4dbb10606dd2489cd5007894b318ddf214fc1fa5b3bdebed8ada21d659ca5bfa1a0b13766918f7e9a53ccbd2d979b5ff450367cdff4175014a1f573d6779329c1756dfff99e49f374cc11e2fc4ef70ed700949f2732d142b9442ab70d8dd1581b891d1d46a80fd299560e22ab3d7c1ff907b7923d09eedcc2d7cdaae81a36b763f7fef0c00caf9aaa57fc9d1c66151cc7b40611f026831a221acc88303fb8aa74c2b10c5848c6790eca4f282e1ed28019a8ad0c6e649ddbdbd5e10ae58257eae37e5dc1ea7585c4f343d0ecd4d0b0b69a08566f684a8eb86fad3e838ef64b03112e772209a124e82940e5f2a8445bc76d906d5710eb8ff03e6cbd3960a2b02086b1d4f32797357a5dd4bf7082d6efd94ba81cb958da3160c67a19b77512bceb0969102385e53fe9e74dd0be116204e6d70677bd3598c4b945330f508f0f6802b22bfa787e9a9ae6a098bded39134f3b53ad67bcf27595104e11c063353c4b7db7b87affc91779f6e2b6e721112cbc85ae6f41bc8bac99138b8aa762efb1bd5f8b64bc04ce253a442c05e1fecfe089b32666bf0cffca2ebd3399b42c4ddef674fc0f2fa0b79f3d25ec0147004478af786a96f01b1717d825d8310789692c126ac455616a4bdb1a730ea1915d48425f931995b82c71a93bf5b940411e9bbc5f76ddf752819fc62450ee206225ec30ba9cd1f56528600f0537e35f60426bcbc70d71afaaa31e1bc4f5f064b871c1e26caf3d5cfde17d6be98b11d2f4f71d00350b8a54209074cc72e7b149e73bb4768d0ef5b9cb6e86e8ff5cdd8c0151dbed785bb0ccc453e4cc9f14fd590bf33d73798d9a9407f00e4c5d165d83d7e07f5b1580c27b4a1f3002bc2558917c321c4b7f0cfcb66b50e2e3890ac857f110ee0f59ea6e14abee07eb9a8e4a6b680181ed6167927a85d741e18ba535752e03965fd5b8054a4462f95d48a2ad05a329cc278d9ac03c73f344d74a7fcd4b51db4319930e3c1f3a29b7d6bbd4f1ba2de1f807d6be926d653286050730dfe3b4051ef5889b1a7c31c5958dc7a82f9ff2d6b00b3a89d2819550542e4450e3a2f0a79c302cfd12f53128424892ef7c918bb3e776e2edd155e4225dc77fbc494e1f5d87f27e998b46d209e2b308976223649854d5972126e1be6b1b12d9482d8af93c16150f9911720b486a893e8d91bc556bb834f60d254bdd32871b918fa232a2c28b56b5940ffa73be4187f276aa6f807facf19eef669f624afd515465b988dc29d1fd0bd4532e8888f6c036347812f0c1c22fc457a849a87b7b155c08d612d6ff8c6bd6839a2fddffcb3f6db76c2ea7bb1fe8c62efd7b576e332f4567df51c861ab881bc8a5395d548bc176ba8d9fa50cf1d2dc5974f876a68bf0eeeae2c30dfb818f8d9ad66742fc65dd1e971e8c7c578358c7c62da8cfd6beedf05b6473f4faff12789fe1b94106420f79f2cb8210917b563e7bb68f9bdb715b8c2b35f00939cc7d34634f7a786f5685ea0e5b072a9566e4b375d59775ac79ee21015024efa94b5cec14b2951651f24eb92ff630f23081e7c229c9ab7b9201a767090b6504c92d0313ff54e90b449dc5b6259ac5416921553988e8a34120ec1ef448d27503eb7c5f8cb9f81cfb0ec313962731fdbb6cd657921ff665d5c2df52b4c9f9ca1dd357a006e5e30aa120a05a3b535fbc5f6dad0656bf43ff7b25722482e6a14db0ef38ba5aeae10b6cdf6c9b9c64e79b721e1879220bede7d62837c3729ba1eefd93ef49ca7c7fbdee9e2a02f1d7cf6482da6c99b1bd36866f3baf9efd4886971b1b599cf97cb6ec93de11717043bf590da5434a1ab213d11997fe67aec204c86d4e645d6f0697d3e86457794f4e52803fb129fb2a07cd21a7116e1fc23dcad87bbae65281808a663e03b32c7b6651f462ee5b45037ac79a424936aeaec5c6b0867c10ba063a95c4f65a9144b4fdd516ef6c9decd271ee894ed97cce74e3f9dcf9c0668dd9464492efde873d12f4c60df778840ef34fb7b1b1acefca348eb44e0f1c359cfcc57a85cba011d1b30cf8b3bb6623cd96b13c49d4a1dca09ab9a6765d7f00d449964e2a1302ec5606e283f5b941ef5f25f9df323ea2331b267314a388d021edda0250ee4d76700b45777fc2987f3e4008eeda9615970f3eaaf13b51d74071361524228007a21204b0c63e4f8a6e3426b84d5be7488ec7024f2a3eddc546070d049ba106ed9ad3e5f9016e5ca3e39281b017db49f4a206893dc08183c7644f339071910beead5202e2457d54bafb88d0b53aeb3691ccfab0bd3a3c9b8f0495d5d162d633619c0d0dc30b1c04243099f53f7a467d12bcb78999c838f00ee5b51f4ca0aad020d7acb89dc0909eda5a5c42a338fe43f961d3c7b5d8e832fd159352e47aa46910a43ecf14003337baa6795ed08d8455f891faf003e0fe52babd69c7f5406fa5789544b7e1153524ed9eec7591a9e3dee7e7b329ac34bc7c29fe8f6c782778858b7fafa38ccd60cee88ec26477e44651a6d2a77b406887900763a7b314ed3b68e61996a0592ac1ff16931c7716c7717e5ee2e649c4589c61ac0d7d6fa43e372de44ebf199408ccf45dd5020b80ca14531a6c7c98db434b0bf631c3be7a1b80fa6fd80a1673ccec8aa06c8ec93bfa91920c4b147e2657d351fc8496b5687ae161a9efa63965ef9953db24ace1c5ec77082763fab2a45257a8b6eb6dcfb85284c7558d9f12eb88baac8edbb007c467ad52d69ee93d6e65ec58880e209374c4e0f22532b25382e0fe8d4face19030971306d9b290ed2303df04ce38018c0604b3ebbea777f6556560a28d1c44b09ab978695b439583d3ba3fe0e67881fc893e4a6f7a36e64e83c1601c770c6612560282182e7524ebcbcbb694c64aff349d0873db9a0da7f169534974d2c87091b2430b710fe2985ec3481925e1e3c9f2d335abe668c7ef16443741724405ef7905e6a35cec66515d829d1b862708930b86351f2431cc2b305934d0a9ba2a7abfee50b1cd78c25b4159f06cb3801312e37cda8a4ffa957a6f07c30fcc28fe0158cf78dbaec23d3830f0805b54d67c56284bcba6eee73daa76d042382cfa49438c523dbfdb1db2997098fa31f20cd94bae00b808b807cde6735a0f26e0b208c4228e0f00037d3f9a24ba636847a9ad68abd7a6cd448139d6d2b75db38f17c899ac2c9c0f7f693f6b6cce77e3e804b5ccc8b305d25f24a149c25d015f14f5cf168bfa287d398c07fa1aa1c43e061670cebc4efcabb5dd4ee80dde32b6be63daef5c8b7d79d2571e0ce2e087e18d66243f154c8da683e84c1fd25be8f006d1a3415e344888a216ec040ee284c0e35c4adad30d9233d152c3868a4b165996c9385281e60dc0073c2f9cc7aa0dbd85901eef13c5ed72a8e53ef2c23c3caa14425a1500d34547ad2e64536c9678568887f030c764a4ac38b6d2d44fa802f1b9465d80345e5439f60227ca8d0f4237a9787c2c9e02ca2ce23fb313366226b589956b51d55acb95ac91b2bac7d8f3f392a12c56862cb8e778d6d13decaa4418cf055a2f58f9e937f2ad2030fdb8e73699f04667fa9305c7f2e0a8133950435df72a4abb57c049e28d5d168b6d694276da541d75facc824047aff9229b5baa3c83b01d6e67a5f2781365067fb21ab0f3d5fdcde631f039819945c8a711bec75330766cddf14329bc3a237f43714d6ace843d74cb92579263fe072af9b183b734708c0a0319a3efa731581d4d48aa2f5c341a7738a78854df7ec58b9f7df9ce9cdc74000827f4440b07ed52381de04a58e31d8e969e5ae190d1cdb5dfaf678b291c0aebbedee6e149d53559a95805bf135e1c342ecfd7c97377ffa362baa4c4d066ea5217ba73d3f948b8f8c21054fa50aa81ef41e3ec9933fd721a7a71e32d1b7339ce43cfbda20a59161da70f428c1a22417847adb4439b1bfa390f01ca5a54688e6ef3e3c1e4549b47583845689b8c4c10463be87f9b763421e247e393d6c25ec07567f8c5e03d76a7f6ae635b0d47b7ac6c21ba3f908916e1a91fc01255116d4598364b27d388582ec494262191cacd3da361a1783483728efb96322bcbd1df0c5a0e529c5ffbe4c7f98da2797235ec762763b86cfc832919a6f3377f18efed96cba742f1a11d927c80f781cf9b1fe718de3eb9d76bf0fd01b03200c32968a3c12f2a543fd7bfe4c1455ddc8c97d0167e52873949ddc330f2b29352aa9cb04abde5977c04466e6ae2ed1782c675dee0b488d64207e14c9d876604effa6f1241c22ffac6ed83b27c346ac6b4091d942870555a34f369a0d11a6adefc507ca4eaefcd43c1413e3eb32940b2c8d7b090fe0b4d771b41f25403f64b24361aa8a6945b248708de3a1a62f0a3f1dd5b8a8af23174aaeeb2517095f458283bade99ece809e1475f5fdc2a2a6bc19458cb948fbac9cfbb804b21ae84ecdeefa80d1feebb238cb35bce0371b180023d1b6ffe134cd1b7aecd322da45581a0b64fb162c34fff132a22b6ee1432c88c650dc9216730fc632b4bae3a2047a085a64433f39ce03920f284893a6526e66dd2c64568efb1c86af83071ba8cd077757c30b1cbc6fb54108e56f29a6f0e1a72c4da1a9d03041246a941de82e1630e1aeac7d3a264477578cd122c8b097dff27787565a2d65547efa919e06ec140d07236a38df772b9386fd22f9ca63bda036ae08d596964406805fc26c799fc31ad77d9679059a8f468c32d553b22518e770829711deea21a34bec4755106c27da971235666a0638a70390eb9f101d4d7517315a9e3fa5a6d25e515f610e752537f09abe4e78bda624320fe414e163089c902d0304b8bc77f85a161b0409612f19271eae33b7c4d19e13f5f004e464eb255e8dcd303c1907868e88ab10895ef4c010a4cc32bc91a22f6ac63370841fb07b74061b999363933fafc9d03e2a6c7d84c6afa1568cde87664d2692c8127a54bc720d49da473981bf2724555db46dfdf45af61130a2d2da4e49e3dadf03c810cce79f33373f185f13e42e04d7debb3fe59a18596eb3dddfe1f1e32fa13ef23a15f60b73f3776999cd816ebf779e1aef73a246fdfe62cee33b516da17e3f2967b9cd5edaadf1237c941c17e44acf01b0c7fedf67547904ff90864a85ec87ae6962fb4f1bbd31a54f70cd95cfb259cfe5faa82ba4d7efaef6f69b14a174aa9edd74e3f44e00b3b9b1f68470af6f790672afbdd19b33269b11696a549dbb955cbdfdbe5d93d6609a0ffcaa36a74b0eca5149a0a5acf0d9e37377e1673b2cca8406437d73a561adf275e0ad0d3cef15b943cd8d0ce1f19e27dd9ae379433536ad2d65830ba045252924d53b2b44cb88b9a8330ae1dbee54378bf0264ab332f90aec6f033b80641f257498e20b621ffdd4491f5d896a2cb897b5fe90cac829d9d7e177255951116849b7b953e8be0d0054829ec4463d79baea13c0c3f888119bd29cae64098c6f5fc957f6ea9dea14d4f9339eee789829bf3a488b9762c0fc191ca6e25a345ad807afbab54e0a03e11d77f31e320c996593d0fcc332ca700ac99b88efd57309fc756658e9de13ec7dc0b74ea339ed5f7495bbd1d6ccc0c12591246c7fbfd6af97f1555819eebe474d20ecbaebc89219d8d7fe0b9e108c0f8fea80e57a7138c3f4698cda17f41c5f0ae9acdd4b98b0bc0905e8fd0cb0aa488db0afa8e3b8fbc899c0ba5028e7f95cde4b004beed1920e8b37e83b260c0550d63d8f3f3aea5486dc5994f56df651f0700c3c94ddf82a853732fe35eea7dbb86e1772c00837b87790fb4a21ffcd7df787ef3ea2367af48ea2483b54f6a7befc52ba121d2ce79ded10e6463bf00b0049822893c43db4f9b3143071bff29e61026a50489c6081f2daffd246f6a42a21a355eee8fe6ce76ed5abf134d1b161bceb93375bd0fb1405d7c3b265d9ffdd7244cc1d2c0c9ce0e6eae0f1c2884baa96d8e8e683138eed6ce3a47ddf173bf8a3739791ce88beb768a3fa5ded291523941de653b2de84ff9500e8296dac1febafa6f36e0f5bd5f52ea946b83c16087fc835214341b027247e530aa489b08ae1da72246e0959c721eb4f27717f08cb9b550a4708d4382f2eaff4fa447de09641187f353229787bf2ee7f0b80f51fc0d76884cec13830a8a29ed8fbcf42abbcb6ecd72a4701a76d7ef7b0ea6c7a2a5f165f9491eb1b328c252cfd9a21d8f571a39471c829a20d1f1e754892c2891f2a52aa6dec5ba7bf172967f2f5e657a8de41cc4d2f3a646634d348d54acfca7170f063d7a807ed1a77f94c73b2ae0eeda277985dca7c21aeaf79e49402436972baff3a5f6f42f9690ec68bfc14427b33d5c1e419300183a221415ff9e322aa7727da8d61bc881d8a4b738306b37d2454a4485bd90e2913ee0acf5b6614c84513e8450a7ef8eb44d915101ac04ae95d26d0f2c46828d4daf76c40b44a788f631b7ef1e7721b9829b12ee30c9dc8e1a0389dcd9f7cd9db859f8b5bf1f5ca806e8c205f115ca0e2712b85c5e97955a38ab115613c2ad028183e1ea67080feacd6199acbf672dae35af39fc8e951a2047c7f2a2143a0f6a0095749d966cf4783a54af441e08d83f8490868214f0aff7dec480a5b387f83c14b5b9d2840ead16a22d78b7bd646a9ae438edcc84558d91d91c4e53c81037cf47e383b822b0a0f839d987eecfae0462664d6157890d3574dc0cbcce524db0fb7e079185a1f35fb0a7975edbadc80c149e6ab81e95b514d88f5fa121e8f2d8e82c942e4aabdb9e6d8fe7ef80c81721b05f7f0441986b41a63055844e06a78b1c7ce00373df947bb773532fb76666fa9732509eed9731f94f99c9ea22f34b74a33df613979d3025c165c5771bc4b7c627fb44850378d4b7f8c3ffdd8f93268dea1faf7f04edcd5f794618ef330b5c54ac05bd6c1219861f72c5b22f68e7918103c04f55d90f0cfc0f2cb69aec3693b489f05b036e2c106bfe528ff3645691fb76d6a85b3136e59f8e8e8e5be0f37dbf2d261e273e6f2d1adc37ff99df6b29e705cfa45ab4fc57102efddfc18774d4ace0e2f6e11c0927ce61e0be9402ef46c78c0bb2f15f1d34fb8985ae1450bc91221dcdcbdd588e88854e82a269ef0f94aed7002f20dee655a7593179cc39e04e9f2dbcb893e745f763e9f66c402a48452ead1513581c84d698edd670549e35da8d02f19402cb6f7298bc1b55c7d9870df438410e69923200e776a5b61c6f18044cc86f3003678b22657bab211c5cf56f37df2a994c4e61bfdbf7b7df5e5e53b8165435a2690f69b61acb9f61a6aedc23337980648e8b73ab703af3f9e11d0f8a6ed78e40510741bff19fc0770c6fb396697fac17f9e9dd15b1c9216c246387140871a2e4ca3c8fd5d69abef05bc37fd50599340bb681047abb34dab9a6d87213be0d788c1024fdf1a9aacc8aa6c37af767c37f5c61d986c2b58cb79970801dab105a2df4c0b747ba31ba59ffac9613aa6fd9448764677e1754625151be8126ba20c97573419bc1ca44319b3410a72a2a0afe67827f5baf8180bd4e88f3b7e41e7e267e6702f4bfb509e27fed5b4afbf9e5d91d6d696f526e7b8b61ac4a14db043c662e91bcc488a33b798eccbcd0c6456683703dab36833682effc87bb290e1c574ee8f06bcbd199967132ca650d0e971b7ba2754c9ed0916b7417787751adcf3842c2f7b0a53586e2dcd04b2e1687e9d87a5aa16ee61a236ef805101c8f4c1852f12d501fabab0ef50f1be41bad7c2fe0484cb21886b7c674c6107d6bcc35a669d70e382fc1d7d624ceb2d13bca69734aaec122d4c58c786fd35cc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
