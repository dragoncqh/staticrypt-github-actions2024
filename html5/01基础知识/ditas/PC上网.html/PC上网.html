<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc74200d214ee773cc805cc2b4bf5d69a6c6a8362caf4693aebc57ed07f0eb1079978a7d8eb1d58f69ac64da3e944b00a84c5955a7148dee78563020c32d5f4d984ea7cb1549e7e505ee200de3e4565e0ea56cc1ad4024b6652c6f1e32b35c25b7ac0efdf91565db14bbb1e2ae6ec6ad536dd9f67b6a295eb680b5ba9c0d2178bd9535d7581c8a01975d5f7c73c10d86d8c1157e754698fc854ee3150e9a8183fb97c2041fa7853ffc2bd7ef8ed9ad309dfa9a84d4deb979c55724ecd0ef53e2ee6104c294ba8b14eee196718e33f91ef43bb13105e3439c09a7973df817b20efeddb28c29430aa980f0eba395c6910fed0a646277e085edcf9e0d3a174da14d50840b5446646e2cfdff60949314f05c17f344152438539298eadfc1dfd0e47ea108bef16eb753ffef38c41547a3d5541c372061f35bbe0cc70c3e09465bb0fa9dde281e87591a074c680cfe6affd6a50c5c4c60f41f37e2140b9ba8e1f8794a9089bca348d104f3abb75f72f8e9198755e8b256dad78653c1b322fd451131456b62fdeda9070a71646cd1728ced8cb7d33115664c4ed7a57fee5f8cb8dababf86a6e0e3035d5fa93f47802eb87d38eba2575b8b953c68da67d2632729244c220a182fceced39837df9ed9b56739c80adb4bac49a5de9d175cb3af7c5ad864afa41fd12ed137b9e9570339087c25b330445267e9266343feab5b8ea4b422e36ca8811d522c25cba081fddfa5dac56e5d7e6fb1a446071436475454708dcddad92b6a572b7d1ab125f68e8ad63da80ed577873299c2065fa67926c7804c0da08b56bc956d4d96ed66d1aa20755e0470c72258a2d9abaff3b07bc1ddbbbb23b0633579d4e993aa077022204c90e1885a5671ba2d578d6f900fc95d94be03e640483a06820052ad07e0ddb8b9ba963fc2737663009ee417d62531adbb99ba8ccef8132dc49fe2f4eca354eb5b40f8e86c943a5a710c7853d53809054391c73a4a0ecb3b8ebefae9ffbf9416491b03cc3e34988d1b39e474d6c2bcf0f842916a2c287a41b047b99e06879a37879ade60fadd9b2891c2deda4e9b63c8cacd8694951f64c465274f6c06e2fd9b35bc48a66bcb8f828c8676058ceea3f3f18bb3303e5010f89f930d1b124913bacc4a53e104d57d087a21380cf45c7cd18dcecca65df06098d6d65d724a595d5afbb27737074d197f07d7cf9a23e4380afd816e2528a0578e2322fe19f2c870dfe66bf0a27034d25855c7232f0140773748023fd167bc9697e712cdbfa8e5a1cb856cb9418507d71e57efb5dcb107aee81157edd781e4191dd4bb69cb351f12a3121e38b510612e808e2e0fb6b367ac2d4947b759fe2890972dc9e0ba27f5f061d914e4414aa1eba193528d6a9c04f5928dffca72d18d06dcc6f9b2a9fe98d7984151b91f6e6b23fea779e04a2a913117e6c4448df5ed88ee45a690405f7db11009b48cfe772a400ce8da5d457d8bf0550e8fad5c426a41c81c8994f365ab8a6f789353ba4482b370a83924cce123959b604057173b6742e6408bd9840075c9f9602ef1f6833ac7ad74ff78eb018e42805d8dc188afc34fcb96b8918f5997387f3e924a8a58c298f35fcac923fbdd7433c7d60e925c49c6c102004139da9a68c2bdf58c98d89e72f924367549a6c9700ea0365edca22f1cc840d0674ef12bad3a16db85a38a47e27685ec2c62b76dabc331331d1fb376d23351ffb460d558aff0a889d96ab2cccc865aa72bfd122999fb85efaa89eb880748c7ccd7ccb94e05e5d8cb4980fe84a90d80333c9c2cb6394e747ff7f66e867be5e454640b95846a6ac0e84f933d90115196531c0409a284ab81f9ebc5a700ff925c076986310dba97fe1bcbd213fa9176a69cb31a1fe1ce404b4b171528e6e3effaccf3e67ab3ed0b59587cd98ca22f70f87fc406cd855c3a2f6c00586daa8718ae368f43cc5dc9a638fb0cf7b582588e9c8c3f22778f5eb235e9cf80d297c9c716c9cc1ce7eb1a61af5308e86ea65fda7070889df520991ba35943ef5dc517a6accb34b02ba039bd24c51f3ceedfe46f3eb94da824d551c49cead30c6b8e9128c8c89ef1225949232db0b9ccf14f18ce77164db97248873c9086652bdb20b227ae3231c0ef1625b27e2df1d5750741990f684bc971811bf721e1e1ad4a02942f4292078b30aa90f75f55c1cbf77344861561c8102f411ac0f0923f45ee764982116ef28516170f1d0c9959c9823a5a1f98f882b04439286b0eddf414e5b27ac6ff1a27d7a50121ebb8ecf83ddd5240a4b54a4972064d35d34750fbc01d7653b034fd8660a1410de39e88a86f76025433f8c30c040bf02f036c2efb4c9176463af05780ebb0a1c9367f49da1eabb7db08162d6ca6539cfcaa5777e0e254940400fc17def2fb668e100340ab690672e9884c3e686bd262f1c956dae965fa55ac0bc26d308f4165763fd31a7d34ba43095b9d888582218089a420b8c24786c720a6c17fbb1300b2e5bbd7624d6a6e9550ae61e1ba47e8d58e95b491fe9ad0091040d0f1483eb39b6a5059a091b8e29a3c7c814aed65aada86c61f429b8b0b883132b016b82f0f825cb14460878099a3bf6f4654247ea4c9d6b7b478d6e60b9334dc10be277d6217b309fcc70f99641f3440a268614aa146be0bfc196939c1454977e7dab2a6567dfdda6ec02808cdaab9dd002feacbd600809c13d312254f36621b5033059f5a7783fa18d481e1fd299aa6c86426ddf01a495a690852c2ce41adeca8dcdc212f9b9de5e2eca841c8e1081b33496383554d713a75f421a50df71ec827e3dfad8c20143b5d2a2ad774ec6f7959dd9bfd2d53cf148885c64dcaceaeaaeb3830f86ee6f03646e86fde9461aa2dc0daaf0f7d9072e2e05d3a3c969ebf335bf00adf6b4dd9db13eced5b5c589baa29d4b740baf6e9e7f33dd770d68a311619c79891b29e89935d42d2c08814d7611c88b0aced6a9a4c1c96a5a0ce67ff8f3b22f7b489ca4aff0b0485fb797fde35f1baa8e201d304f556836cea2796aa34c5af96cd9c04dff824eb87cb78dd6bcdce938a27e474bd011ae008bcbbc3346c603d186f269d006294c685ab9bbab48d794220d08e74cc855358e4d0a41f41285ed2e1d5ddbe4fc19a31923df664d782110b8d2d48a5f2646ea78792952e1d2ba5836f9ea1a9251a7e06f4ca8eac1c45db2651879eceda80a85c649fb58304a5ee735114a7009cc2847f08172a23270c59470d328eb5186851d94e74cd1ecffadf1af385ad25d91442f19d7efee2d90f71d6abe4f20ba0e736218496c2d5e1ca00a57e829304adb2be515e747553f5dc3e63e11e8c16486e4d51fd62e702c189d387c6c056e0d8a2d6a1e4ac2fd6bf156fb754131075c78f00cf0c92d3da494dcfdf9c9bbbc69d461803787c6ebd2c0142865f0450432634288c3632a26951e68b8657f8bddfda600d203a0323e71e6d34a42b17d284897f05c0f71068ff5c33914b56bcfb81be21175b6679c48bec27913383495b04e628edcda231676df6f2429321110cdb95dd3331711f6673e9ffe5946e0e14a29c900240bb749d5b9b7d06798ee9c23ae7789684ec309324903281fc094ee6d170f970abf7223e07ed0950148babfd13cdf25018e7b613c1024564dc482e4ed8ed7ad60a645d5318f4d539821d3e529e11e4355a67937d17096bf0faf713000248b73fb006adbd94d0e03ec8582a19091fffcb91127054f997590dc4b980fde90639fb3ec4b69414b9ef89b098d5b4201fd7f7ecb5cb59389ddd68c0f1f139ff94173cfd6b1c136dda07627d0e094455ae2f0c24a09ccb15b7eb08caf7f742604613eb7dd0c01f6539846ddd2e486dad242dfe667d3fbb85e952763b1d76436adeb11fa758f8dd004f6ba464bad12e42f2f8cb5d746ea220bba0ccb06eaa17f4e4af13c5784ebd8b1503889ddcc408d49716e283245157457e30a49a7839dcf2f63be3f77485e2405a70e7f1900db9d8c05650c5f6d76ec75f7a34d455ecb5e8bc2f3a7e271b97a32d878cab2182a03a894d08b0c90f8206d11085cdeda5f915f3c9be1c45a461337828e236784266a20aaff07d7fc8b8415d2b38270075bd35d1d74277f1803af8d38cad4f1750b958b559c25ee6338ab75b4c993eb025f30777d68dde078fc83fc34141250752ac63c72ac01b80ddef0c6bef2e6c36c58792f044b7dd823f112468440d60780d4ac7aaf7f62adbe7d951e7735e006864e658b5facd93ee98d26f8440e92e1820d076ae2602148a02c3b9eec34a315e181b617f8b30c0124c9be3a17f8866bb383524f43b12d3dea27c6499a2e3fdc831d34369c3ee677a277fc83fd6b818d0122a394ae5fd5b1299a6b0e2bf4fcdf75597282a7c60b82569953b2bfa2316c403122a0d17bced23e7df4cb7e7abf63abd23483dbc80ab31ab7a5d44c93a4ac62c3e0720d06eb9c065eaa969a9d8556c9906e2f845c87d8f083d05ca7c7094278ec371fca089868f58dcc1a61607b8f424c10153f9386525c5b64e87067d99bc5e044719c339a8545bc7567d767084f76abe457a6580499f95d7f72ae898eb404a23f3e898dad60188a911d25362dd1d6dcc2029ca88ac9561044f9ed01f2fb21f41cdb507f703dcbf4a182ff8859a335e0c342911fc3555a47d4a64b3c8de1d1bbbdc6cb1e78dcb42f19ffcec51d25cbbfd23764a8bb2eb1def21cbdb0867aeafc824ef0059379121d839a3b701ea0e33871726167e53ddf98d1ea929721a3d1de94524f940dc8c718b2119502f83253bee471bdce8f1898c7422bd602a432c842d91fbf57ea1693c32285ceacfebf9b212f0879f38b41b1a980cf2bdbc88defd5bd7f51b45dc2cc4f7815230e60bca104e6352a64bc3f22a80a23d83bd2e93da49e356feb75ed46de48bdc1ec3e87b2365f0ddf6e6dd28a148321375424a49ca69100c8ca13b6a0e02ce66f1ae68f5b0eda41ddb4b49c890b03c0a5ebe3ebb9ee2618ae8e857f42dd98b26ec3f5502cf2d1e4b6580111334e039e87b6c8ab367d9d6537b1258d5ee1f58f4962597bf1e92687f1ebfcc6e1259c58be6352afc2f6de97aad8cacce7106b7ee6ce4e1eb0d6d1dd313f23108a22d6b7fb90e721c91c3d359f72687384ad1bbef7aa55ca96eb4457ec35a131ea272960d5d140a96a2987f4804a7e193de2b97c6246780978a7e192603da6681adba7e85560d22355059017f14a6f57a62c2388722df958b60a878198e5e77e3cd6ab3f1484c1527a6ea74379ddcb081f68fdad15eee7b87c943e3b89e0cd8600de7e0a773a7c8f264207fefc27840037d24b14b08323b4f052529b4ea602888c7e56412dc8d7493b56c57f6a748a9d39a3e8926fcca0aa7217f1ef29a3c6a7f4f61bbabc608caf77f97957ebce2dcef98de0c22cf7a434d95c3462f0631faa7fa7d48f42e00136395b5bf3dd12eee55277ffad8457c9a7e721bc5df11aea206b8917800a29f70d6edad877846947c794967cee8084982e9ff8fcf004900d2af9655a70df00f5a0da97c989f9f8cf5e8535a5a6fd2c79faa3db349f2926a57642d9e61315112da6bfde44ac79ba1f72c1ad81d7e1bb78d6ae73bbe2815b0a7ea3b1d34823f84247267ccb579a2504247c0578242a7fc0e65388f4bc14d6a7d8ce3551f153612e719bed774ff29f913e062d1a132e55d1df5cf87a75e2a59f12122e4f0a5d99d5a32a29d3a87ef8c491c0f63892f8da0be5d652acf0e84c153ba63972ac83dd7d62ad0e3ce3ffc247c4ba65fbc9655ed4812676845701df694b9df92139aa3069fdd8947af3a1bedfc5921a649a1c95a01ed977a5d2f9050edb13ffb06d6f3086065837732bb794d3d9d262d2f8dd5d1fa7d3c8703cc2410d1ccaa56ec4e44b05b21bcdb0ae58ad041005c77c886418df50b15e2ff9c3ef60f3eb7c0bd9f768b76f06b24723e0e4a6158faf58179e38b5b5da8be9d5f99ae16deb2642d147cea1fd8b86d808b093633921481b7e97c573567696e3bf2eee358747e7b4ab12472b67a6fb65dd049fae987206cdf4e27453b7a56398e0de2422d60630b02dfaa92317907f1775e94eaaea54cbe3991d73256e8d1731f154f094942b372b4c64b3fc62e3ab5861e52cefa2eb9093fc6525b0f5d7c238943462690d874cff1360b0dda4f267f301231a5a5426a1c6d49ea1a66e4c461448b13c72361315a3ac1c9aa00a9f083e5eb3219210d8a4988460b4d84cc81898c47e1833cf23c9e1519f1b05be02892d3f84683ddf91bcc1c9403d862a35bb370eb1be7e9a6be515340ffbf9ef0910de382712335cbb29119c6fe410e4a5c8fd308c843220c3c02777f3fe767e3520cee03d3318417af85bcae11ba37e95f12715674b0e96fc0ea9e79b9591e9f43a678c413b4e502b3c42a12bd1ec09d8a81f064f1d37c30da07d67c643c8415ce7de9f77170af8accc4d1ab5063322822bfb924341c1c66b28d5777aee021624e13ecd262bdaae58da8fd0deaa6b59fa399ce533dc9cbdbeb03619b1f286a753758ad9d9116126aebcb4e0ee02c4b7eaff15663d0ab9c137a85a11d34eacdee721ab54be0f07513661424ea0d2aa766bd321faaac3b3a12b9ce1dcafa82040dc1c92b67547e4036f263131a64bc5ddbda276c1513ec442e52e22f8d40d24a1f9cf9b02918cc6716e100f442892ea317b627277a208b11b35f40f2f5cadf1d6beff390c83305e8bd406e560c46d139fdd24561be562aa24123705121c2328b67b77a8672512163d24fe2feec1719cd12e81c17cdede1c330fb5ee265a51b8ecfc0772befa66c0a6defc93e507f3d6b7d847362c289e7aad353eb352c608cf49360dec1dc07da10875cd44acd95d99320eeb8976f91bb78d5b581bfdbb14b115e07e56ddf2889f80ff065c35e84f302f3e3f4ed8cfb2b75a608a2ce919e07ac084eb3e9f858899bb4bfaeb147ab66f5d5bf48dc807948da2a22a907f276c0bfdc87d47e3846070b35a0c94959cac5429aee246da6f6d65af7f0416e4a4aedbea7f786016355eed77b933eb907e8208e668f9661515e49b58b82110a2f1e15425681db2c2c8a5110d5f6e6874dd04a373d346035d38202cff4de4fb4f3f2fa7bd7108a4984d82b1c7b72d92321c2d3ed3bc444cf08642c3a703037d2570c89cb6cadbdaab25d79e472766604c2879bd8a76d320749e35b897a6f36393cce501a5fd2cf67afc342b000c21b8c6814ea78a093aece942c867c8420a099b0b00ce8356e8f24cfdc4b4b2169edebc47122bc045640bd0082e5bd57466043cce282a33041a921295e7836b8f975a98b45239914952389393c2128a3e09ab4704ff1024201dc799da6459869a407a9fa996109fbc8065a0dcc8641c12c8ec2fed61f8af7cb6978e8bb2998aadbd386139a22d2262d56231bd7646c31079d1a21237d2053fb8258376064ca54270bca3bec677ec4e1eb04b9ead7c25321364dadb744d739877ad7c9b38b38fe363881a77f1ef425cb37db1bdaa6f58f7aa1e1ff08aa1acf635b385f5501fc931e9def65271ea48f6fed1e1f96d3c04b8470eb48653ba532b6e3939ed4d57506329b5be149aba0f0f01ec183874f451b32c32f7eccc8f2eb5d2dabba04f2257bc9912a1cd89ce3985bcd5bb2335422f40c0a638ff7170b28883f7b5f39eeb11c58e4ceeeef83a44ab1127fa2f2bcef7a294617a50f139d4e77c91cf35e96fd8881d9c19c0e838acb04d0a586f87984610e6ab64843aa90258c5bbfce9d3d8777fd6b02f9c7a8b3aed3983abc4799357a50530732299463b0ec4d20f50dbfd67d683f94f6ccd28060596c95727b9ad5e9a453d7e9b9328c4b5c29d855e2e349377dcfc845cb04d0888ecb2994e487bdbc4d8fcfcb91a28ffa7d55298fdc444ca453c2a92ec050a664b977399880f3fb06f01605a2ccb93868af368fc2d7506cf9c59ab7f362dfa385eadebdc165c0225467d93c278194df90c677d02610e8fb9a5b09bc549f55ebb9e09621ee9a37895e359d88d3a0071d46e0157182097f7f6ddccdf966ba415dfc37adf385fa62d05733d7d79cebf7fc1739ce3e3362cbec532b74536a4a2d62c08635eac0968a0b0fdb46a871a0d11c17a2171df0fd8777a0aa7de70729467f770b410a801e39e95ec78af655f05d96c6dd7647c7c78c2409b97b87ab92940744996f27a3adb906e76094facb09babbb379711084de29ef01e6ff04b4a139857ee8eab63a9e4ba4ce486a6c82c6fa0015bd3109cfa9db65d197cb9371348c98c5c7d12d99f488042d61325140f963728cde2e48542e6df755ab849351f9df0a3339d90ea480e0948ede4151c23744afc2202393042f1a272c8f676592e0cb370c75278204bea2d2e8ddf9d9c5cb98725b5d8b44a9f862b722605b1f529e58f8c3a8cd91b2a14d0f3444ffe3ebe1ed0ee35718dbbfb18d76b5fa4f208c7c6e78c6b674b00b652f217615ffe0d9960f8a517ff446a4d1111ff2519974996ce5ce6b5855cc249979105ed65f81a2854b96bc62f7b52c4280ba8da604123688addbea187262f9ad5020247bd067acdb5de050d6e752c4a3ba3d5255100b267cf4cd5e32a17e489c7c604e5585be32987fe9ee1d5e5258ef015feaa025d5294251cb191871fee235e43f123200f8c5391d93bff86a62e1cd9c83f6746a51a5a93e5529d0c8c3af09c1fa1da3f0e92499e1a004bc190cb205dd4b43f4a468f890fe952c5f4d6e23204268f603cb684e1aa150180359beb835fdc2727d32eaf35f16ac13a6a3592ea937659659eeca70fdaeedca66b7d7bafeb87fae4dfff649194e1889e71e62211788b4043117161365068efe5e960e580f0d0c03087924f51e55e4fddabbe4f0b6cf40f250bc9e6a2ee42abfe9b435a9e1b92de52aa2ab22a90b3514e9ae19a953af506dc6ac8aa2fd3e0573862d8f44d1cf26c230dcfc19e1628fc79b530709f07c55339998b7d196984815e6a5f3d381c9bda0122f92139e75b5c457aff26d4336d436b3f7f83317535ee7ecb0de6f2929a35af5edbaafb064f9665b2940ae529bcbb8205908a9b2c338739c4266ee41d3202829878f045b8525485636b0495cb3daad2dc38b5d9652a560c7ef7cae94fa865d02475e3545e1e03157b52e0a8a902225f3df80f2f47135d09712ed401b95245346f3dffe4f4000d34450174770bf3f9c804a6dad04a8d2125c5fbf34b321541dcfde3fecb3b82541ad17aae3c2e35322884d908a4bab42571dac3faf53a8e179acff423c6d95ac45c4a435c8b9ea0100a91642ba4d50e2c13d57f16a38390c3e117b5936ae4ba293a0caafbad79dcaceca953d7cd3a4dcf4caef1ab13bb716d5b2fe5763a48569888d81ea7c7bb11788d9f354d27bd66093dd5ca6b46f5c2678b86818786324bcb154379297c3a692a9680d89c19b492d4fc23248f816b69a3edc443267b8a9bbf0b90b31ff136c963da3fb0bd9bca2849fb2dcf714e341308ea7b81e02880ae7576056195c4dcfda965868c95447a7f7b733505462aabb66f5cb77af5289aefaec57c78d75211d5c2e843a23a85053861959b4c089d65ad258631f4500e16cb6354659132e83e8c3d30a633114f7043385364f112d9b3929f9babcaf92eaf3a1392bb347d3e34fb42c838ced8c8e1b57c0f96f5e745f1c990e5174b39624fa1c03b7690e3eca5bef06ab468b60de629b4b3bfd25b646ee6f0f4ad19d47ac607f778e14abc393ae6625bfaba6ebdfc727f59cf6b86c6fc7f15c579a0c0fb9d7240a09ed41676b08ed066e182154ca4bc86f518f27f1f69e98708b01704709d6c8af8e17844646968057c686a23b1406b7f5dd4328ae4c2279aead77ab3f2d5e37fae419c5f7f6811a9af0846588c2ff79b88b817e1e970ae78e848b7ea0b5f186cffa608b89ebca6897a6029ee6c582e4d05c92b3db3a81e0c4c93f0b6b276326578f81decbfd383f5f680d7c8ecc455d6268a73808d5a5ad74e1be614a39f516fd660b8e40b35d8f35ff10daab781f3062d0a55e9069244359db71dadb1d55154a1e3fa6a111ecb292d960693216a52bba787c4f6ed1e0abf712173cd919dc11c61850a4d4cc04ff562de701146a192d2d06862e865337f006dd89d9bb28f80093570f1312989d22075655e3e9eb20ea4d7bf88390f1fa712c220556a137c2661b4d6de32c6164cbbea8f88fd2af42b3c7ad8b7833e42d904cd51859c59c3e364fc07302032a0e5575933d4c7396db871ad7491017038298bed0902c6595fa55d79f295f142e27422229729bbe7db39fdf5a4df385d249da3a38bca3f7216d3b72b12931e66dbdeb5038d9a9f2f44b50198765042c82cbc6b6b66e7145dacfaf08cf0477097508524dc48989d90641857e15d6b2e4356067bf9abc8bb48bc786328b6e9aefbda36aa3a738a29b4d387869c140aecf96c7812cdda397f8c61bbb4eb569db39d2a1603954ff1a04ea2db92646d6c7e61a0bcadb99e14a6dd4744af4ee6b9f3e67db1e8d0ddb4ae21351e1a19d9a3db68f8a58bc78373f81ac6740bde22fb868dca0047856138bb4d7a8d38d9e302663684059178ed1886a6016e46037579cfa20ca8c97e01a2361c0aef62b04b17ddab1b4b4102bf0a314155850cf8af9b6d66127f332a462327cc90f3f2b92a67a845ba385b9b44f835725cbf4f77e6283e3e4d973f91287bb4b201cea9b35cdbeee3b8eaadf47d562e9ee98b36a63ed6b22c198679d715c06b15e7523324ee61618ea9f575541d8092b1f10006e8b78405ca8b61ccd67e160be1d02bb65f6c9fb11584e2f2dd02dde5de8da63aa5e42535e03d80a34206ff1e75a651fc2fbc66dc8cf6efa9e619bb0201551a49fe4f174e0be61c0d51dc209973c731ccfda6fce6bd923dbd5db22ad8b8a3ac2e2a7f99cbaf26a96b6a2b7c42d3cd46726eba9c61732b665964c43f57ed5df9d51a2ea0e97b61806611d243f34899bf71b1e36586291ce592b8c617bad2821cc9ac73a358123084faccd2f445c13431b3550537d6db035a2dc62778914650c88f1ed2714317d50389d534efcf9025d9c84c0b20755432846ca39776d08f25af24c63a2d44eda1c4e4fce779e4b60cdc9a4c515ead33dae81be3e3e899ba6f338df017367ec8e79460e0d3679f2242129700db0f424c6fed378bca48128436800196312fe57d18f3bf42f9208e9a61fb62ad871bfeac9a7b9bd785bea418e385928672be919d1e57ef566c5c0c02b6529d247dfe4d4dc23f6beec60cec9fea2edb0f251a3c81c1dc3dbfed4c99d89058360ea3d48c8c5004dad141f4f2d30c5af11013187e6adc04d48c96542e2a9e90d49c4ba045fe53183c3d42a6da69d4c3a1591f4a2f1e16d042d337641773ddc16a3c06137745a9bcac3f878ea80264824f32cfb1f87c299d680cb7132260a8e1f633bb967a8b06728922f15566a500ac9313d0e7cfc1097d5e1e16c1ae6ef403918aee433c223d960457036d5af46b2d2f773312a26d55cc8a021d6b039ea4f5c45add52265bd0529dd4eab759f764779bfa8bb041c87323030b8e7fb002f2907a2776a5e5c74c27406b238a7c095856003dd414dab2e1f09983166eea664a488a6150b781696297f0a70c7ca6e1225eb60045fb767af132cd169766ea4d100f3b7f84b13be9639cf590f4b8b22d48d94ff82ded9ca8defde0f96b0208f06bc981fd9dd801365f6e4627d8df01cfb2a38ad6229d779c6136f9c21e8c2a8d05b31c82972646a3e7e2e1adf9530eb045e07c8a2bae0db4deeef971731600c4c13f48d71da9f8f67ab1157c94a1637961439d5cc5fd8c75ffb583dfa355e2bfad542c760602baa223c023f7b94389fec632d05b507a3903d0d2d5e7e460a0f1c2e733dbf33ac4ec71bf8c28d01994299d5b336cbf7b655cc5c0453eabd111bde539e67a4f240e7b7ec2b85db83cee1a78e6c2fd72c8589c5c65551278c2d95985157a4cc39e81b51fc68c45c7a34234fe901523d4464164ce2cebb44168bc7f02d7e0633894fe1150a90c6bb213e0040f2cd573d23039c904c037e8d879e3f148641092b7ea4097ac81fcd0d1e3aed846133d21abd7fbe213bc025bd2ee113cf0791008f6ffd42c6fbf86c7859106629d768cae129e1f15cae2dd777ab1d88d36224e440bd87a5966e0857f5ddc1b995a6d2b98163343d4cfb75f50d1c5cfcb9034c778cdf0090793c5ebf9f6d098c9cb1a49f93242bb0ba961fe027a45a8e58d07a181480d08a9df78f8a229cd9e96469e246c6202cabb56b5e91d29a624a93b65a520b868a93e75e33aa779730515b71de2008c71d8cc5602ba81a166a1f44d29a478306612202235b81d49b0e9d1be412455b0fc92cf9a07fcc62dfd07cc565c222b43a55ac840a32c0529030d222138550a8cb45bf36be21e6164828b643189347b3ee913bd400553abf1e93a52dc250f6953fc5ebd282a5d4deb8fa4ed16eb5f054479e1c54ad1f294a57b1091d720157ddaf7b2ef56be2d892b0e7ed8f00d983078d452c6ef36c2bce7abed50c393553432e0a5d77ddcaec1c310594696a845aeeec951797cb02411dc944efedd9ade28728029b7161c11daf70a046f8e9191a91b8b47e38484af0866de664a1317947a996db0d613a989dc9f5efcd0d1dd578acd068047b755b820c0f4d4c81871e56b70a4907db85898f004a1aeb673be0e14a0de00a1efb18d2e46eae0c6ea514e95e6256fa8f1bc6c6996b152ee03f63c9584f40d9bc1da67ff4dd782ebaef826657b8614c20ce6b4425b4e1dec40a8a566d9ed26a42dcb694b1fa2e0612308402ad57aeb7c5ffaa2c7053d23d25497dd017ce507b0ba51264985f9e4b0fe1780902b95f663d68bf21a7651c91bda9d4e0f81949aac8b0cec6a966d57d9894ae746a9c16cfa691dec0a288b2f7703dec940d4ea9bd1ca5a84b0e53935439f02536fd43661525ef4d345fce8f3c0f2a30d5425f35909616345d03f73cb060c1747c23b68fa8a622237038fcf66e5953fea9b49507872f0c1a410405e4935d5e07d8d460c020ceac484e773e0a5af6d19cb2a70dc2179d0a51cde61b983426288837b9f51fd1c6e524e47d11d5e460dddda00bf48af2c68b1beb23c97bd2539e5b14187e692ead4be2199cad239f6081eaf685748e42e66a0dce5a88725a722f164b89426f7e142b576de07ddb0ae5826ce0f424f0b529a0c3da5ccabfde5929f64a6096a41773238f23f644f1f0c49cd4a14db8476f611738ec5156c4a9463125598230ba61c90d0ff62a12dd6c44ef0800d588c7cc3be91986a8a95da265b984bf71ed057d09ef38c7638aa3b14cf44de86e0f09dd138d577f6e3a38287daccfca4a810c5cf6bce8ab65b2b5a25c2051818dfda9aa5ca2834ea6b00e960f6ed89a46658fb0914d4ca30aa0e6047bb4ee21e08f8eec2728087f99385c40356ef250007680b668decce00e71779f425a12f21452f8fd8762712fa618d439e45c33b7d2bf1e19647c2343969be292bf6241899a339628cb3289591080a35d6c194820d8e3fd23cdd7fce74dff74901bd8a06c8ac7bf79fdc69d11d3451ed429559e48584c4ff3465d95667e1dcacf4824b7b27e48b0ac52825f509c7374bfacf6d68f75a9c00acb6a8ac2decb60aa587ff6d5f281d28b0a411d49a425d698deb8c914619cc54cb70063ecb71d6122b5223ba22452865ffc99bf0afeead93fff4b22ace1b0e0137ee4c6c46f8bfaaaa70ac2881d7e486034fb0ec81079c2480c987c3697709f48d78d858994ef90afa2739ad1717469ecfbb058ba111e0589abb0abd65afc82bb56c8fc71b8a5e19126706b7d7eb048a96e61926d7b8b146a7305b6aab5955038f9ac2cb30bcd9f69bc77fda00413bca598ad4db51bd665af378547dea32b77198a9707c4b09dfe586512387c9e14116ece6c4a967c75da026851475654a53ab6ca5cc0e79934011a673d1d803e5ab69484440eb4a589625f189d9a7845da76db5cdcf18f71632e8fc5d6039458516c06be68a37ea49f0f3d7b72a1318d4febf531e5f10cf0865a64f8929e01bf053ad62b883b7b618436aaaf8409ed23e7dcd5b43b17e201dfebc0edc0e868aa140dcc517a1a38624af372140a2f477ab6f3ff4fee4b122665f94e21e19d281a531c5bdd17cfc06858a1a7cabab5016a1999e1bc241c334c2c3cb302fe22e117f48e45581925e320ddac6ac1d560b9bda2021940648ed2c882f4dad5ee0d2e9b3e95814914ea82ac742477568dc05a4f11fff0d44eb5731781f5eb840da51ca08bcc40035937e7f89d90b12ba045d567083e367a2a190de3f0fe5497e3ce7f4ba7eec58696d272076f9fe8d9bb1c43a0983bb3e2c5e63b190685e4f7b99c66d2c372ce8422634f9eeffe62ade06e5bb3ac877f56be9def8118e281debc26ad928be2d812a738a89dbe5469740300565385522200b2fda6eead40f998a6fffb2e4ab0af8c80aaca5bc4dab888bc32196de967f89725f586aacd1272ce6603dc002ba2fcc8e29d8f0e98515455f8358aa8a300d418dc14e4d73c4b11f90e0f47dc6ff953d44aa6b269da54fe1c9c6c19a33c6eee60e44eaa2fc43f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
