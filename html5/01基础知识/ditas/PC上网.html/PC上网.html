<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"595b6f2b2ec8cab9a5bf1085c23d95746d28363e1bdfe00a627798bd260a013cfdb0f7f8d74d7778a3d08282869d601d0d3e2920509d332eae8678ed856dca8ce839eaf59345ca7a7a4a972a47e919565c1c6ceca4c1984dfd955fd7818918798cab1498e35df7dc3af3648e178653b586f522d745610e33d718ad4d04e4ee6c299215ef962f7b452369f15c6ae65b0617825015b5894d528bef6d3921a6d705c5d77dc7f382c9b360b069c564b249c083c94305c54943df1671b2e808ab1c076a70afb3daac3433bafbffab543f9a7417786f684e2f4922fa7c002a29c3ceebec36cfc64ef7dc9b1ba566c1521cdf76397163eb5cddd03056c80c81f922a32bd340cd08ec37f00723dd33092e02f2343670b190289bcefed5d6a4d71834d370c0291f337fb08bb130930acfbb8060655e8aa6f915f471ee81f0509e324eda028cfbd654a9ef1726e49c8980e4137127c4a7d1b3a2ff5932c51f561762edc478cb380e6670a9885524093d0198e0120c17640d468b6814ef40c04fc517384ab6fe12946bca847419ba386b79a6968012d572cc0c0affdf70ca8029a1d9f8855f0841463620902ef58de9fcd151aee259df15980c69e843b63d6e729a4e9f49edbc03e146d2aee27a755fc4e6ef2b7e67e8a306b17c8575af57a2c40cda2769f556d1255d4f119d3fb348059d9033caaccf8b7d5ca484b2b3aa6a38853c67878f59130e7a0cb2871735e43664f19cd16e6ffef2961c287af89b42170dac0675037de536dfcb020eb67cbd6b61b7ab0bdbb9b96aa660bbdead3d6303d8b13956a6751f3bf668e73a21bf39cfc07209598a5f11e89b00808da20b65903eb6fe8f56a0e1fb710847fa7e0728090be726fee254b3d1cb84d1f9a0523fc47f55fb8c049e055ff00d3d9bba8a2938e5da2f73cd28cec77ee337111ae18c0a3c436f485a24ba0a93bd78638d8aff766616bbe994ce830928f31bd1a5303a3f7bbe5c718733cb8497a56c1934b2b81eb5f55405b8945365f1c7a8c7bbb22e783e725be97029142a82bf750f8d8e7965fe2ab8ce025e7cab21d6dcd772b88de5952134ac7dc82c733dac4b3bcdd7574f3f0d11b5f66d18cc44cd15cd96b9b56606c39a06ef4bd0b9a0d6626573bfc5372f8fdb915b5358581f1d450e0179c2c183f6d26be7e07296e26ff29ed2f0058aef2ae3a991e4131830b08b8beefe06090ac143226f4c4f6d47d430a2dbe204307970665c48bdf2d9249863aa0f50a9d88334f552c92cb157f2d1a5e179b365b165e80de800fb05851d69e15790b5761648e4330582a1c9313b7344c1d2fed837aee54df64c127efd9aa439bcfb2e6950e0fca1d4b90512cf7c62d911f98302d642f74e4063f90147799cefeb4b7a5fd156869b36e7a88ba1376393ee21fc0833c8a3e4cf04e4e779a47909c58067066e7df666ab059661cd2dbb868fe6eea77929948129329ae5f14906e23fa588420ade2b3860829d3c1233ec7545f630f2da3e4b8d39948b3301823cea3a00bf954b3d531cafe14c9e326139dd654c4b6af3713ab647e31d7607c8fee612f887aee7a4e8933c5ec7d7259e209dc802bf2d14310814b6446ca6ffbbe3b9083f2a886d9dc1eeb32ef6a7530111d76e6b00a4d706c9eb640a88f5182a5faf2ef5987482118ab279c6f8062c68325c828fdc912a2792029e7a2cdca6c1f16ddfd979dd1501165bed8c8068686acb062e3fb6c7b7dc7298b5b338a959b9cbfbaa0fab8ed4eab1659394a9362c2ad80b6c11727ae8b47c465071d193a6bbedd3d16d6886dc57ec5af989ced455c2d793c2e6af368d94ef09726a192ee23115a0f7ea0db0667cb836306336f5ff5313da9f20bfb1ad5e7fbdcac1d9cec76fd697d44558fe090938b449c2c1198baf8951b919466975cdbb8b767414a056ef436a957f0ef90be72a6bdf03a741673c6b7733ea489d1bcdbb6098ad4c1589b89b70e81937825f2899b8ed40b46e7c1be65a8dc27ec410543640ae197180110785dc7cd5b99fe26d702dfacc4cd372ce53e0e4aaeb2b4c52ec928f3af0ad91252d9e39780dc976ea1dd986a2daf07d32416177ad7e26e2b10cd340cde2a2fa78db47c2afe60284b0aad0ed167cd0627e1b2be50f543c879837f4862f5145139eb6a3732dee78dbab4016f1822d263d7d90572ad541304d673765b0ce213a4f9baf838213a0d8e0754fe7db9431b51952541d24b00d88c9cbcefc8c6a1ba6261cadd2d1112e8802d73e815d259d763b24b0a739f7c70f27d9c6f59318a2acbb1f9dca4487a1229e79d024886aa162d90a4d1fa16d4a6a556f32e1c9cd8ccc2e9499c92be69b6d87b5d876afb7aaf5f1b9507da7bc5ac56b6427830e27745394b353c6de6839257411c2d2d3ecccc95927b805ee458bde11cd941bc660262bc980e561e0a730e70fe5dbb15eec944434b8944a8231dd0c2581768b04909e6b108cf46e7153e8d596e990f2473f0f32a49d9f668d6dd5b3dc69a80ee1d4ea50bf81286c0a0e818ceb95bb1ae9db183b467b28c8b57b4462072e51fba4a09014e576b966cce4ad391e6bdad3a995c2a54e2cfdea6a84b2a5c498c2164ef905cfec6e3b0ae735dd6e765988c4c90122054b2e5b6cb1ded3ecfd27d0b6efe06b8e6c74ffcbb50217c672c8f5f9f73e0afa8259878719c1e8132645304d1e5cccf89a47e046abba7b9c1c3339545008a029d67bcaebbe526a2c9f75803642378f22510d3f882f60600f052fd0065fbb75e068e119f559a74b8d295df5ba575e3dec0672da7728ca758140c0b5cf766550a1476d672ba5025e9d282392bd8da51c130bfb24a1f8c3369fe542a28df85d1fd2c8a24520f3a5f3d9bfe98a9d8e0d49d44be605d8977c2035cf8d848301beee276488cc7ed2737b2143b63adea327e1dff087ca5f31758b65afb2ad13ccaba6e493122517b7149bbe1af63ccc0f3c2f68dbc296caa88069cefb96c57e552ad0594e5ebf98a6cf1a3dcd02bdff892a898207483eaf5e45b2b4e76d5e14dcbd31da4282967d184fe1c3fb8063dafa3db3b4319beffe7f12836833846d0d756ed48cbd91572912eae7d1bb75471623a248d5b44062dc17ee50e6efdae408ef82448dd80453a92da7df1f8ad49a6721e4909de576f1e8474f17f4fc7ea425a16360f89e440d0990e415fbe7764d4785459a446586c4f12c52a2be66bf10533973543c57dae521ce052bc3bc6a085189a42aec2cd1286605d28baa2c87374d31a4398f9c2055fb5d1361214b48f6a44a02242eb69394f23b99ca7a49db00488cc4f9e50c78bc600cc7eb58f6de0b35b88d50a00f876c9efb165d1c27c82eec40df8b56b221dd07a2d9bf86e8da0e42caad93df2b892d6561759ac8440cec78b1d5bde0b41eca2a033778b4ccd3e3bfed602a8e463dfddcc32a916cddf848fb6450703cdb545c1dcde54f055f0ad198dd34f28b8dfb2d85fea0cfa65d34288fa3da58df05ed927a926bd11961b0f9539ef2adc3fb0d34665877e7c0064aeeb4b93802ac206afc82aeb0e4128f55ef7802f95e025043453b4f2a9665cb0614d730c5dec9ebc7b2298d6dc9a3a36e7a6301a810e7dffc129abc29adf86672c8c6d14b18a42bce86fe498a1fa626c11e20bcb4a46ad2c5a3f32016da972cf9c8a7651a650d8791e1ab51214dfafe888e10b185bd3fd53664af3e1f7bf036f18dbf1a7cf59ca646b8000ea3d37d3034c84d430bb4016fd802087fffbaa3ae45617610e17398d4ebf4238f3efcfb90f354c53630c37aaa4a7f6d1746b1b9a28f17468ee50ac82f113bd7c217d509341eb2ba5f8e9a2adffb5f7590852130788e315effbf8ae0923e57e88b4856ee909755bebf3eea51716ab953b8bff4157c0312635e8cc39fb32af20fdc8d2d2d8967e8d12983558c7b325d8819f78c1da71725fd9d569bf785f9a28fc4765a480b558d459e09b966dffa4ffe157d01a2bc34d5f21ad38b8832a17babba180f3aca92530e1dcac80e2199404bed3e21e775d95e1e9b31037e102f0fd4d4c84896fd18adb88affb5e9cce9081bdfa3ddc7764872e00a8ae23c56b6a2d649c3ecf1a0dd3be4c827d1f3419a149770a462cf03f2fd4bf565fe22f6b2918e37db36c97ad808755edc92c8fc371fb5d107b6b6f4163cdf41024358d9be92d56647a77e4a2b9c0e0ba401ac9b0975fee576574724270fa90cc22dc8e5831fc1e7ff04fc7caf530a0663253b3256686b135d2db5b77110713c96d3f58e302e5d77161f6533debd9211b8efea5408b506c626c37a93b005c128c19a55c26ad81c6761ec2d6974555424dc2dd8944bbd7e5e4f40f6544d2caa83d070c75a7bb9ce7ec1dba1ce4c53320de259efa0c51c4ad3107cd2bf5e3c5592997195db0dbcf1f373208f0e473e0b77203e134255ecaf5b60e7095f8ef36685407e0fae049ea245455cb0d01871ab9940ca244b1d589e29ce468208fbacf586cebf4f5cdb4c499cb576ca222139821a5ab4ac7a7c37770d63cb19f93a583d86cd5c97e0886ccbc7eaa3d48ed97dcdf2332c522f6b1ce312f3c32529efb25701b119878e4e70a82a7a199536af2dd49f37560610d504071c590ca5575fa07ee7092d4f088608440f7db37d45d260da53b9f7996891b70bf3e2f648028b78f08f899205c8c2e7fe94757546d3c632afa0f59347785f9c6bb6e10c3aec0dba68cba35a2c4f12e0cdc1e19e4a1d03b96cb9d4fcc909110dd91ec7a41126e9d9515f40ee866dba5e74b7af9e7f1646ce8c8871d8bae5e234e033d87f01f9fbc77a47290479aed915d990e40f59fbbddfac860a88ebc72a53bde92b7ab7a2cf3de42ad72e612e54776232bcaaf32daaf7a58578c10e786517f55d3fe55be1c57de6829b316748321fe22bc6dcb3418e3249efe3e227a7a0c2dc6a695d53794a850cee31b7af0c8ff2ff76325196a2e4771ab41f65868d75a7c3d39ef0e0c813c7602a0580dbe4242d3a29ab12e804e175496db3c911d07223692b1e397f8bebf2a77c6409b4c1cf6c93180ef29224a67dfd08a975d25fcdae2747e180b2ec6a0b790a4a2218d86263d863afc9676eb85e7f1a386eb93082fc408513141e04b3c1909791c519aaaff21cd0f7c6b35a2d2bcfe403ee665b056a0656bdf060d586d11f2111638db55fe8728563147e9dffe838b5525aec3b3a347fc00ffc729ca5e6cdf4030d257e7186d7a457160d636078b825982f24cce77ef65d7c28920811f927d2c110a2466088f3805933c36f890ce3d7a4f148ebfd9428e983e523673d8d40aecbfd0b6887d6df152055cbd80792a8f39fbb7064c7a17796d1304b45012c0061a7269b0cb61666350127ca7b74921e47b7887a7c22bc65ebd0a8a1484def19338163d14cad776386e9cd94f14b576652fea924e7f1cb68150c9ad1cb510480ba63e7fe94ba0791353e7a646da204881998c1b8f54e8e5278259ce867cf6440def9346a9204f6d0ecfc640079f04091cb7d55df27ce4eced13a1d597c70310e59829050762734234a136da85eb8f6f9eac76e5c723d7440a4d292b7d9b49316221a2603cae3ceaf43358701ee3b23c91c3bc935759530a2e9b3957e52b93d8da45b531b7c33be46c925b4ffb5bd13f87328c02fc62502c64c4a279a8b034eb7bd015f43405f8e18701edfa3f0fe5beac2b79141e2eeeca9c094ea69f8a5088c4a0d37131bfeb59d76d99199539b7c2b5622877d3cf10394f9cb6f5e7e2cce24db668e98705b2a6171d98350f6e75ed9474f7c42102b9a5f5f7133068943aa059b00ec332dc70d6581af6a2f067a823732c2d5e3114770d37c0f5a3178e194cb012a275345ecdf980c5798b54af51220d22176a99955ce05d71c4288973ebb56e2c19ebaf00fa53b0f1393604bfc0051e97c69c615e8742e1bc8aff891988585351bcfc3291911486eff602b2a54f3ab900fa648b4517248a26b432167ef8b5cf24b43cbdf7d2f98939138269f2c37c6f0e85f279ff9e528265b3074e27bf8aa10789a7ab6867686defcd471700a0968868965a602bc138ffde4a322f190e1612d7d5be2ee09006e32a96bfa5ab5c8de6b3a69060eb41f8614ddf2023410be5f29893a207887b5e80f8df239190ea6ac7e9b04ab1deb12f1b159f3e89e85f47b2770d0e2babae7ccf3f0d28fd3ad1206cc23be248a87a710920bd222608e83a144671c3f42a3a99d88522a54cb77c2bbf3958a9f4b9b67d005a1c1b3b1a0838a8af4a2f3ac321e1952a29157bbca54f0361114bfc901a8a8d79efd2b0f8bea54791a443c1700d6b09a6d2945b42c7f8bf92491fed672501674eac419be8df2811e5c73728d929fd377c997d5a8099b14b4e0ef6fbc35e73dd177131dbc991c2fde7e940f852fa1ab814166e8158cc497e8fc832b49a80301c3740bdb61f16df8949cf394e579d043c74e769a67e0419405f87faa7f2ac28a79abd46b22928162aa706514b66c18725db72fb0d3286a0a078452198ec861db1d8c50bcb1448d3a080bca848723623857a992d119946075f87368c037972d2d8f9bfa75173334be5c1a977dfb0377c7a78646b3bf038f6b61780304243fcb1a4a6c67b9250a98d76a59486769afdb50c7541273fbe91d0ea109a720a2ad05899d9a133f87e70975a819ea1f1c4d0bb50ba1b2b9807d685b4d34172c90dff2b6d6d0de4097cb685901ad5f50995ebd0e9a23ce9e0c81a816497b6de37e77e3015fd45c3dae82687dbdfff4be0497441bd1d8c83720d0830ed0e551079710e10f86c9af54dd461c7b033990a50930aa78d0e1baa615ce4e127b991cd38cf84af7355eb223f7e934c9011c034b664208db480516849a3b2c1d1b6308706424173138f656034784f1c780913cec19103839c46cba2c374a25c8e607ba988b0346f2cbd29a3749b80dc404f7388cc6b92627ab19135f84ffef5c8bb989899ffe68ac3069cc3397bfff89f1769f1662efc4a053cb4f531f86126c147c857449a2ee13f12e8535019e3144183bf9c569cc6a519be7d9ca8123c4aafe15405a9399435e51af225e64e1b16b364f4d007128722f0d5408ac20bec83169fbe3433e12b211b0079399b7d30474d85763ec57eea2b9c9f59575d2fdfbe94d3339a5d6c004a94cc44c85ace63d17b34018ee2364f6882e40eda30fb7f2f419318a7e1563e7311475cbcfffe1fe1fb4585d90d6568f7c835a7e3c4b7d586ef385e24606f56d44a0bcbe977768ba0eb933ccc10e08bf1a7fb08ffbb7959c73487c0234bbb5367be2b86756b7eb3d00fbdff43ee081e6c5bd46154a12f39a9d834cad1a22821475619199ef7e61dc4ab93210c885318c9e9da3bc53673e189aeaf7f466f65f2c4eeee545d43869d3060c179181530630c1ba03b6a1de3d9a16acffe80c93e70f230a639b4258406457d357fd27e1b7c4365c6bd77f55d6dbc88c917126492e8072859695a5b60a2cc9f68728a964d7c4cd63afaeb5728bfb92012729da84ff7469ecb48e50f67746cd25c5c5aa445f6edd8650c734b9be232e1ae4706d23aa6b8084c14644fc82e0ac0ad626856d21a789e75579fe8e329b363db00e8f358f3a91e3924272a6e97a95860bff1fe9a232611fd3ff4207f9243d5c75b5aa636262edcfc0911af23f4a3384533196d7fb19f17a9294c98300879167a358f22bb31fd2da5617f476c1a51da6ee02d8db3461bbc328d2200aad4df88e202db761416c3b482efd02a7813162b70a27ae7de0dc8872a2544cd33472cd1482a986c1c2bea82ea27ea7f24a99c9f3e6c9e61422d24beb7d678ae8b26e81a82efe4c0284544388e548994b7a0636d0ba451e8287759973b874d1b7395e2c554a001d3d5f3b08d0e63931487489e5ad2f26b4df74ec0fea92692a0e6ffdc86aaa1df7aa21ad29c12af3b92a313eb145da24d977cb9d03b507ed640766893f9fc237b21be67a81c89020ae1784a873e4a48a15ab99565537d6e63789de496f8ddb759c548b9e586fc88f95f1fe08458f2a8fe3888517704cb0a8c3943491dbeb6144a82fa85f1eeb9444785be7b26ed1b9cf84f88507537b563be6c1bbea53617faac9ee5cc8a14f5df596c16f82629deab34313b65686abf216b2db38bf8941a6d18ea46c8bf37c1f61644c6369a08bd3256932b303582371436da8ec898c164d6126f5a3927390dba4ca2aff767b2d25520ee3d4573c6bcf42449603fe0d0098239f80614aaf8a14f841bee321133176f97b98f88deed33dc7a7991f0ff77abd0b7c654099fcec6d8d62efe47146aca0de502a0e9434d7d7cea7648b4ff09021b745f7488ffa1b1be61970b9c3e80d63b16a6e2c4b3a89afdc10449ec03948a6e92cd7a2b875ebf5ce28a7c7f73c88bb0560d60da6f8802742cb8781c2650612e4ae746c8d08c03ab89d729929a0f7e7b2d1a0feb422ae5c2a92055eafac69a3cba09dfb7cd70ab18a811b9f1f2d96db3cdff40f99492c6fa09af098b78302b6a422bf735726b0d8df6e6550fe907e4bc865306742b2c5c4d3fcf53ad3b67aa32f8eb451cadc5c5e657a4ce6cb4a01e7e8708ba0aebe7ffd99c4b7c4a11de9147595c5c018ad230fc1246ffb5728bbf2983bbd3f7a876c5fc5d3c3d01420bb840c0a2ef37b5d3fdc9636b0dd51e98df29d957bdb5f094390ffec3ae2a93f62144a6ab7eae9517e2f969db257b8d8f253d6c360f36da7d1e503e687237576f1051b87e7b9c643e90bc8b718d5e649f6c6aadcfd33790cdc2c558b5c6f5db4cc4684e3768bdb6a64c5d7353c8c0d5681c0dfe139a937bee4f1f774514afa04b16f2346852e2b5bdefc85658ca3d1ca2063a9fea5f8c903d72ebc4e8800d3a878afe352808a8681e209b966d31d2076150951975417a8829750547c44dca297585199bfbeb099d3236a5d7d1c4fe04b68a9a7a290dba0f0a39d24c15d9080553e57144564c66dd2f8d98dbad4f9458a22502ceb2a0cc817f0d26bde4a3c70c6cc179f487d039e6d344d617fe723c071ad469b6923c865b58cb1399c3e7b488a5c833ca132f67c01f309fb7e535eea1ca4e9eb68c1a73200e6886ed36115d3c02e641b668ea3ae3a2cadbab8e6a83689bfe01ce14d1d2d49dfcc2cc4c8902a6011be43780816ea5ec5c55f3243b11f5e8d56a04b34f7ec1df99eafe7a0f478aee7935a95c3057c203a86f6651370944d86223ba158ffdd919c40e856403860b9f8c003dc43a1a79bc5ef04e272029b3ec17be762ea5cd84b2dee4cf5e556f8f60997bb1447af40508b9aa70483c57e9f7b3e32da650cb38db297f6f288881cd93fb32f1f9dc6668ea38517747ebaeca70f854e18580809eb6068a6246ee7e422a424bbb538489f7a0edd8e9f4293833ccc716db427cfaf0974f0adefcee98f14518bc8f641436c728f69a88c0c0f9ebe7f30d8afba2069cd786f84ab3660f4ae07a72063f4f63bbee32d1c4a129031b563649b3a312328d129dc27d83c1bf8a00d7e760f307fa8ade10074fc8a714ac21cf4c4146ef3e27bfda50ef6bcef963c5a42b35f8da8dd639fa983a410c2599fc04814dda1a6fae5471b64ffd083595d62d8e8f3b37f88dd9306eb8163ff4d35ef7a6e7e622fed3682e8e1e0c1649e5f1e9450847ec10ca43aa2b716e4ca7874ee45c341eb154b086b134047effd41e119b69cf44aa06ea369fdc337483ab7625d6dc4ad7544577adcca2e448c09871c3b6c9e1eb3504e1fefd5fed38b9aa0d106f34b065e40dec6300f957a3139153f5fd6febdf17ce6acdae7a0fde3329c1d8dddbca1027ad44f63e56b8ba0a87ddf572afd9101b6c6498dc0fc97d54565332568d778767744f5fe1001bab77a35a2b5aaa440619242685921d5aedcdb5d1ea6b246a3ebbdd8efd1f814c8a5ba10ce4484b00ef73e0ba290383b4018507e667da06e113f961514839628172688f9578af184941d2c6242382d50b76b12a32f500d01b91dedbf9eed54f2152443bc50797967249e6e85ec970db51b2b229d1003947c06eaf6e5d0f1ac9b3d32134a73f053205f1648a7a50b1c7df1f1cf349d594444193ccfa462e72489f8746042ab0e361281e7c24d90f69b0dc87a8a99feeb46f97e1027698c3d9b0d075d04d3f1392e6ed5d6817a6ab9c4625ba4679c62f4ebfa34183a36c0e214a0147805d3a60167f4d4a1a4b1792b8fdcf056232ab1c2ebf89948bc6ce404f733666e3d60072bcfd0ba6d442f84a28cb4e3c7f9c62d8781b011a8c0af0c6cf401bd2999019380646f669d943c8904ff70159e99d656c3cbfe6779a22c35696f90045a0c7fda7325f6daae326d68fe7e6926697ec31957f1c2468b2a079750bcd77dd63a7f83f4c2a488677ac401ef5a31112a5fd0457f924e8105ed66c58e42e1dd5e86679301df4713b708ba6958aba1f9f9648af0cc620dc76adf2f98adae6763192181e062f22c0a71ba99768c32628559a86eb472b2a0675a6790ff5427039608367d961489516fa633d0f893f0fbd748c04fb3516947c856974a3a98afd1df72f8c84e44ec3c1dca00c63d4545a99eace1d152f4fecfca4e974f6e87bfddbd8eb9996b6263b58ee4000848492de2a8c1412e7e9472f555acee39107f8ffa016433934d89d320e3f18d8b8747f27d29385091d16785bc34ea914f945ea099009a7eb7639e08ab04e7432c1c83ac95bf38d372f51e291cf804bd8d9827ec37b7534ff71a9eddd61a9fd6d4ffe3ec35ff0c971ca382a96e80c5ba97d5348338e9de2cf62af7bdc3eda0cdc32db0a606f27241f89b0f86b3b97b47ada16dce64c48e9b9dc3a5a3b2b8674e414426fc049aa78e61c141d7072084358a5bd691965e54f93a5b35e88020d17f74dd74d4bdbcacd03a3fd23366e7d481728b7391e0bc3cf559d3c8db2b0c141124d48c4e6102057c501cc9d1a6b37f887bd54842d046336e7a74662c972c0093ab851dfb1eb12619d15159742dec122d7cc0bfaf0a9fcf4570f671aa30b1372bebf7d034ac6e756827a7f4d0edb8c40ca62f5844433db6140d093de1aa093a815ee1eb7ef63622efc26f682499f3f59bce12dfc369c3ba830145aea4806810997e7f609163f945a1370640d867ed754f3b53135c2107b504cd6586d27dcb90996768d21c5efb2263957de75d9836be48a5c111a4fd7d797ec6a993c4fc31e8a4dfb57b13207981e620d28040b9280a06821bb814f46035939aa65e91033977e833038db3a2ec338ec82ac835e18973737e362bebe72c20f266d197727fc51f5a87ce702dabe4a75fcd6841599f1488445ff90201f1e952e0bd813143614319ce091b020230d1059d5262149e8b333146dd90cc36f5cb7920aad3e91c1854ad88d6c0571792775327aa8f064f442b3ed4243c09a9cbffd85aa19db0a25890732feafe95135046973edc9919ade3152a5df4aaa2103bf009f3ad68756b15428f6dc1704c7b53a927d5b1478c4c6a4de1d0947412528d3e9c94352466e6e550c9beb374bf103de73ff7851ca6b36802a7051bfafab57668c2aa578611e84f4e651cdf7b19da25982f1d125f416172d11a07a3d494eaa271c0ee456cd6b11755f047109b1fdf9b8e6850270f4d5b4bca7acb82dd9776cccc77b052640ea1d3f24d3c4afa10c3ba153ff2933600bf972580e9d9ddb604301544fbfa4abf4a9a8f6a10cad3fc52678cf37e3118ad24a57b0a2cd4416e0c0d8489a9cc4348a51b732f968e75f5f5c5916776dfb8e89d7baf2e1ede6f933dd7030854d342be9c22aaad072e1419766ac3110380205557ee85b2241171f0200b0bfcd4d215af25050d5c57daa9ac62624ff94c9b9f7796f6b2bac1ff580e965700721f18b886211e455b93aaac7d6482215fa24eea4397bd896f4d2f9ebf0a075a7d3ae5e07e739ff76740cb0e4ee420afc24408bff062e88b764c32e111f8114de705d210c67337276af773cd4e261ad63032925a70973bb960e0f2cc24a6c0a48b03e4f9421877a58b941befa921fb624260bf9dec4723484cb0fad31c3981c4908b1d7dcb50a626bdf8919b3132c4e93858358bec97a20102b65779b0906eeb6c49c38112efc084e965a14da59a1a4430b7e851b9116144cf7da348d5f5610325fc78889453c29771ae4982b4588b448a0ca99799c26ca4b86a7056777df2cd91a8aac2fe3dd19f7175341ee87e7818f171d286cef51c36b10ac6f853b345654863efcdd30d590a00c803781073b9b51ea9efe705d1a841ebf4213e161d6c90766fdb03b420a3149473f0349ba9454071d231c697d078312b5a8229fac988370bf735228b28756774777bd4d9c74f782925093ff6d606bab14080328673b05a7215ff9db1a6ea0acbf4574ea7dc5d3a866018fe83ffdf6fa5a807607c058c3f7201a828831f336a35ab363397418826126c0d8577e3c5c03c5a7f8e50a5847ec5039b56f449de7e4119088a6bf1fca4f9171cc43131ebe94ee8e0c7f3f9dff25507f6ed1f2e9ed64b975827c7a3f5dd3959a442c77c4db82b424540691abce5c289f3f16044b7869b30b6002c89a540b6e5269c4e37936322143823de81b1d8524a256d8389684099dc170f88827aa68a09eb43fba8f914efad1cf21c9e6496e59e53c5cdcf0377d4a9d96d070050caa35fbb6c7fc55c81791196fa4f9ac5f27a94f613198e72dae1ed08b8b9297fd7178e47095dbe656c2919de2999f0098b7719177c6b540e0b90ed14e559e0df0b19092d2fed2417a8b43ee1cc8d222ac839458fc313b778c8e006f6faa30b25a1882a686a817d3fe347bd544c08262a606818da91d8e82d6aa96d08886618a9ac197cd39b2c50f09b1ce4e9ff0f749d535f9e32fb1d2ae72d329024d665c30816d0f70ee49cccd0fa8997edc545ee23c7c8f59002a6c831ee73b7c7706f1ed7dae6e08e51f04d1f0181d69eef2e56e769ae0e5a8720ac7220d03333343bc37ea60df4949fee0441b5690f89b10a0d2936fc14d251906ed6d97d9ff2108fb8f7e9eec3bc6d90cb464fbf5597f0e8261d692189528c234cc464a3bec30cf392313ee5a91a45d0b9c899d6f0eaa7e67ebb19d2d5225fe8245aede393dcb522a8d3df26b7b3faa46ca78ac637a8b897c1be83433534fcbadc9dd99c616e9320daa23b58c06a54a7681911d5bcf5ebe722330ffc8aa107c82640065fe8f6d565b958004ed030212df252174104e49c466201e3c32a179fcc2905b9fc387a77ef7501121a568a6f1effcc7a1620a43685bc625dcccf2944b40bfd6c0794ca23579cde4be93f5cd3f4ce6543390ee83446eca8e5b47f8c9fbd4a53fd2d5fbf406bdb331d95a5f6812ba96ac78c933ff7a846f20271aaa5a5037ebb91975de109e91003919755c2886e44b18384e97095976e518ca52a7dd560634c7a171a1f706be879d9e16fa69ba6b3ca9f8fe37bd0584050df616a143e1b5e64c7f904c632f0315a274849ad38dfa42d70c5821763402ab43cc844c014e00b0a9103019f3f80ae66a26a923dcc3caca67e3b107e8300704e50ddf8cc22ea0202882150a09b1ad3d2900b0559c7520500047e15697d21bceae5865ee9531bad8ce4899289f67f282f632277cca0f50391255a36474ea93c0ed2a7f3e96d82b8a37876b2e9e4b38dcd382a387a1788e2586c2524b0a909b9dbc5da4fb611513668c11efda63dc3b9019e32f62159df16db04a51c48db0288f681674da6ed88b106c636f28ebbe843ff92e2f83436e9407bb2b23c080bf80b0bb0899ecc8b7ecdc7ae36df3862b8f06e33688b6e22f02eb0200a46396d99a426992ce43a0d334294213f2ff57c90c572cdba2e5f8fd2f6284aea246f6e76e5d561f28b48aa98d3758ee2b04f8600cb7a7b35ac8c7d828f23fe26bcf863104f318897b6dbec7a4d271c413490999e00c97e648d30c63e667b547cd9b81c810c1b461fa6a1d0cf3414987e4634d58bb3159766e424efadef5749f01a972f81adec81256150c68f5efd0452bbe1f75c6643cade843914b5880c03fa46048595085f480c99786ff1714fcb18c31711212d4d740bf488109d894dd2ec0483d907dde78c7676d5d90b2ff532c315989a6a9f6bd5404ee2ab2b90e593036260949a7826b6cbd934d0aeebc45b5b60b3a7862b3a57616017c685a38ecd24149277db0809a993fb627881d1bdf6d44a7338d531a4ff15df448e5c8f716d8c19e9fb7c01f5d85a5886863598c264b7489672dba3db9d573ed4d29c5517f7ec9507ab41848ec53070104ee46034b4721c650cd0f2862cc0dccd6e93431c62b1d8066eaac432a16491c222c51f99b4b5a1e3d74fd34ee8a2d10a95d87fc3d9b470fd2159a6ac45c9d73d64dfcf0db196b990e3d2e6da865a4f836297ea756761ad15af872e55832d6d3612e876be83d428e72865b164c69a6942c09ac1f8b6c39e1ae2e08e1d6cf63dbc0b068bb35ab18b33d124ffab49a24ceb9d81638be199d200af2a7d5c94c8f12c6280adff7171188a9454bd2edcaca1d12884c600a76c122f41a7e0abac3fedd75be16b6364907cd6caa9df30ca4082e767e83776567e684df32b679d412c6fd2274369700bfd010d2e187c003aa754ca15ad6f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
