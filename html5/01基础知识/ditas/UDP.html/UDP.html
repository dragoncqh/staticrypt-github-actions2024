<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f271b698510ef8438bc26df98c30b5e9c761a27e87f7c075e890327124e4fcb542ef2ff703834afb2952a6260932b80cb127b5a3f8648bf1436a76c28b4dab1a63057691b801f880a541052208e52347eb592c8133a663c8642db3641f8250889f7c8b44af1c630234ee8205cbe896c03c194ae13ffeab44ce25b1b9df490a9db4da10f58fc8112d3acdd0913c24c9b37c5e5651ed890bf4c480e402c83b184f79a0f9f4d9aa04b5c6003986c963c55a1f9efc99184d5c5e622a01520f65ed220ffb08ec0abf9e09ba500b8f17ddf91da399793ad4a366b9e459ad28cbb99f9f256bd385827da74ce8ed2a04a50452443adf80dbc1b967835cd6edb3f83bc9a0fcdca086fc37652937066dab8f68b424a94541d0665417df9a4c916fc688bdd6f8bc82a8afd9ea550c8f5c86b7c680695f47df2ccb1a24499f9efbdea1090f4e725fb29dc425e1bce697da069f59921c45c0ca802b1f0de5d065dab9e4dbfd390c567f2b4a1c4d26581f414b90ae01a9c59fbbbf0b1aefbab5aa13c6ecc7c8ad2db63804c1e7f50dae4fe5443d3d0afece8cb05b595c42092473259c42fe245aa44656cce58e92c40aee071a042d9b19ad41d8cb0f9c2c4f98ed89c24581bca2ca259f9ef5b74b849905fcd50e4cfc3ecdd8ef3c5b8839ceda5b637cb2ddb6e349fff4ad10c434f3f2a121603e6bf17ddb82d9eb95b0178d541a540f6551b0afc271c3ed5c4afa9b0885bec5324e6cbc87adee4b31260cd41b3d031fa214d63e6453de1dd878bf5f9f0f68981f500f4b3aa2da59e35f81461abe2d4d986b6a2a46226fa6deccadf541f4796f5c041e18a80d9ce31575948e07df42b60604b6c7b899f3a1f62a3f1135b65d01c8bf2f7577ed678b72177a3b67ec988d97342f4869023555a9847ab9cd6664339e12aaa164abcd0d5d2fba3b7035c9f342ebb7e2d9d13f454d6c00f02e53b18e40121fffbfe244f81ae404e8283949c2836dd2533d66a1ff0d69f21548ae99273581b7296d3110b6e4772ef2322aed8669d611e434e2f28d799c6c2d9d40679efd872ba4294d7638534d91cca616910d89a75ced54b32ee858d05c9257e19ba0f9b714bbb08926586e2d622ae4a9eda836e4555792a94f0abc84799e9853a3c4304159991f23ac5c8de1e48826c1eba77a98d2a8dda7eb6ce083baf41b00aa68dcab415f44f9ced4bd288c416982d89e19906a128bcb290a64577ed9e6a3cda3f3e69082884f9aadc9130023eadcea168936b99c88c86bcf77729fdf9e82afddec96f31cbcf0d53ac0d90c6c289103855fea31e256b8be67640b07256fa74a09d49d36409e1c6a6d0fedb352e6ac132e7462c97f26c57f71ecbc063c7e0cc603b1979e2fdaa38e6b00b6f9bad85de6c690a6fedd9501c52537706d73c3fc99b0895b2422c91b3d0516993b21313dd89921d1326c7cb5fe4af075151765176ac6ebb484e95d9c4cd4efcee323b80bbd2e9fdc4f60905f37aea604fac1696a3ee1de09f9285ba582d3e3ba453a0b3e1f05871c0192cdea1d8ffa6f32931573f05316d70195845c41a1f75559f4ef173123d0254beaa2bda7637c59a637e18a931089f1376df7a3f669bd1c1dd41356bd6f7ffc647bb202dd191b8b8db2ea5e6afc7d9403ace8b28e5cfda2df06e8ea6ee7815161fd3c06f60b1261a80b64ffd71b1a631ff8799c6d9a494ba6aa221c2ababdeefb35821cb4b0d7432801289afab8728e8d51997c8ebe823a517843bd6db393477b26cd3925ca4b626dd6961d8320d3047fb1667ff765842160bbfd5adb0190e2f16ebe41f5c63c9aca7193b6288828ec9dce4af94f8aae138d013465c04e0340101ed124cbecf70e3864bbef747cf892431745100581a13753409e68dc9a51564ef6ecdc8fac042e39a5ef7c7491ba4174da2e0f518fb673ad69cce8cb85249b2fc35c9688d9b0a0edb81673c7ce14bc5842d085594bef9d5f60e136dd90ab6ea4799c375017d4ded019f7953a86a8675232bf25a0103b8999892e04e0d574b6995f0994acf29bda43782796b818d0f89c2fceb99fe298da221bb0abf3687a79b363f4ec74721e4e162b20b12d95a83908da1d2c0e249f5a29385113b95fe65caf053def478284cceb86624ce9d21a364ba37d1d8357b8658ebe4594b3445dda695adc98ba105003202f90790de67ae1f118bd1399ccbf45969a7c2a4999ae33ea7d20c29b99af9d0abf5b72e53f5f9068a3a8fa33959b15df5483dfe0abf97e90750bdd4cd50858083aba8388765dcc844d36129d7b2d6e4c61fe83dd06ee1d83be80b3b4871d97ae92068f1a68045ebe482ba71c326733c977774e25b78c48d11dcf4b0abd9cb8dd2db696dd69669c511f8f4afddb6b36892c960917e695cf75497b6ba471e54d753883c083c1cee056738bd0ac963b0d93c06550300a4aae13ca0f708621d6355aafaccb4731f1dd0f07bc7ebde352a918bb57642bffd97948307aef4d5ad231cd27fcf3ef1e2329b5d430b183ea4844f43fa408e23a0073964425cf36395693803e6377f1c8a88ca859e20589174ab9686453685cfbe1cacc9cb4b758a17cd54ee5d0008b94e51f2c6a010fad7a84a0da76fef2a076b89e48bb9e24cbd1d7378252151cfe384246b0104b1833d8f71d723110baca59a5d1603fb124ca815f4e98ac9ffd0b6b23e43459d0c665e4815af79a45c14da6e7e2677f526436abd324fddc2d8c13f7ca377dffc202d214d3edb243e9960f12be0a97f60914a2f02630a5364a373c515607ad73d0e03d7c0e23418c77d4585f0521672bf4f8835aa156c1981226a026a64ef26649c88c6de94918bd1ee458caa030a2d03cd299a0918fdce617b442def2089d2c654ed30d17efcc4c81549edce7407f83ce6ffdb0f13501ba1736764c875f235f7bbc4f3108abfd958a1ce082df14abb10eb4dc10991291d074994a878104dc89a0e47bde3475e0075cef4efdff8b1bc48d08892e3135626e8b90770a2804efb067920a550507e1e8a1c72c3683ec21dc5fd642cf440c5c06a24a3e2cf5dd0d25aa3fcd1d88cb79ccc7ea4fccb4684a0da19e7eac694e7183a25f1111ff982b8a644a18af8c26b4797e96ff2f513fc9d95cfed667cdd113378c00dbdf07a472a7c3af5ff65e11e8f06855ba13922dfaef05929702fd28cfccc6eecb8b3d0209fe00cf6f364ada50140a60f544d04086987f8eb95ea1c4e0d77b49ac2611bc97a4cd52b3005c864c7ab621569a5e9ac48ccccdd96d0658652c0f88b192f807d6499a2b49e7e73254913e449daf94df218e7060f221b5fc34e095351cae8b4677266c645aa7a4668e60ced7e0711f75ce2fec89aff1ba60128704c11bd2458045cf5a1b71b7ce7485f785eca17e8cd6e60a18945eebfdfc9aea0e0f677201945aecfb9ab8952fc081a972ea1a6a47d1a6edb0fa549b196ee0e1c118ca6ef30c1a06b74f3223e6e9976304cd30821794e951fa1e75035ea177125e364a2155355da44d57d985fe4fd8ad437a0fc464521fdb909da721ab562e44749ef968bd2b4cec220aca108e6ef27082c824d3943bfb24a56dee43a4ce7acd75425bdca8ba7a6608ee554fdd8510992367ec6cb2c87a8125524d11c991f5fdb4d2534b32f058eb16fb644c1bc69a046272acbd5b506f368d2f8c1b06b944668c5782689683b9bf0c7c79a99363f5792a166dc29dd24a45c52512f6bc6fd7e887a47a3557a4703642ddf7c16e55981c43009c7d78f7008a1c5facc6f4801a30da773186d3d9e1e08d4e75bba87db08787712fd34368b832ca3f9ad9b3b658e8cdd4a71f8beca5f1188553c9e8a2f1fe3267d5cba83f95b4d18020fa967cccfde0eec55bcfbb3e64aaa5b00e1ad3b1864dafc9f14f948137d0bea6a4b9326b33453f20dabfc0ec21c8d8238d4378bd45fcf8e51d6f4b099bb4660107beab170da4beb8ff3e5b0e46ff2b4d54a1176ae992b1e783caf962fbca250ea42ba2afa7912af888b0554a79a55d269d2e4f6ce76887af3ad3ebb6a92d3bd810569d07218d630a3e606e55dd5fa160a2d75c5a808905c9614d0ce4194144b0ca1a492fa8ba80637e2da927fcd5cd52d8086f2fda1cd3aec2625ac8bda6262798915dd0a0c889ba93053f7dace162caf273bfb2d0d4d037358067a376370cab03f18425b9961f94aeda557495aaa1475cadd7f1caaca7d57b06cf5e8e44ad69e13256f0037d35e376a15f53e3c0aafa2fc0cc1f6517ee9e2ea0fe05eaa5255e84c2b25439c05ea24b49bbcf113d717e612ac78622f5353700eddb22725615e3bfefce44acedd2455f99577c02635d2673f4e45edd704be9c9c9f5d62825a4f19585335072e1519ddae9cd189673a48f4ba1cfed8cffa0350d408c5819b0c89bbfa2618005dab6e04925626c2130ce4c21c7c37f99fbf02132f4610c4947a18583c684e2703dd597f21f5f351d7c600b9691e4a421345304122d2c1e26fb551a63f2f9991afe723fec76f37f087e9693bace34f02a193794debe4b60ec36f4d882870929756ef6918c4662cbdcb9eae91b9595b822d3186c290c356e702d896ea723b8b20db9a08758d93574d84f5ddcb088c1895efeb8414763f32a6f00430f4395aa509af58fc4d83d38db1f6bb670c00a369362d30a51c5b5cb6e7bcd52fb01d7eae2f8c8fb49971d1fcc8599a1ff59205307977698e2e09600c1bfea3ea708f2004bb99c3a354b958d86ee9051415ee12a9e4a072ab9a6008cc64676145d944f4eebfb75108462aefe831cb73c8982216f99b708daae682e8ce117e75570aadc88683197ee405f046a46d6f0bf4e684d27fb0ae3f1dc070391160da54075ba798c8f486d6bd6ee35cbacf24c3f98ed66ef6cfdae9b8482902137d70927d5393578bba75b212a3f592add70e57d2cb36f79e05c49b1c67a625db01b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
