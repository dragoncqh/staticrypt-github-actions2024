<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe3ea73d928903e660e3fbb39ea32c603b957640c733ae97adbae3a73ed8af4823dc580327a12682d8f978a4690c138a3eb0fe14cb50b8191d695bd35c68d48f3e0fd3eff3218f4735decaaf39f6c0a6a6e73a6cd2cde49def44005f62713363ac378998cdc9ab5ad51ecb91472c6d636d32feb60d5390680df10c19cc85784ac6a84fcd2feade8adb4914acabf3544ef788683c9411546ffda98a100a2372b3149efdcb2af2b5ccfdfd426f8ce560a667004116876dd2d3ece667e75a903436bf9823b782fa0a3386c19797694f203c23adede63f3abca0e752571ff96d22c2b7e8be1f25ac4abf085377ecae81b8ebaf714a2669b33fcdb2956d2e792a7a5d7e1c25a46f8062aba0a8bd9edde46c0de2ddc3eb1e32a31b3f762c3e592a0b994b5c78979dae0851319f86429d10739ffa7ae430f153aac6bf3978d1b41bfb495a3fa181eea09f793cd0db84d22cd99245e4a257e2b1492ec4601ba41e4f78c256fe77e351b620a45ef67fd385254b649ac82ea23076df1ad481b38a3aefb325de78712b3c886f426b19af8a48bc007fdd3bafee2e7fa5e7bcdc6693fd561bf7fbd72da843e4ca685f596ad176b9edf97260dd10b002f6782e00fe8f38912b18f6fc9bb6b17d2de9573233c8dd74281c368e004cfc14661413973a2a88bd15fe4a83c4ac99a35b104355ecb64172c12c91cfd2c1efb36f8547aae486857ac2343973fd79a4fd88794e9247a309ff8daab36cace1a78190499454e345f02cac533f07742d53d738cf29b1c5895d4cb5e141b697a7e6a94b6acda0b06af4054154b4615c6f0909d2433675dedc95894cbc0e77da47e25630fae5497f2bbd6a6965c9b65cb97b61e06f115ee69286fcc09d6b69c81faaa278c2190b8e33b09887970a8949d9266c4a155c6f8425cb3851c375a11e7c0e5ea0b5ce28db0bbdb683145943f60a3119b9f51a3d46870d7f661671414b9b5b6549f580f7cbeeedb065fac11b22d09e52024107ae1a37ecacc4bce75420e6b3360dda88eeb20a0656d329c321815eac6e9359babafb37a1ae3901790a3bc629243083db07340444aff2ad1ef6e431f261b84bc5825db64099562fde4cf9ebaf2c5e73560ecc59c92479f79f087d32c7083cd69e0cd8cbe9b5f90c7a36e765c8f8ddc64f3196a1c6b2c789cf40b2d86cc2b791c05f8a5dbaaa1408442ebb49170ba33ed6a31973d2e3e121d58bc2904c36d1997ab91da54a023184b662bcec2df87d78536010d3e9b850f1b7e6225a98fb10cff695899acc3708e980a26b703ce5bca00171078143286ab34e39b87c29e01e2209e12d8275fdac3113e9b2e0f8821f63500204bcfa3a54fd634e2eff853e4c646f235f4b738f48398480a68dff2455b070a0f12f5450492526b345df30c721cae7bf03fb7c30cebdde2f0f3096ceaa9f247dc03119592ff47cee858aeb7d8935f801947ac0d8b98e5d5debb8625f5ecfbae246c4764a87fa8eac901ae56d26ed527444dabad5ea20a768f7623de2257649e455a4ef5afe6b83f220ba1e7694337f43ffa14acd819de6d570d25601a3d4edd6673e7358c791dbb11c63d39e49ec3dba458cbbe863e134b3363ee739af02cf9fb5321f6c193b1eb813702b39610b3de35e962b2803d9952130c4ea160d902d37ff16bcb5716e0440c7d0fd6cca96fd1b23ba0545d368e962fd94193b942cd69f8deb768e749ffa1193db4eb18b3968a9d47094efc03979f2e10a167991c5459d848c4bcb3f83bc4369aeb467b1c6d5ebf623eb1a4c85a627667c89f34c48cf99332cd56b146182d03e15cfebd61f26fbb270bafa492bee512c4c858d25ccaa33f69fa64576b20d24c68d433e40d93521d3bdea093e1faad0e53591306f4749df5f6c88b8d53c547eac196de97dfbf5c65791002a69d803c4017b033a98aab914395526c4b863e8250f4c2e85bb955b168ca2885afe4bfadbd0bb5114e3461c38c4da59158bc95a8ca2293c9b32a247152aba0e4c5cfb5f4a5b9872888e697aa6dfcbfa5a5716b7d1728f260f2fbde01754bb3424a1a118407d369cef92c092486cba3cf7b8362bd0a134ed2b34083ccfddf47654167d02f22c1a114672b8623a5fa41664685b4c65bcd49d142170e5ed5da74ea90cdb9c8c3518a8335d4d41262f0d5f4561296378d4b47afc2ad7727b9be3fe958c191ddbb9cdea260861e058bda97a4d8731a388954f34c05af25a82ccd482c195379da71b0fbba0f2b03a642445501cbdeb42b0ff946d18ecfad9e64a9e1fdbd727b42d74cd96f3406c30a0811e7bb4f000a41330bbb7c528e97ce7531bd7bd9757a57d4b18fc21ab7828b58f4b34faf31bba0fcb02e39d36d6d535f9bc9c1201784bb3c9a2f80bd0ec744ea3758194f5750b7153cf5f67b3f83d1f51782434b5f8cf04c3bf9d80b2eac968028c3a39be85eca5489cf72af5d19eda52e9955776d0c026e561ec9a8a9e956c2c3ec027b99c330fb69351eb861eaa6bfdb425452ceab8c059807a1ee2ce69c74f4cf8dc7a1ac0f03901aca869305652c79ae955afc37e3e197ae40f2b2778b06331f572bb3e5fda55148638059a6a358d38dd7c55d0afd0e257e06a9f04525c7821078d1c8346ee68e9059755c2583767b5dd44e97487507f66fa06416c50952fa337e5b667186b3e910c7ae2e8518106011e392a8f16c30a86d4a020d74ddad74ba061b33463162b9b21a8cc134065927f605657d4ad834c8bd21c2d85374a933efa7b6d70f568786b316f7704056d3d9c267e7ea8014bf02cac2e46440aeb776a0cfb1ff6c01909bc1be63afc77f9c86bc2c7d2cf5a717f0af424071ac0433262e9cdfa902af884a80c7ccf818b83145428d41d8987bf95ca3d138484a0d8b93ee509fa8fe5f470a8162d9880db6e94ef9eaa91ab979458e28cd06db800c022059f2ecaee5b308181a52f8db95e88e41c4793ac2a09ca88b5cf7ff7c38a5ed5067b62ea02a9cee2ae0f6defad9970252604f4da77ec4904d807769fd76e1eed50dc64a33a82b72bc05afc2360622900164de11a79e37edd579180628dc2d2a92b2b7032142e482e706e6739fa1e373e5b74b336d1a6f5191f2d869e46a253e37f3bf0f7cc40b3f6e6506acc77651743b9fe5ef0ca0a4faca0907cc09587f6c3a232344d471291e0b8152b4774dd1db0a7c8db87e41c476fda741ac3dc5b5bf17bdb77dfb8ab2447ae5eee3733afbb456679327f57aa69840e5342bc366487b94b0504e7b7d629d39d06d1aa1b01ffdf967e9226f44054724ed2cb2fc6dde9e9357cb07d5d14fec93b7373ba48cde5922da432616d78754b01f875b5632eea42461582969d65b956cddf7dd6596eb2e35a6c31410d6cade86031b4995d333bed2deac57db9533c40b0177efe9e9e29ca085340c4010c42cdb8d2ee954c51356385218f2aa405f0df1da9f09abdd4c16bf944ba05630f7bfa6419dfff34ec5d9e53a9ae17231febd331288d7123f45e8ed62278e992cc8924b91fbf7a8cff67bbb6dd28557c602d55d478005b290871d4c9c318b21328635d2f136d124732b561c8d5da20456b8677a741b25dda769a339a2c871d73ab52555d9ae4199b410a7ccd926ca73e2a0268796b1b3e9987341905272ed65702ce1ff582ce067a085e591449ca72428c13a3c1b40fe9e50d6d701b9021293ad1fa01115006efe10a93a89bb07f500c8b611f353d4916fe04e69fe0fd8558712ab4bccba7ae42e68ee74393084b4f356db72c8cbdbb85cb3ce81031f1b9b2d8923e459373ce3ee7e761c42327e78edcfaa274cc64e4764b2c1d3fb9a5ee685d959f97009ade0b49a14d11950b570dc58109a71d35f95f3989bf0c6081a3a774aed539fe9308712ba92ac538248e40867136a30545db6f41a13a24f2920da00f16c9ad41709b0c2cfec7f05b6173bbf670c95a55f3fbf27749b07be8d686c6564fcff45875842fafbdde4439a349f9593536ab0a057594e1866369b06587ad9399f6a909a0f294419d04f85b75a9d91d9b2b949b49194ae391e73779c5053bcca4e7b14fd56d3b46a6bd3ed765616a61e1076ddd398531fcb04cd394c09d1d8293bcf8bf45eb4c1407d29e73394ff9d84bb9a3574ebaae6ad20f57fa0798f1bc64b8f52698870d58c3be2c5f16c2779ae87814e0729b821dc886f65f18b96693c9fccf4874457300c0852e1048d065c87b9c527242f4e0db3f249a3affaa291dbe280bf047b33a23711cda0b1889c4e7a5af334761f53abddbf2d2f5ca553eeb859dab2b73f3163154c3433feff1693aa1d6a1527a3eaead5f0b3792975d2df2df1b26c0f09d55668a9f197e8522672ac3876a32895777fbb1c36a5a04e4a1c5d3cf41790e28ff95d39e4a6f9fc8acb35b0bd68e578446ca9506b99ac227384203083dfa8ce70535fc302c1f5ec6a855db57e3b5f7efc30e6b95032dba42983e14ec724866e640b0c93c1d721ab7d265d894818d7acd5b1b2d2496a41a0e7f5c2ed2cf0fd9ceaaa0c0ad5a1c8c55abae87d88a44c01cb87f3bc48b637d7bfff73c32c458659a1b224953fbf1d73b42847b0fca7e40a64ed8f82ff91fc2c53ba14838c255a5423151c5b4cda504823e15de9850e43a673c6cbd2a28da968a2ad9a57ab3afd0f9a049b9099fbc1b9f59a6a6722a476e0de3a79752155ab51f5b753a701b62a55e246cfc6d046e58e19877e5672fd499bdda96bfe125bd132ad251d11294acccbf10fc7645e69d4fa323dfdf43147657ae6f8089df211eadc89de0b049d07b746ab0e51f48dae9f5d2221fb626bdef713577e68f650a910872ea442c1424f5343804c1d2d63d0997cfc5882f30c41ea3d1664eb868645cab07c105dfcb755f4069ea0238ee79030c7e5d0e306ec3c310f868a326d7a8e831015114a59dd0dbf8aa208f7ef4c569abf46f3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
