<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41863e24fbfaa4e976f505c92f2109589a86745a400c53882271289ab0890ff1bdffaf2975aa8d6435b885e4e50546e97e42bebacd5955da884713996e49da965d80cbcbf237e4cf8d0f5ffad406de313bb01364d4e184262d49144278e7f2116ae53cbddd133711573af7a395590f9d50445b45bd8d3121a5ff1f7e67b0b3b56ec764fc030cca5ab28d83b3ea79cde637363a32f962261c8075186c1ba3f510c0c773fbd3cfb6a6ebecf4e2b3a628b073a260958188227700e37a19b58435f00656bfa9792589a4228f11c153a5fdc00649b1478dc089d6622bc874cad0b6da701c6c8703f420ea8d3460997398521bec6bd3a12ec3b0bb8894c1651bf37eaecd9239fa8ce18a17ea57562b691156a921529734bff72a342ceb7baa192ece379845656e1d712e2bb06f72135b969490f6a6a65da01c848c5ba7ff988935d0bc32d528f22bbe3b81c27619d1135b2de5ee9028f091a2b8c7902c3b748fdd93ac07e9cbf140d415b19d99b847eab91ed13f0cc9789628506cb668859050d6e2830b3d58fff5c45237d4ec66d8cc8f42ceb1a52cff5f33af7f1fb8472085110bf550ae41b62bf12b40e39ce927e6ebc09b47f681dec8872a735222f9df608f093a6a6ffec37ca6211ebeacfd976ab50968833b65ace26199804920c357108c62211c97aba12ac15a7063c0144c6cbdd0cc43d4fee135a04888e9c82beec26cbd77cb39ef6260e2391ae84c256fd6e54860c57966c3c26afa33ef88861ba50f410b7560eb98157a7b22cbc135f7ab981f37080b56cc9d80ba5b08bc20239fba6dca1e865d926110ad454a1b1288d1d754ad739e226217f667ccc860cc9eab368ca968953d391d5b04ec33c8ec9e8f9b0945cefee8044acc9abc0eeedc84fd0ffda416199b0756655316482c0da9512989fa3a7faf121cb5eb3dce95273697d62e17f29f20c0649d6dc74311f3518392b9fb1f4d041113830feda26eb1dfa16ea53086d23fe9d63b6f87f42a8e8c7f9832eb250b0902e7c5962303a354127dff1e4754d6c2a8e7e7de74d9239572d3a800f44eba50bc9d5c0acfed3971fa221d4bdf968e77167fdf0acbc46536c8b1254fc4efc1a0dcb7ec6f04b189899c8ec0a80243e6b501a4016adacb61aa5cb0ef72c48703bbf6bde295e8deafd9f83fd7815ccaea87fc8d3a829eb91c9e36b12d0aa71ef756892ff7b85fb2963665cb1a1c18ac91d54b91e40c4a8e88127c2822db397c951d6e071969d5a0afc88b3ce8b4698c10e9df1a881810982c16403b6743db864efb335513ca0aa161df16b485e9c09ae69210f822eb1e986244bc576da33dc01cb4738b85bac9d19281ffa96879f0fb513bdfe2867988ef7661af535b7164f91468d0ee793968594141db40e3a299fa3257ba1f2611e68b28e6d56dffa2e66885e6d02ffe28e34220f48d98d8209ae187a057d964e7f95df93dd63245692182e6c3a25feb8106a9ff9422ca01e5ed088467dd59bae0237cbd7908eb970c63e35703cc27042f73279ce3fcd09aee1f0f51eacf7520e09cef661063159c40e1cc09305a3a6bf84883c1d45742b93def8733d67d2308f2cff7d88513e43171ca957e11e0a8f2f96d38961807cebbe8e6b569f6f129554af03dec91911da215e9cf09083c31579b30f961f219ccf21ddd2a42590060b0e640c528f0359fb1b8dc31805000962ee2f05db9f7691fd005ba318e861e861de194326dc31f61ddb7001406803c49eb37aec94a3675d066fd11cd4e712b2a80cf894ce4b66618bbb0593ab46a707a99deea263d7ace7848da11cd2a189da5a5eb1038b3d7fb8674057e4c5729ebc525636dfc26bd4726ef69b6c2073dddf644816e9089da493dd16b2a969081af5d56802984d85652fac762790e28809b8e29a28f7c276605e8d4ceb3207ddb5903156ffb04b7350638ed365b097af17b46afb69645f378357d4d3e7d6374f03cb9bb603e19287886d0ad3d357f6a09e82e2c971ccfe667c449fda421d404e9d38cbe5c15a9e478b49de973d7021d8fff8137ef907519bf3407ceb6809a38b1ac54dcb2418a2227ee71f5fb80fde96cae86f69456b367ff012cd5d6ae315eb7bc4c2ba8b47eb9220716f5a11a11437af5e0ba0ac0602cf8a4536bfd9d2490e17f9ee061afdadf4aa3f9d85b4bef0cb90bcea8c6d843ba8ba9eb63b8136348618b2a6857aa8871191093ea04a902bd3b2069207e006c8d74e6de0fd8b880a3dec6e5165708be8e4c6c2dbfd5e35df2c66c980f90bebb10a1231de8b156b813152b703cd7199cb518e145a45f61636f1073479d5bd007dea3644a01ef16fcf8158a9b7751b4ca245f2fb304db4efc46fad672b0f1f7d2b91875af57088c60d834c6025c42e0a4f30b9ef5451572f193b5e706be36c6749ca35caa716ad58b796b5a0a2c0c1bd1c0774fb1a4cb876e7304ae628e2ef81b878e1713245911fe80ad79f3461c971feaffd7d7ffee8b7d665ffb6ce316f8344a4d24a26b312ff46685d99cd8d3ab03edce25fdeb5bc3d70a38fbae5846cab970e9e89a6552ec2071608ce184c874acb0eb92845e252de55218f28705285b117132e57dce81357df93302fdce4e35b82a3e0c9af7a5d72290e79cb84016b175076a8122de5779ed628b0f26176ac3f3562857f42599bfdbc97765b5f9bda313ffe97dc982e748aa14501a4c11ecb8d651a3227e6b7f14dae998144660f1b0f1c4c23250f3f156eeb33e18ea2b0e177774909f65ac3e6ee5e448ebdcfd9c044fca18204abb35d49a893a06d08d6fa7866d40d98bc13f4207052fefc0bde9397af7e61c2bf0694ceb2709dc4f9da2580a855baa37d0a6c87f80a62ebb027057379cc6f0cafb3f39a5052fb304afe674acb361a5373265d41bc809294b1ff6e7baab28b33f889fc5e1d7c0a07f6a49c34add2aa5edef21f614bdd1902e0ef39e2bb7bb6d33689c4a08322a0444bb206ec94fe2c574c1525b4878a5827c821a6ebc44435ac450b66bf0d56ce01d93d89827f849d084cb6476531d9c2c9c7b06a8eff249985ada4578aef6eb625ed2dd31abbb5e383e438a01b0ebad3ade940f475ab5bb85a0bc458219d66ca2aa46e47ee3f8964270d8206470a5d6ab98eba2a31bf6e6984a9825bd9171e56ff202fd2eca8d9394d78b94b000dd8783ca51d62b32b4d5317de35428f438ed94f2ff0f42474f6af8b53cab59919178cc9f144014cb78c454566776072484cd7ac7c2f84d519d00026a2f849787e4b356edfab4772e911ceea842c2cc70b50743cd6152b00c0b959d3abc65653515e1472e2195535c786019ec1fba15b853832f7bb6e8590e1cecfe38792dc21398788b7a348000fe99b0cd5ca661b096c8a77a8200f93d60424820aa657332da7d0c7ac735284cb963a3580e95ed02243c285876538944baeb770b1fce683a2f924a67ccb6e2843e841db26e083ddcdd5efe2ac5d539299596b1364482c40d8be442870ec5f708da9241911f45486379882f5e26f8046d553aa4bcc0d0ec8f66c4382a4b32e4247c9423336bb7702df9c6c1d5a97389fe31d586f5ac8374c46c126861a1c10f870d64e13a13d25f98c02770c02c766184911a1780f2b2e71acd5bf8312b2eaf08a7434a0cbace05c7b4ba8b2ccf7b2f9077ae627fb3487b4e64811a8864e681dd7b793fad4a65dab9c6346f204d2ccb3d6b0e879e299cdb55997d8617247bf80be65d0b6f091f9b5e00aa37eb452aab2c88b70ff2f237bbe56a45ff3911916db68f4a26f92cf2d3870ad7ef56a02b3aec510c4709ddb2063a213375c53d72ec0aeac0c90d07faff7e1aba84079abdd99327c6c7167f42d7c18cddd3fe195045220613b17d139801ab3d1bff1b4b16a9e8debcd1943f4584ff42ad6237ce18fe88ecff0f16a3c672f6f34131e7a3225f9b2bc3ed8db10844d63a88f6caf4352e0e3eea7d4083cbda7caeb83b0ad5bc976dafcc2a37d18ca8af7c292ee94b65e233b65f86f407542a2705ca51761f2747e6685d2f09cde531cfa128fdba7ae0119aa93a828d6354916e2426024b44b8192111da7b8e03f51beb0c9c7dfd9a2bacd1f3e57937e7d51d0a676248f17ecaeb268cb222c98e1bd070a21fa767da17c315e4757922a2862d27ead302bf9761ddfcb4c427e641a50424ef8c9acd37f7d0525f9443f6fe89a9ca87dfdee80d695be3df624fac51fb1ccf436c9010a21846e0fe18eb87831558fab5f57800cd8c79ed28a7e9775678ef8b57d63206de4442f70379c2d74c4da37b3032383a56e85f625d3c204eebc57db0ae3c7b75a1d59449533b1f99c9e91218e212a5b75407507b5535cdfe70facf5ca241088fa6c2c91d81266ee2015509c528c5f796a0531bcc6a19af3e2ce68fa1827c57080410c2b32232352992dad7f1fdd255425b52499c8117ae020f12729188f2f86cba556371c3ae606e7d81f0ed4e58d2ebc404650a695f154d7e5ad637917a6b7242edb39a233a95bd66ac28c2e7f5ddc11691ba231052af417ee2572f06cba2066421b267b23b28823ce7861b551d6b5c55377c3ab47ac6bc26dea0e29816c5f7ef228b0f6a74af09bd978befcb11e8b67afe8c3416aa07aaa7821f0fc700550894b01125a0151be0e1444510b3ff5f93cd389dbb914ae4dfbfa470cd5f456ab468611474a65acc723f733817be81e3fed6dd8c6eae5fd5816b501a4418417d20a906a542bcb48d4638b0f00a345fd33fa8b8821aa24f8dd1c059cf9f3996cf1f8decac9df4a7e4bbba8c5c94ad96e9bc602ee5b9aa90f772d6194acc1143db1ebe5866af545a5a7adc40f4a1cd92b772c0abd1e12339d10f24d73864a2227c8f552686214de7ddf1a607bebb729c270a216b3dd07a3df6074391b63873017ddacffa31c06f91bd914240f69537ed2153ae41adf678421d3c03ef0d1f07a2ea4478dd5389ea90d290b227e41b1eca2b011e8c3073b1f9c64ca0e1845fc0d6c35046cd17028cdd1e5ccc29b3219fd7b5135f01d008bc18e63093ee80e5392e12b7de2e1c92a8ca0c3e944bbff7ac70c0794036851f53910a1071190a34badf67462fa486063509ce4c18c90460ca50de45796883fe644da55edb874d8d69b2e9500fc3206031579815f8cabf2c9c9af3bea2df58a39f87686e0dcfe36ac0f4a81fdf974aa21ed7a5f4a6b5d73addc340a3ada08d7ca3759b9279f1b21bfd0455230b03e355608f21c7a0a224584ea0c1ce6907fdbc89ee26567adf07bd46a2359c8572aee2b6a1d3071d2dba5f48f61c7b79d868cb6c58470c698e23811d7234174a4d2fff473ef04df01938b34ec51126d1106c793f5322bb181f36a5411a748c7ac708f54835b0621003a319d57fc9d8581b642a627d5cdd28c40162b5203341b561c6fdd6ab5663d271bd608f11b754e8147e25e52759f7836f333364974e623eeca22e79bc352fefcade3190aa18f31f39e58dea8d28b979cc03e32ff6da8eedd6cd52109be77ad362aee11a608597b70d3dd3473590e69edc1c74e121c4ac9683f0420ca5a8038147d276fce2d82f430bd286d58a6333dd9326aeb8536f039aaedaa9e140a8c9e76d1bb7a50eed6d33c1564e094241c6f6a12f9daa0542e3c9564b30b9c9707486937cea68a3970d74235c8ab7e827512bf44e71abdbfb9392868114232a5fa3874c44dee30c7f212fcd1c9e54802d43173d1a2d790b605a208c0e463cba51d3f71dd1b61353230316879294dcb8338e7f43680fd69c422230c805df718aab02d79cdd55daeeb1ecd2ac786e49979282eb5805d8797f5673d9798325a5b1d803276842dfa86a9df77c882217a44357af20ed3ad4aa5b980a754c4913de1665d969f4b29bf32fa35556da7f49bafaefa7c0eda076be47487fdd92d2d78bb63d14e2e511695e1d5488e167e83ac39380be7ea966ed5056fa2e3c7e7222391d22db82c73a2484893595f600004e3ba47d75fe5425a99080e8fdb0af3296c61d7b8463b508c3c970b9caa996046fca0f8e09e80f15672dbafca7ae787c121e90abc9eee7094123116eee5ed1993b9b4caa5cd1ac34d30791cc66dcb4cd01a5034e471ea89b7426be089dfadfe3849c75db172520a31689ff6f8e4eb03eabfa07c7d0f9c58f054d759731d52afa238adce4fbfd6b68c3e546b0bcf41f76cfd8b7de65722b4cdcb8c9d94de386411167f7a574bbe138e4fb1fa0a16fb7af9972e248b62c4855d8e32e55e43c212d5b5b99622d5de92b6586c9afd286cb3c1a9aff3e83875a14e933582c6343276cf6b0ef695ac2b427eb8a8e14a7c50984c060d152d757d40843d09bfe775ef4bfae8fa4de8f41c03319d8c91c50d58174f4aff87cfe554e9937b66c0dedbc82c729b01f039578308d6142a07df7aa797fa3f54ba6befa35be6d0a6f2d3649cb28ce949c9ce7eaa1ff58157045cf3163a89994161308716ebf734811c5e41bd05d30ac511ec939f63fa200795aa190086a60dafebe6a6d2547e8af60f736d664dd9d039f30dc90b9780d4ad4ad9a20983b6c6702b1f3fb9a286d300499d17a10ea688a1da96a09b658a8cce0c174db541ea9619f1a3263c7c66e7c4c6b67825f327371e9cd82e5d8c7c59d1735dafd1a881dec93be0486a54829dec97eacf3f4520cc9a011b4a49faf0c5f3adf2e92605cce263e770b0207d2718a5f4a4599f179792cbdec38fbce95820f3356c90e8dce6ee4d041d6d4de7f8bc59978b970ff7aedf347585112182f44496300d3817b23848a0c038872286396f7671dda044054439423b7056a093d06634dfdbfa102e85db96d9cae21d7234358c37fbef524bc1ef22b4959e9e7cc313bb0e6d00fb2904d5aa7c692e166167fa4020b919ae80d1bbd420923646081eabe98a603014b3682912f54ec227da602327cd1da686a197b8382ee7cd24421fd4d15d03733ac3850289c26dce749e5bd926101b325440d725ca2fae652c84d241a7cdf59d94436d6c4b6d43d2a9e6f0018e01bfe2e92cf555047af452f1971c4b0c265a367ec136f00d99f576999dc2b9761fce0219ce7efeea23a3a71555a59f5f8da1e2039598a7db21b70ed052dfca3baa8587ef567853a4603d9c44ce62c94d0cc5bf9e902e456b49f7164d273c3877a44f118ee7b7adc5470869a8f9cdbff0d71ad9f491da44e899b399c81e918d4edf882fea23685f56b3c1de16a46253681349e08fcf092d826a33eea917caf2e6e74b9e2b2552e86cfa8396739b6b43c80100af7ec4a50da03e37262373a99468fa01312c17b206cc9fbef044210ec3a2b46562792c81a33f51d937910c0707f9eff7f722a3ad8875b79d0fe70ab179cbda1a2109dd769b1f17e97c73fdc12cdc7bca3427134056d113254ea97819287e941e597d48c6606ee160bb5736547391aa1217d591037eb79c5eebfb7ceb931d18e02ca4d675da16977d272da8e5f2c88fa92b33d518fa9d397cb42c94ecd2f1a72c289b14a2b4631e8882be8e2dcee71768acb106c02ce1499ac79e4de7a2fcc5fb412b910e1472f9abed3550bbe98cba815cd635f3af50eb7ab9d7d3c7887c6b286138cf4cf61e6f31efc183aafa04c19130e66eee2bae10d5480a086e3c9ecae3723b11f000b542964e45bbee7afe6d0891fce0635f4f3df21d157b23946e76d96178ad5c5af6bb31e171a9934ea81aa19e34288370eb4514a993d9609acb1eb1355f0eb593a3f5329cb07a37943960ba827328918a41b175802bc5871665d813e0b3e9a8e379f01a748c080c8df1e70dfb2c2ef3f8d5f11c8f9eb81eef3aa539b341484377ee9ef964b873c8f6121d2dffa6deb5614a0a9f01c641301f88eb400f4cb80fc317b74fd7da3f497959d0ff2eb1cc5eea1da4fac09d823c99279991b00f82e83799daa9f437ddc5db421718890973b686bb5f06acf819896843979381cc833071ab28cf0ac4b419e13e3f8592146213212425cf790b25c3e7cde40ee631f0ff74599c84bcf3bd93aa4e0ec05c83a615db661af314fdbc6653305c8ededc0352f67b2b402df2689da91fef4f38858e4ddeb68415341df3127f68a2b98e159c77aef7d47d3ab952d2a9cfbbce46da04d9f180c67d6e7244cee3c18455c5fd2c252784d5d2b7bb173094c4f0a0f2c47dd2ffe3560e57b721df7c8131f77e0b7149a20c72cb5b1d3be2f598c89fac8426103f0c0604ea20dc68b6f51dd1a4beec4241f5857ea6a5b72f3cb83d750a96b8884e696cfc865fbf6ef388220d96c2f584700223f8a3f3c163b237a6cad266a7d1bf43150bfd04e278b8400450a2ff2e08f0abdbaca0eaca08b0f41f429173580bdf07132747e255bc33771c5203d087b05ed083c8548b2a5a7b02cc742faff1326c89d8cd03449d2e4f22f65a47f5d360030fe5d3c9dcf74a40e799950b2b11c7f71c0d620d188ff8d1e59e5e19467905cd8c32efda67d2155cc86f9a2a9adeb709f1b6ce0dd84257d8629fadf126e89e4ad4d3053a82048fb5a87e641992a9bec845c68354913a2d749eb5a0e6620ef0b01c5a472d5378184221791cb35135c2deb238dad5485e3093a251d0bf32666419019de49f48bf85ca2b0910d706c9930566cc4f0c61e038e6a8a52ab56209abc2596a0a41f37025a8776fa2d68171f83746c9b25ac0a49dda86f9e3bb95557682e54a0eb832df51becb3b6956671e1c0c12355e3096526eeb9022ad3c0a203be741c6bd817e086c6090ae9b7eaa9850f49a9323f4f79a1ce7cee6351236abc664dd46ad94ba2e54cd2a89fc7300cf931daeb919dbdb51a7034a80a0e8d7d11b0b5820245badb6709c0877d45b18675c52fc87327c07e32ef274508ec4c7c034418b338b01f407a3562d0e0dd8e29c257f1a37e90edef649ba0cb90aac392a5aa89c3500ecf7ac7e7b6a22cad913b6695adf89e0b6b64de933b4bdf213c4e409db997ebbad3725dde60f8f36630eaced2abc74b3fa1f03fc79a4c6f81e3433eb8aa5bdb44cd4972ddea1503be62014b3479e8d8721ededf53f19abd517207f7ddd40f0bcbdc67148ca262392f27bf217af46bd7177bea289d72971d79416aa0d0c5b6fc1a52fe24dec6ccd153a2a0f26b1033086b2790a9415d6022636f206be759e731cbed1de4a218ac43e37a104795eec0176955056af0327c881bf45a6fc3bfd27c52127bbe24629c7039a37fe4a211cb818266001f0c9bc630cd7d059f722bc48753d849854c00e71942276452c7c249704715ad28aaed0fe2a751ad79a4f7510b72a294eacd9b3223064cd2d6525bdf46d8b488fa9e057e2f28276a02bb71ffa893c8be0e6769956e0d33c0462e09c28a41359129025361621ffd7d70838d693994ffb6b3fe8164cbb696c673cf0a0f9f8527822df462a927cb6ee4260bd97c63403743604672ea14c4dbf32583da438218efcedfebaca94269a66ebffee0cc8b2a719a5ff617ff6420003a49661d097e87e59b2a9d934a5c9396d37afddff6684b3b756e63dadfceae3d3605b36122e0467d890800a719e60814de4419968f88aef4ca168c0058e352887507cbd05472d7de80d992910deabc5e01b9efa89326ef6a19af21bf68250f8a8fbb6e27be0b3cc3f93e55384d54aaad771c2aed159dfcd94c89570618a6539143dc468cb4f3595a57f81624beab4dca65eb753e0807fca5dd56f34c28dc3417bd1e5bb8d34bbd3fac59c3042f04a0e15c16a31c2023a6bb787151e619c95e772de64e401f8c8c131c4d1343dce6382b04dfe0e11bbfcc664b95e9f216dd956c6e15b75fb77fc9d2731555f4c6bc1b002e3e8a16d4fc215fb61d6de7f73bc7af0b100ef6bb18ef3bc317077841d121ad1559fbc3b5a0d04bc96c8755a05fb654daee4ef274976ee816f47b83abe77f1e0e544e7aa907eaf0e7c2371fac1993030051ae585e82e31f5b49195e119c7d8a81292b04caba6cbbe70362630d74333345a96e07997ddf26bf0d6c780b523d57636ee7e7955a73a4654c65880d8687920a255bfbfaeaa9197675386030b2b8ebc2d8fb4ed2373dd536b03169c2c0fdfe88254bfa5ba2eb3b1f80c96fb114771b4019fd99939993f19140df251a4d324c96547d37a348c22ff30d46a37e93304d1c92d470e8bcd4e73c961dd0e4c830adedc2392042ce52518c1d5366d63e9ea1c4a26fc6c6f880a79b61fae13393532127c0023f8642ffa36e8cbc71289b35c990818b426e044320bc61fadea40692db825411242508fdcc5259f46a309186831c0d27549c3bc25bdcd20b14e01a319707a395ae8bcc2b45756362e1c3fec34b013c959f0c2bbea6d19db184291a446da40ef1bdffff3a761a197c91e095c74fc43c6e40ac7b5af6c250bd7f1e144d17e600a1e4c186bca66de453bd1d5caad9e9f230f566209bd463aa3ba45b3ebb116e561904a0768d205bb8cab64487625cd46ea9fe73c0233a30e1c9f544c34b65023f7e72b92ccd2b946ffc15e21a3905369f704c67c597b0daad861fd2732a4b4ca83dbec51469550ee4541c6c47c8bd0069359e25a4558b69504ce43f6958e8ecb260db72fef5a3ec11b50c0706daa985271cbb4e44ff67b96d21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
