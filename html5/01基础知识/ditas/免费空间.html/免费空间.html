<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76c0957d22e71fa7c028c18ade374636ddc74308376e9e03033894b670aa042cdc227cd551fdb6a3b9e70d727b6864f7e2ca32dd38ffb12cf6eb587ddfd1a7b6f3196bc89983f1df700366d01107845967a5593422ce02fe74ef2a86b37acc7776088f01f3df34cca83b3e917ae228555c3568c02ccb5fd582e89139e1f6b82ca1feb7db5de00d3937874324cd1f1702c09df2ce570ebc0197fbfce698fde16411e579be4258f357744d13478c5a1363ba3fc7867d4fa876f070f3727402b4b94a6af6e9caf30404cb29ad7a422c16b1a60d6e6e2a1d6c42e7149025710ca9d1288606037400e70e83805fd43afb0d8af76757cec38cb0659d0445533efd9484f0bfe8e6bd9cdaf0db72fee74729445e87838d5980a0758180fc46a8ad8bf50a01a066b5ad7eed622ab36e5732648b1a7eb8a2a4236ad8e6afae0972a2e8bf1527ba2ad5e681eb324ef136e31ebcc63fcf0627743479df7e4ea685ac50869591addd44ef02991f9b21dee6b943ae45a99430b5b6dc87a473b860f96b6807fc0661f9483b88c4c5a0f14855dafe632101d88d9d85c555d61e0c04a2c719c31ab2f5240fbd0acab80366d4d17528ce0617397a377dfec923c1eb782cf28ab35bce6241a57702f1d6ee21f748587d94a96ab5771c953704b837faa0841774a23f916063cf41a4fbedcaf849b35cd07e68e2238cece7fe0ecced5119c03669f5196e09462205c509ca2d198c6fc196404643f108ff589eb0b13e7e165c4bd65706e60916c8cc84f064c68b4437d260d4b97df20bdb9fd747ddcce832f3208945bfce9bcb4e828da58258c7906adc0a204a3df8921ca93d8cae56166e3697a7ac91448d5787e09fff6036ea1b862e40ba6de2dad591426bef2aac34002fce2d1b9e88e2e34b96709cfad125cb3d4e7831c20bbe3212c3600b9f92f5e2f091870735d3adb9dbada58120fa4646ac6c8d20edc81d3dbe46a3192feb555f86098cf9fdebcfbdc219a0512b27f4309d6db6e1d127f4a87e27491531f40c691c4075439755348dd0f4f65026a5755f1c5f1d2d14d17d7c7e832c4147298154edf4711d5a9256cc112ac7c3fa7fa5967c22c1c8b7c1932fc3f6fc538dc8f5603c1b5e3b89da1602c714c49774535935d6a658b72c11aa028af42b153ecb5970c1d77d7b5b21fd3a738533a14aeaf41c5907fca4eae80a6ebc4ed635f91ba891eea8dce207c6308c5408c4cac478fd7d34bff037b6c3e3d3ee100159545d9fe0aeec254157f2dba5d3e8fdcfbc514141c639f011e6fe0c5b35f590141a200e15558f7bbfb44a08ae3ee900530cf24e891c0e9193e77585ac4bd24d54fca4265fdc075ca2f704d1b921f736848becb87882745df1cefc7ebb07afcff2ddc85ec48af56263e4af86771c2b15b9e7cbf497483e345df6a3b6d690a93052dd7cd51f4f59b0f41a50eb7fdf3ed30b11f5ddad30204900ce20694153ac925a81a2090325c1546b5f5ac96434542ae0c4864bfa781325a5dd606e077d042e45380a97b19da2868fd65fa69530554f766755f468dcf917a1c4186a08f3bcd3479e8c00f7d821480ebd6d529463fa24bcec35db4946460abc2a610655ffd82cd7d4d46d65d58760b16aa91fc24cab30f75d628b5cefcde05016aa1a42c9c2b22cf79609c625d22025d4e9cb11581fefe6a3dca04aed4e36acebe3ec3e71b469297440cf2ddc121be20b1bdbd0156a323496054e115bd696f5b5ea4279cbba17fb95f0cf1e4cc8edf651f960888b2ce0afa21530fca2379306a712cff19e814ea6953f7e5b6cc9e1743a54c434eb7fae560dba792c1f408f054024bced5db269a6cd0f621e805d5a45be4bbbbbcffb775b74b569d76be25bd0091c3dab6efde3edc9a46a9a9034d8bce6747307d4f4695a5b4820e254ae4818ddc2d170eac61b12f1deddbf408f1cd83b752967a71bc9e9f8f3b20eead9e000b036c49db78446adf0ae270de8d380ab24b0164e0ddba03793ee15b5f11e0c987a1dee1bd286e25555a9dedb9830738cc13396f3ee33f926cb7e07fa584d523a8332808d932bb5c612874866617aeee5ea7660ab7f9bf4019adfb9e5241b461e91ca19f39e985ac6317508aae84e14b82095281fc0f5657710947a975990620030bf1f464b47ee221fd94119837c23f247fe05a120cf16a97b416657a27a1455684e7bbdcc9db9d5244fc6e720f625b82f6ec3bbf7cf503b0d577db8e51a35cb1e9816b0a38c1ca252d0a64c9a50d8f7727e8ce792ea83bf77f6076cf4fe32654cd1fb08da42417b9f4084398bb531281fa31550498f52c9637eb736b13bb8431cbc50ca3fd09e823fd0572b2a59f9e8563f2933908fe9f99d28f560ea6c6e1082c0bc61a91f98e9202481c84b30926dd604c7021cbfb438a233a1d09065c56bfab54a04a0c3ef4373c2b7d2633408da8a7a569fe109411a974f0e0cc1d91fbe8ae7f6d42d8e5b23d3c605ac3864f1984abe92c320a34abcb55c18ce50f8e80c1871fe8920da45c6e937f06a978b531b733eeb87679a57bd0c2af88cc1c7c54d96d85b9f845e7e124d7904744609a1fd919bc40e74b7e92f211ee4e6f6cc43908f8ebdcb85cfc7ec3946dd8944ed7fdef6de172db28cb38e166ad688d188bc8e485bd619330ab17d5eb0aeb70d820a85df2001fa4c99258aa1b4cf754d4b79b2e21a54740fad2da73e15aaa3d6b1ccbea15145540b56e41a91a419e4d7b1c127f7b60bc5813264eee1b93f41bc8ad78cc9ba00c8c076ed3b0f4efc6e3f4840fb6b8afa57f36110efac0d4c41bddd88854bf6b480a7ee920a944eb2765459a7c496c93ed8c5eb32a08093f998c77e3fd9eba86ac5b51af725a64eb855dde6c12fa585671f544842fa6b89ff4c3f6e6c7ba2fe827d92d403b6b6f3c72c1e8d62390760eb3ceecd77f211ad47f44419db57a0e24b0cd0e214dab6ac83798afa18a14e00ff31cbfbbe228881a36ecb7241dde2df3d99afbc68f962da73478f4f90bc2f0611081c744c2b18bdc3eb795293a7d4dfe0a6ea7c60fc76fb385dac20f1fd9a7a61e0bfa05ebf785ba18a088ebfdb2af2da4c07e72f619b3d1f4a09fa3ea512847bf3eaf2a34cf3fbea920aa7b12813bdfcb7bc807e1852fc5243e4dbabf74ab8bc3d9f7fcef89b5245d8796cc2e3df37219e4224658df8a1fb0afefc2890f8ab88817d0e3618fb8ed0af70acc64926a2a6e352af987d4c2e0fc5e7aab1393ca005986e2015edd6be2f6193749680248cf6950026e9e25baadf712d45369fa3083d1ad3c5b9f9bc211c8b555eab1ea982ef48e40e61c69828716c766a068973ed332c78411a38ea0828b061feb32010f7d3240dc042008ee03be947a3a4396011d8c605524d667349cd73cd2544a26fc4aeca3d8290bc49fd0e9534db89b0348069d91536881275479951e53cbf65ddab6f9a8b622302f1c287b36f24f137e87c1e12cd5bda0034fed7313d39d4a205df7baa1be4cac1c3d6b6cdd7ea3fb691e897ad9f7a41b2b6050c9659c305fe4b62cc7e8ab42fbda17768c5eaac19b5c44e7f7f29e0c8bb542764eb1d106aa7da046319b68bd7b117666a8a65d51badc661aceb24245d79f5bf558f4e6cb2109ac814b2ed956817479122f1f844877ec1387072af0b00896b7f3e5b642fb19f3ee9b3889c7ab498df25a7d9fe56e01efe23466ede6e57c3593859cf3ea18bddf885042b3ba914e19fcb713057e0d0d977d729503e7246394c84a50e794c473c459f5d41a3401c34926d80ff428f56bde0efb3b8037f2dac956bb1ff25285d20ab88d936bcfe6ef6d68990bd58bb38312783b5c61d1b31dcaff10cf6e3ed6a85beec16df9ff72ee0e9f0ebb3017bc95f4fc73e4a517ae121b0af6f6c5231d1d09d1c6c33d395f9381af4e5ca07b553eb2f9bfd1d18a2534b45a86cb9fb4ade3713f3f9b3d2745b365a6341c76d00d82b6e08c17ebdc268997df66e574bdfe6c0325d0223d757cfd453a0fa95f0cb616418176093c09d0771222d1d877f8344419e16bf63dd09a29f00eb5b90c383bc3b49a487252f4a7c59621d8de9da7f9224b50f28fea54da2f7a24fa61d2106341b423e73e09f05263968f6a0602718f3aa1339f0643743ebe95c1c3dbafcae4afaba13ab7a57d250f34a4fcd098c79491019d2f72bbea8155c17885238f30b6c7e994e9a7f426b12cab2698e431876680a73b26993bf7cc83b378f627b466c2d474941e0b7e08866609a0cdf14eb9aa1f52cd57385942b478768e68b29f7b56abe9236b20b7dd49c1950b205950412c6693b4b2535ac03d9c7374a29e5a998aa9faef8123f9441e95da5a5ece90a97d8cab5962b198217c0cabdf4bcfe2cb77786c15f3bc160cf456ace8e2fe2289c542fff009315139d05d999f36647c51d5f359c491374b65a261dea7575b4b87a00211c4c7844e40a5c7e04d7223301ef3c778dd059fd71370b187c4e6f9993e8d3ce2e0be852e166775202d3276eb807bbdf45d42fdb023813b8c7a97fc1c978d3b6c159a666932438352728fcf79c37b5235c84592afe779b6943adf99145de91e143df998805bd27bddac1a7ac0892dd1683f6cb144623f216e360103de08f6b45d358ea6124a1486194618731f2b0df5fcde634d40b20a0bb2af8adb6821a56db65c2d3b086e2b9e65f67345d227fb09724f8c06bf720f095219420bd4227360a5a823e984528f1445ab9d0c380865a3840bb58484dab109ff26db7473ce45b77845dde00e009f62479e01dca159c345a402161cf4089b3f0e24aabaaa9bd7690756d5842c255557a1d1267ba2d69fee09db0dee3e800107a858a6e159c60f265894e9e313956daaeb54f53739482a8861f03a9fac1d8bb2d844723435d90d72320ad08b67702e3c5990fbf412f536b29ac093b6d6dfd928639c99019972827d2a27c12f0be054e89a59879eef68d94e6b684ab1a7c481acce55f1b8b5c9133256ead80435f8d7766f0ecb0aa81a7b25d3cda6cd877b42f232ef991935b5025e5e72aff9f191b44622486b36bad9843c3d700f5ecbb60e49c2bbd2abedec0a28e3c44c57aaccbf45b83a3833bb1e6650e29892de30e47676682268964af9debf5612988a24b051915ba9f0349fa95001388790d28358ff757534bcf384f0ba4acb526c7b816abfd496f3770749e5189b00023ca8ee593cde5976dd94bc6b0790f656254596c744bc3616ca90db962a52616137e5bdc1ad78a83f8c0c1402c60873032fca0933b3711e45d838a2433d271af45c2fe6cd0ea28132d8a54574a1b6b1aca4c97a5eed0152cbeeb14ed501e06360b108aa249ed5e694869e315172371f1a0ed61027126745e10bfd49d5f3feb654bb9f9b4cf3ef2e983ba10c8ce69160d807062a58264d9c1493314a486c41985983fa018036b7774ecd477fc7685d64109a026f05f3367e68b6470118b727319bc1aa5398393802e942e4324aa8d97fbf9699690428f704a36ee5c960565f719a8c6cb53f4a65b540b7c9451d533029c3755b931dd4a15772b90169ef4aea4501aae297cc1b22a6c786ec9f4c7908c5244741949208c9261495bcdb122db1aa6d0cc0f42607e8027f36c95ea44d347cdb1bd9384c3d225ad193fc55823f36fb29fc28d5af95378f11052a337e79d6dc3fcc1c81e7d8e1c7ee88287d5ceed87cd8a341217f5115d638447707cf2afe4ac3bf5b0c9d990b118f07f802bd398c04d7f78a3a0e5d0527f1dfa93ebe9f7533253f26618b75c8e3002ee955b4d4d633172638629449bd6c8ed85f81255799b9b9a8fb87a2d76941feca6053194d902b651564c5367fa3d2741670e2e85dc3832bff593351fcd6bbc3433ce42af669ba8e25ec8443e77adf8216b143ec416d94bc48e6c089e8efd3a0f0923da55c8a94a543e8f34dd848963f04e854fbfff67fef64f94ea893424a1543d67d7582ece90a290ffff52d15a3d10347786a1fa2c041f696210ad49d394302af653890b3d4708d0de0eebf946c3fe7535aa101010abcd897048e0c98f196c7737405dbdcdf175d9ed75e3708caceb5b1f267d0e9774cc961b36ec640e76a12f4c86cdd0484b087bf489b77c32269bc26667f334f4d26a988850a2959d9273c79bcbf9bc55b3813962fe13eae10ffbca5295ac98d60d084b591a835b54a653256b2b6ccd6be0401f928d95accb6a02f0d5320ef91359ed39899aa786215f274655ad381d618c4ad00c210d2eecbf0a0131d126e9226a4c58373af907d8832342905dae2b844e9b679c1baa7a7451e9f6bc959a4f98cefd5df513e6ca6b612ec395e696f31e3407c8251de7a227f283febc750655439ff1282891bde857603bd5f0d57d6a29819b87acc12068978d52187e3bfd2e5b5c35f077428b555c232030ca3c11a3af4abc59a41b99c39b8446fa9bb6f5436cf0e33c58cf35defb3faf1c9e6e88fab79e274a615c14883e2604dbaf6f0b639f62e65d6086a1c208ede5046fec80b7b244d39ab1c3f4cd0ce9871a0b73953d01e641524eb7d8721855ea57f10b5b1dbad63d6be2ea254c8c250352b20f3ba7c0a9a0f7db3181ca988a67fa4a65cf6ac84edb973fdc377d71c8935367126ce932a9400dba9f073a02d93517fd33ec36c5809c95632a6f66dd74fef83b21bc5fb302baf885abf12fa41e35a87b34af6806110eb30e42419373babe79f37dfcbdd40b5b7cc4c9b426d5eaa4084e83e49d717d6107b9af27aceecd7417dc6182715359dca2b9a48da4cd1777ae3697fdfae012c02ef4b50b4fd1e560c36503101e398ee59918e3fd187a8c9eddc947940407940759822926c146d32fad4c51dc75545f7ec7eb844b45dc20650c7ceb238408d1a843622e7361f7a7537a7c277582635d759f18a8cb3b318e03e8e6a23c5aea5a24b35311e7153e19b4638dc051b05f27c6377e4d144cdea015770438225f20c14e367facfc44ec61d1109b9185b976e482e533fd96a159c8c02a17e803285b47e1704567314f615524850d28a3cf18dc991848a4d292a0b441b7e3055151ebaa8c28ac2f7bad6c9cad728f798b2b40a8391410240ce753ae8605202a9f2f391988b1832da47e78c11b86bb0de36a0134c8cfe819e048719c52890dee87a66de2ab99c438d50d4bf4d554ff3bbbad6440a569e58c07777be45cfed8045045276ddb9980539754e0bf5449851c22d3aacca9b43efe389a919dbe38b58cc5887a5dd78e2385e277affbe714538e7b5cd073a1a85b53c79c80409081844859d39122c2e5905a086dd37d7ed6606fc22b5510b700d73dd85908a9026ca2b76280aece43f5d2816e4c24b3bcfd87ac31b719758746d5de62a0a0f80c3db5bf02c8c75a470d4ddcfb971ee5723bce5bbba6af7286833d8eaae3fb31857a80d3ef815be867a0c99d204da67079e505208129978bc837e27b9525e381160b70fd3f8311c5d27dec60787b4c6cccdbaf6d278bcf3fe3192bc62db4067cd6f3c42611cabcff59d2c8703aeafbdec87992da74736235b2b3339101628f6382156004236598b433e04646adf883364772580f85a28c8c9681ff24821a8188b3d3b512345b993c650f3503ba6ef49ee559e4cf265016be0e5b5f9be061a8c88e4add7c0270bc843cc970f5315339e3ae3a3b27aa70a15bfad5edc5a622eb65f5834c89a49830d726f7bc03b50b6b6abeee42254b7c3061f4f0d106f43747a07dba137ae78f48b837e48279e9b233dab387fc5b9d1ee238f77a5d4b0bf642a9113298c38a93f9210bbc8520bb9fc1afd8b53a01e7ebff658c42cf094adf24fa023d44b5bb0737fc27f107fdb59b9d415e5b30971827d4e1a5e3644250e59552b8b7dd308018d252dc06002edc064326e914de845970c858ccb35a5438643265f79f30e32dc591e1a11ff3e3c2e2938d44a8253004d4b781825500407226d695e71d8975980be609722f280bc1c8e6271ecfeaccdb8e933b4032484a9112948017532b2e2e23829d8ee619c234a260f7e42f456ed8fb4b09190977b801441343c6442213a167a52cb88024bf3e9d7c6a94e255f33f08ac062a065e8b90d018ed63dd168813b639c5ec7b20e65245d7f239287e08cfb0fbe86962b4136cf908ebf20858d391d131df1ee9ba136ab1b56a7e68a13a9432bd0249e88c210e62d7fe2ac9a13510c22ef1a8162892efdd978efc0a3e74a74c529a9b27cbf95dfd0894259befe7cdfd296e5cc9044844856ee27db2fbabebc918d221ad800302d80453d6aa19612b995d04f3e5dd25260e0896224283a74223e92c9151027d53bd35d28b42e14de5abb3e262b713606cc4247af5a1f27999ef4f58cead54d370a02e36e30d879cf69d792d986184ce0e0dc5cba22baa67ae6d531180069029d36492faa1140285f12c4d59dcf2c156e8ffdb5dfea7b4844a359bd9e4df7781315ea82e9a5b4f7199400a8b6b247729a14e0e667f080beda84f2f3aadd81b26ef5b31c6248823d0b68490683ec4f420eb44c98516d6c6bd82ad803e9571d06952b4024966302d3808950f8bc59a934691910f797f2e697b0e2c98d92f178e065d827385cf655460f15f6c50cb1007a95f3980c4dc4a78090a8a88df16885ab823b13d5dc637c1f8e17054827514558960174f8cd9f0902b592dadad0f6a6167bcda42a05a635c6982676ce8676c5d793ed4517e59fcb5ed0221f8e33f9c6cac7b00b217f460e0028449b5c586d8c3b7f26b75d5d43dd08985ec2a4ae9d8fc514a726831ba2dd40aef95022d7610f0659701556fd36afe89cba2f394532cdaa36626186880efb4e4cc3c0bb45d52623f8eed54b1e02a8ab970af72995854554ae01a53553bc18968fbae2b3367dbcc93030605305d09641991765d5bab73b8a624fc3265271fe67329ba0a4d382193d2128e174e6ab91894f3bfa78296e45af5d1546ee9f48271da76f7b0c27fc1a90b1cb36b6fd260dc6f7448016ee1e27faa1801872447932492567fce81a3a0a809945471b8e82998b5a4fb2ffed2ede8fee17681e0b8612baeb00abedbd74986187dbe50b0d4d72c624e4291714c279151591b020ff3299e0254acc85e8ba9696c7a1611e8d513efcb38c4a153c6aaacdbb9b6d175eb3f1f6d164c127d432261b4b444c259e529fab707ab77c2b54b02797ff6d049410f0eda867b46c1ecfe8833472b7156fc91155113291b0cc805252eea2efc4bc0d33f14e3d61da653d30002f827919f316064a96e9f0db8868c1b30a8851875ac3cebf72a9633201202a262dc0833305c77e7f45f05e5483fdcd235db822a02425a78dd9d3aef5ee60fd4d5cbe99566ab8918e772c4b55e2f6535148ae439ff1619abfc39820fc36b1ebc7a33b03ed85c469fccab330d2ccf071793eb9ab1c0ddcc8b45993ab479a07875ac63ac757fe030859252194388f382fda340bc00344155611096356aeda143dfd542984f24627f77a60e6063181f3ed3fe33bcc15dd567721b80cb60496e8eccfa7aa4fb93d46068df347a243f99d66dcfd12724c6b5d74b626871f8d9514a928728cf539bc2291d665ff024960d42848bb49185cb16db9507d70d151e9c5b2818d4247310f1abc5b09333e87aac31757732a823b73802559d5e1695b827f00d1af4f9b43e441ecbed7551b46aedb956273ef9e81a5f4b127605c394ca26c7c7123864523c6df11e86d8bcff3b2635aeecb8fca08a52b19af3ee1563b1e40e93fcc29acdbf892e9d55fea8170d4c3c9007c2876f8f967661354ff8f35de30336d127bdc15415269653ffb8ab5a7b5b6e4a0e1889d4c648c4c32774a4c682ca9e2324ca50c952df157678613b4acdf39840c5769bedaaf0fdaed9ed27a19fdcebed3aba984bae1a86b2cc596c1acfc109e7280b658b371abd7a4f1cdeb618edf101c62747f0b41ad1edd0431552076adec1eeb0c061557cd48dea64bc22520cee23f32640b537e8f45bc66299c7de0c8ebbcee9b0a0a944848ef58f4a3871cb063772138ea7197e8845c7d0cefd465bc96e2c81493b2d9f05cf66dfb39ef06ad842f4385081d7b8f2c672380152461450cc92a674459ae8287bba0a7df609f7502f5f646dba31b5841ebf81b4ab5e097f66a70cd65ab437d6d4cc42a0c74d353956f39d9cff897220716ec075e61c682c2d703410e09d4607f04f36e574d160112c590a6a987003089299fc6b97b94b7868a00c9888cb451d07e6eeca8afa8839ee7ca4202416b9f320f801c03ec41a977983328d8b5694d5f7e6fb7c19ee31f64199284d078a4af1619f3f332c64ebac35d5ab0fb09df03ba533979738a49b118aed81f86abc3a91c2f569b858d8301b695e4e6d290de988ffd484703250c41d9047a536685acbf7772ba2a2423b6eb291dbe4370add9c12b38608282b75f36f1b6d9586d48a07648d5930d9466559f3166ea555e23b39c108f41ddd165883dee64935f99273e144e933bd37c3a533d3887bcc16b4250549432746f2827e5d2afad19bc5f8a29ef0a2bae89175facce99858ce8f10576f74b24a288e18e8c6c2be66af6d84574da4ac063107264c35160c4c480d8d3d6003bb7da2b60f78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
