<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4beb901a9668303501c384bc94f211e23b99b88b50a1ee19bc229e02b069e93380a97eea289485c260c5ede91683123a4335917eb0a2b2ecf0eff77ce8eee58bd3be33ba90e7c447a21f0d49927b3e89e4fa63ec465165fbba62e0c06577262d7957100f5e37cf0603e6be7eaf98bf69eccf519df56a7fede444b84fa61a55cabdcb0aa7de02c906bdb56a055b5f1f63767f7fb9b7df643a4d1ac0739ac564f8705a61c1c6e0edac15828f5c613edb874a63ae1a19cdfad3c36880d2f017aeb68fee0396362f0484ab94fcab186901bd57e3bd093d59f20423e3c0a48a65700605b134febb5e44c80785f576085a586c6045b0817fc4e1e3e6bfcbd529fc27586b8689df0b9e3b859028d59c6951707a39087e28a6da356461c6fa0529139a336dc50df579ce47c571761250121df0091760c68cb6452af036a49019588e8d731ae1fd7cdbca841019a65263a465bad65a869eb21a16cbf0db323b5e8c3763b406092eda5550622e0ab324a41b99b8f2414ee8627d770ceb02335bc9e9e43a59568552449cc552cf4c68b7dea1c56eb75577e785ce3ba12469d335dcf919ac6a7fe307e3c0359a13119968d49e290405269b6216530a882f32a5d329bf8d59a5347b8eb7fa8ed5ac38ce1f77a172b9e1d77099d0b9efcfcd3090ea4155a7bb2d8cb702ea0530575eeba5d0fec547ca9bb431c3f9b9ca8ece9f0df8ef2ab0303a87cf1d4edc5d6ed223f4e924f031cc20e393e73588b9be58c2163109f3a677abe7181cd7501ebcd85a988ebdf8512ed792908a7cc2f7090b31e1a45369d13cda3ddad4a572d6a13f08c75dabc03d6ffec5097c9deaac72f81a5e30238f5ecabef0dffdd9a670d86d202bc9163f05114561db059e9c442f58401a7663607d0be1ea519d7b0e04bbfd4dd9b89ee10188b309ddd96f466ea86aa356ce6c945274115cdfa36cee9cc6d44eae344d1b5201f19c6864617a4427561a4a3022e0eed28a4a5b966778e45a35df4f32d46a58ec9f86a14015cd1d1665b8b41e0b74dff6b7a99a034985e7fd966685db40211ead1e8f5cc01494d5a0d9b6746508890886f7261ebf55873f5807c72bce783865b7de6a7f3e38182060a28ad3bf4e9b42d88c2c8e94065afc40f26ef652363e40fb102b9933edc64b05b553a795ff4aa7800ec72d7b80be731081b7785de3ce53ba2cbee878c260d3ddfd5baf3d6ecfaf95e9783d976cd191de37d595f829c1aa5c7a8380a601deeaba5da32bf5066000a9d2954892ac2bf11b97f2f47523ef5e6e101dfe1ff6710b3cedaed0dca282a81cfaa9763f16223ea0a65fb26e4a2cd5425ea97d4b2b039e23fdbfc72d7734144278ddb87081309f6e580287e7c5760600da1b39e3f49bef20cf8b524c82c26d6eccc8f46fd4ec07511e0f6b9412d4fcf9807fe48185dee1abae2ac11e9bc30a6346bf8b69935b1a28c97cd3781a109b4e9cde48eff6a7ac9c3e92d740385a9c537d1fbf7f557d98c856eb8047f8b646ac6cfec2cb6386cb2c4a7dce0c7d8e7bb64afd9df0bf3fd1b2336b5a0912e167d7040e211b09095396fd7650b0026477643881095fc2d50c23b911ebe79577760474b21aaf1652746988b5739028b567dff3bea6bc602be7c647f0c1211e8694f832c3491a84093d9a3bc2c093883b19f7715b50636cf55124bc39e45e91192381a33e54ed98b5bbc8fc54d87ccbc07ec1cb4924b758acb3966638889eb295db53ebce5fe1756ba1f0a788ce8f4f19056c02bc904ef5a1073b252f02efaad747f8abe0dd6cb2fcd9e75a6cd961497e24b4657a38cc4f2965f9335faab9c3913078eaff3885435a784deca9af3b2e45e63a0e88a26c40b1c9c027c99471a6bd5a173450ebb7e1e6fb008fc1084ec11c864a4a73f82aad4e6774654f80783ce2c458452a7653af188ec804dead2a9c2d486a030b652cc90a893afb98ca34bfc30ff30e6ee6b74c5e6561a2a5ba21339c0d80cc29bb34bd2175b7045f4a90fb86ff250313f827177be6434e04f80b3da8d0e54360b32a0a4547b05f676d328ed16ac004b32bd8ef42ac608c8c83f34d41af65528ed43eca797e22a5d273c13fb46709e1c45d7dde9fbc12d5e66a83f62c669a19ca5d06857e7c3bb622f315216c22efa13842b53a027f8919192a1bd4c7ba1fc167b1b05a833fdc353327378d22a136c3292a3e1800567fa9fed60058cedeeb970c2773de8b8d4e94fe8760ebdfa8266f38ed6597bd50f15fbebc721283d7a376429f2100bf5d676544123402b7d77a8165d84c78679b881171434d2d174f9a865ba989457d761c4c6b66c7ac7b888c8bca45968c42fd52a999d116ff9e6b4c0e35013c085df45fd952132fd72291ca3242c369baffd6387d04f153a33aa63838e7fb0a88b9f5d723da682d3a81acc5e98e8a712c8f544c1326e78cd0f0f4d8e4caea52945b98591350cb310667e43307097fa2d3fa5c2092227941f90f2629974f38b151ca729cc726d155ef42a72e958afbcb6e3fed1397dd940377d302b617222d191aafb95a15354da53f4466276a5e29d01a8c6187f5036ac1e166a19871996d3feb2d5e75bbea0ba8449bc728f532348e907a258c9892e00b669b4271495b75786e056a6381649c702489e5860759d1298795cbf3e314b3a7ea027eba9f9f18b374940cdc194e9c44847c0f1258c3ecdd567ee10b2aa3765b0abff6132f9c7a82564753e1d695a583adc31c57ffbae621994d523e0ddb3301dc0a34354f65bcbb38678dd11f24bccca23b5a6a467cc2e3fd12cf04a8e86b44eb4f4551d8a133935084eba2ea97c9bfbde0d0e9c204ff13388b96831921e5f9ca9adca3ac409f7e73297a860f21a8e96327cf00f5985b1d3c09cde06e7cadc58e8b82d22ef178f715f782527a31a7fb7e3c22c88d6cf5b83ac8ad4e8240398c69e4601840cd9ea6e73ad6cb7262325d29a389f51275e03c821d976e98cc74b2464dd69d345eb740f01a4737d5a974c7317dbef534dc8ad3766783fd89f08efcf1cd2c890678aae6858fea708c5e9b2c22f18c267956189dc36022b9c89a84900a69efea1cbfbe880c8dfba8d6730d1f737f60bd7bec0c22a3c0f1248a109d2508fc6fa461340fadfa5a7f8617f2071bdc54c2f3748e6eb8309613c6474c8176dc8fa9a842deec929bf7c4ef08d4addd526cf4de3b1e522114dd138013d3d23eed4b0671fe485a6925a04bfea481bc6bd581e0c8c0435dec58a269931250b97edb6395a596ce81d1d2a9270c14270865017be1df043a9fc27e2725c9136723451d993e2e8fbf2a6285b9a667300b7a134737374bea501490b97e370113b8de9013a139d927b7fa1e930804ac3494f4b9dcba90fd3ea5527897c6c25c8f6d4fbc0b4d0cd289df5866bd6308fb0bdab01cfa9b8edf9e8f260be8b4a0f04bb36beb5d6c1294bea52a0a6eb2b17e5c292b9dde786023d0fa4d450300025ddc0452c5b209f6009cbbdb97f155b9f98ce4ad0b61bd0000d06f04c020cd53287163586e6675e7aaeac938707ebd7f1f3f8bd2a9f11a80074dbfdf66e84af200c4d0b4f9a68b8d156eabaebb60f21453fb27da43609afabe8499c0a6a8ec99fb98754a4e35956174a56e3c9a34147bdf4f644c4b844852fd23de86c5141866b3bd803f0851cda816a0cd3aea88b9704a52fe87fb2ce91de9379b0e47e7205f124dec63cb0eb26a502540202ab1e3e2f8d5a67f145fb3a7fcdcef9051c24715618557fd54ac2f72a82ede713fb94b09e8d56649ec545434a344f2c4d82c020bc91a218e14017083d6df8139e84d9898864a6a3612148907181c0b1898e5c636af3f04b3422e6dc1e0771062480fce9b5f279d76e599217a1a714acc50aa9fa808461488248521932fd6e8805113c6783275ad91b1a03c14ecbcd3aa72db8f7d13135c5e4514705a8a49a49cf1783b38605a68fe96aede7fba203e78c6f3e33b3665d6108218c617a166fe9c217cc56fe985b7aa3e7d9a9073efa3a42bbd35ea2495585ba9374585274ea33cd3317a1d0e4e04086e89424caaf8fb2768faf545c7dcd5835775e0574a2b4d0c159ef3dfa5b7c0676aa2a118ca78667ba9f8ae2d1cf1232d428c0b30b9b9a9cc8558f48c01b38e451d061da5715d530dc7be65b67871065e87e7cf7536d4dae3e773668c9b2e0d7eada019fd32eaede72df269f6404fe729b6c5d247e44e9933df1713f2e8dc1dc1f2ec9031338ef53260da29536a1e67a4bd547b8d03109bfb57235999991c460f31715ac011cbe8da67c96d5553046782918748da72c24b6770e4d44b1778c569c4a040e674b0d6a00320833d14aff370538fe609be75d010507c9538a154aace27b4586cdc0255154a3b1397311081adbc5e55fbe834a2c7ee003e8f40000a8a72e9a9bed09d0fdd8594276264c19425a3d66a9db0175363ffdacc25acb9203b6ddfa0cda56c0db680414979070f45edf20058398f8a0a3c5e6907914f8c4632c621c020b4488781778376c36d356e1e0a78e619328a67787fd0fbff43320fa6fb4f86cc7db49d1b35718056252e3e9469fa7677a98931b6f6016b5704eac5cdfeac77dd67c7b2d11ea93a3e955fbe7d39ab5b89f2656cc82797bcf8fad951fc10bc25c7d154b225d3d2205f332237176f0f4116c8f82ea66c10dc91843800c82ced1137236ca4b7a28762449a0522dd2b69781d9d47f4c1884b9e3d6b992d2b73de5e70e19341bf2e7a67f43b8969c526e445f64b02bb7bb59330a54b15c4d747f616d61b036964dbf95d02f9b4a105c8d7e01560b112592d2b00f45a7b5b10f650f175e77b0c1739aea087f80d0b79c064ede733566cb49bf131bd596aafeeb63fd8391aff1739d31133e2857535763f6f7f9d3b2b80c8adabe1ae357aaa1cac853c0726d020f13a12b525edb6dfa44d47e65c6ef1895ac9e4a33018aa9f3418e42a1021f7626e5efe0ca23b372a3b66e55393a717208358be6e48fa543152fedbd4420fd81587ecdb13c87916fdf688753182b26fe8d8f504bfa35ef8c7a9ec348e255e1c77d3ed861c86f7867bc22403931d9ee617a2dce759c3b5d9a4aeb1c9e96fe0b410b72373c4abe7429e5b236b375b5dadab5db28d904c131e43d9eb137d9db2148a4f06c8004e414a6dd9f3cd4019b56cdaad73db4f2d2a379de94624dade957268774d5578bb17037b0f421dc44225a1a765f6c97e7dee9bc055e11935aa981f1f059d6d41ca097884183420a7e9bbf6e612a71a90c8bd3ad13a09c5280734a3b41bc432405be2aef4d9fe5d10e10fa328b8f841a769f4edf70506e5cb8cc6b2acbfe2ecea6adb6d826097c1a8633368be877dbc76579e64e4b3ba13dd1fc502936cad1f10429c87ed07e05a78874f25b499148099b65da8cbab50f1dc74b2d14c417c26f3db5d313020c493c761327c9696fe16f13826d6dd7e171c713e3aa129c2df13d385d4f44cd223b3344b182b7b697aecb9fe99f9adbc7f75dfd39bbd94c47946a2c0944b07ae68e6c7ad116a97afdc5f74f65fa9122a8d68502de860b77e67543d9e6dc1c3d5dc87d9c8f87af0b3b2d7483061c7a349d270210fb85abbf7c92b07c4a3707a475447ffa3e5c9a494dce79c11021e609b57d5a77da526a8abcf23d0443609d59984ebbfbc073a75e2f854f4fe35201a9e0cfb741c2ee464968fe30e3c00ebbcfc61d3acad845176e1a1344ae41fd205183c2b3d619d71673e533902a33844b1840283a433409f9bcefd775f819097922c23028cb4cbaf19ef47683916dfbd43511a1853d9118a5d1e4d97bd1e833df787c4c63da57baee24e8d286247dce4adbd7132007e5858d810891a0d420a8ae286450dd41fde22037a12e5c2a67dfaecb217331c8db79339e7c2d24acfe4c667779a8ba438b61421428a92c6125453459d10aa2d06296e1d62c55824e992e9d8518de9cc4da557c323f4e165f975856acad42d86662b7a9a7991d9e6b7314e2a9ac5a2ca6c57d092eb4c39f07559c3a18c83f6013533111fe831d3bfb3eb688cecb44edebb095f1ea7577d3b422fece0257f3196b001ef284a39be42749f3909f18b19e769233d676c9094f99dad96fbc8d9323e4e19843d31590da7bd53545dc672c2ccf70203d4362e23f9a2c5d40f45583d8994690f50e353eed15e8272d8d2688df1dcffc0a5a7e6d19c0e9d57e58f2d319e9720bd60a69a04bd9c8666bf417589499e2c462d9b9d3115e9bd4ed541ac1ed23437db99816870fc36f943eba1c2a10e63667648046daa526602bdc697b89d9643b4c86343e5c8991d5e96d9292ba14df28ba2d2263bd2906d1cab357bc6ad03037567ed9e5684c272d44fa4eb6bae84e9212a844a276ae306c464431cce2f3b0c050214949a8ed5858d30f691198ec47d23bcec116ba471caad78b36f1fedaeef5018056810c3f9615de7f281f3db3eb0bbcfde9c12bba6798d4a5c5c7dd9c0978b1733b4a9ab6de8e6a1f27da3e05ce5f8d41d70ebb4d4d1d48778b2cc10669d375b0a6b66ab743b30313b0df2d2ff6738cb8e9899d7ac99b6724bf648ef2de235889de3f37c79783793fdee66ca812dfedbd6188bc8e7524e0cf3f029ff139239b328333dbb27f2ac7d4eced36b880b219da35669b9005fa8111f66d952de7168b750a8dc8ec094b19a0687be8babff851a2303430b4891b5011d47124b1f1ee3f35d20b954e89b9f3c072f1b7a565b2f48a62c50617e299db2e532742aa626e796839e6599cb45085bbe9edf01e48f27a011efa5b5b3b7730e1dd38f9db631e9a0055431170c98f4d0194e25add4d7d422afe192fbe8dd9a84e36508dccdd88e413dd64d5187b5586d7626ad9b76eca5d37ef14322a2f0eda87fd6c2df80a91b0e5a9694af0577ea0a4f01c729f59ed73a9eab4760f0d80162a830f9e661dfdaf7f6eb7dde55883b6c4a2fd5c3b545c321052bb0ec118523081663ad275948b4919449eb3f71039149d872c8e6238d06dbf1f8b7735c9fa8401fc52bd3172ee096514487d476f127353ff7c44aa19c2ace08747f22dddd23f0ca1fa604050c4a5f4fe6bfdf2b8a5b9f11550e3442a5f4f19cf0c3216ddc5e27dc6e9972ccfc0abe58a181060381bc506eb1879871b9e0b7b219dd5100d5d80a0888a4a9786468ee8c15353275ce2c1c5e3a5947ca9febf61963fda7960920da22c0f878cfec54e146a8a9f8c86ff94fce66aad668f116325bc76b8fc0a44332285886d5b5e91dc891c515544adcf7d5fb079401912803bcfee4d73bf735be50ae65beeb975ddcd1271de9195aafb82d1ce10f1e5125b9d746cd19982e3acbb90ff16de0cff63f9754dc73caf56dd5375fc3a7a3638c36563ce74722829177de2cb441c89fdfe28f7c21e77169fe9a31fb3606403fb3c25bede30d92fa73cf99427abc74a63642d94bbee0ff0046907d90722453b6a307218bc1c38c6ccddfd7eedcd302a7934807dca9ae94e976014c3f838cd33cca1cab8c07b1383c4c6cfabb2acad2b029e2c3de03a7840d2e3f6a4d85b0040eb2d06a5c905077b1d0c431cb6dfaacbc5ddb531f4c9decdadff6ecdef0722ad64ba1e871fc2b8681cb2de2feaaa247f312c3450568303458de0af40d88bf479f4e03972404a7dbb5634555fb7ee0e7f4ae4f29c69a03396eb1730fbd8e1c4fc01276a6a8d0e92f2cca08b9aab12e6f0bd1a89f0cc9312070f58a3cd5bdeb9ddd376cb3b6a2beded238b03902b54b197aefab664af2f28e88f4b6cd6ebdc6b807f99980fbbafbe348731e81b5b023428fd67746ae5aef63eadb10c61300a6b1b7febbbf4ff72fbb645abf15399e2efa47e8da32d4c9ac133a22abf91d0ae94f283e5d71aa20ef4cae7fc3442075e1cb9da4bdd4eafd6ff67e990ce290d540a6da1bebdd352eddaba78fc79ac31133df05e6e8086fdc1732e14d75a52e5050dd93bf037ce60240a2ab6d8d54a4a6ad3683689b76bcd6bb9f32ed6bd830d3812a04368d4d6743cd356906e72ca039ae8a567fdfcd7999736941a9569e36564d1643c2514911fa39b00c5428245a7170232daaa9ca92110c0a2c21781cdcfd7ba0667c9e9b7e24ae3b9675d58e1b5506c012125e87944155af43b60eabf980d172f95863c1343314c2b59c357d5d545bab0866f6ef5e89b7ee11dc5f0cc1d211efd2dc8d12a15362e0b43d261d8ae4847b401e3e39cd2a52e1836defa6c3bf885c29bfa80fed6d8a6d32f84590d6a26f6418d1f51e134da1460ae678b9d0bf7be2a1cfda8cade942807e9eacd20fe5ca10bfa243f73af2fd281893d7b1c48520461b048367f350b7652386edc3d42ae6e33971d7e3b15c73666824e4e97c32d87ea5e225cd130dd933252f396e997975832e727462f77f69ade38a713480b68070b771fddd040e76360dadb83b8de9a6b41e3a094be8078bbff20f8f0e062b412e444678d573b47b5eee6a4bb5e91e7cb8b4b4ba5c4ff84b236bf7c5cfb8c24751c438eb292ac232c1e44b8871e77680d56aaf17a111f41c8669852ece2dd9694871ee6be5bc7f127a5af57128ab3fca908a7ea9db492aa78d612fdbfd67245a66a18c8ae8f4720b8bcff7797feb89c0970f81b1a13c4a4ffcd2a55a3edfd7686e56b335fcf0e41acd1615143b5075df38d41f9eddb1b7926bcb3600150d8c7cca91dc2f6287a268f478e7de603858e6709ca9df90ef41b60db4d50a19f7bbaf8f6ac2810e2f41d5b9c1881625be6f886d86f78fde7f040351e0dad6334046b65e2bd52aee8ea870dd71a0be7d711e876040ba837c0f857e0f99488932c39d6021f7fdcf6b0d26c258273c72cf515ec79cf66ddf40bd2e245894bc9b8427da07a7ce17e9af6252fd0cf685c8e82254333ceac7a99824f9d401916eeb2afe4c4fc8298e9eb56849b2255e60dae8cad8d9e2379b7c470645f7c02af328cd686b8c015ec79cd17bdee9e0cbd965b25b1ddac7f2f420d87f1209cf158b1ede4320269083a26f7db2f8595818272e2051bae17a6209d82e552b43e08a1e1bcd57d9be6e71982b292b37a2e5b9edd1e15246bfc32bc355eada9d7c4aba0e39ca827c01c41cef7d3b03f9dc2097dc5cab860b1b6eab7a7d02e265ac813a16e6d2e224f542cc5fc8df658e285b63faded12d340895be55e4a89888bd2aa740afe87a69d27aba4cd72d76c0d0c10954cd8e987639892bdd50fceeb979b8cbb1ff3f5ecce591aff178677d3a2bcfe7288c9dac18bd27f15abeb9c2cbedc60b5e81a915637529455df09b871abbffd209e5fac401ff1e24776d867776939f34cc70278f32a4a0e45d26431f4dbc135def0f33e8d1ded159e34369ae84b893b82f8c5dd799bbe7ba3b8425ef2e89d4d760c435d4529e19afb5b490f210e87a5e26267a90b9aff76e10cfdfe67d86abf9a96f0cd763cbceb0b1520c8d34bc83965207d6c326da965bc5b8208fed0851b8f3f03eee75e2b4e5a78472c51e35b81d37d42123f05499a833ded636bac73fa7528c14313f7ca090cfc3956a0e566c91fa435b5dd5bfebf6c0c88810fbabbb8b155e13745f5cf9086b69923f2929b7684a7f62353f4df6cff308189ed05ea514f9dde4bc796b58c185001cf647d395a77b0a7707b79f73115ef73acb8e90505635353e16982aae6df50b05f96fbb92b65f813c6605260036eccb47d87f378469946c988e8589b4130697f9772923d905182ca5639c4193a873d44c932345a6c1e6874a5d71a13499aef705883e6931d4201d64d1e345dd7d3ad91aa039e4fede3916d7f20a9c891aa14de4c3f257dbbb1abb9c3fb8628c24989ad1edeebde1ec990663a187a0c83064339b649783844a44d1e1d508ac9be0f7c448713b185d7df90ad59db8edaf7c2d6c9dd86ff8a0373a6d0af31a6516dca3d5425ee47639a8469d8bc5c27c64a3f6dc66009cb3d6b53240f81473c749aebf64299459a4531f05bb5604cc3c59028dcbc86f2e22f36f48fcaaac804968e50b1c1865fe3c81fdf91f95f010243fb08067bcdb66e9c003babee43bbcbd78a0da9cd0f78e838a90c52e04d959e1ecee4656fb3cb411c0cf21c693794897713a2011ef4b6e9eb89f536cbfefb7134ffa66f21941d0995e73f271f76f817de9670f93ef8c795bf7778adcb61913f44c756e343f3bbc13c8c332ea39ecd490ab924063357aeda21929689212f1fc57615c1976e2c3b0561274459c707cd8d921ccbacc118c1173fd3ceb2967d903356666e306595fa870b31234e938d8532611ef23cd804c264ddd0ee060843db5aecb2f753ebdd39eac47ee03e55e328013235e312d1e35ed83b4b25a524cde142be869fe4dc1cf0bb11b46c9f3dc4fb87c42d706c6b34e6707d1402435f0dc7f2e4637617e8a2cc84ff1f59d52b9b84611604fbb4daef488794645c46eecac094e6b910f2642e28dfd5cca6b44c12776bf6e3d65ec8a73bbd5c5beaf130d54453ba183fa4c2e7820b19ed141e2f4e44656bff64212dc5f55cff90be2af74ff729e8023dc9541460b6641a1615be9e27b8b34e370bf226f57b86068b1efdf59271665d143fc792941e3e05b1f5c2553824ad4d158a6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
