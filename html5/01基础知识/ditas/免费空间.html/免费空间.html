<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4282f5b434c38e01e38263f53cacacc729167692cdf82e922ef4cf06797ecb2649b1e6629d9f8a86349affedfa8d84aaa9528cd7c9445b9f1d8161ab8d5e1b132e597fb13e11961e70f9718d83914fbcab02f411de02b9d3287b9658f272cfe443be0df5373c8ecb4a071891616d79284d25cc7313b7a9bda06239ea7bcddcc16bdf01dfa374771badebe15ea103fca9e7f86032cbe33855203303f06eff1170580f0c5ef36db74122abd62f4073b74c4691f659cff0e80b7d4957d6f03bb36830d1508b623d10099d7bf6b558aa5bcd0a2e9dc28300ff91334e3ed88ae7496251d91b8d9ad70853dc20ef95dbbad3c87a77066b361989f6d9fe6a976670acb4f44e24b232d074ca1792bed3d1a0f5670f7f7ca6b1c35cb13e7563da08edad822d775e245d7093154de8b07f203fc90c39c17cc77298f4c8eca413b58970507d707a25b13652335f005137c02b300b1b3b1601a94d73bbea128f5bac87f74bd9aaf1ff3e4ad47b28cf6c12b26cbd7736ee70c58266ab4ceac009691c8bc9d7473ae998144330f49cdd69c65b25cf7ad183380a8452f6a98553ad6e26c4fbbd4ca5fd8cdacb85738a7566d7e25ef8c683ec73a667077a58cf92c893c6cd203dc76158d3580c89f8505d3b1f4aaa674a05427d54685b60485668987198e457e355398cd6f022e6d04bfde8d70c79ca1b755b82ab315f56008430fa11a2c2ee7beec3289041d26ea449828393913090855a422e1459739c0a10b6aa412275fc40bd11c33ed32a18d4a69260a1046ddc934184b127f2b52a712b4fd34f504a094481e4d7741136ef36a462e3c158bd446b6dc5e45059205024ce37618ee5c4a0e24b5b0ec4049fb14bf732ecd61c25b8707cd21827078052cd607cfc653482c24cf4ef5ce2f1f3c7382ceaf8d6a5eab954b8b37e1fafec8d1ad8f326edf5f7b7374a5ba98c0dcb8779301b8e674fa08b1f15b4035ce708e24133ad70c3bf7163192353e8e9c14f6c5b8aa0cdff3cec8142ffdd67ae5379087b64f894811594e646c156da7c6b2fb2b0f899d5e00896319d4f70cb42fc3569564e892dd4a1968def536000c05729170dba3fc542671ed700c0702883349668be998c821c3d19ef6dfdfbcbfc5c73e66d77bd916b5974a0316abb290af7975060fd792ee872453f08016188659fa69ec548a3f0fc53be7ebbff1f1caf22efa193fd8b06cfc66e63399954c6e2bcc090d7297688ce4bea5d182d63297a6dd167f49af8119be54b1b403b8e6012f0b9082d6b5c5c1129136023c72ccbec5a4faa5b67a1f3ed8bd9f59f25b5b9a0fcaf8495dffe92284c5cbfe87317ad79c540bee68ed6eadd7d79f370e8c0f120ffb4578da911155d074fb062179604d0acc8ec9fd1fc87747f7ff0491268218c4672c98b821ddf994949ce230cfae6780b8a8bd30e08957d71e61c139f0398e10c608074f01cb90512974f79b0cf01c6b4fd104f6b5e88a89b0c342f0173a52ec7a591800c6f55850148ee88a3c2c58c8b4329e3b78cff57b60afb8ade7c23ff77af2d6894884cb3916446899f8dfe4c67d5140c32e98a8acbfaa4cab84f52e584d49a8cb029aa4a7dbc718b77f0a8eb4a3a9eb5394f33c04a05478f92c6f9d3143b77c11784f472bafd07bcced7525af760a83f072eb0b4e1ba604e8d0c9fdfe6c7bc428f3a926f71bf3239d8f544a732d916a766addf29872caba30c29f97502f040bc59e1dfdc2128a23650486fe17414a8e24fa6a6efd0a8d968dfc418ea8cfb2541114498091052f00729595ae27d87c64d4d19ed258bc9ed278e345b5d68186875c868cd8930204031e83b25392abdcc703f4fd429428a35816f002c5f925ac3484bbfb38768d0758939ba5074412a5454c2ae46fa8fc1cd6b1636d6995745754f79fb58dab763477e6864eebd8a3c72320be0f883a5ab793e6a3014e874a3b5933d3eb3001a46a6da77406a2355254c9c1b4ccc998cde61afaf3f6a766bfcf6f6bbdd7d54e60d73082a5c571894bff1846f6a7a20816e85e28c3859dac5323ad8f9074de1d2f1ad2c5af3af555c42df7f0ce29e25d8e914a276cd827524f4685bd0b2fcdbd4cb4410e40bdab8b0b32b14f3576c2081bb94bdfa917954748eeb47b65b53bec88db712195a9fffe276c4ff4433d6bf6662428563a94d2f50f984a21643e04951949f6b2e9b1c604297a24df9e0e30b9eabe1b3b0959eb8d3b904fcbad5511d8772d7217b0d62fe3964a9c0481ec5704d8ac251d0f211f10785acfc10804265575a41d442ef7d3fa4d514be13b7308c67978616e568f8aa46afc237c215bea83611bbad7cfa51ef4af121155ef3f356b374090e55a9837dec8776a353e141f5bc1a9b5c2a4f9d44a2aff0a4da86f7935e0b5f3b36ddf5b13c10d7653db9f9d07ab7770079a86e03019e2603628de8a00b3396fcfef5c93391a5af99adcef5659ebaefecab38f2fd694aaf19f3edfac1159c8ad7355f3861ef3ae193d34cdd2530fc7c984da60acf2db49ffe2a27c6b4e64c501634b27775c7378fdc896c935012b0913778a5542e944a8a1a892a3bcaa1df598d1e4787c4f9da36f4ccba4357ad90d76591bdf0304b8afb2e1bc08d309c101b26afcd09e3fdc329415607c157e6702b11cdf02ca3afbb4026b7918fd5b62a2f037e664e7980f5c7938e11c53134364305c8c807d522e8da77e8e48dfc2813edbd3ed4256895750b608c32362dcc4b3626de1a15de9996db61fe9d8f6e782700b3d3666f6f955cd66538afc1733de4475a0562b32c898b8dc29e8038a534f2ca41f16d44e2163ad549a0356656d0cf9b2a0207fd5999f714697a67eaffd78acf666c5dd5f7f3df894cf5dae31a5ff7675f3812974d18b535d617687bb12118b7ef25cc4a19216bd58d12e67426b114de90a2b9e2c32705cadcb8496c8db5e993b43d1f49d282c69864b381130e9ede030f22412ac28ecd4a53f58334d144459bac14d59e1fe0481df1083caad08ca383734711f06d6a6bd413ed7663f3508540e3cd6ea26a8f24cfa1489514f0fc84a2aae013299606840bea4e1b48ec3c14a56612d7454144d9d152530f39c5fa73310b1287999a3600720d44e3735df388ad710de5ccbb41f527cfa02a0022ed86e1410d5148932539fed0fbc35f6700237d220504a993c8ec2063754ee9b5ef0c31e1d27eace76dcb7f806214aed56e52fcf073966c051bd5371b4c993445ede161eb7dbb8913900c4d2e0b42ddc28dec555b8cc7db4dbae7a7297b5127f5413080bbff115fac8eab421989ca8cdd33acc3b262f4fbf28f4c7c1d80b87464a1ccfc4a15301a7dec1841fd6690861311752d6783fc00025c33dc7a259f0d09378d28e9dd1a6340d86e968890e31f90c4140860a5d45d00165e5a383377136dca8bc490ffcd4923777659cf666838e4657fc715ce11bb58422691b652d766c31f145bb1594f03f196ac4a014709bacf2d15f437a1c1b7ba39e0def99e3b7a8a307a5d6e14ecf3b54bd01c31569c0f09bb38d91f37b152bd6b88881aa01804e4b38ff767e69bad7f789ef41d688b478665618c050945ae4f144634ba4300971497369bd6333b4896c33da19ff5f8cb79d0eec060613e988d2edd5d48992ee2afc7d62fcd51d8a31fc1d9eccf9a11c427cbf78f453005fd95ad95b1bc634e042af7e70ea8e49711a8947db387a248b24f4135d0b5a31629858e0d69707da813fe4f670a93279edad81edd6ccc7c1ca5fe27fa3f8f2d48f8bcf6cf8cf0a600e9e9f1e9059771758e94273bfbe441cba26ea2b23eae2975c5dacbcbeb9af7ff5cede5c463e6a62cd86b2d70ecd20d8076a49cda868d672d51dcd91fb047ce3ee8fce2bad92a81c8ea9414ea73a6737093194ee0421468cee53be62df159b9232970b2727b886eb8dc26702621a4552353089fa6b8d552c3e3ba21d63a17ae6b847ac55cc9e25e7d3e4757b1460fb3853396f848781ef7881f985e05136066afc68e5c55624ffc09f0aaf644ac8d9303d806b6343676b2c77a5dd13b57002f4aa8642aa6cb17d3f7df94e40ae78a28ac1b8e05a3b3736bec70549ea51f90acb3e27947465fb7206c331ee529e82269d6171705cd003e5a3b654225be7984e18210cf7490bdc407d87c707f5eacf1fa4fa2640943334160ce245635cdd9e9796ef547d9a52158bc9449aab65a36336aae66e4f5dcfdcf2dd9239210f41bf439b050001d78f93e155bb022ddcff843e2291d2087b400402f848cac43772da6672c7348bdd4720fc0130b4793de6eb87f1d1e999d4e4473516eed924bd400cf4088a2b8f8377ee1e73d1eb4d6d29bfb0767e902aed281e0caabc7ea7ffccf6294c02ee2049481593f5c521c498424d617ea2f54f3e20023165451f6e2b66aedcc5e401e9851b227bb75f988e4903772004e369b5c7b7892abfb8ce91e82995743ac5030a3fbb58e80d1ddd1bd600a43056e72da8f48c3c8c5b8ef766b66015a9e1296f443bc1108e82bb25d518cbc13075914c8f47a07e2d685d147eefbd29a1334a8fee9c20db9c6d7f7318295f6c92c47a6fcf880ba859579137069607bdee0a8e8aa7ef984e1986cb4b72224e93eb81aee2c5cb70ce734f4582ef6e897e7c1edae3498b38ffa27dafe0123b7339edc01326e9113f43d3f2422cd222d1f0236bed80f96eea2ccf810bc52c9dafa74b2e24ccd2a6f632e2a4ae06a8aa59fcf0762ae2e70f823ca68eed1b5b5cf839e151fdb8eb01dbdc86b9276ed7e03e110f00d43eda1e2a316502a1719c9e7465343009ced76917b6534d1bf05abc3659ddc8b2abb562ce9e0eed94c4afa62759da911f00b1e54b1e0e768cff00e480a394d00a3f4be578d90533b7b2c1891cbba2c1ba2e1f6bc9cc4cd26fe8e18f60d14492d713e714d880a573668ee3f135fb586a56fc823ce2059ddfe7217adc8abb324031890ff7a83965acbf8bff0940153070391d051e138e0df3ff43dbedd2f09102b5dba90d825336834eb5082f18a5c07df42d6ecacf25e35ccc35ccae4d3a9ffecdf5d2a113dbe2eb5e233c4dfa6bcc4a66e7d916a4777bc3c95a5bfda33bcb80dd972015fe09269f45f4147206846f538dd4d7a7ddf11767b9edd403914b593586026bba49c838da7e55c8a05f07992cf6ff7f4e352c24287bba9e6ca9d50128e4cb3421a7586e4cbb267a8bba765452033c65bb630943d256ad0a98774370d88531873383ef4972619a3a097be5409e7d9d187dbeaebcd17b8d843aabfb8fbeae54a4cddd09de85d60f6808ac6e2fc16d3490edc02dbaebb1fd68c81b4ed46d8e79297201c1566048ce78311db4c9986a1e40de7cf81c92f6ee2fce9dd61f5ffb8129ca304b90fb67f3f8f2f9b603a1d8f39e268b7b39d2c70c34b01dab070d9410e8a46230a825a7c80eb6dee9d5ffacba2e7379ac3913232f5d87cebdcb36a6a697081164026909728d899048102b10fe11094c6118683802a42a1d862451e247bd8e403e4acdd763f84ac4740962625c3cd8b3ca0d49513a5487815c5bca91d85df7b860c51009ccafba033342e8986360ddbba69a2d88a4b8010344e34bb06d8785392265edff6a06c9ac76b08e3881e6ad2669f6980682957615bb37fc80f0774661f1d71f318288d000b510be5363122d88201314a635b40d6a23ae231414f4c716622c932492d20ab985c24eadbaf323c51fb8c52a30433cf573ec7b83880ed89bb2ab34dc5e60e7466ac7ce699e2a520103f5e627f8ba0c729992e9f07ca5d1bc0ddb90738b6ae31906f55ad4226fd3ab5fd92b32ee3538c00a685d6207574ebcbc15af46adfd07ad81eca53be581dc203db58fb7ca2d39085d5027b3a1ae157f84d2c565d4f659096f16077a36ced93f2886d38f758a1cfa18962d77439c553b30111c722fc70cffb55fb16f767874ecfdd0ac48556d7c4d6991865737b084455a900bc1337ac390e67155eece0a616abf97a3c9044940569927cb7088caf50632e344fda5922f9339d81a24475baa9f55fcf84237c7afd4e77940aa5e461232f435f0b6326c4af70c504362acc8206b305a84f2a4f99bce6c7697fea4039972b91ee26f49be75ead0180761772589c17e03ec51ad3d0c492159ee5d8b212996d8208dae5af0dd038e5bbc41b7b00dc7c3df7bf48f8baee32af23350117d888f6d0c3d746c429ba0e15167f977cae33681d894579fe987b55abd7b19151af7605e6c45eca6e8ba3f48f33a419e6f5526596ddfdc7f6ba9d3e8a425575ab06d70ed5db869b723d8f27a77bd45c7fa5f3a0099e7563e356f04649567fb9e4e62bad79ff797f1c38deb498972a031c7fabf3870bc0b137bc6a7c5192e694327070fcb4893136c106bb96a2756cc6181794e9b462397a493d6a43ded879f42c5d7ce227181dd97b0eb6653b82d5a9a26307b498f90528288390f46699edf1f645119586d8ee7792e39181e53aa93868b5cd0b79f59aef9bbb2e10a3dedc90c9dd587eb49b450410205a94f6aab50bc60737e299624d1954112e15ea0e23f902b89cb3ccd9f4e559a477c238aaabc6105b8508ce19cc477eb08bfd73a0043721a6216e527ec9ab5218c5e81fa6e7210bddfe7f3b5e268b10ff0213bf57b99a65d1e9425b16d9de056c6ef1ec0b6da04d2cf28dd650c9d4267e1752ae1cd2be4ec5a8ef41a4876983451e55d0f2190b838b3f93bcdb58bd26dbc3ae7e724f9f75662a7dbf78fbe986b66c32021316e578a66196dcb3c51fdd79d00d6757962d445d50b25a54571129333b61a5fb3b2be801a687375e0f2e262d4adf139ddd75e809da1c9e30e377dffd8bf7f1477919276725efaa21bd77310b53edfc342dfe3540b929de0f156a091d5c87329a54624aa8786cc76179781490cf6add8eb41843e4a1e3468fb6f66ec4db7169b430ddd375a5dd2e33515ea7fa89fadccd5bec251aeaeab42a0cf611f260a279cb56a4753ad17351e7d0d83710d2538649f7198ebb42b8a078df806278fd511fb02be9d76d1b4e4c06e66f8e2791ed6c60e916707b9f755dfd8b1c168ccc66ce4aeab8c4803cb4c848af7d29aeb1bf2461f1ef8db6d39abff3ec6348938b55ed4d624b677a4af8deeaf32589448b55947e853b465e846ba98f2b9383919c8c562c95830081e2c308caf7227374e8d352ea60defd868147354ebeb64e0d13937b1edf8cfbf4e4eb9e4a516b32fc8a7b57fc3b157952640babf59f44347d01bfbca6be87c3cecc338e6eb51eda56760ca85aff7ef115bd78e84b672f6a0c97c9740e08c0ad2967db66c755be24b19f2d161ca71f9520d0eb572cf7e7438d47d32fa0fe320d52cb26e7026f5a41f5c5fcd2b35fa9eea000eaebd3f91dd0b9b0dbf98352cb50d4a20d3601042ecd435d8978ebdd8718cf5209ee19d7c9e3c4e0390f06f073feb5d22b09a49f759086e94c4b79f49302178486469927f3d0f3f081b6bb7ee37ff8f85c3a7b68a9e3d62c0fd77ce6b244e80f9447d67235fe4f1965ef671fe9eeaf3720808e7dfe00e35c8b2070109364699dc671b9673f500a59402485d88533c13862c683f2c9eb88439157dfcead9d6cff7081be442e21598fddfb8ff42baa58dd9b6693536ad6240d1c3f0fd12002ae831d38222d1cc0669123750c6a118419e1806bfbadc08d8b215ae3f5dd2a15fcd82860dc6bf0e46476c509d0c4325f60566e898f124c4f4b8bb60ebe7c397dbf7da0f05448f996a0eb23b16a23bd42ba70cf2bee3582a6cf122554ab3a40d5178adf0e124237eddcf489b796b02e390b15d9a8559ac2cb00c6f9ff55d9b548d82860de766d6953f1c96acfab44d2dd85de33f278ec70016cf77630ad649f9e6d04ecb9d4341d362215d9a1f085a91c0abedc9be5f9fecd91d794632db38db167d8486d3167d2e1b29cf82253240b21f90f59ee491b034ed7806b6f895408536f9991bad51072e3da4fde181ae32ca6bb0f27ca5580c53f94f5e71de9c351db6e1ab0d83f50ce3ee95b2036cfed5bb57615e24202c19dca64a10c7b44dc57afc2e80b1b76d85098c1e5539e6129814fdfe008e11e1bb70ece21511da8ece647e2ead36ecd1f421afd3eabc73960d5157cea6371bd11c98bc4a6203f63e4f586d4475523a12e17a7aa09e16cb24bffd988f96d277cbd4abedc2c36ef6ed480f04ab8b5b986c95306e1d52827946d326a66e7fc2063e5a54bc439da754b3a78e8e4a2be06eb03d8740b915693cdbc056b4a6af6e882b2b2aa4cd9bfa54569a81c14fd3a940b771c651d0cfda19ffa946542aa44e54ec11c75cdcdb8b1b7b3de263913b870c8806df2edb6027d0339b2e48ece03577c8b8de25617921cc54c85dd4fd94bf9b9f46e14c81ab042758e452557bc97e3dc4e9076c34e3fe30077760416bd6cf0b5ad6d6a4d29d9af8d52de43cd0a4d386f9e4dac2155b856612b3a48709017e8b0be18bd6714ffbeb61fa0b8dfdbc76a8a12acc558738d3bb7980e9ed69eff1ad9d946f984e41f855ecd2d815aade0f567f35cf4239569bbaa4e67387d0a4e64767950e2723414f2be795408e843b020274d5bd81eb0b742f9583f105e8efd739b3e4ee1f787d6569b27f1cec0c88f5f2766fcc335e9f3dc33ab9ecd59d2a0715dc9750d547aa7322172d5f12117854b3e7e9fc3db3b26be6dd9b12ca5b1629093d34d4c03fc9693468bd1543a10884e7cf711e1fcfa0044d9d134c6f5c68cd3de243a9564ac262e6af2e384998b6393011f0331a00dcc276494a2efa93b85abb7d05697722dfe133230e780d88dc99c1c35103dbc1cf70650c8b381d6add162d5d9f74f5d33723fdbd8faa3813ffa1f329675342a8f7afd5c1f791f878249d39d60847f86914b52cef398d744d248fd619291ee3a9c6aced4e685d2014688848f3d8c0f5247288b02e95c9c04ca0ea0782ba6b01a06c80f0e9ea8bf00022f945fbc82a89d0dba14569b152253407fdb4f6bc2907cc6a5c45a4a47e039faa0aabe03f8c8e647575a59904a4741f72c40c730fbe6288d1510cefb2433688cdaf9fb68dde27cf5a4721bdff03ba4dc128853a4f9077acea1fc5d9b803a3685fb3cba77969226801605409136e33db83957b7018b7730f86eefe9cef9bb2111e88b313fdd5c7a4b46dd1c72be69b319220c80b1ea4974f3479832c552c81cafbe28192d7396f239de4c6804011a0f129930a6188a6033928ffb91628d61f18efc24722235c626e4786bf77e004498e3ae8b9bf1fd5fa95a9c7867976ebccfb0128575cf484294d5a84737c50019d0654cb1ca1134dab63d829650bc01c72ee35e47b487b33ad144145cb062f3566a3886fadcff62c5211ebe06ae5d7116afd9171a65ecff26dc0916633fc5e1a8bb49cc14b64b9afd1e23c6cec92d3bcdaea72a8dc04f46442f38a9b8a5af961517634e58fd425ce7a5ff46d96eebc4017b07a822ff86a8a94e17fe6434c540ae2cb6e27fde4a3158a6dcb60ffaaead5a9e66d1fa7a0a24138255b742d2b0290806297b8bcd4f428bfdd5309c8e5ce9a8fa9b47c66ff55580d0177c28d53a3bf4f207171c0367db7e0f2a853f4105bd1a7e664b9937123aa755fccbe76e02daa6cee8b721a11baec2027deab1e0d9e0d6cb1622c42a9ff2dd7cc189cc2f00ec758b3f4c4dbbe8d1d67c7c9815197fa4ce1819228a3870959c5beffe6b247e3aa72d6cf49f3ac255ddbe60e42e2b83882df2fbbe98b735bee741367cd7b511125e5d2bde5e13c640e937d68716994537259d4c0f26ab6731870a5cd94536f6ddf036ad1c21319c36b2518192ba762cdac32adf641f9cf549b2f5ffa741ce3e34e32d4f3f61c5f151b16de7b1549e0426055bcbb155f784df2087f2e496ff0378821e57a5c7bd8bca68ee4044e988b718dc2c2e20798d71496c1e9e805a855e55154a184db802302174c9a227e907c88b400df716a63546f373b0ee8f821cd5f358c4a745a914b47ddde619051c6674a90603f156e33e3304a048eb9e019e7fa37be1d36aca819b41e46b2937949fff78d99351e77baa01e1bcda7fea568a3f0d2f92a2b483cddc3512bd26552cf2da257037196569040d471fbae9649ff5e734b1fdb800649c0ae3dc10aaf2358aa74af0107311d1650538c8e09ad63920396bfdd6a0af43734dc8038d26b735fdc45ee7ebdcec14436ef3015d099060edfa1e4284776adbabb0792000a7ed4f82d5c034c13bd0d367a012597499bb66d63d24599dc7b652506e4f3f1b13f062f3ecdf62533be30d874c96bf83d14130220dacfb554e9774e2cd4a4c18d3cba144ad6c6335ab09fe6b46192ed7949e191accbfac3ddc8924acb2d8f33bb17e556ae0ee6e426d6e79daf2725bfb53ff138013894010fa5b873171ef2a9dfb56a8ac5549200b85c55ca6baead83bcee4ae00b7aa56200516dd50bdc1fc557d88df008c928ff94049e7e879381c8a16090dbbf16f9a3f2efa0691d58e0ee8aba5805f61a0679248fa55c80fe84163e820a339ec98b62cc225bc7d37c6250e55e1611ae8b7905143209fbb65641ae5a2aa981fa7310726e8410a713175c1320b53efae549cfdebe39023d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
