<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"385df33072248b263688c97f539ec4c658e449648040679653091f102e07ffd75cbe168832ec3a4ac91c712907182eea76f7f5ce81fc487bc5305a5d1c9bdf74a0f928a82ffbdd8bb4d2c9564a8e8f09982d35fdd70cf48adf1eb010ce3b94a4e50ff01dee868a94633c853a590a3335191df48d087bf049f94d0b74365da7b2df51606620ee388b07697d4e6b4b65498b6f6d29daf094cc037620a14c0cc020bc36940793dcb21dafcf5f8c40963f1f06d6b0b8b870474ed4c67fa97a8c1b2c9967b53460ec9404548a4c5fe470ffa9b5ec81616335b77fb7fb950eac930fc97346a0d09da735361aa0e217d55f543e3de8f46fdcc21aae863dad17b99f95fe195f4ec2441d532c808366e135914edc992de68238696ed2f73e68a786f379ba5d27d38c93c0d212589f1d618c7dc2adbb3450fcf2aeaceeb89e68eb861b0887fcb830dc23a7e650f6a571145b6cf06520afd722ae0f47aae6b1cafe9d55086cc89678fde122ea070ea9a3da6155a0271cab4c2c02c2d0e80e042c6d7dfa4c2bedb5dcb2ee65661719b5b240247a85b14cc73d39c8705ac08c502f109b48300c0c1503d675074d25910a6d03f496df8414c264ef1aa8dd88119227dbd0af7fe0bdb671a8c6c7785aec0d47a3a8df4a711e3f1ed49e6e923e968ece71235b6aeb1afb1693df3798a328966760532971b2bcf29ec6177a46cec2b8367233cfa816a5a80ada786f096c785f4eec9d2c14f7c804d45a839fb8ae32439666c85ccf37bbdaba049fede05c020b1e59b05033dd5e192a644f63b355abf9f294708cd3ecbaf1be3ae2972e43ec070890e66fd260a7f9add1218a872e0b533f383e8810e40a8d24f9335ad0725e9a45f070e1e143b958da0c8b1ebc614b00c572cc6f6c30acd4892e3b6d1d98c501f53d5e8d0f0a766fccd1100a5b59eaeedd6ca4e46ac51a3a8793422cad20cb74297066f15b57315f06ac24b2db08431151bb55cc21e3b566fa60e27c6a53979d6ae8a65761bffa59a54aaede7be3dbf1e9e0f591148488a55e89ec8eeee9246d5e10ce6191a9148e90948f163e7062fa9178150e5cfb904b84c3f879b01b4ee2a8a7280e51aca37e1ed955d368e0223c5b1a4ac9b1ba12ba26d3a35cbb40d85be3a3484a0a393149a0e36eb3ddf8357e15e3fa73f3636f32c59fc13ad28a6243affe2bc41e0c5cc19834f580297e7edd6d410fb4ca84cd500098781ab3ec05cb5dac8a5933759df8fe289174aecc85b001bc801cbae4ae2c965fba23dad1268af09747f8adb3f511aef85ad72e6c73f2348530023c5a72531ebd705e7601d7d22333d7b84b98e0020fbf6d43d90e2f3c1485e8845c316e52f3afaaa21468dea564702b4ab8e15bfb08fc16dfbd86a8c2288eaf04bd03e9114cceb8b1ae5b36fad98cd022a14f612b7d8b494587c482d0aff1fcbe2a5bfeac59904110972b92b6ebe39e1a1e51b58bfdc9870bad2e457bca96c12594041a1279df8e1dcbe244364c750a9fcc1bb94f7858be4434c9a2fe3d6f0d9e16abeac7baa7aa234dfdc913c996409d1c13273339b9050372671b4af740725792e1a5e05080c72519f0a109c071a1879d95f1370326d5a15e8167504f91ddc6417064ecb4fe1cdfae73b6f79124872c30b7f41e7fc5b8d8efad96ad25527ea9c0fa4f506cac9fa6260ceb1ca7d36dab6daad24ec9399eaa9d374631e3dc9524736d7c9733cbbb7b78de1d15b2391314e07416cc84f47b73c7d85d37994db9242626b5c20efca1e019c139a319f67696f96dcc95c17eae44d632cc64f5d8b5f9668901fe911f8dab6f9d89f206d29152922ab92640e4719db989c7b96bc6b72af9485a6724ef01243b96f084c92632fc52f7d2691bcb246032ec5129b934ace35303491b59321a43b2bc3f75b644cf599f2b2915e74e4e3be0a74cf50384f6aee5eab45650de54746640dbd6ef200d74df1e3afd223b41190826db82d41b9a93630df1cfd31d87cfbe09cf29508c6bbfcc188562a7828c9c7ca333a3a5e20621bb59de07d99c3f3617ed299a69c59eacf5e6b40498cc45ef9963ae59fadc568a1acdca029714ba53d3763501da0ba6d47e1e25f441944593d0b44f1f4961dead997b912b198ff33cdeda28b8b0d63954326477dd0267292054c249c9bb2258edd48b539c1a67c3d87b077b89c4829b70374c8dd6fa17a6564dd33c2d789f1c383e9df7d3f46d89ed4a48531fba1c1cbde09d4dec2b8fd0557f59892ddc3266b20a21d21f3801aa05cfe687367249dbac5aa45950e33f2cac2fffc46406032868fb55c3793b96cc6583850a28af4493eba16a3d8911ddc97e7199923b6fb5ec53fdfe471a5ff1bc066ea02a7ae524c6b56dadd97e2c2ca13796afbdafcae784a38b5edba8dccba2846ee7ee86c7abb9b7ef1b6023e0ba832eef4db34a3073dfabdbe395e4095600656e8a2dec20ce1aea90583f41e695546ad1ca10892a719797d778fe6844896fefd71db5f10978a013fa5201d0dfa4f4b1147b9954db80519610e2562d35157f6121bd3dc99c7e3b640e05784d4975c5ebc89ebe72c71375110f09cbccbaa633c6f2fcb459ae64a9f6eccdea4b9e29844576dcfb3f46219d81988dd4e7048dcc9aa5a2274158b073e5f24c4cbb8a32c579ba6209604d0766ba8d34cf731e9b13fbf7c20647095c87bfdcb49b455b54298a3818dd833c53923d73b5d384b6c4de4bdd611ee83c288ff9e2ccece883e6310bf5883be4c8dd73de5465a6c4600de49cf23d94b44964af30cec5e8b571867c8fb5465366654b20d57ef2183ea472a54b8de5e8409c85756fe543bcce3fab09f07b744ab0f343c2e01f24358d7b0b3fb7bc79c39dfe0a1bcb21d779098c9dadbdeffb735f2d9cf977994d167692461605cc10385433d1f20393bb68794ea16a538d1c498f3c6299f4aa0a8f88aea6c7bc396a922f83e30b70e2c4f3b39d9d53fe14c8d79d3b135a44005113e96ccb57fffef1698982b27add452b97ed6fc53957db67ce97a23a3e5ed90540e8044d707abef622d2b24b283b7a0e580dd675a8ef69f9c5be51a0c09c0d9dab9ca5a16180be2311fc7c9798962b1e646718853de1df26114eb2b11f6ca73f267572dfd6207087da9fa08ef9cdfe3847899fb8567c9c221ba4a057a77aa3dcfb52d6ed60d93606f9c7827d8ac44d17d0604ea0108f7472dfbb84589231c8ceccc9ba5f7427ba82467fc3b0462c24b253d66bbb5bbcaf5979281138141c0f13399862194b4e48b3dd6198b379916db579b7ba758becd6fff804dee8e937b15e067f5542079b1b4c767321e274da943925f758dbc4a7c81605c44195dd97cdbb5331d10f1108f18718c51f028cac0db04d20e23c3308d24c4f183bd3b159d3b52fca4f2f224ff4f81bb30dec49e8d5dc2d8c6fd31d2c2d4c69e47b4d3086314053a2dd0fc046b7fac38bc5adcc1e176a57b11bdc60b1eef4fd87ff4fc534abd92f411f004c76bfb9c2a5e766aa17ad7a94726bc1225501f06f6f7a4dc9bb6b06466f1cefd26830e798da062dd273df793daf058bacdc98d7fa1c819e8520e52152a3f54ec2d79cdb3b6ac852c6c4c88a826e3edfe2272b287c67a4fcbffdc9f6b0d6583ea578b02f20c1e65659a478c6daa10403524cc3adcf1ba6fa674ddf43eb3622d51a209415b94af9c8375cea4eee7a184ae9ceb4e893a1812d45a2007cea49ac9ee6ab00b3d586cf2d38182c1eb95880e73d2481caf3f8861c17bf82b00c8fd54b34ad5ebe4cd05273a430160c10d34f5394a2df3b079328019e5b303a521202cb69f1ed19b0f1f1b0f13997306a9b728a5c191bee714f0bc1b9be6e9e9d396be3ba369a71676472ed407397e836addf5632aa39417de8d85881eeb3e78f7fabd733a735e0def3100ec57aa2106462f94c1e0166a66cae3a40fae07860bf65f9b8ef396c16202a45bd695e184eb30c390702d5af263225acd3d690500e7a6eccb16032e5e23cf70c98087bf88f2be13f60ff08d235365ffaa3b50eb693fef1a9a6d1a79ab08a2f3ec54afc4ceaa06e5748eef172642dd532279d18c15e4d21d7cfe99fdff9d0ff7d449779bb4e07930100e0481ac1b818a250b6e462e82b86c6c866a4cbdff17942218b5957b6635b0f565ec27e62bb67bb1576e4ed33ba2a41ff9c5a6ffe9cb1870e0372e893051a82e5c3da54dac174e999a8756670aa1955d6b0f3b5f5ae574456ae719ee8b47980afc202a5995b1ff157e2ac8e340516f920c3ac52af997a1e845a6c4a489d29cb56b4648fce3a3f6d4ba5145f0447843a5130b5bcf1300d237daec4f2766a2fc5f1e4832e2a7807aaa4ab0b9929334ff7d0e85d058e366dd79b2bde37b34f0de09632f91bdbd3975c8cb7ec4f022a7e34256765f127eeebac4e3d57099b0a07cd895cb7920c411f9b66abb85632e615e8735a050f23fbd1e1e78d53c81395f4939362b63d082a4ecfe45950fef924a41b23bca2adc62c9f2ae55e23283f33765592b03d700a5b9618127b2352bae35e9e7a5d0cc35ed2bd636d1135d1947580be76727c1e6305a6a7cc69dc1453080756a890578a23c00acc834cb634881e921a58e256c7adf0bd1b4e7777b93f91c4259dacb2259d88337d5ec1c229740493dc9c7428522c0ef4692315d81836c475f15c967de7ae1421bedcd86d0c8554f895e050c13c512568a1b34dd03c94ba4350ec836d43cecb58c8e27e7684cc93071692b39c35548d0d4715b92d07d1d1103a18b03380f4e2589e452f4fd28519723ad69565fa622cc734506b096fda1602ed54f7fa7dc1706976f1f8ad7fc9932c5cfa7cf586ad04b12d3f26fab97d42f9349872289b4711426708d2c405ff06db6cbc63a54c516e2501708aaf64f7ed3670c248bdacba114af3af59d587d78a7f32faa34e9c330dcc2a2d393f80ca46a7ec70c57c233152e59a3779aef1d8f3646f41d29263e708cff0798c9d49346144e500c5e0c5365fad1a664f201276c4383a6da175f7f25b0545ada4c7e351f29f1d103f66ebca95c97d797847d441dc024859de3af5e79620a39a76ee98e6913e5790be892a23ff7d972ed1ec4e5e689ac30bc1b9d43512176dcd17885b985a7984bd8d7de57e774c546f11d1c244919dc3e95dc9991354f465d10ed0ac5628ab64ed049ce7cd52471b6c66689111bb72e3e0649d91671bc54e51f3088ea4ae6e493340021f6aee9d21e93723b22cf02facb247714bcbfbe898f2044704d9d7fa90e1e81ca1035867095784ac108a7b2f6fe65f2d97159f410cf19060a4dd75868c270e78d14d93d88cd017b7b986d02b4e83f1223bba57d355fcb9592100c76708aae7eaa45c4fe1545a5da55c60143f5d231200ce1885dd0b3c0a76dc72f6b9f5a5ef4c34f9e92c3c19837cddcb24e394bf41054d9d1857b9301547541d344608264b00abd31a7a8dc1ca83ca67726673a4d2586316176ef74225f1d65cce95310c6f69802a6e2f434b2507f1bd7393f72b995bac06721f0f0715ebe87a44d05b49ddb92263e30e7cdcb98e905445a03cab09f0769d34ae15670f94bbdec90c82c9882a6bc4aced8827b159ed29023901b5340b5dd6f759f0b0c496768af40c7d941d586622b78322ddd29ef74097f5c3e14b935ae9695f37ac8106708c8167c114d3424095d1e34a07f70880b8bc1a3d24153f02f9be500e6a66dd574a3b5b5acc20d63512ce48ad995172a672775c047125c154b41fc51072707a8f5fd3295fae088bcec0fc2d908fd74f36024bce3d99d68bae945c40a7cf29f34c6fc064339be7c351b55db79a6b4e0ef443486d5a7f22c647e029bb31540584c6b0a399b3d73709c98630e28b0ab6715247a2eea3f8288898d3c3a4c4c271e9888b6c252e29fddc848e271265e80e4cc7b38bee63a586ec8f2154c21ec6e5cc46e5163e8782234c69fc3cca473be6ffd9e2020d99eedc9478d5f673ad3e6e9719f9f9a0b15bf85e9229a94730a27e7edac0efa058aa643e0a868a2efddf9e6b7739416df707491d2bbaa0bf9069c7edaec7b9bc569231ad07701a98bfb7eb685307a8ec357838ecb1aba9a571f01357452826e9bb4f390bbd168f3f9063230f31e96fe4485a0c8240ca30f28c3556ae1a23012f8c30e519ed6eb7df3f64a20a7f75ebb1ecbec622c84b07c041f7afef6f32a7213a7aa27708c80b519338713b79901533c0e4487df174458a62814307493733479b3f1ba18293d95393077fbdddc26390290e1ac013a753dd0eb6d1a8c8dc88ad43a295289bed84b60c1b64759c44774b2fe4ab589c28ee4f05ec9c3e3f8914d5101a5a144f76016fc96c74a591d9bcafa811282579c20f4cc53cf3ba40001317aa4a46465fb1aa81fad75191f8de9213c0ab9a60b118bd4712218fd6ba448a16a63dd253b0aae7ba7643da660971a027298b954dac66a6e5e7eb58e97496bdf2a353253c6b24ada278d2f35b9b27671eef2325aa91a53d38ed5ff30c2907084373c00523681722427618f27ba9b6c157d3f69e07e1042d84f315a02c31c4b8fe9aeaf04e7bb9319eaea55cfca1ee2dbb52c811ed0fbb47f0c628b6dd9505d3617f3f95463c2b4bce6e2118def14cd3a35a79bef760abf7433e578ce231523c05bb2d8551d520cd2222cc47af81c8d6675c7f37f2f6e66f9a6d4a9ace372c4d4a752928bd94da9f8bc58d1b4a879ee73d5e0489ea1d9ed71712d601103af1f65973a7a64734098a6217f9d16b840982c4f293d76c80105b48e96908101e4325a89e9b0040a70e8da4a2baa38c890049ac04ce184839c89c043d7b9f967510654000949672f779dc133cacbd8571a338dcb824d3060afc8ed3f70512948f1269a639384f97ba4f7ad7ea713c33284f56c3d9026751fc1f0ddef27a00e279b2cfcb0220386e3a0813b62f378a7fb1faac088b32a1d0b2231f65277d4f239f9e5a16207993fabac0dd8a6ef4d98456ee6d18e337baed49e134fd999fb719386bed385f95017d0143acf1f9a4da62267b79e05c056d7dfaadfe8b12c80e64ff8af3c56a91f3e8dc7edda17b8d16a905d03c1138aae9f04c3d3bfb196d5ba5cedb8c11883351d67dd7f991047879c0eef8107b066ce83308dd87c9dfee9a67d476777c60db593496f2155647b635039c2039cca8921734e97f954f70d1b83fce3bce98c2a35eff6f92465a5b66b2bd09c7e6f9129f787f185372782c331aca67c4508b10c328f32c218cb64deb75f75fa4ccbfe5126198301ceef6d969ca1bd24da6e84f3da513045f9d6871e560efce207a18492f65b82acb959de02a172007db5f17bae50e793fe9b4a8b7689eee5074ef2465eafaa66bf1fb65773e3b0a59cc5c049db86286da929f676446bbc62b06646fcc160db979503a642efe21974a0455054b861b072e0718e2d89b94f6e91beb0a89b1b1b4d1fed4a1402775c56fcb430a395b6a322ef132297f6cba76c0e53e9f6d023ed271c5b32bf8a41c64a577de964edde7d005b2c6d9f02fc74579771080255dbd784899065a0d2e647b3099b72108452d423b8e102fb42c82062425f4e01fce6c6be54cafbdce463fd5c68c0c5c49e0eb2f184f1e1cf15f393dc43bb4b596bf1fc9de0b56a3b835e85c6f95eaf284b4687ff33262e3be8c352a2d5e2707e97c0849031343d363d79688cb5b80ed873bb4f473604accf455471664fdbccd1048bb6cc3bf43ed9a72a0f3490688346bb7500b8037f9be399bc30917818821f12f03c3f1992c49e0eb30226a6742c85dd3352cc1da21adb198055a81e273d7db12a0b23d7222596bc99800689936f4aa82493985a8233ef9982a97dd165b003deba01b986c14e8ffd6f0b323ba2f4c860bd07dfb434f7edaa9a65d622d5f9d1f7603790ec86cba7f57323b793892c4d7e1da86b854b030eb91b4a85c65481cabb13cb08a0bb8cbeb90643408a2ee953c8ffef2be9e1d9b7b26edd49f5d2c665a29b8d583a631fd5dab582c745bc352f8b1a01e6d44ceb8891cd406c816dcb6b6d6d14bf3dcd7be2ec8020a8d6fcb231a4edea61577e9ad29d4e392555ee31fe7703485182c4d213cff68f0fb910509017946a317adb456941e1222aab73e0a20717baa496dffba00b1e5d6c673a95023e32ba8f8770fde75cecc3f6e8e29ee653dbe20fbca86c22b7ddab594b2f5e112a1844d8b66d536385e35d2b3f18c7bc48f0c64b30efa5af412d3ec4bd5d0cf279a9df9234d06c695822a125fb73b3ec4fd04326c0f1351370194deff29426e58f70a05ef5274276e4ad0f27728ba9bc9c325b8dd1f47977d79b7f1503c20435fe1d72ddecfd4b866529a990168913a65d217381244a401552694f542821b626feddfb79bb23800ceb1d045b0275a40aaf552c29aac5abd53fa595335c5486df3d2047b4f041c29beaa1965c2b27d7ba021ece0b2faf7a2bade397f5a2208b5226a58a142e07a3157b021f8a698f2850c907fdf9653541554c5053a77362c5bc814b65363165a5cf8ec4b72c71d0002f30b2c79bc78088bc503fb062ba8f7a4b5609797128ec21e6aaeb89e4b373a68b2752226ab416e6948491549989ee2b0fa40c5030863f7844f07219b69e279a3017ec9372cfe8e1ee9e4479187fe937c5fe3f8d14655b259b634195c4517a924ffc36780c38849f1faa8a22b1ba0002707670b9c168742a48de1e4602c84d4a0fbdb999d3c4766ad2be5101b1a85c31e8d5336277cc6bf159204b08d726c5bdf34e2dfde2027dc77ad7a1f4311ee63aff27fcfa844b791f2ec253536f093e3160eb79c678f5030d9e66075e247ebeef4e7f88bf6df188b911642473772158efe45e323c3a4eff3494179747aa5a57f1640fe97f2ee58e779ded446092fce7e683b3ad3897846d06395172850560f00e563e523174b7b2052b5e74d272500b73b608a83607e39ff6c2a2825b5175de6132049560b39d7356efb1856106c445f144572abad13b8028edd4ac6d8f87b0815e283d0ebd921745771cb166e7f851ee5d831a47051c615ef1faeb60d93919226b87280a62e1c56189ca5ac079f9d84649389e0527396414b03d645e409b254e92cbaf2a94cbb0ab5d6d4931bc3c5e07337460fc9940aada86bda078ba7fce29c41d274b3877bd13f19ebf62e418fc4be0fd2512d7861e0f579643d301370a8aed495eca483ae479b76c52f8a364263e4c796f6e7ba55f545e7b9d11f2e951b9b3d653a571ae6aa6cb981ad361b11734c2e11e531107c26730b568fe03a9dc819e4eabb60fbe3a80c2860b91ab74292cf449bca4100c980b8cec20d838274a7e275f6e296e6aca82c36658bec11593c7f4371eeb71ab89fda17b54fd19bc67227e7222f779d33c2c03a766426e7f53b319e8d55f4cffd755378adfd2e5d4a8480d2414118a7d835612fd91ca0a0a64be2ed6abedf61ebcf78566d353c718490b0888bfcd0fee026ad12961416e14c081faa4311f1d7288f35fc8509bc0140d505adaf3f1f948761c4c7193e58d0fe5293e95dc42f56a507009bffd725974c7e14fa9b329409e556982a3cc91242a558a18d6d6f5f7130a528b253c628bbe6131f451b19e7c3e015d8db706b484e594991a204a57abbc49f5f3e19fb2e1a52100896fe77a6a52cc19f93f38ebfd522cc357c5e1740460c52e77fdd56c19212be0f7f1a773ff5bdf46e59af215b4d7e798d3f5dfa2958eb97c3dc5c85b2c132312b840471bf6b9486f2091c56edb40be223ecf530c6ef420dfb72f3bd341394a6c0dc9a8c765f1f668fe01052a7932a2816807df0a888968edd443a7fa3f6ffec94ae1d1b16dee915bb687f318051728d0b96ba3c79d6c5d0a5cc2d54f71f41bdf70c8cae84d63e7521fb774c62f3d788899f331f8c6a8fb52b8aade2b77c451175eed6c29b0f681efcbe54b89238fa58b587ac36d540af040bf79db512fbd6ab7d218b3379bd3a41f183df0a5c8e41259110c92b434305c7abb45ff4c3365c3fc849ff644dcddd40e963a571a66098651757398a2447346df7ef1c99bad2a84b3186b9ddb63efa874d9a289c869294667d34d0960c404fde9f556cd3d169c4bd1f7573568f6766102f260371df6bef96719fc6f3bbd28608f04325f65748aa4d6561b32e19a815683f2e428e8826ae0ecf83dea1fd9c1f4c3dc4b0c921b4556a5d996f71c1b97c2d008a0bbcac9cf23182104dc7d2101bf9f8e3492d1717f673824f9aae9d5f13eb7a7e956a3415078e0f96c0ee693fa7cde650997cb12379e3d22a7efc39fd3d5321c594e750ac3da5722c96ceee8df384a563cc56a0d8efad479d87aeb8cc19ecb1f9f97807e4755f06705d82145f67aaf9acc7fb6d3e20288719c6d88cc208e2e9f8bc66170b546d3f0b3577d78a9b80e15ce0e855c37fbdb864a19ef4726d8e8ae83a1f2496dec59a6c67288c6f84b02021de143f5a8947ce94c10e1b0ed855d055ce30d7bcdbe70f535d41b17b60d53757de899eafd4dec4eaae9e62aa52f2eae409794debbe4d97366d82267ef0be0d1a284b94b2e1a0c800f7492daf00c571b1c598fa0efa3c073d41645d672ac3e7651fa45bead514bd9feecedc6a78c68323556a5453330dffa5c1d63b7c7ca712644573e327d168d6b7bc44ed547dd359d9a993a48fb10b0deb25e754f165c058a9f54b2668b22708876d242bcd450d259d06952037961e1673f8f35d1152823544b81377ffd6fb739de0265433db58c5d07e234e5fbbd59d99b1fb7d70ccab9221213105433b9102f8fe67245f4552c8d992f05b86843abdc5e47f65d3f6d0653e635961b5b940b4e7a9e8fb35963716e4ae61a64ffae7748702ed92111ceffe72cc12b7f68da4c70c4bf57bb5fd8c37148db22169a5575d8e9548d915bec8df9aad2fea871e5f10b66a38509e711bcc9a2925c3576d77369d7610c158631a35f6bcf56317a2728a9136f4d6ddf22b340c978d2fc28bb4e7ccc112228d5193689363f6f1c67ecd56c8fce318e8ab92ba4528570f74ad65b749b143641d035f7d60c67b182ee5d9cf11e66d9956100ce71cc1c98b65f40d52966acfa89f93b45f20de60286bcb629762c5b71422459550e4df11b5cd44a74ad34b432f37b94e53b901c714f73049ac83b357c57e1148a009c1e9688437e94ae65929eb6804b22a77f51f7545e70044fe4350d7205fd57e0ae6dd35c4168c13e92b76a4844ef0a607033a6140828e6c551d1ac329138d6558cfa58919dfc6402ca8b15659e5c3f461c90480d4268f0018582f85f6f4d5d5d8dd4c4f70afefa9715f3105e536928064a51ede212cc02f1c3dd1c8f8ef4445abc06fd9caa4fb83a7dada445c58cf73e8d7a15d333c168d3ed389d0dab715d1b7cad3b34bf6a9787caa48a8f8404bb0e833553b8ba4d0f93fb4e926499504e967ca3292ed57fe7acdad715eaffa6bd85a4cdfd6dd36cbd0fa47409344f4662dc7d0cf184804b49f01dbef849adc4766f04ac68604412cc23a2de456b9bfe66b2debf2a7dbbac7b6e5adfd0813a73300f1c1950383218a2470a02454edaac7f94d4e0bfb8246019016822dc9b0effc76745bca2570c22314481faf69f1dfcc576724b8377f24784973b3262ad550d65ce04c043ae1ad70d512d7541e0f58c539f0f48bbdec340c2695598c6e1940ebab98542993e5a64639bca24ebf7f9e9a2848c49f3164c8fbc64b35fa9d3542f7ff512d7bc24935e5f96fc236cd7e35f15dee0d8ce3b017ec7b294dbd808cecc17d818551b7b2b5e915c0fa9ea7b871af04cdf0e556458f4258ee216b4844a4566c842e98e048900a7c6487766057fdb280945fa3d46a42f67e2ebd797f3e81476310b589429b41f5ca21c219741e2a0b3df38c623d67fe808c549455b46f7483610a1480d1f4e2b2f20cae2c3d1188855886b4ab71ce7c3d2c05bd855b823b28a7bb714dfc789984d6536f96c01cc4270bcf7ff2b9291f8eb67cb915b998b79b3c0dc99ad813a23a291ff4d09bc7a76ad14ee87f9774e99fd842fd3789188ee9866b9125bddfafcfee7738be6ddfa55e85ea4fd3337365edfbdfc0c24fcad12eb6a19a0211456e2be0ecf36ded981a8712166f877f853ff21b1559cc2327a184a4a5e2c88ed3cf0e769ac6849987fbea392e8a2c16bfbfe2bb171e59ca9a2b77f091c33a43cf7d56d241cc053706766d2b6125b55aee671016413e4181405becd03519ecc36c436f7543f6babeece0f25eea2b298059bc2bca555349c47800a61129b71861a6e6391843bde635fa48790c50b3537e220759f132c54ea07b53992b0b6347870aeb258cc32a22cde31e77152c579d1bb395a605b6e67837fde99a074a2c809405427d4c1290583d313daa5947d9d8833c55d1cc814ced428aedc59ace35c85d909a55f5d9c8870db95ed9f0a5032374197c78ecc382529279371fd4559c9bc6d358468813e3930a92d8602718459ee0a94338a9662c9320119f5c68d54b9b4f1e86771f5369501b7811a1a54e8282d50170ecc5559a11149e9288c2743a5a150c4e7b74301ef893ad166826271b733703250dfbd3206b00697154b9317da75ed6a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
