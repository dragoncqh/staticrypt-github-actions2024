<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"428541d329a1a20ad179f751f6ada4aa6bb626fc2930ff513354fe57cf1f4489c9791b6e5d2e560f513454a0cee75078f32c1fa5bd0f62791b903066cbf12e004dee9f1b636a9de420b0958ba352c98b3e26c077470432576940d17824dd3971fdc2420441cda071dbd11966748ecabe2e7bee155e5bdf8a0a3040467297b50fff0b06ff0f2a342d281db868eca0399319207c8f1c154fe75ab09dd5b8839f293358983122a445694990177e211da7fb7124eb8341bada10ec898f429ae0075a4db8ea500ee1308b9e9f7114c06590db9730a81c36b1aced16994e0f895ffe63f519b93968aecd7ffb3d3b74f8d112ac70d35ffda900433ac031ccda8cd3c4333e65b7982d216ca9c907780df023497197307eb2e4359c248ab985a64d776513b0002e3e1bdae70f5538b2b5ea5d479dde263b20dd13b768a287eeb1a125e1c79c3690f71aa7fc21b41dd865fac14eef4c6b2a39a08b5335cd62578189976ce68d2bc7df1ab819864db8b5f673ba4d50124bc47b388e5b5e617e6159f08af419ce0ad5c3ee9385c63068ee40eaf5eb3f39c33d8aa25b17912fb2a33781d190dd6ab81ffebc51ad814c1b3e8ae5386f15b315fec81e1d04c6bab8f0c82d1f43f307302e34210d74e126d88fb981f7fa9a86c62c1d9c9161167d6926d5c5a224fbc568116f9428ba80f52984036596d52948786d5a39169a4c11f1cbd47d2e7e4f3e17bac39613b445bbb39eb67da3ffb6d9271af5c8f2c0d1f4f4612c102bc6b8068e0b4585771fe9ffe210edf33aa2f800578707abe390c928d44d7e55465b76d6b0b3e9414daf2f522764123a29846aade1b946773585c17648de14497c7f502cafcf60e60894e037572a8f53d8c73bbae10c38b1bbcea437aa18139cf6a16ba9c1f34bb908392ccb2bd8734683d2ce5b4a769ef808af7a24826bc251752f410232af197a34308bdf6780cb6d1795f291eacc36fdfb766bd45586f2f9951db308cf2987f6d7e5e5f4cc030be14bfb58d79937e44667d6bef5b411fbed2315885865bcd5fa1c76f5474a45f06969033a1691191783bfefa6ad8d2019f5bbbf0e951c9084fa1899e5925cdae626ea36e0d85b3ec1a897ad48d853bd37cacdba39d45d0eb30bb1a91a928fb90973c12aa89a0ae9b9921981c90c4931101d3d427cb03984392ae62694b252e6e9ed59d563a8712b78ff347ca3ddb74168195436e32a3405033a2bca931ad0c9fbfa4e26d8a39542d55a931071efd2c41cd2418754d13e3858e8eedf8d508fc2dbae5b230ae1054d63fef4a7c058227eca6b27963f087b8dfbfd0888bc8649e474709fa46714fa36fd081836911e57265e6fc4762b993d7971e1de07f2f19771b628be56e52f63a758d4f57c2dce4172293fb2136e0cd89af22dd2f6d6f27b73a4fe1f55281d929bd0c4f50950087fa2f04506ddd8729d5e7c0f75647927f02fb8800cf44089074483b9b517887cffb818a629ffce3f9af76dc2d14e903fc31ed84f8454ea8e76fa6a3a4d22217fb37a4fb69d55ff5b5575d709d1690f464ad6f7ad4b04dad6f428ccf7b03de551fe38beef58fa25f245feb9502eaf569519f4eb20cd2674b530cb68b823dc8be41ae6ce08a15b7d91b11fe9ac2a767c4be40889d9fd69f31b764a6c50db80f05ffb3612b7f8135dbfe6a4382d768298cba8b678302523e7e56f46d387ec7f1f1c7101b4c490204d4933caa319989e02920e9c5b7af17ca976164ef5bbbc2c79b56e3c7b758af987873367571f49b0c637888a6df97b2c0279da4a3de3aff80ccfb8e60515d67ed307ed8eee6f5cba34743defa746f1b0096ab216dee0bd51491fd74eb2587320f30cddcb44c02c8b31b92010042d21707c40222676e7935fa6b2b87da8766185878222a965d3518652da8501384e8f263f319bb09cbca374de87ff5cfcd6fc4025d5881c37ac7fb51849723b7bea94f7acbe2be29dd8def4d7bf17016f8f6fe106f8114acd6f87ccda33f9189e376322ff9f6bd70f9bfa64a5c2a48bf33404321a91a38438ab7637e4f7971337badf687a12c70ba54293271bec95afd5501d3e4bb5b9924ecf9c1618f48d5c313fdffff2ec999c960135ed2a5c6e8863b3c1963d0abcdee41dfd964e9e712fd9df08b2c52a3bb03bb01b23d311e053d9bd02df801c3de08bc7b3066895f6a752f32a74628af8cd5881d337c19b639bf630f1bdcc26b6b7219c55b76e1ffb7d00ae222a5542faf8be99942ba5a382da2765d1bebdd01fb1bb347be514eacd5931eace7edaca33cad690a6e2ee5ea4507dc228bd3babfb069bdbc000bfa3b766c20bd89e3d1f15f5812bb145138ba7dadab56f7b491a5f8d9a72668040c0cba890d350da4ac322a722169b3c6fe90657bb91b8a5994a1c732a10a73bd464ff716af091b184905e6ad74c323e57635132b32579159cb0f1bbdd6cc22da25be3a46c95c5d0ef569b083a19aa8ecd296f6b068f6afd3de400004f52c7517b569a92accd801621cd403d2b3e1e36c00fe2c005d331bb75bd6fc960fb1cf48ebd9aa39b215e4202ae27ba3d6ce1bd3c472c1c25b1c292245e02f214ad3c7f178812989da69a83e900c4cb2662cd0d2a1d25ee86694e4d226f9426adac1a4c71765fae611788aede5752997852fe0a852dac3ede7538249cc138c7e76443de927a878bb593912deab63de62fa2989642529077dc68b710410739aba1f109618a27f5d27e84da3b6433a3f6fe2264e88df67c24cb885a3b5b78b31197206b0059341f79c015f18c5bde038e0b762b3b23f4f3b1d8031ad73bd9c2e4c625d09be1fb963f07029f9e250635255b6f9f03703c384ed807d17acf193cf0abca0928f872e04d347e576770f620f96172e8080a55da792a0369054cca4720295f195c2693b956b7bdf4dd9d4674059b586bc3d87f5f887d89012a437753c168efc1ac55d61754d3a1e9a3be147a82007dd55d4bd8cc2ed6194a1ce93a30a4d35064eeeb69cf224b1da37903d2b83cce0cf528b714b2a0f4bc0c407190a4e9c8675ef65171204dbfe18553a066d310f599f0488f0052f0d2c3fb7fe33994609a91a1abef7190d289b3f1f927cffbc92167665a02f972c2c54e4a6668550c9ef1d327f334f96110afe49dfa02638b59ecdee74d07fb5d61a1f1042877ddbd60b7df50955ae78bd964363386b66feec3dbbfc1cce4aff5727f054a0b117b7a6d5c8d3018265b31722a77bdf8a863fc03d785975e61c8987113bce4e5fb974db080ad5351b524811b7a6420cdd9518b2e45b12c78fa690787ef13cf00d71c87acd2cc25e4584c69905ce7668ae11df56268990a2f4fa4c912bac9144074cb5140999ac357dd32a7b580535725885fdf8b809cf058e30874cf0f189a84cc6e481b88a4d2d01d38f7c69ae2d3d9be0d1ac8eed3624129fe9850c89fd4a3c1c77eef25f2c510511a66494954a1f9ff5d8ff6707e84d297a8065b4e63b4f324a4bcb1a380e07181cbbb0cc520c79970daa1c2d0b491e2842ad54c5b2373d64665987e0301280c018da0fc837f1102724021119953708f6a9243a55aaddbb2dc20dc74da9724f2fe3028644615dd41c4b0dcf82be041d3cd53cd7b889eb9b094ea5abae23d269c44aec780092901b7ec5d103a5a933d85dd06d3886fd602bbebd588f915a1a33011a7badc9135ef83991562e368eb360569058b425142f8d1e45b95249263eb24365cf0b3aef0bcdb1cefacd81c759c504b7a35947b96c4eb44e80ae9d86f3c766c2b91ffc7e6d8fe003754fd5eb64aacfa9e72a6e99be4dbae7a517e5a9748399ccd69f2776500bb8dc5d7d3193f1eea2b9f18afa874170b207f6d2c738d279ee38c1b0150ea1399571498e849bbb0bb9b69275efb1ee34cb0b3dd05364c9397f4d874f6ef60520d80f311a0febb2e399e8c3be4a05da89ec2be6117043f577119395ea2487aa82817e4f20fe0b2a512f07fa119800852b37f48140c254a0e51ed13570d1837346a8e6680dfb3fc7ddfb9acbb76bda03ffae6f9b9e55080949691ed8917356499f1a555f5c46dbfc2faf1b9c7cd1480d140713e0fc7728cc3f5f77cbbe303b6e4d02f7d027a6a8b859a1ebc8c7070e1fb16e31df8fc7ff6e1c706ae411b3c908b63045a54f3387332592acf4572c0f6a89fe491c798e9d74d06aa423280bea64e43cc0a9957e29b86bbbd4e758964311e410ea6be89ba731605cfdcc4013e6986b2e459974f171fabc7fe619ec5ef310fa27f56975b3fe99f1b23ee6869b7d9ac8371c52473ee34099a5557ecbd7a7e1d67915f509b83b6d05fb9c7f0b43e74fa657f1fbfadb5baf43fdd8a24b81ef36fc7195918badbe13f9337e6443d934a60929070788919ad2195e9f9cee5d1465fe690454369d394ad108a63f7221bc0890e4827c2a7b50345df8eab25c1db59e07d0ddfb751b5e0011449f78d09dd269ce94a847c4f716b99224a415ee6fcb354d9814f934776379127cd199338b62ea683f9a0f283001feca9db691d19476ffb41336cd58c2a4b4c37fa347ee7e24213fe9f9a7cf6c454f50da022453c78ef96b5b65e128b055f11801e729345ad71dcfd3444ca259ed438f786ff635e517864e97f14caee8cf091d3824891863d0c560d9fd0f0ca079553a122392c51fae21f1f6cc2f8670e3058d63b656c11332642706c16718bf1db7c669c8b35befb8fe0dee979d30b220721022eda443c09e0d1aeb17f30c86c4e5fd2a883d83d6e6c640062ba5c9f4bb778ed654e9a898763828eaf7b224196e3c5069d7d8be79414f183836fe881852313082f4634811b85857feae57dd601108d3fb78af5f42e09d211df1b3c3abc7e2a7b97a8eeeb157554c995d9a04ee410b17e3999569236c9de242fcb4f88af20978bf94450c358a153097add8916f0915a2bdce14c16abb1d995bc930b305b485446a887e4d7505813b942d4da7986b59e2df0d3b58af62cd6b1c784d7df6029597fe6df493de348d33d34784281bdd27213fa555abeb78ef15764fc7dcfca357e8f3b8ddad79c6d0a13f3bfe73e81b8048c2fd77132803b93937f97dd9cf80b3b1c70a89c2f051893def5520ef4f626dc98766705231a758d7f097ef67be526a232053aef58c33a253557557c4050dab9811049ea06fb377517b7503398fad346dc33b39b2eef8386924aa79d1f376661399e9ba30a1b3ea788d7239d430dfced700627b1d87669137785145a34d0bdb6ca373b89eb8638a4ca4823800f6a2dc82d290c67cc064d6155510802a6b740bcbeda89d65af81f3a202ae96cb99797252e78e3b6ce2990ba7b8ee248bce304a753a7645b9c79383e4b54b407e47ffaa6d7b8680fcb805c952624eca1a3c713a7c7a2f42fdcc66a9b7d88c0150462e526afaef86523f460cc98c453cfb4585166feacf67e42b900497e6dfcfb3fa192bf90298c53ce97e80635c8cb9c7a4669b9f5adee754c8009066bbaf1502479642906b37cf9e63b5791285580a5e94bf6c05476579513608ad0d83b5b6f7e4eb28a89c69cf403c529173659e0de45432bb6383791e2069d35d7266f75f6cfff3e1f7591d6b2dc96cc176c1f088ec177d77757ed19bbb819847f63b28c6f90c6ebfec1de72f1733837bc7ddee4f9ab36192d89d32da82258a93be1fc8b83c496ebc75acd909740badf068db907149b1d5fe46d242d762990a02c534df2c1d82cebc9dec9fa4fa23b2145e42ffb8baa4f3f0fab4a38de8db7b259bcba7c11f326e93ce79665fb43fc3b369e43bab84c65216f90396a4e89477481826aa83ba39a325fdf6dc82e2146feedae31facffab66ea14346da5e2ee73767bc00f25c628cbb58f5cc7f3f639119268a4d60bd791a6f163bd2dcd464737cb92d7a6dc768ee66ac333a172befc2e2d930ce40eb8b4e64703de24afecd24f0b2c32067eb2bd3e1290451b5bb2f32b8bcb342c9e5735155c0633cc5310cd8a7f8377382f87d8765723c7f3660a1b3e134ef1ceafed796a52f2312d6b94671f52d93e78c43c6adf2263607d62f24f244336881b9b32ebbaff84f4f41b3c8dfb5f2ef786103c90091f65b869198e6c77433f993be3909d2c3d8e41813f046230035f88a03ea4c8e0faad3dc317ae41d7e1fbb33d68c174967b97ec29dbbb6ec541df6f3b487064df21c77b5fa73a286e856b9c443a65e18365a6c127f19fee74520d902a8194c0ad5c667608ae0de8eede2a02b9282910e0230aeee8f6f7623097424040468136ce3fc73791720fc4502b6db4c2c9b8ebb882f52778e233429e75993c8cebb3c131dd86043287b4fc94702561296df0007fe37c48cfec0a347e30a4b49a231c8a7f7f6629a233ca32ebe296975709f9b38098c70b45d2611d7168ee7456aa3aedac3dd8978af967c0e411f9720db2550e1f839d17f5c82b344c710c022fc901508e49c8ca10c836fbbe5410c30b3c9820109c58bd0a8cc4de0b03b600cfc2bd04d79e02f8404cc2483efa7ea147bf5ce6436fb5a32d80865ec88243ace55a0177ee2f5bc89ce34bdace98908b15c46011000b38d1017f0cd05fa842a6297820e915b1839f1b6877976c476aef490bcb0c03fb79f06048f449cea5c049784653471b4265245d11af0bf10d742de897db1df80b06e8b02e4c6b1063902b70f4b8aeb608185c73dbfde24e12c98727bea547b02711be8dc0ccda3905f39e586cb6dd6b7deeec4a28cd252ac734f070ae6c9c7f128e5c551de3d76538ae7f0b8eb975dfa9990f15477381dd61f58640f834fdca88f066afef1683a517fbd156f993687b189a1b43af9c43b86ac32c2ef2769fa9c2bec4eb2e51e87c6332c4a82cc652c7ef9f2344d15a8e3b5d03b0dc48d46fa36c5f4059a6a4882ef728bb9b4219373e43aa3c5aca4761e776d7cf619c985b2db76bcaa5c7a268d458809b4d674b26512f2ca24361a911846bbc295b51222554798b5bb863f4a613088fc95529d14d9d5eca3d506c370b650f8fbdecabba25d14865b11704e07cc1350808a2420b82befec339ea096d4d1869efd735a29dd2d20de1986874647522d8b7ded3f08f115e838ce4f45528c73a5949ddd6df195326dad0089b9529f2a4bea8b7d8ba23b32ddd4d61318c785454ccf40734b48c5ab2fee91958a4a0ede3b351295ce4814f47338ed3843757aa0ed90d7ec9f51ce088d2289373141bb3adeb6e259c4415ff0f1130c32f85d75b4e9cca076b951c24a647f4d920f8f17da5a112b66e6d6f6c466626dbed62a8522b417ee72c9075d99cfaa53baf30d6291ec39ff246d9ba3438cc5dc5780705824d5405b03ba00b34ecf13c4b31d95ecd5edcb391106e8ee8ed3d78e25ed2c25f1256307861bdaad2a9f77721078ce3d9634381a94cb5e51fa4fea448bf1e5438d710da9a803fe107c406150f5cb26c893fcf84e675f5634cc5a518cd1f77005f5f59f34c67cfc9b7e1d8e4ec0a98e83ff1cb160aaf58beba812170775bf1064f3a9ca0dd47f0d139b01befd2c0751c5f26de3c6396d0d9c13a80403fae5d9e997940e991bc1752ca8af1e2d4112954e95360049bc3ebfc2e893ddca206a4424c28eae388a5a0a3d536eada43cc03944937a4c776cc158f72fb1af6a752c86b53c47ea7c161b2a0f7c0ea524ffbba051a665fbc3e93cbab6c043a30630bdd49f21555b0e6b532de66dc56191ce4c744e664ba3b56363610c63f59412faa94c3c25b3a92779bc995a8ceda92b588437302e7bac41a713f0be3741491e5547d5d3c4f296ae3ce383e671f29df869f3895d1f4f9d1da2c0e164f67c96e451c76c328db920d022ea6cb7b9300d98e0b14b8bb1f66940d81100c9532ef31858336a85ad33dd321872939482cf467456b4791161fd7564c2cd343f5ef0c7e2e33698bec2f5c7cb05b356cdd9ff2b26f573c84e3f6c83653bf675659e2cef2dbcc5dcbc4c315c38f57a1b3871436bbb5b89d9951d96bde55843d609c9c532d5d256511d9167e0619e2d3afb2d5cbf3417f3f56a67181dadfc01a84216fcf5011b9e0c93ec12da4aaefc29980739d4fa8f024382293ef70545f321e87dd94da8fe6ff510b3c6795736be5d0a279e16aa7fbb57b70f32c46c9b5ebcd33f5ea62c826af7cd8395c38c61186bebf52ae49b4e19e931565eda172a3c74b63ff13759315c4fbb63145d28862f001a95f94caa6be16014afbbf255c1c34046ae50d3ca5789684e9218d6d20d13f0f4cfbee4cfe0eecc3b0c90c14ce6366fd103570fd879612d73c41760d4114519c46ab78e260ebcdde83db9bbf0fb5e9cfa86d8fe96cfe8be9478b9db86f092595f28478e4cf8a9415346809fe144872bad75bd9912ac9c40cb5f284f97cca0cf9a4cd77f8ea51afad3410cb27b69f27f4f80f51d0cac3cd91367e0b3ff4e3a33a485d9153d9c7de48c9451e2c60f2f2880d18ed2358b5c88f53c6b17211a7a2c897a91083df57dd133c07e8617581c7e22ab66c1221ba1560d9987070a3cc9341b49e6705921321655f7b0ad0868e56f813b2f5a2f4334b96af2e102a7db41e6edca791e721110f0b3d186a2f3f9f0c37939bca52798fb8f1725e9e000d61aab1fc850ba5ad00ad8c10d213450d0b431bcc77cb486a7135dc572edf183ac7351d7a57bea30dd65366042a4f48573655b651e2321689422fbf1e13734d9e29717bd5fdedc1dd8ca8be08b8131ecda12e9dfd7c714fda5f9dcd01391656400c6280127e9550c7137c9a98aa9bb6620406d6a0bababfb808492b2bb0d98463966e5cf6d6afdc83f91d63af4825b016d88dbe4491e2d8feadcef746b956d7801557e8351d5c01799f02dd50661bafece7e8375e7bf24a5290d816ededb95bccb9e6a18f06d4e483196dd72c3de3bca299de9b6cee701babb2b13888dc0a2dd07418a852a00e74f5f2a16e034d7dfa91aa22f22895fae08e1fb61e3a9a993d049eb7540aa1bba4b58fcb23a6a00a9ef758a7752e32104cd0865feee5d3bdcfa80a74848a1272bb31cd041a885bfb3c1d88fde22b0c0f1ab588092509dd9d2fd418fce7e103f22927275476e41c8f37f16c69effc5faad7cd0cafb08b24efe84fadb8379d544295b0c2c1201062a47c538fe20ec3fea8222d89d7f323feb41c69deda2c0be7703250ba599c177d4d1d0a58c1bb995ace0f667dece2c34e33e71722897a4446d2333ce92169a3d890942396f92d7906639be970783f48da697c712aebaff17f344403f3554f29e92649213d30424d9cb02cff0ddb1a123d9c735029827a803f5f4e2283bac228d1d11e749ee18d0026a2f6061ff9967c9288c7d45577583cc90709432741831231f89e4fbdb0e48c8800263394fef503ed8ccc0c853235eb16a7953e4161586013e54cce03cadd7294fadcb3ff3ab585d2706d9ed5a153f6eba04e3e71ffb7b9d03375998bcb7549f65df5dbe72caa58c0463b93732ba1941431084c70f7a19c2147e5cb45afe49f6742c8c36a20ae566f2158901775ac4a05e3e52eed9bb3e7374d018730a8f7bd00a9242b2ea1653546aac8f16764fbd477f41bf0a44f8440ede190d84c8daaebd07dd22e3c17bc351c49727987d7689ea1ca24811ac7ca9f1053809bf0887677a62346ffd51c760bcff4e6c444565be3c930596185228f6a3f10006b4a05237880724fc9f3482f30b99e06696a246c0d760c764242a97797fecdfe2433a7f673b639b9ebbb057d59a42c8448206f08ed05c248f558e7ae6bd24e6d3237d5a6a36a07b998fcbec84f79922a3a307601785373a3bdbfe90348f67a0704464806d6d5260a70db0e9e3c60fb862b3813526fde25856c3296a2a2bf7643457ac63c0ef9583384340898c68c6b17c09937dfdc7dbdda3b54fbd032f1d60e3cb2b05cf3048c4e49a4dfe3960ed56ff8667dea999cf5c3077a4ea16dfdc2a9e688c07cb3943f06f77e573ea84ee5a44466670c5b4eaf954a0bf289137df9f632a29916bb023cd5ba2268752aa9fc657976d725c068ac04a8959c7447dde1f812d4c46ebe74fc2405591b48ba3cf534244a26522189f6f131f8861414414272bdd674547fafb4eb4fc77ca30c634255818aa65961c853061f3111a5aa01daed7e44fd6e643094aca9575e2cc02bfd6572d8af57dde701c347257c7f5c221f17c37667d4b713ff03fe18fed2fe9b6eb069819c345973e2d8df158d440b637b41f6edcf3723805c66d15ddd88e674c27ca51565d36d30f1f940a378c9346ddce1108ad81a4f3497d6ac054c030df7c6c770775ec59fcd1ab1b876f71d937790a6e21d16963705c79f1c48c634f3864d59cfdd9082549024deb41220925c1b6aa3476a76a5188b8e9d8dcc5f35222ac812b9de713cf647b1f752f63a863a65a5f7b37588be4c121b54b5addbd410395de4147c80ed0eeb3bada153bf0dc9f6250740d0ebd038164e090f84de2424dbeebfe193dde0cae720f93351730dc8ba40559429fc0e54965b35d741e8e473e1ae476f50e16ec340c4e993268dce95ad6f35c1a1c84078036eb96e77cd8d6f015c754fc3401ab51daf116b0a2cc1df6103e8c69bbc943cc1d936b0ee3c443beaf2a4cf42f8fab8ea8c6254a8ec3c5264360adfa2c6e0528539caa519358f3bb4badfbfde8a891d4522a64303017a4d9a8327cf81a558f8c58055f5b879334068f0a32b45c2d424d173b30634b8f1354c42ee199f553c0e8f276ce0f6680ac81ebe880951afd20f573dbbfb28c4ba0eb9a2625f804368ac355ed2077c6822dcdd52c84da896ac7ba57a4d646f9878a0a3f78b2388b84982a914309781277f9abda93146081701def95e9220f631a1d163cd7659b80e803c982c78cf48607743114b6c2ea34ce2374498f6ec52d95970491c8b6f7336835ee1b2f49d6592dac8805a79679c098021926ed58d3e1ed3b35ffb55a51cebf33efd92e15a166412e126e6e0356c0578dda9aefbbe664add1a475f70e58fc031e9ed1fc58fe92f5dbcdf148fadd0d2375baf8780242b29f283e81b1284e9e44e81f394d4db31ef0568b63c777b9576a9971413f57a486e6594f71e8c8cde483ee08d89f9d47d9076417ee15435580b2baae72db9c803be1fca9188e97b5e82671f2b0aba381aa6d55531a5cc02c6dd7d95cb514654936089c1ed39deb6c2b2302bf8e115cccf49f9e97f027045823cbd6c2d6626c73ebf47a066090671f7c4fe6f23464d76334469ec9a8c98d95f0acc8818f6e45b92b59ad630583d93028412aae51bd01e0ce1c58dc2458c4dc5d28b59e7d5c8d2d469df8b1f2453842e58370212325ff710811db0f9e35e4e6eff06a1e430e3982cd3911488f5cf854cbc87f07b822c0cf0cfd1a93a23fd2ef31bc13c3bb0b97dfcc374a20eed3a784a19588d3fecd9a713c2154e960ed663eca843ee3b342aa46fea5042b26837632531f2a71c253ce00600c466e8dc1ff563eb03b34aec4a442eadebcbd43270cd4fc6b7a22b20ba13bdecad0e2b9b33b8d55be1ee9a51f29b8e1a547524057976d5babaab7adbd86794f4faf9687573127efcc6166cb70a50047d1e072dd90e0ddec96513f2a99c2a3678a0d7c1e11378ed3660e1a2c740fd61a40f53ca66c90729039893406ad9992e97675f7e01642e1218319af6e3cd087da80003bd8594df855ecddac1db224c37b52f6fa49120f1907bcb8cfe488ce5065eb0720d01ca8f1d42dc7a7bed637a3bb4d888001576cddbddf906f6a18d0ea5e91fc67ba3a55ce56595d6f501301225076dc7b0da1016ccd52c6651317a500ee2bc9dee7dd74f9602ea380f3267e83a4a895284096bdf079fd2c4bc202acb630e5a433ba188f6ef4648c38eeee2d803f336769fe4ddb313a9fad86ae2ba316bebe87036fd1027802c063f6bd3f8253c78acae997738b36c2171e8239fc39435339525c49d23afe73f6c938456a54ec43f4d4913266f41fcccb72000dfc80a67aec486e01683ab982121d92f37cec290c4b9dc3ac6c0d8367d14ca7c35c6eb80e01ee69bfc276f39ce2114df90ce9a92e51c75bed0adf9dac8f24f7d2f073216970609a0f9fcfd7c39a804486172e22ecf3fdb58b0356c6ca35ef60a01f398de839589de177d263799e869f3ee46edd03b0f7301d2e83dc739080c177812f4e8523cb5f36cf242a2a0c59f1ef012d04d7a9a2a7846867e8cd8c50ab945706d091323044e0e8223589ff41c9a29d7beb276bfde3bb38fa489b8929149c42f2729d7c12d7e5f10e9c59415c32e0ea7ba6fed8b9f77968b529d91e52116364d2b4f2454bd1f4dd00bffd01f7766c5bd4972a1ac6915ca101773768d358802422ad5222196a0ca9a51ae39449ece89d3f0f4a108cd21b03701b6537800e03f7af576f06cc4f0ac4181d4e952bad08b08cb2a46b1afdd77f43669c297ebd4d819f359bb4ff2cc199e94b2bcc4ea5083906c0070f1040aad0b7061d7c4d8117b59ed0b75216ce3f94f26c3d61ebe872c72d6c4077bcf3b24b40b55bb31add7845300a070c4737d8a41a2573196cda229c5a63f55694542831d73d7f7adc1b49f3de9d2b1d8c12defbbae155d8e41dd595ca616eda242228edee42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
