<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7051a7f3ab8fb209fbca26d42829758c19714f13690b84b36b96665d84b5a7bf2b9fe5178e4e398314cf01387df6febc364558a9f09d065e3f80fd320237250a949d2ed71bdcbbcbd1fef00e12fdd00d7f64c2677bdf89dc2365693f667b4dbeeef6b022ce65c9edcca26074db1ac04d54d7a43c65bfb3311856c89a86a526360296f5f6ce9b20e52d21756614703513f04b2442def81f82ec56b75d8bfbf4d2dab89d3a93754ed66f8b83622674e2f826e98f789da6bf5324e084ae17e44679ea0f3457799d42ff9bad0a28b5dbf36882bad9b1413981e50563f6a1111e177708b8a8c7e41afc11439993ea27f3093ad01eedccaab786a13227421ea58983e8634eb586ff9b90a8e414394692ad30d90f083309a05a06f23c0ff292a4023a25236b594f725bd3199e29840e513073a397cdc8ae7397a6bee2108b156075a2d9f4aae6c17a4ef70e9311841d2da7ea30be15a5efb6260e5bb8a27464338aa3fea3e6b9179a4cb33c3285b6b15f81b82e6073795c9ff673d8e2a52c7e2e767f048d6ee7588a4f8a30823978cddd56ea353ef576389de38b91915164a970cfa9f6619a60044dcd1a8ae40bbae9b56e8b7b3959abda6dbd1b107ace15704c74d7cafe2d87fad401f0e6603e2328063ef377ae603a2fc081d43a0b5c6fd360352edea1840cb3bb6ea16f868321dc2c346b66fefecb9457176e3df80c26b99b8756fbcb29296ca6ec2859f7739be75b9869e1f55ce4aba675bdbda4812baa5bf58cb7495dbb13d7b8b5d4cc6ba25270e0dfbcd88632afb2f67c567463e0d7d62f96d69af189ac3441455a998c7073fcf2889db03d59edaee79cac943f58ce48c7a44d7ab7794c5d35845fdc3d1a614b7da48ad5f1413410a6060610d168a044825584da9b7706f8b88dc93a2c4ec1bf6ae6d2cffb1e59710ae9a1cc75d3a0b8e4434e398123835dca9cd3f51d7094d20c84da640bdd4c530ef1223aa3fc0d8305b0632273d48b7477110426237cefc6902e45e1113f8ef2903882df801d83303d6a4abe4e5847e318630011d702ddf216818de53b62337a56ff0082178dc4cabd12e99867f13d75207ad8facc6d3ae66a16f0229a99a5482d602245d4f95e63e1271044d45ed00c233b47662d3daa6d21ea0d6ff553539be80b2f10a753a659abd4fa5923dcad71dbb468f9ccea355d3216bd60765bae630d6ba0fb1144126b6978b7241f8b413f0a835170adb0a728ebeef5be79d8b1248630f3bc49dcfd24fce1039a0fc4c97993357e5e890a2f4ed1a640c88ae4d500dab6732103c8844e4266cbab78ba82c5d5dcf209e355058c51c1af83a8d8dd013ed16a3c773cac8e0e7ec8f532a304ee995aa7dbb89101c5455f2f24db2026dd3eb9d8729de4738c39559290e9c7b763478c927e93bf9eb11ef5997ad875c53d3a911aed236220b633c24291e62c421631b5febf099c62b5af3e76961c81eb27700ba0c771e8f22992454f4118298c8bb535239b678d76a311ef466a80dd3958d263d887d4a894554b1bf0a3525f02673a8d002747154b743a084c8943e247578c2b2b5e363221c10bf325da18934e32cdb741409cba97c8c48dc5fc29f6c857a9455482752a6658374ff011a1e6d97592b5e4c48439e215039b39294106bead9a84a51231fd17f3d8c9898e8231b32b773400510e26e0a50e99e37ff2710247d9b91db05321b0554817ecd65712563a99174301c9c0d46672e7421f4a6deea7836ba75e2d89c7cdfe459a998a62f22a5f0fc2bdf6232cb83f4d78a0e90441308f6fd9537a08af9c1a0e85d59af98d1d4db3b3b00e5acc544922cb7a87d51e8198b28f9e83d8ea18841fd0b0dd83dfbe26bcf2fcfa520e5237a3119b545c35b52bbfb1d391ee11c6a35dfea0e385d1b7c5730dd899082c93bd5cfff50a2fd549bb2d803547448383e22843aa4724baa2c748ef8fcc8ec75f19d53faede0ca8569185026a1ef4d2c9a897913d5eaa277fb7266949169cdc45e991de150a2771ce8765347d720dec7f9eb03e2bc5673fc518fcc26b9f1384b1ba975ecf48c8e9ffdae117c50e9cea70e64418f3a014424eb51d3c2032ccd4478b23e93836c39df1fd95aaa9f57d09a960ca57230ea74b70899d963a27c9b2057a6af99cf575aa2b1fb94fc72d1a22df6e8b41772be743f92802d2ef3353f7fbd27e6c083063dfafb7cbfd354f28d0c2b6e86fb6419e6f63f0c80892c44f27c33c98aa4fa43cd936b017d27b7559609fead8cabf2975b6b12aaa0a12dee6cd3e534f58ae3e3f2b870ae917af4cd1d3d563450ce19fea8794dc6af04cf49b0459ea08afcb361c5886447b3e5ab39e6613a5cbab17f227005a47e7a1590ab0476e5c4bf08883f9b659a33edf4d7bd9e33881cbaffc411231aec5033703a7b5858b661af869e023f7b619fbfb832d6ef81bb6d90c492c54339739b0cdabeb380e97b8b9eee1ced043cce42c3b2fafdce00e92c12e6f88bc7c5de52f128863c9af3e324261a33fa9f61f23d597f2399eb56b2b55c04b9d877bcacb0caa9f1879f15a9fb8e861ab30a111c3f4571321f329efd39240f880820f66b2873ce4d843ce5715c505da8cfe7b7d9631d3a72d86b8cffb18cdba495d0d91e78dad6ecc55cf35c83eb32620523bda82151714ad26f2fd19add192074e72f63e9fb561d007aa64839733b7f601c88b4c7644d4165dbd60e95bd69ed32db08861104fd55b5def41889c22e80bc449aaee4c96294236f04564a09b6681cab00375625cf1c85ae1685f225d7f652664df8e766bbea0141dc7b99fafdaadd66c39c3efac8eccb9eaf09d3882a8658d27e27317dba716f60b830fad29cf6b05d089000ab8b90529c90d7bc9aa7f409f0bce7a85f3a49456ebee231e4bcd312983506e84b3e51dd756662b62a0698da08fa6cf5b55d8f1321dad89f8a3eb16555ff2507743e726909915c0a32a94cc3b2aa9aa56b02b74b76068fd5e061d750541e65f011152d11d39947b94fda96437da1d4e2b31c8813ba3fd1d5e532e9430105b6071563fe0f0c508509fe45b26c6e8ef23d7f3b18a91e97760c181f0a9f8093965d02c526202862716251eeebb8caf746f64ce0eb8aa38ee5d15053deb98d0edf4b4faae7514a41108e53b4fac07b26c03b11866faf3bad992e7661cf38beefc34f42fed5b64294d6a6a5f495ffb66ce1fa9c75b77eab51cd02676b9f38ac21b251f3f8d5675a299cfe975808e2858bcb3bd33d84e83c4701f0a795a8c3d6f3b4fdfd5fb48553939cabf8e6f5485995fd8721438766d294e0ddd5531d138a4968d8ec70f6f8e48a70db475635fdc5bd1f87d481e325b410ba4f243bcd75556a2e46bbbdfa19a5f8c3c88757b9d68494b81d2d1e7f12e22b102f950b1c23f34d25a6bee87181132216a37c7e313574a91361d204c1f9c23ecdc8987a33f174ba3efc8dad5542e2fa80ef960edabf398de522e63f08123d7acd5990b829564c3c8f4603d89ae16c2ff9fbd8caabecf3fae6af61a820a25ca30409b39538bd0cad2996e01eb9f1e1872bf664ea196491d6564c21ee02f63279b41ed067754403bac174b5641fbdac63b018f82df0aad9f9c0fe1119db233b6e8172b57057d94925807283985561938866598c4dd15ddb09cc160b04941fdd24041c74803c6534733f0a6ae47d7413accc5abe9dbd162e971c561d415dba4743c20ae2f3a1f56dd790e0eb695a3f8fc5ad1b8c0747f1589322614134144f346a794bbbb002819b49c02051d17ffbc4ca340169261e03336c27baa57926487647074157671c3afb3c3cc606e4775c67c919abb8f469e38ab6afc3cb3720a7a967dbf86b7bb9e9d3d72f641d49897af9c3fae4fd08e27ee8d720c230e7edf7f1c3182def8ab76cc5f3f48b3350aecd60fb83d196f9747d81a8fe2e7d2dbc4f76aafd221bde23cff46d8e9c8f27e34afcb8a878553bbedd731de3452ef369d1859dd232cdcdbf29a2f57bce0266faf9187dc81f4dbc355eed4b03471aabe9441bb47d07af2a90db4c4793cd9199e650b2ae1ef4493e04ad2fe70b88ec2d9b16932f6798bdaa44f26d88bc6b4ebfd6da9dcb1609b6f6a6fcb3f58bbba0ee68588133793798662b493a1d58379810b73cfda712f88df03b40dc47d29be4a5cfdde0f5a1a26c93246a692797fd5b897e3100186408d6c2300d24a71b39b9043f286981f536c0c0178e9c82457a599a344a95e66afa7ac4d7fd1e8d7d19574fbda48eae92a7d77aeccf9d5d57eb506c30fabd683e8f055c9a96bc62c172701d8f3be3887aca5aea6ca4ae763d5f7c1749f17e0ac1cbd3c3e8ca8656bbc104b74b9d0c90e0eea76678b3e07b00663bf97764043e8bfd27f9c0469aa26c78937d989c395fbd7b3b7f9c6216e8937ab758fcdbefc3ec6e4849cb24765c227778bd2c429b6872420182e1a87ddd1059d6f4a402cc80593916afcb2a5e7e10fde1f445f26e046ce591afd1d02f76fcf89ef7830d7035e42d53ecd5b125ef82ba568d1276add9dbe7653741e1eed1b4e40b07f21eb803bffdd2f6cc697e9a1b88e98ef6be0281a6efee852e57148ca6f1f37f8810d3e8422b9ce14067f7030b4a51b49193c388eee41217a795986091ad8e5699c318ba981e167664513bffbe04d4fa9f0e08eab4189c71af3d3e038c3533efc182ab03f6fa8322810d6285bbbe04242ab7a482a5363aa6bbb45f4a672236f5e38533a71ea38967d25777c45caa7e78d4d5503c17b6ace4e6869ce2b4f2b584da80593e55541c01d8b2c75accacd8313ca024eb380c89953afcbd252313a30f3410e5f1f0586878cd75d65f5c47d98d175e64e8937c2f69b6f4a9c089504d8daecce7a66621ce8e249de19b49da4c1922575b048be4f0998b713a09a785f995faed8362d93bab04b11595e4a0e2ab2d804759edc20d36772acc045460eeb1ab9ab4d03d9350817940ecb9e54a194f50efbb0ad9976fc2cded9f058b269b2ef8da166eb8eeeb68d008cc7dd0890cb2698b31eb7ad8afb57365f3c9471afd471b7d77c2846051becfa8cc9c9c1b58c3738cbb8106631db47974ccf522b7dda2d13c1ec89d54635b1c8b2645535c8d40f6d96051a6c6646b50641dad9da99ca4f52b0792532d55f94fb35e47258d578c7d32a9517b773f8b7cd2fca913c7a4eaf393c77dfe50ceccb8497afa6b8617160a2e123c7edc2284760354a41acfaf6b72b775ae6728c9cf6d926c4c7c4035827c6c94a4005fd5bc0f1ea845fc6be3128bf8860338446332bc5b075347e00b361200c7df3445bd87d53cf18a3940d216b35a9c717f18361dd1c73d47880722d99a72b1c57d2582e0bef4d975012fb49e34aa6ab3d9eaec0f23eff6a5509c20a8f45002e76324f326982f58dd80cacb62632e58ff77a954b3bae1759f4133ad4b1cd702d19a8228ab2e6ed4d9e787b3f82d1c85d5fc17755a2672399a0f28221a7753bc386fd71cc5c63279eab4df8b87c92ae364fbf993846b94e345b99bb146edd75e42532bd47c530796c30c28213a1ecbd70cd83b304ab7c88d72cc71b840c61855eb0fd614ca5ab5438a5100d0ef397f7e1baf98cb34103d94a65169650582bffaa0694be9154dbb8f91ee73f12fad76f0839ff9f7f3ddfb5ffddda1f6465e53e010e54b46a7033bddc9edf56630757de507bcdf1617f0afc93ee64f22b698bbd385561eefe2c25660f9184628af3f63775cb913a27a0727fb227d6e334b329241fea0a144a7cbbc8baf5aa7b6fa7dd8dbc905f7d81961f3eaa5cc6142251f7e5100700e0317503af4a247cc39cb2ec6f8f63b3143e110815c1bc0144b6b04a065063b15e1ebec859499384a2498c7030dfa7478bc42c540de50c1d5cbb9964b1a49d5b8f500484d0958fd1be33ef264bbe2745a99973f1e5e3e8ebe110523c0fdb368233cc0ae2c9a7166fee948ce41924bf18b79cde58ef54f3d99cf65a7d50f8ccbf73d5a8c2b67b91ced4cb2d3ba7cb403253592c57a8688e51cde48547e98ae8f84005427933245b556c18a877080728997aafaf57831b771d124fc91aeff3d3cb33c473daa6e3fdbc5dfa45ff31b91f85b8ad4b25b7f402fe630efac5eebfbc8828c539c186cfc7a6bec4d02871823bf6da6246ab4e81245f8843c2fc26a511ec118ee841e8bff2af193ccc2f241e6e9e2645d6460368a79a04332bc7a71e0a53f08fc5bebf0ec1b82ee378ed220fea3827d9c3071b0a81ffab7715ca8262e7de07731e5c2a46c0bcd48f741ac4f2620ccc4b6a55a5973480f0849db14c8ef1822fafb2883a676a73a13537925620b8b4b83dd2f7c6c2dd1a14048360540dccd27af8d3eb5479f27dc237799deb30e37d6e566aa31bc7684cca20458cdf7e099009c70708abc63c710260d7935c1653aac929a0c1a7b2de79423b382697e168ef48d6650400aad0c5933f40464f57eba0b54fbf0e575900c31278db679c751ec94482b04adf2b1a4c3e132c6727418645ae865b06907678a635d1f68a4c23c9edff18faf66b2376578a94ba85d70d2480da95ae272f1f57f7a115f8ca7ee5677d88bf078fa5f22fe4c77f7abedf19bfc4fb05fa338b2065a9b7d93331dde9a1bd31c0724a26d8ee354d5ede861bff114fd9d8b341c67ed6dbe4068a2f8eace297ba116f3739e91a53469624e2e71ed15b60098d1e614d61020ee023d6cc6f286b7c3785e7b5cbb864ab0efc445dcb03a3d3c23f089bc125a2ae52a92c55940f87ff793f12f8f013525b3b4d36271b60a07cef9a8467cf61908fc23fac977b2249962d7db1f6a89b2e21205b6f153846bdd03a9d2da6c484eb970c9836bf1ba8bce7e42e6c2d3eaa0e14e8c651eadb4593e3adf697cf7ddb986ed333d7a2846da8cbfbdfc1738d6f05cb0312929bf7da38e00799cf01cc316ebe3336207ef35d51f127eadfe3989a416e23bf1dc110e67977d6f0268faf828901e5c85aecf660d7c218ce512d56ebb9170e998e1897b7612b92a523cbd48731d1a812afac33f7cbefad6d3763e303cbef4e519d36fcbc8e910d8f100ee20767fe5cdf47ccd50bc0bf1cc8253615107920624ca553188bb60d8788b9efe435e62c5036a255ae3e821bd57f213de7edc9988f5e1acd6b6e8b44d8509ccb43652d8afeeb37495bd1da1623d2505dfbe63a7b50ca0a5225190b4ad0e61d6a879ac00426051c266ac27ab25fa443032875c1973bcab62017f5dd96e17cb070d76b448e157b4be706509b4432719b6bd5fc38e9f9b0c0985818b29674b739380a0ee7ea3542138e9c1b66645a4f9ea7c7982a780de971e055759ee78ffb35b6431476c3e6a74b8db22b073e32717f7c708819921c0667a6e74c7cdd066b7bdb9cc0ea63d6bf16e8ac75114d4f944e8759629ed424799a3b6ac4fdc5c8e0a2971f316fef1406c5f6e56166bfa9e4a839e2abb557dfe23e80aabc47ea46ea989088480ea35b9bc05c1c7c6ac16675ef5ff4e5f798ce5045f7ac66bdafd64a10b89c8b1450ca78038c550fa6924f1dda0b0b9cc4d86d50df4b030244227df2dde71c6ba091875ec32fa64c830ab9f217aabdf063666825cd91d0d69c42a9646e8d9ebf6e6a7d7c1885062607a981ee224451ab9e627f14e6e691b99346c43fd3302b1f685502d86bcf4ac3fe2883c1c3fa4ac9380b0c0df5b4bc31fbfe1dc21d4b2624badaa31963ac96f3870cc830894a0bd568ff9aca82ef9e04afcec2848c4a82d4f77d66dd97edafb951061772c194f81fceac4d4758b4147a247bdd748f43fcc31a6731d9724e6fbd3417e7782a30ecff14a1dee42d5c0952b5e2dd6a48c48cd14e78906d4038e40cc387e97f6fae64fb06aac67fe2a5eb17403e5f9e388bbe8b2ec2779400c5e316d51135b10872f64efea61e09ae79df3ad4412f80bfc741bc65389db7f0c3c7948e583657a1f5641b44bf63507a54b03e99e880c43fbfa9e9ecbf939e4f98b7b3ff18ad3949fd4db9463f480e6e2f8aa0b3260a7249b582228e2234509a6b6bef281d81d316572e8a2865e00806b306aa46536ba0b4030919733f33eb4ad47c17cdae2a16e043b328d697c16b45915d57224633a2e42a8481139fdc7d2d32d726bfd1c38a8ef1d79d719826d9430221fdc3d6d440e242fe74dffbee145851da475d3f11f866bb4b9645eb36ea55a62a82977d03f17a2581bc1e78912a5d47e5f6493a50a3483d1844f7d8fd60aca92bf88bed9f0e06e022f6da45134d08abcf7c6b6c0c076ea97eebb811859fcfe954448d5f0dfed76ec0c308a750f2b3211933e440cf65785b890fe14bbeda94fc24e8c467ee69744e24f8708861b0e9d8991140d0df0f7dfc418f36ffc39297df6890e79ae18341ed23c8f5c1ac8e4850fe4286269e22688b2794413eefe42aac2912b79be18250e20424096ba1fef6c910b9c7b303d4fedf7712e067431f237858ac35465d098ecee9f8508471f1081a6bbe03c0fc1eacc8cdfa2d540367ecf0c7e32086c09c9680d894b50a98ca38fec42e2ac4cf2439c1829790f877525ab5f68987d3a05e58ff9ecbb938bfcda42a811593d370d7f43253b5d5855902d7f71d1c532ee4d4412c6e91862632f41cedbca4a25bce7459df52fd1eed6d3dd9dc25d5e87b80d663968bd86419d519183347b13eff55826c8a207469be29ee4e8748d3fb07f8619425bf67dfbe1d851d9dba76e75ae21477505739b6dea24aaf88d780f185a5d201a352bc2867607b9a4e3c9e92e0051955c583a03860fcb90f5d118fe11e1eb6139c01df6536b9f01cf00ab9e72bcc470cc48522e94af23359d66e273c665a8c1b93833883de00ca1a3dd6d90339ea385e0cdb36be297bab281eba1a4e637c0694dd04d4b50603cd705b81c54462a6ffac4b0eb5a99246bfb351396aeef4c74c257e00155a5ca5fa6ff23b54100b98458362580e63b19bdb6d01b08a6148c5b90b8841279f0cc8895dedfbae174dc0d0507ad78e1ef1048d53e81c3fb8c42c013ca50473239c0e89b687bd14577c8db817f967c3135d264eebfbe1b1fe8d784204113ee857070c8097997d1d99f3e9a584662e7d3682e9502d2ec045b56e0496ea5e3bd75f11f145ab84b6f0397655ccdeef30b1761703d24457180cba98c38b721c76c9cfcf7b55ff707c2d0147b140486739aa9675a958ea34aa1af9cea21aa24980a142e5a35aeb36c95271904cbdc10e9039336be2493424f3ccbe732d216e84686fd0aa49917688096e3852821d29cdd06af4b1d6d469b74eddd079cfcc81c2b4ec497bacc099be11e8842ee101b40bfd1af8860c0c9c27f611e506296e71527e2050c59e182c2157b1ff22e1f02010a3a856b6f4e1b494edf2a1eea8924481b284bec215f827e6b6953bf8762c3a1c4e55fcd95e6b04db18f0bb6f6a647e73e7688941a28b4a74edc532554d5d076f96c96a9d09d6ab52ca862fd1bef97d9d83ceeefa5042d702e050d589577152d109b320d9ed358770c2c8fe7c78167f2809a74c7ff9327d5f4c1e10297205e7701690d62d44fb856e09bc625d475058cd890ab8561b0ecd31304d0c6ce7c4a3ed67a483775fa589533f740695d8b2fd2050b049e82dcc11d488be0c97f930cd704034c9cc5d7a882da478b4491e416561c77eaefd9a575fe1b415f76f8dda638fbeb8503d3027a1c0d21d1166b728a38aa69f131533b0296dcbb9078cf0bf05c336e3b74ad069881bf12e0409b286cc5861a4a65ef30a20169d264f4418fea9751e98e0729dc439789dcbc3a79024ec735a9dfb4ddfc4570e245e49ede8b7a0f6b927498d1afdf3b357536e9ec68d14aa3e8ac9a351eb0d4c0b109f982166e7d24271c01fabd0d707b6ef66f34c331ee233dc74b21776b13e0350d318c13c4e96f30d2ae1e829f5eaa20bccfc1ba35c466cd3d8c375f7ef9e9f4d787a868deb3c4f12580d3428fcb5b73e6eb6f9849306ad0438aaf374f5dc3ff29c2e710fa8f867249c132a772bab7471895bfadda53562bb13a945eb38460592a104fe444d1cae525b6615bf130b5c31bb183bfc698c0fc6a0fa10930d8ec60797d50e2a8699cf0715a1a25a9f6c57f223911901ba983399c542e1e1f2585a2129e7673e922635eba13e23d5ee03f3fa313621d51be73349e6dff876410694928368bffc2c4afe3ab54b57893f1810212c7cd8111ff9edb60b1a4637f04bd469cdff2143494a05d242ef9bc8ffcf87d369c46e8b3ebe6486ead282613e8c078afb8329d08d22aadf30ec7cbff151052d9a409a5f494b7ed58f88c02e07bf3cae8b70aae3420e093cb9fd7697f1c2ee64529253c78734294a825b06d6b03498918c97699a090bfdd5e55018d9a9c76d7ad7c908a39000c55c7c1143cf94b87240a724a67d1acd02e85358e8f46b0772697055541749c1fd89c0a559961ce17f2d421867bdb285aa6393d8e6e0ecdc8a37f088059e903592c080edd40201ddf0642996beb1783e6a0740da839b7963edf9163231bda890c750b08a1e2bc52f93dcc16e2169ab71a46ebc2d967d38d40919fb11d277e89be0549f5f33dcf691c8181072ebafd96acc5c2dcf43794517bb17fabfa6ab10be52ca0ce170a914b849b332598aaf8572949224d768cf82e8806f6e12c5ed5f7fe892972ecd9ed29954c3db0a71e641b721080a70fe4193ad510d76251bc70ad636393b20ee6ea85c4fcce166e1fe6743b0f43ed71115a1fbd217ad40e598d4036ee5c4d07ec56752ab45966d009cb39ca28d8f2d171bf301d17fffb3198afedee472e3aa735d12c536798bd5e4eb334e180713c3c3c4b4715c6ddb8c18d26525b43a3468274a095849c04792d54617bfce35108640599244a29ecd70648575344c16b0b40e4a20b4f254b289ea0345d47933b81e89af704f6645e46fc36931abd83d2f2c80c960831718b78f263538f87718a4bab5526bfa11efa217f9f9eaebb11488bc84bf6bb21fa554758054b413b7b84c882c656b199f557d783826cfe773ebf92c022ea8a44125bfffc50cd4f5788357535f4626465cb3e2e2d96deef3504eb4595ced57b09c56e6335fe06b105c893394f8beac0d0499aa6b40b2e428fb59e9f21470016c2c4d9355adb0e82fa4ffc8a0de9a0616fbcb94442da176fab5823bbcdb675857f033ec07d4a2d21a96883e4a7dadc127ac88578dcfb3f21da955aad98973f44b79392f102690e31be7b925062c066774cca3a1cd9c1c29be59314d37ffd2f2f9a619502dbfd6429f84710fb1561006481c5f19eb3bdf4919d67b74a822944d4c2ef31ec77d566a03c340b22a137762d9eb84bcc8993f1853981457bc375db3dfe623b8eb81bb72953301b1b4b0773d3309c7892619d0940c628cb713f51b3b516b2d49df927f1180b6a5dd577995a0381f1af889d7eb9f5e0191136be2fc69e967a210c49082b4345015b0d6e84ef3aea819137152e20a57d7fe905bc2dafaa55f053a1960b334f3f5a6d093aee74c5bf67e4e451e69e3e79ec5b8c47e9b2c8289bbeb45ebbbdc5bd84f1989836cc26bcf16e6dd8382fce1b1a3306a5f3fabd687712067b22fc8f5697e15eb802f07b7c1004db45691333b1cbb2c108fae481aef7498f437a49eb48629d5d5bc48afde2c4cecaf58ef7d28f24d38f058423b15761bf58281b3eb67adca6e803dea69e0b10aa1a9c6cd3b2ce521a5e50355a70528d4af6d19b49e3748c52433302e7db29272ba23042c5a704798381f663305773bbcef7b8ad572c2d7e6288afadf674c48e4f84875699e617ebc89137481504a0f5830c53555c9b75495f4b3b103c8ea3c241af13649a78285a23f2078a3980b975fc6cfddb29ecd5d1f78eeabfa1b7be568953a7597114002319af75353366b0c2827710d12b5d988fb9b388d5022b43614b7a3f7626b87b1b2bf556ba03522a7493e1d1fa77f85eded76d1ea1aff789a008e225c7f728f51c19b8051dad7c141acaa61106f21daf083b1050ba0ae56caaa4f44ba8bdbc5257cc5f3f2e05059c2facc1769c8c0bfb6d84ad4c8754cde3a2c8ee66b1808c60b4b49aff9832e416cd8f0c773f333f90846fbd5d68877e47577ca7ef3c4d5b9d118699045e4a10351185e767c715b4aca27f7dcab80a6a5dece4897a1201896ef042f6240c43c7162016000a36090518361c19e55b5a3895e4abc327c50fb2303515582518adf325f58b46250e6de6776ee32a0cbfbae004da2e3077f8085be99ce97a8a08780962d539783f244d17f5d7bc2f2d6e84f2a07de09474ce7ce05ed340f9adb8196ded1bd1c9926efa407d1a5edeba4e41bad461f9c61e0a61734582ab3a68765896226bc33672414368dcd52f7267948ab3a467766a8efbd7761c1d4c6ba7f6b2771abe9a51b1ece7a4ab46e68beb513e998891f0249067bd5b199fde1f98f82fc5bb9aa02ea5f68491c1ac1afb6c5e72c21370e704eecd73baa1d50300162d2e31a751988e450b6536e1053065e3a2bd5fabc6651fe83940cd4efdd797ccd81c9deef1f964314f1a3a4961b4d4a82319610f311d867dc67ccd8a7b5f8aeb637596c4faefdec89ab9b5e76425ed450a0a9b135882bfed956","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
