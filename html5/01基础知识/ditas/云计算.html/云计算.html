<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6585d902e451b35ebc86fdf97b543b5209d7b48b0096eba285245b0c9e24599bb3c66a766cb701b88ddafdc5fb0d6c4192b999e3f3ff4c54559d6c4709400cc68cf479cf91fe29670c7abc7504d141c8c51874d26b90a566557da37e1dc2ed885d5a4ce84afbd5b8b6bf674b434013bbed0913f582c7b805becead5b39c8f9e0a5c4842e1d4534e043881c778af15293e8208f9cb8132dc01581602a1ada80de7164f769fa6f972e6d52247f6dbe222750ec5985788ff6837ee60e87c2d8396f90df1c340b6679d35bac712001eac93ea1a52941be2259bc81b9e7d33016899df7711052296f23e6d864c54a1402c21331ee3e5e9c41ceaf8e1d150d00b6b067baa76b3fb33e99ecb2d3dafe0be5598d180ae82d1b9e9cbea441347377a458f90a69eb5a6513574af9f0efb4bfef816c46094ea7b5da222576aae545b35b74fba17b0db43651553943f3439f45b46f06184a93b20296ef3de44a874d9ee3a2505f95344e45245138e876b710782b195036fbe4411eb52c51de54a202f3f5f357955ee8e738f83767b3d84210aceef651d463b503c5735efe44d2e8370329ab665cdff2a0c36d713bab1839464bc569e946c60f84b49cf4e7ce8fdaa2221868f8fd5327a11cc1e9b412b2389d68bd6805cad7213684aa4cd37bd78ffe356683a3a78e1c49b000ba5019f68357bfece6954d515b0c49e3c92dd0a4e5cdff4fbbd795d9699cd371ee6fb232f9abdb31bf18919c494d83d58462795f994cbef5f8beb3bfc96da183c4b1987401d2adb590f3a508a71ed7079bdbf42f7a057a8f77bfec32a93b68d52155697399fba279f5d2ef94276b1b2f0148beaa3e6ce1f8cf21481e3ecbfd4adbc521f856e36e142172efcdd145b409063a5ae2968123d77f2053c14127106229e8e980028bdf1b675f7ce6517469ec0380d4e156b57ed761cb2a3f62495ad6bcdf364512938885e70a1bafc0fe0464f4590af33ef579af64413156ec668e84d1fb04f633469c0cb28e2c68556a72f1a3969d65246c22a809019c4c57baf954e7306d2d05014d4a08a01c9e19a40d9e6b8c338024ddbc5ca128b3c07aa0c8c945c8da7ee354d0e4d7f7a12611fe68995bbce946db6d2735b5466d26b37057dd54f152fb76fbfa309939c615982611cf6f832d5435d2e8bcbb927263555462bca9968439f6b28e98b00492b474c5e4638d19e01288b33c904fec40ea40d4686173dee4502f3be783fa034cd9eae89a397b96eee28c011e4ed083f73de93c74af49418472ce6c351dc00ddd1539f03a1ad0cec7a724e38c48c117b07f90b66d7b18aca0b40326bdeb1a802e001deb8250ab9613e8f8f36e674fbd25f1ed3847d78a80725b209f603e70f93c4a18663c1ccf2f556f32697581d29671d73a84ceccd2dbf62ccf81070b4d1e7564e66afffbaa04253c1ff8582c58bd46123e2d0088de45a02053332629f325311781afc0b53f385e86c95c4133192525a36f1e6337ebfcf02d30fc93b418dd88fa71be359e3560d346e6e61f4e2b37fdf3b73624c89a4004dc4ff4bdbffa1c8d68cca03ebec618a64ffe3be39d0f341a83e39aaf98644f056bdd2da349135edfaca27719b7bcaf5427590cb3ee707f43fa4afd8b178d4ef4678f2d1a0a28c7a3b9b34351ac300147ae0478f6da63032ef0f0e8699a297776253006a36f7dc1f3372f6cb131ee892538505775f38dc0c672671350a2ec2fe018b9f938a7b70415718e227595adbddadd7d3ff5c8f2a00dc7bb592c2a3befc38c362ffaa1533a63416f0fd4ce5308ed7a63cf982c38c9d0a507865da13d819474a8649a35e77435a8f7a9f442494b7b0b17d373851d6b2fa4112610638394cdf0df0e41e77f99a3af569023166f56d6d1f7e9f0a733a2001c6702df616431d96fb7a909724dad20879a57702733984499f74ebba6a74075c50a599a5aab4a49e3e5ab4d0714c2981c8c7cf644f1c56757d41b92456f0e76dbc99aea0fde5b9bb4b04c759a5583b4b4c990f81ca756e08ee7729ab023d2a9a44aaed57f493bf02980dd53f9a9c780bde762707a575415508d6dc73b388a9fbeda9a05e671607412527c5928ebfa8515aaf55503647262bc253f41f8f0f8e4036c1a240f3c4f72012709e9a9e65c39e47dbbc3a0246e7f38f9988035063551b58cba8c710d548830a49d68f9dbd4a08e1a75929759bbebfd11db74999a32331e40aaf992b6f1c469215e7a9a273a79eef1760b692d203b10ba622b2881625d75018d197e917205df08579f094d731d297c27e4589c265dca6bcb9cb738986c51b372424ad75f6fbe2fa449d582e032efcb3d1d6ebc450f41ba98238d15a6e20780af0bd52044a16db0a02285c1d0bffaae3824b7b2f76d055b44eff9f6dfe0b18ebcd87056f7679a8bab1a9f94af788a7a460af2e52a573af24c2fb61d2e8d43f6bb3aef279d8a2bd0ca1ad844115a513441bc9502031acdfa85c76a03edb2f77150353ee00f7d5bbb3f631b667b12ab71296624673fb00ae8027cb80359aed88c8f73a123305cd4cccd2568ca7fb37f948239d38af5ae3c0ed025572e8dffb74792fcd0028db2fedafa4029ec18a28b7913cdc5c52cfd6c2d5a0ccd98ad4a990f6a13636000b588ff0a1e71d10f7669fa156b6b1570f56591e9b99855547e27eb5d562b72b583d7daffb21df94296d1f818dd2bb3a0b810fbc8a0adc0d3f601cb189302732d49a975df4b526227b0ab366e6e260a81f259333d8314e7a7feda56594dac67e65b4444353e7411c216baa2fb56e45d2d218c2e24f1bdb5c11e21314fb53a528a403733e0518b03f871ae7e005d422a0e5119f07967ce2eaee505ebc9c1620fab624da296ea6f0d396cb2017dce8f3408f23578eec5d08498ac5340d1bf6f3c3720f6eeefdde59b6eba6146845b556830d69674ed6d7e28bba80b6e0c08f795a4770429cbbc5c94be8afc5a7944793da45d96ab51be9448fe87e57abaa793169fb86551a86fcd2475f1dfc8057f2e5cf96ececb8436832a61cd075fca8ce8d7f1db209df729c5516ec60986a54fe38bff4e9b6a197c8b43767cc01e9dcbd6d225124a730f0f724c1fb13a1bf68366a5f390ec1020fe50ec80408a2a6532981ccbad1ea5d433306f32e80acdb5dae08bf3ab0ca3bd849b4161569a5973c076757628028abe1e2d4f17bd5642cc1380ad5c8ffb69fd725847e2143ba7b8c2ad9c5b1f4e47d56eccaf7f3dc5b5ef16dca1a3e495db9efe30a090e8adf385d8fd4955fb56aba90a32054c24193127bd5a25182e2aa4e51d43121470048d21facc10d34fb8b8fc97cca862906e6b4b9dd9b15a8c79d8330cb737f324746cb30a6f82d7e7dfc46583a8800cd86a2115552dcda7e76d9768fffc5ceff09b0c45ff23f8ebfb572f844979d8e7b3f6f7538ec437554ad06cacb9524b3c2af66b8480a581cca15bb467a8ccb41e85222eec2c9941739bea1468a451074198ae8d35f3183071d93ef6aa916793a5c89d8830ac5e48e9102ef65cbaa51431f83e77c1b3bf5901d4b488b57ba728704ad1417b1f1eeba52f58f87549ed3dd0906dc108f833938393fecc65807b1efca28299a5825773beeb186ab02a8ebc1ed428d904630aa93c9918ae48f6273bee896ed331ed4e1b8fdd7d0b8ff16945b4b786332f09068068a78a97bc142e1a82aa772375428a5a4db1d52f4a24f456a49f4d5768be79c5cf81c6a988baa79d2074d17432edd2675b3e14f80cb20e1068764fd9c342b12e8553c26a39379d44d21f7c554d2ae518ebffa2bc380bf994dc4daf3eec1486b3bfdaeb5d40fbe2784ea8382ed6167074d906c15d8607d68a5e739b5eb5fc0c8547ad2a1f8d8c9b5822ab15e6d9d1436a98eac15f9dc5abe0661e421ac6e992c8f3d3591f673069bdeb21689eca7f726491e6b0811b31c3cb197457637c739d7314e4a3e8a77aa756a8b43daf0da600440f2a69c464c9d61bb0a2e2ae97b09758130859c11656c328755ba180479d32fa0b4b76cd2e59a7219480da700526f05ea0f0c107b0226933c499fa5904e389fc906f0fe031b9ed42575a16c9871a9ae8dd80cc0516427f684aac5f5dfa90dfaaacd2331a150f096240194f7a32c8d27bc4ca685a6f429b0cf8f1a38250b2d88ca2b5ca70e394fe5a21d3f59411a323ab55ef2a4f29ec9775b6173d764320e20c9f8334b35ec57b6bf6415d334ded00d6da502d3ea2deaa4ab768994931af04d8a2d3ce3931671c065a6b52dc570191e259a13f96f82747e8a590c5270f4a35a7dca58292895be8c1235bc8648e1f92d7e2e68acfc191a6212a23c689392e3429511ec4b7038c50ed5ca8f574012918a10860148eb4fa631ae2f1c9bdc1a835f169ddfd074c5562be54ba29b489ebb2f3c125d279bc3fc9603ba2b5d354a5a096fb4b11a198bb994ee103f908ba609a7abf233aa6ab0d77280a5381e42376e90caa062c81733bdbed04ed61158ef1fc897412e6ccd7d16f27dabf3bd1cdbab04515b8ccbe57de629bc0e0e28d4df1e6ecd6d581086365533dce4333d2a27bdcefc0f88bf266ad21614a41b52758586c1be31ae1e12f580dbe4faf48a82ffd04e36dc8a244d48147f1ff3c7f6dc2aa4697a217a7336dc44baf715ad6a8f428071cd4192e30c0fe0029d60f7f5f6b285b0041e4e570113b376512632a1089c7362bd4206fc81459693bcdbabc9004cc6d9c41274ab88fbdfab3140bce987bb1c6b081a4459c0b48934a1be1035163c492592dc6bc02ac4564d914e6066936496d864dc8216d25249c09c07892009ca99aaaaddf4ebe03dd213548c820d6984a4134e5030b00a9867c72c8126335bdcd56e9456f5d31d6cc04d1d37cefb7ba09c8139760c2a5a88abd5da8d429fa4084c9cf9bb92d2df0cb81ffbcbfdc7b33d2b0651bb0776493e533d08e1fe5bd3858c73a82535199ebaeb0bff902982e338cb51181fd6938f6196f88a6755ba32ef9a6e725373d8efef58a7858423d79ad0f68fff6446bfd51ac5659e9616f9a8ad4be06a21c304efc8e7b64946a6969cccda14c8b263ef322ba9e333616081a1454b75076674dff8e789cd588eb06e06844ced32631ce6a4d7f004f19b2fcdea1809ef6b098bedc11922829e05e32bd4658e5fbffa0afb5d372c3ceab36eb204fb5b968e0db9571d7d0b0ac45e91843dab19b2a30062931603a25ddc869c53860f9b012839a50c9dc2fef0925af4404ba9f09b680f0222b93eb3a5dfc5a5d0bbe932c21f124789395a1986033a917c3f8c1c7b8b8b415dbbc1db7572c91d70019bf99671f23c2bdc7ab5e4aa94abe7c982710c2ceec68498bf11464b3211f3b67d2a99895e431ca1e422b75ef587d2240c86b0d3a3cebeb65163b0f24f7a8e5cdc2ceec4f4445d31579eb436425abbc769189933c9bee720df2e23ba28e586e30440a84a3ca308b8a3d6a5675e3006b62ae36b1584bab482dfcede7121adc111ab925fd373722439be1bc6c9efce79f8008be97df9483d088cec789de1b337e2333789e1a628469918814e5d74dcc741475b3629df10d52b828e84076fb0b7a79977f60aeab98daf58c7e29ed7ef8e6ab1fc63d749c11ef94b2f370b83e2c824033789ec7a76dc85471e76f010becd2b993a59d8269b05152f2630d3c0682e7cb5f459b31968ab962cbbf2db03b803fe32ef9a58141c3c6975ee0925ee07820f6855b4a986abc0f7a8ddbda6fe8641eed9670ca05d684fbd14d2195d368c25ba0942053d364078925eeb0325ac1e4e08aeca824af7daad817fb2f7e744de3bc6102b3c4e1a36b0b425e0df0f17d65d4e6a39785ca4fdb272467a6eae144a98618e969a639c5383b510357a9ef21aa7d58195dd2f7d680ec000bf02e9665292781388991b526bc5b98366db3186a460f0483d97069a6c5ad7926551f09be8039ffd302b46aac80a78ec8068278090ce8a7dcaba4ec66237d24c6a056a857dfead619a35536c3dd7feec068ce2873ca9215d9ea07ce37d98d3b178d204c0a3fd9b5b4b4e29fd274e53ccf4f0728f3e41aa9f953290bf6acf9b0c05af04d34d7f2ad304caec0d6a264270792203c745b3338701e131988f88b79452a5fc62540d1f16f22789912c841ce4216debd8d4245923fc01097bdc1c7c09dc61e48fe36e694e8e0ed71737891d6595c009d6113bdd16a87fbc3ccde1ca5a3ebe2c159186fdd3bfea88863b78a430d0eac612859208a3501fb6e47e2c381694b8372efb4e8c7c429f20bbd4dd8d648c374b5e07464698acaff7a82e08e2337f53c26a372f3b21ac10b2f76a01b506bd914f3631f003abbce978030eeb003f9e1f75de8b2b7274e7ad3a16d25563116f3e222f5875282eaeced7216630c8e44638525da467dd8f0a2d618361e99a4d5aebc3cd33787bbd942d1956c9191f8b5f6498dcdef75b4cca0eaa9b904537f5b48802bc2ab84c906adc2cf54e95ffdc60b11e8ea14fe06ad169d23691a0ddce199eff41b2ba82d726893b8f5c8218b9e2a1969d40c6cbcec6aa63a8a23270a4c315e1628708e8b83cd772c826026867d690bc497ba7a49a2bddcfd86c63a2e5d24ecfe2e4a1447a14f135c1b967a34a49cfbe3dffbe452be2e9e71bb7fd269930d9d6db1f124db63f9d261dc4f96567068a63d46c772b6c92d5e3c0febde7bdeedfa1edfe885920930704c2e4e87ce7f192804a34a470ef27176c075f7cfa77b06258d572b7301bf528a2d3081e7c78e4d6ff7fe5adaa4088110a5054b8006ea4e9121fbfdf52488e61962c9e89724e43a499029d95917ed215bac06ffe87d773835dfcaf9c138ba122d48b6668ce91fb3137e5758d8ae64f8d7ff25b9a2ab92fa294847d941aa04d0eb514dac37e4c292fe11116125504b22618e0473599de5c4d1f17f9c4a99fa532b7ddf8113b9f46dd1894381ef36dca037a3603ae93d882e281b4a171d2acc153f2e543d7c17677e237c5f2c2f86affab569f7a1abe52eb4d2263f986ff48c04770d052a19114ba8fb1f60bc2b54c5624202e9a10d933586ae9ecf3e0350f3d3cc64f4f7d3c923a2aded8bd5aef8905cc41504298e5e8eaa0cdbba3e0102bdc04002ddb3d3442efb0ad4233ab3dc59d481f9eaee353c601a83997bf8199d7c9836579eaf3bdbc4070321bf3b1574419331775b25e78210071aa93fef10942a3c67f8d8ce6becf11ddf219dab151ff3cb889b1c93aa41697e05ece36c27b79d4f8a6ae167ea73db83f9b3004c8a89768199b1ba2d83cfd37d87d6508287156a90131164a9e5ea21344b5f31557999b8da72e2df55e37e73de4a1d72fd3f070b0d10b31476a9b98835821b2471b6e8d91ea944c7926cce4d7584e25903e0ef6870f29c91b5fafafa7289f736cc68531bdabb47732c27527dc0c5080893ec2d0a21c754be93988bab6a35e9d3b4e9603d294f32e58b5c94bbc6dcc623b2afd919e67646f9142121a84aa9147d235c51d096ad59bfcd1b8d130ac0d6549464a07b94fa7afa119f16927fc88fefaeefc136a82224dd6a7eb64d3790c29b71f3edb57ab7141d29859f397571063cd71b49403e9803659c8cb17357cec16ee34b39be086ac22792029749e447dd84a9d9e8609561518a224bec7491bfb164d74989d99552c5eed7cba317b66acb5541388c0ea6482ca17fc766cfac03c2228c3f3600bf09f2f4e02db1d912f08d368c6f7cdde17720a206441490c3023391c809e07e66d44074fe338e21710f0d5b71eb770e0012a1039cd4b832600ca6d10e1e785a2594b8cac3714f9e1de21948025c150811ab894947aefdbfde46078123feaf09ffae9d414b5771baf28e452d5df23ec2d6e4ce7ef175de4e3b5b4a9846547970707859872e94e422851703b2f55ea471590b1c8c0ccd07fd4b0057665af75de29709cb0e06e5bb3f415275950b9c763748d9532f7aecca06e3308771050aa771e1a92d986f191e0bef2fb7f0d7e3237ce7aab56f4b0830aab063437f3a424a8f2bd79d027c902370d46d64e03ab48d9b42be0e867df0c684282e124272410b4b00a49326c8d4077f3c64e89404db86525e2d4c9ff337a0ff289869372cc2c14cce94932b622d68767f96c40a91bb59d61e90b1990462fdf771f6bcbd24daf1afa3eb9410960f5600316cfcb2c3c6c9deb4e5937bfa69148eaca2f5e3fb4b3958b33374670ff05fd0906f98d0a29ff3c97d50df2007a04dadb456ccdb168579d2077edbb3062be3c9200cfe4c66ce4f468a4ac6a484bb2fbffd53b522223f184bb1297cacc8cedc94c9b293e0d3a0ab792d66ea13f111dfd5cdc194f077618338477873a3866c35cdc2d2ab01f55bc17d5429a182a3b51225c047c2675a9f8017e3c01048c005500d480d11b1b28b168d37a1ed422d070610cb1a07a8e1e78f26860c571f46c4184ced450a3b3265382fd61e1ff01f32d324f698a77e4ead7ccb4f2d801afdb3032aa88e27d882662c5042df1e7eea49cfb59aca786eab93a41f68d535c0b2c7836970af2679170861cb7b61fbeb3934e80e08a585e67823894d39c40a437d87efbb5d48511706db7f2ecdb15eb6d1f57f583ab6c2b738771ad910dc1944275ac43db9c231143bcf382ef2ca99b46d1355bd39cb0f0c2fa8fe9d0648352bfed8d785a3dca7a61d7378350e5ac9231bfaeef27e833cb8ace35def251e870d0594c6a0e417f91f223561538e7a685c5316e3c97efe13f979484055837716b1727f187203d436d8f186c76bb049d15c9e2a11125ab15cf2d9dccce178b20580fd510c00caffdb3b4e9bcf1de753f75fe05b94d65e54cab0d7822e2d15989b8361db6c2329a785dae87b11ed0873fa5c048c906d32449a6ddf1979e46e91d8cc9d1d7e6c79c19e0f2a99af93614821f8c08e550bd2fe345adb11050eb61169b53c6dec0e94a6ab45e1e4a68e7ac93b1b2ec2c21496e8aa241fcfb0687ccaaae88412909002a11ed9ba80d21b5e52c811e2fc16eb2bc75864294514176a765da80b5885268bd25492b3ef7f6611137c773098650ee0565633ce56c9fbde8a2a1dd3586b4c5576adea7f3935a04f587a8798cb3c2eccf89fa36ede0f6db091a46e21b2513dfcfb78cd0b284e784bed109722c3b8416bbc83f9d934b6efc8d8de7479188a64ea3abbe2e86b9b0c248bc10c79ed02b8cd68b3cfef0a61f8511012828d584e39c8d4a9a8f60590d11d6fdadbbb1d5a5bae63614d6eb2a814fb911efb2fbf11278bab385c3d96dd743abf6d23cb6489b58b014434eba06ba4013d2f9bc15a5ec0070cbe080a4e7b48c6c87f0cd2438b844354c228513d64cba02ba76a132197f9bd7c5983e74f3f1437829776b57dfddaac20e289dd66bcfd499b442f30d681b866d30fda4ee6fb77d46220fd84a86fc43280043a1cda2c3b8ac880ce100ac29d45c5f285584ffdef75eb3ebeb8f5a282a5c43010553e0e9640afd0c92a9b9ff2f24642d9f1e6839669ddac06a2daba4fd876537ee8827203ee3923fcd5dcc0b436ccba3d92beae7d820539e0d87f6dd3d3dbd880f4213246d35233620e35f057888272e0fb67d5cd58c087bbdc2990677cdf377e79476a6c99f9bfec9ae341f5d5c075fe655632ee023d3e89f8a0975c5b24dea7f98e7b439e90341ec75c3e5253129c6db5fb61ae6513d2f29b5146077fee832aebe021f3107a6c3ebf1b1526d11e22ed04c6488d91025e18b365a79226c3b358a8ce742e6cd5bd6309d008ec5f908646c5eb744abd765d374839da2f19b77fc575057a6312ec9a6804d37e108f2e1a9f81c1a7bddc91241f3dafcc85c92dfcccc33bbef139adb740b8e43042240a14f40fc9b214c44605c081f364a86e891a3ea8ec9e416a7ad395fa265d2624a6f97f213773cc3f44ae46804f6f59f26613c5d8b5b24f894b09ccd17193731e438c94f0d84f43c33b2084f6da8fb91c3fdce8311b9b1ea25eca8c344816fb3e67fc49aa37316a351636216d845391c0447b8de1b82742c063bb93072e9d6f9521d8f792779c165eee801dabddedff108c6a8a94f8629d62df3d8beea95e69c35041626f1dcb2bb77083ed4e926baefe4f62b4884ec22ca90c55afb3eddc186c82a06353f7c618661898e656f74d0e964d6c0f139dd681ea92b034c1519aa8157442469b5e6d3b23d35897fb54a7d6aab6427a2abcd4a84e884c1d4948d6730eefa1d698dea5dfdf22bb964cfe24beec66649ecd8134aeefb2b2eb7155cdf8dfb00dd0754dec610ba49f65a3848529edaecea788986a447fd0b70cd56c04359a39305cbc6c3e538763df9967f9726dc89ce414967fe16cc9fec3a782f0466bd67ce80e0127169b4b896ef65b462a9da036b99b82265473f9bb0cde95bdbc25e829ce77e1997d4e87e144007598237356e2efee72fca4ca0f3be709ed5e926eac7d12f362bf9e9e7fe5c81c672d5c2943e05d6778872b5278c26e17f4dc5c351cf8e4c5ebdfb2b6491fef746f9f68972112aa78b4e62e90848e393e92a962554bbdc0d9a6728af59bb34ca72928616091c46d37c5662bf15cf9fa9ee42970b9d627cd0ea9dc5c0e567984389b973347d3642147bbfc49e0ba6f58661bfd5b484b8e514ce0f92dcfd0e2dec841e931783e54cf9529c58c7461fea5a3f602f24404e4c0e171a2ed135f013130e784bf58a6e633bc30f1b8f269d214a7b5495c7619ab2ecc1899c719c92adf9275d427b2fac34d47cb61bb63e3011bf3bdf36465cce5bad37acff36c805be4c0c2a666f44441948766a010ca280036055555b2678c71e973759f18f2cbe6ea46a2f142512ae5f294ca39d2bed9cd44393b5bd10a388539f4c5ab620867f760968af9c621ecece446da3956c69b86076aca3cf753b4842b37b6ad74ab9dd674b136a183be144213fc311e9d7178cbec2f3174a670e4a8e68da1465041d2920fdaaefc200ea9fcd1cbd68e0b3b4d33f8bca61882c67f55fc7cb1f059c4119417d8f17afd06ac3dea207e93f5bfbcb4af41a4c55e0fca94152826e7b9ba977e77b636f17a216a2c19795ad468d8740427e8a8e7bae413134db1eb2db2c192ed7b38b5f799b331e79025525cb09911cb51d039e49961ee07be53b9540a9ecc3816a002760491d6daf9375a47f81dc21026eb8ed9b8225b3b74caccb5b229445c92773bc47a6fc24d27c307dad3456a37756654fe091d89610493adb458db08183bb2eb6325f6e5f8ca13f701b76125b87e6c0ddb64cc8fc1dd5255fb09d1868f93db5d2d3a27c7b42d52b53cbd9c2ed84d6b38a77a5431c2efa1d9d03e68c8825b52c27f3d19950d620cfb2a8caec6e4b06395576befc14524a2fb285692fbc330933df99ceaf349b77d5970c1566a449b0596cf7a7faa37ffc01d5652984dcd9173b58eeb3ea9a3a15f0da37e65c2e6dc2402be604fb2e2096b6ca5546c9688dbd43dcce8ba422e7f2d3cbc16049c733aac292ca00b1f55bf57578f990e50f7faaa2d93ee163316355971d9ecfeba9be96ae310a10c87d902307f58b3873c5f1780eaaf622d85e3266eacc1ded240182a45cdc48040ca58c0c04f3866f56a5c7998fb25ab79edc7148146fc36bf00b4c054a48aeb0250cadc5d0c8c86adc4ec32fa80b2ad47ef7618502dde692f97a79ba7793dc2ba2ddc772ac5a4d8d5828fc003e8acdecaceca9573f95c02d2aa6e0546bfc57d7eb80005a51f773d20ff86f5883d96e1c2f8055f6603331d3b1a537003aed349ebf154832ad8b3cf9fa7fe63448018daa4bd76ef2b47f01f3bc425b5068370c2392bc8ac772bf1ff619201f07131f0f20dc6b65b7126d6962c30b71a0ddc46aa3e87712541418fcc438503b1f06aa6bfceaec9df47dc3fa62b5c76b7808ee72eb88ca1f62c68b2dec1ce162ee6d28399922b5767d175ca6b4090fba9954efface3eb3f6403b44b66c646c52215dd0e100e268cc922ccd34754434ebc1ad09c0abddc3d224b306ce78e566cdf4b9a4e2ac49ccce58c9099492dedd6656909ec6e3919b1821dcb1f8b451ba9cdba844d56da98f4bf32ccf50c0d020641847e6d401c086339850f17e7328410a2a6680658409b57fe213346103d26b47d4bb9262838d1601cb026e43ccb814aec363f7f3640c5b0c4ac94f7ab3f947422e717e53b585640272913b72cf5f3a94d0faaa97712b832cf0d37b194e07f44ea7e7792e0d30e71985cc3c9188129ff67cc159f42411f800df282e2629f742ab04e049ce2f8e9ae8f50f6488b8387533a1b6a76ef554bca495a7deaf66b2d26d2d80faefdf32289c35df3500dbfe84cfed7fce9f2452592499de0dc3bbfe202751308fe5a687d35ebe85e93a1914729e2e51ecde0273f2a3565d1d37d722493bec8199d6e439c22ebf6ad9a40ddb3a0131995e5010a38194fc6da1e55ffa9adf2ad6270d990e0ab2fc143258aabe69e2eb72a9ab1c60338331113be7f80bb87d380f003566405a1db2a419963777149de766d3c701cf6dc7629a38f365b27143e21f5a99ef12455c83f8bd66409dcb97a672e4ce824a7c12f041374e36b98b7b6a9d5fb824d27fd6943e7c993c270a2afab5f032696e9d90c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
