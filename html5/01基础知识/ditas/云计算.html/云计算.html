<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a120cb0d0e01b60f1c0fdeed525a772172f5e02760fd7b974bf12dde7cadd65879ee131946dd86be51a8c57a320dd9f93ccd2cfb23a7a08d6f5a5fecdf39e2ffcbcaa33deae93eeba132922f6f5127b8660925208efccfad3fc7f6acdc9acba77a9f586c005385fae2db85f53f89f85fe0874d896a4109ddf744ec537e91473c7612d21975437da0bd34dfc9d78a1ef1416cf8fc219b197fd58c6d7f7e493c19d79720db5a3a3dc7815f7cc820014f09a3d823c3da355e827b6fc7c0b8d48b2274457cdcca760f70e11c032f6be757cf080468759fc52857bbc17595eebf1031f3fe2bde622a247dc4d394151d8a0a637997fbef7b6b06ea0bacd5eb3800df72d143711076f3ee76981f30ea82851cea7fcae3b93504131826d2d3298f16ffbbc2d0c75957afe5be1c4133193ebf86b74dfbfe6eec4aae8157c110371023ff59298e93292421c681f8b63feaaf109f39f90a91ad4a64052171077608fa5972d5a7c11a1cb6cecddd40feeecca944815bc37908c9773afe2384b64d064467316e1ff9f3757af0d787d4d4552d923313ca7879f8c343ebc68ec0987cf15f42d8cb86eb6335e0202f5f802b26cff196dfa61207185c246ed203b0e32a4460338257582e49a1fc7501c09da7233ae0c715f19f6c7ce1187f6dd6999a1f24d2a4b352a06e8a4579f979545dc36e51b498413922070080da05fcee73b9e676a4424e91225d22cde8dc14569ef7addd2a4dae25cad618f683fa6565e6d21797f5808cc2113d7e202f04ed8b1d494f26e3685e5c45a5a8cf0e59c62108b01a91cf9e38e0afb23256fc8eda73953954cc59304e2e912df55cdba041d8d913e1294240c496a01a3312e84565a8c1da60f0e5e586ceb719642903cdd1887c74944de89bbc7d29f917a9ad6c1a80b5a7786503a4bbd2fa49eb9aff25bb42968937e5a01bd7af0515681966089ec67a90ec60bff2d9ef1e9453876e12f65bd9c88b9fb48be531bcf62fdfb5dc88a3899f64b9181fac9163b38d460712e6a40e65aced905bc40ccc9b64bf5bb5a553cd25d51c6dd591d9fc15a5e084d00ded120e3a2d5b8f4f8109e2649996b32f649e09db1404c559138d1cab4e0654a13ff41334808a4000c12345e06477c4aa0d4e5ed77649fe55c163057c1db7dc5cf98d051ac8ad336383c990ad2206c45731e05e15385c1ba8217a42fc096280c5506eaa00c6025999fe97a6d14a7b75bbd8e77ad8c24cf0249c8a6a2cd196d903b72b4354d6cb6a125dff27728de78d30cdf941b431e689f8a7c952b4bef77859ba66158bb15b1c823909a739376c1cea49e7ce10fad692790fd0f88ac8307ad7f218bb7408d2109c10b90888ff7992d576290e017119f1160c18d5ae4426b272de9ac5a2cc93e7b7e6386836cc1febc03654532d7ebc74b344aca68abfbf5283d53100901b2546dc8f4cfb7c5f772c84723e23f8326fee8b44263d6e324d65b1645fb931b6b45841f5b320cb938475ffa18714f2851c73021b77b1cb7fed61d32211461adbbf7193390985fe441db302b43ce01c37645deb56022e781d164585ebcc8c76157538fbda679a5966bbd987ddb40a20d10b7ba76665a0d54621fab198d020844ead1cdbea2f35589ad2aa6817ce093556cba4929ce002a34f934318c9beb7f546a764156556e18c062f9a453ccc7df1a690c7c51ef1e0bd1a8834d9435e820407f025a182df12b4724da14ecaee85f90c973c20cbd44299f6a98712ef819db230b657e53b2e444d0c3c8596b97bfc68c4901c2742951ee18993b1ba56757541d4af6abb03e46e4fa31b09327f1c655a6ef37c010f8ba7f8b8f077ae3da7822ab1fa2997e60d2983052a7e269b468ff1c59e8ea474ae677161a341a26d1d301c13f0167471bdfb846c96eccc84a29c4068235f4fba0b52e3b6978c1f55936bd509c002be51d14c34edcec28608dd86a7f70986a1ac43ed2a69976a8852c1b84796352e3fd96c9e02c42491d9b3c035086869a5ed44926ac2fdc2848fd3775e0076f653137e49fa9e5ff512ad58ec8223f7cd503b5322b6b2643fd869e795ff86d77f9c04be1ede09ef1072123930f0bf4a9a6d4d517a6e060f1b93dd1e9f54a778a51c847ee41c12a7735b1c249d003e7a9f9580f0c08b88c19263bee1799d67c35cc7923e3db3e14b3f310d8623cd444074e36763fc36a99841b04c7732c786db40f7dfcf65660bde3075515f81dac673709804c03d3cc3aba83cf22df5558e489ce6fbe184f6391465c9e980372c4dab8a6395f20fdf899e10e46f78a7538fba0f4fcf287bb124324b9feae49a64a27bc8cf9197739c2c3ce3a841bbb27495c5da695624b4047b58a659326ce7279abc1cda6984a3c214c0e51370f6c465f78f8323ddecfb4ca39c50bd1cab1a4400bc95dc0cdf226ce601de878623ac4952d20125393fc8a69361232847a0ffa9832bae19d1c744d0018c8caa1b93b2079fb1afcc6c1803e3c5268bb2976a00a2765d8459a87b6756464a65c8b56034b8ca9ed8eea6d549a29472842d91134cbeed0862955a594c379e591197802da2dc271322fac99f05d1af5f51543a30a47520420f072cc9cac3dd1f7a3458304d85bec12155a90cef6fd5716b1a2faeea4c2db89fb42d8c3b0c004ab04ddd5b473606079b3de1afcde23ef143295c4b31829cd5f1751ad1dd1c449c643d5fa740edfbf1fe850e86154d2a88be1664e2fcb9ba11f92b9ff9a40f9e0b606bdba37fc2d745bb0214c9a51a70de5e98dfa283864a0c21d54877e59a61c6e11bcf6d7ef4cee2e8efb08639c55449b0e2869aa3e57a9cf7337e61ec44c0760edabd4dc8e8faf256d888b5b2220473501bd2d3cb33d70261484afb568ff679971ac8061adfe902589761e7495063da3765b15a180ff237d41d44173cdbe316a0800cab3ccfdd96bc27476337823404397d61140f1e63e333b5356b5cd54727bb4727cd5b2abe54481f8f8d4d52b429318162194b17bfb5ac6bf93619726f2d9293c3f71fa2880d6dbd1df402514635c1f247e7b09c54ec3b84b94a1dada592b3ffea1da13c6d52cf7a3e6318f6745366427aebc4c074dd3dc3b1de03a125f4fc30ac2ced262406825fb57b6151ace65733e478fbd0e35a1202cb1a1181078251a494bf17e47e644a77d78120d8a5fb9ed52218b04a1cf91db710eb83e099cb5d2233559a7ded1545cf51b953045d6f1add952a06b94c09088564714064a7863eb7310635338744275e63148c031e0584793842e7fbce2ab7b5dc2e8e7552579afa54b23228fe0764f48b01402b29621318932019407c6d48f4550410dadfac5e9033395a13fd5a76898edf651bdca69458cc518c7a476bf438b9f878c1a130bc5aaaf705e40e38e2b1b885b68858a2d08eeb3731d8096d4c8cc0c8cb101996190b634c1b8a8bafc3fcc57abd65c463c1e9c64359e98e4b7e9c6de9629938276e21dc18277961d69c82ba69a0faa8cee9898a4ac4f00cfc363ab57cf8540f7030c70783c31a4d7cbbc47804731bae4ee4a5243c79d9d247f2689e63098a66552210c78b7ce3abacd77dfca485460aa9ae933c9d7b32998215491b7f1fb7200e1c34062366c50a739cfb659b001ec40b2e3a59f15a358010983aacbcb1325389b122f0d34976ad58875af44c5b95341f589e8d77ff5a8ab371d8260712064f1b6f817d5d1d3d070d280772a8fd3273320e54bf64cf90b3b8b360ba06aeaa449f5ec91b2459f1cc94179c55ea1ed1a1463821b87547e6fef81c88c96ec7a430057bd77c6a7b5178f4369d76c991f1ad54be9079b9031e12ae78deb4bdb81ef35e0038b5d9218214e2b866ff316b2468bcd88c947f8fd98bfe8034875cd67465f065bdd4935a9be2a8d0bb0e38d20cb95820fb5383fd9b7948a165879656093c79d998fb10902ae4046a2bcea88b76c2dc3c3fb6cc7f1095377462f2da3278aa36b1c8e7dda58f9356b64d6ad36564e4b5a4546818587eb96b935fc41a01a50b810da6a9a50bebb5d561ac36a60c4936d84a15061d1296c393959af7420158b735b70d96be3700eec4d99d7f619b811d913882732cc15c91c44439a992aee985afc6d768523af9496ccb5196de90e9464e83337a553f5a18addc590ef48d744f5542e949b6a8d9b8611e63299766e757479cb5ca83fa451ef39767e6f94651ccb6b3b30d2111849082337d9e32dbd240e71f365a3a3c79d6a4da36aade5ce51c3a21bc8aea8e77820b8058521abd36e5abc71ffdbb8542267514240824fc3a97673dba24f2f0771995874b715ceac0bcf3708add23f4ffb0a10a1032c05abaae4991e64f9180387ea3329d8c648f762f59894404acdda1464c61a6e95b675163f38cea4628aa1fa7ebecde13772fad2c486e1ee6d766296424c4d4e7cd7ef1a87ce1eee382d4fb0bba5b7893a5b6a843b50fb37b9b54f7d584aeac74cecf09edf2de772a7c531343f4e4d059726ed9d5fff033445ab826e0e185b98b6120b2ad950b31d36d0e368cb94a93aafede023366213d5184e31a7d599a62d35c9a6eea2b0f276647330740a595196fcc49ede97c14da89cbf30e92e586b471a988be4b232f982c311a9b9a55806de5973e994036d4b59585c99cfa81631214e4896d85dc53d26b8a33a391655b6b9e8201a7a5b1c5b87eb6a273586eb81722f75d251565830665bda8b03b6faf7544a5f2d821335bb74c8d186efa16089af6f0f8cbace50bf3c1886864b694d4f15bb0df8258ad7e948831fa7696e44281b858cbc462f2b5b326761a9e6f380f25ae20a4d5f5a48044395deac626a195c06a049c01b87b3d644fd6d63323a8228d5ffd3786d9f1c47c0c66552f8fa0148749c431edb830493c63a8e4f1f83ee0c301e3d5f7022cab89a4f406bb1f0d8f2a94c14456a896e77e9abb664651d711330c34b9ef0574346c5c06aa3516920d02cdd5d08ad56e213755df4a189c45c203c3ddc62a65571c0cf4fb5c0edf3772a6995e8f22c73440ca598d87eb312c5e9d81a9d18e844f0fdd12eb22813b5311006ab28363f45c15d17c35551645e8ed14ada701fe9acc4cf6f9c6c950840ffa5f3a6331db7e46adc56484fec568d730d080446c40f6b75cddf10d326207667760b8cf15e6e1eb59a96be3302467379e752eb8391ec9ccbb397878ae2a3f08465d734b4479c94cdf788dcb8186d58b7e723e30008d2ac96881d3be5987573e3ef0ee6de1611697408a8b9e75cad2b58ce7087b80983073bc0a44a72a2879b1937c71c85778aa2e2266c5e21cf0726ec715769e90ffc873289b0cdeceec47fc56ec9c5af4513d0a94c4ea44321323aad4bbf3eadd457c384e782948252a935c4ef90a49bfa71abf4acd36920718acde1428a7dedd523f074433ccb8d215a6fa97184b940ac25e6014332cfed105d0f9c1bce92ff6446c931f62129c568d812b391283150d34eeb32f13b46c8d569d41c076f56a99d9b649c6d9ff518f76d9ca06ebd48cb491037bfcf3a7b0b8776ab33a03df5ad5541ed62dc304e995dbab9b42e714683018e0f5028153fae883ca9b8d56950a586927afb72e6e71e03398bd5a4b4eec59b44601d06227e83ef84e110056d9bfcf90b933a00c5d2ed70f723306e2877818e64bf7019117f714a76a2924cd043cef3d7bc79c47032e8cdc79fbb38e4ce69406eaabd2f2bfd5aa7ca18a62dfd047f1ac079a47377d73aa4dcb4679385ac84f00d269b5580270a5b459879f86d55b46cde73730682a55d184fd16343d8851c395686b8d1811cd4a32cc2df99ef7884341cbf71edf917f925fdb71d12afd758f70c26bf4b1f976f36c0bae5a9007bcd318c80013fb612e14b51a35ebdddc60db561b36b207835e9a71f4e392b26b9ea2981b9b90c39d8fae02370202db3745014256d1fb6d044ee97eb44e0493a4cef7c7c314e2313a8f0d1e1acaf07f98e1aed2dcada29be9132cd2cac6641dab3e38d94c2caa05b8b62a4916e1b1f31770c463b16d9a35f400bdec71a5d6c0cc5890c5cba70a2c8927c90adb2c8eabc02caffec2a10ffb492246417cc89aab202a9e678c863b0d8a07859e6a1fd20531ea597ce92c56bc1826690546b442f47819a3d037cceb51a635c0596197087a042febafa67a8e4effe68baf9ac0345f38cd8e6004be56ff7668c40ebbfd5408d99f78b0c4096f6e64c469fbf0bfc59504c12b699ca36d2f3937f60ad7241b0db278ef83bbe49d3e44e72e64b278dc5abdd21c2892f2019fa63cf06f3b447ee3603a90532a9260e5feab93bc4eeef3043cb586870b82df3573781301990695c37d6d29455fc85702f38fe11f80484870f8463f83aa1110acd4645b21d5203e20ea62df4cf6ed4641ed5bddebe3e280a95844a8fed0a32f70a9fca1387c930abffe43dd43640f56aa46f23c8000102f85b71f84a1620239938d4a16f3189830ae3e6b1cff0da0d2062196b1f10fcb977b4beb0ef02cf46fc3a98298fc582c372b44b5b7b93ce65fb1dbd332cbf3e6c0ef953e511948e2c877c3e29e42bc3478c35cf93b8df0697d806da5fadc4324d7060d081a865507550f92d834b2c5bac2d535ce80d5c755718a6f5321c59edc4b049f4b28e29ee42db9766111db5e2de38ffb6ec86bb9eb4574668617fbe9af0556e584b29bcf54a970be7aeb2751a672d28dfc5c945862a0d8a9ce671de601b6a7024a06fc8ac55d8f970f102a7160c2dadb8b3071717fd4364e7d930dae93b73cdf8aecfde8bed4c5663ef4a1d8a4b032d2a7afa16faf83fd48f4f4520d95d1421ad90d85178610dad34994ad35f5bd5981c681c50c665773b318fa7d3b174265d402beb825fac4334b06e531f4d99f9d5db8ef73fee7cd884f2181a064ef170b4f394fe611462d56a23f7a15b1035708186b6103631284236f7aa082f8c98c4021797dbee70edeadd49a9346e880e01cc2f22c84aff471c166978503928674a089e77d06f2566684be94d8aa6dcf4c8b0dae138aebc6879c4f66d13edb9c0c331e6d7fe52784622f7c3a1941c8eaac9982427b724878efde978d2d0e6fdae63e798bae33880b53ef1872ae405e6306e61a4126c7605de33b16272fdf2e5de079567c91a812f7509938f9344a484f94807c5be46a4ff0643525c26bac0fa0e97b70342620c382a439df0fb551597f1a468a98189759ba609a2090ce116e24e9e618e04d74ea20b4b35d4a4937fb5996888db17132a8fe01504dce30c3bea50d53cd0f7f76f22e9ba2d06243356a60d8de68f668b463198eacdd5a18af462227f1bd6602640f236b860e80a6f1823a550f80a48f7a26e5a6c0478ded90bd9e58569a0146aa73c6419d7d247cbb2afb80df37ff6330855deb801c4df409bfdca7c509c769d61c1ad8e3ae21f0dada16c719e5121ac8957c0814affc259d3677090ffb2dc40e90779ec55f0a97674c347b78fcbc30bb80109d59f9d218e2b63bb1158681b805c11343fcd3d1cf67f5854a969880b59205e9e2ec0881f9501bcf704dc1f32a392fe78ccf5cc4e7eb4386ce1ea41da8e22c24a25481aaad6643c201cbd54b549911229ca9963b442333baffebe2e859601df8bf71f3b4ec41d1766b79df880791276112c0199b16bf8ea94c833ff54d0b6721f91af062b5395d9af3c28953c6410fec86b485417dc519f4a4338df11eebff46c7c33633d7e32f60fc0bfe655424968e3cd86e87612971dd32c3f8d56a7dffd90dcf596fca1b8ecf74018d30e00da884c39c21ffb0cd5aab1baad3a4eab05359fb42e0a5dee49d1a5f5ff4586873839cf6a8eb6f049e57b2d07ae59817381a9e41f418e02baac556d179a45ebaac6cdaef37a3ec005d6918a3ccb08fa62ac0725794bb903237128a88fa20dd752c5b63ca362f6ee0ea7f7a2cf9051b851a9072d598d8d40b9e2e79b6e6d6e29c57a7e1833bc3e7f5ad2833e672cffe54b4ffdff3fecea6fbde50f29dbcbad3aec32ff85fbaf1848316354831fb31bbc284f7638138fd8b999c6889a284e39bfc574ffd6945051a17e68ee27da83d48c4cb3b7c48b2f23c4e3194ebb031fd598cda360efcbd7aa1c73de83feba2e4ac50e73d786d1481cacf289d4f2f471d440ec4e36adcc76974cce4238c70ba6e683d904f1255905eb53b43496f87081ce92d77ebffd271723dad98591af804e5c4b6297473751d64fd7e8dc9a06e510fb41670630fc5354609f20fe5b97bd21961ed6ac91c0df5919a1781b60170bd519d44e8da4069a0cd39fdd48ada86fd1d9bfc54b8fccf6d59de6d7030b73489a7312313baa5a4555fcd0860c084b0d25abd61b74860b5a798b804bf8c2450534094bbc5cdc541d0b8784d4a2390e4090fcfbc116661078a45aca60100a588704c66c5e91e873613bf0eff4cbf462a44f3568e914a11c7c1539538e78fcd7f57445f8db805878e8d7793c2cb87f49c7cd36b6fe52a4d3813fad964fa4ee9fbbfa7eb76862c4450fe2dc50fa9eb47bed968f5a287e5be233254857a76865bda7fedbbd7fe9455a718ff4ae34f8c73c3b6c80b66e4c1671aae0a33de85de4083c537d635be03816cc9e5e27dec33655ccd6ed154e6cc422dc3b47b0adc292b007d28646a89eb6b92712460109f4146764c1635c3f582d2712a2de63ea15ca466aab5c06d70675bc6dfeb312ba0541fd7be42454bd5ff0ec04d68bbc7afee1dc161338862ad1c49e5de5c1faaf1427f669ee7bd6e4d8b2a66dadd33e96adb1b4e9a205d1119613a5f093d4901c1bc2c6ad5db236a67e5478f7e4126b7c618ce96bd9e7d467c80db4fa4c9ce46a8ee642f6ce0f94b4245b42c0427fab31751f2a5bb1af57a5f83901e937c4201adf29ded23565c19d341cade60d65b81da07e9e8ac243381fc322126983042c1c757424a09ee3e35cc06a1a536a2c24c60cb1e97e11496836a057194919981e571339a624e8b05a41dcc6776a5c217377f87a04dc4e84f8b0fb4ee113bcb248c502e206c4edfd35495b0abbf3438b1966bbe7910dfe5235b1e9ff1f62d625622db0128c624a0c31f436d27d79a488a3c30679606d08a1ad09c211b4c09cd33cdc3e6a31784bf88928f610e8849477235b239651e5e82c54eab24e826a61bf316049d330c915b6d334c1caa239d0bc48ee50a53fa027ab805f40fdee6c4ce0bba142ff0f390bf54cb9497a1da393bf6656fb4e97cdae4860ffaec22012f53a9b4c848d61c3553e81bc3029a69b41f4b6d6cc58a2fce74fe415482b1088f8b81b9d71d4a7e450427edf587dd278d7988e7bd209d4b6f2dc941d50feac28bc7e7994ff3d2890439edb414dd66c7b716440ecd4d878a0d15cfdef1b39caf4480f73001d9d477b9cbee4197f214cb3417b6c0ae50ac7ab5663e47b93f5942fc5571271837027928585ec8fe8236755e79c103fc01bb5e4600ff2d4c069fb9d46af266b41ce5360d43220eba6d5324cfda8f4f823e18ce52b2d8cb7bd20974ee0874c42a0cd35dfd711eb34a51e586034e48adffff3732da5f86dfe0601431138213c5ce231fb19a028eb86e3e03645710283deabf3ce7d7654be0e9c6e93d437e93bce1c21d5bc6117249b5ca09d3c9071dd950f0f1d20cd0528240d8c560c63654f4f80246447e6fbe3a16ea3988baab61a81ccc9c62de886002dccccd2ecbcb8ed4d5d3a1697400ab05370057bda1690927baa15fad3eb3b1f0e921900a00cdd91ccb9a2b786aa87bd0a6119919f4b9744c7536c37ef48e3af7a6dedaa2515113009115e79922b419d049009178e1dcec6879277d8d2546bfe4c984ef86a60b985af7f89ed6eda90834b03aa07aedcf584f97063eba35406ab4a9ff234b2ff7d9b6b7e553812ad041ba8a7421784685a65afb2e34a58a8b336593cd2f43b326b3a61640d35d0b8d32f00a58cb87ad80425c5d6d6070b147f65c3b4abf15141d518ed9fb27d3beb770812297622b9115dd98635ce7313c13ce65045ed048338238b6123d9f84f52aa36f77de1b849b9f3cbee6a877a64126882323563b4daeffc9c6027c282686d852357f98d0fe72a9c8638ab519f06c02b5ec52ccd5a014723c0550b96db92b802c083b3953ea2d037be60d4f3f650aa352d674106666fa5541374832aaae80f9bc2ad15b9a80bb3c29c82ecf70dfefff1862d72a42cacef05b3b67f726c99c17ee343ed0338010715716b28dcf6a06557085db3db1f6afd04694fb02459f38f7daa15a6de802efd26faa7a95525b302119c731c2df33fbeb6100097f7cd5fe972207e5c7a13ca39029755227345cdb9fb1c21dfcde3755f1d7de7a4664d19ac7cbe88cc2fa1a9ec3dbaa762bba2dbc0e272c8eaca221567ce6da564dd62c366dfe13b4c2eb053cdea4d9d1f073cb766973a8d46b98781f7422a95a8b447e3bec22aa3f42077c150e06d3b68fb6019d55a82b270bf3f4e0bb289099c69c2000f58201448440dfe45b9019cf02744c78cc9dab270c408f75d0de690a50ec0503d6031fb98333514aebb68e8cfa7f316c8b8f81b16976d878f61d3d82dd337729cd0b3d6c5960bec0742d51ce1d77e60ecea99757cbd05bcf227dc278df72d2b88d8c430ce4f57e64df5a8fe3fdf9fe41c928f75b407d5ec10631be88ae11dfb2fd3808317e94cef5b892cfc5b7178ef79d47f4bd5ed429a79865344765c3d8ab61940e48fbdcc28854ecb4d6a0b1b83dd1a30b5431c10234162679ce4b593b4976b2416c670e0d98816955df724880d104d7a48061ba57ebff341932b38a78d5badaa06bb87ee5bb0f0cce3b425a7098d860b1589465e35a7ccb2497d9fe9c33c03f4fafd8ac01d5d014d4ca161038cfcfdeef2075273477e72cd46a434d2f7baa01f1c806f9f3155933fa8ee9072eaf4fb698ca2c6382069673a33425e649b3cf53433282854d9b5a68fe55e37eb90c5ee4a8424a6f01a4386da84f497b18387cf868cf1ff728d6852c7316f2b4f32224b3b3823ff8c762082e4470ac073c29372467abd5319c0bb532442fe15a987ba3a4ed53dbe883e23bd0df03d6305f809cda06ef8e3eadeb26c50611eb62bc769027e3ef13f1a8e8addd6b477299787ad97d0b402eee3120bdbe65a2eb8bd7dcddef0efe691cdd894fe8c93081895fcb373e86cb98e069fc122acaf57e4667f6b6976cf071f1765ebc1a2d2486f71e497d1af6207c5f8af3d4eef7bc94b845f7e28dd5271f9893f555f0b4174b5862efde1dcbd3595af58bfe694b430d2f427369e6802501d0e5bfe383a466565dd2099f44f6474792891ffcfa995c90cd0cda6f588885c2d4c40e19cc2fe4389166b5bf3fe0a95eecbbf9077868bac8c1401c647425e331c4b75f09ab977d74a8fd88097a6959357da9d03a97e0edecc4a81731c2711a1d5a6cc78454626f815fcf9f9ce6e7c22280d9f356e84e270ffc7a4183faf716e9ae678eeb6ef51aa400f5f9005cd97c226e2b8a6fe63b547ffe05dd6bebe4104b72b1396f720dcb188d59d6269d36f7f1de73c6804d672bd8b1baed0fec418b3b174c98f5cac6c0054314ba11e4bdb35ef8d5af96ffe234ed0cd993225723aab7310acc5ef3b2e7aa2c7f90d131ae37bbd6490b074a10edb6cac31bef9ff56b40a9cdad17c58d5fb14a7b8f88c304a51870cac2c90682be1265b85a6979f9fdefbb7955063d4a222450dd7f0d676192d9c9d767fac49ae3b3c70f56a3ed0434d6e78b25c0905052fd6e1d10d4de14c4c2d2abb0019f562e29c243da74887659f420be555d74a3e2f0b87ec69f5f64e22c1741e54b2e3d2d64118b45443da40888e89433f1f6e5ff4d62a866f2c7c9dca4ce6d4e7a2af8ca86074728b6347eb14b1896a4c64c57d70d615b70f9f42f13c7c6c8e18602cd6b73c1551dbd7589f24c146154a80da3643ec0132d5b5943478c21e8d81c6990af5676d2085273b7b9eb1d418e068a461e6b45e9178d0cd969b80195bf421707c355f6e16fbcfec11ab71d46ce8996883bfc76d4c6630404cc942d565cfdc711207ce1c6c3c75c1a6b18ac64f7d9af0aa3452c3eb2c45c03cb15d5d53cd69fd195e577bf18f4c28969043dde9f866955cc8ca2381c2a2b3aabd3471c036620bc276b852bbaddca20aa020f4199c48a5295e69bbe9d01842ad330339338104f4678a79f7022f132db318c82ce6ac2b83ececac7169f0a23718bdc28fb114cc75d346bd9355ab3a9ea9c1b0e3f15b5ee43f705442299f2ce82713dd158b6e15244b3fe659e7828f23f0572fd8bfed4d09fa11a6ff5be015e39684f41dcb67dbe9ccdc24b05bf2d1a44887d928b4183b50074e086a7158702db8b61499926da8b677cfff8d47d665bb9c9d6982695b10fd4710d2f88067225f3d89ac94b3d91deee3af208c326c9c7e4655d002bfbe1cda4f084029dd14b83bef2bf56b251064b5347364c3ba771f6e2910869945a0bb8f7c6137f89ae2f613a657ef8cc4f350958b6fac54dafb8631d5b97040fc3dac2a8ec7b16bdd96f20dceebae9a9a9731e2588d1219e3dfcdb5f07a1c88e179f7d1239d2ff4ccae40d6d6918118f438f3d9ab418433991c5535473ff896ea0b334a9c8f5d11370171d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
