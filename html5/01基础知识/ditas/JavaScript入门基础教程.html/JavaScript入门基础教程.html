<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0073b8c2c38a402c7b9ea314cebe152da3a06eae795b9d5671d9eed4931b60ba26a593f75689543726118467945743b7c129640d6d9a6550a962757fd830688bebd9f3053612f0a6f811d9d9eb418f1f42196ccfb0e666836b718cbe1d4b423a1c1e887482a6f5236f9e1963f0b0aebbbaeca22e914bb168aa45b1187385fa7792dc7e630c75e390f26014ce6c2d0014c8db1b39c8a97343695878b11b53157b383769cc2b4e0fcfe02ecbc970206ea50ebaf51912cb45a0e35e1aacafaf5b0cda8f551def305038a6e27d3b7ab60a808af4777aff3991755fad1420a43243a0c14bb46883ce90340c1deadc0ede6ec82169e7503ef8d99b2747a7f134042549687a8b7a4d0eeeb871bc27210d07c686478c6c5f44b70ff743c10f28300815a4f9aa091c0510a4e707550a08032aaccabdc5df14fbeb0991a29d07630235e647daab71f57cd964eb2d20c9746dcd50d5aaa50d9ea715087eb8116364bb531a2c4554c37a46720e6c090bcc3cd6d158cc4d08e25940390ef3e642d2a4fde8d0dbcf10792fff140a768fb8c6ada74d8ccaa13a420b752394d486d9bf1892030dff8ae7605775f428c354224edc267e855f30dfc87c5fa36c3e2fc2ad107c2a15f24cd911f70d23c0dcb85ed2825cefecd5b4a25da12c8ae854f1a684a73a8e68203edff7d24dc17ed5bc2a16b5008afae1b7b855a0ffb337cd274de2b3f93d1c8b0fea7c345efe9c29c5038ef7a602cfb3e16150dd1d4c3476a69e76ef9843e21b624551525d7415c95ccf4010ca792ff2f8d6a37757be3d0f222ff6b1ab2183147f6f2ffae2044b7c4e20b596c7d7162ab683d06247a2b7919392c22d78e0e9c5d3902f57d696c8a6f45dfab8c61674bef31de87bac04ad0f96099028ce27df54f85ef75d4000a957c667bebeacb5b72e8ce5dd812b6e04394d6e1497965cfb1561976c5b8217bd65a1b7b1cd5e716e7bcaa799e3fc8db3bdd5d75e81d1a72d4f605d2f76ec7bb9210a1a924ebaf42602e0fdec0722d8b6c8cba2252f2e19ffe9900ed46b175f276fcb937d15bdd19171aa053e6ee639e57b0280460be97434486793f7c0c477446b86be6ee08404ddd260da7cc65a7f5fb2a7638eaaf1808ab2eca30262a77485d4f480a972f38df21132edcda62db0d3f84a30ea9ac8347eefab773ee98e86666631319dfe1b29f48832770795dd6b75b0c16fd91f754b8ddd443549c447f26a9fe889808646084d2edfe25de8329c41906288b22e8ce17d45d707aaff37687810006341a6cd59389226cb1f311bc88a2f76744d2600ae049928b1f7bb179170e31d12be1954ef45b71dd452f91c8174b8ef9b81bc4cca069cb7749bc67d6c368511fe54585ef80a0b858d238a4876cbcdc33a5ddcb2cf48a5e1240ee099c6eb1b8204dd456ee97f5943dd817a8ce014adec29e4e50d080488ad2cb4ef0751c8669d60a24626a8598d7633d67bf5d5a09d14f174daa3328e53abc7583d59191182980e68b6cdd8a794a1735cc343c2a26a5cbf45c233e61acd14e2865fe6f103263751f63efebbeabbb774dd2a0c5e482b1c72cb92131265d47e0ca03ea47552e14b47f975c006265268a795b2a9caee78decaced58d16ac01e3c0b633b52556f6c2fb92192112c562edf92da1726d1dc1f97f0ef0193f3165cd0ea0df25e467e29f95b7a817dbb063ff2e3c14418ecd57e2497dfeaef472975eb137a756df59deb660a985c037ec3300e95685bbb07f633bdebdcd11dca70b78b244a86fe92a61acac4f555883783c1fd55c8834585377a23e6e8ace7b1429fc005392e960aa0957a1b21369771358ab30ad13d5e8bd557566e8cc8ad6e58057d964802995ff6c53feb9cdaf7980677ed15f59ff7e1332434d2c3845d2860f8c98313b5f448eb7affbd3a120d9cc4f1ca76b1c530cc695ebd5bfe2907d00516f0c19ff5ee3bf2ae9e39c521da67bd824ec72d4016c6fdbd173b0fe5effc6972c8cc9d249a809e28cb519b2bdfb882f84b4f375e2d6a49bac6dad24ed9cecc238e8c9f7f2716feb0c3d6a7ee6154f2405bd51fec2abfa1fec5af1cf493debfe7ab37c553eb9e977523a01b367d9f5b6bc95c2b76bde6afa53c99e38076e24b17fee96247fee83e8642e9412ed996fe1235b64461377e6dbd5eed7dfd6309f3d2dbeb07a2bb0105b3da97629ba849f7c88f4094d3e7774f9734f0b3c1e2275e3e98d614d35f9b08c6a693206e78edeb08f3482b31cbec9869213ab49ad3d971aaa0804717945c6511c68c4be67560296321f690861d352e500b53effe012ac4770d50568a9ee32b7e3ff8b45fe97a147120ffa5f024ae000d648573f2f08739e1c59d064aa3296733772a236eec6c4e5ce793c60ea8dfdc6731c84067842597557cbe28c79823c7e7956bcae04955f3080864fd1302e4d677ada8e48943c1f84de555c28c10112948944ec7a90a4e7e93ee77a2abec22ad7eb83c9bcf8ef136fe96bb6f8f831f8e6b5d902832189507cedf4ef944aaa07e99b2930f91a0055d75fdde1c1a3270ac6264d599a31ea02dc1e5b9dbac5ac5997fb5b984992d1cf586c726e3902ec8a180e2c7f5cff68c1b624f96caab2ca5013524cfbd8bd80762b96ff706b28560c766a3fe649d445689e65cb5a7f544b7e6a5e875ecdcdd6c28ff29d2d4b3753c54e3b7ca15165ec1bf926b53b4180ac192f0c60673eea8fd981ca06229a4e552721c608106dfb624b2da8ece3e6da78414a0074f432cf33afffe82cb2cb26384b62956e93310823069102da4613a3c9c83b4ecd75022e0d34c8e4455faa596478ad0f323e01cec0ff83d1be1e13b0e45445826e5708f204e0debc5b8999e0705a37cf2f66c02e5e4d190c8e95274ed0c65848a8261a1b418bf264ccc3545e85c450ef4698e5dec5641567e72740713fd2357a220257b44bcf87e7819c592349a28a25ec0071448bf3748e297310d9f866e69f96e11134c52d31293b352ab7976bf0c61d572650581ae61d04ae7e35979c9a765b52ea36479ad03c9a7fbf060262210910a9069bd4124906e7f70cde37931e1bb26af318e2d3bf7c37d1f3b5269d9a9ad772b1ed7167c48f092f5f89d426079b323d852338da745c3e03760dc8ab0424e72d6fedc72bef38a4e203efe87cda62287ba658de4620dd5f4d4514e36f17dceb5823b9764c6df5b7e61a581227b078164ba443d253efc782ed9308a57f960169ad452b2cef7298fe20a346de3a4995891efed4ebd995bd600515cf5891ffb752978bd891cd88b1fa311f2ccbe09bb468cb797ed8c3b8771471ac75fd13d711604a8d8dc6f442c5fd6d96d6d7970057f40d16150086df16efe24acf3bc7dbcb48296beccea66ff18d0460f17e72e0563003c5873ae499238f57e599f43c971c53cb928940035a39362eca29711aec32226ed44366492cab8cd2914e8fd6645a756f3b4e0d2186bbc4493da263bc1d8db27589a65db2913ffd47a8f96464bba182e5e435cff38bd3d14153987f87b209b21695e80be238409cf6b6854460356d3a2e9bacffca88bae8cfaea9861de73a3ff4c5ec37e78f69c52af8cb60d312c7e64cdedbeb7076e1934132d6aa074572668596503a1f5b429867016566af3aa3e02eea44a3c603f04936a53105b32919f2c86f46aa141738277bc1b7ed2a8ca95e7dc2161a078b3a60ca6ff760fb4f3aa0d1f4fc964b846c796a4e2e87425ce52afe5fc153d200f9ca39d5d24a94c1b6bcc9de5a4692f9a6ba0616e801732dca1d671694a9040addf3b3e0af3e3115ebc1bae474818d834bf81f8f7d17d72f714845bc2f7b73d1481d2ae9823d74d208781bb0f4c6770f1472ca6a19311efc7aba5aa3ff0f781cb9b0b2e667e6e4f51d3616df184c0297e9a071affc5b5d4be80115a8aaa16aa1b1fe070602468a0534522f41b3538ee8a23a9c22ea0e2647e8cc32d913bf75e3cb2ebeb954b25ff4829a7c871e96d16304e9336cb065a6eda7eea7751574024780610d5d3ea1e37a7459c3d5e3448067545b6d0405368e0ce7c6a689759ac525c432f3fdbca2d647f88382c722aac6ea9aefcd307ef6c1fa4479950920fcf428ab10e70809fe713ac77db3b28df9fe1a2b4984ec7324fb5480a719b84472d53d0e36c0fb83b5b8f4e455bafb25e9a0f33a1049239c7e6e814a4c0ed3b30287f4001eacfe7f9bb06b10c4b5e3188eca41ea32d4aed48d4a504f4d80de7caae9b1423e3b67862871ac8abe6b3fd847f9bad578b8f4fe179b23522b51e3e425b020b4044d8ef2a36e183db98cc50c83125f00d834eb22b649e73077f9b60251fb35d8f1036944494052f2fe5dcc18e6744b1e299a153f75510c45e96a2f034ff588f8cfeb56ef024f3a3f1db7fc64d66a2b748a1714efd29395aeae5b1dea631add61f3dbd5e619aaf2198b46e95d508325c89cda2a3daea793d90af28385eaef1a5298ae44efc7d8d88c22e31c5971e0b9b13ad099366fc013f83c284db1e7f1da6d54fec6f24b6b7def96556b1b03eb274dfe983c18b2bb14bba99f8bd4c3098c3e19be70f434bf8ceaa5a5a401dcdc57b27b0b1b0177bbb45223cf738c1f6d3f615e5871b6479ed294d9299a279ecb19e98cd49dc11771ef56420122b53ce896bd60e029ffedc30a4afc01140630040e86c845ecf27de077adb684dfe83016fefef103a843a24fda362acd14a4155785158c78529bf01f79bb39154f2181ab7d1e821b0264f3ecc22bf00c9110043ab57fe8b0d35d4ef506e5747512a9d649ad414b607cb90ec4df54e3d8a2947fe61130b92b8dfa608da06cdcc1a683309008c442905fb2a860dca576c8006fa413c68e31828800fa699eda89e294599ac22ce07ea0aa81080bcc31461eadf4ad32db5fb3433886ca38ee6768650926d0959ca1d979c79a35503bb8927b6753fe1c5d5cafb7c805f1c4ffaa4fa53737e83605770e416b4863bc2907b51a62533542a34d9774a00cbd7584ca7edb1d26928d3e20091cc03916ae9ca2d334b2a5fbaebfce320e08cb7561d1850c9e85d4f9fdc4bf5c7913ef21e0f1c8ceb03e19ccc89ef3429b48dccee341ccaaad86cb301c41ad72eb3d58a0fc44f7aa305d04ca35ee34b463785ec92a0afbed207a25506e5fd18decdebc57b298410c2e9c0f6e7a905fa8683fc286dc2586f696dfff4b5d933eeaf120d863fe5321c21f83aab7a0acca9a8e27cfc8fc75be3872d8618b8798829bfa901920497603be85ec36096cbc5ccb1867543821fa7088f401978d9074755f242898967b760626b477acd6814ec53c885bf05fff48f32374274912a1f23d4846fd64284d06ef6e5c70d2f952af8dc503615144fa064cbd5ac490ece107ee941d9f4f762094cde7ee74aa9121d352c2d751a253dcd663730cf590a27b9fdde3723bcba09c73e93b19a08dc31bfac7fa50705fc16c85b9ed035be356acc8c6d8d9a8e53fadeca60e1aac64a2fcae3c34f35f7031a8f54714afbdaf2c9d7023f6a004bfad433b1cf9f07f756ecb4ded20118563d64a6dd32d540548513061d28b1eb294b6168d5149fe9c462b29ca7a84844e777edb20ab361697c3e9c2cd8a7747522df147a76224fd06c895c35461277ec5805103b032fa6d0784ca47795e33424ddf2a51681ac18aa28e3f9b9fe6bdbf012c131569b3a2a84324d43ebbcf8bed76c50766713e68e1afb348a5a5c9440f823827beb655cd5a1cdd9506048d8415f9325811e7f41d38b6c9c85e6c42327555e05c5406bcc4f8d67df9911e72807c69539e27d5e2a171f4cf2220122f62688c9cad169f1264b77748ed1631c365dbe616fb3ccc1cf87f38fb1a5423a99289efb21f13f094bc805f57d90fbd29a5e73241a894360d3de9401dac1cbd3d04b8f16bbd302e5eb8b1840ab44a6a7c0a80c4decdfcc6fe45734ef10f63410a970b4ec309bb5415dae130115627dbd69731e464b800be9412f40ce0aa678cd23909075521f43f81e3ac09977e540a106e2c046494397dc615570839ae0c18465aef01064d20fc3ddcac2bfcfba934f00814e6f76f7ab11998f5ec1f7fb5ab67820a5e20e08fcf32f2f292f8fb7f76dc9bb7d7b2f6542524b7001b32dd0426f1acf26b33f2df0ae9d44e202499a2bfe0fdf71c17d082fb3330ac6ed1661ab72fdf7883c83aa8dd51a3293c796dc63b66bf68f7fedf4337f0eec5f860cd02642d6a71218875695a189bad9faeaa97feb4bf29e7f14e1adf973fe3c4af03349515807653a4bb66978135468a5dddac78b7ad2b0d3f20fa6929bad13a56e52858e92dc5512508dc662ef1a6fad0da2ca4e7d5265f607bf18eff393ae45ba4da9352c9cd463d965148171050a729fb61561c4e21e32c858da29997430350c8335ef79a27b4d57508362442ed20055ccb1f143d6b1f36cc0aa3bc97e6f3cadcfde6d6b0729b29fc7f25f9f07b902b1ac4f2976ae5060ee600543f7133c3026f5a9bfbe90dab1235f03bd2a42a4004840be3fdfbae5abc1cfdcc7038b94a8e8b38df48137840e0736704ea8d29e49671a19e93afb89bc47bbcb27658d4d530922c4aad7e98fe062322e5e68da9a33f7ea9280453325e5ba36bcd9d01fb6c1aaa8e8ae83531553ad3bf2ea80551893fd4f9941bf375262735c0bfc560597dc9d715ba6cb820cbfb3b45b0e7a5b979faa4f6115cd5ab41cc0f8a4d8ead59bdce09f9b419c1d401e0f7f28abdf8a3136ee1af6a857bb09c8d65b4198c7b010621a430a84207a474f08a0db41158e293e99307b9a707c286911aaac0a4bccf94227f5adae2fa059660134a9d0608cba5434cbcb129b7532d016cb43699201dd29ab7a64ef1196db6c40346db8d8c41e1f84d73e453fabe0e744c6c85f91e506192dcabc5d3e794a991a59844a999491fa0235baab70c47e4d32a2425bf15c188891888260963345307b36966725a76373c740c0788d6dbd3d64fe86ff8e10f6534f07e5bcf3fcd84e2edd4057293666501f0db67c4bda11c163d748c3e7080785f03201ea794f9967640adf0ed80c4716dd4e2256ede9e6895c1146cf94cab44c7eefdb98c874e85b49057cc8fa6bbd397eb708133f2ad3b413ba279480176aeaa389237f9dd6890be57c744199f1f15fe2108d53c09e1c91ef97d131c1eb20142fab5511b972d9b85aac17bc2b8ba0f3e29076b222ee2f95395e3fdd43da77718f15019f3a102aed05f86cf978236b46803c968ae5fc9c17f75f0779b543fec3211a82f404641bcfc24dc30ff9ee00a43588bd5c6de0194f036069c00b6fcc30f7f3916e65ab55d1125dede88a8d90de11c43feec0c3c98a26d266a09dc37328bb5b8f2aa904782e252ebb1e2fdfa4cb6ea74c4a642ae9f184e6699460946445bc8e0100f8cd861bd13b2d14db42efdefac6b46077b5041200656d1f51f8f887dc727e19f83dd76d4d2fca4b5a86b7daf7785ae34ff2afcd479f86ded86ba56e20e59b5d61f338689a43b8165ea3c05a9da0ae8e1db2c084e7a187defe052cd3490b0dcd863836561995a2cdb2c5e128d73c2a8226abea0f6aff8af6cd8e4d4a92747440512c93e17feff0bf3d80f1d6a2d7d0fbafbf6c857e85615150154306544e83800a35da38ce55b351f3aa2fc3df345311fb76371807933a88946c005b54d086f5bf0f2d7842a35de3487b65e36e23ca614c9cb9a2592d769c61ad7f4a8ca0e9c12ba97204e48fb19f340b737da3118d300462f4aaa481c84f5d0f42832e18c627d0ebbc761f3e753982ed8e066b460fa6f1f053f01b227f430f972b89135bbaf47bfe47797f30fb4029d843dd701c7ebe9eac3567e731f113d31ca4f7bbc87cbe7c975a5e232f59e1a49639cfd9a2cda8ff44b93515b031a79d31b8887aa80f37be234c64ce4cefe7e7233470de9256f0b6fa0c193934559fa390e0263303e4809c02b9d4e4cf43fe8d7bb79ec314726b745716eaa53b77e74d66c6b592cfcadee918b599b8ae3f39bb930dffa65b28b3d842c18c8b3e24f4f2532b83ecc624615a1a37dd409c95767034103b935953a78ca3bddb5dd703fc2d2f7041d00a4b0ee61f55654aa434c3df8282644ef09db7c9bca01371f23644cb445be6e9f7067f8c7501e49bd5cbe444c4d8c52c62b902b357007e7de9af4efb5448bcc6974186ad1844f1865ae414fb3bc82734f574ef61b8b28a584ebb94aa6be4e455e4a400b6890f8b3bc9778ea7364dd9832b24d015102e9effb878bdf3c74e5e85c75440f2bb504a022cc23634940f4b5a1e38e264c0540ad59357124a14a3fcc344e223d1df3dc520f1c7ca413c26f5abb23615072d55a659becb609b7a813c77a06cf7f9a2af695fa3600d8c0f914ea9cfa07a60bfc09aba0a1b380c3b315d8e0a3f3c2c1d74db780411dce8c9544be0673c0551b82dd4b0dd6cfbf6756a56909626a67d42bf2d43c35032b9313b48528cfaf8bfbeb47fd6d14ec314311e8a9428c1a3f9be113f937cd84968cc7dcdf4239dc069a116315f98680674b8ad99e1543b30697ce27f23e230d1607095d61a1a3cc786319fb9e8fc04c37c90513164747874450bec232604f710fdc9fca354b4cdedbe886f29527698b3cdd98a86282e9701521066aa198ff7c2bffb2ee0797802a077f9aba04bcbf251577af68be958d887cf488c52437fbf087d24dcd1077e4c28dc05cab5663af8cd288fca6baf4f3d269d76a35b1b6b721786481bfaa9d2102003d09f84dee07809b4fe3f62cc5381cae2edd4abaeaf2356f43fdef8f0989bb379fa3b9463d50e76e4b828c796b5b59b68fc37729d32e8051eccdca22a70e2381a15786320fcb637c25f4def9f04b7238a3de71a1d29079eabfd3d13b21aae05a5f4187a0ba249c96b3ee3016808809982f9d1ecc4dad4a2c6fc3904d3fe417611d50cb4d6a86499e5a8ae571217ff4fd1e72d92363fa29d0ec27fefb23de3688241653d728141f549230815fc7fe3e78a24c3e505f1f713085b5c87c55ccbc88492366b2d33877a6a32f16f85d6fd9a4deb17c858e99e5d0ba6ce3ddb1b29a1ffbca0bc0d917d1f707030bc5fc17af78cce38c574282cc88b293e7e4f2c2308e0d7a4921128b609be9c875eaf76995c3f1489e75f240f8bb130a347b1fc86961b4634d031ec19524c81d0d4fc629cdccabfbb330355efc71bfc8c13d95f98e7b8a332c5e9c9749c39444d9615f3fb989460f2d66b731d5b70ae6be198558a5c7601b929f153b6cec7975c5f5fae4c3ceba259f097259013b61cc9569eb5085b501b62eb37f5a01481e45b4acaa5ee4bd598f8fd7e70f1551048a580da47d40e0a822d27a89f221084b004f9c72b609d5f65e2f7e8fe294622c5ccda730659bccf248f484bf266b0f338f174df437915f1d9c8792dbed375a163109938591782be0052edffbd16fb8a85c51f1d5b41dec5d155f42d90f114356a8e6c69e2c30383a1a9b6d17dc93e428ef3e0bce37bd9f90ab7d980078c2710874ff501d74d870547f3d1352fcb712f52627e6dfec07dc82f991c842b25a75d719320ab8579114267690d414dcadf102e4da80797ac7a59bd2e6cb27e2a67948af61ddd881bb13b7182fac009bfdd3c1ef492e932dadc6c0e0a9caee2e7ffa8551c2dc291ac747db4ab6d1c0ca84c3451d6041664c60ed952299e3a9c22dba416ac4c4ec808d1081e4be2bcc69afbe743ac4377ec03f60c65f8a4706374bfe3027013311d44e4d167c507b4a9712c1115abd27e35efe57b92a190b39201defc1d9a7dcdd56be23a0a0ba1c87d1d6f90ab608450abc2e96d9b0341ebc426256f7acd1ca032f6b6dbfb0052aca6da034ee59c94686bb3567a09511785cef4cefd9594e4079878c3b190d285da45e02654b0c4fd61afa6f5a2ea50c6c7250090febe2c74bbc12efff70259e1739747e822b796f071967bbcc8a65f5aa746f2029ec6f724d5cb4cbfa97109e485337eab9fe7403b10015b8e7f495de53c3ecbaa4a416a057abaf853e1ab38ae6582f3aa9d4bd8ccff294cbb64afc966c405bf114f96f95951c7b0297f52683105c4cbda842d88e06e36299a938a93157d156acdd9d5a4124eb1cc3868bd156dc6bbd7bf8b1793660d2e8e49b093c89b77ad4317e01b8e598f5212c8803a9365f2a7bb3ada92f85d9aee3b99314c10080799db313a49b632def18d7699c06dc2dee842f265655e3684ac9e531f94cda5977f9bbe72b228d0099bfe97651dd965c7136b88e7beb7997216af8656888e50433ab4cf432a9f966f7d147584d400d740d96c3262519761cd11203dfd245c2a1136b0ad7777ff336d11d89a400058ffab9dcef358ecd38f802888c3f8957ce3eb94aac8569e11aa64b681aa30733da9dbc966b22c783881a3b4ed14f035ae520c04afe248e0ff8a3ff2a3911964bda7f40bb0ec4f8fcd9a073fee5d1c4bb85fa748003da35b6aee1175107d3b5b1592773b065c984c68f3367d7a546da7ff947bb51421bed3ab8045206ffe4175ed96fc592a29fdcd9f57bb5f9f86527a00b8b1b9d2fdfecceff20053cbfb4ffbca1bdb120bdb0e7aa9b6f9e03d0169f7c300fe86b776107ac11c72a8c878123513bde9b63da8eaf165e539738530658a4adb7da1294219baea64643e0a2b8e7626c84659e7aea8f77331168ae9610a49ca45706cf5e82a62d12494d0ec94aafb7a9849de9809eee7c4ad5cf51bf742ab7c45259b0f1234a31d782b7bd776d9f9be4623ab419ab61fea4e79e829b2ffa724194420881b17038cb4b262838f66497697fb2f47eec9e741ddead8ab30d257dbcb2549c2e433ffc3c2e4b344f0fe39bbf5fd869b169633898d1bc12701897e4c46fc881dec6b268847db7215e95918750a88d2512bb056f94b7fc3d252d66d4343feb947b1cba862aa1db1f10cc23ecbb0f0057b2193a277e6add683c9d5648a8d6d0eb23cce8581f27200b293662d1c5594756b507c5a3a7df88f6755c850ff34d5944f94e9c28ee6436f165095e4acd57a49feae3fa57b1bef7e9e0c7594b2bfe6a3e8229e89adf3f60fa2d265b3535338efad119f537cd2651ba1fa156abc04c89b82cb0e1b10a93b2461a0504acf6a58b9ba5e212e1077da575b0564fef8118b5671fb03299f4322709116177e4d5026c726e01e4f4f4a6f9fca7947487178f5be62d7958805c6e63643b213e67d947713304fa4f71dd82b081fd042ca972f2fb6588296d237600ffbcd82d5dbf84509899c60453e9d799ba01c659d046881e23ac5ce9feefce7f7d3b758ec61298cc8b5f4d94f01b55a4bb22e6dfb6dd38d714eff74f0ae623523ae8ab86243f1c126a139f9cddc6686261c5f5ffa234fb5d0389c1332f906bac43a7b222ac1ede74c84ce14473715d3aa31ba68f2e677b5b126a1b9322ddd78bcec3a980eaa97b4fbfa42273fb1d425d2fe4d3d2078025f186b083250c2d65a6a3a8e492f907101ffe52e7e49298d6ac37049a9bec043fb2e250db8a2de0815ce2b0e07819dccbfb449901ab98010b00fee55b0edb0a783ea77c222120e504a5a74e1d41029913f0284499d7f8034b6e53e521f15f3b594ba0d53dd77fd2252cbb9ed6063875fa7823a4d71a61e6fee9778c78a6f06dedc87cd8fffe8802d525844148f4cf4be5e50a7d2fe989ee093411349df6219687953d5bf097c3485a5f46eb12787dfc5de76af976787c5c0f77a6f848fc9d47eef796397e2d037d981b6e8eda0c2260de39e1129f166a1a1b024effd3b64c7a5c9ec27c0efa9e278533ecc9fd863c84c4fa134cb0184ad2df423b0370d8874f950b789f5975f078cc3b84591baebff5370482151e12c575bf34eecf5613f841378550193e1c37d758c92be308b4e800af7945b3b7efb85e057fb0bf942107a11bd2f30d33cd708b4b4f7c1b825c78b3819afef005acfff8d3af5cd988fb03f6731f53082dfee692d41d280ddeddc61c5f2c4b965d3279d365cec45c09bcc280f7c7275ebdd64e18e478bcca052a12ec9d7f35bbc3f2befc57f88d224ca6297d6d040354102e42478884aff46885af1520c78e0d63169a6b9343cdbcca154a074cdf2b711f9dfebf0897fc30d264964270bc3825b5bda1ee87b4acfc6bfb26ce8906f404dc5760096c4ffe2cdf02db30671628d05ddf31a6180929d009d52c40e13da007478ba68be589e4ec2605a2b072d7f207f6549ac749bef741f6f26f5f501c59eb0add744c6a2bb11cc7db6a425a9057c004732b1f2d03887459512e77ac6e2b2b88fbfa841e8a82d9b6237c981a74da7e95235ac9698844e168c1dec2b7a415fd6a3b81573d409dcb4acbe7cbf9b727dc2aab649b487657c89db6249d9f2a8f3b5ceb0913d3d810e1bd10ee84cfddf1fa6ad07fead4d2d1ada8a92db156791bbcb02ea359c82d0bd010c1a5ff46fa64b47a27465f47ff2c5d643a3fa350f5a6fa945ab54ea186b9163ef2c8b2f9814a99862285c298bf6b22940846ebff3317ec7874ef43ab621be95860deb78a811a22a17558c65c52e9cfb3f0b27ee9c14ad360f9a8822fe504db60b91c24ef27143240cc41d4d10b027c996db429e92f4051af413bf4129b420c5df70e2b67cdfc1738fda0dd1109d5972dd5e7a617bfcb90c947ba4fdc825834bb3e8f460a32aa8765711f1813960a3311a813e14832f4799c384c6cfff39fc817b724dc2c69d0548bafa1d633de91281a44d5cb9c06415d969a8a608979f2cfcbd7995f99811c7e8c9e5b148c72e376b9ed858cd9c0d0db0a1c30bffb679caf2005f0d86872cfb41bb0f9b456794e542c1babd59e613e97f5c84da31b1172c73748e5066a50d9c6c5d6ead2e991a01d392d21b3706fa674583a158e61d43aa4b103a872223e262881459479ef7749d9ec70231d7b40b6a95aa4889bd35463d156c8097423bbbfb81f990b16a669db68c03598be133452d006c17a0b51a0afcab06eb270de6a5ce24dfdc7638384ecbe19b2c50c96d1428e211aa030ed499411f75643baa93ddfba55402ba8b2534d757539d6ad254cce648ac8dc4639dbda86596408154e0b4b3536c11791ce1616c5dc8e02ca3ee6678e6782073da5e0b30ca09280ed7ec59e32b2649d4fbaaaf7601dfc3e5539d7e6dee506bef4e3dba99d3f43b0873a9ea450ae7f51a9ccde9349e579ef4466ff1398d91738b8e8d050b3bbd8ef82ba768e617535855cc7e40dfe5752092f633d82889346e0762875a5e031f19f01a7e303d89b55c72f7382e0345f9ca6928da61f21a6f995298d2b47dcc94438462be3e3751947b9dd2aaee6668bae3450365ee108ba301171c5455bbf718af34bcc520fe668eefa7c286c93fba17f6a8d3b9fbe91b6cf2af2ba52151b977fad0551298e3e2ee8b6778adc34817597dfcae0301972f77bb3e730e09ec592e72ff9035e30ec9b6bae9e09bed30973eb4432f4992616ef274740c08a49a7e7ae41064eed2b6a4fc65af92f94a8ab8419dd68c12b6a53ca81c4e8bf3790f8e11fd2835a79cb1b9dbb37060931fd03e95374297142320ff308810e068db82c76ad2f655973bbf041a8c42f2912b7811755912df7fa4b95c577ea7d79ceb9d8e0669d40ffd2ac5c19faa4a0a6f316153f1712dbaa585d0b3ea0c147c9eca2206aa8ed8865b82a235d010efd18eb4665cdb880f0d7a56b102dfcdce8d87cd0379e8e8e1dd8c18ccb1377956f836f75c801550d4b8104a24283f8feb2c613ef60a63a52864049eefd74a0bab0fd923039eda93ad5ade8ab6bd1c90fc4939c8553df0a9128d847a47b0caeaa6ea21d44644ed0653ba31cbabf8d2829f87dd85ca1bd1605f626c1d4791070affaae991952789dac047ac86468c78551de82eef67fde0455ad48c64a5faf002d05a7a213f408f189f58e4a90e70d40fa4e2130a63747fc6a7f52919516f652cc0381204023ed23c2fbfefb7221c6c47a22d8bbcc98d4f79eaa75906c6f3a6d4a9275359c1b70164a3a8ebf5bfceff082f244668e14b5efdd15fbf9698f9dbaea67ed897402f9f8009b5abef4f2a28bebd470c97cefe98c3c2d3a80d4b691d5f7aebda99509d8828f0bde548dc2094a897768e28a2db4528dc13ad176fa0fe86165322f19f99c63e8bfe40e479218da45672f2ac6e7bdefdd377574cd3c02c6ef7864236a7349edc6a1dfc4f79be3e340165617a339bd2f3a3ee641c084d784724f38b738c714aa56b98e9031b56625a3f485e772b0bfe4051b3b5f0fbc63374e49e65557e8078676f6d346edf8e81dd390a49ccf33775df325193b95287428cbd745b0e060d4b100f48b1dba44a8e98164c6fb611e94f27d30636c5c002d892286c63e85e6a43230818d21658459bfc1932934eff07ba4094090e48265903a930ed38e31917ae7a65ac19d657cae8fabf93e3f98e660296630b5aea286fcb90c91f0c831465e28f346c4dfd710ba8e0f564be09a63dcd84a3517930a857b5c12ec0424e2536a0fe5f13102fe41662dae2e8349c47019d7a86bd04d66c037bd55ff7bfc23c24f09bc77363da739b49c7d3ff9a1d3c6812959385832d55fae3fbaad93fd603511584e4603b41317f3c4a5331f77b406917aaf5420b37368e82956bdc6ff47d7517d1038c609b4df55d254225d8327a147aabaf1d68e23debaeaca6bb4b4307f5e063e1765cf01cb2f146a54f99b1b32a340d35ab828db6f3a4bc05988128ba1dc62704b0c9c25b2b1cd460960347031d51736579db89beb8d5f3860d51d09f74b8173855dcf5af727a98c8caa40c945842f82be3f4639192c6d4688fbaf8d8e92ce88cd2107c21715c842cacaa745700a8b83360a25c0aa5b0f2d648931d1dd4848d3172a57082368c8b022a7447edf10d7192b3c92968c96511c61b9b9a9edc38fd973715403151061dfab27f3522b6ef7b99b66b2504fc39dee0a9d6080abfb017c0d35cbe8524d3d420ae4125942efbb64081e8b32a02abc3ae52411090aecdadf0cdc90c9109b4419076337dd679404ca600990840a3c35a33e11f20cc0f99e70839b4145db011733f201f907ff12ff923b6537e94da1a609f3974b92ea6a64ad7c2e44704c278c475284f173676c07a7aed46222bbee0e15118b4b35a7e8eb991151c75e921b4707dd8e56b67951f2933f81e7ba0efe230ae4acf81fd5fb59f3a4261251f97eb3c1d4ffd9d8fa72f24b5aa1e59c5b51e2f8cc9f5a92ccad57f08e9bf72689d3f754646a922914815f209e32e81c63a526968ba50965008262ec9f4b2c38dce632b2219eb3f93f57ade614a87bc66fa69d2ea551def48663f165148f87540fad185ee9502e8a54e9728cbbedca3bc96c135d98fab21a6cb966c29a30232a4079a47bdda9f0a1af47436711ad4df431e4955846b5b7f37d309c207063e89aa38cae96522af49ff4b5afdf0128815a3f7843e2371b21d9ee51861da23f1d967665a1da1d70bb189b6c05a1471b3d88eed37d4e334661cf6b3da8058c6a2e86fbdda8222386e1a76c920fed2b8f1a01805806d24dbba38ce110ce149d86840b0c462ee93d494ecc567945aedab5e7e04bf70aaed07efefa011268c0ba7fadba9e788a7bf93c9f24e6a54dbc58ca16225b56407903555b15df62466539ecffcf3e3131f208cb59229f6ffd4e175fdd927ebdbcd17d4464fd1e8497ebc9eee727aabf4ef1257aa6c9a960a99f1c6c46900d6b76948e1f1fddab5f5fbb34dbda17ac7319f1f6e6be7045fecc62bfb7a979eca7be616595d121b8931a4825184df47aa788b5922fd8388f8ef3b7e60b415b542904b1d9f3f8c827599390a8b88b3d37c4bb17a9a93ee7ef347d37b6e1d21a14b18b548daa8e78b06a68f7edcff9a380037eae035afff48294db917ee8ff07acc8c88e636fb9f80f0ecf48b73bb5a3374e31e436e730aa29d578d093cfca978006e3366de4684337a2c360f7d27f3a1b00133f2da616d7dd7ce5c01645aaedcf6afbc208ab3c7b481200af7279d7ef5a079c21a0af22e349e43bab82b17cf3e71a1203e0f3c2b8fb913f9637ca1ca36d868452f0164bc0a346f5f356b8266b0170c1f1ee7607f0609eb6538a74958a86484701f7e103594bcc580a90d74eb88aacf6c88562857c3982104a514e7b49a3fcc3672fad6cee6c44c00d593bb2d18ea7f139d8963697b6105ca67ff7c0098f4b1a615e49ccf92af47d31696f1628a7fa75bae8a756e1337c738ae48d8e952df22cf19823b655595deaf77c5a87a8df11ecf4072fdfb2b0cc11aa5d22441c82090ee656b11b56af48623638b502382fd22029499f1153a40d8304991e7a9ec7eaaf347656c9e37a46f37a92cdceff38f55c8b048370963655685ca93d3aa63add14430342578d9ccfbd491d42ad478fb90e52897e37da8900f0901d16a4f968757c77f7b183667146670074071b5f80eff7cb657929a284b047c1c31feb3e2b8a48346eb985fd9479fb340e6382fcb50df908c458560dee717647d78285dd5bcf1f21d8a7d302e616c72819fbd223195025e6cf7afb0e84fde34cee740238899fc0f380ca5f9bf7f35c2660ee8ae685e944de59893d257b3d36f0b60070578f9b4d4b6f221112d82acf2eddd920c1614cbc745a08339f1d34f6917a46cb4890f3bf78bdfc3b22ff20d491f47866087205f48295c94ccb08ec806e168d4a3414485e38cc0c03b96da010ee0cc06af934e113fd9d4ea308733518985a1cc7620486d7db560c3d5c7cf19532b443e0cecdb83d86431ee53233d8f664a3c1ab6fe5dcbbafa32997a4c9c97322194dc37f12c00557f174d5dd80480d7b8e652222e868ff2703a67e2f53b3312b48c18c11bef17bae9a7708ac24fa3c0ca1336b9825b1f14c3d917ddad57d3e63248ce0db9c7c4a3a2acb79300bb7b30e411aa09eb144e636e25a0a15b3b71834867cb86922917e9a1c6b9b78b48cc5280a7d8fc16bd8e38fceb7c1c903c9f70233d8d8432799fa2a682756fa3847a63134a6f74ca1edac6361fdcafa792526d3692b2105c39fd7dd279709c48bad6f0d75dbcc6f2262f8a2b9a61e4a683d9e6f252d2b844f27839a30a3a03ddf8a67dc04d9ce2ecb55434b65de97ec94637a2bb3ec5ce8a113874c5daa077b01b4c8ebfcd167f8c34e22e78bbf6771d52f2205ac594184cc60f22b1eb2e11b714761301bcc31fd7c3088111d637f462bc26a8ece8a1285b62e926b4aeb77da036acdceaf09867cece2ef843d0b20f9f8d97d395f0c20e45e5acf23602f5fc222ca2a8ee43a174de0cbd60e8514ff4c55a9bef96a86c07fc079b61055b86d623eeae10b6b111f824cfdc3591c4fb41f7cc5b83c39e6e400e1edff60c4edc7e1fe37a2ca670adbee4000319220aab83ad216558b3bd6736e0148d0995eec2873c66bd309384dc41df82263ff14b139080b32","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
