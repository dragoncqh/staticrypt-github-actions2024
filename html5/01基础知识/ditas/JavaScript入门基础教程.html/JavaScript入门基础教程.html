<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34aceac87d1391c3c2426db8ed94102a3fc39dcfb0cd806911eeb4523d3a2a32b93b1ea2edd07bf84acfbf5afd4618a0f337988501e29e03b9b5020ce24e4cc314410081adeea4bad4bbb077a245cad46b095dcd72484edbd8413c7805f4ac60cf9713dd520ac9c175b00746a23ed91319f68d74cd3e9d8df5c94f8717a0d04e87358b1cc0159b4d6056b514c9b035a43f5a637c52733a7652095b44b5bd8dc699c4e2d6c6ca7a5480873b409c2e0a955f6c9b69c5342d950391749063ea1d03eafefee6773abc9534faaf48f410bda25a1df4e8469663c663ba72fcc97f5b1911e7349658807be9101fb3d9e0eb62618ee81155531471dcb4650e84acf1855d9e6fedc0c887b7a40e4410d38979f67215d91273ee26aa1f558981ea3e574a933c55b37ca280676c497af0c520101ed4e56efbce232c9896283178eb8cd7204904b10e0ec5ca861773bada4cb6143aa47cab0d8ca5ebd0d4af532663acc7885310d82af7e1cdff592127d9ccd22b82eca4af6a5a9209c9efd1749edb497ac31872aac62294fb9f13070a2d83b340479fa9e6cd478e5438d0243f86e6a4509d92243b57969c867b911fd9857c3f31701bb147f6305419f345d6646d3b4a3e0d088e8fe6caa32cb42c032c26f9a1a91f58b9d238c57c7c1914bc07f0930508120649c041c1954a9d4f366bf4f32d52419ae95ff23323bce38b587751e64ee4ffc4b91f9006e0676396b26866735c205bb62573c394c69bed1ac98e33be7c8864c8a5ce9ce4022744f59dc471156a29b279720a8647c43f08cb4cf614ebacba5200de764f346641a52803f2615faa62a485ba1d62c8786661a755775070ae45cd2ee16aa23a14a6d818bf68431c59fa533f0bc8663bcf77d812677582073fa8dec0a46a1caee8389585c1289ca676ffdf7c4c5b8f4a4d020132b9c54f794119a9554090542c5d1fd5a005a8f4006e9684d25fd8848e355af64744dff9bcaff48616a24b5d936815b065b931b53737f234500ac91c793fffaaafedab764388ef89add184c9e70969b5f6d956156f491c39f57de413f2934e423d42a706632667c670fc7f72f025b6bf793f2462567f280b950847de7943c56b0490cd0e031683bd5b793d896a293b9ad90f2b54997690005e1a298ea86c47247ad1a840d70c5d2524bd699083e7b3d66fa6edaa4dfd6f04df35372112b36deae58621ceaa6daea3e681cc7bf5601dd660d32bbd16e63fd1da55f4146e33af9523302c2cced6dc78f41f0a5647f6a02844a12740c8a8d8bdd8c7a070034fc1556c97c1cb093d2a44ca0b43cc82561e3f778ee66f117677d0781e170b7c917b4d003aca9d7d19417e53dc75e5d0d4f6fcea6dabd9b6ea2c4bb38bef023c9f03f0d40827236d02df5717e9dfb8f6290f6898d253860d08d260dbbbdea042ef4f90ba9373b70a16196faa3b842de3018cdfa56f64b02953ccdb32b8fc24dea87e4aee2485881d601f673e2cac08f62111a38d31b6934c6d133a18e6a62189319f55d21edc28425fd8970831b31049426614be666c6f71da57d6c9060643b18f5def0ada190077f88d13ba802d606e2ccb662461c18105f6baa2988f6237cbb079be7583c64c1bf406a533fb3ccf3130ff2dac27ac66cdc4438318d398245041fdf0b38404672be57007c273352b81266bcfc8b32a00a23206ba4ce1c3fa5f004f6b9fb78ede896ad091dcced9c1c22b0340706a35d158755eee91a2068ea9cc2fae077a3af07477ab544cb64299991a90ad6ed833fed455f5da3213518e641dd18e54ddb9ae05e00d21a89eca1752b56e76320c5fdfbed6a8779bfa2f75db767a2087fc8e7be8a1a6d1eb2901954c5b7b3d5ae5e9ca03291a93cfece01e928015bd1c92ef3e21021ae60c5735e543df0eebdca01faef7f424f0aa3cd0bba8dfe95f1da674429c322df23351d3f56f65bfdb7ebe2df0787b274e9c342664b0c73360f1d1b75660aa916273e1ed82b02ba06644f13202dc37125262f6eb31702861a22d79557029107b253ff02e212698e79e717d4bd2f820436c534b321287dc99e30bb6db15de4b2d0a55513affebeb67067194bfcc05b3d91aa9ce4f1c650d6246df8fe2776674484ed4b2d0da25b6ceb70a2776bcd5a2e07a3a84584d0dcbe7cb02aeabba876fba6de7c24cb5b85577889a1913eaabfd6a0dc8fc65f51dc9e5767b1c3edea7f0dc2852362fdd9af58068c98b78109520c22645841d5a8f9e1a505553b6b734eedd673cceae0873d73221630b730c8b022b4c29bd6b9f6c2dd0cd2f73ee117b19a1a568ecd21cd07e9d277c160532bb5fbd5d17d7223476fcee0abb279f593801d51ea2a3b0eec7ae1d5e542be36ca3a6ac4f50c879c0a48a67b351c800b8dcf8b1cfa14fc8d36148228deeee3db26911e07abbc4533089d0ce21a876f5194eb7938bfddd04cb804e87da7f53ce9d6797df3e2279a759a44b10409db5debb6a0c0c5aaf6a2bcc641b8d3e36289d26a1a506f56957e0aad977f1da9f92786920ada50f8abc032dbe00b1bc1a00a1d54ae5a375d70012f543b4d6f90efd738636a7f9fad0a06fe9ffc571f67cf4efe2872334fab802f9ca792049cc7b189fd5116e3bed4068f8300a153f2c14d00892f8fdea7c6da88d120aff5c6e1c5b9594363c399a1d23b595f6654f0aa723b2772d3d09a0b9d2db5efd893abc15106d8e3d55b66e5a3fb9eb4ea7953df0b8afb5a5117f25a0914f9c71b4ce17012fc348bd543eabd37189e7d5bf8b44a44b9b76fb29acd25d56fe580874bf000efd4627b6270cdab9dc3c0dcecf18429fc28a02bc924b1902f2ee597bed6ec1c0525c06251a426cf60acf0ba449c0cc93d376d2cb334400986e421be4cc819d9a77e5aa27ed244e5df7fa6fb677fe272ee7b1d7edbe2b30b3701fbf4bb85512db2f378710ba5797590eb4d27ec4200f77ba7d2c938f2ac46f9235f94fd85df9ca131956b895730e6908cccad5e4088c44a9cc4d78c747d906bc5b150a721dc0e7988feafff4c8d30934f2b87a30930f9d9ba46e4d44e9b43c7aab488fbd1ff59540d17a8b70f0a20012065b1c865e33344bb6ed129c47dedf0b5a36fef5f93c109f1c2ac813e2632600249f607e3157ead5ca41a13758bb4b5355ee9694a095e0f5a092bb4b6e7904ff95e894f601da8ba50872bb869df96d86363b8eb76c6e3ed6c0a01da1f960c7ed7a732d5de31d291f8a3a66b9ecee1a74c517d2f86e06992cec4441dcf94dec6a9e3d313f651591d6eecf7cc8bd01e801c050d81281da8f147644a41bed550afe4318fb2aea62c10cbee3cc79f339a1cb92fdb0bef393907986e5179406d31a1ab1ce7be8ed2e78505a090b213b8c224725383c12c612c92a470e778baf93a0c6cf22bb36375735e8a6d697d1738dfdb75770ed9738fbdbff04553f0372edf160aa90377873461740430aea8b03a1c4c0fb762b08f7e750bfa12f6099e7d194976ea00973683265a0b713c107384b8419327d14c64d3a7911328f415e2829c2f47b6585fbb8e4f7d5aa96334d8d4ca4fb9d77f990f01291f289db3316bd7f34c952fe29867c3e64532757967d4d29923df105682a8ec05fb745d10676d4e21c06d94dc083c6d9169bfa6b404ae39cefa54d8455dfd2f55636a12690a7ba220a947eff4e1acf4b831700320348af9d649c741096926d2b5b9f181bf775651fb77333d134876777b1e2b9fc2e08f54b79e6644165a3a27fac0b827aa317ab0cc670d5ee665cb20594ec02abf395a5d0120b944764b5ac133ef15fb30acabab5ef429b622857165764531ba439866b295dd57d48bbc1c29918937bb554e37e972cfa0954fb58c20f34c8294876dbf87c8633345565bd543748654c55ca167bd0efd28d2744f98bc87e70f8ca0c9d415e39b3f8996df8cbd3c80997621c61fafddbc9ef3c506707d0baeb2f325191ec1ac25860623e27f2e3c1214ad7e17bfd92900ba9272748a0eac3408c61c1bb654680f4d6c79fb92f4ab65bd781d8a463d2cf0b3e67cd4a82843ef024abf029a1ea9075acc7bc66dd5aafc0fc818ca5f791da27c84810f5b87edbfd73490e600f432ea81c94cd3ec251febddc4a80089915939c1f82500430105a1969e11799e344d922c0ff2e3af4d253577482d6b3c0e6476de64f21b919b7d3831b028dc558f91ae5643ea54f6e7731d15059ee8f42dc2f2da44d9812984bd0048f9844f6c0984e5438a95cc752d2d587b59532524cb94a1ed4808bbd29f25dd340f05fe3eb8bc4b7ef7dd7ec9684411c20aeaba5013affb7a35252a8bd1587cccdf68f7a8fd638f56d0175f08d191206b56c50eaed8c8c86d5a5c87878416c8b477a97c2ce733c30d12f1d83fcb10b602c3d626cb4b39771b8f302f52328e74069e8fe30adf728f8f96861605a31b4109ea168bd5200787581241b9d7ccad80287a3fb4521248684f9ee2e7957cdf7abeec5e81004571935ccab17675b468d5d88e82783803374c11e98448ab089de0c5bd8fd85e9cbabc1375d9ffcab67f5dcb306168ef1bb57d98b4fd4a54d3a47567c60d3517bff580fc6e053fc2bf0b949654e7596b7c80c693ba3eb5a6de12cd85dd3d0a322e9cc3bdf8b8c6c1fd197dd0b87d979d779c19227e4a50327be22bfc51cdae15751c2bf326eaf86d991f791596cd07aaa3272b49c2cc49eac3f76ce395663dfd0d6f851596c725c1f36a11067acfb8aaf7ded0738025c1abc5b53e30001f81c90263a3a1979e79eaeeaff573dd718528bb071e811db8851896de06e0b32939ee141417fb8a1a356e475bfb9639c6671ab4e4924bd5b029c3d5281f5286945db2851008e244a48ef08cca2e315b675312dda416a273dc468c79576538fc871bb25af6bec198aae7cd5e1e9ddd05e806b5ca32a20df3f1b62d7f82519c51b449932af06697067bca825d1b03d611bb991ce2ebbeac75c66947ab96d708dad41f9d8d1f4c92bb7a89a656be55419aa2450b6f53e37f74981cc1004f12470f1fae17f45b672136f2d517a9930a6dab365f01a14528959b13a9701cd808a88d553409672460887e91ce6a933e1940ec392ed9f0d2c411e7a0d136b6840cfc70843ebefc30781f3071a7bc16e135380242b6bbbfa480fce83848cd923e246395b1c9b0b80cf5f6b397a1295d469015699844344868044d1fb9af3b11a86e3944ea1dd1521506057b54fd7d2134d9c4735737d9a2697ba726cfc65065d13431decbed91a6980a0ff06e5e1300a66c936ba29c906cf78314b8004fdb9feaf3a9dc299a625e6b523a77305cff1b781121f30240fab3602145b167ebb7b6701b5c46067a939c2f0b82e6d4beef40c2e1c54ab0931efc59daa1d47a2af2bd19c95509631bb450e1736f70d4574d38413c36925385f613eae1dc386e35f7c6310a316321f8986f512b7f4b6b11c7e81a49421efa8121eea75b3ef45ee69acd04c20d5b971abac2284bfb03141dc614db478a36e9c2f10de045f825a20bf37bbd9c9ddb4b983516f56c32e9e8319a282f89b71b6c8aceae79c185adf87a19fa964b05ef067873fb158d64bfdaffb86e8f217860ea58e0083141d3cedcf4d736d734d7351f6c5405ff5f9bc49fc1b73e051c37203c70987306f9cb9194300113337baea5e0778fcd7e7dcd02dcb5a7221b4f6392b898af0db8d1407220045aaab8be0de85cc4f3d693bc8d650b9c4571640003c63943274284f9cd8bd0d0471fedb8700038cc22e7757570cd3b35b36e0aec22e667b03cb8a488892166b80a171fcf218e5673782ca71ec91988a5478a8171e62c75e4a14f17fd46ffe85af2e03b0d24959ac10e5aed37f9d6028ebe8ec626ae571d3a1cccf701092bc4b890341605ee336d9a06bac2f16a7d0c3aab9ed6661501606c93ad8070afd06934b04868e454591d65ac5adf4e14b4649575fff827650fbf91763a6b283a0aa844d4138c611c9db64d5b70203183793baa70d40cab05e3b415be6c4a01a209b2800da16a393baf5965b4195d4feba1f74fc1bfbe365199536ce5202bac32ddc66ad221d1df42759c7fe559e7131e80c960f9b5f4f229a506d8600420ec861f2f2a0277a0dc560b09094b484f88452a53716c41a9b1698618721080d9099fc9e71c3f403552c8ea0b48cd5986b75cf35cb740792e7cd09284f8d3f4b2f04e175d135a1c9fd1972eaa68b358bee5c0fe7a0bf1e890cdab10a1635e8ffe213bcd4eeafbe74971934dbac041d4c87352c8a31c0f15bce9a903cea82213509aebdb4505a1e0ed070c9353d96943421db64455d463c428a8bfab72135c4fe268222d8ec577214682b0aa5fc9ca26eafc92b3f888fb049b2d32d8032a0963b55b5bf44ac8d237f32035fcf414201f0910b1731f5052e2eb7a99a5f082acd49026efa48179248afdc72d1573baf2e1e5bb45c1e64e4bc7aca23bae9a12514277e1cc613b0431e384a3c53b0afdba1fba6829c737f858d4156923086f5f9fe7e0c88d3b0488d6f7d1a18c7a3a9ee394e98e525ff277d7e0c0a0d07d3e9018a8b4c5c001e745a687cd8269e79ce8bd769cbaab64850a1aea7b1ee4802ea96c9be4454834b565aeba0416d2a6b55e12fa1ff6ba3f5e459e73442b6dbbb0ce2cedd79854e264976f1e536af1245ba8e9e4645e5115725d0eef48838c5acacf39513bd34c5e18d253d9e784a39ec93ad745a4297895cc3e6c4288ace7b52a9247c7add2223509f51e04951ec82223fa8340ea64cb2828250a9a813f667392b502356c87cdc7776675055f04bedcfee9fffd6c47cf42950397f4dd981aebe93e03056bca309707fc4aeb263a52d5e97de9067a39d8a2a5da561f3faa21ecfe1a6726ba7dc093d63db5e53d56ea8c42183338c309924d1ee00c43a53719298f7388f167b86c5a828b2cfd151e4be714d9ec7e1f45ba6e01d448aa4ca380cc656246d2cfce830eab6a70013c7abfd19a76ba71443f9708e973ec1cb0ba86c0c5ee0171cefaded7b83275ed3c7356791c86bc9aa255bb1b555562af8f6c532cd4176b2a7029d473ec1d6d17469d41cfbbd3bfe9902c8c7e87dcb9fb2da15b1f8db0be1038a0debca98ec01c3b92a5dc2102defdbf6df0665faa1baf6e44f468d27f7ffec93a502b72ccbf387db88c97f7ffa50f7c4473d6008d9aef9a86548304cf13e8058d863841e9b57b1f9fa44ea99907aa5609f15c1573142677e01930099e3ce3bdd3d50a78175d85057fb399e3aa32fb56860ed047491e0a14d6813329e831e7061f50bd8e1b9ec9af2317c9a8c646f22c44ace94341ce7ac70afa6a65eb9764d9b3e1676124cea2f374d3588ccd978c25719b81b8aa2b87131ca51a563a2ae05f1d58dce9613368f678bf4466d82235753ac5f5117e9abec6383c19acaf002538bd510d21d5848fa6130cc3d2de39cdd51d5f16affb2eb6f1e838419613862af900a286fabe45dadc0390ef10481e4bbb1dbe946ebe9aa26405dfa1180eeaed2b0a48aeb2eaeffa1c891d5066f7eebf184711f2cd43b8e9661eba30a8393817daa3ce5ec95f2118728cb1d4c87ebf61d9c1e0f702cf0f23edab8bc43747543d9682d95d18012c38772737bafa8078a3d028ee8477243a633ef94ca45558ab8ec514d82a6102675279e5a7e433e2f225a790b59050965bbf83220cc5dd3952fbabbe64357c8a512609fe929fb6870f3f35984f6fb88032a10c508d73be455cc2d6d85758008e0da51aae63961bdf48ea2b7f44d8727b49b7beafa85b7d549db2c70be96c1cb54320bcfbb3944ef8f23445b6faad57935edb4203c684c48f050f5c6e35ce16aba090c3e094e83419af09d58d3c99292f3b9db09e2a9f3020e9927428985afacc0426aa6567a55d8a384a55257d530d8cf7519f514b6ff6d51366ea4d7235124ae0313b363937026a84035ea173be9242596975dd55eb29940b5bab6d669f5564e4d82faea1702ec67197fce675f1160d7d30828a022a7a4a55326bc46305b1c7aa1bedc168f7d33addbe3801537021c0670856d66dd58ce7894980a49ea6b0f86972def106fd5ddc7b075469bd4d1fc128bdcc9fb3a3d5966b3cb25e6ac8ef67325d414387613deeee3ea3b7fa4e37f16874af4cda94a9e7b51178ba450cad53f548b7115b39f45f6e819de8326d466ad7a82192c4d4a1998fa68452ad9b9655b3e332dc1f613383cf87bf57e1c187fe50ba346634c598546e1c96d96582fb96c968974ed9bf107b1bb3fe02d48330f6868f7d5c692c894b61d4a17622de7075d99ef267ef8edd11645b6b56351ac7cd5c9fb14fe3fbbdedd6a9544612dc7cf161dae1f63f1f45459ca536a157bc1c648452ad075a681b6005ef37d26079012782aef51c5b272366c07d31152d32231bfd24a78ee7738e79f758e7dad3a2f6ad5f3f8c69440268f10a284a152ae2eb65d3cd9d2c87f667eadcde781a73dc4677ee448043de7ff6c5d08172b6d345adf0f14f78a09697f1bc0a0a7842e644721ccc5f3399a40b71302371ea33bb26a3a3061d8a84552bfb9267ae81fda0a3c34816f553c291ed36a8ec98dd8a9aeb9a9a0e34ab97488ce0e92f7160f08130e3c620e0977c607996d957e99be6ac8a962959fcb672380c214fc6f4a6ab529e2f08cfcddc57ce6cdc392071be912a1e88c1830192b147e5fe6d2c745d93d7521e66fda4d05cc2bdb6783341933004a28a0863e76c290f6f51edfeaa615814465b735980b435f4e05b1cf6982e8a756e77c62c827250e3d4245f67770efd7b222333db24d356f26e7b4e8d358619bbe2b8f0bdf870a3fa8eac025b4b6427ea2fbb51cb0407a27c31038bcc0417d782f1faace73aa91c31b1e34b872e68af766cc0c87a77271bd58abfc448e107411e21182bd44780b3507999e5f182d9ff3dac95360328e4696ac518e98912b2dda2234fa3ddbf52ae866b108fcb45c36af4949792ef62339af4344447e13c760d3500c017011a5b45d6415415e7fb6865b5084d80597aadaeba84fb79929e7829225b6230e40ffc93b8cda048438375c72b22c06f0d9bcbeb9d71a08b3771aea75c66cfcac3887b5ca06b0596bba9c9bb7abdd0f59dd18f0197d65b82bfafd7abdc8172bc1f13dbc178f623efa96069c70a28409319596ac08b72734df6f48fea64510d8409af7b6dd83acadbbb742a689d4c3fbf24831e20566a2d26b9f9508c8b1d2f7d26b92e03295fdf06dcaf30a347c95792b44b2507ae1594685409af66a45163dc9d0edb5bd944d9fd7ecedab0edc7b790d97af8016e4d9ad19f76c92e8cc812a2479b47f8eb645383256167f776881a357516b88007479991f0f53fe863c7d139db301743bcbc53171c22cdd4bfd52d0e8d42f9e5c647a99a42c331be04e5be44bfbeb917bbddc83b12ce2c7b4536668f45e5db1323a2435e9391734a27e6a2d39bfc2ae42650fbb81e4e4d03e790ff45f117304d2c217abcd245bb8a6b8aa3c8acf47b3972c0b5dee87a42f014691c090442db7d760876c840d0e3860b4c5107e0009a05582e52ec8da4247db8e3b2c86f0a64c2d3269ada4b7e5beb5836a62b49d41a0b0615d6f119aade630f2bc629091706abd4c90cd1f905bbb11b55b711d30397cdedbaa14be3b02b52ec310719fffe9f0664c2e12773453ec40849fdce58e021c079a864a327258b0dabd24ba303d5f19b6861462d9c40c0a2894fa4609d48418862f4f54c00d0787169f17000a0591696b4ba652bde0ee365d3160a6b09ac9b8a4d0d85a0f628489f16c3502de19fddeb9a7754e6fceab5e52c450573662b264ce0d6a3d85ed09fa507149671808ae33c4f86cb1a26764ec665d0a487b18e1fc11b98341cea8eb64b8fbfdf5e32dd6a7dc33d536de6e2261d72e9ee926e198a887289381ddc2e6221554f3b9bac32dc5ddafc276ee9a51b6fbb708ee98b90d5f15f21ad46146dd1a3c7dff124bce641fbcbe57a21ba9ec20ec5e8358a04609f207baa620d639e62219792856275a84532e13a5229f7b778fa8c7e761e74bce22087270e017d19d25d7cce3f773eb09e8b225c8ba69c27cde96641b0729b89766eaa5bb374c2e24ad8f1b55d9a6c71771d31d8ba6dd046814e8a60143e5e7e095f4e190e9c4dd44192b07939512deea12ca4d775256350ba74a8a9469efbffcc296d375b59715bd33dadfd812f542fe1f115c46f41e28e97908838a20a92606cf66acbbb2bfadb700c140ae5b7fcbaa4a8ddec01336626b24ca99d188ed434f78dfe5c3daf3eb82442a446aa469e7221fb64f2f0ca6bea4628cd7b1fbc32f3f425eaee26ec5e7712bfb2573c9b1423e6da2372a530d45b91b0622ea8fda5115b103cd4edd394128316ee799bfcb25f3bac88a3658faad6163b3660c5f2773b730c0f6d6ae30477276e2a8e14ee2ec91dde1c8f232b3984c5f87a1e111e586bb811344a172158e6df75d99e188f508d3880e78699a1ec54e5041ca98c207f5dfe8fba5c9f17a42778e761ca0655ad1bbbdf3cee4a49a9126d5494af41f8b45ab570bc2157ad41ae88357bbdb0752c15cb5839bd60a6ee0abca55797711afc7a7fdb755b08c3f028a26d7a8a7e08d08a89f518f34214f1b75c06f6216a3f51557dbdba9a6910a74c6e0e8907071f58366d172e7bd549280975ff564d172029b55c76a4d422b1ed3ff5b6ad7bab710c50fea40eb52760c1ef9e0ab40b53b630548726d0163370db5f131810ecfbd7a57b8eb3e32068e03ffbb0c4f9ce5adf80bf16d2bd225f8cb512ff0e6c0c75daf3138bfd72394ce775f6a3200ecd35b655c091d5365f0e9063de7afae7620384239e98684f2b61eb77f4d6e0a4d0c30869842d9575e8e52751740f906abb6e4a4beec85c8665ac1369d21d7e5b65886b27f230bef90e5358da9f433bf605895994c0c4e339d46763df297e6f8ae906073cc43f77b416599d5746e3c338d45ffb0cc08a1119c972be3dccd98eeed3c2b2fde883ff2c99d1d88967754c268ecdfc99befc01e535799c881b7a5c98b1892aca5d8a65c1970031369ee1d15a97fa575e88a64a33ba9c3b49c3e16ecb665023d8a8a33df46c67de3bf3a2b1b09594678c93f379f7a6c8d3b0f6f1a15b5b72a112cdd75c4d1e718d80ceaeca2af60b712a5efe1fe01d4a23600a68748ad6cb2ca1fe32b9674e6a54966ad85debb7ca360754d95a3c7eac39f1eb73cbfaa7bc974b5810a382ded2811fc8b26700a6d9fef7b04fa0484a3b2bc819aa1f96da2a842f59eb396d50ba8b7997930c2968e1378666d5fa643cccfcd7a256be39d02a2b00d10cedc24ea46f25fab63c3764217ca18b4b1743b48520ae5af94f744a6112455452e9a984285d08ef343777c980a94a50ab8c10dcf3fac87128c270d91935a4954fdedf0888bba7a5e63009f26a9e635c4c93465e26134880b07e886d8e08fbce92f32e780cdbf3c00722ecbff5624197b9ac9b233320918d5ce054ec6f2c119936f94837eba12dbddf946fe3bb108860a5f4f3a955594e8f27f000bd954d4c0ac196c008e525fe03b73ec95f61012e03b3ae45f157d6da2bfffdff19a99fb71a0f1ffd9dde7dc03a70a7a44c18d42d22e442b5614fe72ea3cd995295ed465e3c8cc3339fa8afab7c22d7a81a5b4829db96a0859542bf022cc045c01f09a774386188a32d5bee7b84388806cda1d3e84e650101c22b27b81e81bf95e980d0e1b2d15faedfaa4f2bb8b2219b14b0d758222e7e9d9655273bb1712a5b4bfd99799c894935d6cb52f3dd8be2af0f8ac17515a423fbc4052dbb67ece2740c446411040817761304b4a7837417caf65ff809cc47cd9ab45dac712a34bbfcca0cf406cec7f20470934df67d9e9f7eca348d11ffc249286644588445af05718c9667de2eaa5bdbb3922ee6422d3bc039ea6a74cc5c4a908d7480962c4fc1fcc2d6daf40ff0231818ad524a36e8f0699ed08ceca8bd89b1eaf290318902b68440b94db86edc7c7a6b9a649a53687111d923f353f560354694734923f0b1ad2138ae1f41e3ea6f6d8b730878083aa8eaf0b4153ee14944b2c9476067d8ac3087136c7465d4646752ad48e5eeedd76e70633bd0ae0f203315c0458e100c71fb7bf3558e26f48c1b187778e3b3f50a7ac8410bc08fe17ce225c61126df40a79dc38a22fc4e58c0156fdfa07e356203642351a4a862a41b6f191a682fed01dc3fce38c1c8fde8e13c9c3f6b21f04212de092b2046337757f16810c0fb91fdce8078969a9022cf5ce4bec803ad03c904f8038f8f6a23ee5e170ffabcab6401740eab05a4096e9e3e705d8cba134a1cfb773dceb921be2adf505f68f3ab6d4f64f34b81824cb44065ef595227c2251eccef5a825b3ef04863e2391cb47b3a38faabf35566ed0ce263d1255325d7b2582d2edf8bba95056d1eae4748892e497b43be226e4f59e356788a10b62284ac54c624b388cb9ea8302131da787f44c5182b41932d5d56dc61309ed339f39647e8217052196ed3acb84edd895b1a9d139bb1b6594d630002160f6d5e9fd8e997e42a63b4810f52d4440e6db44ebc0a0df4520bf422a089583d258b1a620dededf9cf533fb6ad8bc8fa3a93871e0c54af01078beb3bec557de7a831a7616187ef88a2811f228805f5a2f2c14d8df5aab37188d8cae8d9525d954b404280389c6e141b5ccf8deed69cd0d024b83b32833efeb01461cd7b1f0a5dd46baa3ea0f283ae032f1351a5ee2eacf34a11b3557e85d03389f36f215830bb058dccee3590576c956955b8529f9e588a852f4f4487a16d7786470dd2d754c9d48d202170af03429589a03be0a527097f0215b3a2e5663c8df48dcd1e54b129536b4ba77ac5ba60d4ad246a428ce2126181bd522371e0f68087341c96b6380624c870645abc5c46aed1a82d32541d8adbc03ea3f52de0a42a6f4b0234eefa711f8abe87acd8f91e9408e58371e0f747e491b94f5db9cb9ce06ebecaf84094e9a463e9d993d308c979508bf6bb54f665d32f4163902053f0ccf169d99a553c6351a3990e0aba880d7f894bd1f812202d7a8e3310521e6cfb5ac8247e5defe51c891751429018177054bf260e6f598ba73ecbaacdfd1b187aa42575be54da53fc1f736078bfc3617f5816a5800322fb5819b49ca1e48d3afe4bc7adfff1bad049613fc739f706f8d317bab25bc0b83fc0d781d3467c4712c057e1a4f10bb13e3946114296f22008fd6565541c81c4cd1102b14f266b32397e1662bed9d05fcf3bf6686f4737ee8aa6408f62407b36fcd278b903ee5ed5526e53a5cae85daef410849a3d34af16e1a668d61fb6f88d80e10a98596ac91e00c9e05604ea0535a48f562f506d25744e73fcf6de95cfdd0e6bbc2163c9004635717c25806abc2fca3f16b77642986bfe2afaa45f344c730c61d1107ea3f439a54810057028b121aa364030a40c4224bea42294c6ba25a4fff4d6253b9b613b6242945a68b3df87d7c930a1c8074b1dd9e2fd09ed98b1e1ac5737aea5364b5aca84fc2a455babfae7f98949cc4d61fbfe4c2a5472c42285406d7450c222475da1ba00b77a7737f7148cfffc47c42244d975ddda7f445081c66ff426737111ad3be72368c597647f7cab0cb0409a32ae08b4322b4bc5fbcfbc6c7e1cd1e81daeb20c24eda97ea978cd962f510db4166e7693fc410523e3108f78c0a82e15dd1fb8cadbc000852d6ce8a4303e5e135b011ad69525fff0718b501cd41b98f1885df1ceac73c02235d53c74516898b17bd0ffc8ea9e0fce088bc811b7a9cf484b447cb14f93174dbbe2dab2a46de97bff28a18edcb5a7fcde726043b7b0bf96bba2cfc4a7f5d45251a6191320b4c3e3713e5ccf289f2c8e19523b1f378fac38f462a5387863e97c690244aa52bc2fdc84ceac377c16abf6de939881d0c2b89764babf7fa6fa9fd72e793d67a30b6f4c71e2324eaf2e8d32ff81a249c482da4b2ba8ab174236540068d2cc2b16578e269e9edf69a874b7718663b936c9ac833f43973684204d8b764ca5a5ad7fb3865563a0ab8a95e240e2e78bffefa5e650360de9034831475cbfca3be1d12dd579bf8b7f5b61a119dee5a21d73d875a75b39068414cecfd59e797221af09ec7a4f9d84e4b0781fed7a2dc7be0b066d88871981c8ea140f47641518081d0dd769998b76f51f51ecdf165a237773a8ddd44d51da24e0d88d90fb2b1ad057c681fbac0d16bd785a651ea78afc8405eb02527b9984f3f8f9d8157cdd8aa2e2e82e2377616065846c2616d172c16362df3784ee787034442b6214b8819038ec0276a7d5f2ad5827749db30ae84807e3464d29a0816ffca3eca7e91ce7b195eadd8e0c5313b67923bd6a80efd543a7e2ce47221e8c32b9ef62c0e0cddd80170acdcb56d0bf56755dcee711b0760e16932f694fd65980ffa95fdc0d802e8092557e9e46ab353447ef272e58e264aa35a41d62fea6153e7ecbbc3da14b9a747dede73714f689034cf7df4319244866efe97ee24456da6fee7e9f7239659636669833d7d0fd5fab88e097e514dbd254fccf8455919acc1e2199cff69906cfb5a8769c00ccb445738dd0fadd19eb52ca7ea487d302b3ada276a4f29a7571ee7a2428d28c50ec17fb9b5e85b074d42bf0810af5327614177fb3d88de2d16f0d5b52bfff022fa5a0160260fd62d2b5e0a923b1d137fb5cbe6fd3b45d8f4e6aa7b5c1f7a549146b578580e1156b5d18563b9f242a31319ca4cad3e601dde23fe2ea41e87b3db78dd1239fc91eb9e223143b5128e98f77f1e535ed5ca4c6ce26c4d5e3eb7a3b72160f989284937f24ac53ab05b54f9e43070f5fdee8e04d7a0a92f33824bdfbf14beae06ee6f5ef4c7a1b8d1a148f0778606e3bfea799506b39fe04d371fea58599d8557aa09482c2f351d7454f087f33c193d902088ef4f3c4ac4e48615a72d2563063ad0ec03b8d6a9282024b618781ecd87818334591a04d55ff62082356b1006abb3e6e0093075ed8b85adf981e3c2e4af6fb0f4e8c67a190f52cdf327d36295fc85164711905ed13ee480315a58d38148130ad951e337e36c97b409fe2be5b3a083f158f2bb0a994ed2a6e8753bf466cb44596d42dd339370aa2cfc869ba3bbc6258b40238da7ca66c4eb34b4f80ca9653c8f1bbbbbcffe792bc1448d3d5870d6e524adde280c3c8e965e5d09ee8fa08f715c1047655ecc61f5444bda6311cd61988fcaf1e86922f17f88f18b9acdec62bfb13ba60324c6d6fe6cd71a9a075306a9e6f7a5668c3e658471f24af65e5d0afb3c64d4a93830b49743798fecd69e6a9ab8a1855864c000ac6034716304061046e37df9d8c04de3797dc572f2ac527c8051750cb21359d0346458523b556d28045bcc69a2b7d951eb09034a7076088b30e9af500d30bc45c875d8a540fca416f36b7a6ab085fdb7c986c2dbc1d405ced73f4c51fc4a3b88cdc2d58fdfef43eb716b5b205ca6c27c5fb6f24c29c18362f89ee85c0f76b1926b56b7c260937c158d04306e0eaab28d4d6070e96e5b7421fd077c17f15994aaa58eba1cb0e4819d60b9416a1a3c7075e397454137baf17fcb61364013a4d9c008fa15b521342ebe0696c517ca356b8c6d343b5d90e5807207380611bf1bb7b0eb9075388af7df14bdc7709f25b875b21fefe68f93c6830eb58c936269250d8ee2cf7ad86af230e157601dfc8d372c8052f4918a17598d1aacacc4b574378ae873f0ac7d8a289bcae44e34366284193e7f3b7aca4645953dbcfc1dbc403969efd615488067cd8c8578bbadc819a740a543011e758e0ac07d338a0d58da5ca28c28796af0c33aeacb432660e05e2c29aea083c0ce515db0c00dc7c08ab28e31ac67c5af87630b1728574082e4c66414f4fef86096d32c1518a8bd103cf3c07ef50dd9b128fff2d6a63e85481d08ea30a54d3dd58dc5f7e25d4eae0e4e176a5d6966b09ecb8f71042e2a76059aa121fd39c45861fd2aa008750abf76207a10dac8f41ad45d1f0463e9f43e04d5c91e79d198096e96c789a93dda6b0f2c6c4b6b7b912db58a7acc6418fdc7f9f3a9266cdd349d9a5cb83af5521c20c8bfaed9825824f8eddecb29ccef22dacad17a133f47ad43135616dcf0775a9ee2a4bc4b574d03fcccbe030713c0b308c97d255b6171503fba34204b3e2028aa19b041ca77ac933432a4d261f79c715ab16eacfca2d3f59b9bdd91fd7e164d8ccce0319a20727ff05fe6fcde23b03e8d45128bd4f317355ae5806f020967b27532ad26c90d962163e2b4c5f2ca28ba9e04601fc609d85530aee965864e0d85f9e16b78443afebfdea0fef8503a67ef16ae5aced8d9af536fbaa94ffa4e9f497c7843f4962961642031221d5b4ad502809a3d44dbc7e3f636e0c0eb0690307d4777c225263b70334a127bad53ba937f9cf667a0ff7dfc2672efe3c4c97dbdd571d47055bc69453b09e05a75a9525a90c534dd10747f2d175a63d117777188682b3a5ead97373aefe9cb10dfcd9dae529a915c2fa34ddc9a4371af93c950eacab87809042227c949db8fee54e341194213e326b30f1416b31bcceea6ab4bd5c9e611215bb2e2ad26c8b8b9654163091981715544234ce7210b9562ddf75e61be24e58baa381b40eb29cd1235f0bdf70ba9d0c24ca94fbc958bbef051d1eee98d3e3148f014b34a8d8084a2fefcc442ec2a345da7e2afb3a33b1667e8806b869c95cf759a29456765e8e3bd90376c1da865325381927b6bd0f0c6a8fdb9cee671c6ef0b67c2cd2c52febe2b184dc6af505a8de5df158d529d5d94f2630adb2e51754dfc2ef71ec8f31308361ed4682f11cb28819752a677699a12862b0118bda264c9a91a550dd2c868ba12962d2005d01c7e2d38e24af54ab611a5b5001413ecfd5a38e04834a5d329158aaca469cffe19c270778e1c24b7ea48645dc3999fe6dcef4a0159a412b06c9026bc45970a8886634656b8c674e29727612d9dae03d4ada894e287fe25fbc1dc292c8831b82dc96fb8ca18ab5528824464042403bc7f80f6fb62a1b08b4158386de1737120fa41070d49c8be9bdebfdb246a240eaff0f6a3f048671af12528b494a1f04230618db2f17995b00dbcfb7d0c9c8cd31ef52f12018722c4d0ef395f83a2495b1aeca7c696c96a0e284948f33f8c2efc54b0d04dcc12179a477724e0d25c3ac12c0aa4e128dd375096471bd80a6003ae8c7abb2e30f33d4c5eb373807ea625054bfcf91200e926076544b4d3ccbe2095ab18e00a8404c6bc36b4e0520a45af0d3263b2f72bb2edb5dd1be88002e267aefad44737d0943fd25b3b1e041dfea61e23a942a5505560f85338bb922df3b47f0e0720adf8ccedc95c358188d090329d0d430286ed7a9aa412a93eb213b29074f1eb30cdd794","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
