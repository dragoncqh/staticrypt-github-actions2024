<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e0336f6f48c98af470104e77ae0377828a9919c0d7d722935fc89282515d4dde35992b831d00d9e7ebfd1508372219eab70f4caf506ad96534783534630083d5191d98fa90f95d83b49b800aaff6b657f1b7b10620bed1a3c2edd09dcf8391d07e1745a230487604a9e890707ab39e3538e66bf9856a7e163a02cfed5bf2becfdfcd9dafa8863c530d30a587430a5ee2d48b8da5501cd5dd58b60ed7ac6f6587d7edada8151785dea7a39e2a12d0078b12033ca20e9a58823c7eece713b8c101c9f0379b081abc370d4b833eefe39cd11c7e0c3e17aab13cb361143440eea71b0d906305d22bc2d281ea713f8579b1951477480b1fcb43a7d8713a5fdc5e8fce90579f1a1d4ce51297aace87425d876a5cd0ea2cd9d80f250d5714e6ad111d641d8289ddec528cfbbbd851c1ce015f941b4515e60f5999d3b07f2dfaaf6e514fdca67009d540875665f9c6825de1eceff5a270ef568fc63972fbcfa584e919a85640f51b15b63297d0d65b02ed4fe53e378ce3650000ea3adfdb0e37c5b8689237c7eef7db230a21d039ce3381add599ddbe2261e12ea840ddde65156d517f0b802ac3a0fe6b7fc1865305e4a022002a62d51e0e0ae4caa1db377c7f1aeab01ce476d37e57385a5444ade31a36db139738a39ea3abdc1ab04ccdf182e0dd12c54c72b9a0a2d346912a093ab3b0e3a10b376c72b178df9ec0b8440652788de6e5d42f559ebbca4fde27e5616a906f9bb10df14298ecebffcf5ad6850858677bff998b236b5954c422fb35a75c86a38f4a2c6d85b1ed726b3d9ceecfcf0275928725d4583ab447dc2541ed895cc41c30bf03e2bddfdbbd157c32b70dd804e1f4ca2f0045453d6b3bf8683983e291148b8d13e5c0276fd5f15a810a1424d4fbb0648bb3dea808990e2a7702fac070de4debd65886ec6e2872f15f2c15158bd66148b14b3e293df642ed71f21a0c6861fcd377705e0a8bf4973a4bd24ad36bcd3e6c9613eb42064bf144acc8fcfd03b26f16a71e4e9ab11b056236146774272e29733c0ca36a0186bfca4efa1b155eb68f479e0401d2b98f665796e2f60f5ab2f9c16792a2ef8d17f58e090a3a72dd540cb966f50dfd3b1efb6b33aaf541d3b4e4585ef4692d72d764779fceeeb44dff3d3cf1928b0468d3c92ae8e66f5ad1440d7f0c48cd07df3716ff5a3a6436d19c3f6c688f7eafdead87995ca0ac845f3e47853a7cd8a5d514f413c68510f2d6c38b19a943a14429f8e4c1d6f5042a8676a383cde80dccf047604157b20f8f794ab1a4ae06f4aeda18c473b1bcb2d952e3ae9322d904981b6b015237eeda375fe43594fa782bc4adc2906adf8faa28b7c3a8d3d99942267a8fec4a1461d07470ef6c64c61ac888071992fb22e87a954bf005ca0e385ca3fb6e5d7e1d1a3f944b41a0dd2e5e941ce51f6eb0630a2972b0b7c3e89d2c490b5cb16d03b326a5bb5c0708a9304de4857a869b4969f2c65837ca2200933f16f3da56e5fa1d72205b01ea5bfbcd441534ca743863063a79ba1721c9bc2aafee3befe44a42f7a415cba229b98d6d82f854a79cb829d889942f76f3cdb00d00bc736a7ffb037ba5d84792af478441fd5094ba3bb3507783c60ebb50eb9dd3165288e5896544a24b95a29851e6787b04b8ad2fb9700375fe2f9cfec0b2b3472a8f808845e4a9263c3239ca419471169461b26913dce9a6206cefe52a02307e7cb3c22b4cf8237fcf2739e3983258a4ba4975f3ac5c367aa4111da92e7e924da9ea41765a0c98df7808d3bfba970bee286c2af9e268e61c2fffbde8471f38f9843a0f9a1e7d02bd2c35daaf482c461f70dec7b0ee01a88e2c3ed302d81066ea89f7f88d9bae3054498e8e85cb5d50a800f2eaa97e36b8a00d82639cc2cbfe3260cc1ce35660e5408be625fc2ee667756f03319f7f36442d4e37234735c40297535636facb23e8b6f9b631cedca4f9f0eb36efb926300f500933deb475ebd69cdadd4ebd299bc399e6ffb9ab3be45968b076995044e8510739fa4e5dc67862a53e32c5f0b7c10c4f6d6c1108b6b1115159076ea128ecefca59fd7c1482d70238ada106af9983f907c89b1a2a8430b779890778ea807b9cab5d7ee202bf46d8d28dce6ee601e4b2f62581062acca1526d97c43435c93551fbafe0be9a0956f81918fc99ef3e18a46c6ade19f133dd924896408079b78ef68ffc40d72eb4e6ad0dc965350100c5f47c8c0cb671cf5126287ec8b04e49569bd3cf75d66491dadf1c8125e8524422be74964fc569650fca004101864123b99b6ba45bd03cf8733e369050adf090b1571ed099f85ce14bd123f4f0450872e05d356bb9f01d2c5b22216bd1f220b2bcd93d4c12cf9e75473e08a39a8240162ebc73d32d7e2b33c612398ef7648d178a8759ec0531e0b548d6211c27db9a864124bd6b7fb1c4281a56a699baa6a8a9c75aadfa189b3134a2439d69eed71cb23e13f28c132964fd764b81a7a993c268a2fe1a89d76c53276b0b18b0f4a8dbb94864127aaf3817f7de2bd0c71994e51b36fe4967dcd93e99e365eee83764963b88966ed7c687a9e9d7b9c875cf01d57113a96dbaa8de7e26d210618ceb07fa5b6255d02a1eda4685b6627ebc95f092c83826e99db6fb3107505fbf61dcff38c8543f534d98b3185337da85665c14723c8031bbf0e7237396a193ca21eef928197b4a127f4596753a6e93b2e6328346489882741816040deb9e4f573d90757d9be525006b3aeb422c7e14b9c1d3705f2d002aaf69b39ca75db00fd0b5612ed2c54fabc51aaded38cdd3e20c9b9aa5efdf0bbc5dbe7e32ad9039e01eedaff55e691d7abb87912617ffc79e744e9c52dba23c5cc9a0221a3c9f0422aab2878bb8dbabf52d6a0b1e030d18109c6a4e3f7513ae10c3a7e6e1c74985e8982b1b6d636c3c1d4a19d8ec195e9a44692e55f451160428d249172fe0ca22a03a295d4c7aaa2503022495998e4f5b7099e70436874461fe72d927fb61b7b3a5081154540cbbef5a89ad48fe2f494a1ab587d11f7f6d6187afc0fe12ba74b4bec0b72586c88c8fc60ec948cfd5e73d50bac195baf26e551c4b65078b450a38bd8b4f7f304cc645fbc2501ed310f9e3324d3bf7e429e0abf806f9bd42bab59f1546393409ef1f4e8a445f6f5e38ece0ca932ead70401db9073a39189748af5e3b8fbb8f395cc9f9bfc482ca9199208d3628e1be6f30582fe68ab1a5f35cb9bc1cce8048edecdad608c1d79bfe8515b135dca02c262958979e2aa2362cdec25c67e1ecae38022946ad29c3a0230d8fd1af9848f9822f1971d324af8de39cda38b2c8aa95b43128cb92521d620404cb2a4aff1f5aea1b5fbe34f4772261123670a468502abcddb29ef0a71936a9b3e3b61bf164de0159fa5f8b6c07b2978467636d85cc11a43bd52772a45dfaf0b285f513b77371dca9c7e7938dd2d5b847b994f97ab1a85e4ab4501991717bd94a8bde689b6cd69fe1f17042f5249b5b04b4876ea4e77dd6cef7ab451443d206d0179d90e3d7964cbec45fa6c87a0e40b8ae1486b259268e81d609c742bfd5a7c0e6c0f8bc85df14a0458e7fd0903b4690f3d8d111c705adbc9fa5b6848e80753952c517cf817f29ccb4559435dc5d6dcc7b0f5736c317758ae7517921b2e676d024618baa11f28b90e500ecb51048146c581e743d88faa91ec1090b367910e628692b06b664c4415947a033f1779cbe1844e8c0e965229005e80566732da035ecc5d8fe6d0d55f30ee82e6e84d21581cfc14769d298ba00df53ba33d5ea37e0913414776d04ed8b88a9c998e7c8a4b6b787e4d899f13553abb487a3a88c210aa9e0fa00ba527eb6b94f327517023e3166f8ed0e7ff09a58f17eabc70cf45f839445342759d80249c7d27ca79b64e2639c59f985d8493612be1c633c3c3a283a354be035c1db2de69f60cd4871671bd59026ef7aec5b51d22052dbc53af70815f9f8810b32f3c8e6109486aa50a2c412ab35a8ee383480dd5be0e2cf892501efc412edbe443c834f906a69132f5326c89092810ff2e5eeece53d3f2c386e08020a8a64c445371d7b3160d9c61bf0a8bb5ad0b591d65586c85605504b647286f82907089242c273a0cd33521ab0a42a042002e95c5351705631284582c744cde45076d82ba31b9fa1de7d450b6d4e59e1ae81492720047f1c964fc19e96f0ac753a8147a10940ca2f63ad50980e7fc7ffc982d5746973cd0917f998f6992e31f2d6068fc26ddedceee3b7ec0a350f938893d2ebab189dc9be007a9c85b421f718061ac95ffe3389a5fc1e0111014e450d075a2755094fe3e769401cf49003f2d71a64130486fdbe4437528c83c45e80105ff69e94eb614796e58cfa6359753d1f0fc8e431476463502523f43665317b814f05ced0622be949f4b20fe3ca4e651bebd8c6a32962023bef1d2070002e2c867c60a19d35af9dfcca47dd773339539cd46c6537680b5c628fb42b907d7bb3ba8053390becdf95c5e9f6c087b8497b62cfcf838ece302cf7d32701a189c1f013f7fcd8b8cc3559577302067dd7a53ff23404c7bc94fe18481ca346754a941f2cf52d8ab0b12c56e673eb0fea897e1cd90d9ab4c5bfc1d1cd57fd44896578ed8fb8ac87c36eb0ff0eb9ddeef8ad23e6d7ddcc1969351a31718621919b7871ff77d12eeda5d95880f9d1c7a5637189699a4456c7543c7a0ff164dfd1f9167f0429c20d0f7197d94e711df929780034311bcd3d8bc5bc5bd37e9625e7fb4455f6f046c5f033827d2794a7fac7df4ebb791687357abbe3a05e4d7c8617b026295909cebff08e82c123832ce76d4c90c08b299dad5e1534a4b84306da88ed6bc97e6e3444ab0892b75090b258ced7706913f1e39ee208ff124549f6db9a1797751d278a464d95f69e33cad704bcc888f279c009662742ad65d9e7862512d10733202088211225d73e7beb1fc4c8de324102daa8b0f5f5f8be7bbf1b2f18176abeb177ad00f5368e106cc1f70ace92c2e685717e1b4a560b89858f7352e8bc7266c681b228e0b1b4ea815b26d53677cb09bc77829f1516f73945bba4433340fc70eebc6969f185ad2f79e8185a2c0b2e1f822d40f79865d75ce5e78dcda3996b6192bd74b777830b2978ce01b73c7f5fd1ed583212ead984f2be8a15a370fb78b83b567250401283c93543170ed3d1e8a86dbe31103cce513c989b0648e1470cc83f884987fe89d513e1b1617c48c394d72410738c71afd25fe3863fe2a3940e5b4fb0140548dd4b66e9ff206c15b81010eacd0735ee6614aaefca50c051b1ba41993e27cf46b4d22c0fd85e60c15e840642d1103c1f28952f9d18138a218151fd88a6a1fb41d218feb442a2836d7faa372d797dd156612120dd0412c755e230a9b338ef150b47b1e8d717a1d374d27ef137838cd701645fe9f76901fb5555b96dba73ff1849e79229998c92d0c04c4e467480629407e3d6279a2661ef9ec9c6a3d460368096639e98a95e7f8b8de9be9921e654a5ffcddc5a43c178471b445987f90bde22abd5d5a6ba604e3f366d191742bcc7a95192ba33b22bf082610ef7d83529ecc1eaf895bf96b6d839c7bec485c50d9e2bd49fbc23ce033b227d4278f2ca2d8538b65d48ca3fdfaf874423b93f789461232f8763312e26f1f7b3d6208a7669ae3a7b5dd9fb1db67f8cdfa9f60d4712d67bd63cf75cd7a59e5298d7d0bd0ba9fe528d12a815701bdad393e8f3e1605a3c2622f6aad44b9d635c61544680612105b73fa6df7b5b20961a39f47cbad670babed7ad6c2dd4b2ab81525c4181512be9a34879229ba10f77b41899e04f6551ee52d5ee46db742a78d99a086a6a2399d6e810929fb90b5f474489c3af459ea13645b44669e40c2d9ef3a21701d2add188b8f8253b81652796419e23acb7dbae3e14343cd36e3b1784c39b37694005780208933fb1b787565f2a88ad38659572b866159355dc88ecda11ad377e6606451b2268140bb4a8b51289f88b85e7f60227b296e05318ce18665827bbe814f7642016791377dfda23325bb5ce658bf0b3493c0d62434127f69139315e902f2d3692a5ca1b35feaedbbaa17127ee3f8c5150de9178238b89ebdbcb4421864de0a3ceafa20ed9fcaea5d62d509a233fb475afc347e7b33da9b8bfc2167ce7bb61ac550ffc4cc9072743b3cddd1eb51b1eff1d5f73f178ea8a96945f625c10831f844a3d60694d4865f9d77e571c2fad3b512e8942fc6d112033861393aeb1002966823e4cd61f0ed73d1058ef6ab195d41785c9c65899ceec7b150d60bf4dd5422476e2fb2e2050aee0bc34a34dd1229c0d78947eeff924bc5e1895804f0b723ee8c6999d045dbe228c24f69bf41c9539884ae063804db8ca99aba8fc6147d84438c2c7d10973112b855979137e0084fb99aadba2756852842c0e403b62570f721e21586dadc1339171e7ee6001d68341893a187aacd85e9282c7ea9f1a69f54774583da91b773f36d0a8820dad018e4dc53f4c191c9b888facd21ff62ded3f588739a936e6861edad526ce05c7772aa40a9a7f9ab4c6fd70b3d91c525fc96d6fc07601a77086ca23ef02e7b322c90c23277939dbed5754d15b79a994175ef60ecb8529198f69a5e0bbc04113fff799eb57c196f6bf98e30416961559520f9c0d46daa3a142f13625edc9fb1b2f5373cbcc2c2d6f6fdeb6ea0e6e24c9e283c6b5066aecd156c2411dc51ab92c668886b9f559c0caef101751afd817cc8d65b5dd25fa7bf81011c1fcd77d04b4debb6de47b0ca78d73a090faf5aecf0fd0ba25c8be9a3890d06e80753c02502949b654941d5eb143f56d4abb521bd013d5e371fb1e4ce9975e4c49e5ab1a2e937b5a6e7c832fa5c9f14138711ecd3b7e7708fb777684291f283442b8e8d707834f1f32f685a76b8dfcfdfb81fd094a24e870a9e5473c640aba6899743e333d85f17e0fb9e8f8256f2379fbbd3f79c92351b5349c11181c971cb9aa06759521aa48b079e0adb6c3c0e675d5151d8db5cd79e5ce870434f6f8ff2daf647c0cf24bcc5229f9cfffe45bcb613d5827725e4fbaa3acdf217b0014661a83cd5f912b636fb7df438decc1fccb0809c7dcf01a80dbd5946ade559192c5d2166819ea72b4798fb100a4174b6ce99f22aeca9ca736dd4672f7daeec7dbcfde582c2eeacdd7cfd722ed1728e4855b20485ffca82d89a6e1da1aeffd4b8bc53708da41c22a977ef81b072daa2ecdfa4b4b36fc9a2fe8cd4605a7b98d30a7776971504ed4723f2a7d8b1f6fa1290d46a8b6c758c888d25609bc8a7c8c911a6599f772c63d41e36cb1cddebe06df376d97af5ee57e416aff15bb21f13a0ebf015436295298f91d3b7911be1437f67d1a4f154230388974091572fb62dc6eb72be727c4bcf45a89105d4d5401d7549da7c857e840afe41c046e277a83e86200c6cd1da896217f2897d958fa82228915792740075409844280cd6e83862c45be4401d8876b4a08a7398383483912560d4f5ef14df6000c65a2508c0296650da24a81fc48e6fdd9e071b7294d1183a9604a78dbf5b0a64a0f8c6d5a16302df7c3b4b6d067f73c260c9c9a56fdca33de1d8cb8695088feb434359644ea439deb5dca8f96fec2ac882b3fefde270bf9c79e25bbfe612315e40e839ad0471f0735cc205892216d5efe4eec75eff219bfa5b4fbe5b097e456fc8c7149a7b40f280e85638576dd01524d110eec39b30d24168da37ac899da92b57f575aec57373f6df426b093f28df235bf9b126fc08cd33baba4aac31d82120f50664cc51854b7ae2540dc2f789efb01e12f21b97aca09716a6212d2fd7f001cfc9acc5e367d2e5408a6b443cf799c5cc92ddc05aa297cee8a236d22696978e04e0470b2de6d1247fe017207563408cdd3696363252422f6812915d74ce0388102f0083ece50e3c1f5d9ccf8ce9c7471eaafbeb62e5f37f2b2244948bc0a04065ad8bda2e7c42f3948c9f510b5e183c09d1d8bf484ac21884a59f247b574d4d39f1f0a07e7b6002d62f0a7f4fcc0a43dfc20fccbc7dc385d37531d6a30cbcc1ac6689b03ce8859fe6993103115a6b9d3fcfbfd5708a875382bfc20261d039f29305e3cbf4a17b8137880cbc374972906c33ed897839c45aaee730b10c554a2523d355dfde014d43aaee9ce2aad7831e3c3791c8273c37a2702613c31167172e351d53e4ba7b65757694da69c50283ea298010b89185a2807068252a3f50ded75c347df77a3774cae18990dd1d74b15ac1bdbc67e09618b30902f82c1a7b62dc498ba9f4cec8ef47233dc861447e0d1d3d8f92d3768146a7b1833e9ffc9fca217cf2be93b1b90046135c50baa8f2b9a677a2016a4dd3d58f7542861923f480b999331d4c6558955900bfd831154474511faccf4fc7af8df7207bec371293c5d2105100073fa9c100dffd1c81bc572389340b407b2306f03d5c62aac5df0acc2755c5ae67271c6fb652ca907f323591533fd93fa52855657548c9cbde6b04531038731358f649616ef96b73a11370ebf861f7490f60c7d590e6c13c4338156c4a2ca0d234de9db3a6be2ad38e611bccba931bc773340ede991518a7f0135e8ed92c19af4f89daa3290f86ce56634525dfd270dd029be1b736ad2222f0a0795da62cd08c0cb9f247bc262daa48ee2932f7539d3147bf10961620a43cd697fa42987d0ce96012a787fef4301add085df42ab67a3d28df9487fcf4df3251519610e47f7007a0b6281801b5aa19bbc3ee974077e176cdc08ab2a1c178c9027ae5453991f6b9915ddfc272ca4a04c38bc2a05aefa89b375f97b8382a60f994f7a090278ce5230bcbc4cb22127380733e2c3f55ffdfad3c4614a221e219cd5fdace54ad5c243a1f651e83a09b31de74118ac0b2f372c77eaf05838d29544d26a30812f02bfb550bd5940b2e3d15f521d402be53d424675e8d0fb5977fd44655e6d4dd6c2c723859e6e18fe635663e6b0dc9c2ade75abf0af58afd7367aadbe539c01a7e8a4efb0a27235383c335feb8b6a6b9620e98e536169944b070e14c1914001fc19cc153df57b0c5359c3a537be872d90d45e2d319bb5995ac8de7d3bdac3d5e83908a14ea555e0b08037db6a5a2260e1914b8ba4fc9f1c3f78223181d2c0b0963d398adf909c9bdb885e344679776b12ec9681ffdfff3410d5b253c388ecf2395603d8fe8817e5641ec720a481b3c7256b64e81ca62923940524c846f8ee8a22d310c96969325ed900e6bcff89c1e8c7088ffa0e7ee45eee80aaf135a75ae7d146f76c5e086192fac079d8c1e9fa8e3e9299466c07a676f56baeb930bdff1a5b734b95464d57971a5e1d1cff31ba121d327d16468c4c3edfa58811cb7c7391f0d7e58f6a514db5ca903c24d6a8616fd68a85a818da79058ad3b0a16824ad2184aa93800b4b3adae3b872594a27adcbf574513fcbcaa7902b4dc969d287afef53a37bea12a45934e7a655aa90b3e79c89f24ecd57c9c8f462e8f0e3ad34f16e3eb0a5d5b5e9e27a06dba8e741052689236ffcc58a493fb9dcc451780a289f3b092a533f6854079674a72ecb15b517f13422415f5ed9b95ebcb5a2d037fea7eab873272d21475b3abf4d3697687c705c005ed74c4c8b103eb6d55f91261afdb6e7bd985edd5c582e35b8a8acc246fe9a59f41502fd382198a52c23ac2860fac9c6dfe735ebb938a7ac27b663053a0c0d9ce13a825b6acdeb76c05b352f425aa9ec7b35ae47c9f11b2ed1a0441de64e83d2274cb1409aced9c995aba045bb6e9d7a2fc6ba330a3ed27ee78162784531e8dbc48cfe8934af5352d0e7a0cafd78f2347f3591c6b019b95a8a242956cc282d1eb822c05475c6b7590d7b7046a3e3de4e87e0f0fb4551ddcc5bff5814f92507ca43b76d3b22823804fecf33eaa91c8a34b3ac1473bf9a983c5b4ecd1e254514ab432e13fd88c7d1b1fba6c4d966aefc1193fccacea089ad066d75f7a167815e5adb1a148d7bd1dd1b2fac49c01a51c45a3c45f0f20d2511286fa35d8a98e3714f90c23acbef11a14bac4db630c456f8bf2a2e3da0fbd3361636eeb034cf98ccc5a6659bb02bbd01f427af63a31749369ad75830935c4140d75def387658b6fea6ef3f73a24bf97865c7cce87aa23fb15e5743d615c46140d16fe37a132f753b6fccffe9b3b31646f72f1dfdeef82d28acb0ea827cad161168aa398d6e87ca5150b5b230cbb2c5a39750060949c555788f748399140d3da75b5febea5cfabfd70ec366c0425bda6f2a0521b7cf37c39abc2ccbccd53c972079a3b26d377099e931f911c9d13d12ce67f98f4fdb1546d77b264423054324c3e20b5146599b562c123a33e7ebe96d7b6c2638d8a001f9a0b7c18afc19b2c76260a62733fcbb3835c6965d9c00c93d927ff249746bef1ef148b8fcca45d794a398a9151baa4c6c5b0296f01e50d7630fbf30aadbc4a88e778eec2e1c5518d9face6b8847fce748d28a4db108e7c221b08c3a744f70974834ae12a634c5bf3ed78168f28eb30aa4da18b1383953307e0951bc7a0fe794b229915010ebdf8c416a3a3874758624f6b116b494bae2b729c5905144508bd3caddf3d532ff08f1c52e829be0d681302202c2819da016a07670a85d1471df75fe702035dec500e7075276b230b39014e69ad16f8a2a46f869f80eef765d607aa1bbb91a54fed3611449d3b565c21b29d1c40ea54eb8380b2398b7d4dcc726321888deff08350e8641f3b291aa1443c44900029869d5187d3f9f16971a7b5b294f88a1ea87e0a1763f127ddc897a6ca2dcb0ffa38a4a0e0b997257ee1866861aa0dfad9a7aa7923f23cd9feb7341f5b4129fb982fdc77c9ef091f1dc63be215bcf0d76d1c7a8b7aa861854c60cba259b789868e3ba518a13c6404f628cae4dda9155fc6fea43d82cfc31b480335df55e2114e4717452eff45c898d6b55df7601ed34e5abcc66b3b640db5b342873b315272619487cf794505742507a472b0dfddde7911278cfbeef2d12eeecbce737a752a03a67d9adede9dc7b758e5073088d55ac6e03586c3ea7e25e06bcf781d784868434aff4beb48346e960c09fa41be48a077e12f0301735ffa23e107e8a6479bc273ad701c7df93c46ba7618321772231b564356c3cb2e1198b130437a73b3e21b2349c919b3df7c54bd8ffd08e67fbb4950af00038ae0074e66cc259fd597f935cc5915a40908251413572a7a4bf83139e3477973fe1839cc8f2165cd2e5204d534dc63a347a1e3d02d568e21ae626ec156da320c8fb15742d67c1f5fd8a5f61882b453a30bb119cb34cd59ca66145dd52dae63117ccbd6f9b5f13a094093475478174fcd38f8b705f04d89214049ab6779d17d9667912d501b57338484f555eec4c1a36dd92548b26165bb08365a89a5f14e44431bf5c09bc45bd0ffb504709bef7817ecb5d70d09a27078d79c39f86bea8b505e096817b2f9c9aacf0ae8e982f496689433d3b34e6f79d0d6810c4e35dd97b40f1aebc673e16917d1faa596ffc2e67605c32b24dc6efc3ef1c68a79dbd70a6f4792ea8d5ff158ad921c2115d8c384c3fa38cde381825714b2c0d007a9547209e7cfb0abdfef50f86f7017c92d8af11e551b49e6f12e8c306446ec18e138313a2cb084f46be3a044e2244106b01d6944b9dd963beb8e52be771e6f642b6ce50fe6ec27bb7238fdefaf41358a7e83afb3dcd8a4e6084557b9a84ca146972f2cd1a428dda4d4fecb313e993aeb9f160a52bd74ce066403860777614e4774e10c2a836bbd75f77b1e22f32220a21d476af530db657990b9b8fcb8d99beffa4cfbf916ed35098e7784cb7ffd016669638ac93c6ac1f4b535c044f9e5771051db1bc92e8a802c83546be763c84a7bdea7828335bfaab42f0259df6323b061d478523adf20c6d846e9777ad7d27cf211b8a2baa6886257641efbfdbbc1585a9d9528b325981967465108bb8583e26d65c0d09fa84e2026880fbc7d7a7e9899db056be92afe3740dea5b69627fef21a59070c96984db7ae1c2f04df9f65df0bd808835c6d748c278bba4fbf771ba7c768cac5c776c96cf8f88d8a5392ff1f0fa020eb4d213214007864140bf0940152fa03098b97705bd3126c340911f890ca45d7eeb7fdf40c1313fe7e785027d6468d2992d965be10aef2c4df45790da497fb0777709d7ba5adabbb1df3b839002775c540f9edec002a227a9e62d764fbc86ed498be2906bea428ee16166d7d4c6936df2302985f008e37b765888fb0241cce5614194400a92d5243bc14588f1172b0d2efb764dd57c91588fea975bb77124d387e4426695d900497b93d5486752e78efab8eb598b5f80321d91cc316728aa0b6a2951c67c905e1bd838232b2fd2ad197d2c7d3f59fa711c5e3ec15c266b0d6d2d2adbb29a60cd1c878d1389153e4d8eaa048ec7a51c9a34dd7051eb56babc4f28571a022cd4977866d316b1b87f51def0e2211b520298c5046f056679b9b8b1385252e24359dcdb94bcbf2266825556d4fee6ecb7ecd933d40d068cc594af2ceccd0e042643659ebd3678d710ba68ba12cb574e08f238c8bf3d5303e31826d44ffefb2f12450c899ce799ef56460a4f99580dece2e1523557ea38c0d8d37589e91b9e279ad2cf0085afe933596f03c8a3a3c4d9d9db6c5244f1451894c04def483ce2c6dea3cde935c6f9c3183f7a8a1fe7c3208a382ce619175b278e682a468faa8792c674e906eeb513ffeb150e628c6758d7e45d0a3eba8219c47e29a2f1d3114ffbda57f7348c0a616d51dc03dc82bf4e82478a9b07ceeb649911df1a4dec2289b786ce8dc8fb3583c770fefc5eb55ab50bfa6f6047de0446a59b069a936821dfa8d7018926b37aeea1588ab78116e0505a4e50c773a15aa5c5fda2a1d8de83a80a22c5b8c2b4079397d9779cab81651da8c0f4b75aed06795a973bdbc3e5543140bbd255904d572370c90e80fb397e660655ef7f8a0b94d3bc32bc0f22f1e1a210549343b5ac28c961f6a77ebe6af1ef4fdf72765ff2bd694b96e1a6c3ab479cf36ba43a75411cd70a5bf67d35858b142317fd34ac4f70e85c1bc86a24d8ac2370de69d926ff68bdc42391d69cae77fc8aace1b041c5f4c090df74f6065472c8e7ddab0121674459c7987cb940a4734a0a442a618a8bc7bd2161a9f2e430fa9f91626857babb74ecbc230a226c740317794ab793f010a85ec7ee6c8ea2ac25ba6a9b17935f85d60638dbe11dfd191ef83042567d32d25f7c5bb3e63f9ec67575f35082442f5c9cf91512ea27095468fc6dfb896be648df1582a2dfc3d02d3c55d008b325430e8d1712285841593815b15ba63d18c9a4e33ee1836c4a9e97f31d0277aac85d472ad1ca589b342d44f9f7adb64f0d99dc839030dbf7049bd6ebc799aa5fa133c4607caf70462b2729b733e70b8bdb9e19017d8955501b32cb01e80739fa3695bb5cc905354747f9d02542250f051061f88054abcfe0cee985427df83dd087e464fd742f7621f14a34678acf0b6f51dc83e6dbedc2465e1f622c490c03967a5cd134a369af1e4cfe5933c688616987f0dcfcf24abdfed2c86341e7c7aec306ede20103d9a73c7a0ba32617652f1e8df1ffcac2c8812eb7d9848d95fb50a54f720ed860904b9252e3f7fd83668f6b909750506c3ddbe12c99af096874c26f8d3665bcc578d4aa5d0eb6366b835b604a6311285f709469c5977f351dda85c1f8f658ca10e8ea793d206d136e732854e1229f39e632a504439d13283596777e7374dbb5914ec0a12503b0b0ffedbbe6bf73f10e86673f496335bf652abbbb449e90f058f4a3ab9a3112fd66bf6bb5234deeb02499dff2761092303c0b50d62e86c43d6a2007d75ec69c0e8ebcfa00c5aeba4655101807c42a7b0f3d7b697a79cdf75dfaab10a5abb5d60e714617482596a64995769fde091495c4d0e4d2e719eaaf8b66bcea1ccd218706bdbbb7d469b3b149bb962c5602a5d43666cdd1ad96bc437e3119e571db2954e40ce5a2663855668562a32868e6d66d7bbd72522e264346f4c2770ea1d33fa6eeaf3711343206815d72aa275ad6c1a867c9a555c56bfc1c5fd2e3656c70649e65ec0cf0826142bebf6f9735df32a3df46e9758fed5e09a49af6048464549aaa64f1ad37cb9429b26bd6985d78574be77b261ba41a5de0adc9216e04124e15581952fba61faa1992e4fb5b5d7621468b746d1ed0d7a25512bb5b5414daf10d9e04f7316247fb3ffd6b87406b5d3daa88c384da2d835dc2fcc5002dd95f43f57a06fc3c2d7c84624fea0fe88815baf8e2566465264954a0861fe9d7b0e8a7a12e2a69962b32146a1196bc958af4f5f4151745eceab227bb75510acece5c69a42b06d5bbd9d1a76fc027c613cac550d6c857ebaf72ca1a4fdd27bf08d5ee66f74ceab61add494f83704fa17350b13dad9b038e1b9620a96195775403722508a7149dbfb1b37ae50c2f2993cdb6395ee872b8a4790664f1e124bf8de7716583eeea1a7233404cac8f70852c633f004e9cdc79d5fde68d5caa677a4cd4142e5f92807ca0442505712393571753ecfef001419293c671b17b66135f71b20ca86fb381e8c71834b92c602dc94e365de125a4f0a551c745139088a9bc49a3b551240837b02325c56de53afe53f6bed0db19fec90572edf4073bb58148e19a148c8d7dcdfc686639e64b6224fadf31f979c0ae665acdf06eaddf8bd4b13fad8b5b1b3bf1cf668efe37a8bb3c10198b72a8bafb7033bfd76cdd52608eebe1811868e388b870e0ce3ee668a72ae69088db66ee8d3c760cbdcd5fd94ddafc542329ceed9b3cd7e2e41a88d00c2984a557e908f49c1cb2d38532b92478df91cf7d3ccff6f638f7161bb85f46172ba940f5fb896a3636322eeb1a738fa86badbcba49cd0be5f76b7ffa750d412ea1616148875f472f5dba0b8746a3340aa91aa04839011f6dce5712c19d1f1005190bafed7561f0c9f644368d36f36b322a2d7ad328596aece96f608eca19489255ca06dc2198258aef50db62c57d6c065cf8b43cfd5e5a7e4d99867a29d15effcd53f5b6986dd75fc09cb2b63939fd04b1e10fdc780049c1bc52492ceddaa3fc35fc7de0a49b8a19405641761455aab6c20bc245fceb94aaf6ed269431f161349ae6ee9fe9e7edb3ea42dc93139a5f7283e7457e7b0b76ac230b75862b2f1609a9ebeb953b2d24885deb00c0ef4b3cb88f0efc6c918107691b6e4647675c4ce6cdf8624091ea0c33375e3d7ed41e8ff3074af7555f4d9222b9eb279d4f06511b69e2056e00755fec6a82ecff9adfc5495060d6a58f9f2950d7d6783a85756cd5934f6054224313b1ddfe11338f0eb17a7f1c31c9bf6b34b438abe109ebdd053fd7ca2783bdd181a0bee0ceca0ca1f33a5c3b864ab4cf86608c9f72a328c74f25285d2fdeb74c7543ac973800c3daa6ea12445e76bd23322632849fff2277b0625347d494e3f89149bcb3f0a257b8d3975cc8c8eaca3d581778817dff19c8e6fd1f76a701fdb7f5bc4fa516dfe178afe9d2714ada864c24caf2a6d1ae6ec7f83d35989b5f1c81f1b4d86b5ab5f92323eeb39ab0ef0f5e85658bad804322f6fa882fa7bf87f762f19a55133533f2388e9dc3c5037daa13ae10d720ae6baeeabe72103cdfa5392e44f2fd9227d8137a69ca3995c47f51aac0f6dfd89da87cf9090216a9534acf10b0a4a77b3a1d81ab4667662469b3faa653a9b2c2014d467571d5f4a5b3c9da1f7dd38ef624e3d88e2c79ae7eef764e10df79b12fed2efae4a4de6cc21abe67c5832a9ab05ef1457774d7efd29ce84af249ea2b81d21fc5be3df70c15698b307bb14427cfd7e3cc8fb930dde91c627ae3cbc745ec810cc2329295d5f854ccb78120d296234a935fc6a537b386c0644f583811ea95aef9f9261f76506efee493eb4b31e39a514d4bab7d8d1a723a05e3f8ca17dc31c8f65b80e6938a55a69c9ca681504710e46c4d028a928e3258a4389d019af584066ba08492528a6ff06ae8b9fd7cb876fc6548dc5ae1bd09362d2809ca1af13b3b71fca9279fb04d43d7740ec4b3021eb402beb0914d1c98ce51f94dcc93aae023947e13e3611ee8ba0d6386b984a350603ba6d5fbd9ddf3e3118d3f6e693559940e1ed36281b9e107cc8d64144414053f1221fdea625b120b0c9dd7aa82b602a3989e3f0cda1d30ab0c55ecd6a814901677a3f8374a00dfc95189c4be031362c94ff7ac717fe4d09cfc56419e5b1525fe090aef0c7630fb98a8308ee5b30378c08eca9c7bb462638627990b5736d14b97b6ccfde87178689491168cb20389816f3c3fd1b36b977cf9366fd31ac0ca8f90a792d2d41deed7eade51b6117acdcd79ec9fc7401e6057d13374097f11839595ad1abeaeee223cd0b3e2eb20d41378e16d569ed0442647d99550da867270314718e65ba446ed820d7f87ad9cbfb4e37a8c23dada5c442fab6ca01be35c5551c1c8e4a63e46c287f75e8a0c2aad0ffa516b4c74ae1da7f1fc89e54fb20a29b6ced4cc3782f2ae4caa64eaa4e04fce089577dd19c552f646a98870229a12ba3c3e4407ed5ebbf84e725d4d0541c17c5fa4c5c493aaa939de2f994c89e3737416ba9d49ecc82b4442498449e732bb590df97cb1e5e2c4885058d69bc4445ff1e0c0ae707a51696fc44c3a34bc6f79ff170214fb29e3579f06b524eb0ad296c3fa7c77bd1a715c56a5a32f87e90e456482a2946f709ea03ea24a24678e3bb4bd57c6035cbfecd5f8196400bacf572dbd7b086f44ca635740fea92aed125a84406f44ffad27b8b72d9dff6b71651bc9467cbc3b4c3007c3364524bbe912900b5544e2fb99e0b68031aca9cd42a5d89a932b190f6c874f6fdf9c32db2dce348a4df0335a55f093e0f4a0c6ee8b047d2a0d228c2745e7c99eb472ce572adf685c65a0abd406ea16d116875fccea9e6252467895cb108da1563d89ea91d936cc851c17bef26bd558cf3cbf4e140f419e20f89f843c92b37678e6fc933b7ba4fc7a406ff3cf5a31ee24e4d9e3babf6ee819379331d6d9b37758799ee69011c75dac23faf1b015faa03943e12fb09687f380efb8c5eaac48f7f2f5d0148a7e266b78d4400d366252514e80121397610dbe02ac90e75f2f5c1b101821539f6ba33745368588d5daa5e82ed6613d0731521c30057eba42567e5d3b3fa98aa5257d896fe05a0a7413d733720613ccef9edfafc87907d8cabba4110b1df1d12b4ab071142e6d4354a46f80f9262ae1fbad653568d451948e8da31b50c2bfdd3a2d655e7384b9f0bd534620911bcb1ea2dc0c3ace0158c6fb0068fe9e9605c04fb2ba8d6f2d9d57dcdd9beaa966034a6a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
