<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c797391fbc8c43db322cebbe88f4ed3f66bf05ef47a5c8220bc65ad992498411cffebb7d9532d427f6dee86a118abae7781fdfd1f942a8e2de431fc8298e101fa7b335767614e2204875a061859e508babe1ae8ec7a13c548e64507de81b34a25b9ff0a9cd9dbc7d33daf88b532f63380daee7be25acda0ae0e6d21185f0a1c9b95c73f0381866e36963cd9ef4bc05373de8dc3d49d8635124cd729cf77e17b0ff67decf1a0a5e58ab8b68322990acc7fe28035ce9d90ba6deca7989de1f1cbac7a14801467629d55f063ee1d37af1a8bc819e58a22ddeef19e78a3e594c2aae766bd730424290ea96e269a19949d9ddaf9b90678de49446d4b00d5d1868ec5d409792eeaf3ee37416537b19e31400ecdfeeaf164281263aa2bcac6a9d8654543d821facdf70d0a3b2fc039187298284ac07b5066872c8cfb287d896f18d0b59e2f80997bcd2c9e2a0b5e631ad706dedd0e6ef225375dafc51a06d76deddd517074c5f3459205b5905fda0bc43a4706d57e662402abb474e2ab496d8b15f727af1b55453e46a4bda1c8aaeb0d54d1f067fe44d892432c541266f2ffaf04a8b9d439b77ff5d2274915be894ff7328c70164d487fb64b296bff1c26def3da5470a89adf2851df2245f4f33885e6b394b19ed46fd09c4b3f43aa740d94a75dcf389a4de48786cc3e23a7dbf8559d6fe96c4342f719c5ff047cb1bc50384c4ff186f8b9fd6791290415a49243553d629079e35d5c415199a153fd74d53a11a8678dd49d235c415284d42c32cd1558b527e57c4bc3febdfb57cd7ded493b37280923ada63751ee974ab751e1fb9c3559bb7cc3f634e8d851620209e453c81f3640044801c26c7d645dd528df01f4599e21841391be5c4cadc74ed77eb306fbed7e5b3debfc4165c3867b56a0cf1fd662edd93e86a8d6427f07a2e60241f27019ce3648c18b00147458ba2fd7cdec7a0bf51fd2ca70256c5ebe8352355abb87ebf5f23281c2b6b805e4b337b966b49154e323f99b7ccb88f15cd3c8058552c2df1fe8e3a9ee05e145c039ee2bae27fdc5600b56d0b03268e491ac9ef917766fdc27ac0694da5c7bf164d341a6ecc4451bdc4546533641519f98ceac01be926b5b8d533e848073fd1d1fe0256fde0560bb37dcb18bf5f8667db526da87f48c1a0a4d078fa809aa5b2c494a897d640cad349875787e499228b1edda11acb4f558b7c34543e6b7ba1579560f1465fc3fea47f3a1cfa8bd5160960e60cf9d8a6aa740d7b947181c47f140a7e651175e5c78a6ba86b017233007450d3adfc51204b5dd7288bfb6674bb77e165b444072c2c1ab9518bf2383ce25c7bf3d8c31db93c3af5508b23eea864faabef5b117f60214c1860a898ba25a4dff174d07f5ed33814c480f0ab2dffa09045dd99d67e04025309a842061ac0c6d9628f7424be6dc6b2cc6257a7b491900589a7cde06c1f5cb57e9b10ff57b048be987034015694b00d039b80029a0b2a9b0fbcf3ddeda73d049355bc5f069dada4e614520b8c948b170da225bb82d170654c1daafac938e760e861ad6b134dd3544a3bb2c95d5661c4f8006466d4fe38ad4364c54f164cab8a4a8f0bf0e7f823ce68e46963781154c60aea45994645103c285aefbd4343fb9800f70482ca8b57f01ff2302924a43e753f5032dac9e97678c7d09610052ea681fa1e445279541d7e12bcea348eae93a5ea63030089abc5aad34454a2ca2e72298ba13bde6ae04024f626a3255c64df93c9f6d956d5c8deab4f58e1801ddfc091dcb5335624887c746441ac22d9fb613767294004089c69ddb8253b2f4dd24bfeb72ce335458a7124946cc54ec5620e161e466614ec9ccef565c7e9a07cd45fce7777f27442fe46d0448192d0eed2091186fa945fe396f0dfd1900bd038855b97955bd64d2fb29fbe0d4548325ba0330a214cf07387b2fc3862683c9c3b0d5f7e0eaf51ed6739a38c3b9b1a43edf5451603d50d61c45ed8b39e05be7fc992bab76fd07b9e593ffb43fb96684da213ae0bdacf10032d7ea5f2a427e39a5660915aeb1ccaf1441b924a7c26d8a47134ad75ef8f7d5522c77d2bcead2f1cf56f791d046e32b09a90badd2f9c7ace08642d4ec6d1c4ea861f6b916a7f61b2fcec98f0becb98c108ab9e393ee859a40f35249a09523a07b4d66aaecccc17bc0dd1b56df7cb06a1ad7f0011784581f2420e34856f47f172bdc569d8452a593b1ce80a3ffb5bda9de45360665f9529f9a5061c54ad387c5f25a135f9788b3bd6042e3b767c0c59307e282b7d3ec717dc2d5c3de8acb11d9ad898cefb22c3c4c336862ee59a87aeb80ccfb42e6a518e0c3fcfa3b0ae5e940b2467a438a0f9c8785cabe8adbc222d76a1012b37c75a2027f889b845c936217f77e856e69ef8cfdca10750577a490bcad17e8bf98350f3098a8a8815727f717da2ddadf464d931af5ad987f86aa1e918e42de6ecd98bc4a9f30a92c67899df98aa7845ca7a7ebc10cc2276d016e76d030e5e971596d465619ac0e480b51babfc7942a44d7f66f2df923573506cd45294a395e3fb90ce01ccd63f3503f98325acf3f2f5ad0f6e5796f4c0462658f234691d9fe5893a13d073a63d360377cca7eaa2fcff29ec3366ed89ae622c9a09533b44343d2baa4a4d68e14e38ff7194c348b583e2fbd4bb2d5e453820c0e69031979b54e6fd9a37209f905f9ff024600282d91eacc5bf4395dfe875ea921153e3dd1e92d2214d98a215e375ddb7dc96e2d0ca6b657f84aa3f7743cc9268aecee089f05a0595dc274e7d73fa771d28b8faf0b0d6a91cd7756e910dd6714175db33b803073b31ee2def881943874fed041673d3a8870e1f8760d3c201fdb1d5a04106c6e111a1caf5b7b86bd84b275e545bcea37945113f1e049f51bdfbb4fcbf52ffaf1fe74fd55f7abb091132b1feaff060bc14c245efcb5ab501b1c180b5d9f295b2dbaf2afc5add4f2f7bfd605a4d7060c81d3f263ce094b1fda81debbf0e515c11a8f8b55ee1e75d4ae4ab8cf46caba65fb5236335e21aaaeb3440732b566cdcececae98e3c05eeda0946a6205263e09c17d7fc930d6cd389df84f52da7ed2b2222c655ecd669180ae12448836e0f3d80820859df8a73c6e276b25b721400934c53fcd6a082932178293d3e7212fd71c0a4d6b67b2fd775debf9edc37856a9f87df6178a65d2226e19d838f6d9994d8dc1de865607e8491cad64f7ff99262a8c6e8ac8f02aecdb09af616566c21fa1b8d94af83277c22713816b4148150ddaf922b2ae7263d42bc62d460d224b54db60b8f57d0bbebbb7907f0cff3e3b16e01db02084a62425d773f461fae976856e7e1fad8b6db9b3c4715ec8c580d79669d984beaca6a0923b45da26fee9b0a399a077bf9ff1c01d7653d1443e3434b8debe53ff270844e38f781a644d4e81d4ad2e3466ae59458eef3c860f551809711ebea08e6bd6cd91ef16f2f1b49c0eac23885c06c232c608e7603111b7f8751735b6a0b00fca422fbadeced836cb8990b6af4def50f08292a48d2fd8b542b3a5a66348100b0ba487370a42d8dc79c811f3f885282ec5646eef51deac6ef0e39053b4199761972e445b640179f4994356bc38c05b95e96f19c0d53b7d7608c760bd1ce16082fec7162378a40d55efd622c79a47826a2d340ca2c049edd39546cf4a299a70304ebcf511ae9b284e25e21691efb5a253392b642f24b27201b698ca72371b5dd707c881ae2627f282ae4e8c75f5e5c49b6568c60019a37c1c231f42955332f980baa0777c72671f3a83f6eb7497f7d188ec7073c5b37c02a163f92ba579ad4b6175479d47e82c33c6cd62388e254d58991ef4604bdce25f7664e053a05069e21b9ec4c44f313c4f1ddda0f5a21816529f6e03baab225363988248748999cfce53659d3bf49ff719a4e0e0a2506a0a7d104306cd54167ec1d6092b1995cdb6acaceaa6e4688512e8cce0580fd3bca1e551ca993fe4a28f21609e06c11f072f24f5c00c83e9c41025db5d4767d36ece1bd7e901a09d94fc643bda22bf2bee6549319d5df6a97339e5f17c581a011492efdf0574fd471654d820fdb05a83645b2c084f216cd41aa0edcd490556b9b59da45666b63fb6a736813d5c2bb413248788d0e4c3f68b8350fb766d3b6f3f4b74230c02a8ebcc8982f2beae75a529e759117a86eb898d66f6a1f84aa18ba01957575fe86ecc81b7865b891ac26066cc9dd5e423eae35fec00033bab22ab713d1d0baec713195c18a1e9fcfa72a4dbf911a084df31bf9800489e6216e9c48f130870ac79a804c25c32a40bb2ad3311e34258e747494e23b5243fe52ce598e09123921f9fc3702da1b43a9e8d4b692a2113b863c978b50078316cd7adbd89a1b2f708a8a57aba79b0db491fe9f07b4926cc9d63a5fe3803da270ac85791d50b227fed823d32546de662d1d795cd5f79526438b9fc6951c6f5544fe3d3fefed8ad59f91f320d6d1d293d6fd10f1d61a96a4cc507bb1fd093fd78f135ee9eaaedc1722f25a7c052c31e4c6d513afaef8c7475869290d7fbdf4e5fa5c44f2dbcd68506f0f666a4da8b1092a65c7352eb1adef1c533e8c53181619684fd438be00a7088a75f7e65729f4050eb5aff707500370f911a6c4d89162ad9ff110d51f0e3e9390dd0a288d54f32f500c389d1b30e9a059b6890cfec1908ab08eb34e3d5a1066082e20b297087f39fb120427f6c230a8ae09277aa40a04ac248f85fa21fe152533c4c7893fcdd5852f606e1cd7dd0acbd12868b3cd557a84434411329a149d8a3a2a5f1f127af2d3823b0cea54790bb335fb790665752433e7783a5d0182fba78fd9cee9a03bf6dc89b11c8055bd743da5bbb1ead669dd3e2c44473fe0e263b06fb964c26a672cfabadf0c444c8089fab557e25aee449c3c8bc47e068f9b0abf9021c5b6a7b5458de9092fe70de8be65f031919e32c9a3a3f45267568ef38fb62012f413eaff91a7730050fe65442c516183498aa1b9d8d9d9910e1536595951d63dbdcca25e3776bf326e8a7c8efa50f9606aaabec5757dda16732579d6f68eae38ed44f8c182b54a92e9f1ff574c72585e5ab5c6ef6fb3ccee55ddb29c49d002195943f57d4644e6585f0f3fafe3ad13ee6b4db1fd3ff136555abf6674b52b7aafa62a6703d11228617af64a9d364dc8c0f59bd7044bda923a1ec0599bd28c2b2826cf05727795bab7ee7d26e61518e41a4e506ee260ff52bbbd7623c0f358ed9b6105d2927e7e0ec0f24d712ce84527d97656f878275700f6e91244c528907dbb5c4001fbd8090205b37e1d047916bbb6499eed1c223aa62aaed2215eb232d84b76ab5df57a439878112ad779d2d08b689664384e95361c0dc18831496f26d01940b0732e09127a9da4ad522a916efd9ca9c2bbaf0f2505ff8f54772a91e8326a43a5b2b1f71d0f5b8ddc68f29f569fa88523a799240aa818f058e8d48b929964db3f4b35102684c3b80ca36f8b96e04394a5207334c6212401c34bafcbe61ba7ee9e0c1cb6addfb261fc32acb32ca24f1276347ddd8bc9608dd5a667bb7134feabf745f8fd98de6870a7b6a714d2bf97516ec9114249e2039467682db80db1c23ad2523c426d8f97015702adcd968c345a3ae031918710b473830d7359a2e3530645c8c825f30b00697e9a62ae85a774bca3940fd1b69522973f6ad17926f64050d1e8f1b07137407dca3204ed8908b7a2c5c79637fd6d4dd541dff8daca7be0abe7c1b60310e314640a32d7baa1b9772ac0c58c99121f5b53b7666e79a4415223c6054130d252e093ac9ede8939cc10b11ba9f27f0c010d5797e48f82ce315f6d9189f72e750688ad9671aa6b69e5719abed515b1bf35f72d7a5e0479d6f905bb9436c8a8318d0a895395dd3ecd04fbb1192b77b080ffaef719661e224e04def3da9255e2f66fbdd82b855860fb80b110440557d7ee259899b229f45afa5e7dd8871e214ff1ac54fe32a130cf8bea794f1ff8ba1de92ea4ffdd9c39f9ad59b8b8380d9ef6b2a744e46aa6e1f20a79f4def63d214388b15846aba039eb6a08ecc5e1187948fe72566708b4d806dd2682d980aa4961ce225cfd3f48edc6e213f1ccbecefb50e8129d4e6ee6924f72b287840c8f24e655fe9bb042d9c8ae688b284f25717a686ff9ca3ac0edb524169ea8960c5803959cb12d23a1873c10ad12ec2986e7a55ee0a12c49093d098198589deed732576f88671fbd645addaa85f30dcaee0704bb23811e28bc369d02bd3a5f0df112500c4340e5891d3b54f6f38f8196c8cc063b9219f30de2d981758204f1dfb096818cd1ea8574832760082c9ceea6bb81435dc745586e2548722d04db79e635a0393beef653e6abed46badd40487bc44ea367d75a84ee8bdf4a45c41e7178379c68400e55914c1f0e98319a11442a647c4a2a5a03302137d23900d68b74641d74a57e515d67d5399198280a2b13f35a55a3daedf7543f0a4469e9476c85f1c611ca7fd3d1ce2187aa7ddfab2f0a0f98f5423f024cf7172407a1b4d80505b5161ef7e65c9e8ed364a3bf70b09ee6fa5438d51cdfd3f12bbecebccbaa6fe7fa711b465832c6b42bd28c4bae3ac56d8acb59b6f489a923b359b363e5d66d35d49d35f25c3960fcb3b2bf832ace03a376c2d80669cb072b91f704fcf7c9884da0a39a854e013df99156d5d0e2fa5536f883c0eb1476b7451e803d9855b2bd6ad828edfc3474a695fe7903271c89c6e5eb4dfc473e103a7957b17a7611a518493fdf2bcb7f22ff2549e09793318b0437200428549d88188c468eabe58343b85af9be2abf6fe1887292a6e79513e6bfaf228004da73dd7d9a1df6267c1924711fc1987447a3426e12c75b629ee3ef98af7e6242500340d612613db508a67ee05e0216eca86dbdefd92254ea35a3264baed03c6003441603b8368e8ec4a1c0ee1b066038e0afa4eb9773766b0c98ac0f90824a8a614e4ff287740fc24daa9202bc4fa69e6c00daa27e7eff2a2fa71805930af7a5a365200ec00c6ce10132dfd6e04d02244230558c54ede2e300a35fe4db2dabf420996ec175c7726cd1e7f6f34692766d90c7f7f5e582ef3c723de20f4ab916fc4511ffb370211a1da81c36e05f08bc0eae304bee5e3d5ab50933a179d09565d1964c71c5eb7a5004c5b1ed1b0cd937f13645a3cea85272a2355c6494495024aebedccd498ca35733909f17f43a99502d3f5af85bc956057d3fca13ae875a26f486884c8923c0b64639c9887e9e8a2a610f43b85e42d520a61b5cc1d9ac0bf49ab6e806647d80ae036b6135ba708437e47801e69b75a1643d53a3dbe624df6ac07e4875fbe4c1cd8d183f359906167c48876467cc15b8c555dfc5950b8c2dd0fa18c0fcb8f1f0cf1404a4af46f7a3864ceae536949cb6fe40f41d903075016e9113c8f445b3548280a3eca1ea6ea4080a2358630499be4ca8bdc63da84c2a642579c618e5512a01035e6a55e6933e39ffc7740ba8aba4f6705cffeb7bccd4ebf9a355d7b140deb0ef97d584fcd1213d1f4b9883e1966db277aedb3ad782ef32daa9036d920f39d92e9671eb9e66c4be4ffcdf8d535e94bff865687f1309b4dea032d803dcaf6227408d0033fb321b04d87ad8000f5879d200c0cce9335108185c1dc5ca3d3480a4fb9132bf38587067ccf106c27dbb3f6c6b24be500185cc840cc4f10c60d547d6a05884c6a9a359ace40d92e1d4b075398c4dc35f4e0013dd25ec9f378320dbf4fef53d96cf05b02eec831111ed70e4e93c308fc44f5924761ab938d413e5700487bd715fa8e5cbf85a6f2516829e77cbf0991a6def3002364d5db6b70544842464f7a2f041727fe4bb59f7eaf5fed2ff4c4dd3c7379cb08911cef677303a72b0c2fe3ed3679faeb23f7fb9c80362dee0868ca6b992fd03dac8f48fa0be778b95a2618402ec3cbd43f0910bba4de63a7bf873880d401cbc7d0f329f7d740abfd9e6889584a538ddce95e55580fa3ff78121c45889a65c9e5f00d62155b206014626b5f0aed2d51564a82573a21964214368cca8f8683f9808987a93ce91bf5b9c3b38143f1a7eb5dcb227da19a833c7a5666bff8cf72633f9745a4eff369602b0259cd7bacc810cf0515746bed8be176e26d93b51159a729cce4671d0f0c25dfb3d83e2cfa915e91c090db38a1f11772ca4e29389e0734baaac29697da78859149f0894a89dbf968c0344e0a58de2715fed5ff27f0b653d0b44ff3ceaec8e7c6ce2536d6116eb8c5339b808540a2945fc8e82e4417c6f4882aae6b575f43d0fb1c80b6bafc738cc4fcdef801080d41be8697e692b48e0e0605e919fed8bae3b13103638ad098c8af94387fda1bd60100b0b635d1bfe032c7324aafd31d13ec6a95bfd77936c3b27b254f84dc21818eb8f66bf96b092c2e6ba0240624996c0ef34248d3f8d8132562e4dcb6f727c103feae182f8716cb4ba73946c979da35f4c5fc2dc93fc03048aed798f2d5822fbe03ac1f83209eeb9e6afa27d89f69126cff06e098206439a447ff9465b68d97edc7ee2c78ba545f9e04556e6c4d24de9af01ffd97cb00175dc59fbe4b72f1862a3891aefdf29ae46dd57797538bd703cbe56cfe7d90342b6434fea4440166107544ce40ef9c9b72100dcc053dc403ee74101c22c7e5619ad6cc45ffba27f6bfc7b095dc26436423810ba5c9abfa14544604f246915b1ccabcbb6573ba709535b64553896de2b3fc0dae8b00e30bc5358036c48d7829672dc7d2b34af9e5303e7b5c0d53628463cb63f4f05ee3aeaa7874d914322814b6cbaeee86700b809ed484a6cf1b131bf5fd22b5c2f037cbad006e4e6155b5146c58eebc49cf89b651d447b3a4172833c448b51485704b408d3ad168eec523484d07bca86ffdd6480ba80161565dda680128571f82d1be00086735f2632431a488de5b126fe8dc1db9358aafb38fbe2f1118993f0faa9c2844d702f59d1792f2f16b6471d705ed200bd822469fcd23a5d21d377b94a7baeda00730892e6af3b5929be65819409938e24312f8336c2caac4097d626448cb209080ae9283b5005222ad1420bb1c494c6c48883b1a594db8e6c476b94bf023468dc19d37e731a2e18a8896ea31ced74c4415c340ee1960cc54203011e97fa0cdc976355784621b02fe3c1b0a4898b1c4db77d253e7835e633aea946db44baee04571f496f04c86e86a67900419240095cfbc7d98326ed0b3223203521738bb70908defa9fd1894a0545eaee6f824d194e9146e98497692e8524c9c6baa3e3127e2e56ad35a4680c516d848139c0ae69264c44c2998c38f8506ca4aa5e33607a5d7db5ad3cc7e90ef8a4974bcda8af7fba43234dd32f09fe3a26f1fef399d06430840fc98f4b56014eb001956a8d964ea07aaf99548cc85e194e0668a0047ffe9b29aa247da811e4fa7cea2ecbe0e9c06b8d6b91fd47def5fbc3aa30a7e4824deb68df75821fceb8be60df46c0ce5e4fff0d4d6844e27d15c79fe9c58aba058eb0959b28df373a427bda02199d78d09ec53da9d1055f0db722aa3394413deb2826cb0129e927453b8dc8cf3a4d22b867dc959d52809abb916ee8b94997cd2c0f9fdcaf89c563e06ef909ddfe5ed2107f335c8e2789b19e95eba8da6d9717fe46298927d21f3bd30bd4064fc50e1dcf8a51f8a1d9b57a5c4a1d50327b34ad88ed5e558c0d68f7c35bee6df372cf07acc6dba777e3c310ee50df348ef182c311ede50ba5da7d684913cf995b7b683c0222844c26de15dcb3865475219a2ea92aada920cd9934249232a6f95c77ecd01e85a9cc6a4c6dd398f3c958dc8168548b654ff546939f06ce56f60510a6fb6a1753cf08b65346a6737d33a578541e34abbe7737ed71904aa2912b81e55034c3ae507c677477a3e38aace3ba304d8ec1b9c3fa68002a4637a663a3f7cdfef3147335d2b07a75a9ffeb4b590958dd8be3e8f1c683b440a397f03a0809514c151e108a62fd185c1d566c1f298b2f3aa54f7c89f0546245c0bc1208188ca6987ca00b9093bd829fda023f4cd11ac4eedeb53ec2154ed521a9285498076e2e26c9fe629c880d3e341233a2e4e96a3edc18589bfd0542c56c1523e5be16aa433ee9c787db2c985827ad875ea1b98881cb70662660a3c11fb2011bd2459aad151200f564e3c3a41bc0c0c3f06a18bf672abd7fcd0414fb4137251276210b77ffd67b0ebbfdcc9cdc9956c313bbd1e27abd4cd5814fb59c03d9387602cd47937af0b8b4dce4865a642a99030da23779f12af9cf82b50f3a0f14b2933d2173615efadfd0c9a7eba0f4bb3930415d9fba497d789a022d9a35182236fc40ee19e84737d2ed406734d2e9df6eebce4e824c55a9aa1c11189ffdc27204fb0c20b652cb0f68c1d89650c2cb2252034334ec36755601a6112e5c934186a0ff0b0008553d92a3841c5df381a3a38433c12a3811a4594f0b89ed7aa7109f4b2f3661423629fd79e2015eecbfa6c5d2f71009076462c00438960244dd51bcf11e0bf549b4d3956758e3338e33751dab8ff2f92765d7eece13b98ee1ff54bfdfcc7172803775afac7a913bdb7c6d098e55a4d45d575555c8908a8d8cd16bc241c0a704e7e0615a42a4aa84fd0e550e7d9c60885d024e2031a119b9582352ef725c5f960a4042b3882f5bccc0523f01c0037dc3c32e0de93f9d676a9b388006e899070a607fc6c60ab93ab9a94e59f8c98c14950d7bf3f537f387f9309ddbfdd2cedbb830b22db75ca6d3bc14bcf5cd4f62d0d0b8b6f820e4d55d557ecae4616643bd3d55dcdb0ffe882bef9aab401a0864d6ce410dfc9f0c6a4b9cf7500d9a3e8605659a9d4ae6485da21ca38c12e49a9141eeefd07869d1c24885f7b1ea076be4a6ed0370e650f16aecbc92dfee867e8597753b84a9b76d70dde6dd3374895b6c23e7138bcb19f7ee422bdce0591aee9a1af76f43d69f874615c1e0037c4c0514261d07eda14a4c988a7a95639886433c83917e58a85eded1a8d2da4f01ec7ab79ac4dda2cca3cf963e9ae9d370f747c6a92930e6cb0cdf6adc566d7a64b50fad1bc4446b9dfecd5a64d350c20529d04ceaa59687e952276d92e9563fd0d2dd892b0e0e86df4fd8403094854464e69cfcbc3f170370e7b49327cc3376e4fb17eed363aaa1633e7efafacd78b08de48c4c2238152b49087c643219cd59e49848bbdd1ebf63996ea792552abfad71fc5f6b6c90fbcd48f2df606128c8587829837c3fa796762b52b5bac01503ee16f686694f81bed32da27818b9efa01f60f44a6d166127ab4a157c6ec1649b761fbac23a6522880b789a2c3786923693de5d5007f027945af5e89a4dcb0bfb11773a19bdfc8c561cd7be2a2262577fa6dcb569cbbeefbff90e73d3259cc6ea046ec2417209da5794aa08519981d95905942f9e0437a1e2db213bd190195e49f0267d1780b8903ac3703e279babc96b4902399f6d71077ced7ea66c76152340715d53abd3863ed3177f826ae2d2f8adf0cabbbd0096f1b1e65cd5419a93739b5af6e858c042482bf6320c03a9c2cae0c3544b62eb1fb752d88dc515d6b73ba59f267db7f1bc3d2ea2bf2ee17ad82a219e4b8f7729d52834f7b413cf2633a3499460b148223de3c817548883ac2429564bc93c8976b3de5170e782d31d70c72f5667e10c82ed1fae78225dc75a336e9126c504659bcf1ef5151595bd128a1e9aca5887984aad2984b968ff5d47dfccb28a6b37a9363c86dbc93f594ed8d82bf6d787399136d79eb2dd88d89face2be3f511bd684fb7ead78a94a74b3f4dac7d5709a5864f8100cf8ece97eed6ce73cd37471d20e3c8ec3b0ec61559e75b7da38b7d121f9c15e5349a0957b9f99a33d24fdbaa615b026454533f5df8103e60c5ae58679fe7a78a2d74ccfadcf85c56f2c1e99c6923a90ae013e24c599e8b631b1edd7e4cec93559612e29e920b3e19ec2728e45fe0756e8e41ab03e6a1b9813e97d80fdffdee26c002249485e19432a2cd6488a725f7206c92bb2b089a8b7c2259cfc7dcf8bc530f76ee7686b428c20ec4adcdec42850e888cc7f9f641f8c11269891e3aad76a9ffc9650afb5a81437d9435ea3b7355aa23c234a8c7320f771381119997cf2965c79f78fd3635af33c91f02d09049c0c13e3ed418cbfa6e723649e1fe2f76d32ce3f8a881afd31f08ce5b4b5ee3e8eb5be14d1498786fa536ffd197284db2fd6ba08864f104ebedacc43e76cacda3d768561b22f980ddc419ad45883ecf8e69cd237d342b5a988118f1f71b97040735dc1ae46f25da916ae134c033bec515bae69f152e69802ff7c9fd1458c10cb139f3207df097b27b708287b57509e4b41fcc44e0f392460d0386323302ec1f49d075461c2763871f26e295e8a0d17e3ae28a154e39693290a31588aa779e68ec81bf3b9b819e6ec6f160c2dc4a840417881874c48671aacdf5aeafc0b3f47a0a35cafa7bb404156c65b2a285a3947ab00abeef76ab6abb70721b71123ae2c711699b83943a19725a2f8c9b9d8f523569570fa22c15bc43c4768f271bbc5184a036233633e2b3d8ecbfffc689627224f1f6974af410e0e11b08d87ac5ef6022924abbe0af4a5fa604ea36e8dbd5bfc067e34480e47db74d4c8cf9c640b3244017fc793c173f88debfda77ce45411f9432e54e8a9cf72e391aeef6f993b2e16b35074132a928da657f3013242beac31e5d80836552df0264c1b2b19b9c2143a147576d9671ddeaa3980de800115c8a558843223beceeea046afd3fc9756c6286fb94527de6ab1ffa95be6fdb86224b89036f60da44e6493e62a0e6ec74c56934cf03123647b29a50f36f0bb88fec276793df846e80a8f152d9f51748ac2a5b89b11812e6edb89d67e6e38aafd3b1653839cbd448b26bd9f142c91e67a1c808de4abdfddc3fb4c892ced66f5cbcb1945ffdda52d56e6aa478f9c2dde7fd242d0b79bfb9a9efebe9d0998d691e34cc50334dcc69e6312be90aba2e9abb04a9c14e6b0a22e7420ace962ac663d374d36b67a98e1303075ff3f4c7730d837b4a8b8155f9842ab34a39878fb83afd61f98347e43de425ed963abca4c6b9f853db36274d70bce32231ae22fe4c656b2a2ae2ad6ebcf3e1facc7842c7b0ba7c3e346b1dde36f24e25f6d15f4fafa88c4808cb0174ffba2a687d7147af4c48a36e5ef039ec6ecabf92118ede862e2bca1264922ecc14e1d568775e46f522099ba66fea420afcbb17c5069be9d6f1c9401fa03881ae12cac0831abdf9a29d3928971aab16b6c266eb7df96c835bb8eef083f39dcc01a6fc9175d01dc66218186d6f2482b06dd3b187c92e017196c4eb4aeb5c63c08d2ae67408f66c244499a00dd95bb9bd0d1edf1b46d8d2015476e74f2c7355f3f8b76441e387de3f4de4458204d062bc33e09db646c683415162b2726b4f4670da3b3ef3c07211e9e4fb16cc70b535fa0d92cf101fa5321ac989f26f68f7356a599eea6dcdb57f1ea10156294c58aacdb713dec33eff748911880d8ed988f7f71ee577af3ee97c5a31b5994086d2ba04563ab581716edfded9ba83981c17199e3118fddd9d352ef50b1131cc208399865cdeac97269c46931d80d5e55b77955da5999b768025f9039ad2f844834cd2e4ade72d7fc42dc299061c9f44ab5f2edb2d06d0d2b0026066c64c3773c18992ab7e4db44684578112ba7ebe97818c3cbcaae58460444fe069a7b1f8f3e8c3cebb6a64d92d6f991271c23a04a7b45a4a1c0c82d1d342285da04bedd6eef4998bd7958d67e31afd62c448c69a16a2f3ab013802abc0bd814e739648ed9c514175d1901315367d410ba7306dce66d2445e16eafbc319dca102be6f67e044d4c1cbcb67a9920a69786d54ec8cadfaaf1e7164a7674cec5a1f03ed41897c4211cfa59986f7a736b58e2275982266025951b7d430813a89290a669d6121c8db13f80dc345bd039465ca33d1fb9b9896b0b572adc6bfc7a5f1a79ff09d1b4f6f0bc6c6ad3921d97f8f9c04a8a03f11daf96108c866c9c4f491d14dc4f0a97bfeef9b7f3ddedded936b3406244629749ab8d544c78be5d81313272d7216befab3df1e3942ab676f3e6f3380198fe62b8cfa357996e62f4d802668a74fcdc964192b7c0a56be29f5c1d1d2289d0d7afd1525f266298367aa6dd8bf9941e01baefb000c8577ba742a0eafa111377aa4f5ac06a039002930e942b87c672fa9152f6990af873cfc69d29704af3d662ba231481d18866e7483438d54fef6993651ad1b0a06adc684f95937fb1da354d74da410d21749e46854bdf02ecff85d5d515718c0f3f56c2a1d6546a1bab97564130f8cd676f6bbb3aad59ec64ffd971f77f4b9c14a6e5ce03f800314cc7f11974aef5f6b0be92a479412876510afee309a32f2e9cd46c055f56f7e90f52fdb385f237ec1435ea5d65dd1a4d9f51b8bf885cb6bba313e6e4dc4efd86ce43870cf733d7f7f0637334cce48a20fbfcaa27daf4d754a9938552369a215c0423eaeb5b92cad8bdd6c9d96cdf82990e5b407c9992e40b9ad027a8d6515f205a3971e02bff7c3f997cf9d4d314b36c6f3a1ab53f23c1b25f0d3fb1e736ad0e228ecbdcab2bfc851edd65ff209c93f5f71206b11ac697598abb891ba3644a9a49a0bac81f1c1d4d2e19b18530117b50f331c203d949477b6034833c9e220424465a3937d70a48949034ad02bd54dd1eaef35dc8ee1eab628c094198b91e950ccea462d411e3c5fb5615f0a688bf42b2ff5b86033d0c6c0fe189acc287affc889fe20d08ddd3afd561595a60689f14c4e01bbda56e14964a90f3f12c5949fcb86074cbac0af3d01465af83cd854edd11d64e77d1a657409580f2b96ba8063f541d3aab543ccdee99925e9d5e44cff47e4320f4fe4b7ec57f57e5b9d6a89456aefa74e20d22222201abcce36568c941963c2666ffbba94963c2090ec0c167aea078917278961e10e21a6c490c38b5b05d74769f719bfe1d374b60f9fddddf56f6bfa121cf2a7b7e0738d89faa1ccb86fece67fc177ce0853bf3af12fdc72a782434893af94bdfbe258efe11dc36f2249d9a3b150d9934a82aeaf1ef1b9f940a6c0582b8d9287e2b86fc6362f3611d3a10adb4cd8f9ad4c7b64511a6b93c39181bbeb5f4022913524de6171b2a47c53617af3173b1d6abc9000c99e5be4a62af046e7ab4a49360b36181e9c94e74bf037525ba4bb6c68b5f755998cd71b7b375c6029501c31f332fb3cbdcad7ca1574343e298fc7095917ce3279992fe1831c2fa811bc5ef8d6312d08b2ca423fdf4017bd7143fe3308cd90d5226011c17b36a65a0deea5723370811ef2333a671c3ca2fa8db62806752c569e17615fe88a4bf2908cc58dec8b2182135b85ced764952c827499dccd764f3d40b4e57edc0e59ff3f98c15a4843548bab33d1692688a82d02444984915cedb1b19358cac12af33d0165d4e7f7cbb23ffbc20573da74d86938ad3fd38eebcd98db4e68cb738824a27916c0c4a924f3f77c16796cf7c35b53af3f325e3f51d845ec2fc85b7be71f647d61ff4943dba5807bb2c09bfbf4f8f8963d4c9a28015be66f09e9f7449b2d7e8e8fa867d42a34b2888e8e58f3c4899956f10c2973f6a09412778e7e39e23b86be4cdf007da139df81dd15cf25e030df48dc6fcc96739e4641c9688b9ed593ab3debdb062e05443646c49b0e5bda590cdc656e0e75376889d6cd6c5f62fde7d060675161abdab8b8ff9dc09c52a682c52fdd940579d264458a2884c3e2793d975790de3c10c343caa4b483f53eb6f16a16d309271e89361d94e63e32cad9acae3f3bb989de3cacefaf4544baf511c920a9444676d3ad2bd00a2567bd60903b1cc7d19b5f1e7440e9b28a26bfbec14ae8935497b3a8c97ba341468b0012d650073c985ff67799f6b31b1c9cda56f5724fc422f72af0e0440da47f6960e87e914d7cff59d5dcbd17de6eb616ce61d093ef63c46bd07e6b1cdd9795deb541791d9e7565991181b469a35836445405952363f301693026aa194544c5df6fe01bf5f523edddd4dc18d1502ad6ab4ec6483883a8dd548784f556122be602e248f14b459384d438438add70b94d9b1ab82882a69209e5b77616d1a4a00861afd4bacf70f4e9c855063273a18fd05d224ef77feb91e75b668cdd65832d1cc6f69167b7eb3e7b3715589ddcbe4c8924ffbe642a0b5595c9022f8e1f2b599e2c43b2f8a3e34bac4a6885438f0e5d529ea1efd004ea4e92b71b8d00755fd3c328757391a8b447e3ad118d47fc439e845db68f0c8c32ad5ba33cfbd9f42e767824d16e22c3c0a794ea06fcf4cbe3e9095de21ae3884ad4f9f6f2d8349524663a59116745ff41363aa39a3f8c095703be35a3ac1d27a8415225209f2b31321929657e4e50645499e5c126c8a4681cd63a276da40ece97082f9133f5ca37eb3b8f8df143130e738f80c7732e1213f241ddcf74dd097e20a0cfb7b344154e61233259761c3476e9c7db3f6766d382d4fb7fbc46ef039442533969a3c65c4eaf34a897b81402b6970647b5c87c99f5afac25fe35217c5f7c268aba9025b7ae53c860be22a917056097d2cb3a4508532523822fa06be267a84adad0f4d76677df7b91538d69e964d6c0078baa78e0269bf9fb0efa10fd603dfd0bf5b887daa4613bff9448d64f6b88c9e5e819dfea5e8f4aa1698987d6284f749df96db06f4b96cd24c29dbef34f12aaf75e67e02a40a1f971e2e49eca6dd1b4bb5e625479f1b3f7cbdbeeda2a80f2f60168f00baf8e7645fdffcfbe5b08c6a66f32d91a40a9501f16f21129f1b53175830ec228fc8eddd67ebfface300179650201989e0c7bd04610c7428d0b5b01b6447200d3c0bb0aae3fa1a1eda000e5c24a53f8aeab381a007670d7842d6744a67fed71d8fec15237db62bab1e0e39617badb1779050b39cfcfa0b6365e6b8655893adef1b80b57387494dbffe61afd58a705a07d3d74c08ebedbef6de5600652775dffc6b1493c3b9a74e97e1de7a5a96c78fb1843c3d25281d44042332e3a4dcc68f74ed9c9da900a73a35cc33395f82ab8aab05c74e7092e69336de427052afc5bba7a66c37901622123b3aa3e5dd12e33625bc24883d853c44e75b0fd86e35c5dc8718edd81644b4a6da6979413b4fda252c26fee65086ae5bf8f09fc38725ee3068df8de122b05d13628ee47cb6a7bdc3ac071b8d4dd563a647e4308a38621dd8e37d369039769307dbb71f0535074758b545836420e4ffad3353aea21d35e79c54d14468d39daa0ba6001fba866041e14f09bfbd332751979d4d4596de78205eb840ab1e2e293b493caea161f921a6d2b6e6275f4a46021eae1e77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
