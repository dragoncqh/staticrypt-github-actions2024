<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37ef9aa41e4c90a123088c5700523074d30c1fd514960def4c2c5a8cc47442d57dc0eb35da41a41f3425abe9e9881826816129c79645ca3810f057e84414b0481c77a138248cdc4870b3fd0bf660ab40b0c97ac87acfa6950ceddcb0ac233cbafae7e4ee6f758662d5a1200834178f78a84ee0cd2dd4dda78928891d6986c78a97f56ae150278fb8d88241d32127a04d914f83030ec7a8dc16b20e65fdc7740f1400eae1ec0d05714be8f2087d06e27d4049b27640fcce127b493aeaa349b05132c3b4b1912c7548f17df4103db79daf040024e232008f847b96febde02b5c2aed13e8dd57ed5d1f904ad084098c92be429afbdc86804a3624bb51022c90f83d69d3d5b5c3ffcb6c04f20851419454d3a855d08046e4241cfc669bcf5176403c22da8abdadc5e99b51ca6789f72b106c1753707aefdcda66b3c52510b0babdc67486fd3a0dfa671b8a1de45450819074fa74adff062ac51f6a2b88e095000b6aaa6143c4bf36b6559907d278a8d87a3e62f05b17aacb3d1891a6bf83f5c3050b76e07c744989388ea54e599fa7080e0bf69b6dd950ba12ac8e8c0e9fcaafdee0a74f2a86c00e9dbfcf89cb5aa0d7ba2bf7c24c610feb3d8b2be9eff0d9fa281908f4d8c2a548c1436cec8e34041e0d104d8110a86c86db456b03d45a570dd9f2c1d6d315d62fcc9e5ce03860d4736e01be972df3fd695e266700fc1fce97129bcc6d2862e51821feea6234f7747a9967a00d0698465d863eb55aece6780ac6ebd0d491fa3eaa84d919fed2964e67a15045dd974e3d7d3334a511fe56dd398b515995bb0f163cf9040d67b745d9fca7047e636138655ae3764e308943d8e93196def6104fa4c688b595afb69a2169fd1e375b7d0f644778563548f308c301face0f2c4ba9573ceb05e6e9ae45ab0cc1702211546a9cebcdfcdb4abcb842448ab3abc5a57efcdffcf5c45015685a146dfbf2184b5d4f1ebd76d816a6f91a09a45de1bb3ddfadf02de51323bd6b0e3909a0779cb6ab419bd3b33368dfb7d86f32df55706c22f1d4b5c3e98486a9de565d801ceadc4816c300fa8aaa516fc07543e9a0c744c580788b62fa4a6058254622517081c1aa7521b3033254d0afcd629ca5dbae4d588405f30b1c2742ea65cad50a1c3c6f478006f08aa394bd4ba451ee65ecd35e087df976cf81f550a7581fe7fe79fb90279d126cc046c87a7e21774957f12091c244b195a770f4bd183a08e62b0682d919ab282c864e75ae853da1bf44f6049faf1c591ba448c27b65743f4bbd92cc2329f18997cf709b9412c2b62f368388f08234d7106286eb9f4f9da23ae1581f4dea4894ada2487aa9f2dea3078e61ac2dccc2ead2bfb9dd4353471559aec972dbdb87d1f534cd6ec5ecd5c673a6a145c12c44910298a4cd668a07556228890f72d5eb23a087d34bad112333b41349472063d8cf441c1f49f756b6b33cfd63f0f8572d64943dd214357a49bdab2f243d762a6f24fdf043d2d54a7cfe8f3b9e76fece16c4d39e2aa9a9d0a298f91c80b1d682c372bd90cc4ac9fba6ab459c917e1dc46d6e427831128419e0a03204a18a66ba191e77ac849810d8c24207252e2bdda6b616f249f82dafe33737c072d2a9f37c156a42328d95fac2c5cfd71ea0822e1f5231f6f96b4529bbce18348f46e33bdb27369df11eaefce53ece56aef7472a9544457a97f46c8217a093291aba6fdb035cdb6b514bd64faf7444b80190a7296498a47e119460ba3e7af234e36189fdaff363edc849673748e8fd3b5dd865109b6aa83cc2e4a018cdc51fc0820bbb6025b7310eb474292f31c3f05045c722fa95736f79ea3423770b6e0ca88faded7f1cf8507fffc3407716404b9edeca8525d63950de45e269efab32793f3f53aafcce7691bd450f8166e43cb54d975692b691d20ec042a443dfa0f4683d8105f6420e508fcb6dc0ddb12348581c98319ffb8be45892c1cb559bceefd36cdabe7cf383f8c9b640f37d742c99bff1711a6c5b03c71d44d3d477db1cbe7d5f3e1e1f4566d759cbfc31df3732559c4c56104c6997356232cfdea34f876aeffe2f07a2c373c61570ece78a7cecddca885e2eda5bdb8e7598d2ca169e38bad4fc87a8fb512a024c58a149c6a1166bbbca7575edac3d2c13a1ebc0b327a5bf3249be1cd7f6ae52b9757cc94c38a07d7f10fa5e18656453d1e187417864d68eb25f0b5c5d2082178ac82494dd9386293450971c584747eac2ea7928bf8231d2c2958d2cef0cbf69903d36eb69f59e9d339c106b7e996aa02276418db8c98be9815d40e5182363752369ee16dcd6e2ced57d0b5aa3d7228beed47b3cd46fabe5449cc8f884fb3196869f6784b99d91354528118d6c0d677ead88d5c4745586deedc373579f3d7a780310dc0fa10d833d13602c4f27c83cdb16fac72f9f996a6cafcb8bedb8e97ba168370a0c8f88a530c22ccd080c8229fbc2d0c4b7495e37cbb68e49636516fb16d35a7f0ca969da6c2593e028ed79051f831a63662bae8866cfe366d0cd5402c1e502103b98235acf4555e83f54b3bfa0702a427abde6de4f38c3c34995bc0862bd64b496dce9cfcd150bfa159f0e691a8796aa4aa2772144d3f531552a1c0cbdb85a7db69d5d0b95eeb52891972fe2db184ce538a6701aa04dc54ade209b74ffad4a5518308d09e3668c88887ea82820c5906dcbe196c788fbc462575bfa13f9e4305a892d85c614b16e97df6346efbbb392f85bb2897e4d009bb5f41749fe38238ceed04f007d0abd6794f8a6aebc03b2b3641d0ada75c5b442b967be2c569d808042cb7919df0d4acf7d669e706b4b5637e4d03d3c4e3a09d501d4189a82f1946e6c4881de2b0926c146854064953c71cae6936a3d311cbb036c61055e07d355785454e6db4da4a3f13da6ec21d670b9d6bd58ddfee42f99e80910fae5e8f57a5d12141859490524e57ddeb51565861f6dba30a483100cb46b803cd9f945201d3534a636fae37dd128dc9e03e74a35f5666c0bb88df9e1e3f60b30c2b04c1247039ec84bdea5c57d789ab71f795a883dda21141663a041aea2a07a5f05eac1415d5b6b7a118c12f8fcd21d2893e83e69b69632f6697ee4626966341dbe0ad1e111f086b2a8c5a2a45212f7199e16ddb847386be0444521b028c4a0ef814719df0b615073603afec2945c9404e8d995c4fc150474aa74e423f1e5174dd5965348a65a62cdcb8ee82bc9b0c531697b8180f2d64d24c0537643c842b78ccf8d47e4cd1d1b6cce506e1a6eddb06723ce2a3a85d3cf4819ceaf1da5d0f3e7b49a0acf14a81c4609e611b2bfa093a4fec98eb96251e7e8813fcf6fb5648452305351f17ae9d98a14eb6cc32a28b5a4546a75759099dc15478ec20ead015cff31cf9d668348700cc5425c54488b32d727eb1382adfd507c99bd07522de157c1416ae5c951d47d42bad3cad74192d46be46f9b2b4d0d7dfd95976bb6a07a259a3d70893c397e885d547a3ab2c947e71924891093053f7702db0c7faac92f74e9cd305622fc20a23067cd4d204429ffe52dbebd4236cc840f8730b870151c2c10e4ac0d72f737cf8df1c54710f25b060ea6e27ac79393a45e77fe7f44d95e35600a0ebd1d84467a347d3c8a16f577e45c5bc06aa75d349fbc402bd7acec5cb7ca240394db8de601fa2bb9e9dbc4385dc765a53550cfec110e170db0332fea08611bd730be5057525388e591634b98f472cca5d0a43bcb3784e28100342a654192b44a05f2dd4eea1b13091bc43d0142884399003ac4e111dea9db54c1061938320540307f959b23d4162a28bda82874c88dbe0b77ee6d642ef481930adf085ce3a643e2e8969261de00440569859251a372d31b1e1f78532ce0a0befdd293068b94c49b1943ca39fe4da2c2ce45ea7a12d6fe0901bf0f1f0dadfe8b31d2b902515ff5d997750d94c134d54b1ae67b82bbfa6543d664081711d745f9e7bec4f24247bc5d4e18608fb1977d4a38ed613e7427a90c95bc79a27febd413918ec35d4018730faeea0a8ffa9b6e235f015e09b5e7614c444a166df9bf87c770312a666398aab4e76b009a6bc5931736145cbba5e1e0d04698765cb15e7d7a5c42cb8da22f38fd587192fb0a9e8bab28de45beb34afae5ec3bc71ecae476badfafaf93d2742862504f08c137a60b05a496c97936f5524a7aa66befe258c18a84a6178914a7818368cb266f9fbcd1bba00f1a63520ff55a83ad2d3f4e156713518dc71fe454244fdebd0a869a14e431b7c174d0dc424ae81494b79bba7b7557c3f1328e1ff1f047283fa652eca4910828a0d59ac8ae1b4a628a74daef4302405f80e3b4bac9689297beae3c9f6235ce51c9dd389791984e280eeae30cabafc3929ecade20b9ccee2611d5ea3be5781c287d48369aa9fc90f2217652f69c7a386ce291701b986ebf49e4615b802d2427c6d89f8e4c1a8838876fd50a20cb79683ae6274f5fd80c68c78f2c3941199c64e3f318a8f81e49587819455f3d44bb1acf994a34d8cd616daeed1b688174a546c146b84b7e06d427f5312070867abb095fe979182ccb3633092f977f74160385614f537db5da29cdfc5f792b7e9267b57d116b6931193d721ce416818afb6c1442108d51545cc5a1a60be81d841207f4a1519d23acc39bbb875e7b2f432c7a3e0cb2f0c291cd3c84ec95fca7eb5ecbe4f4e9bfb151d03a199974b3906969be0b732c22b3d3ca8622e8de1ff32093da2740d7182a519495956c9b61a2caed3ac8e7baaa1ef7a4c81e0ae4ff24007aa9fbe222c2e5620335d465f9b818ab62c0d00c57611e5a64e313c5dcc4f730b2bc95f8dc305ccdf631428619de5141925998f93627d0ec827bcbe87971d90b7de8f1579c594a45c610253a7fd09e8a0ae6ac20bf8add1a8fcad53e9b8e5f9a2d6fea4f8974596831c61eed16937084df0ae7eaa2ed408851fd448cc1ffc09dc142f7d0e96f583384cf8dadeb57770d0a60815398c1bb33725b517bf1bd982914d77a2b64e0053603fe161970e03a21459a3fbc3addf8e74873e70b8f7944494aef7b1766b30d9313af5ea6974e0d1fdaf39977ba0fd66875ccfd5a29cf17d5ca3da9cc9cea5959a8606e7bf64e00678c7cf58bb8a14f3bb8f5d4b87c4a1e858f65ed284d3b20aac318ef626a78e823ad6625a5705ad2c9154a39b7ac18de47fb690b1d4bdb4785feafc4213b4410955e5e1ae1746b4e00a4e2cd017a16bb070b44d8a6aed85fa3ba964ca09661b55848149b700fa5334d33e5a10db0a110d3668a304029fd36ef349c395496ec2447b985e07850a7646d6116018caf3b189f14f05e64f39df8017740d45e7645fb6655d69d0e9e9054aedaab84483eb1a03471e1fe1b2e9147445364bf74ff38e2314ef62ce4142ccbaf8f50b2ca7e2458a5cda0411d2b9f3dcca4eaaed9f0d080ab1c5ca5dc889342600fc80633a40568d7d51ad66ab43e231de47a21dd25e70e015ad60a85c9a80876fe40899c926918f7b6a5f8a1edd9900606293490f14f68df2a9f52d384b932c7efb9921b5428398eb12c78dae6d2810d333d5534aa978ebaba0fdbc0c3f7c3eb1702787be85e7ced36969800c3a876025bc26b7da7b90d2fc882eb690aa2839e208a58ba85895127b3dbf9ebd28a0f11fc0025c63a749fb2d00039b34ec1347d6191d07114957d5686cfe461875ecb6886915053954cc9f02a510cbdbc1d35aa586e1c518d74647de8a85e4b7d89090203d548d8bf8f41041bcdf59068df1cfbbe21740091a56435c18cf0fdf14d7e17af5c158f2bd89f88fb5eb25cb3bbf4d295fe24a5316ca925ca1121e96f2571a13103f25d55fd1e22bb4494e769780726495a901577e9b9a6a37d4e0146e3783e2a6ad8e43517fa6ca9bac4b2bea11956d6b957285b27ec3503b73b13a28f200c4c3d3974ec84eeb1faf8485a0a856bf60bdea217db77f4173fbaa58e147334ba75ac0d6792fa050afabc7fe66d8b5a0abb13c9f3e131a8918d2691c7810de1e713705e6f51a52166fc604c44e8797dd55e637b24521ca924db41f28e44ded17b2c2b1d3960b56c9defa6b9e34f37acb71182c117b128588848500d67fbbef026abecb28df05bf963b25be6d3d5a6f132038cebcc9643e5c3d487cef0fb4915c034035e3a3f21ab538c5e29fa1fbbe0b9cdcbb72b274d7b468233c11ee3f0c58df84c76ab4a9739aa837641457439e347040f4c19113f2762e9596bd63cb5d183db024df8db7d128e339174679f9c88c76f95fd5e4734e18bc7110fc430b0a4a4d8dd1bd867ef79455a00d9c0d0fc74ecb538ad76f9575a9bd9c4f9312b0d9ca066e301f6ce885b2e718ab4aa0d3e8adcd0a0e17e2c432844df931c9c6f2d41a1ae348c3f1f7e57ce2488dca66c2c684c3dccbd7b72a79217540123f82145d27d29233a2674e493ca0c1c8fbe28296329d313513d1ef29ceb983fa0e8ac2bb1f350536012e6636d635dd9c2cbb05673c2863f9004fe89453225595bcf05f437a612045da0efd60b781365010c6d144e9a8e07f4215e90287895b5ea19fb519c34ebed096ef243a0dd5c28b64dc4c78b4b0c1cff0f14f866a87137893d7f8f008367079fc8d461d30bc0b855da1afa91c47310c73015fdeb528dbcb940eb7fce2b944fcc5dd8e703d7ff76f4e52964ca4538ab1a45f0a0e7fd074640f8914010c75f5916c5739f6c54dde0e3c44a941affba9917cbe38ee5d3177ac8797c982f7a633c0c43d59e5ebb3052144efe589366b3c31afd3b1376f7593646967ac08a45d39dccd5f0653b0bd866e580624e1c6624dc97e2355193b2ebec26a55b0c58f9c8da2949689e536c454addc9fa8036b46f76716a382e90af56d72d8428c1f31f6fcaafa625a48b685a464bd1b2b4af2515094d4f4a02fcff6693d810605dd9e2add4303f150a2be0c26c0f3d00722d62c29dc99c6d3b8a5ad0cefcf1c6a64a936b1757f67b165f24388ca05e6c081b68d908cc5eaf8b82ef41caa9dd1a48cc3458b0dc58aac7c84edcdcd2d39352e07fb99c22eba7e67132488591b03fa0ab23d1f1d6ee90cc93b866b8291e966950ba12d87426e0612092b2b03cd80ad0b9dac115abd9934f396fe177fcc755a115051a39e7b1a94663936415e595c85de5d7c8539776242a155c7aae69b6441cf51e5087ef2baabf381012721ffcac69874794d3c7f2ddcbf646a67f5c5458e353f0af5cac3aefc15b2073d08fadfab42c7034944fe5b45a8c1856d20ac0c538e0542832dfa1ed6a5743f9c542d1a1a091fa836b9adb3e07bc9b1c8ff9b6369efbd8f4054c24cf56a982b0940a3f23a7c4904864b0041306b91b54cc55ecf4aaba26e560d0daa0408f5456e494f07b070017c6a680f01e3c55e6da447e655c7a96a34a7575e2e5ba9391c5a43fcf936efa593bfa346e74dee9368ec3fcaa7fc5f10abc854c4c69e678212f37b2202f2728cd8761d9452ecad9935e5db0912573380dac89024aa422eb0f86dae629bd648fa773e32bcfe270ac841b76e2d7cd4b35566b3978f16d7eee242523f01b377fa68aaa37a21429a35dd85d8ab6a9848351166f3d7e00fc47f81549fef9ac49ac71d6e452c16aba2372d6933c88f8de00e829789db198d6d34eb98c4a6bb5bfea65c05b1409cf5500ce3dc6273d4b35bfacd2368aea89b3ecc1f25c8906ba8d989dfee40bb0026b6db885685215256206d17e724a1ca496b3195de3e7748077d3674058712e9b5926d0a4d09f578151632cd812697a82e094d06ddb2ee15ab29b803e6131f763a203275d5c323f513a1a136bf501b27f62aec025eaf28354b1d1abfa64691c1c4b47cb1c63d2131b3ab6fe3f189eec4da51d20bfeb1fe961001deba4f5a6a896ffd12c47aea3749c3675e41e1f90e168b85265543a16d767771c108e8347f92f59b8898245a957423a2090bcecce4f40a3025b8ba576ca6d55816e5df3479a771278ad569732f78b420161bc7dcacee1f87d53b7d6b9c09af1e45700e03cb32b3afdde47536fc1d2ac9ffe98a792cc590b429c7050b416d9d6181da10e2b18935b6ebdd24ab2f586c155dac73f4053da880ba216d81be117c737d0abb92093768636e82254c0ad1920e825bae8fcbf17f24f28ec08ff8ebaac5792d85868471a89592eb1e87df8dc9beb3a20ccdf5a5e41d237258b54b7a8d7abbfce5a99bab92637ce9e17c17a2bbb1acfabe1f104fbdd9e8e1c6df156113e954b5cb5f9f766b24f8a7edb93a717b07700ba5421b70d40e89b3052fa936e81294a5ba21473771f6064a9795562741fcd7051adec2a9c3680abe200319668900be09e71fbdc66176241dfe00cbb97fcd4d5cbe68a6bd5c60a1d48364f871bc6e9bc3bc192e9225e44f924a3717e1f894c8c479186a7ccd64be37e0b0c2a70eae61ab78597d790add2ce008de607de1eae35cf21f403a7932103af8717880add88352ea0675b287644ceb4d40d122d1fdf96635de407687288a556958da80b5e42273184bab073bd7c3af04a81b378a4d9b298ad544909e9ef4b31940c78a2ab37afcfa4ab0b27146f63247baaf768f2f84a98115ecb72c413a043152ad4f0e15b514aa8de0e19efe3fddff7beda98bbf8ad7a2adb12435652a2f5bb82f4c2bb5084589483c3bda255edc688a5ed60973e46a728ead9c10c23ec2ebe7fb01ed0a353956ce32f330f674af9e4b383980b1341888b2410ac74e9c91fb28e6910948ab8cb322bc2bc3e0b9357976a29037048956ece1fec3f73839cbd0a0b9cd9c7cc66d6b804276e9e56c6cce0d0a134c14aade137a55f4137fdea2ce18c7f4c301521a2e9a03e4ffeeb26763688ffe984cc1431ce4401034ac604a6406fb63fe24f47311506fd20fcbe7a836a4fe2a609ca8cf0adf8b98e6675e3d3fdf57fa0711f0711fb88f7acfb377f418672edc4e428589c543e322d978ff86b4532fc251f204f7b364f340ddf21670bae5d903bde53806749d2b6b2d9dbc3e533259f5d7724804f3bb26852d2a2155c69ff02c71d43b758e1fc63c7953069ba559e0cfa04e52e648f1bf6266b48c011de6d86c942dcbe93ad2e836526e2fe4f9cbe9fa1570543e28cd031d5551221130f46b4f2ee58078ef85a1e8e530cbdec657e008a78419c7031d74c0a61437a103884a93d63d095c62665a03b59ee7075e7f48e7d3fc4b7ed3d7e9b0d59742baedd9ce1a200648d0ffd43b9dfb82c8a625b20e792cc647693a6f01906e47a0fe5b2253b9a7f2e90a501fa299960127f19b212469b7d7cd136dd2bf724f0e964c92e18c74a81c67f412d180fdcb3fb459bae11086140575e06ca7d73e2921e94231769d8befa11d387e8f442966ba3bf4a2cc73fb5aea82cc49df54593b7496bcce224a6b90c328432d47bc843267ce90feb510e87f4c1618b1c38ba355b1c2ff5edc34e40a7b95ed5b9fd7aa7f8358e362b7d76202b05c05c870009f754746fc218513abaaad6f82600bd7d05b406a8ed87b43596b2917744eafd6a71db883cbc77c114785dff7d0d61d51d0dcc5b973acc117a3bda86e77389fc3a2cfd712e86f1fd38a57b69502813ef9874fda3f9188f5ccbab936c7ea1c99e2a7cce96163908c38508ed0dc1084af61384c6b2203035e3d352a328c115011e2398f5160a69d3e543a262fc963429f3146f6888706e9e886006d504307a298250ffcd409bece22834bc44bda78253e4a8daf8e197c6623ed0edbe87cc0ec742480f09779f2de5170c6159063b9d0da9f4af7d406835bf311e79f72498896052ef7381aebddcdc147629ce8e63830a4378110d42e645de5602bb7366aef6460405088e8a081c4620e53cdd8b3d43bffbea9f4f69f656287d4e24ecc4046ad1d277409bc030d20a239673d5b2b8e56eb6e93e2a113b67bc882195279857340febd8a46a346900098d1724757254d1cbd31773d4f00defa10194c599ea071b552c5c0407f7ba12dfe7f0bdeb00b6fab24e660e2510a925bad96b16f55150301a6571af28ef17f8d635d5d732eb596de9aa06803901dd8b21a9eb08685dc50a90adf8a9f3cfefe3fc6b0bbf71a356120d8562ec90477bec4259eef163bf69e0b955c90156bcbabc03460d03dc430e7ae5156a9af386a97a90003958e5523c94651bdc0765479433027491ccb7b29a4351d064cf81e26ab97dd92b032bdbefc006c31dec07df9c9da6787b375fa955976da9fb2d3d84161ec0b2d4ccd016051bf3932660c3d67ac5e223843d342c1cf13bd8cfeee29cedc2014ea1a9c12ef538befe9e3199946c2a0d7b8022f4c1a42b537262625bccd8f8517604300634276e98642e5269b21f2e5b3da00446c397b71ef6d65ce93d0a84c820c13a977d8f7e6c537fe9ac6fcc35b4913aaf6a8c9c07d407f7b3064da209f9ecba4b1d49ee73ec53fc389ced93c97f323298f4ac978785effd7637d47d5ed56d25137acd3eff302750adc627af67a603c9bf95c6b7e9ce79822589e58c633c256e03d4e54f629350274fa9f9377e150f6a2d51183e8da80621f237ec3e6068f981105a3773b883ecfe788e6ee8f89aeb93c88bf58b6bf3c9098aa2c588003924cf5e3b4b7de847da4dea3e1029f905909a900ec85db7c5e00ae074fe763e9a8dc57cf535dfb0d22bad806330dc657f5df4385e83169aa5175b65f9b3296bef65e428f0604993f76354d4c80f6fa2ac880c05b1215f9594c12d0bae68b812775ca2e032dcbb67d2e592826b7f08d5b4d163a40c082a759b4972e89c81b4f0986344a485fb57570be7be60b5597cfeec2a54fb197ccf6ccd5cd4132be9d0e1fa71f774387f280f8d2ed3f03c0d05d4be63c31956d4554d5546f538ac5fec13bf0f57c76ef645133b4c30f8d9a1e1a059fad6e1ea20babba3e72540857b8dc60ec2d51c415e44e421e2f939d9bd82ed864c0d01a4d4e1956273acbc695376cac5dafbd3f79a3e704535166a4e6101a29e748ff210ed1a3fa3668f9617ac71eae92a9435278afa94b58094f4181bd51ba34d9b8a9f330d923e1dd322bf4e46099d3bffe307687486c82891753b99938ecd9725a31005153481819d360a94925bb4564d405fa851665c0d2a8931f7111c684006b6190518822803844b074e10d7ca7c0ca58c5f93ec3069cfe433d8ab099689e9636f6a73a6be2d0f48986956661acf1ef550f0c9223271e6df78f946c32b17ffc3d6433607a20d62d8bb4ecef565d376db80fbc98fb48bf4725ea83df93d68740d4072859fd1074377c45b56601a051fb2a209a7646acce3a82469d2771fd638cbf48be1593120a7b5efddae9f937536f451bae55cb74f7fd6d282810a21a15478ae9e5e9af5ed19c799e1c07fae5ea1045786f6254fa1dddecbf8c5ddc5b4425d1a696db4139cfb6464e595bf56b1827c296f9e86d7cb8f6b37055968766b268924a8686414f099a7d5c706aac69e383dad679a33caa7abbdabf52320501e6b99570a27320ccf9b3588648f4ec63beb8432fa8aedf6507be157f65a4fb34094789ba50baec0db524685f52b9acfbd7ee801b49b6cca82014473675e636d1afd5f48e459e0185302a34cb2a7199522c748dba48397d59a5a710afc9f0274a632d655fa574e1322db0eb3480dc7361e5b927a380499d5a96a32e15a781c6e72d1028190cbf443678d6742ae09ed61561b72688e76eb2acbdea0520c671d7f1e94bf7a231cc4715b8e21fe704b1568fc6813c28dd3b46da47863745a11c5a56370ebc3a540295522ea2725b0955ec21d11718ae321991f8f36d2e956ac109e08edb7dbd556e5459d8c9918cd949e7d57daf13058994fbf394e8d8e8e5b12af14eceac8b0b65b25f76645e493e4ce44c459d17acbc5a158bf2f35350a0e5279fc97028eca187305d2f289133ec99a0c22e786f475d36f9ace06faabc0eb3a2ec1fd4c45e92fab43aebdff3dacb25a1238200ce1f63ea5cd99fe607cb685cdacd10cbab042164f1147d5694b6d36597cffe894f3ab32095696287372bc02658a0f893396745db1d9fbf4e8aadd5cced0b38fa07efe854c195378cb645f82d8cc01fc3472f6e97aa542d0c13991fbd94ac130f12b81eecc767c9e7384b2536000117869bea4f06e48a8ec1678fcefbca7d6de70cebbee94f5e2df96c7c785904d73f06c22f1a315deb77f69c2377ceea22f3b2fee451834e9eda046ec91f79d18712acf54e11d239fdbdd7511158ceeca09f0d2c33b0095e05987faff4b49339ee2aa5b8fd3d1ea3a8e4aeb7ca7a2445fb3cc80d20748380b2782ad3a75c646ffed193c119d3e2305e94f817f65b6a73367ee01e3d6b3d470ec24a69a46a64c362a0c777ca62ff97ae68a528b80584b503d1615d41bb8497da22d95e14c82180984089a07322196f5b47266053a2aadbf7164055600bb5affc591ff07f508d784e35f3a4807d519e338de8f87a068ddf0dd7d232525d25c66888254c4c9644e1749d4f8d77980e3a9cd0e7a0b8fa09ca75d0cd47eb038728e9d6e1def2aec88758a41c6ad8672d95857548d9eebd1964d86507f05fbe4d7d51048369e718c0087e9dccf7d562a8d17c414b79fe2aef67ba5d8ff5c73b6cea06f04ff9ceb5145bede808ecab3e4662da77a35bcce1ec2b04cd10ea923703aad2cd4f86ad9cb6761d0a08f204de87afe4c349184c287acab98613961b140ac30b900d5b9fd1f87f65241ae49d804c57ffa3ae46b860877de6e1eb9ee6347a00eef4a4807629d3088739a249526fcc448be120cfaa2cf71ca1e801f0da5dabc95c02e369c32394ba2582eea9373e283e04d6edbfd08c9ed861671dccb5ac8cde469616334e82ec117c8d6fac036439f1b855a45b18fb48041d0a72d43087a67e1b7f0cee1e22d7bf003c1b24081bc4847d7ca1a35b826bf71d7f9f049ffdcd904a8c6ebf650b014c05c6a0a11d8a30d85f4bbdd90c39307e4137844bc58165498e6af3d1898b5ed725452766dc3b79d53895f554a8c770fdfa20778fa1aee85985f0c26225041a149d581987f7b887990b0431a56acd815c20b2ce57cc8b23b59ba45a0c3e54f3174fb6e6e17f4a0c68969d05ee8de457a69c023586a1facbff4afcb4147c76c18def6aca5d0b56f39d6c289860343cb4357744b166791bd7fb05a461f201d2fd00de32f35ed51a03b83a9edfb90d641866a0c25f11e1e683d47c339993fe60a723393bcd94de7c8ac35d547ff2127cdb3005314fe3b0fd267337413dc862b5a603dc9dff3efffc4f85429bb231160c9f74d6f30f867b5445e641c5a9218eb0285e70b57b79aa81631dae282d61cf6c99f2b3e66b00774f7fd6c2f0517dec41095525bdfb4bcacc9dac9953a390f3f9b0ecaf57850a4b3ba3f112cb5180f4fe53bffc206fb786f9c725b608a2cc0cc06b3cfdfd05f79f548b2dd22bf9a127eaff5843c37fd5c2f1c3156dfacad5449746c79eef645fb89c3acb6e303b575832f88bcf1a274d6ae7919c718b94ef3f1b6e0bc31df924bdf894fd678e0b2cadd1fcd358afe582fd81b805d0ee04172152bd4509610bf208c37b2a279e5cd6d69df321ab4bf88c8e72d4ef3017b84fe1c30f4da8230754264f932edeb2f636d35b85226a0ce8d84805518452783c49c625df960b1fc38ef8f75e4ba235c6bcc462f2f559c46b2ba22bb76fa4b1646ef22ef0c80a77272f487d8858c3d2d2d6b7c02dc68534b14b38dc81833decbb6e741204a1098b88d5d3cde747eaf2b25545dc7b9e2f50ba31a726a90c540f6b08fcc5514a1e2a24a2aef7e4445bcbbf5b363fa9802554da958e3c7b277cdd2f2a5bd7c09a05f0b7392393d88471f5b3e3828c6a177fe1f93dfda243df897e6f53f99ad543ab1ec9c54047f503bf9d2bfc631defc215578dc265cf4e26f401e6bc4640f02ccb124f22c173b1aad927f12bc28829cf103659ac3a486ef4f2e6f99c5935b41b2d46398c93b97824582baf9f1ee7ed32fc5f5c783c80ec0e7017542e1ec9d49e4772d2a04fbaa3710e96ea7538247a5b53724f3b73a7c2456dd0df1cce6064268c6058c8ff411b5fd9f477e2576a68bc1dab1f64fb19a4cd5edc4225010f683054105015b6c0b0cddc1b3eed198e77be56f5f08ae8ccffff6eab700efb201a0e32933be35920e300c13ca84a4a5dade0e7bdc5bc1f5ef6d0ef8eb9df275dddddfb034fbb77b08d66c44adee1592122f20aea691f90311e0f5c62ff118b9c9bb0c8ad4d8ab4978af7de55913b2566a556b204a289f6f0f7f487b1778b68553aa28392383bda5bb10d69ce164a342ee99065b40ef2a54ab235cc47c758698fc9652aa4a65eeb6a89b584d2ee9bd5685ecb3e09eecba757de0f702f659addaf992eb590340cfad579ace3dfa8b594875fe1b61077306d6be8c72c3dbda859a0066fa95c69c829b9a04ca31122779cd92824990e8ba26c7f8b0d0e411c065ac13deddda0ba59641171ece45a38318e3c73a685a3c9aad0644bcaeefe1cc9ab089c556ba648901f95097463ad869c7c62d7502aa36e5fae8ea482e23f72842876eb63dece6cf484c69ce64da1439ea75799c306c4578eb17bea497cbed4f1a46e958291f7c2b9bd5220210f3343f2874c76abeea1300cf96b59893a8e68e110cb67036eb895c18057c6d445451c3351ee5274043b4d4cc487b8d6ebdb2f065e7fdc5ae7060da5dfd97966bcb208c331cdf36c6dbf8596a7c37641207c60dcd0e6a37be44fbd0fcea296fb75a630af44cc90fbc3114ec2aed89398bf5b8e1c41f32c694667b3a6cc1cd4dc99d27c847ac63baea9b2d425b3bf7b24d605421271617e46033341c8a8d5efc7fbcd044f3c199eb1a282123311bb878f18ff1ba1898987816de6cdad3e170cb997515669c206bb5307b3c57b52e00adc03c6200b0326ac87b14f807fb3eb5ac7c03fdbf9c942548554047a250cf23f54a92039336cdead86bee956d15e86e2b8241fabb447f41675b90beeea5eb11060ebc9164f302a9625f2d48c7a81fdc8814bb22e71d83d22b9bd51f10450722accf96fcd81b887d3437d616bf91eb6e94857a9365e329e83d19d70934211ed5bec48036faf56305c2132132af6da4ff33a050662ee0410a6233701c1af69dda256027e10fac4b95e62d3ce36a849cede6566200a74f3447b3dacfde174092731aba606533682d1bc155858a8bc74f383136e4a19838307b1ad63e4a50afb086e2d819351a6da577c46775474690100964ea137ca3ea0d78832b7b54e6ffab158be7e06182a7e24aee7c1b16eb2313177e83c692f9ded1932217b7f4c0680475b205e2e00abb7b3d114f8f1593721c2c8c898c7f56decf7aa6ae836259da7bfef4080be832ae825a9a0bce175e4bf37335d5e7caf88135078e7c4250600c67a7ffe6c12196800426bfd07439588a0ec414af1889c5a43f8568da30f148e735005c51040705933448e3a65af85971cdebcdac6e64885ea07e1c3b7e7f47cdb6d14147f600810a86a1268179ffc62ea511b30cf71fee84501a1a4984118fe741cb3d0a704e9dc17d812c8eaea825e8ec6962600fe726e3ec3f512336c892c42dcf25e8930ae81d9c4d882c3a1b55885b65015d99f2f830a106044b45ed598508b24607c749b8fc67b49fad34e523380ad0aec7cd2116f2fcfbcb522e7c72f72b3a5b8dedbc7d4ced1b538202196d263f585720c98f9e9009cfa97886f350240b1c603a495c5b1ae754551ec011d71f747208bb1e32000cba4cbe4dd854d8d79039d509d69ae1c47104e65f18a2d90a236bbfbc8beb7d20243227aa094c6e1f18153a2782ab71bdeb225244a33125da895c032f8fca38bdc88291c9cf6ee001547adc4b90b85d153a0e90c3218b12f634d3b60e70543cde64fea2a0a425c41bdc274a3f3aa80b6201d4229674901732e88528fdd565ed0d4c407e43e73a046b3b0c2e74064f2beb44109f6e37da3e41392c6a705e215f36348742dfe8aa5377273a0bc0965ea44cc933b11db181b41d9ff7c0750295bf8c9188c0473cb8c9bb1e9b624b29cd386988a736069b58bd739278eadff251dd604c4c0fe2ee7da153b9d56aa7892c777e4d4ee6a595d211600ee8375ff754cb17396607b37c999c631adbdc9f6f9fcca4cf913426522094a1230e2eb9fd889b02d9d4d3d7eb6a783e800d75bf39db53bac5358317a1d12cd588b1007a3b4fc3fb286516d87f985550988442a47334bb428bcb6ab3b39934f5d4b5b3f005b98d86a15fbfaadfa5860cbb70c55f58205fe326874adfbf2a5dc5e3b69b2ef9789584909bdea3ff81c296af9e990ce8b0d60d76cfa4122073793340b1dba2eb0dfba11580de8940ab156446508867fa7c49d54c9ef0945b1b3f6295d21403fb81bac0159b619814947f8903553c78ad6a693380ed290f44ad335dd2f58f722280ba17cb7a58ae18bdf8d2ebb51d3bdd1ea30f72564febbb5da61e219b0219b44642a7885a40170a1dabb658608275de2cb0d11b9b45e982069ee7f176c8dd396856a863c740fe052da773873e4d55cac2f022deb9acc38d1b4954956056f5b02d32e5544929573ccdbb0f25efd58b5ac939e8876844ed5cd79f67034bbb943bb03ec76c91ff6087346685cc7fe8090d8ea78862f7726e8f60176039b21d8b00924ec57c847b59d4bd69e84d0b97bafd026164bdfb0a972135d6535d60860781aefba29a1879b57991a2d1c42619afe466089d969fae73cb4eeb1107fea371b0a17004c5340a810cf7465e1fbccf32f2382ee8355158767d1465c765bf253eb76825eda959a9132cd02a59cb545290abafb90eeb2542bbf98101c2f59b52b362659837cfe8eddf5468597161686124c0c8b526d1973c5cde222f1da6835d25a99293de5b91aa70f81f02cdd36b614bc13374bea575bf3dffe52cb53ecc75c4a25ca9130ebfdc61e1f16ea2c20f889cc5cf3b70b2c243faaa5e96a93435ce31de16339a3263464f297de81f3a33c5f57875952a4eac1819f9576201189a3258fc8338209b932f44043ea6a2c9a00f2dd1ae9e012da43589ad1cb7d04686a0b08c85692f9d57e92606c63ed8f9dbb3d23e6b93accaf4cb9d8111d7cfd99f9ea87f3425b9a0e0a0c78c88926895ec1ee66ba2748bbb58e235ad791357621d4e0bb35be476f9f50772341e404b35c0d46e4bbeb40d9820125084a0d4de9ad2b0cd2245205a5f6c76133bd8aecf4d439198c730e1c6229f92a2996d8d93b5324c0ba97aa7bc65c4e351684eba2118f6f92e7dd80289ec58c4b871d5542c1e2a0396d524fefc3d0b2e0af9cb9f6434d57724875121b0d8f7d00b089ce6a7b8892b93a30b5a39a2729e78369b037b5b4f4a4fa7b60720f0b70a7178bf5742b9704be0c2bc90fbd3ef6dc8ecb33211eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
