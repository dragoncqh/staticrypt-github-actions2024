<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e13a06a8d9f8e4fe7c9372ee036aae4c0b472f4803003e7646bccd0651ac00fd1781d701a8a81a57282936136c8a57a3c10892ff496176e5e2d651ab2daf598007ce017a4f3db4713bab75c6c3497a8d92532d79811398164768290c23970de483be84019bb55b1a6e763aa4c14551b36ec015a21b0c0c15602cf01d57d2490e270941bd295f8f6eb3e908c8e983c8bc84061af2a9310f227e8abd5e7b6459fef8fb3830adef44bcaf3fc594d261ecd1fcdd65a4569651412a3e76e67b7f336cbd05b36a7e64ecfd716168db71d650adc740f18dd60e632c13748c7b5a356c7632cd80351272511feb1021d6f2ad5bfde07e22cd07fd43328049f19895fee0c84f442527fab15fe3cfab1e02b51f930cd48de23bb0ff91a3a92834c4087da555b7212ec5fe80de949a44b786bae87e0ceba53ad14f55b827cdd33ba1cd7324f1b8dc3ee299da9a7d0fc43634450b7004292981476d31db5bd49dacd3a71e0eca78553e3b3f3da097b52584a3c4f4a9c8ddb3907515c453c2ba03b5ab0aaae7d0729da349e263969b245d9d0af63b3b90d8fd31ddd819a77cc786f385c9b592a8913111b8b503da3d0f86b5b733a4ddcb181921ff32ae95624f34c4d2cfd33ec417a97d06ed70c76afdc8c421180b85948a9504092fddf79d49268d9a2946cffd1ea1dac62dfa105c3af1bba4ab745970a64aec38b0cdf472039a5f7ec0a972c6f51cf61987f0134be8fb1333d490e4305752ebdda37b12742b42fcffc845d6632088aa2b5749d353687bd8d402315233efe3b70a51398f7ce9f58f6e241348b2a36c303db358dca56c7a5e5483ee1244741d0773ca92345ff58ff10fdc4ac7b7d35f3df38f40968e4daf4f57b6bd0e1416f7e7c3db4bd6e78b255d84a80f5b09855eca4d8e962e8bead3e566365dd8d4d422efdfff9d01c6c659f0a5d2d81d539caf48564486b36c750af838a27dcd5d0dbe38240eb902c463cddf091fc1187a88928621c52f6f1d2f44234e81f9e1066a3392e31c7a54570e59845ee9b0397305232acf7ce5b0d2f1dd4cd0927d663a352ca1b4ddf25278df46401be6684c4cfa31a17134770dc26aa76d981c862299a5c0bb067eecb42538d6708c3fd045b3c72952ffdd58a9e1e56ea024d3e44a70ea95a3b94d243c02962a8b167d10d74112ae9fa1e96768d5a7b609455144382aecff2c6e7734a55c5fb4b748cb88fc8e8d19862a88afa1131b448360e927e35766f6874dcb8919930a980b8c3c1a189f12f3ac64cfb608ba1807d6b88506bea2e200eb8d5ae50fce1ac87fdd2955d0100797fb8454b977345f81bb87a420e091ad0c39d13ea0a6164fcc42499554b0da3a5b630744b4c4b1e1ec06d109247850b0613fa808907a93c18cd8937e1c73ae701cc5677c2271ea3a434c6a7d7baac40d0d4c1d07e17dbfbe959716c40e7b79a99a344b06f7c93b27b99693a64433c32d5581c155cdf3e78d411e106d46cf23862faad7b4d771b763446e9135813526466113f889c13325b47e07f9b1af14a10f324cbf96c8770721892701079f1554269f77c616ca5e99871f0b1a1a0dd0282e0b3fe76b4907f984fbbcaec29b947716a5d1a95a821b58fdf0399d9a2ea38ab820486f06524e8df6320dff390d26248f0cdce1da77e00f12e281a6d2b43b94a22164d1306ceffeee6a48a090c681ff8ba7824aabc88f44f1c3a4f52ff2dd9e84f2839653d9f45d29e3adb618100275dd70f60f0c6d6450447d7400c2f04cbc774e65b72cb7dc472c9921c13db204de91ab4c513062bbbe2716b1b98790294f7151c9739ee143646dd76aa633750027da2db50c676e0e60566f0ddd35705ef5ee46739969aad97ce42382d06e69ae89d74ff4fe670fdbb8764321157a10233a7201eb8bcb1144427001242fabddce8e55522a9c172ac2dfadd7f1effc6516c38ad153404bbdae883a00e70fdf552a28b8604d975d2b448cbac8a44cfc26f7a08cdc74ed13e92b7b8a511ae3bfdc4cf551d1c2cbc3adf15b0adbf928503452c8d86d35be87d4b99d5026c9167b1b52ed83c57718b18e958ecd1936c2f7a3db139a42b55db1e8c89d361c29966180b75f29276c99c8dff5295920a0d4c56287162eabc17ac42219dbe5df98f2ff4b544ba730bd4735d21ef26ebd87653536c49cd29b5b63b5386b3e920c4ca04845236ba479ef0c90ca08c1b058920f18505ce3d8e3bd3b6c2f0c3ac0cf672850f7d55fcfa29a88498768302468c5d388d759965745c89eaac2f8c200c2316e64373d349e5196bca75f987743beabe2261f538e0d350e0e9e72cc6bd2473cf0208e38876220646007b04f002cf05e9461219e797779c7c2a70d3100c0ee4c84b7c618fe4dbcaf37a838dd4da842ae403ba8ce3e8911af656c4800e3da554200279ce94064d91646efe82e876ee55b7784a5ff7f1218d2278961175ca09c5808acc7345fc63aa6e61f07f3dec883150b5909540a5211d113a7f151fb0c2dbaea0a09fee1f192b16b0a9924c60fdd0c723f94f2badb0b4e2971a358e4e52e4e88a7790e6399335babc493d007f910cd72122d44df098503247a8259227a44438811e72836d4682624d01883e22fc3cda7cccf3963fa3f580028052985ec24042bbd0f737bb86b21e8df2c16743b4853726d7617991d0a351b7f5f41a1f412abba174198656b7ea79ec976e3fcfb27f6ac8a559314c9702ba1793ad5d6229675ccec27c7db33d538d6404c27027d1406b2b417215fd719db5735b6aa01eba001c807dd40a59b73e44d99048c2b164973cd833812e5c7318826062219c1fc9d55285b2865a1685abc694b575f4a01022a92e22aa2102cff39ec67888279f14881e4a539b5fe7be42a59923de48462a915acec90d2310671dceca76e23da9f239e4d895fc022c75ead10bf6be4b11b3f649c1f8cf63ff95923df74a83575806269b01affcaf8b83a2666887960931dc6c2af7e377888e925862aa1cc02e963b99d906c5bed57a0b29b8c8d37265f8ec39914a66b80eebda5b10e17f4657d3b566914df64c20bea82388fe372198d876d504a23103e2d723e4f2db2b17bb4b7a7fb1a27936a46ec4bfee08dda8aeaf7f7ff899d5501ebcdd60b2a9ff746a160286f4790a81a354e940bd92c110799844fd5eae58e19bcefa2756f46b0a4aa14f0ca131c3ecdb6056986615c3e7296cc56c1d40ac0085efe1b3e58ded5e0ec9b9eea330b9036f6958dacfa21e036d65e7052314ea0a5aeda0b44775b66fc77e1c56e4a8de3b507e136dab370f64f3a7ed62f7c9c5f9e2e1d83fbfc57a708ec46cc873ea0a347da89818a5af554287d517ef67e7c7b8d1c93cd89dd445e518ed0fc460eb420c66d8eea9f5ef476bf4488f2a0f0b8fe0479d06e26311cf4f71c7a0535bb38541d2d61ce16624e72f9419a5faadfd3d5211f94a59b26a753bc0cdafd327ac4084cda33cc76285279a9c58799bac7fb6846f535ad50fbd5a77ddbbe4cb1c0807767b2747450cf56c29864558d7ee8f1d21a71d5f9019765c87079a2d42da1e4c8eb54c240f1477c492076c7098841c4e2516bcf4501f0659ec8ab82c2e3a2c94c109231fc0a88a95adb0a31fe58d2c2b94b511a0a0aaa4fe978269f96e66dfc5db1f06fcd9ff52d4991df7de3222096726f6ff835161c20be078e3a0560f3360ba65bba9d45713abd0016bb8bee7e7e8c7ac5ce4c8cad692e04c49f6f08e5e60aeec6192543be5c4f718a34ad7e06161e188df35d09cf5079e9ccd56ec024bd56f254eb697ddc198162ecf74cc05e7282d530b2c63b34f55ea08261fcb7548b2ff1dde07d2910687dfb8de45b78d6fb9ac3ed7a0ffe907959b7ba370981f2450ecf8f6cb7172c585a23dc6327682ea33542e7e77634830b1fdc1b292e239bf2bd9484be585133c7eb34445fc4fe5e97cb959b52651b9dd1da2ff9691846660a99c4c6372eadacf416363397518f25a1aaccc71f9f003ac75fc75f7809af9774191b1478ce259dae000d992146fab8553d5fad3d4673611def218510a0b6871556a7a5fc1d5b65e187c45bd93a5a63f7173c78a4239fccca918bfd149b9bd66902f921a736b52b2cd603ccf1f9bf611c3ac6aa597b00ea2950ed0d4c490b5c29f111abbb68d2d9303280a136f98cb9079d1ecfa5c400e01e45fd4fdd322670b50b8efb35ef99d59e699ce48a8c4358327b6c883e08ea82df5e43748b6294c942baa51348fd0c1d2b43884fd32ac75e9a2840358a1daa1b53ad394fe4a855308fa39e50c6a01ad409a8ce391ea53d84dc143ef56b978289a9adcc56b498d1be05f560cbcccf8a3559165f92d2ced4660888c02747d7da2b2f9d2b131a56845a52e7fbb1aab8882b7f9c5421311dbae11926d16c2a8a6a8ee9f0cb856eabdb0e18e07eef78152c72f5cd64454bef995f29921a9dc316189a60ff166bbc0c6a4d4865513fd88a0e6ce1cbf4d427a0c6a6f71c751c43caa0712f194530bc52363d5117493b673b53dd5631519cc8925488a46c7d07ff8727c488eda3a19e041bb5ed60b870f5e894c57936418f3b32be56cead20c78c4450d2058b89ed7bc9f2d3d47f3be0666718b3d74f2c105ee3f5d77d479341cf273e18329f0476cfb4836a0b5f168e011735b137e54f03cea77a783e7e94f9841453ae3ccb34881683b1ffe127f19533492ed49d62081a87684411b9becfcaa5374d70eead7400d85b021a351d0b312bb65ec50783655785daa3c71306dd60fed519a42710af13bcbcf01a3ee435eba4f46059deca771801ee2a188be5228a3956e0c6578cbaef02e252d930470ada051e1e47570c8fd71bc697e34c9d6ad199d3f90c91ce7d8a2e2848a009b0ed41baec0c9fc293b4e6f094493d8237ac44bb0ad907896f5fc7081d78d1df6a4962c645301edcc37095e23e20b460ca96a20ae54680bbd42d072d690de7b2d9d8fdbb5810737e39c349a53b09b987f1962f3226902f00e2386cd5fa67d64b1221627d0fe66368e71254247f2be3dd6073fcae617ea567483596e08e736ed14c798c2c2e6f45492f929642791f430abe737936ac38b1ac3872d33ca5e39f5d5f5aa09695a8b29f94488940e2a6238b055e00ed11d48fc22bd6455688d5c307f99e70ffa3ebd1444c96aea40dfe5b687a81bbe7bcdd5dfb4863d8425ee8087416195d6581ba9b8b692b102a2f5eec0f22c4ecde36d822a5a385f2fc7eb6a69b081646e28cb2399cc19b2fd6412d6306957df0fabf8006926e2c6e45f5cad4065e1a2065a5ecd4587f5077b06335ad823377aa0b855982f2d8358ed8220fe30163993d98b3820b33545319702a86ca44214e7c90b9d44f44e8fe1de5d68936c072bc2f42bbd92b65e6048a43016f7d576fc9a3cad2e5a5cb22ffecc1af4bee6642ff902b5ede11c766ca260c232dc067f49f449b32c7bfb54f1864028114114c4ff59393df90e46dd862cfd2ef64efdf4b0aa0174467a79fc33f143e82fbf75e65d3585d6158e43d85b87f237df79f8632710f9f8e5872d0512c1786f459a560fb1400abf58d95b0a592610bc5df0df3aea0f88c484c65bf0bc6d4a846014cfbf4ceb9345a7a88e86e4847bf15c777b444ed82640c3e373c0648b0918bbec999f63c444bae716d1bd43141fabb6ab52f67436b382f834ad6bcd1c5f0be92879d65c1dea2cf6e84ca231add8cd73539b7da730857054d41ebf37fc1db2adfc8fe6632a5c2d21d2b0ff0b9e29f67c6d9b6053e4c992a1cf39f4ff8ff949ffe1bb2ae4bd3d87df49cbf277b318deb2606849de7ae05815a2de67284b10d6c6e57e7c9228f095b8dd1f5847f8a57242d89107016e66edba2b196cffa7c3a1af59b6a94e29918f1dff3d0798f7fa530ec098e91b693f56697e91e16a1ec2aee6a2174ed27119adca2c3359ec405b07cbe699dd2c95435f04c480f0608fd4a7a512137427a44822fc4ffe54eb65a4724ba65db87196614ee26cae2f8a285d9acc59840784555f15db0bb5701c800b67d1eb057d14cce3f2529650453d55417939cdbc023b77c587aabb7fe027484392ace59c5619f71a543fe7375aa79b3f8a10f658dea58cf544668000876ad3f7788da62156af92a0005284b1d740c5fb2636ed696252069e2da9319cfbb3f28a49af846ffd025f8139fb8524c636d97be9d4dee286f04b586597532b607f4cae56ab18df7d00aaca10f0de34f6d055fa8283ad74ef31a4811352b91dabc0a34ff26dc6bc14523c82193b057b15dfea26a21ebb144032037d170a6f7931e0c1e4e42aea126ab65ddfb3e5582a542797702af1c094f708084ce3e7a3c40045788fb3128d07578ff82f62fb3e075ac318ff2de56e047d96e23a367fe8e2f1f6e90bc90d5073539b8cd97a2a781d0aa4fc1e06e6bc174d451c48b7d09bc2d30d14097ac0f058f7e9a9e894e0cd32493609aac9f6ec06e537659bab1bdb1a40e4269c73ab4fd8c7ac3a39aefa5708e05df0a0b0e3a7bab2f1f02e0dc62fec00addd24b425fb747a4cff4c3aed3bdecd9ee52e4a2b634cb22315780b48c3213cf16533019a471f214077758d9814df3706fac875177538ef5d148994677527fbf0b5c11b108791b63ff2220307d19893c2841da0c87efb009fccad6f82a5ca62867b9ca9d794f234a6d42cce33f0101881a6ced10ab0edca53b0fd391d1ef44537af4025e859ccc2f1c59c2edf2f9944ab167c91e7bd84c9dae0cdbb855107de1c5854e7b9f49eab57e1d7ef4d78c0595bdcf19a41c723cf063c62a08cd4c32e616a0bf5cbde5eda98d219d874d7415cf1b5bee522cf7e993b2f7a78f45e7a33c953f6c538e65d77f6f1c0244f16eb3454ee15341b5d931b67ee93b66db88d3002cb535563b70863bf9e8bb66005ed26600f9df2a02cfdee6d3329c134c3ef9be7b13be8a5e4c9a5765a4ec76b979dafd864c2df3be69a58b660616e3029ec71c8e39582a57f65a5aa2086585fb7249252f2fc744c996355747921eff38a1d391d785e07c62c6c83bb2bd3b0ed6dfac1d1d9a81a4afdec98466e2e27542b21ec91fce1eb0886cc28b2d94b057cb327a03f38dc28a38437a8f01845ee4d70fb277695d52d1ea74378c37670ea736cec55ceb0797266692b5e929fa877c286087dcdbba5ca0ae02fa859c75fc5dd451b0535f427ea25d69211cba95518f32c89e91f9be1b742767c835da15e5be776f83d346a13f3d6c518f1c17f2a4c5e1125350cc5ec2ef998222d45908decc1ddca8a6af4e2887e43396f2670e2ed9a0422c8b20acc68c0380fbd4e020f6ac012ec7efd910f1c750b858b597b69ddcf4afba77f931356da8382b1ef4269108c391ab168884b28256747167438f639a47d7c9a5e0e159b31555ecaee6e080f82919abdb80dce27aa04e9ae99762fb1c2157e30922a1add38b8e2417bfa32cbfd293b6e29cb28aa94f4054b2a6f57581c4ce54662104a00063aaa1e8d8d2c70c5eb40c622f5f8a9eec7d19ddc6410642b2c2f441f31d21165b3706183e256289d747fc4e210c7553eb80652f0c58d1bd39018378a6dde71bbb3e631ab0fa5f19be110d4e30cfa7fe2bbd594c3bd1ea258a2c36911ad078efb03dec98ad8731d00639e94da73e212cfb36e8a563cac21a7e7a79aa1ef25d8c6533284e494ce1dc595369cb0db0b0240acecc55fca82d1a1b5fb495570f0bbc1713ee76ff29c4432612f5a58305a1ba0c266b5be0ee1daf5f4724d57a0f8ee206bbcce5733a11ca9fd0666f5ec92db5673695df37399ffbae8c3617acb237c15ba876531cb9c7b16e8d905e3f3e6388f30cd36842566d91ea8a079fce03b9284198434077ff7391fb26ab80e56532f6cb1cfd8f4a0ba657b24beb882c7e25f73f19b56f861d0f95d37a3a35e456c7751ea31a8f7b14890ea30860e782cde0f373f0e11d9c939fee4a920e970235b410f4a3076382157372642d43b75805de06353181251b339e6430995a318b16f0c09b4b01ac495d02bac0b6b6ba2614c2b74b5c0039c45530d38b14b604b762a2abf1ec24d884164b0ad5eaffa380d82f9ba2389f9a4a9eb6743f42caaa15d2d06a6070bb9a95d6f1ef94848d341d41d79883015ea98c675faf43ba676d8a1404ed2c4cd6b5abb9cac62c9024f859ab0cbbb2bdc360fd6ff2e78a7004555256191da7cfc859336967a21f6afffbd72c7ef9c1542fb3937518f896a0931b352bf039c85922df04a86564e463f00fcd197b6d317603db46008e89438699dddcc43f038b540330372676cfa31b1986257f5d815a9e844cb85d877b2354df9e4a2b5f59022e6c1bbd0df32db6837fbe6f0380bd15486f8c33372e35122f36eae72e545f095140632fd9af20a18afae52873a345cc28a60e8546a767bd40e6d02bc2bcf74c086abe1d9e7e3997b843a955037044a8b7c3b17b88ed39b407434c818d66a2724e73992b433f3c9845f85b77219d9df1d2ca69bd78472a9a702265f91f675d92c041570356ecf0c007c127fb2125ef98b1b14e8214e6e8c5f84f3bed0edf766b2f22fd0c40881ef5ba0ba2e8fcb1f404393b7bead3f3e394c4aa30ac9236634d2003aa18975b0abc1a79a746ca2e9af1199927f351139b0c6ac3a8a49355dfea971c64a87bd39ac10fdcd85d9081c42e38846263ec257b55e0a9ab4b5e1c4550d83e16beffefa5a27408563803658ae2a74dd87d35f9145762bfc51758c65e3bf0a6563ef8790f4eb1e4e61c0f72bb81cc2aace333c65da7ad923e9f43ac2da755a25e01ffe7bb4f7446f071ce1fad0b1cb4a6c7f260ede6fc737fc6d0fe291fd8ecd91f1f1278ac12fa9afc9f6c1b379d978ee1e5787295591e992da70145bbf3443c50288e31ae1da9cf38bd9d9b8d25021fb24c7b5c506d5f0ec0c9c46057fc385bc92a58ae0606d5ed0647ea0dd2987866838fa17fbfbc069f5971abac27bd0649cd29fafae08d6d6138c74fa1b9828719c488aa7e69a2253e19a4d4d157403d2ec8c10e9703533fa7164f3c6c30fd5b2032c9bb8779993c7ba63b17fecffcfdb365954b217dc5ea2793a89ff7b2270bf44a7c4b53403a508baa96ffeffc0fe7e92f05feaa3f0db296a66dffd69935fa146158b943bdf775f8842dd34ea6370069bbbde81c36a99cf6651f714b3a2950d41e4c1937f4d3b0f1c733e44e061ad82da69bd9fd7f951c8b418da838deeb1ea6661edab4a8ac4c568109c27b6a82c2e8dfa50f5ffda9be9cf664d0a9ca835d9cbe14f690be46ac3e8efeb1732c04e237b827a39a8de13179342fb0e86d6ea71f1e425bb0437a17954c30c6d5f2dd137edf1a929d3914a3826d6e9554f6335642f6c25504b0d5988e845d9b3123e1e9f9a7ad8792bef6cc3ec1343240361ea9f0082f591e7578a659c4038d8d9adb954d29c08b2c891895749f4b471ee1c22da65cbd9c66c50def00349887e2f71da6a8020829fb99b074e3d19dd1fe7266e1b324830a3210e7f12c7a1fad3947ac39c7b9521e1e841c685c8836f0628cb33878d511f9fac3b5ffb36edf80770115061a80af08d2f483c597c5e8fef0d0237ce3701383b8b62fdf3ed73f3fcb3ab91ce4f661fc576da80e70e2385ad481dcd5c3808caf2f5baa68229c4f78a97bd70528a6e88a924207e83c08afc8201a1582fd819a6aec156ee9570e7243da3c5e479c2dad230c4dbe079e0a92c9dabb9db7284b3da4e86af1b70c434a8e7b73e0ee0f15074d15e423af6479423f0559a5c2de21a81b333725e757358243c1b5b1d1fc81423e544cd3f03ade1f0152fb0911afa89e4a7ba5296a36f6c44f09cc0d1cc794d5f9705121df6b9bf344f8ce7b86b4e5f2c8d517bf222d587b2bd9708e41366572d18de2ee49a089d8b1cb2b23cb7362f605d583422a337221dff07b3a64bae54283182737804b83cec019ae4558ff85a6725265d0f5067962eec3e9002d2a52b47569407636257ed47fb6224d7b1a71fb3b3c31b19118a6dab92537bc8e401a2f2a976aa08e74912d522a42521366ca30bf6379651f0932a5f4314993c5cb449259eca96a2a3f41afa60bb062e634e793aeb2cefdd4a09cb7a67a7eb17a08fd5c3254c6b85d47d758302fee627239823928768e6f14d9cd79919c49c723f91d8deb703ae9079129499d3c1b17e9901ac4b7a421bfb909a95980242d4872756e2ee69b401193420ae8c168b655aa180360e05778f1dbe73704408c067b27227b8f1c56cd464bf2a35fac2bf3fdf2bb3fba0b1c26209fdf90d69183e7547701a4e1f3ca8bab274df9bfa46de674ce165bb9a2f88ce52f676be494a5eb547b95c9cc43bb805cafe4b637b9c7928bfa01b635cc7b9f501c1220f3dbccde3c3166074f4bef8c6c9483e12f7066071883f1c48d10f3d67142376ad62e0e2f72f9002c909cf67c289f4ab8aba3b2e099f73cf7efbc1b516fa9e8bb7e8dbb0c29c078eb040cfd8f8751ff69f67d24babba1eb268f2fa6ffb38ef11ce599bcf8b66ec035ad2568b5b875f9f3bbf5039a71c587a091ea9b439778cd7acfd275fda3803113b9ef05f37e0ab30a10aaa256554fbe2dfc8a8ef6f795471faef9f7e07bd8547a68d95adba978cfaa3fd8d608f3651bf10b11f7d6a2fc516ee4a73886c1d8e5baf635afe7017b74969e8d03011d6d3be67ee80a7c1b702293da82aa44aa061763a8a8a18f4f0c33c5cca0be8a3bcf46728e3bd9dc37ffd86e8d98670a2f30e09958fa175030c44d465641202ef9896f29710a59541b7b1406581f9a0418ae4a32713882938a34cafc47d18155d87b0064c474d2ec49fab42b9ab113e4f3c890058030f4f3a02936d57d151dd56c89f403da1abb8c34a0c26bee7a789d4baf9fc8387bf9ba8139c5145d4b67f60b2f388b3d69a423ff9d539fee552357ccc14bcfe09c275f2b3a969c089287b6a97457b1cb6c899c76776e5c2223e77789109af9ae861e30e95569e1ef28f4eab22504988668855d3ea60a56f18a7eb1f72d125f40b955509f319133fe9be0d0bcfdc4e14acd7ceb9eea463f4f31cb0ec91a0001a10fecea4c2773840911733b4bcb88c57ad6db29f0b98a803befffaa81c82ac22457ddb4e5e7ac02665dc73b39ca751465f6a20ad8333952c8ea54634e31a3695dd7b81672430a457c15555fb0b75e2ed1a5348d720f46db48b8b2b9000a869ee2dc49a21dca3a32ef26aae30a4868394b3ad81ffdef7be20512c079805effae0cf9032862f025d3ff9910e848741b3a62d2f121420e90b28070856840dc7e39391934da8fa45ec168630fb98411395297b9b0668daddd1fb164841a354139b9427b91f194dc0f377e70bf4e52b91e88686b8cd4041b356142695354bf4e08e97f11e26b010bd190468b0347479d71bb83afabb20414a2c191010b3e319ac553476259a429c9f87d0aea8903d6e55ef90b06c22aee44bca94a3c069e43d4c541f0247b6d8aebf414223c63e08dd25f746891977bce2437332a32e4caf45228acee518a1b9fc6b83b0b969bf55054092a7b3151d7af4c78d784e9b6a47a896ec8d68fecc7d41798e9ef40d55f23aaa8c56947538457b2d9d3f765a83bc0810584e801ea26b7a2f670c0eb88ca1a613253ddf4222084c3176f46174ab7b6c15135b016b20f64c95aba5503c04eb992b9ecd02cadaa1e5e8f5948351cf2010a1bc052aaf34f8c761e6a9907a3e1268b84381c06f62789fbe5b615bd567b963b0ec6ca62ee9014a2bbd5502736ab358a5b3d0df0587fd5e247884a7189e112cc09380df9f567ce2d24dcc50dad0581ee35157b8dbad4103872dbb8386ee6692a77166e1514ccaba1a8023c93010b862116203c87276a3acbff63c856b2ae21fe0e0b7dc57557f3a44d52d8c498eb4e640dd5ba9998eaf7864f269dd90ef722e66ce05bc54e1e24d4323a1dfb2a673be9877cebcce95750cd4c69b2a2a5cc8520b46b37b80ff3524497b4fbe736d870aa56bfd11c2b7f9d8ac40833868586dc7f0fe2a2e25f25ff963a30745e41f37d51ec2a470a9c0b9839159fd74d90ba0068ae98b80e98ef9e68a1011eaf0242d3328d9b5d0be046cd586147be2ac9b0a5f9e70f88b5b91562c20b0f3d52f58bc2f2a7ad15ea51cbf0f1b0471ae1b468d92bfaaccf1c582d82d75df6d60f38411ae16275c724061de5499440f8a980dd78e0e7063e1074a15ecdd3e04b8780c4200d022a5a21c3cadaa385edd8994010aa2e632f4319b0ae0ea2f10464388a2ec6da1778de3c087eb1006a32699f3ae47344e944583f350d89741d7414ac7b02fb2a31d114253e3aa15c4ac9fa11b1de5ae4f2de9fb4ce4c53eb5d77f88658b98d3ac21cae87f9a2ab7a5be7fd21ceef4e0c2520f2a0beaddde822ad1a9672c889577149f6f01c33b7b45aca37fc67afe7336102c284465dc0aefaf955c2dce51e7be3a0c1c4bb8a420877655e015619509e34005c47c22b125697e336f508e91f0e089b05991cc2588cdb102122df951f7128e6e16e8e846e612104b015c64f97bd9cf2f8704e3ce3dca42750d11a5b0403c7e5d18fa411c12e4bdf256054e36957fbd5d4762f9c50764a4710b4fd7850c66ea67dac1c911ac354f4a4291a7ad1bcd7f910a226ac9fee74756660c05c1f0d762de1c14217ee7dc3679b8dc16a2b3b74a14b17b43b391c1991b075aaf6f2c22df758e331dc905eb314decacd8a0a9fd553379c460c976699c7b785662bbc81842753abe0d4c5048fb71412ce360becfaaff5bbe8ae7635bd264d6ddc23cf655434562627656b18b9b969d89264396458328052563283143b5bd3a6ae5726cf4fbd9caa3ffd978672d6efa6370ccce0709c33fe40195f8a91fc6b7e6f22719974289a394f82ca6dee2c01d3d1b08f52a16232face34243bc2ca03ac43f5bddf8efb8c866610242b2e95a6ad82f7af1d3f3b4c968ea27fb2ba163bbc937686d0dc273e4173391b94ca9b834330a1422746f356529b811cdb82d082390e7dc1e97da355eaa4470bbb23d569edd9ab656ff4e3df91fafefbcfbf156c1d5f6e26de5add9d5cc3d44d044ea961a1bb50a909a044358e7c8b151cf988f458b6d48a6fc1c04a7687cd02577cb26d2db3a9abdee58209307eb87290fe88f931fb03b2ccc8f7ab44355fa7ad736ef49a0e9aa344eb810eeac64cdad819bb913c50ddac6da31635471a9a1ebedf375d6ce1da7302ae36b2c1287a01144da8485542b59ffa8cd98096775048658d1fe57642e746a72fd7f614d3aafe750748c1bd026cfc0d7bd872350ed5658be1cace6110a8de31cc23fcac568b118dc3d18549297f0d618e82c517bf85a558cc14a3dcece3f20155782dfe5ddebbd41cc1abd41a830db32f251a8e5f700ef0b47360f419b1dad46b20e06489db10d958f940e0dba2c3720162e86ac2a66b121a00b729e3e517e8fa144d37a01c9c8fc22c351e0bebfed99075740950739f507980d7d70a322711354df1d3f3cdde70adace84531f5ebd4c20b21606791c741feb853a31a1d8822c4c5878d2f9e54bdd9248221770db032c00c9d522a37beeecb65fe9a8904f51554b61152d8bafe9b3bf0a91575f2e69e6f5ae2dd7e2ef4aebbee19b1dd14eb0395679641e1e7a694e7b4c056b5e07c380148f0990e5b9928309fea30de759a6f29f903565deda93ba97e9d782b2946d17eea75ebcb8a81572998cc5935186f3dcf440c8a6dab165845b1813591329d68553c4faca213ce661e76968813389dd37422c0aa5e2209e3bc2112fb2fb50e0a0ac03b26b8da3658b45250dc69575bdcf9dd4d519daf5344f9c654b885b1ef3bac0b775b3d8fdcfe04acc1f300c521dc3dab2c51adf20e14e0489ba0435f0d61892019e5bdb91662daf583e3a543aea96d911a0f5844293d52043c2c7c94d897e292984909d14a7778fcc295d0b2b3eb62560cb9a23f4d25d655debb61aadb8fb9abf6d4612e925984a20a8fd143d85e10217d08b695726e2c265936c0c140755396b41fec8bfcfcd805f99a660f9d362dcee459c8b2444587aa6a237ec5b5c5c2ec0285a8ec0e0ddd6476c09280c67770bfa005cb599ebc8cb6825e842b7032ca5bff30cd88693bd5e19def81d765d28df6f60ce26cf3cc0971e2d371276759e2adb969680bde578ea45381b2eae343f03429b63c41ef34571f43290ce15aea68c334f4ac236275cdcb5e518ba44126f79738c8405cba25151a8b4673ae2c0e88fe4a7dc537bd8574404ab4eec93955561b2fcfc052c24faa1a5fdf7ee21db0e139d35e2b4a46ab6d8d35ccfd8ece2543e501b069fd503189c6c9a234d5e8dd6325a28f99ac0182248bd7963bc3733fd673ba65a085f0bead278635d11ad37439b4dd706a3d48b3cb83cedfc6ea3c58ab2b253401b0bf3b680088a8016f4917fe435b276e72308d86d86bbca3e29106e8e56663f78f6eb74fd7cc88dbb3a3cf679122b64cdf9a1d806f1a845d58e0a99fd2f8eb8d1f99e65779e15fbe04391cebed600f882402cd31f18f313c0f82a8b09b67d539d8e202bb0370ccaede89a317a0763853cb7e0b13fc18ce2235852688070957980ae6dea9e68d72943e52d4a208ecc73c6dbe2908439e547949020fad27bebb4b3c1a584e14cdc75ba4d32b7350aa689c5eab9377bf4935345f742b22dcda9b70df153521cbe4223c0c84638a774fadadd0efac43deb84e300c77e1d82ab2e1437ab7116890a66604e5ffe19206224336c7cd170e6bc8411c2f65c822db67ddab1895560fc8e2e843f1db7c72aa0d026dbeabff90fc8d4aa998aa009189f89793d1c8348739df151aab5c63b0ef210a11361d34cc43e4fb25d8bb689034a33925daafb58d402b3abf4c29d78ab45a89855f7c9de6d0589799c38a90be6463cec882452ccb77c0419497ace90b6779d45d6704174f40596b515d184e0ef91daab7b4116f6d724cab89cbc561a99f0b6ff0174d9587bd318ccf5efe9ae71b63c4a05e99ab6bedd872b26546e1ed35c3359bd2549538bd0a93648fda5ae0f2b1849caabea9363fda86ff5e92de67a180e830f93cb3932487606a881f81d8961066baff310e6e8163fc9bb9e0e41f22d73b44e0ccdac05e55b355cb0c31e38be9b63e3bc2e74c44c9946566ef24cb58b12731752ac8e788698c2f6d8b5be724dcbfbb1782f3446e85265bde7ba2ee7eff920427f92818d18062aee642a76c98d33c42d894da28c933659a33f2f3329d6342a8cf68d6e5ba171dc34a850a8e664f8aca25e90ff0901f49a632c01552a201f3191e4eff06f1e9f055f08a8a3e684f1fd82915794eb3c89b97f0d0138a115d64d6a668f0cf773737f81f388e2ed567d7cd19fc6983500b614eccb268bc487837b602e083140d8067443383c5a0e448e2e1a3aba1bda1027f0af72d3b3e3c0d00e8ecf11e0cca8bf94230281248b067450ec31316d7d7d55cb9560396c73f19b56f490f1e425faeca7fd9043ac479bf43c601cf2c3624b2916314b629bde7409f41a935923d37be6d718e8e5a1837e501c7d8c225f74777260eaf98a46703a799718efd196b08ab13dcc708f4dcffd93f6900ebae28a0d919ead34554ecfc8cc657dcb2526c7bdf56465972620f7a675289f7f79d9d5bd249b0ddc8f3818295bf5fd818a161f9f7fe51b79d9f39c61551afe2c0093bb3b062fb69c1ae9f9348ee17b570f679cbbcf22fee70b436190eef8b00fe84ae76382c1f6d102b56efb4cd0f7e88703681838986d2d5410bd4aac24d19eceeeeaff927fe3bab965b458f4bd41c8733cf393b47a96d4cb73c3154f38db8399f7c1381221b17b88eccd2319a996bd04e7f9a035a66f4d55679af83bf4009b5019000150aae207580f92487936a2753d1d28b8876d529bb8e917fc46bb4c4b8c37a58e84f52e1eef128876956eba066adc5b144e87fe6a96558daca0f5eb849aa3e15cd4754840685dda50af83dec40796bd20cd9c3a36f658be36bf74693317dd71727c1620a9edf4538077bbc2c5d8f218bd4517d563a96b4c8105c153579d889699b029d59d499c260cded0f55440f3c6eaf80e5ca0d5143009d8859f72d2bc7d0beca4441c61d10d7f114b859796faeaadc6b9a7366ec2bd2334a0cc7ff6e6133232f4ff1bc641a08c3144c6271bfdb97f434624568789022b21e639da7669a6de5084935a81c0d946f248dfb11e15c1101de4780b75ae2a5c3514a83553429adf3f31e1128489b77aba973f63eccce4b29181189120bf7c51fe9690b1926ca9dd926b3d895cf1c39cf6d437b735adc6e5591fb363dc67e4baca0395c1618cfa26e4765171f93522f6b47532aa9793c1940b31ab457c86b1fd6968c18af6db9b873e84011d178b9deb4273dda15cb3c28618c0fdb741af545f4f0c7707f77549613298a0f91c5e9979815c4b8570c0bc998df37c5c9b2a0f49fe25fc59065c2340dc7fa2b7228e6700a3795ff9ca3a356d6b8cced478e8737cdf0c31df359b7a5b42bae28915f7fe74110f8762a43f9f94009b8384ca237873fbcb9d8e83dceed663b8ad237f8e604962f285f41e32411fe574e0b58562bd6e3a32f620aa5a432f069d123c98088645f059cc68881d4379c389997069c6953ba43d3b1684adf6670069bc5618111ec7c047ecaaec8cdacd75b258d30da1e14bc1308e7ea33ac961037b8e2509109fe9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
