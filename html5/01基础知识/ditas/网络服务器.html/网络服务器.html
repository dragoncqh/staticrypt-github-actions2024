<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d80dc5f79d83d697ee46383794d9b43f23eea31807c2db27fde60446d68eecb52318256b2e66f3f2ac131986f347508b7c9f90dee4f44b49302dc87e1c3ce36f7e5a34cbbe36dc433e7cc61c7cbd41e44cb0681fa20923882996cc4b0451aa120a7d3967dd0c493ccfc429358e7d3833cf8aa4b1df83ee5591a46ebb81029b2d3ef895183abb65609e8e6a4229790aa291263cfe13ef13a35b7b4776298186b454d02a6adc506cde388d8f4a8a3dcd7293da72042b24697e53529d7bd9d9bc3d5e1fb4e293de073050ef6216c39be26e51b49b77d53f089c3c68fc0ddcbfb22707e102cd9c4f0a6af56646a232b7c04fbe2a64b9a7779a1346eef994c9f481ae6855de9f7a744988322be2acb55f32907ee9543db35572729facac98609c3700a755e715a618bfbf18122f3a17b8debc031e6c85bf7e6d2beb02b0a3e526d9f13123fc54ff1839c58834d00c3911cf3f694b57be555bc84afdaf79ae666e0dcb634831e18ae9777e7d9099bafdf8b8f22d399ec9a9c14e19fa1376dd3760e65d0470f21869f4617eab1e1abac021f98c37d0720cc0ace2e4ad57e723704cbe34d7744b7f5d4478101722a310ff1f505b2250f0dc7d0699cefdda3ee71fed02ab4859e7d4221eee65a0e9b029805e53a2d12ed87a53f651e42a8054683e1584850dc825446d5ad04f8f6f668a1aa1ad1e77dd806d26bfd185ec707850cafb480cad5a5b3eb0658f3e558c70b1fb2b02637a15f33baed5462bc6ee6e2164498eaddca30f2c3244a0530bb8f3d3842bba8d07ad2230e2b75e4c5c07911d11ad5de97fc28842df7911691195d6eec75ca9dae92e78450a02f0e4def3f6917782d814a84610632dedb8041706c97b1e2af3914f9a2821b9fbdb8ce8bc1b12f61e8a0fb7cf51236e624cc6c1480ddf558e51115026361a1101d548ec984021e5560a22db0b6a415224d068dfc638e5e12cd7238a6a8ea74e95bb9b916b2c718561ae27885ea5b398df13bf8d4c3472e48f43f6c656e33fdbf138f8b6b66c10d1d18589752f02e97ea60894ab9ce59df5e7f7e37c13f4cdd746a0661e6376bf3fdca4b20da7e394631710d47fd4e5ff5cc88d1514553b590f82427f87831012cde0e9401d2b14caddb8aa7393048fd13e496bd66ed65a8dda93cf525e7b270fb6e1984f23a4fcc92e6529ab0583395ad27a95d0b74dbd94d94ee7e15d34b634c69cf40b5297d14892cbdfa75a0ef8345d92590692d1bbc865e0a628ae11cfcd09c361917a0d22f2abf32f9c2eca7525536013508970130e8369f0608a9a10a32e8d1718339a84204fc8dc407f0fdddc9164065616e3074170b41511ceb4d969d11b2e2aa24a28cdef91a5c49bf95a165e4901053a874c042b0c8bf5274411c46a654a47e5e00a19a9f2bebed6b177db6901dcce706377a580e6503f860ac3ce61be164792b833b03da448466a707b477aba1012fef779110e7a03b1c707ddc7db33a61c0f06fc34849105ed68861e39443375be5f6c0cac5e3e1ef8991dad86688f58f0dc4388536aa63cc10a7687c072f07be5c0bc0a126f2aa6771c94f07e13cc235dfbf2db470c9becdfbfe5c80b2783a311dd8f5de57e0808002cba20baf73a87d542492bd6f8df16d4211f47b51662f2f230ad24536b6c045ef325e51481cc266bed96facf56dd682f229632ed5174cc0c5049f4dbc71f323454e8ce64b01afe0d2c36d36e18dff5184db1e98ce8591b132426c4b0d40172eedeaa5a353562547e4710d6560855167dea0fe2420d3f4ba7e8c5486f43d882e39dfd30fb96f8a3f26154d5374dd6a6983fd17be67390d7d2bbf08a1a49dc256afda05dc4af5ef6d20df797c9a400a7bfc840d2fdb7fd8c161763688c6572f4b4050771e1fb76ef1fcfca07e4e0cf8035ac5cf598d9e8ba89c9e89e7e805bea53671dd55cff7fe3f5156035b4be11ebf131be529f12f4163dcdfb4fceb6897332749cf28219ed71b7bbca899e14aeca622a557bd33a76e48f4b614c4b3424e3120f5d1abe426b3736bda2c3481abe06bf1a1b3ed2c8157cad61f8d9073a0099093b5602d027b212886d3be14cfd618a66a77ff4240f920e1db831f49cc83ceb5cfa933d85cddc8f86e646cf0d001f93e9b926313aef1ebaa19ce70adb5f641ad79fb04181788adaca5d4be5d51cf907e415066114e90c08c7eb42d6188a16300d9636ce3e79bc20a511a8cc876f007f60f30425095f6ff3f3db37eddb9b982875f1f1269559083f09777ec5f0f74cdb062fd6523bf00f9ebc234f3b7426b3bb86d112b875839fc0fbab05e276b0ebf0d53466c848291cf5161340168b6d9be199d7e409f6f2672210a11546daba9099bbab867417d501146e4a93b1317804441746c96ff2d8b5502870b56f2ad947a5f8f6706a81d16ed13075e4d191e0ef56539639c7762f595c1cb50fede0a506c0025c3682dfd37ec74448ef468eb123f1b57ed78c638a4abf278f6aa45deb6b59bdbbfab9ad1bd4489a8f502b916f3c5e771396111b0b1b47010a5035ee031b1026e23ad2c07bd6891b4650f412a42adbbf1bc2abe5a3fbc248497a39a249780949772518dd3b34e328189435f9b471417219b09beeade80d7a804202a5cae3acaff50de704dd4ec74efbb923e7bc04b3c4b3371fe74baf02b102c0a1950677a920a75bf0c8d0a8f25c85598538a96db16d646a0f82b440626eaa9a18a5762e21daa2e646857d7e60262e551ed844bc23007d05d30b4f91f3038a975bd79acb660a3989f3e22d6984300c73b21e9a0d6ea2222dccacde199ef4466ad9eb0e138017947035500d6bb7446bccf13923bb03c74fea22cc23d08c59ccabd970bbaf40a92b8181f4c97cccb87cedbd4928125563c14dea8ee3577ff8071e54f59918b50fa58ce4bd41abaaaf671dfcb6b2de5820e4b9ef665b3ff3272017efa7e21d0a79457136f7ad64bbf36c6e61f1ec76a6a1732deabe1562ee26afd48ef8fb33fcefe5e603c827517dc2c61dee57d3ed0dea37090ad9c11dc4867803cf42720300af1c4d1a56637b4922c4fb2e63e7a0b44abd704f1f79fbd096558136c45d04c3b1182f5296b54c1048b1e7bd359dbab5e24d68de8e15936a21b7004c300f20bea22f41f2c9d8d931054a33e7a161846c78dcf80a8ac3173cf75c325cd894ce3bbc919439d7b8b03723fe263c0ba849c36cd3ca34ad726d24fb5517cd6bcb30d7cc82be4788847dad6d8e9767221e104c604688c7b62ea50d288ec50e66953d54f754d3e46ad2c0e021e2f1f20415d12d804712fb3b1c04d169459736a9a3acb3dc18156768a5c10148bb92ca316cc0df6174b419438588dffdc4b82f3f9693866e82db97232c95d6fe69a051550a7a11051977a2b842dc8e72ccda1e0ff691a12e5234e2a095e5c34c7a6970ee4b0e592945fd31620df53f78ac382cac2a826ae06f33adedb5331c152d49f2d948604d3d6d07d1a28311918521a6d59cbaa47be56e93dcc516845c3cfbd1801a2798026474056c9a77e1a81f4110a7a902e038578968fc0e3fd14b43f331ef0709d037f283194dbac50d2c6aa86d735aaad53b48667be9db7db2b9def936b710299f1c34aa717119356d3967b345642a8f95939d9d9a464040ce3192019668286778b58772b36a0a979201b886f93dfb9f16aed2fd3753563d69ead358a21705ef8a5da0e0247f6c443cf0fddf8e2b453fb5541cf1b500c311ae7d3afaa15fbb39e31a542bcd8d083bd92b0a60db2bd3f1c6191fc2782d65a526a4d1c22792123bd0027b77f2ac34abf6243989ea49b46bfcd41e395bb0e5821eff9ee1ca1f0c98633fc771f7dfe04d3cb57c69cfee63bc78841847a5c841687253f8baae64bda38a39b452630a73b47dc026ddbac2e5dca4d962fc745f2c87557c6cc18e6e5fe762f03b3a030174f7412e7fa613fb6b2ec0e2a04a009acd04d3e4b3507fac42b1c3718fbcf939fdafde989f218067b9fad8097255f148cb99d02ec05e20c47a7e260a10cec1b3e167fe7502f77846010418b61d8a99869be22058d4ecdc4d1e89fb9c36186762e858aaaf73e68b368f1ebc7394c85da35957070596cc4e1bf63ae45d96f7f12f3769a2ede2f8e4a8d2699c076b0e65ace9587a7302ed2dbf582a270da19f32e75e975c4e7312fab47808f3e46f3fea09346571407dff16136cee5a812b6fecd23a7ecb4d9275152c912cc9f7b3f61dfabf13994de103e36332b886533ac6dedf45c2a25ecdeac5ef2cae2fa950df0061eb66166edcab2b2668ef823fc088850d68d684f66752743f57169922b81ab6f2161bd273846f5f1f7515d172edf1202a658d3c9579922f33c90b0fa160781beee552b4cecb5c4fc288373daa493232df46b71be5e62f862d1b07456e4c1793b791f33663331d6173335adefeffa4c94e8cb61ebca2c5dfb7887e241e560437eccaf2b7282b5334d159a7520c1d21cdc8c47eb8f20fd3895c4638180ac27c6012dbaf975ef3de754dab55bdb30a0d81e5f3edebf7afd8c56ec77923ba682a2cef937e25df0d68b8df1e31661a09157235482d63e9af2e72192688b4dfceafff1911a89aef89e92dc69a3c95f735c35d7cd6f2707e65b4d66c41392153cafdf7b415ffa0424a502c007c901aee21a69eeb1ae1efae108dfee9c1c30efa2bd81aace81416b6902ddbfad89da3a91c1f3f28bcefccba4f6bf1d428aed721dd0be4fb27a91af2aa33ddff609ee77b821ea16d12ca1c50548b20b545a8c2100a2694a19d0ba71a06ad96927ba713120cd51014efcdb598f2ee4cba27e577b9dbfb760ba3f89d74c9ccd9c4669ff57d034c537a2800e543d9ab98d1eb91735a9bc7a3a6319223885f80ac57b0d0754a454752f24511f4216d8c2c86da7fc7f6141c8a0e1b7e858ab09672f8f7e93c61ec10db6810084c39e3e43d31cf1a3716f7eaf57916a9f0ab2d818ca7a5f826da34a8d9d112046bd05cf793c28860f345a9c88aed99400982ea9834af2d57d327db02078abddb38e2c2b8da74f2cf21d2ac0c5261a4cd36fce59c15c3c77e769c0d169849fc55afe38e84eb426efe57327884491e47c92d73068b559cd735bf43cd9efeef7c19403f83013c7e24b3a837b13a289a64245113db7d764e6f78320933d55ad79f680af1b989716b92d2d21b6223335e757ac3f03ebd971996d3d89ba11d0b57063b71263132a396b5b2f31e80d596a44a493594e3f596998a469ff777519aa891eff022feb9b5aeca842fb3a666791a40f89ba34f696db91407081508e011e88ac7bd4c67c4905b32ceb1d17f30922f435249f0b4ecf697ed95159dc6278c141b8b516f266daa0da2848aaa836162d78da259b4a40720694a20df349ffbebc0ea9a022f2b173804136da43cf557ca954d62326cafc162ed551cde9ae4493a24ce8b1cba623d3431d6b20586acff56108862bdd5d1ae03fea8516cb102d35144d47d68f14218685749bbb5c83290b743196e38e54d94ad53e6f65ab7f5a24a7e58bb09352317464dce1b9729df9203c370e1162bff853ed2832a94a38a5ef2a5e3b57da5df91d256e73e40252fa120539e3ef579db7483427e6ebebbbb6b32b5b64c2626be4885ee1df1d3e279d81ad42843b2c562cec3e8918c31a54fec198f90d2dabb0621831507b8746f54fd57a3d14fe06112c2e54184a3856502dfea66ef3f1d4d0c5c795d69296c9cfffc2874c6d9f787328d5f38f8d19976249c7421d61dc33fdf5275e40920c953a1dcb24fc8cb8b5d2bc8a062abc9eca30740e4766aff52134441e769b06c71009f438032cc42e6cd6124e63c7107879f738fdae307b86674539036cdc75955f6c3b7ab0d8ba3f722bb33f1fd61cd3a9102f2d09f27dba527d328f684f128d854c210d011cba38bfdebc6a0c35b5fbca415922f21fb9d23fbc94ce6998f551df2c0407c2c1c665e6d182a917820e71e0cf1abe3db51736c4b6d872a1584965e3f87a826369c8f50125edd97b264223413e09b37ae99bed0beec9c83a1f78e7824163a5e3672d15e43522b90f10a3fad38f4b5faddadd60ae9102e187c6dd4f0e39e8054bb85e537c10d52fcd55dd80af0ca20f3cfb956f9d258423fa7c048c91c2b74397fb1be43aa786fd26263d879fc4a7795771ef1927fa4c5b9b4fea7d5ae92e5829cf21dab82a52b0eca31675f84a5fd6574b574036eb71942bb02ab3b6af689df5a9aa6d107ede3c474560b92ddcfd902ac8494f092bb783a0abdba1680d16824a8afbf3ded89717ea25a896ae252856a661452804ae66e8c7123ff0c13d2e963b41249c9997ce062944930b54bdcd5422312f8c5a8b55e97fa3353461af3b28f97afacbc617e79a9cc6146646550df6d87713116881ca407ddb8d4e20dc06692feb87e33ad00af39142c299a6b421cc90cc5b58ac2afbd89b76200fde864e3f158285a80b8c37ae1bb1b35a46e25aae85fc1d2375c3d7067c8a2ba99233be1495f065150c9a2b08da68aec6c3d4dca765a77a071268f3186c081d842ab5707a3ec733cbd21f1cf2bee47fcceee002ab21fdaaf616b0e85ddbad1fe036d2a19a9a8f4b23f3a2bfb42cfd7ffc92ec0dfebf13c2b6ff6fbe81a8f500c6fe439f692b7cc9afb8178db7774cc0e8a00eace75c507f21461cd9427cfef7cec4eda2cad59d1eb753f688a48937cc88a25a7fc29c70cb5272aee93ee2efb0ed827487304650a6f805693f080abd08b60b50cb0ccdbec178dc5b404fd68ce783e4fde97149ee81511bd20c08bb3ffe0e03373408ae3329afec8b7743da4b5e4c9ba476a8648602d683b1e70432be4e77ff32d68b9734a297b347018feeb19bf87e9315d82ceded0ebf929000aedee1e528854718f4d7d9c46de11e3823a81de655b0c89314c561ca765a361b3f045bab96de9d9d410913ea7ef412d0dff5c42e367066abba1d8e44cb663efee2f5cda8a9b53ec3387a78e77d6b4830add9e5eafa2b71c7c7b8e6af80fd0091806822ac7a750c8c381f95fb42cba4b29df9fd2e28b83006807034c6824d1d74bf41f72e3eb5aebdc79401ff7edabdc96e9c95cd25d4c821865ba8432d262157e0fed6264a1c2676e1ef9b1b2299a3596616c6d5c880f50f1f7e482e34dc15747b53b76bf2b90161459863f3efb09840259d970a6dc1ea06359f34883414561bd4bc20da6b5e96aa3776fd2fdbbfa3382db53a0dd5efa84c7d624f2db03c32fe9c810a7f6dc875928ec6c100c189c6d7a7c806eac8cc2cb2cbb65a3b659e07ea7895d5e174ffc6b0bb5cb87f947b6ff2f80a9449553af9e26d7492457da6f3adee7ba280b69702b25ccd66dc5648578148809b14fd303564719646f72a813295265a978c9b3004a81f3fc276f8853ab2fa01cd8fd7d74f71ef24a59d302452797cd78b3694b91c75cfa3103a5196fbef4768661f3577259166fa0075ad27b41569e96a800fbfde173fcea2cbab18608fb7aee9e58fec03bfebf63991732c0265a6b3ed91c6614ef4ddd0fec46e063ff3552f9ac2d7d26e176560e9c7a86db78723a62fd4068670b6d712b3f1d32ce322754bd95fc09c6e21bb72fb30ab66cae1b68d2c18bb670d413f860ce904ad8036eddff4e6eb6f0b21ae43d8dcb8e1602f2ef9c5f67342f449fa66f8563467c8ee71b33280ad373193bcd7bea397447d8e8a08164d2e6abf2ad4f85e0ffdd15e096171fa501ce1d50929e1f8d70cb3e1ed79f300d61c6f5308a39dcd51c93c3a93e3719ec6ad11571e2ff2f86c6e5e0af6e4a71fe6dca881b8f7eaa4d92ebdf55e164a3cf2d702d21e12f7d6ec937fb0b6e0658c7cd97e89112cc8abed2b7aaabaa49238f1d6f9459cca5076fee52de0400a57c92e6704626cbf6a8e9aaa4d5dd3273aaa15194d876845328ca68dcc2a11d01ee5f72f946b50dc811c0e04b4feebaf649b021afa317a9dae5016ab05a70b72463b312561175aa0ac099361a9816869e17f7f1e25358e9d22a2960ad9df037fa9999344f4c20e2d52c561bf5a74d163bc02626d0752ef050aa7aa6dc0e527aa67745a3064bce1ab9a6e537b73801d4b4ee38158638421714cfc5f3d7f541c8a953f5dc3654872988f69fab1e2a404506acb828dcd809c6b8e8989a21ed747cf41b2b1bd3e1bb9e9c632f1a735d55c54a842c3d7d55c68fc07d0bdd91fb733bccf59530c52f3a4a92450022ef2736c5e7f53a4b6d448f96b5aaf57dd5504fa635dbc5f6a45bd3679ad310084a0b05ef1e3d1e2833ca54f82afec17d20c2d7d2bd95d7fc379ee1018d5572c506f93b27a15e4b8046a5351a5c365247d38a2dc1e4f5002c01b4f9b76a36b72f5cc6bd381ec24333b62cf5667e1c468061811d0bbe155aea04b663754aa31e76cd894eac8c283917ec85aa4ebb7d4b6453e039b5ebe01514a2de47b0b4cd7214e06ac62385f5067fe038bac16f8cf27db4c6d7bfa4280db48d91a1fb056445c277884a940b31ddf723c96f6f1c4e7236de0e251d11251b7b7b7898d675d637d41f21d29b125cce45de1f21d5fbde8d9697cf4ce069d56f7814d3d93aaf291ef203169f59ac835b59b45c6434bd52fdcd70ae703de97fada23689f4ec9dc2c508d59751fa372c898a3c36673161e97b9022496eb01c13ea5396ab30498db8cf1bb0cdd77c2b4d6eacf6d59eb845954ef221f1604ad3e9aeb0c8631963c72d03528a50a5f63c8c14f627abda2e39b2c1c52201a225c3c586d1980798cd8928a03228389f233bd4c65f22315f00615abc1ef96bbae8d81de9a75aaa5d18bc7b00e1ca3a55268c72e97b2f97919243d417db1faf207187f7f6f6c9751a0e87ad2af6372e621ebf63cc6278ab8fcc24f57905439f86a64afa07787ea86babfecdae0529ed790aa1f7be30a67c1a428f8e7a900270b61080e2b473c61384ba91dea2784cf0999502b41baa82f9d77b485996150bcfa6afda36f8b4d26829c16a9c63c1f863c4906ff9d4c138e9cb9ef43fffae35717ca71feedfee1d85811923e66efd19db846aaf3df55370116214245ede76660fb231a372d477adbb81e3953bb0bcf037b0cb4512e6f718c141138ec55554e20db692cbfdbe74f44c700225e6974f6f52743f80456ade9081ef72795ad41b6905e7951204a23b36f8d8213ec84cb9f6f9f1270ad4f38430720d42aece18715906c266600a996ccd1d681a7114e59c7de7ab5eac7b183a5703d2df1f3709e9e988829faa802d06c66ccb7695b0b135a0e84aa6e6e474ebbe3ad8f88a2cb8806d4e57ab68f97604d7f7e723e5d4bff7ba2399f73593c574e762c686d7136b974f491e559d4b14afed2535536fb62a481a2d728ef71c7a2d6ed544946f862f2cca8c5fc7352fb928b7e3732781d5e39f6fb0dcd7842e57c42226362ab71e727d76f764909beef333a4338f1373449e1a611760af706708c5ec552d6c491dc8c7000dd2b7737615b5da402c416de39b5d3a5e239e1d050d37aaa61a8b70b3272d5feb401be5b4b3038a0bbf18ed98ac43e472e78daae44cba0c7870336d21ac1e41631a752d7d8721640694c4ea2e7ad44bc372b63e5075725bfb3858c104eb3ed7231687d43aa8f121870365966ca89de498a2a65e7c74de804fd8b6e1789d7a32167363df8c6c1cbf74b54876a08f945bffa694cbf4ed59f7973f2c43b3884f69baf44f2d2c903230708b4daa095c0c724bc725e20d66f4b7463ed0dc1556e1a3955f5b1f4bb720705011a60b4ea813d1b28545345c4a6ac3c89eed5dd923a2ec20f4c4729230d23a2dceb12d89cc339825966512d7b462a3587e4d166893018b5754c4448c8e79c82dbaa8b10e6e239add03cb8b5c053da6c64bb1214a8140a38bf2a3c61558cdc79594042460ee266eea3606d884b16dc2a0b22c4bc870aa0a135c8f88390f66fbe03b39d3eefefee2385b5ee71db576f7b71a5876eaa4e2913c45c63bbecc6d899f402b769e47ff28c236bb2cdfb61304ef724fe1a7a6687759ce6fc0f57577c5005fb31ed87846d1fa34621fd3d8cb89d5ee9bbd24d3269bf1a0ac2660c01f37773706e920c4f6733e9206a5fbcf653780ece388f97d3b2f5be7a23832f7bb50bd2e645f4515fc788d1e58cc466d4a47e2abfb28cb6bb55899d398785aff2f0c15c6fa626c43a888cfe6248541f872e0b4dd014859d5ca37a492bb10f67cb556b79b3a737e578b688fde2f3003b33738d887dddd79a3bdbb30e50149988e5db6ded0f532bdcdc477c3485bc2a7fbb58a8a95a537346152f859273ba8f1fe4551952c4a1a89ea1f4598169484441f1a51cce78cc53f2c5dad43929db5da937c51732479dd3bb6338d45001d64bd503ccd0bb0394b4e256b29a863f6ca79f1a6d293aacb9991c3fbaefc0484450db0537b79a76578ba855253967f1cc9bc03175353975f4ed94960111d0b444c4f94a179a2a7a4643dcb6da7b0c95292c65de7470408d7dc45384df5cd941ac99ee4d0cab4c6098e74105526c2098a7cc494e4ca0f3b52afd3e51e86fd540d9edb36e4834b32e95fc571431f94431bc0f6f7f6cfa0ac0bdc078dfa90f759578ab386db76f5de6d04d9bca525b24db9c797b0f97d92b65c6e748e1007182a5cb0c149259711f3d999cb842a919e47039f373026956d5da441e84f87cffb2bb0e5a9f2f924a749e5d5cca4a9b2946763dc99e5b13b3ffbe0594ad7165a31033bb285e7e617c2baff14b872a40bc998f1ffd6eb1ef7263299c753ef6b593eaf381c465a87d152ec40c07da2cd53d68683886e1b895dbd92af53364af4038abf29f9935f9605093bb7c4cd25fb8afded02a8ac3d2002a85897f770b6ca2ecf89c4bb4fd7f0cd1b9c478670d88791515c9f9e16dcd230fe3d2d94a547c84dceb39fe8960dc5f52e85790fb3bae0d5ce45e9c7a4ef1e99e8523b7c8c225fb5e6d6fab30a259ec96d708316a9d1d010314c1c2228cb4f22ff9befb85f3c67a4a97990982a4661e0eff161720a7f314920a3ee38dc7bf3c31bafed8f4bb0c4bfdb9314d2f4534dee395b20d15de3b1a94e2bbd2a659fe05aedd574e2f3202b1640ae11a54ea123b010de23e105dc1ed259baf7adb9f6ffd22fde206190646172b1d18ea5aacbcb37829aff5053b06c353e6197263d304ca7a99c5e32b61e6c8b6b9cceb283d58a8b184aceba96c408fefe1b901cb62f4514a2a9711bd3430ea38395087678723a7a37df4785c954e80f78fb44c8873b36d212ae90eb8a31401f2605ef37221052002013ef45760ead37c3a9f1fa4a7908d001afa663589aed5f0c301b73cad57dbb8602d861921e0e56a8083c6f14c091461be608c74033c67a73add74b21da70a5a1422e444a8929b8ecc12ed328904d21ee63df3131d4aa36692fc874b0d7575ddd1b38e2c82da4d84ec410e0828bcd9cdc327c5c4d21c67ce0ab31d852828d5bd044620b61bcbd1798c3210430879f978f04e143d4730c9cbdd12d38eaa9339ccf1e058c32e48bf25641dfe4fb6bd74092f1614c68fca9e29cb7bb2b01b84123ad3e6667e4a2ce2726037456c08a957078cda24293f1c2c9e2309f22039fc80cd0325792774ed96fff4e370f5ed9be57d48a76bc53af14b6e453e34b952e5260675e32fa04295c4db3ae769c63ca0209c19c381e93d0a05acacc12f2b98c1b3b24ca4809f126d59103dc744316752db2059281943435eeff7c7e926cad67326576612d362ab768ee8e2377de5e092403c596f0e8dc75119479fc5e4e31ad4ee2a81b210112f139a7594f451837eb1bf9654af123f5e544f459a06e5e14b0a71cd93ecd96517cb4f6f4857ceca62d7b587b73158dd0cb1febe6c1866e2e7ba4f995cec8b52fd8c7d185e513000f3db57a48d09d7768761a6ecc7099bff4b9a44768ff441331fe1807baf19504906b19cd5c5b0f3b524c2bd660b4e5c303f3ebff9f6ac44f7d420dfe53dce56a493313f0f4bcc3080bb3b1a250498f9483fdcd583bad1755d66a9173950dab260537bd5626e0879156fd68922c6bbcb24d0f3dda5e90e64a243b74c62576e9072b9ea511e039024955935eed811abf4fd51cb947d1a8bd2022bde66e6ac82097ec0b987cd4f75c469bccb3256e08d54932d334dc9b118bd5a57a91ef10f32cc022c3a869469220f5261f18e12cc59b16bb3e5941b6dbc2a1ed5580bd4811afc65f5c26337c06abc16ce326ac40311ac1f5daec6d532c0cbe0c9f1f53431bafd13510cfd848da11d40ccd9e6068b99ae5bbe823c23c9d435d6e992c11eee48b2f0dfcc7a9905ce7d45feece6d10d113f1e22eb6bc4940827793617e52709378f6823a312b9e8c9632e02fac5725261b29c633e3cb1a816e49a45c6418876f066e622bb8186565519cfbb6d9fdf03aa2fac8d3d09191552526f2a35064f73c344b2bdf8b41af12a8b1bce724812f84ef96378905858b55cac068185941bf40127072870a0e1c811dd0f2b0be223e53ca534176b145d09c7f10b3d25e37f2e540a65423dfdfa9ae72942cc05e096c33fda7ace9d8c28603a4529c2782d9bb75b597c0c5acb6242e66b3616c9787ccdd2900b97ca7659ef881754b600e701d17abcff91d169e4e9923a8bc3d3eb380e27f5729c148c8be24e312d08939e0dd3b936de17173b879e3ed4ba5e4412f01758b7d74ad471b86bc7a529359fc43c2edfceadd372322c73aad911b1161387eb45c868180b87343c968701d5c27b83fd8a2e78e2476f0e2fedbe33f5ef32e172acc3db9e12050c2dbf49801fffeb245b89ab01fb8cb2b266a7e647553996b33d0e8adf7d37d6b890678a5238b877e9ce85207c34dae8ed213a84608b25abc205f73e367b553552a9272ca4c33bd6f29c01aca6e5bd09294d3ff6e7f00ceb67e30dd735d0ea817b1e64a2ac03b259f09c38669d39dfb67499dd14e8fc4148172055295034f82dd59da39e4e29db21a1d858d8666b957206843af7d81596c15f4a00910d6f704ddd1ac0fc12d3f4e481673248378248ce7592ab2c4eddcfd8565bce2868ac993154f4d5c36ea94f28203670d69ff4403f9f411705c57ca7aa049c79dcc6bd95c85e32d3aa5a15f18807f01e21dca8d53e47c86c73c299582da97b6fb807ef3d39fb455d93d93c94d8a723410a3fbe52760ab98c2383b15762a683e2f7bcef783534b6bd2138abc399d56d3902694a4311b0ca00299911a10aaff63f5c02524b030d6cc8c17e62d95c7a5df346a6a8d357e43eed76b1654f4133e467f82ecffec1cefff6a2badb56a0c7f658efa3bf00da3d20440d15ea097139e1a87ab9210afb1cc8e9a45b5fe12e93c9d1abc3daf0f17cd51db125776f5943e7718eb7719cb08ba54f80232acab83df6ba8bcfb7cd31984ab8bb97077da3b41dc6b370e92656b4042004cb8d87497b0a75f44b63f0ca1c3347057a03f0f68f568283e8e0c4c01716c9983d1431c45f8f41b685bbadaf313e09d3b4e754d290a5413a2ba3ec8c433787c1df3a68dcdaaef2fc4072a5537142d54b79d306e3aa9e7037344d973173dc824b87d61effc999dac7f724631d1cf35a6d32795c99138e9e5473129e4d39aa0669f6dc819a6133b862556b2a71cd98ce83e04f21a9b85a3300aa2a763688a39b4b92d4892f6b255a7b52bf89cfff38d5e790c8be11909eb8f91dd9acaf2ccbfedd677c21d43a7613f42ad6afdae07079d7bcd70f680090fcf00b702f68b3e3623b73a4242fc22caafd71e11193526d50310bb056e0be36a6da45ca31dacac0ab4e1db0f386c6591e71b87bb7602369e6a072c9fa3f582a829a81f4e773da95947d9ed85e62bf09bb13271050311adcdd1658dedade3213c290949de032a8bf7b6ab8b0bbe8e80b79a6de46ddf169e09821845382fb483f897e7d56a62f01d50b35206c885afa4f421dee23c896a4a355bceb522545c22954f9909fd91dc29367214de7c6ce552ffa028321f167c54c7edf6d25c75fadaba7fd297fe21a080205eae7bf479154e62e35a80784feb18d67e784985c557c29343c3b0b008515698c4a11c03b380355721f465ac47989cb64f38582407424e156657bb8033f082a5c5c85c94eba35975c29d4169ba667754784a38298dbdd40dcad9cc1bd52a22216f929c87ebe5044bd340a97629e71fbec4b59618825b06be5762e96d704b7eeffc87d2d38398a133da27ab52251402f6df85c7d17a8e238166972ffc810bc11b7e8a1d8f8b36253279cd1ddb10f4877cf9e844212ba28b97e4a2bbfc94e2b168e556a84c1211f3a233876fb2ca1ceee0cdb5b3c4c6a8c37a733fdfdf02496cf31f8443aaba335af94cfb1c90d985ba795b39adc74bd7b1cc590f669bb67c2077eff49082a3aff6bd63d52621080034b77827380f2bf06a54c52bcb07626a82c7a98660d4c9d7ad0e3a2b8e8db49f92f987a27360d9caacb34d286bddedd6606be211f1d2a836990881fc3f27e008bfa6580c7d1e2f4eaf0581f66e0a57e1869ab292a554eb16b8932644892a2e7c7d35aa2f4d11e1d9b4b8288fa437b9b9f4d8c58a39447d72dc0b7e0c619311588380e79fcaf20abdd714169e11fd4684b4e046843948fea2ad781d5565ba346890710be153787f49c173f8256156527072e8bd0436a798e8314392f621bffa7deaeedf859887f57e9967adb3b892f83b11fd3c0fb85d4e79696ba2c8e580b8f6c13c662eed2c722f37e530cd5b8795a70064952aeb7d86400f61271fd5ab3c3df16364ba7440677e6c9ea2fc35f5388f880f392c70123e135df03bac1e9c6d3d7a49e5f2169fd7c0b97f960b6eb4767bea27faad31979531a0ef9f6d8deddd959580d99610d04cd0550fbbc942663f1f7b85d7e87409638bb4bfc28a3c785c2c4c3c6f5ded1dc223401d81f7b0afe8d74ea3ff5194008420edce21776fb068e1fcd99a5c144a1ed977c3d70d88774abcf1dd22bad0413f93ea8f1b2b00bddf56ad31aa0d7e3e34bc7dced001cf02ac232a4e8891158f4341f1ee422cfc123ec8452dbee9b5512fb010765a80b684f76fc4a9484273581ae10d68d7e60a16c9e9195c966acf588ec6505d18b3b4441952dd5c316c0875787b200e38e9a5dd33e327ac8b12c63f253ea7105ff2514060f19f75e3379a268e8c2e0cd9d48d51af46e14edb4c075f5c181961e3a7b0a93faad93a7530ba1c527dee05c83747f313fabc27555c7d6c999a424e21d14670f663a91d2b6e5f9e96dbc8df04c5b8a49ba5fa75e2ce9cc5632e76ce620f63a548ff39cf26abce2fed1a8c2663178a44840d23f11ffef2a9221ccd0cfc94163901c65777072805d7d068c0a3073787642e8db7974ed0d2fa09d8cc67b7eb94cea42620b7138f990dc25bf3a8e17d815f0a177c305c2579f4241995fc9daf9c7a5559e1dc86d09befc4b45c52431b2607039b0a340542ff605f6dccb621322d93b0ec9c0cda3a1a439182655ab06a463678a09a0e3e8c6c9f3d96a15e985928ac52d5cc138e9b0ecd849fcb02f66afe958ab2ab7e60654c9a379e72bcc8ee62fe9ae9241471fe24a10f351894ae177d8d57aab47db8cde23e97d0d5f9666f3bf577aff4f24e6ee8644bcb3e158dc30155bddadd0c06100cc7bdae37c32eed2beb19641b43544db85467e114bb59435eb6b07d05ac2a78b31e5a765d2f484b0ed96d85aa9e7d60cac9e18962ae9ead52877242ba3aaa602c0c44c104ffca79d55ff589934caa55c746576e33d4d0c6929133d9c792a2e428359e56d3fa38f6b1b4b604f16ee84969cf57ff04e48358c124303c9acf1f0fed9d5f50d5eefb35c3b9b98a7fd6a60ac7572d31a5eeb975ee1df37b84fd5d27e201a8f4abb547467835803318e979a81d278a9488b2d7308cf15f4f1793a2c7ba86f4b6f460e0e73f3a81f2372154d3b3395590b8aa4314fec753887254217bb6d72fd4d3db620a2d7f2c97d5ddd7aaf1656ee7ca2993084939160d44457ab7c5907f92808f53dda3fd37d59a8d2d6da888a1aab896345197e685118e605fe9d90c3fe863f10465ec274afde4a8b5a9a994f14ab7ebb90c30659542e93e54ca66e5c62fb8ae70485a9ce9ee7c3cc43ea6eb325ce5ca949b120b3237289d3ea3063b6815017e449db3a3a1eeece22e4c598262cd3e04952450c401dd246dec58da3eec499d315ab34984a9cb20c4865e7565890320bf8a102a9620c3d7a2a49f40e284e8c6cbf982bc05943bd5a6fdf5334e5e85c1f018833947710d9b66a2e7685b89db5e1d9d865c7ba5963de0ff1ac69478be0d359e06d9b0d8f7c7694202d9be519c8aaee4ea95608250d1b5f3e2660766a1689931aa7de55d7bad78d416edc94f0e99e75fd12811fd8f59d6f94d9a30ec53e78a8b4eda1a27c05806a672b0b163c308f1a2dddc7f922b4ed65c8945142fc3900fff1caedd52dd2c7fed1215c10f262d2a92e85f7d3415304629fa6960eef930b1d19fa5b8857e9d32b0f50e35460219ace99fdc47c4dd38007904ae7794bd7af139ad5083a85c6b141888fe2b4c760ba55e3c14252d5446a4580ab88ceefac9a5c82f154e643d9c3288bda91f23dc36cc45f9071a9b4d0e9a4dac1b944a39cb7b5651e625abe99d673cd660f8a0f30fe33d9cfefcf62370a51e889305b1a0009bf9c2a6c12f5d8ac2493367ef02fc1e8d4165a027511b051ab7b7c626509e21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
