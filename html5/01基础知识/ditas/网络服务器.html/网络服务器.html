<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89b8470eed5b9ed0561a326fca98afb1fa58802660ea9ec96c7b6099aec85af2d73282502a3156402eab41a312c5d0db9380c9e8d782d3dcef2aa59263066ca5d119b4f950491cc4fc2f70e1184d3ea5d2a1898c4974bbd87de6277399d03cc7b8981cd196c4c317ecdbdfed84c6e95ba37c76083939843a80766c7d9e75b72d95b747529ab0193e77ee44d71c1be403192cc0fb6baf5d3eba36173a42e58863c1429272d1c3795f99d0e4d6b2c4229a2277388dd83167ff9d77c02cd1611929b5f7aeaf75bcf8aef55738fdd9e2553343186100d14bc04a364c5abbb897288d67c2ce89f1b6b0974896d8ebd044b70df7af2a62528a064400b1176c83f78fe7389c164ba26cb4d832bec97d7afae332a9ea2ead7b08fa3940f6dec13b69bf305bb4ae88d7ad8cc0013be00bf678fc588bee5e0c78d0890a30fbf8c73d48ce131d163824463f9c18fd644a16bb3e8eb129741d2f7d34bf4920eb106915b95db3a08709e65e92d5b1cb0c19c41deba1dabf1b5a15cc3cc5e7c4db0cc0f92ac067735e555dda9755739829384df70910f498b180ee6c7c51bd3bed954f2ef7cb335a3cb8cbac1aa5ccdd207dc7885f8e0b26782a5c6b3a88ff5b9889b0f2c3dfaa781eceec4ab6782fe45a9e04b2a19a30a3af9c68d8b76d25854be7699c3f77fe07a2ddae8da36eac800b8f1f30785c401736c3eb9002be6f3d50829f6c0fe1fb51560059f29378240fbf3aa2a349018bfa4f88905600afe4e0fd04a79e6d4de4c087dd70335d0882710da114fba55723e366bda6bf6b9d090c308bc8d007fe834e1482623ceb6460e698f919dd88517a4a6d60461e29a23a99e3d19bf214d6b13d8ff9d458d6bd571229165cb467aa538082cf240b9ce90e62090a9a8e67fb7ceee5c11af72a8559ee398f93d26b8fadad3c25dc5a02ba207d2b2f52c85bc35646ebb643df881d41a52019b5a7a4a2070c4adbd0dd9a02fb1fbd33075253a3053cc00378de2b9ad065e606ceeb8467a15006542229023cbc409e86fe77240928f80db0843024d771eadfd9dfd25d6c9022efc0f64ce305012a8a9a2a5f3b35c861046fae19a864baed57ad276289d84ac255021ad55fab33291578f40640fa4d963fce85ec64f468267d973167f14fbc6769528ec89ccc5f29045bf2996824a7ffe400d9f9f0c0325dbfc286c4abeebb2ac02c4c7b129207fc2baa97b1fbeec8b8baf5aaa5a6e404622285c53b5fdfc110b3e534a99dcbdd05cabaa7284c12993d39582b1212660ff1dd3d0d86fa24c6e257374a7f0d950b42f3c503aa70187a22fe5e2f932d030da75c819c290596cd63e0940902e4cd7340ee9876761800eac1621bb30c4a730d0fd835ab2b518bd28b1699e24c3e9fcfedc7b1c6b018d9de04cb007084af0a9064abf00b1938e4805c9b712d1fd11c29e5fa954b740e151da7c4572ec5fd1d6eee17dae193f366c890e356dada99c3dbdb9c217a3a4a361b713eaa8e4551babdb0ab3d8335172c04a5b504edff135c272b487c1ca69bafc32d410f5d7a86d621c021476ec76e9f5a190fb231299203d71f8b5ad6042a804daa05292808eaa3e19097d9c273ce4a4345c7a3d05655a832ca454c633a8561100547e66be5fba66933fcd1fa1aa6dc06df33f795cf2d5860a162e72fa21a2e7a7c4d4e89341b7b9795ba682eb89f5d632fbd539e43b77486eb931cbe79271d7aa410acab0baa12ad1e5491e8e44efc99bf97ffe6f70702515960c9fbd226065293e4cbd982dfb2cf6ead3554c57b2c7d87c62e1c86adf4a67ef0b9aa9faa7a028f5488cde8b324e0bb5c478d40773aecc402be624dfc22adbbbfe91b09ae907815067a73b020c63f7325c80300e246a686f1f145d32d059b9ab62a53f8591cedff74099473faf80e75e7e5d7a420be4e41764760cba2aa33554e4948a96673f38d260229e30ff258a14f2079d0322fce4c1a5d2456face807b377e6f2fff6d92815650c778f42766298fda5ef7fdcb0044416767aec063288f031cbd8b21cac9973d571bd9d2e54f1dc01be0ed7df3cdaba3019a5961b8baac205938a98bc2cf4ed0aa9ff18bbb5aa09c0f820c86578581afde25378cd0126c4a3ee0f709bdcbc41416de4421878729c85e97c4022d19b3257a2984138180eed969861a968081f50b4ca7ff932e405c28e1e5c1fcd61306dca1c23c1f4be7ea2cbd71882742ca11848d997361eac04ef449fab70ca57a36bbd192be1e0b9bb3f8433dd629b4068ab16d7bdb9dd2e5cb150d092f77efce674025c51a7f3798e6e8d90f6a8a854c954c71b447f177524caee4699be623a0e8d8fa1715077b2b3fa647ae807de89fc7cc7cefb06f30090d3e5dbdb597c30656f4a23d884f532f56402108994847ea1520bbd0e6adb3dce961180f9272f6c348f6529e15bbb5a412ba8e3dc17c1a8755d49bd30a1c9d4fc60d0a80a3dfb49f7b3ed7d1c924e7f59c864163ce1e1afbfaf50a89020bcd882ab316dea05c9960336f6191652f4ba1d4e8614fe323ca9602b51ebc2b52adb7fb49c5e1d944947062ded56dee5f6e29e4a07e493a4db580ec272b5c196e102711bdc884f2dac90f1fc0c3eabf4920bfa2ca87c5fe1870d59b8e42fe88e76a33aa975c382f18b37073d875b2374a8fe963e674090a3b2ef8fec28d30e9ea8256fa238522d995084332940219df2174ee4b07e9cd0b9fbca2ae5184dbc014a1fc5197691772d57ee9ff8da0ac72c3765f70fbf7aeb45eb5592aa4d0ad4668981e3e4e58d94365a4dca135b2d75fc5f5a617f416b8b518dfd0d651e99ee9da0a312d0e5da145808930095e82500cf6dcc7d3373c13f2988aa8ef05d09db5d09f0c0511d5d82be69bdad4b9fc071c2970c18bf7a35e01f967765bc4edb48a9a6a6475001c7fbf0f4e30ba450560b0bc036100aa74b595fdf0bd6f9cff24be714953226d632c707f7a03e63b495167fa376ba723ff47b69635664fcb5e07320b8d49daf4a3ac605eb0ec597901c86ad4f19f698fa7cd925e5e63bf6712e6a1e041ed55c8d8346a46cc7bc3c501c912cca0d6a99aa1e748ccfaeb52bbe74fd2516f07d79c6c6aa50cf5b3c2eb1c2691b933229b4f34bceff95580f7ca0d6376ea51f1ad96b52e71667c3bef381f6b498ba32a5d13460a662603ed7cb334a0abaf4fa9206b753bb564aa4c1e28c17fe0da84f1a1018be701e03041222747bd8193dcbbfcb3a859ae8bc0c9918ef4fe162de5f8dc78c04ad25add282798e4cb3746a05657b06846624b0b6244d704b50bf3682d01541ea4aeedfce216225dad5d310ffb5526b3af0ab7909931bf535f7655dd4ef734fe9d85f76280467c9bdd6704d0300c8547ac64d1eaaefb04ae6386028842eca5751cede42cf46acfd23975aacffb8eb490f9c304b8d8683756ed912274fd3648657ec5f8412b0e4741010cccff15dee44c7f01a0d23cb8ee5be16c691b588e22fa154e32bf3ede110b557d5f3b4c7aa7c9a473a627955930a6d12cc3b604cdb938727d8a1e4d27607d4f5be1228edc47fda9a90edf546d673697c6f7d40fe40ce947a44a13023fe01ee148c0653f30643295eb2dfe63952e94b7d34b037e978b065a8e16b3394709a8f4e85e54e916510deb2ab2d0b78591e5061f453ddd6cbe40012a5a58e06e024735b25b2542c1c0695b526a08e0ec4d375b6c7d1cb6d2a2f23d908c23efdc8a15c5fa96995414156c8e6fb14de6f35fca4a7e390ab08aca13f4179d2db750afcb6f7f68fed74df17ff8ae7bdc3c5e2bbc4eaa12e93e6deeafb46d7c28b3fc00c2b50b884e288b4c7958b2e64ea2e985a19168dc2b4cc150982715f857565b5c54b2c6c973d7d88e5469f17367604c3951644836bbfd88952f993d82d0aaaa77161d18f5f80b3f6ca563d77a2fdd203ae67826b0200a240b1c9d1899f35d36f2e0674080d01007052b37ad84b2a112eb5a6945f4ae1d6c4db03067cc4f468f2e4eb1987685024b6ade2a97ca41340ad6edfead4027d59366bdcefa896f791534a2b4cfbb1c5d47490c60e8418ec40d5488f18ff3df3ee91620b4858b05c096adff272e570159ec8a56ae2748b789bb3251cf35c5681185d5cba52657291e72a5c3eeb3ca2466823febd7d021bda743dbb4709dd25c26f9a100ffa9988411ca6207aff5d6b663e83c64864fd323ef772cc399dfb5b4a90653d5db0c060818c69c8619d4007c9fc8e439fb058214eb03f60c71ffd3b07f10cdcaa1f54269837efd68fce4a85da78010b00a6ca3e5c2f5874678c86fcac26fc3bf8790061d645d096dd5e6f815491e6c066af165d4babc341249a84e3d85d71fc0a9b1a8a69666383a8eb26c26bc0ffa886d36a76f5c5f01b1cc9a5b374c284ad9b204e76ff1590654ba58f756dc8f2ce99c585157f816fd10e00fb16d2fd59d6bd89c1529e7d4b676ca9ea008675357e79264ad3bf4b63a1aca784c0f2b0f1f7e2aff2a8696d8e45875ddbf33cf3bbc033ebefc1171763f7395840330562e38be0778c412eedd9f6b43d8d929544dc165ade015fc682aecaec0fa79eef6baa530250806b586be199db9388cec77de6053af6c3ceb5704be485c2ec0145d762609859195f3e5d0ff2ed53de51d18d25637a3e6b6a7e394d07253247cfca2a3ec24af9be7516c693c2d8586179d6caa2602ccbafbc2ff6d58eae63aeb3832a87efb25a20f7f0c3724d13ae7cb186ef6f79dcc7eca81dc286b137e8a862794013dfeaded76ceb53254059ad0c10d9ab7d606613e00c48f6b1ade94f29c26b8ad1da1b78288dd780a14f0b13fa9e75647521e652d4e8ae5bd54643813fb49bdf74c2b59ca70067877c1f88af13d8ad60339b413f87f04503fe2bf63ab0b0d94722145b4106451f0375c0c07a70eaca5e2f3415bf2bef623ba31bb889da88b4cac43a100147f72cce8949a9d1dc33863fe556785ca4208a374eb72defb26856e1e81c2b9c4d18c0e042476639477a6c4362c64f1c45d683aae7ad9a3067090a895c9d704402cebacc6af7b5e89ffcd94fa042b187b065ec3e096b0d1a31197078f7859095c20df900c5c14783f3074b6996b76fae17e8c0b0f1b88009df6fd559cec7ad96cf80bb9c7c058cf48425f61b77cab700ab1a031ef628cd3f0c4fb5ab5d28e560b982f1faa46a847a8c56fbfb3cc22ab4935c2f8cc867831bfefb2b6fd24a52887c08b2a263135a7a24ca8ac69269a9457c4d30c2bae60a11e34a228f042ed234b27693329a91486a2b426023271a18b9b8dacc3866e1bc937d6d7b0fe24ec25454476034a83967d1bdf98904632b182fb37f31ce8148ff988942c0a537af1dfac337f479ac06437e5a56e4df21ae22b9f6b9374eff99bc80902c298580f1f30de955d8b13adc8f1367efbc7fc78dc71dc8c4d057f252c6cfdb8fb95d0a01d08894c5c0f94fa27da7675c90cc69663245056ecd9d7e65cfaf9b64359055aaf39a9a4687e2bfb12c7d0c4502dc63bf812b5fc4e53025b9bb21161ebd42d314183a79ec51675c8cde3e0720fe1fcf83a5fb868a893eaba5d8ea9ea91e5f16bbaa5cbd446f632c21997e279ef7c03565c19539ed96f7b1ef0575d68be39277fbe332ba780d3fa7abddf0b73b7faf4c96bc44541c5df129f8dd144ccfd156b5999813551abb64b6901bf7560bad17ddcec96ed1dae4272f04e02035be9406e8220e0fdda666e40c6f93721762ede981baa2da8c8f36f8aeac49b25210e54ddc7ccfbf96bd4e54e0f83f032f833c8811971972c1d85e3c8eeff2c77db343960abdad681867be0e11bb8013755ddfda1c9d6f06996337c59ad5f056244adb5292fb6d4fcd8ca8719779de7459f875ac2580a8292ccfc0a745a65697150ff4c1a506dfda7360462e3691133d7998d399e7c0c319485dd18aac14229d7e221202302edc6892226abe817ed6ae2e980eb92e4954e4b4eb31c2fa2c6f9c09fe58caa24bf4b362e54e9cd4fb31ddd6a3abfeee0408bada68a8bb86f4854abf7d85fd9b9b825b5e0263b1acef3db06d696fc638a762297e88240210f5e2dbc4e3b89164824933888375b5f59fb71ce9d923a1491dc010b200590a7289949c066d9b376cde4e11fe2cb23c90b24c7b4385c01ffa358feaf07f547371269411e934aaf7b5f82171f578fcd63d07f0c411680ce626ce0b32d77ee5cd3a55ee28fea56fad192c1a7f41e1d8fad3f3f48347f26953cd1d8250072d80276110d9364b880b4a7ef6e9ad258cdd789c1991a1f7c75c98e736f5cb7ee7f9ebe15199b1aca13d7f988bdfe99e7bc5d74f8c3a3f130bd48341492150fbe9c9829aa03a9e79547f4741d2ef43344be8ca06bd6c9c7e7824863995111d38874c1cfda2c403569372188f1a02fa2af3ead6740020e39b95baab4f1be3746270ec61a5d259c5b8048b3e2341f85210193a11f3a6ffa96294314fd2bfa6a431ac84435aecf5748565173932e962106a644f04852fda620a0064fa2f0d93a8b00d2176b7b9816ca8223ccd62685ede7d1894b8e21c6a689c0d9306f922484e435e38802d56b6d770b246b8511b0fe6b8126333611e8047376fb1dbcb6f10db9ab9960a87db0247de184ac59c72425ce811cf0f038c4c919c58f8909f04cc88f651aa82ef190df2cb747b05c93576edb98dbaf4db22fe97efeca499da3f275953765d6257e7edad88c5714970891d4e9cacb50c3acc39b369d15f52223c8b570e4d4e106b48e703a23f35e5de85b085258476cdf1195deb7d8afe0eeef378a15b1832446bf4c3775769df1e87c13ae43646263edcd594407554fe0e283f3769e3e990a919808295627226462f601357f12edfaf10a1c327c2a1fc195143984fddc76b75b07fdbc584e384a2d79c3c0a4e5560e176021f04d3329d20d69d2eeb4b49ee8d9939fd3f28e211e6686119558fbe34de3c388a702c38cc77b40bb5086e18c7659bf7e57207c6b4aced59edb7aa17745d96ea83b7d2bf5cbce50f3f42bca5b1c55b0bae0b738214fe25b64f2171ed6284ecd8d80f30567ec2d20b83a9fc69639de3e3bb99a3afbb0e622ce573851f2b23301a92d65456e20a51e189ec2df9407b01adf18e16b017b73eb31b7b69e8ee887fbe73da531fa42b8fef3f1af78a183a155eddf00d83ac1296f6884e0fd8fac4adaee14c2a1560fdd801e3797c72175463e98f0762b9e4804f9b04d6154d1bc6035f1050f63296b02f1049a79118664ae930a8315371cccdac10ec97087dc61904933e00d9b739bd5488917e8ee56ba5ed56593d79931ebf57a7e218a6ff0bfb723e7cf2a88f88ee61927f4949e06981cc62df39b1d8e7c6e7eff9bbb35cb169fa4e1428810cffd05b6aedff75086a038f6ad4dd2aa91d26e1e227f3143d9fa72f57bd06c6bf8df26c954bb687c8ed75454290ce5d797b6f62da49cf27e6f6ec4799ab1ffe90742a1ce3eed2d0c0bd522a279d78e9009754ecbe4bb27fb0dc93e21fbd7743653432415afb12fb95450c8ce141b77debb27c9fca4485b735148da88f2870c6c150f0dcdd5a775af1bb91f895b71c4d35965202b0a6380e358ced4da4466478f2e19c2bc0dcb530082551c635e69c82f0080853fa97dc69b78c70309d148d13941ab1569145940f5e1ba3440cc4216bb63c99295624f2bfa98d5b4220db9b6766d158b8260328eeea283c94d110926023a9ef25a6a4b499431530b368514b60d26d53f0e3c5e607cd4c3ab5dea972d27a10dcc4529ff7437d6eddf74eb9d04d95983238708c444bb6cbc1be289ad96b1a010e02ffaac27262d97f75b3973f52a9a928380afdba0b97e50f28dbe1bbe6f0dfb651fd8e07360218e0ea1e306b4b082b2e6723b2746504ee492ee1fd6c7f127fcc5c0d90db800fac7944fc460e2d68e8628363a766c7ffe7fc8e57ce6b42dd56a08183db58d17624b978401add5e39217a7acc106d536f288606678f3bc77030c7b00ef704b89605cc3cf9ddfed25d26fd2a8dfc7147607eabd2bb504d82ccbbc0beb0c905235b73eb6add279deac5708fca13d8a1b79e97f83636adbd5df670bbccffbe53b0c1c1b2223254eb4190bbd5d3cc4b663fc6e8a68f067f97ade0161c6d0a86fc4fd827ab1703a6505452ed2596d0bd08a8095a837f2327ffd2587c8a63b30c1160ecbb3175aee4041c5d25274084770bfcfb01d8ca5c28928ba9ecb089464b44ec923a05ca9eca6b553f3a2becbef07609f5444823fffa11eb5fb41e6c98345ff5112695fd4a385f292267a412b447b506f00cce22bd8046c07a09c8d275552d353e1856856c882e2c9e8857980aa92ac232c3b0f4454850a38b3f13b4645cb7f625304de7dc70ae59f2e18b8d4412869e2e0da27b2bc52f064b00543b5c6de71efe875ee702cccef79dcb9c8777b1d8ae8228b0be48a70d37cfdad0653385b6c9ee1a645a1ee77b4bcdd276b883aeb1496459b3e6de17c0ebc3c9583b7f158dc1c6358c5b794c3c8ad1a95a52d0ccd8e65bd458071c12d41b61386d559ebb5668c00595fbf45fbc1c38eeca1b1504d64beb6dfe0456c0c31cca9a3b8c365ef9805c9b225664b78f5fc5b9c303beac579e05cf9033ce8f5712e2a164ee8bdf35f168efca8610818ab974174239560cefd18d8eff8f5293de388d5d28b8c7104b1091a3e7fdfcc83fe4620c9339eec65154242c412c5b5ae2953d980987e2e4db3261894bf91edc2a596447fbd723ab55cb7929fe6bb31f1c07110dde13e39e09ec1628ab7be93112c4f5ac7936ea851541d766cea3b9129c2aaa7baf1320ce1a845aa3b865af7257f46264f0c34ed220a55094d38d535779d85e48862baabfd189fae70f2fe755e474e062380ba6e290a88920e1478a4fe71d558c4f8f90053be8df6142e3929c9dc0809868e97b9bab7f4da2efb7641f535ebe9d6ef488c227c08a907ec8186a819635a07f9704fff034e696a70e0d723d4ca51dc7d1dad6f6079fc10abd7d4f325b85a1019d6c0ed3af491f0e32231e3617393751bd91cfadf88c694a9b3096591364dacf6fa7fc64f45cf295830dcf4997632b350d81ca91443c463a6d4da180c98e6d083b95e58a38a2650757318e47a1eeaafb1de9a4b78684ee3abcd99d48209948a6163e4d3fcf0c9614b238a7d3061b4e545b150651d41f5810e17ca7e3ce735f20bafee323898b72169ce2dcfe062fd4ccb96b7f713151aa99cf6db0e2e919c5460a2b65bb75f2204f030b020dba2e64b85d2bc28f527602e89cc2c031db9a9ecc6df731c1d2df58061985297cb701d2f23e793a2ec32015eaec190a9d5f403c98b04eb47e14d683d36c65ba7dc853bc52d5bb19fb550023d3e2983370117033acf473afb86662cb8f792dcabbe1fac039a69bf45202e92e659d3299b810f7aaa3d3243cf83b82a76bed3cf03d4e88ff6c953398e15f11fe299d346c97895405fce0c53122ee992a1467f7a00ef595a4776a9ae217a44eb206bad24573c168532023a1635e499fd64fd5adf5a18f06f70181886dd0d812bd967e18fa40acce5aa1cd4b49943eb47631949bd0e07df3ff23aa820ade3e1b50bc8a42f86c070a1a56bdb46bc64e1cb5bcdd602308188adc4df9c9195df6fb3870bd8ae820b433c67f8d777d0e6615f7a8d5bb96433f411ca46b3c03a610f406e9173d6101a8a8b110f64cf641f85753309147b6c9c5997d23c131cbd941a0a4921c2483f5647ce12e29fd1aa8132b8fe4e5bf626472fc05ce170370e8e9bcb2dbb5d210132925e33a11e954e99ed8ca26f9f237ca6f53e1afde0fdb499f8512d7ee5c9beab7060692cbed5fa86b5d5f2e23da9398a4f4ec462612822937668d50e9ca489164bae7ef2986d7ee1191350d3a406c50734e57c7facda1699ccfe0e67832e1c03e8c62418f7b3ec4f31bf4844abd435d3285eab454a57fff4ce8900e6ad40d4bf1de8c8d438c811aa836edfc55e5783cbb7a72ed71e582893ca493d2b9b19b492647cd2b44fe5d6aec5b8cee85b76fba36d69084bbc9d0ce4b83df26d3fe3ba96b75efccf09f173730c6c27f9df58598116e3bdd6fbf3bd4731ad35837832d6d7df89ba839a77aa73546a1aabd4a304016d86b9a25678340f552c012631194fba2d69e549ba5d26f953e9c2027c6c4d59218ed68019994db3d13ddcd9a7098a61950bb6abd725d1127b76ac12cca4760fc3d3f6daea01964c30ba5a8432ef5500a084c9be3e1d9bcde60b813646bda94a62b8bdad691379a7f65e2e9ffb0b5e2b66a451f2e1e7b45daeb522176a79d7ebdd4279f3300e0b8ccc70d8d0ce97bd1003042741360a6b28202a3fc44019efa81c45b5cbda6b71c404efdca65b8fda07fabe0a4a159846c735e118b51aba9632e3de650763e14f313372b62b4cb43d99ed24a2ad27a910684cee16b2fd44e88f1672005369065fd361af6fbb4fc6d992196a529fedf48969f8f680581f918ec7cbe12b3d991e83b0b6d0fb6ead3c101fd1dab62ddcd15fb1a7dca1bdc21a40b6538aa53521b5f76ddec15369d6979b8f4eaec70efcc5d318a4f0d618fc3911e6a60d0e319215e0fc489a08428b0faa6fafc57252f53e5ca7b6207bc3e521e7c73d7284ac10d8cbfd08e2786406c54ac13673820bb2395f4db9654066765095f4b43ad305b93a4bc659b9e61ab4242ac8467426c553d517eb571d1a736affe145a7761d393c73f3626bc52930db18773cb81b6e6929c947d72ea2ea48b60eb0e38316337c223e6aac8b9dbd0b4397d23b2abc238631d9e9d25453c50d2c4213afe7371f4344631afdab1f1d30dfa7a6c4131e9391e3a9250ba9d41808be4fc4996c02b8fb4edd11ce8a4c82b49b97cbdbb68b27602760be8b6355739eb720db715a8b7ce0d8eab1e45c5c0f25363de908de32430a4eed49dac24893c9aef96bdd7ae75c015cddf96b508674499ea9bd07711e2cddfbd4e3709a98ae15538a5eb007c779b6db3ee8152de7506ad9fc9063b240f01778fe1a1e94c00059c7cccd8b2dfb36956516500fc89ad7003f89d37c1e4deb70793622b074a74aa0958edb62b6ad8c80b25ae7500122504f0310a8380195f21eaaaded6f45b93b1e33f4d9ff602709cf18a6a96dd28503691d0c8f13599cb856f046d56f12175d054c0ec4e9b5ffb7479d7bec05a4b58def54d7cc7f69bc3a0515e1da7e56f892971a5de665f54a5f7f58e8aad76f6855a1d926a3f5fa2221772ff26ae9a61f991fed3c65e6d1b150c8beaf72fd1903791c7b76ba26601409ef08a9ee95bead6599096217f78d52a71df33a4231c6d2e07cf3e070604c2ca9fb5f814b1e5a193bb0533fbaa165b710256d1f2c0f50ce38cff9c2713f9b1b3097e54380c62d56d91b25971d1fa4cc1fbc8029d0c2930a57146d9380805d446be42b99229aac4e7c5619df0b8ce67549280362030893a8db986f98cf445953c861011c13653f7e99eb4854ad31cb78a3055e3f8380f636b4d453124a6ce87ca6a61895a2c5d2d10b72ed9bd198c373a09e900a78936c0f82f914f93dbbf9d8ba9cbd4e9fd980f8d29a21005bb712c701fcd34f9527a87dca1ba38ca477b8bfb536f665332bf47df9dc90d7e8123c190aa5dae6f0f5469677cba44672341fd0684eeac2b6328f999bfbe60117207aff7bcb90d4d2ea8bd75b1b0b61fc9802f53c72404ece1358fa1fb282c1323d66c497ae7d52387a3eacf77ef9d8ed7fad8bb4d05854b4c4e9bf0194af06adf11a9be2db0c8f221e101e305e5110cf9e50940a6e811f7efe0cf796e047e85a8d78589ed3990db09405637b6eb17bfe0297e8f6f99a604dba628cd365c0d386bd4dbcb399931d75a0c25a5316852b9fff0d76abf3ede4910b38ea6eb6b293bb325c920d07bbf2c236d1ae8be251bd60e20281d0584dd373e5994c59777432f3a295400a0ba21988f36db40ab81c8a304c4f6e352a902b79fc2ce9a0f77ead42ccc2d7daadbb07356b12a7447b38fbbd8094282bdcf7ef3ae59d047d122acc559cef4b948124270ed0aebbfd8d4bbf11317647befa3dcc3a505611405b7ca2a8ed64315aa5444dc5b140714390584a9ed6ead9d319330d86d86f7364fb8b33ef93abbf18dd8aa6870a5730d405710e32502319c73a848a167b3e5d5c642e423196525b9ea25dbdde24a88f575aee13ac50e7b8ccbfe14f98a3a68712ed941ce2a9ea78bf8475bf48679fb7d1a4a96512f3539714144e7799f3e12933c167d8ce7984c171fa71d42a9bdaa16e11687c8919fc9e95262058837503ee876745aa0d9e54548f453e870b2789724232215211bade577f0b8fa80419711a39cd059595960d15eb141b98899bf739237f7cf950a2f467e5157c28aa335eb908033fd79b6dfd240b79cadb9557360a35cb1cdf5a69da818e12347eddff9c5db4b4fc907da188016f76c6f368ada3d5170a34fd913a6fce4c020cf0f6b7ee8f894eda60e18ff6ee8e165e045caafdfa44d94048476f93fc8e2aad85e2466214b251ca35b42526bba67d112e6358a85115e5f9072d892d946ae34dd2d2954740734d3feb32bc59b40f32c1711a80ef4ffc8f8d9797c2fe29ba58f2bc860551e59140ff00391eebe8666faa065a64150ce0f9ad2df4c71be51bb131e1f666fc44b487e77bfe1c5219f84eac104218a3423fcdc3a52925a352d78f4166fd1008969d0fc32de94b6b1b510d61ca75944afec4568e6e69600489c7f0145eac3f430123f68af4f0dd61c5d17cf1bbee2adfb87045091eb494a52824c8b345ed9893e90460db80b5812485345b008d31386da6e7929c33904e723e11af46b4f5f27b3ebd132197e4dd54f87cc2d526330ae29d2b36c4e6773d53dd295316e57d5e9a676c06c34405cb6bf7647619811e90a541463f2793a00718286e8e335491cbba2f566aedde6ea0fb38440c5b5194ced4bc01af9106d4e4f055f71889548813d40a5279142cad56ad930001c970ff6bb1a6ce5d1ab25821d05aa465696007329dbe2daade1ab401bd95f4f23591f299287c81d8015d4175b0c66db43aa44661ed4faf423999f5dde25481519c0022d5ca03222d825e3b028cc342a82da98740efb39d0918dc1260aee1d12134a7711a333054b9dbd5ded9088dbf1d740c5c2e1add1c9b6555c32c9b707d100ecb2c377c0d0ff11caa9148a7b3e0825bde3e29c2adcc4ffe0465fffcb6ee8cddc8213becb48b72252e222e3a238f18bdfeac104f727547257e72899eb805634a4763972d9cc76af8228db91cfb901e99426418364f4e8ab9848d86913c9334e793460e3ede6252091fde07a51a05e0960cd02ee64459589fffc562175a6fca367ce0692b4bc175816266623f6363ccb4be34524b9897d4704e02006c1d601bdac87da05826346e94fb65c29c1e21219b1a667c277cfdae5c5089ff258c4d4f08d98933743e9185228088d3f7622eb8d436c9cc4743b78e4aa47773ddae592259d06297fc312ac2c9e46f19fd5a76104b4e490ae060ba11efb4cb105c574b9c9d8176b69f53783c9ff82d54ac785a8ebda34f80589f4069c7e5100b62ab76b26f82da16c1324931ad64cdf07c94ad0f3e25726e3a7754047675eb362d2b02f84409a6c21a4c95d53d11e2f7ba2d81cc1b290771bd50c5984fbf905c103076a6b68607ee7550698c3e1c4fa78db81b643688c6a2579af8b2feddfc72d964f780b63a327291aad5ad8f18c69b1ada2d1ad150580d0ad41d3a724b48a67b403090a3687fd0034a184f6749c90d0dd0a480462dc84e6532a4a4aeec302f1cca27c41a66861b7a73a319d06e7e7ff80bea9b243e2ce73bd8d33be3051df96157c2370333e97c3848f4e2704318da0013f4bc9503492f0a12dabb5e4af635b11c5b6c69a3840d6875db4605c1aec8a8fbf5c11565842b2930ff5ee0e33aa35fd159ce30942236360ac525c399ce1c8e9df3ac8b4f9e4a0159348cf8effac74372852b2753dafc7870c82abe9895bff255c1824ecbde11c8731cf65816d55e0ebc5adc47357868a921d51b8909f20a2fdccb0256b66a49a73f3fb7170c6ab51874964d3337e2c7660b1822f3c6ebe78d145e9e7d2d017274a2f438ccba73c7f1d916d6476b884e00eef29335d9b8eb6e190ef04ceb1c4cd7166bc3762aded2d99bd03b6e0463f2ff5181ad70afa03425c5e61ddd6cacda16cbff74e48feb58941a1591ab28f1b204d7bc4b060f1a7017d7e3aca5fb0c8f1cf73d427f0fe249a84f468ad8b2fc9663ef8df69bed4694e88217004fb7dd078776164cfb663409db892e0b776040263a0ca35492e80476a5322bde23418c8e0cd3e3456ea600ac16ee58cd93e13fb371b4bd96ebe97a818a84a02494a02bafa520d7bcbda5f901a83d442c6311db109e24e0bbe785971e13dc2adf048e87c5d3a2ceac990f0606e942c6aee173dcaa029536d145a67a9797cf16ec1d5b9490bf69d04820b1e377204596ba60de8d08a73daff63e66c4cf6edebc89d729ba72679097e94145e7dc6022e3f1ff7135e4b4abc4c60e167ebeed700ad0d2e6feb081d6f1063216adaac664675a6bf7c867b9f336f1db193f30d2090a8b0a3ad9d03179ff794542a4688526d131d561697f8209c10f1b52aed1a530b1410cf948dda86b0766fd9ad37c7a66a2ac4faf02ddbb890fc8b77815b79c890dc0ff4e519b79adb9596251e3f991bcd2f49d06b86ce40a2447c3adbe59de829d6d5139d4bcde89263583e27cbc922e157ecfb3c7ca95edc57fa7199d11c4ec0cb34253a96d814ea79b3fd23c869d6d513f09673a807208f7795738e77c836b8b5e80f4413e0ee8b36d96e3a3076b1b0faa30869b95042d70666a25c4f7427145e4bd4c1c723222fa17c445ec2dffbfe8d0c599292e140ef7fdf0ff651b0c090dcd990181f938a46959c63c59d81b137b3e9c24c4ee32384329d52bc0dda5eb65a01b5eab2cd15764d4275456d8f9e4257efe12deb74b70e7185dd18e54792dacdf2e5d854d498986cc7f21c53a9522767cabe55e4b66d363f370b2712ab036af3e91af059a451f6af95d06325aa34173b5b393fc9c402574267132c92a515fe0a975716a32fa3ea2f0fe5ab48a522cc4b04cdac9d4a730185e69a9b34789ffe890d80547dad8d2cf87af8728c0990b1bae720f2ea163d32376c6b76a8a1679536577e29e30daf008d42ce4f3e7c8cbeff96627bffb70d92c0c1e8c7adbaa5dabcd18316c85332e737ac2619c556b3722c045587424e539a1ffa8d6878aee56bb3a4fd96d8ce6814e6435869d8c5ec8d5d639c8ce285e056d605e4e3e27bf922b1199b5aa4cd24cfe33b9db8ac958660356eaacc7765b007ab2795a838f5154132dffdaf6f6f4bcae2a30cc1e02d47f6857419892f19b21a77f71fbbd39be9c676685ac27fad7103babb2b007611e4e958415bc6045b4348f8daa030cd5bdcf75c44be40539c0a8dd7dbe63ab237ccdd8dd225c4dcb918425a2d7b835683332ac91f750fed87b68dd3df625600b06d3aa2a6285eacbb8dce501b1f517d3e739565a2a3a3dce718fceb019ea44b8e0e1c48ba906e10676b3cf898f0e6d2968d5c8c0d14c3035c66b7fa3444164540fc33c2cf3b05a601a55a5858f062caf25660fc3db7eb2da368926c9ddb95805d7b6d8cddbcf3295951df2eeb1024688d6ac4608df7053f181b317a0f8939e4ce4bc7d614e334e7ec62eaa6adf6b93cae9464f890d09411ca9dbebc3f180366e4c65555b5790c20f5021075696ed09c65c7fae0983c07579ec8fa8c8bb29c143a177d996c962507626cc59a47643afa2a52fa6272ca61584205256407e1cc7c5e426b36ed05b033583d44327d00b305a81eecc3c953115d1c873561fe42eade37cd16590504b8f3f98649c09bcdda4fdfc221cc2874bae50e4e82c0d26bd2227c3304952c5bffb5544b232be6f097e5af14868a4c3114ae425b3ab45d1a66c274eee436b134d9a55db1972e44ca24ff0d0eba761056d51a4be61776a5a6177eee9d6dc8d35430e1dec582bd0acf5c89ee33aab6aabd41427832bc02c9ec76ff39dc1e3166aa840276867163cf5ed5ab2e9700196f9c9895f04a175d54ab05db050d4f2ee0d148a2af78153e45459a26055ae5da96c378dc96314601d6ffcf1f2cce49a9a9c209bac690baa7802ec5e5c2ba1d5bd035f4db06bd5517bc82aa1c2aa9278e52e5ab658ec086a419c3857e7e6e362a5930026c1dee919541aba959825107a350cd74d17329e65ca7978de3a9820a3a82d648bb8871df72ae2a16a2fa8641ba6c6ea8b6d722ae43df95ae57de341843147719811bc65e9bd9ec549fe349cce5fdcbeebd4a76c9cc29cd3de5dab6a9376fe4d3723c4d14f5ba5d09c192a5fe9b314b2b054001984dd2a6abaafdee83dc943ef781bec59e6aad27b497e146d656e00b3b2c828ada217ad2c978ab391d02b48330045d6ab125bbd8a21881e5fb7fa1574ed9532b62aa7b08c3119680319f9c1df726ac8c01576e1cebcb034a3d3c33c382b593a3da5c0a9a1f0aa4f0ca31339066db09e1b16d594e435dd8f261f11f6e4e52b4e694f0761ece9219db589392d25ede405e425b0c217ecbefa12d13ebe3f461c9562f6b9cd8e1aea53ab11bb32e98fa0563d0c9df5909fb92d8f53008112de9ff49bb2961cd923143a711694c0056a891f8609","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
