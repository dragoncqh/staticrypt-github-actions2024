<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"258e5ee1c597df6b1ee683b817f6170ce3d9cf5229895417bb89822b529a702e339bcdac46803ff40dd613dea791e45a2a88c043acb0c867850f2942e33cd61a224200c1c08468abbb0a8f8bea1bf2959782bad031d560d1aa022183d9360ec18915744ffdbcbbd708d5ee0ec4567fdb91ca957cfd468c053646efa5f00c4ba66366a6a9087eb39a0b1150ece30a8c944c55f748b39f7251bfd3eddac846b121abfbe70939d064f159bd637565440a046c2f832f653125427328b1fd2bfa334b0e82663af4f9d1ae400e2f9dbd7299672e7d8212a6ce9524b67aa0b25276f8a3a9b1ab711e857656ba3006545451d88a695bc6eb10254773f4d3ced270e3e80acb437bd89b8a0b89ff0d59aee50224a80a1ce97568c68a9371e3ec7b6a4af6ccc0c3de01150cd1ab154527bc91097dc2d702ffacc276a008923271957f677da50bc7e893e27183d55cd29874547422dd798b6c7809dbe1495f0b12f7c7c96b6596d7f8a7a1b23860e7957ddaf2204263369bb84486402064e0c627884452cce0143a3967e7eeab181653b3a043c41a33b6e87ce9eb3d8a825b30ed9943e4a99c0bda13b767343ed09424ffead7b6bf00f3a6684579fee22165663d35b70cfd53e270c2866461d98587db82a33ace9d6fb415d4690084f3e5870c6ffd8bce4ac858fb422b815af5afcc21bb577ff417991f359c913b319e0cb746d25a7ae153530a667e1ed94afcaf1f9300e15850d7551c13e155b20d2318b2250a66fc2ef8c8cc46423406ccea0bbcd20338fd6e280833f6ec33f632947eb83bed78d6726d3cbbec5f6075c379f2f78f0fa8e6876e7e890e271964c5663ec2b8e412c09e16a4610ab69aff1ee2fa3a034af2c8aac8476682d8d03cf5968cbf02c28c1c74a74a6d43f0bef3afc4e2370051308e288a4d72ea069dca424e1ab9509d729c75d23d43a82378a0367c6b30b4247fa6f578cbce8f70392f35dba2dbe9f365eefc4f1abf8463649aa3544eee2a2b2432b6847622ec92e097c2b9eab356bb1b7f22613bb485e0c3ab8b7e633a128937957065a0273db961ea46fc4fb647a4f0a53fa8ae485a26b851355616a92cdf0f688e4ff98bb054951cb6446b38a801ee7f03092e48d43216ae0e8e2da779697654ffb8e92f1fbb914ad55caa2411819db45e98b79f47ab6d835fcd249508453a80c7e48cf98916c73325e1704e5458a3e2a05e87f2cdf2c58a4245dae23a337b55b525dad54cfaaad309d88989a4861e56a6f83626de65d53b90b1f6a8cd76e1217ccf268e76b233647cfba2eb6b665d71517b7c9719d12fe6e95dc8922b593c48ff9cf23408c8886df0d19c572e2f15a37c547c77a3dc55f364cfa5d61da8b51a19b6d4fa34177367db23306352aa302b214017ce7a2f771b2c0a6854644ebe188d853d3fa75ef1c08128415204afd3824e9ab8c5ca1ca11fbef9d51559225e5036e8e13a063eda2ab0f58ae3854f8a2fb819b348b5caab1a1011b320935957de0958d936ea2f2da0f2f2082c9320dcb01de4729d987bd1f3550dcbeef80c7a825cbfa0acd344d1a15f47023f11757e58ba0d65243cfa9c99226a0f12dea7445435efd888ef8d23e0414f99a17bde65cebd8ed66c4260e20903b28fee94aae721113bbd55f62bfc6d10bae356132d8c6e74fe5d5961ec399aab18d3f837524d3c0add0ddc1ec80907831915d5c289ead43c76dbd36ee25d69a486bb9b927b34d55e6d09ae901c616ef36974ba79292f0791897cd1e42741e068376b0c1b966c09471bc496c3404d8f1b89be55b0c2d48b26caa73b00d0a75a5ed7b6a22eb8048d9fe71e1f77b1803a1022ce4805d70b789fe7893420437dff1b60bc0e2ea87c4c6406c747ffa7456fef93f833b5ccc7bade2f91c0bb1c257969752747aecde5971a4e7814b8e5ba08cedb3902e15a42ece83e20a34be7f9b465eb558a3f4e827c2bb666b1104d749249b543653e44bc35a7a3c1d071d3926df08d98d7f3adda2aaf4d04b4aa3f03e40a3aaaea5502e921b2118ccc67644a1210a805ecdbd28f8239f3f443564b1261194d0959ed91c626abcccfe256a90a80f0388442ff18b2229cf8ccc2409a3c98ed1c356a2aed685de75c16dbf14b48369be816c7322571584d3149f045b480d978fed9c1cc11fd28c865d410747e45f9b5869f6fa71205ca3efb8bbaccf84b7679d26632744c956ba7d8dbec6400b81ed241d766efac1dc8919a04686431dc4833a8355eef87f88a76677e04c354ea2530d62b9a21997458c272e47f99648c1881132d5425cb531adb2b57d1e819c05fd0954f539bebe11c73e8ec63f1c8ba3d8a02c84616ef2980841c0a3dd09b58419fefade47dcf40dc9ed7d3112cc168cd2c3f43ef0bac862be1781e3b88c7857ffb1e04868b763dcc57ce8794e1d29c1def6e6b4661875f66aa66e635c595b38bcf981d069ca6844dccbcba260dc051f7c99fadcab03b2d90fd9f936f76bb28896d9325c7ec49521f95568c5b91790fed8550fee1ab9dc84172e7aa2b0781d3f176bff46ed75951cf6c7e0e5d48ebf91a18b7792a2a24b5728549fa51b4f818764ec0ceee4e8852fdbd0554f5969bf21919e8e899074543e0499bb55106fb618e227b9ac9b8cde53f9142ccb04911c26c7fa250a84e961ba56173bef7fd52d4c44c825543fc649c9b07771a702f3c1bea3be72ab828c8542119ba39ea0d43d363fe5871146a389df3763b7137c86fec70b51ca8fbe016a6edbbc4df347f20ead2330a1e64d6069a03964544feb89618620a293548d7216a88cd7470078ec15151d14c7e445304f55a7fd32acdb1accffe682fe2a368b4135c413f377e9806444fdfb325f867d3c101eff68b387922de10b555622bc2509769a59bf73932b7c4bbc7163343e8774c96fd53784160119844e7fc161b4bbce9c97ca335756439e830b2b7f2b2e1832e810203019c9832ff2a0e8b084b0289d4efd9a4f7c38624e9d96ae04f400ac4c4519e603a9b1ffbc0e5752447af24ae46329100be290fb58a6955162baf35b2d30571cea2bdfe18ef3144543a3059fa01878a1e324a58e0396ee61951a0e101c06d681e1d10de5eff142c6943bceabc291a66f4c47d9f4dcdf38efadf5f91b84cfe971b3e56795bdcedf2eab3e5c93e089898a22eba3b06806e08052a73a4e3bc1bb9d90aaf6705f477a42b02fe728f7acf32ab068e5c79927a5e0802e38e8841f74550f4ae474ab879c13f1445a2c69690d41c08dbb353790fae763939fd4111cfd20223cf2d445abeb111fc8670565f7bfbe0bbd00d0b826b6b28a5162a96ef17d7d9c8d90efa5726bb71413a9feeeaabca453883e5532779f7d29a52f73376af509bd1e9557f5291bf2a5fb6cd992479ad2dc96904c09a26dbf1bf56419428fe55d06eec044615a40c9e3758623adfd6cb219df50c5d926a1267b9353250c16008260d766ffd1d5da736c1f82020b754198696f2fc7e858b085d74bf8e4f130b0933b40ac751afbf15ee7554b3b83433753aefa38cbb5a630c4d4dcba01a214e83334a8b3d5a77a5a2a28495a454b5ba2165267b5f395521ef4ed682843c49029bc7d96d55c8902fc6c14a4406cc1d3a1f25dc1404a767dd95c9dca2b83f003ae20f46941ed4a3ef72e1e4fb05f2c19eeb256eacaf43076fccc5c2acde015524e70306e98fd60145ae047a55926e8bd6597c39bb5bc5574886492e2d6f9a6137751dc4c6c6d013efa33a87dc475e1861bdba68a8feebf8f581f6e2085c038a15275a0312699bdefa1f8ef3a90ab89cecde6cd3c9e28c2c8ce088dbb913a0423919fe66928d4dc89cb130e88d242b2fc02312face499f7c0249f1e1cf36890002a41bf896c62d4d6fa6f580b5052127f5d90d2b844afd002fa36acb7374e048950ff8f22eb4d1444f6748e6e162e94532ec17aa995a1a10bd4265ed1bfa8a561e3c213a2ab69df2bdf6464e6c1717c52182b64ae78d63b8a413dba70f9c89a0cb918bc0b7db94aa8e100847f4f8db5b646d4e46086b2acb2d8c4b53d098abdf47e7f1c199f8c591ac6b2692edd0fa35b02e3f5c8d1e56e7b01d9eab524495224305556ffbbe6c260757b2dd23f4e78c269c71ca2cfe316834d4916fbb367a8e092a260de92c828830e86945adfad8edbe91466640bbcab0bf249e3e5d6bf74ed2f1af945d0d43728a59e94a1035499cb7156decb59ebba28f0cf3154bf0c9ec0bfafab28e50b70043cf6c4048d9b08d7c6cefc07ade9687b409a7edb5f3fea53ff7dfc24bff660fdf3c36d7b490718864f08781a69feb82b255a1f3515c9debe61aec6a0c77192adf1a5352d6d8180e1058ece2656cee76ac3b55dc8abca55eb800021950f4c9697204448c8d527e94163a0cb5c338913144b7a6caaa7eb1fa0d14b0d3fa83522ed0668e2c91fa6404e5b49fff7db7e9f344d6196ceeb63983579fe9cece6ead3b7d37aefdcf346ae7a8386e7eabe00527fae1734b0cef1ad68d5a58318d91536991ba28ee54e7d3fa5297906feec5ccd1a8941cdd411cf5c70a5b9eef148f875556ff315131d4e245cb19871e6f6ae38248d8e1c251d861fa80edc8c8e21aa8193b3cdab7e8a3c36e74ad720dd355c10462fdca59a5f26f3727ce097b7421e484f21432bd0a556cc81a209456596ce50757e20e83ee2d5d487226239b1878f9c6617915a3db9edc390c6f9acd759435453de42c72f9deb6260bed926b6717e4aa07ad4ee287c433c10e4d39f6112e704937c60fe20732bd5f23d81a23f1395b90d0f40feb5e3bbbc58bb7c063344a5f8279b54766b129d71043cfbc108578e5a2c5a64dcadff0bb26e5bcbb995910cf2db95fa26c1b55e855694c16312db3f124368c6bb647d2acddd7a2a17ec8e984917a64ccca6276b27557281300cd9ebff3848c52718d7e003d8c4b04fd737e75c4a3160a02da5e8aed9cfeec3194d829d6434a09f4fd0140cacbcbdc12aff3708dcd72957d97b2f43d16211bfda2b46292710411c60c92cb54de172aa60f424232b444502bbd8d4c5e574c9326803b6f9a1111e3d7888cda94a6ef45e44b85073842f2889fce077efbfadf1749fc2e2c16a09f459cbbf99c1d05b7f4657c4689563362a9af809d65b89a84a0408375798822419e94f36752120c88e24de3df2b5f76f859d476d4ebbded39ab8cbdb38e5bb11a1f0218db3a092638812f78c1e8d6439325bdac980c2e8db7ae6573890dbb6c5a4d0d1aab3eecfafe9c57eb1f5819ae33813e68c0395c86d914f598ca00d7806685f2b459e5b8e789e099e4e883381ce13f62b4eb80dc419ad912899bc16bcbf16361f7fdd8148805e0dad6ee6aa008c88bf9030e986235ff4b39d84b198e1adda98f68b50ec4f10b717928a614038a74de7d46e9e18b12621a889a8c107cf5f35baaeb1c8c2373bae3f895a9eb046be6c7205e9ba24476885bdbdeb9e47608ac3b6e62915b16ec4778b1a9aecf65203a9a8f11b1498847bb6c6b56d304b35b12208d5989fb3eb1efc9781061198d2d2ba974192b1ec3dcd1a2922a1621317d70a48ad06d4875341a2e74bdb2c4dfd7dcd5040636068d8f1e9a156361c160f2ebcc4e57546202e1f67c83f7ec561053f12b0728b808eda7a7a8009f85bfe7b29e15e3194c5b01e2e0de5a40f69c3bfc93de71f75d0ea3306fb2b422d40e5af4a03aa175a58519be30c209e564c063fa6a9ebeed03e4d39221fc82877ca4d035f8c7542251c7cbf00a77264e1e28d40dcf0218494f3c7b8ebe012499972de3def67b255fc3ee36ae312677a4d7482aeb298baf53dde7b745a2550fb47488bfbc2dcbbc388515bb9a55059f78be5914bef9625000d102f6ebe2f297a465aeb7a908b685fa8809695f1cdd14f2f4dfb93d3265e1d8bb6affca1e852463d78a13bc0587ae90c792515c4206a01bad381cb5a195b45560ab27fc3f047abb924e95b688690632717a23d0f85d36bae067caf715e70bdeab062700719c29cf6dbc8a4cc7e2372d21b33d5d71bfe88e2112079167703765f1f0a40f558ee0aaf00dc96221c2fe8a71b1ead214c1ad1eddc1edad53b5e6ff6abadba6bdef23af14d3c9eb306e04c9274778134cfc80bc9585d7c148e75f4297e29f28d891d55367a4e8e328e8877ee295c7a9e8e6d698ad09437e70d328da63346bdcaa4030e304bea62c0b6cd81b2f45a4150dbe10566773bb6562420c413851ee050b013a73c9f28e0c79cb9c4ff88fc5b3e36304f0cb678720a9483aba6bd3f9f4a605ffb51fa79ed5b45ed5c30bfbf30dc6740748f20e18a7b9e7884563f228374443cae4c622806f32b40621c855c6d2d2c1bba4b3d8dc25ef2d3061e22d90d4c82e2ba06f66d921d357f18a07b6168eebc0f245967e7b31ba216f567195db505d5a33199e810a05283b6b33c37e37688cef9e5ef3334158f9f8a9fd8747e84b11d76a785fb627ff627f02b94480a14ec927b57434dabcfb9d36b59bac635542a62f6a91a45c77663ed853b63a61df8e036b8b7b62821571de006cfbebf6e268887f8f47b5037f249c226e4570b6a184a9ad27353717f9ad39ab78f53bbb892bc3e45171fbac2be2b0cab28dd6671c145da4384016657fcc36ff89877a5fe344f87e402f0535462b2ef480916374643b33ab602c8bf6acd90dc65b428b86841ec5ce3ba7415b372347e9c57dcf7b522ccf320916a92a3566850c270fa99006a046ac3a9ab5e5c0cc560749753a8b217cdbfa97e5e287aec91696cadecf667b0b1bb3feb8ca598ca12f7538d28b131b8adfc12441293758d0ff52896ba635f7a6d6095276e749d62cba4a97ce9f5c0294582a7333f55ed98db4b61edeed5aa28a095e023989b6056fc83910152f7ceb79f2cfd75329562a95e0c65610c245077c2cdabf5813669f303d394d55242fdd58d6f1eb95406a6b2b1e39846fcdbbbbf8e3993c209ef94dc3ce08524e6e12e5ee82ea1d34eae4a7fd8d6e66b37a89459c73d43c6b74dd4bbea0ac22fd3dfe72bed7a617ce74f643cb4dac65cf7144fdcac8bd3e2fdb5860d44402e553b044abb21c04aac72dbffbbf51ad989189827d96d1d29c0d72621bf5ed184aa359538a6767686dfa0249795d87aa0e16fd60bccf460d85f6c62358cb32cd19debe96ff09983f66d05bc46c997c59f759bf0c7fec821f9953d1ee6bf1ef27a2d05e8919710684d5953fb875b0b1465119eded12486c354f3003ab32acfd9e34a96ee19416047185200b99071d87087e5e0fc3f6509bfd4baf061d545e0121b550a1b333d692a3bb11c252b4c9a0d930ae1f2902ec9a8752e78bdeb7c6a5e1834be75bc9e19b44096b5b8c1bb713c4cdc2cd528f7e21e73f552896637c4f057e0fbe96ebb0ea98971642c2059063fb9f92c6c492bcd7dd01c15bcf658cbb17a6cfb866e782c137a30445ab8d5459aea00adfff41ead961e9e63a536bb765836eaf785c0273c40c49b11898db2eeaa50af5a04cf3f1ff0000896bba81ecb43a8789c399e07459a467fa52ac3f60bb38a08b0213a9653a48576beab308638d01c53850375e82b9a2df15cda754bb81fae5e86778f2e2e7328a170de6f4adcb6de8972239ba6ad8135b24c6a43a221583f1dc7caebae13d3c8eca3273871fe3c92c4c9503923606e656d0b85fdacfe8061529e4f429aad1d04b597462611f8b45b2723f23970f2c44e6a9d85c1eafb68880f6b6469cb2aed62aa50e15f72ccf21554c2584004e4bd72d1a9bff3e83007501ebb986f2d0f8b2f1fb76e55e6545f5e8a60bc99452671f81dd98c75b6ab07e3bb392279957df63fe5ed8999ca56a0d9deb1636d8af3402eeb471cce9a7876df70052d7fb21dfda7bd512246b944691d052a65370191c4b3faaa221689404ddc3dbdc21679b160e1149165c7d7487db66b5aa7b0603890511fd93307d7d28306730f3186daaa3f51ff2aa821797b6845811e31d50b0601a367e8ed7b3649767ca0b393ed236ab2c9e02183936e6e5cb4a51e0aba8b06540834d32433888863a604b8293880ae0f8fc8587584e4b3334ea9f69229c06832936f38f95fd9af19c97a1b263c94f6060892d890614aa242b30eb9fc300b25435f7a8124fa61ba6239ca818331ceac1ac752519ca87e01071ea04b523397d45d92f894a71eec9649581417ebbf39c7ed5d6224005291845df01ab003dbf13b0e559b12291d0460ba17d3c0356ac1f039213d7bdec3abcafd7ee0ee5a72591abffac9e324c75e251b44d9d5040262ba426f8c23f3fe56cc71004f2a65866c9630b598aff9b4a6e04ce12b2966bf314c3bd9b6c3d4f65c04ae198e086256ee82bd1c7e75420db116653fd3e1ec553946f986d328e3110c52ac36554e727c298c2fdf5e87f3272cded8b7deb674e3eec1759a614aa9ec73a441f964a288c59c767c3a119ef181621934d6213595d7c320f021df6a0280c242c54d973daacca085b8fd9b5cef25eb7ae6ed9bcb0a6b806b39a9b96584215cd3e4f9be295393983a1e561bfaa6aca9c6dce54be22da0c64c00bd8c9cd9ecb8c99463db97079b34e6b723d599da9a5e503f559268754bc999b86884cdaacf1897632808138e9dd594aac0eeacef2b813316b5475c8534c7bdd74ccd8745bff479d0ad3222f9227f50df3f63448d7368da8199bf64e0ac9144695f503a3da0847e7a66223dc1e8428b4f9f94be6361134f64913253f43c3dd9245c41bf7b7a19bffb0855e94a77090e2cfd6bfbf0d40d2f9f6595568a5035bf39cf045fa049c965cf4f2fbbe7e0846b30e6e8d8b9fce8b0fae38685995c1ca559e9315c22671e68ad2ffef0bdee842222edbc8bf432144db1c43f93502a1f309b3d9a5959027a7f4aa1b7af91fc641f3714a5c3901ab2ed9826f2251c5169747d4b7ad5dc40b9dc20577418163a53b2aa64f2419394d33efef61280fda2d94b5678353faefbd5f1ca0e84351aef5e416691dbb43154f4a9847bf1157bcc71279b0fedb9ca6bfa513886da38395db2f16f91af401a384459bf9690f075dc8f3c60c69d77dd49b9ca9f6acd91f726f3b044caf867e2cb5d7add3d3fdcd0e5f4f0fb50c81c4f15b89cfce1551c5c6edb5224fbc8af8a7d658d1f66d93420caf16abbe2fc5619a98895b90dc4c637fc878b6a49a855d37d669d7b48f6ad57dd54839f4ad46864a180cd3d718927fc984cf4143251d621a3faae1c285d6368ef5f9930272bb843d45435913e802c6a590db991735a1c6f34b9d7407e31f25547eec0fa4842e7e81a9b7974b10a4d77e627ba2cf44e25807bbf37bfba6f484d1c1dacf6e5e6f11916aa6a01d1fb741204e15cfab180d60f9cd1d1bcfe8e2d80b325ad952b46061b1b78c37cb5f3048f58167ea84b791804421b8205e0593d168401cab6402ad136a857b089c8a647bd8c62ddab127be0cb417f759545db7ad47f188f0f0825b546cc599de875f063c100d0c5bf48382c8d393868b2583dbf57b03057100803d01fe939c3524147dbf60fb987c31190980f2f231012738f5c3279b3d9d6ee225fcab2448bd36e0709253059bf7bfb530a379445b75b86368514659ac6c5f4ebc5e16edd2165b3642e790a89b2ef57660005854b385990a1a93fe976ffc486bc459ef0751b5c799c73cc3de25d0d4cb3ecc728b4fb2de561eac833dc3774fefbe41cfec877b276ea6f90a1b8f3950518bf29a43a8f728916629fe1df00bec60092d4d98ef6c2a82e5602c31a469615f44d6bd456b99a9151397633ceb2a40ad0af2f381918806daaa988aea5177d11d491b085536dc0ee9e94124276d4c22f24adab149e6d5716e01b4c43465b3dcefbc4af00504802602f5ada582edd54d4f71daae43c2bfea4f37c195ce0d2e8554a7ccdbb1ea2e6e563399bdbfcb74ade9e881a964d78c91206980a6db2aa99400e9d7ba57b92e8e679ae3536181cf53931995358608ba2552b3d5d1ed1a20be62479b33f0b0f79372cffa9f3d3e514d763a6a65598e7a0a06ba8f2dd52683e05c477d3230e3437333f84313211c77a4a3605d503b06912b48495f67d28bbd38eba51e3bbaef3bc7108a4d51e725870aab256b034881e9e0a0fab0479fc1f20dd5000538b3eb41ed65c05ed225761c9e0113a88b40b8d65f39e434b3f6b7924066eb768bd80d53898d33caff32155f875a333691644e2898c21e04a5b49d4bd048a65be9c5f4f962e524d5112124d31238b1c9dab62a72f09ecf7ceb83cd557662fa151f79bb7dcf6348b9f7decf0c2c163c5cd14b24e5d1e2088a6d0c3890eb4fdcf3bca7c5fb270241189443b42377def9d9d82ad6340d06f2c23412cdd9c03f920e3abe855096d1e7f9225e5f07eab7f7523cb8b81d88caf5793b600c2ec7f32cdbb30b5e6b25b9d6b56783efcd849a71c59d0356e3ce4d871e1a03c123947779a67cc2d7dc6afff090d4407f016b4f2ab800b2508b2157c23128ecc018374a4446088b1457ccd5ffcf9ade3e9d7532b3db05c3cec56e3e7da81cc3c1a3c2a30111a01e4e48b7de4ffa8b2665347339c3a86995d0fb85bf24b442c1ec8d94af472bab6bbe807906bcfbd84537c2186b0f6711fd2408f666fc21c9d9cb5bb098a82fc646e6d923188e182ee2b471b42f704fa98ac3afca4f55820a3df53df69e520984ac6634ea86bd7f29d4712374b0f7fc89117a5b6b836851b9b359e9553c52892f45f08bce5623aef65a52322ecad59913ec68cd70fe5f5bbb6a92d22b884eb68e95d1af54011a87bb231ae50d4b048bb0aa98e0f5de3756568c0a052a91c049b42e63770baa77a377bb736064434312a0b73fdf4ad8800be2c8ef319b4a07ef8f6c52efb0596424aec8467d5fd838dbcd4387d6ecbbc2e06f4ae13d52f3608764bf4af5d5d8a56a09c9338eed2e9d2839f0012c499eca971f310dc9f312fdcb6e36983e403cda89321fadc300aa16042edc009b169a37e6e50c5954da09d01e0e24cd980ff9f6b7212d7eae806e8e6973401ff51f46d6c34043b9a73d4137b45bea4e60d23f4d615ae9986477b8700326956de7c6b251fa732f8f42b402d9270a3ba6e854773bcc677f5850b2cdbf8e7cef128f541094d45eac21b15b76c45aa5aea5fd8b2c338f3c508e64029e5cea697a82f87071cfe894ff5c1a588fcb6417e4a2897c6d04f48c714e3ad5d0f7456b7a349785ce874f847b87db09abf6bbea136e7c0d0d307194d737ac4fc14df7e947e662d2421f6d098d11f118eadba2bc7a73a9a2136da1bf84a5c4887384e24a15caca1cd21afb4d66a1d037b8c060fc58689621b1bd7a21621a6c9f5a17ba3e56be95edd7fe2060df4f427f8ee596e4313801053ce8d108aae36ce48fb35e349b4e9c5f9b2c35433faa5c8fd92ccb0d6731698e11eb5025848ee4285fc7a4c0e3c88b15491ff0e9ac05cd43eb31a56b387e194d9999ac1c054c9fdadf7450815c4c76f38aa774fc6088ab2599d24049606de8232a3a5c3518e4aa8b88089f7eeeaf4aea5da9799c639d435872448f39de77935c33a0236df7ade3714e94e70125e3fd1aa004bc517b132549e8e585ef4b1a86ec7864196a52a0eb865a846f528ff8374f2dd47479f1687f36443d0aa173c69aaf0623cc3d35160b58b0b0e91e73c8bc15639b6a127db56969c259e1ed5f0ece1030213ce61cbb779963c8c1442b50fa8905ea566dcfcbf3637f81e9f2ae6b1be5068c91e7cc6c3eb1d87416d5cab16bbc37bf60bd8181e4f3d722282ac3a32432ec69c746e487074cd57fbfa342f9e4bb108c7db5a62633df70fe4c37f13d7ba163fd1c7922107b589a5c01badf3c237571a282998116657a0e37fbb9c42649dc92eda089a3483c0d4fbd9d3ec291f5b710057586df98577ec4ba71c2fa6ea6c2645c01191583837fb6debf21c970eb14c904e90b94ec92a74b68581edaaac963585a7ff1c6630cd326b732e4abd8e1dd5e6256db4ec067a8b0c865420115534cdcf36d0fb4e7a370a52813fada5c9b694ea5c19ecf6db01252c1c2a815e4dda48ba755a6296b42497e6c170851889d649c5b40bc1031f7a28fb2b881a4a7ec64ec1d35fc90ef1a2a957fa9dc648eeda8aeff033d6a93890da12118ddb760bc47e8beb3ff99c10095431d36f807d9848c8e8dbb867f5a06e85bd193bdf1f963de102c280d861630fcf4b109490f3bae97b52dfed41c5c4bb8bfbc73a5aa3f04e48acf37d964fdc961bdf39a341523ad23534616a80e058e5f1eb3daaf26cae20e0adde31298544785b110d8c73076d0986a2978a8f5488767fe21e90c932d2b7c4058366f5a0e0e888fbfe03fe2a2159a78586300afb0eeb4726d5c8a8dd9f68e67ec56180b52904fa52af20ce52c9725707b86b5e7b60f24bf25fbd6030535ff4221b7e6e5cb5b3aa4d38366b341e20f850a1cb6695fc0beb59e6fe4592630803cd93c08e268b8401b4fbecf4b01ce83797c0adc4400f407fd3f51bf473ce02eb6dd68ac4b5459d2eddb03acb05edda57b398ad5f8adca9e184b386d894d783df2497675c4b722b267ef611b2869afb4c79032d0024821c0ea74606ecfc53238254f844bd2620dfbd44dcafb635e385b6a8377985547d2bb4197e31bf9621ff4c4f3974843e2825421be7846012219d8ec515a7fbbde5f30fdb721acc186a006f3cf969e73e00f00c75b67b2b5a4b4a24b48e3082e511713c89ce2afac48a99ce357c22a05c91234e62c0250ce8013071d30a5ba45075a64b82fdfa58e8c075f81718061647cb8a7a79980258503a1c7c666ceb177bade67e80013abe448fe4c8fe42e89d34fe3389a956c04d2f960d66082922b5c16e8b33f9eb236da9875d97056287c5719581e027878911c52bd0b02e420c72627703544ff473d281d6c2aae681bd19746511ce3e809c1c40dbecc52276cf4e239f27d8656bc714b432b4131fa845abb322e9c4f95274b01df63dbef26e14404fce5eed355b8f909cca523ab8872d2a1bc2f61c01b985019617c6898a39b5629d2557feeed8e29241a39500805454f7692cdfabc8abb22cae19b83b9d3a1d731daa3c36bdd8d731094f7d99a743385b5ee553c19392aa493804702ef3660bfab68bb3368817050b6c48738bf2a384f3c476275656da7f96e4a699db2b2b7cf74ac038f0b470fdd3a3c768d7eb554397d2a88fc4390bf4bd22d7f327c78e11821e088cb7d5b1aa135074d2e7af6b15da89f951e715f17a30f766bed3b53996987515800799ec30fbd045c4249c77d31f180a933dda53e187ec740151ed1eb3ef98404bbebf505d4cdf1f6b8a0425a175ef7af50b31163add1ebcfe5b82392ba3f5e0063a3d83b1c8c20c97bed67fbd5238d249e9a06f5ce26b2adb86470feb97e26944c8ad27747c8ce60dfd317b6054134372f467a2fcde5bb02121d25cd756204d910dade8f33d7136e44f26c54326d51b9723c67225351c1c556cdc50e89bb9ff373652e7563e8df089c4928f178024ce55c9ecdd62c1e048f07ec7b4a7205c57cd91fd8a28ee751c0dbc6777ed9b1422e59f03f2ef10110093fbe4f9c0c714ca359572e784b20ed61c0a7ed5e9a0287f9dc0f0ad4c5e2e341ed927a6a3cbeed3dfbb76f75dafd0e2d58db9484b818f34b0880409ad962a058cbfdfb827cfca7d6ad837fbe2f018357a2d34a779fc8742a31afc51ea5943cd214defcf8ba05f84b223f10a82b322ab96a2a495a608d586c402a3f8265bb02dc8b052d75185d274b9100c031c499596dd978fdba03714b04be20b58e91902b69da4a8da4050b567700e0fde9d3cba404ff487508d71a743e5038a8dc5eb891163cd6e66df81c9457192793a7356ebfdf3177660a726ec39ac0e45a199501ae3eb255577c4d8b890cf5d723f9a5054e3d061a58db7e66e5b1712f9669ac5e985de05bd6f96ed25e7843f89803fc3132f17cad8e17cabd3afebb39b4652db0037bc09c0d7c74741c5eb688aef90ad6387f6376ced004a9fb7efcc2df2afb21d1493a0694aa973692cd8b29a41cf019b35045e11c582a9ab0fd13a76d7f1ec74730cf204f7b2a2b2a4fb749921d983055fff9b3466e7629e781fb93a530ebb356c3a207e9f3cd1d47a888e7443655c2668c46310493ba185dcd1828392b106fb5d88a6c44f8cf632691079ea19584622ae872bec7dd4c0ef4b97382de6447ff3d9c65d639d5a599a52f96086ff5988c96ee4c5f98731d6b361b86681f9c867b83f1895dd61be7bda8451384ab3f5459a1fcc15da16849f2172f6de5d0d91253a6a8a23e219bdda7c594d95ecdf0da233ac8d96834e52db8a46373aa4757c404eff2c9580851726f6ef5f34d9e2310aee598db027fc5f372d45e0c452c71c12d07dc76cc0f760fba0ea29252212a94a2075cbc77ef0d014b77dd7e2a7941c9b4745fae6e1857a3f01b1ec9513c6e68b78267438f0e5084cf08e1692e721b27d0e16063a96958d3c5bc2592b4901649fae7ef77a63823d6670350f34778c5239b04b07716c5643de42b77a3277caca9d760151babd7f48665d77f2434eec5a74337d124c222b1e2a753c48549e55beb3980548294de22abe7c69c742092a2fe247d230fd32156727e665299d9e8b23deee19e8f2035e12f8aa5bc9dd1c92a50cff0b86b01fe1418896c0f9dbc2c905edcf32c20290c045dde03fe28ac556d570016efb3908325e80cac21629b6adf797c715d60184be9398ba5da04a1689fee13a554d31db8f5128fd9bc2b32de32350df216172fe9287a9e1d637da90903244b99873c593379692957055991eaa2b199048463a4f3fb4c70ff9f41bc311b2cfc1530e8947615754dd57bc7cacfa3843afcb5f3bfb1f053ef5e5029efde14bee2bda81881d71be114502b90d5d4329a69b9a7c5da52ba60e05fa3f5ac3423dfb9a8682d93e9e39e6d69d671a0a5a8b2b81dd77145fd6106596bf88a25e2fc0b6a5d345603b125f69a4fa9233ddbf435bac0b8ac9598b6e91be29364fc2d6fae458511755d5c0b7ae43e11a75ccfcbf7529aed7a0ef280e5aa8eca53442435e96a61f5be200e32b841e53bbf85b3a1aa35f1c46671d25ca393f241a0b9ea19b36acd4ea7ffde42432f1878a4b7e4c63f960eb63a7dc17d9aaa636bc29292434e619ae55f7016811b488944393cb2f176b492a2b1db0ef13a7eab2e78cfc3dddb272e0d17c5b8875174556dd7043192f0d2a9921f63dc4ddc2a1f5a5ca0d909274358e8f320ba375e286698785905b9243ceff9012aacfd3e1035996fd6feb6bfa110bfd2034b56fbadeee9da39ea10d5c0bddf11fec5a8d220bbde6322d3c25df7a3dc142930186678bd4ad8c28cbe9d6dd0655ffc26c9b9b96202ffac422b13c59c2990e0f636e5da0c9aa066a4e6d48f3192ff848951c8e53e6504ba7c2daa26008a96fa9b1303da15ed373fbc0762bff66ff12f6382262eec5857d5e9130f7bde8c594ee45391684a6fc71257aad1661c54c5f3dc309c417df351548dc11adc8a20f5339d4d5d0548be6503f7408cbfbd82868e92ae7f026af383cca0aa8334bc04cb66a623915743d8fb42b8bcff3bbad55fdb8125f3bf309f56e13a1a840b7adca1ded4a07953fc4f95989e43eab2169a98ceca988ee4944bd6139fe45731fa7b1426a094b0dd5b612a852c2ba9c445c013faf864f3c65ec71cc885f5c2b4d736932b2fad5c94a15690e59f13b4d456feb11573ed74b50755a58f00ba81f25ddc3b8cb27432bd93c3534fcd21085dc075a4f80e75afed777ee08d3813aa19b84b4989a7796001688ebab54d286484425ba7d74f48871a3a90f634aedac447064ef6f621ba6e80277f7057d68b23aabca7249e8f4ab353b0c170d568a244d66d283aa3cdd610b3182e6e5def609093b407a80f6e86ac9a14313b7efc30a979291297595b55fd7debf5d0f3fcf028307a41c00505d68e9b35f113aa88f2fd5862707fe13d29bec89c980c3706d8394da6a7777f7103b3aaf0f2abf4e4b44229bb066bfc9ce5ac0228de1fbbffbe64a4762302420e0956b1afbbe385ae085469847bafc465232751ddff0e7be5f7907ba909a5b861b598b42f41cb148f786fc63d370a70ffe079b8510bc28ee362c85d52f47d32204bbb30964871a9ce411c63390cb3f255e6dec9e5a69192cb14b50fe7441b05244f31f8ef36183c4d7fdd7f7ed5f17d9067eeefc1b13cacd832f7929565b68f2cf72249e86f866a3896cc28555d8271fb40c1787b80bd76d50a7f8f8b54c7bebb9be0fbc9c7c502984242f43b82e308f69b4e5ca97feba6ecd250e95aba837e840124e2c60c8682e11bb45140b77bec70227fa1cd8bbf624c626f75e8926ad0eec1f75c2c37b7ac76c62bc9a40aa61866cc734eedfe6fee6d8010a34d7b547a9fe9476bea106f1c2d9c234e2fc4fb4ff3d1485948cec10876d110b6b17341e09feef3cb12d9ec9dc36135a2ad0d49ad1f00ec376ef2ac2e530ac6da1e1a912f9c8b6fba8ac4b0b365e26ac770b1fa4997e761bf6c3a618df46f3d915815693d821e3f300699134d477de790d11d867026e7b57b5927df5b7a20100cb82271a758d8cc67d2b3864d5a111feb178f04e5a05a454f55a7db13300c2f2acf3c7e7ca1d27b200b6a1feb50dcc552b1204c4d2dbbd97bba81101841b36f56d0d1b4f7584304c63b466b3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
