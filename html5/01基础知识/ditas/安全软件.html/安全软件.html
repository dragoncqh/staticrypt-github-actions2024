<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65d167cf584ca10ebaec4e841055780ce4748e10f64990e084732e4fc8be49b47e45ab3278d5b42aa92e73c62def902349d4a74ebaacc316d5c161b8fa7e819c3e0a56e1461fea1f7dcaaabd9be6510b45972b6ae16886f916b7087cb9055ca482f338d198f14cf296ca7ff055439bfcd5eef85f5818ac7ce3ad07d1e0d65daaa8ab10e22925e09269199c2048565e3a7d91299d4669f62ab3fe161065537d3aa131ee47cc09dba5361a0ebd090d9ea060b2688a5855568e1a79c4cd10bfa163287073e19f3f8d4d1ace7d73f55d88ffee3d4edc602d19b132c7dc9867953ad1df6b6e18fe218c4440df49572b7f9ee283984a4a0e0416cd39347914d921d184b27549aed77124188c3a500cd693bd3fcc0bd1fc35e653f84f131179167350244252d47e4c0c91c2fa6b855dc9b1f515a0a42cfe8c872be57abd066ad547aeec63c7fd41eca217ae1e31c787bfbd9819828074ffa2e603beb22c881d41688192977b3de09edcd65acf3b1490bac31cc2fb5fa5ec7ff3d23b7ac7f0c8cd024d3bf9962d603cbe8845366b192ee1271063606ba71c4d8cab3a8e5109873965eb42d7ebf0a40ed2063eee127ce6e652855104ddc1c20a31eb327f3222b84df56bd5d59f8b706fa7cd0ce023322577d9dce3dd2cfd9ddcaf54aa55062176464224293872e880770ee0574f886a9de5fd5c689fe38bb45bbaca8591b8605e4a8f960fd85f29b9d319ab6a283bc695f397833cdfaac508ae50a7bef1a856944d0b9e03c3c6a46e435d633457b57b429ea7d6e6a5af5fa1d9c385d79a9c94e94a849808bdda0c2c83686adb2764c26728592f4b6e2d6868c654b417620510a63f1cea605d590da74735c1107ce782d9f211c9a3313c73293fc33ce75ba2bca01152bc4fed91990b0d440fe465b35633a6beb4bec3b2dcfc40e1738344df4548e01ad16e080cb4d577db4680b4ed7703fc32abb11163912f96439ebfe320bf52946867d56a3c1d23d716a368a32dad367478d2ffaccb2d75225abc658e1572e26b57fb0ca3fd4cff25a72cf64a8e0b5b651df16a9efd9cd5fa3d1ef2116d81a36a7de93b74de14d4d42470dfcf9eccbeee7b79dd54b8efc0bcc80395d2ddae710b07ef16c80d7853b0217bee69c9b2f6a108bf2ad34fb37fc02e378f0d8bc202b908020c9c53ab66aa67f98ba4ff3649b0bb7f216fec18dc289a782f00c80ef4d4ed60217afcf7266d12b51d950ed74535af1fd6d224938add5327171f1129c469bbbc9e10ec9bc5c17f594302e72ce640fbee77965c3b4855bcd8973cc5eb78bcfd84b998062b101de5e1728e514e5e2821e8f55dd421ebb74d79eb27f082b539373c9863a7eaba9bb430fc1cab6629ce810866bfb0227f07b173e8fb3fe5fefe1fd12a4c3eac68f21bf5e3d5540d7276947e1f074d3ae90a32f8d1187ce8d58d4f279b8b7081ab69dd0460e5e9cdf98c570b0def6dea781928e53a0945e0602580362ddcb2bc9ab367205cfa27e3de1e42954bfae43db57ffcd1e42145ddc086e9d8b8119224aebd4bba1f04144ba9507db61b7750f16262d578a3ea335f69131f0147ace3319f3f2d6918148460766b9dc52d075eb4bdffaf9018b206b7100cbf3c9f589766a2dc374b748cf134e30ad4b6528024f8bc8ca105063c997dee6208db89bace6736bb8b0091d623e88ea03110110a4b29cea1ee1447d7bb3109573ee1e4f599840165512e7f6a843698bd0a4e58f51f95a71039fcac6f31d9f177cc669ede4f8a9acad1667b4d1c2c4e07f5633a615170ef6e4ad2cee67a056481d603cfddbbde5dca37eb804f42bff52455031d89e6076e1f94b0d51ce09cbf71238a1ed338819a5888f65655297c3ca9f99b2b603e3f71307e881455462c1113a668fb5439c05225647b9761e2886c6024e4b5f7a7d740d144f3b92ac9d34e71e250c06bfe1977e76de6faaec6745e13c85e96392d75ba2a79b6d0fde18b6a217ad319bfeef66ceecfa661f267c88e2a5a7431fd8b700ff06a8441b6c915f055876a1a58b600304cc8eb3cca0bd85c8506b3dd5c5bbf6d90349495acc2179814b4765597ad79de867c54b736ffb7b215e081cfdab870134ffbd9de8e742be2015fd90337d1114e135f59060f47fed590adfd74f0de7d16913beef8e9df65d4bb977327c276983ff29c5dd542b92f5bf809fa0e42821290683427a8e9a839587f89db4d01c31ca7b2c7daca173feb8fec694bc3424e58c6b6894cd68d8290d1b3a78bd32e4b4667deaf5405646f447c36b8a62c3f984eddb32d0d6c2ddb94a8c9a06742a2bc2cab08f635c8a540261bdbccbfd3ce93ca72176141216b5d74a5bc6ce8ea995eb79ed19c9d73ae7768415561ed0a5527368d45aba9f3e1cb9f1b04eb6150a2f18af4631b13d1255e52c735370acce12d5e12dec60ff84df0e70d827e14a181d6605d8cda66eefe35ea852752bd31c9e0357fdb34f2e39a10dd0d2842513f9f083e234fad7ada2dee284dab07e2dfefd3e99904330e3af5a3e0ff457954a5174b92889017625935d2e70d8980dc2b9daf9e771a807908945c43c5da9315d9623bbfb06d973952c0c3537d0b2def645e584bb28d907d37259d273fc24def07c42772f1ceaca18710a163d1de8ae6cbc3c11fa35c4316d8f045b05cb89257e32eed4ec85866aad0fe7f5715c80feb144b46cc51236366416f77af633ff63374acafe8862b58f09a06f977572b47525bb3d5b8a70742be520e3f26452acd8399c103ee93a8afe165cde11236c5c50e61e4a69ea0703dab1a6e9fbd79cbd647b0a1e706ef327192c42a554e0ec540518ed61be25655e820e88e034b5814c8c64b2af6edf2896af26e3307f9f9f18a2c755ed92a855c06ec31621de0ad3dd0417e9e61a9cf16f1a7e9ce3a6fefb6712772a2a23191ec474daa0dafc3c09c56f4d84e9e5e3e5424505eb2450fd0d57f78249504df08aff083f7363980174e94dcb487c260e652f27e2d9d729b3fb8dd2c7c61ed5fe4e5157a1f8481d74e32e001626619ab93e67eff7feb4f2a9e93c85d3779a0e00b3b1f707428adae472695d1a09911376efbfb38eb1093fc48b63d4276be37474f2832d326f64c38d0425a9351d9783efc8e68293a0c584151270ab814f0ca36a2b86e1280aa04f79e88f57fd83e060ce3553adb4026fc0cb267bbc955624927bbe7308c6e52eb0d764b4d73b1a9256eaae54be349f270c7c85756acdfcd58fdf14ee40110979a5540571e406f0abc4c316209b64c9e353f32d4b76a40411993da1c2500f71e9537df9fadc85ceca8825323b598890a90f97b74c85bbd97e3d02e7639ee37018546adb18a9cb4d3cd06eb4655d751ba999aa57b40cca2cc35243f1483e20bb2598284528f238d81f858164a21bc501980b88a74e0594cadf97409a537d1a828d7055434019b2ad2a8d6f089547c23e9a8ac66f4c127a34857985b7b737090cc8aa42bd9ba2839eccbeeeada733a32b0e58c3d01d597f2df69e359b6ef0a64227084659fb4b6262b2afdbd1e2881123a1c4460935a27ac26a232b737eabd657d354763378d69273fbe07a8d23d8297cad9b2b6b4e9fac68fbbfc1bc8b6d67e442fdcf272a450811f7d2d4abf6d639ec6ec5da8f9eb7c97d13c44e158ae6f249fd9e85079cbb3031c33d84a2bb1a25be168340ed809934da0dda981aaa0b2592df02fe277b3ede1810c5e9356e55efe7c4c9aff1b756c93e23db9c5ae789fc2f32ce1db665c6d4118acb9e5884a90cb47302a5a985e201426f8551a4c86b0853bcabb9bc07471ba33adb6f25ece9f0055ba9b3decbf7fbffb4424f4c2ad98aa1281c63ae61afbfff8cb137faf966d49b55a8c8f90e13dc35df90b87c70c05584671ea8fb00fedbeaeba08d0472d054723e27d6b8989a7fc3462ebcc4c9613d4e88e4eb705a22cdde8e76c2a97d6adf6acb730de4c8b22bfbcdb052bfdd44dc879340cd5f7955e5dc5e54c4648891f34a7990fbc85329f99e867b1098101801b65a6b10297b33d9232b492e5a9b752dac6add243fae5697aa06029eb74d623001ced2852d4c670ca983f7c69b888da587200b2442ba4f75c7a245ef4e5e3122c1aa33469c947b7c20bb9b933ccd8b35783ee89c074eb8bec268a72ee8e9a78defdc3c634730518f69ac3b3657fd7dd20236ef0ede4377519dc8d8be65d2bfdc54c5b3618490acc3903e60e021e09ef5924d879f448bf87e572266a797c2c534f4ce48fc63c436bdba592aa90d28f86ea98f697e2c56fc83c10ba831a4e0692719dd31c3d40a96383cb5637e6aa563123cab74ead51c89a452ef2954d1de1bb32a2a2270302506a29ae74f18d0c47ddd9325910e5cbc77ef73b4aaaeb5ad38a39f66fdba0fd78ba52b635f5d552a3ce02e8b0d90a27271b950530557715fd83dbee27a37c3995a4e5f50f1303d56c9bf8964e5c92d1ca7058a297a876bd03fd180f285da7f18af98575e42d88ea578a07b1c4f9c483e42b8ffba0fa88f5819c12303b3437e3fa3b6adfd39cc4e3975638f468821a3b31561706947dfd544ab488e15004061612caae94c95e60c4b9a11a1942500616e94a472f0e9af91f6551d804d7eceafb0c30659965d320fec3119ff741aac12b091d45b7aa42d074bb24236c05b477436c48e5e2692b4d297053dab807b7912535cf6f9096918638a48bc6075d7fbfd02b82ab820dff6cc0f4897d46bef325103a42acf9b8ab3280c8239b712e1d74c9485eaa8f3b3ff6850eecb17e2c289166cdd44e90d80052f7cce071c07c1aa1ef1f245e5d26ca33cf27413ed43497c2268a4e956dc431df43ea604db512a3bfc4ef0f0ef6760a96b76c03572c058253ab732912e6189ad1a8ff326819855be879b4932445634352dd7a0df6e347e976c8b56e5d682667b685bed2f64e4c3268b26d0fd5a70873ec6a4dac1993ab1c8b2d7e455fd45efdf42ed13fc54091d030b417f12c0dd802ce17431993c9fa0f13ffb993dc6da6cca78735de84bb685c7071887206ba86e3db3ca54daf14a210d493f648e9072b6d527b388fa1cf90f5340d23332a84afd98290cd9b75d7ccde038f34319b0be39323e0962a429e7276d373f474674bd0dbdc602a3be65dd5ee376a5d943c44c682683d633796237b86832051f0ca244c124122a1a65669bc528623d50e6c73a1d92845dddf5792c76a69907e307ead3ad116480178b4d501b0972e9272539f31079e621949d95bf337316bf202030611f6f97b0179db846c00b5ee000e31ef1eb3fc92fd9d5b58535620609ee3799d792d46fe6817452a7f2f8f70dc8fa542a1d9c817e2e2fabb65b4086b58262ef080587aeb1ee3766e5c789ea04378c5ed16c5d3ead40cbeb2add54a9ba0b11bd733fc151a4cb5b7054baf55d86edbb23f4c0093f88e92055bdcceef684472f34b47607154e160ff195311768739ad75f518292de5ff341ada0c3c8f0483ef667af947f20e54b35214cad8571748a3ae223cfa1d0596b7017624bb247c8158870b39a620bd476291265a43b1841c523e0b50f2969fa275db7c9dd09a4fd06b0022e626beec7769dfa20f865ff3e53111d607c9f47861cce7322ac55cfb9eb10f610ffe36b09d64ca8ebbbf0eea02b62d1324c08c40893bc154df06c2482b5072df86b999bac00c88a01114a6f3fd9731c7bb30574ca7427df8a2d3c594ae177f197e38d468aa1397f96cdc33fc3b805cda7bff02d4f78a9a2f1f7f110a5805a3d39612a4ba16f82d6bdacb45ff534b93a567f339739d65c3a073785e89e247f877a6a6b9d394a7b0c039023ee56c6d7a11cc9ebd582b67a32db0d1bb2c4c9408a247bde2f0215cd9b5200097a3849e6f342a52cc80c6105afeb1201f1bcbeecd85d2eeb65732074e3996f4f96f53dd8d172e890d80122d677274202ba0f12d2bb315f68a25748e4b1fe9971e4127a33af4c7cfe113b8970e8656ad246ec29731d28a0e06b24cda00f32fba316f5ce38fd47aad5b0e6413668abe6d84f6ce83ef3ac3bf77456e2b8272b4147b367a372a0e3a47fe8372d13317304f2d62a4590dcde2e05c4c0f1d96c8a7bd6fd39b18cf49b722005d99a060b80aa18250053df05efde4fd788e6cebd86a8e2e36b80ca313016186e459689748cac69447cf38dfb64b292c4c3048b26174e486099d342503a08413e206144f3f335ba35ce9c1bb68d50a8c229095db87996e84e16228edfceb927a651e7a5f48c67ca6ea2ccbcf957034b112b6af7873e656e411fef4e60c6fb4678c50f794a50bccd953af3e79d8c9adbbd8c5a2c515472edf27a04204af9e29654e4b9d98fbdd3dbe7b2f453303117a1cf7c5512f8cd4a9c7768ce20304570b37b03f00309c3a11ef6304f38ce1f2e3d25174adf43c9df280a3bd6665dfb0d3791944335582cd08fa3d3e7c8d7f8b0c679753af5e82b6968f7c0958b48cd01ec8637f872ca8e56b4a5daaffd861878ad11397b3489546a2250826c4b2e29ef61dcf05dfdc8540e9f99af5e10d1b645fd21e70fcc955dc4239bf1f31cd8012373ad0016b6f00659b11878ea39f6b4eb0999881c0cab9a95724a9f5b00c0b02b5b32f495d85d9baf0cdbce0382ef8d87ff74ad207b2528e3b6a5d7502cf3354e1ef6d9caedb3a1ef3636290350a2ed34ebfecfb4b5fddca56c4db7f240502bf1a946a1bec7c75475c519c4d54d69f947213118069e2046a79023d6b7f847c10659c0fc531cbbdc830b0ab5a6ef70856c0447450b1c1ed8833b5d43b28f2b4a8ec3a5749c28ff36a10c25099717657f31688dda5c20d4a545a5ceab9fa4d6804a616fad6cc77bf2efc8c92285cd83553c876c570101f62c9454b302191b6390a02ace2e66e941771a3c186f30b56790c1813908d96535ef73fca181c1a527324b106ef0236221a0309eb27b9e342a766986e97ebf1e66733bbef73641215b07a5504f2a0a2b199f288b7326c6a70c725e4fa60b867193632bc50524dc5767ef004366b62a38db92df4d152d7770147b4c477920f0a2172718becc2fe475ba3defe0424cc5f500efa77d026ba9307cdd5fb4249f9d06211c34bfe85f85207ef7867c1697171ef69a651b31bb7518bf1d8deea625b814f6eb456103aab3dcb59c074c47c9128b50078511ecae66bbf5cf4a2dfe6b1f008991e68d560626284be3bdef230b83294cad2a6a00667b651c68b26b72f1e203f71ecdddd10ed35b2014b483f7d116ab0b5b343de9e65568525e6c0fdb671ecdedf9b0e5f82ccd915945b2f54edbeca9dcd266f262c95e58d5c4ba2bb147e4693948d4215738f882088f7fc93c15f7582d41105eb842280159236c1d8f18ba4e7e18563a9fc74221d46df1b3e049f0fee824521e953d40fd5fe7ca4a8f32298fe20c9238a1c007adaf450b305e22a0e385e42689b2c3bf1524fcc76339e3a8161647d84985607fe25b4aa0137c21589ed95c8b3d9a908fb1a5e414d0cec7c564e22c13c30fc2af564f7f93dd2810d4d547a7db425cc1c620c7c7986b8bebd88052eff3ba6bd678e1bfe44ad1d21db9ba904ad7aa9ad2a7198751b3cee7a3627f7634446af0f4a4bd607d0add283f7d6353d369db5a4c4195aaf016007ff4084f9a62c5725a2db0450f3126cafaf686df71d0febd9e03c7f176e16493a556fad91b605b7965b2e9c0fc4ed43fd7ac04158be14e8858403f7b73bb61c1948080d7bf019159451868d512729d218fdcb6090ee25b229c0277be6148d3bbd21fc7eeba2d1830696fa0ed9e42df8979efbe545a48ce9a3013093d7a244c2ff3e4f223d35ec3fefe446f989ac4390a9172ed8747f33cd1ad2b28cfb1ce492f02a4edcb10f95a17eb536c3ad22c6079a6f05236cf4114b1a8a8868ca489d9c6a2c07fb7048bebfd32624782ee47f28ada8446cb24729228e2e1b26d2d6afef13d2daff94e6c1f39f0364db694a0b65becae9c32965840b603705bd7eabcc05e7616f7340bde95d7c8522c22336c2e7c81d6bdc35104e4997dbb68f6c599d0457632de77e3c95a690670f9302e07ed3f01eb95893ccddbd2bee1f81ac64ac9bf5aad47726b645638630159a883266f68b44fa873241961f12b4f4b2a6ab86155d1526166a3ddd853ca75c3d6f5305e7d8727663cdb87181be234359a28293cf58d43593d00918a5ae7ca80ef1e6494e4d832d613f25b1e3a85b623664f0d25d3d79a7249ee3e486ac358ece014241b01adc74de4d0245bda1565348d47c5b00fe32c900d040cdec7ce6d36ecedd8218fc97574855a64227127b82082c716943c221d70e2edfb1e727347ceca65eded9a341a992f7a80bf3332ef8fcd65673adbd92d62dd9e16e14d11034535685404e9033bd1b71b1bde47bea916f440371f1a545932b6d442299e135a0d758afbf76a3b3efc5feba90ca42ed74c0580815cd7e69fb6927ea8a38bf9c04e7e52c6febeb4d1dee9b6e76226dee38c6e6026c34ea71d2508f6e92665b6a4f6b99946d99e00776ef07bcb1e4c707896e1617e469947f71f8097c0e245b2a3464c7658459a42f2fd655de1b5a22b724583400f0d45d829a6f1b431d48614fdfe49d607212e06c8d0a36101a01fbd0d03099866c3f9a6f0ef42c4aef963bbde1536f4bdf09724209a42087946393a1ce1e524be4b37b59d2899fc69b1ac136a57bd1e3bfd3dcdf7f782c519d4d9271cddad39c18103b0d985bd16a22c8cf6443a07947f89845fc1f8793bd23cf87872eb90c8750382cf9f6b4396aa41a4d51fd4da290dabc8989b61bf75c2d0eb9c232ec85b87eddf12d67b42ce9aaff459ee0a6a6560b5ab9960431796b510b06f3765127170465b35a61ae121d72a05a3dbbbda92fe30d20fbb8dd3f1af820b4846a28d5dd96d526387508a140b4b80dac5ee8fc54832c782f2a9380812f34e1b47047d247d63400a509c1d1746fecb4c45e046b8484b27c805f33a51ee303ffc2ad006f2198feeac74c001eb1d54cc2091999b3d50d284745135719312e458ed36bb155ed7c4bda2a511ba547e9b7cf9df781f25f8757d111bc3e979e6773f520a1ce9c76b4f350f0558e48fffd64871635903d6d87e80d789ce86041290d476fe99245c789acb153545be6ffe6c19dd27528478915dac314722096ec90409f120ca8b14d4c76989ce346ef94beee5ae64ba0ccc261e367f6f7a2770d6b9af6a13391a7ea0086fe617ccf0fed46998b3697c95e51a17d06c63698379b873a1e3399343cce0e8ce38b95f6d88fa99ea6da8ca9f4d71bc9eed317e7e7d9f751c2ddcd298a638d079d4e1681de71dd9373232c019affa268d4f905304776107814f884da51f54cdf3093c890bb66805210bbe6c58def2125c9299b9ccba882ed0c4b5ec0487f3a366155489a4d7659bcd210fd2dcd82ea09df93d5bca244759888a7da575db7f38558cbca8bd1a9574b91e48218b15f82dabd4c3f1e9b59f84ebcbfe3f16a49bfe72256a7512f2ab6a9b204700238a0ba317c78687af18860ddea12a9e6f483612cdd30516e6e47608c558d5d49391fcdd7d54c2d2274432d1985f59ec27f6942410794c6a2f859550973e0cd7af6b4924861d5eff42875d05b5fd3879e24fb16405fed9614a652a3fb1fb6fdfde38ac7f358f06ccb0f4b0a2fb6dd39049abe616d8d6986f73789406b9a3dbb3d5b2bf345f878a9f24e70b66e2fa11122cf2e16568b7809b5a6419cc1d947027108f127c11ac4dcfc36ccca143c988a9e9dceba49c5f3bf58f4f121ebe0f08bc4af8fd603c4e08c0c100eca221845c4672052b204c4398309a0cc93f4d559ba401cbd312782f334404f99f14208d937eb7bab1ad16291e905e5ad1fc262ce6ae323836d2aa756d381e2cac47213d2dc8857bd998f33ce2c5ccf8152dfda3cd05ea80c5669c089445e5e56f01311de117202481ff6cbe7ae385e03fa81d238e506305922179a2ef7aadf220047824a83e5c0aadf84d769be271abfd133a06ffccd9ede7c4fbd33cc6f35c7596cb830ba01b78c4895eeddf3fbe8c3e407478b890d332cb122305613223a1db115b8a1ef822ee9280a40e684f55aef6f00b71861cb348be62505351f13b7abcc8d9a9656cd97c2c7af151064ebef9e7077cf7f92b39f1f8541074e576f4438549bceb5f55285d0b078b0e69ca645a6ecd3805a6c131976d8bcce4b8ce99538ca58d972c9025ef6883cbaa792a0077dbaec6539aef7d212a5debc1ea816b9eb3c97c15553229bfdbb8015b96b73f0b99f36777b4826312a1c4e3a7415795e7493a05a3400dd2487496e50df51db09fd34874ad7e5c6965fb43f592ff83a10653edd6f8e213351f3be1543ba74d911b8ad912bbbbd9f748582d5d412ffafa4534c54003784bb4514195098d522f355c5373b3985bf94a24b0078c5624933f9a05fbb3182aa64c9a04a6f0576719c7dd395269e28d3cd3d78e4efc910e854cd6578d63f7ef528630b39ad2e11ca5b46a89c09ee5047e8237306abd95440f7f06d4b08402fe66a292ceeb45484240c99d7cd144ab190898c4b325f75d13b27b73f8020c74cb7756a42377ccf85339533e309fcf3497e93c931c9a42f97ce02724a759acffe1e5a9d52823a12e6f6fd53aa2c226b83853c6f048f03493859af0b6c517a8ea571222ea37356f4fe6eee7512bba3c3b45410b74531399a4b92f8eef384fbddce57926febd9a04c7c018c552148776cd61b35ad3fb1516e3c975f56a90f91b56576a1a63dd503b319f505eaa1df49381e8de39ef0b1001f2d046c441d8d7e44a0e5d5eab92f6b81a5630fcecb65c3afe4b460d2783c6d7157e0391a25f36147c11ad1c353d06cef660a0fcba45de6c7982da69dbf898e1eaaf337c480e77ab3d961ab76d44bb228ce2bb1593cef86c7640bf123a8bbabf5e9fb7a8e30b3fd2a73a39100061c7403aef17b8bfe09eecb65fd38ff9e8bf26aa2ff87a347e90b63b5777ee81e5d638f549908b9774acaac652de5c3fee8bcfffcbb3e83046d48988b7f90c550abe320d04cf343806e267a53cc8a988bb176676142b02bbb8f91c92d45c6c394571e017113bc9d570962fbcd16861c5385e88ef7997aa659cb7ad7109971414722b864f82e60facb911b0ce41d99d97c7ad93d648bfbbdc00351f78997b7ab340e90699af4503adefdba207b95dea79798bce68bed182b59cc135fd9acd601eb1e576b05cc83d518f34af365465265de859f077f62403178ebd291aa7eb4bb94f8773eee21b24e847207663557f9d95514dd0bee6d345d6bd734bcefe10ea2be3f9545ebfe1e6d5bde2f09301bfd1bdb470fb4f01dc64a8266f52ad95e6e36145a8d8aca24beb2740f1393653a828006c2315b783023a95c89cc1c79428ddd5f40999cd2631b156a7a92b73eb292fccb783bd5dccb6350d9f7b6bd8a05f0d34b2e41d4b5e55a1a673b01a7abd9b48f94d843e7b68d7f5b4941c3bbe77b0aae523a22a21fbfb7a400b7e81318961d5e28fae5504a779aeba475759898afb58e091783f595aa61e336af9816e9b86d95c117c614a45305a99a8beb453a7789033c8e70c84bb7286bfeba6714a3711e6d6c59f45d80659730dd14e080977677d43fcfd56f0a7d5498f442335a8c3cfac09bb037aa7e7afc95cf9ddc9b77c012e5eb0d76c62092f3505db651b0cb7595b2df873bc2c72e3c23527262349d840c37218358c2ddd926597ecc6512f6210d84c2d2463cd82912665056b6ab66533c252ec49626ed9f3cee265c56c3ce631dc97403c69bec4325a9a9bcccf64464a2ee223898e6d9dce362001b8579f6b2f5467ef1eb678b0bf13dd222017da3e1b1ebc5154954c0cf90a20a491ff3cb387245996b5f9e66648ada750e41c28ba0c29dfe400fd954cf1afda7ca58928cac3d59e41e8aab8e604fcf572900923cc97153c6f3d5e9758ef3b61d48b41d00a779d0a1ce4bb9a113bf81aeb8b55854e15be07460ce202513fc325a2afbfb58f151006aaaabd13c04519434ef68c17f8a487f5322bfdf4014bc53494e1e76ed851e3a8d2b9b366a85b6d175f64973beaf6cc39cb2cc095b31362f24ec49aba5a4b3e92002eb04f4c8f412c9c971b12e839dad1b995a86e255b7ed3c6c9caf509c12cf28cb0c9da9ac35ebf3357d2d3c8c05d80c79b2e62b406bb25d4fe9e649845b967c212220e268accdab82e90270cae1d7e265168f9c19481b1aaaa32b3a92ec6c2acd65eefd4d699f8d619b6848eb57ebeaacb686321d233b67336c5d8a27986877aa0a09ef712471231c3daa19f0c2e233d303deef13c64865aece436441b6a0e32d5070b03db392d7b97d5b89a215fa0e2048f36276981e2f6a1810eb2ec4dd5f09c16194b0f45edcad7cfdc91bff215e11dbf086b83b0cda1dc6f4822e3d2686e7766c880a47b7688b48ae78a2769cd1f748e245a20e54962e6f89a03e74c45be00bac71b8651fd634b618b9e4837ae32b4268e83e092cb81fd41c7191de5428f20142d406a637aabf74549e2046fc39b9a1719994ea0c6e7f308f0a9e05f4058dda667855821da7ba96169f6592c1c79a6017379c73a998ce75e91e47bd109284fa965f93eb5f513f1b0faa01b8408a5f1fe349099228465957e2995ee616fb23351a4d49d71e8071e584f824f63a1895e9ef64774c8b46cab4752f1c45b13cb47384ff06d6f76fa28d9ccafe34262b6d5872672d318948123879e0519a9acbb9663f04b236abd54173f36997d86bed128083fb537f2fde5d60263476908ee8b7b119102bafb433964d3d494f0730c230ef4320435fd827bcbd63b02e5e00bea0912a350ec05a724ae1c4bf96354a2504710339940b4fb24e9eb1bb7e813e5ff6a6cad4a2448017cc4abdc811b0f607600a94606cfde6a9b9b71f81def41f95056592091569bb7a9d70f5f20e3025231c22239b55642c6054ce412ed563460947e1a2c388bb22dab716bdde86e678a7984636f253c56acb2a22719c1f6dc70749e6011c57f894063f4824a1f3bf208cbbfc6ee91610b0beb3723171c491c010ce5eff5538989d40226478016dde0021bfcf961720c5086b4286e26ef27469361355351fcf24c80a1365b88e3c3e10159589db99e3fc9d12ea950eef627a42585c31456bdc4983177a6ccfd57f989552619e2d38c0c5fb8adac9dba10bad0127f660ee268b2f7149ad23ec69ba86a21d63d159172630876d31bdbb245b32da44857ccd10e0bdc5871def485c004481ae9eda991e17de616eda6e5bbaab8b6acaff8c5079b6edfee351f05b9049333fcd4dac96e3774729eccca57a8f70a4169755280b23f6a78de48667462ac9d7b62f1de79d71d8201ed511de00d197e2e04885edd3a49ba7d998bf5bba596600b351d98f359f5f88974008ce72d1cc6eba0570487c6378ce9a1df241450c77050bb64c273a2ddbc41171555a498aae23f58fffc5ec8ae1b7c4a322eaf1098884ea196e66daeef5932e0c28ab2cfe01ea94f253f81726e35b589d973af05841d7f5baf96a4bae9af1e5bc19c062f210083bf4e5fe402a45722356309e3076f5ca44999c02eb852e4b6fc052d0023f0455696d8957095fddffe0d9fc640d76f5cb0b6064efaf60f198d305576de354652afd2d794479c8106e069c414ceaa727297f4d55f8a8044a248f3c98a96939f891b31d1611c41d3c64203138925a88568abef32d6338a267e67d44215ee92b4a9a57ce8a27415495c7c0797afce3447869c0c8657b73a0e580dfeed1e393445f98269b17360c9ec6e80f38c7f31a016e11342e70c1c2f4e561f62e4b3c90fce3394f3e6704c42a065a818160f881be42b272532d066db992da63a571da63828efc4dea891b6424e896864e767ee4babf8d58c7b70d106e8ea3c99cdbc9d4d066ad22b1b7a21493ec260e9bec0e328739315cc6a07b51149e83731065f73fa76eb30ad75d37be0110c653e0684814d3195de8053ed55a73411116433781823c9aa2012d33fb6952006f43b4562135b23c77b73523d7446ad3b66d622d0d48aa39eb18d09cc27840ab594260ab171801f504abb7715c1dcb2e097770e48a50be409077a0cda951bc9619a7db836a812c22130cec08eb7e42b80491312c690cb87629bfd1075f133b60b738f7055eda4b7ee9ff35f96a501e6bbe9a0ec4c79dc61a3ca10be0a550907bc2a29e44da47c310bca847f69877c1a93820bd9d03eaa453bb5549c96775c9789e95e4ab6cde127c4ec90a6c84bcc5a4065beb86b73e0c3ece0808beb5ded9f596a18853119c2a9698d519712d26b6aab72bd877e70d0c7501f9b3c51715f2b79dca0c14a92ff83c74164346e914e67c8163e9de622c933e5bccc4029f9f2c853da79ee569f471e7113accfba9ce9cc3df53ca2c7d0c30461b291a0eb141de0f92e8bb6228fe15f50efdee05d2d3028f8c5ea4346e5db702b3b7df09e2c0219d7fa8eed13b215b0953dd16b018af0823c820685270e0babdeddf2be0eb87dcaa9ad9e28c5989c1d687563c5c336cbffb5b9556ad90d2903a0771997aabfc13b39ad7a2565c6ce487f806425771b5f5476fa7f85080b8e21e0a4ddc59a010566064caff9231d386d98510f598f283702f630eec0fc4203fac1bc39b8fd333e8515a3cfc952f9e6e2038f7aded3ab0f4f5ac25037e6b382c7758063808402ef7703494e1909f827c80401203bd45b0684a6ae148dc3d42c2c1ea43efed88ef6a77fe02b8f48da877d315eeb0ba49fd058425d0929c87738ae631525e7e2ad1274bad2ce0b4161622f28ac863588bcd3916a6f7417065ea420e5574d4b78b17b7cd95a5db9690b56ea59ed15c52403a25a3bdc2fe6d6179c406b2fb5b7643515af5b4db982e7512eb41b5851eb0fb0a12f9f45a57cc6596878065826e3ed4c4a6d9ebf9a1e022b0d7fe9dc2aa683811ba4f9a9cfed4510c04b35a58ba3075b2177c795718dfdfb7ee28edda3c097f76e26af4286fefc5783c3d6c08c3375027b3c6eed6eb7e09d9fe2ff47185d26e591727597cdd6d896c16719e05f4669a26321f5596a27d69dfd6a3483cb9e06e99a47fe3e66a8205964d6fe56c85aea4191bee09be5287fe419f67428d45c672763424e48136650713a7e60606bc4a908f2645a83f8649dda7cd3536f63602ca689162e9ae551957fbfd89bb865a310d36fa8d291159ad8758be496ece7699a098cc2e831a96d418aff91f0b715f860348abeaf8c146678fd479f71a50fb7c79e5dbeb6745a821006906e767a961025ebf8ea84cf55e028ca9a3e56324149ff5f6504373f72bc48d1366a5716304df41bb958e90d00f565162d862359c6e8cf3652f758d5c3811e6cb23c2111af946f1721d5c39f813611d066d8c7034b164d35f1081100013c09cd2a2970613d1226acaa08aae020ecc2076a8ac4f6f06ee3d9d858bf92d9bffcfdeec47a46117f46239e67d140ab3eea7a6094524a8deec0d0b948ecfcbd80ff740942144835186fb20866680c2c22e0df5e961006d3b07e330c4c2812b5e2087a7006aad04019c8275dcefb5d16ad4e2210719d3a7cf345378ca5bb4db6085de6a6563e366138033546f89b7966c64dcc54833d9879fba558e70cf248d72b7f9f00bc427bd7a3883b57c1d52df629e1db32765f5e7dade857854d3720e2c3432fa91da5186f3180c64e3025e8336874414bd21f1a41a3de4f462d36634c4997fe9fb47307f02114831ec0aca5afc9a116f2e053665ac2781c23be1c53f56cb533ccbbd888f8343936609390ea437bc8cd0ee422fadafd5aa7775ee3dea00c4fcf5a7bd7e605e4b8ee466d346381e70549afba695bfdfe238ae82add2d95cea1d3b66612f09c744bf6f35025e123091a6b3a5903bc6bd612020ea19115bf53e6f3c5a28eb592460767c60950ca6a326a5d310d0ce93120647fde0d8f0fda4f021e7ee3f3a7a816fdfb2f069d5dc37132ed2548a46b9fb258758b34608cba8d425bf4b6447ae0cef42c10a3a723bd11868bde50d2fa9615b699581b54847e0b818b87c95353af82e039b06032fa00e6f99f43a4d5d92bfba164146083bd0309afb2d1eb51b8836b6705284d211af8ada22ffbc3cdc53abb3ad36b6bb4939e0169a78c3d9eb92ed0d91b7cf1443c5d3a1f47a1b2fc1f8c2a94092e6bfd12c161440cf00b75cbf660ff9260d2f1033cb2fc4c2c72e0593bc577bb52b916f07f3097d75c7d19b5296f0fc46fa20f4d636e04321132222108bb9b6a1e60b1ed8ec1c17b50bfed0e73081ef560d588a7f61f2968927495e63a7c99119f34ea40f914bccb7ba5e76685bbc584bbe08ae941c8d5baa9492eec7ec27adbf9697a8009f2f2ab290cb41d668156d91dfa7577e700e7f50ba27ece600a0cb3a9974672268315be5a35d5a47438ec0f45a5362dbf4973e556af3ac8179470bff4776cdce13a6040c660e038f07aac2b552617caba4bbefc4bbf1c1e6179f49059495ebf49466f365d55a83f8e0325cf8a7c0d5090bee8389c87f106f4e0e72b9285c581a5819b2ee1fc2fb98b0d1dc7dbb90a76b3ad29028885357feafb8ac2655b08ff289f7c73cd620ee138f610d42b908e0262f3c2505c42700f8e72ced9ab25ae84125db9e0aa04605098ee5ad2e4397ed32f612692b6c6231a05a24c026f737a76c6719badc7ea5b17f2a235d6b217494cd503edb3cee4fd4689a63fa7daeb876ab686eab32d49b1c5bdbf4993cab1af3dead74c4d3d24ceb9659c7adf0396bcfa8631ff899e6e75828d13099f0d7280979653a02417e96ea5bdeab1f801b1038ca48d3bc18c371dbabdcf968e0c1851db9cbe1879fba773a6c8cb9aeda0ae8eb7e490c1662f9a090f6443e1411dbf7ce0a3450eb93eb3182efb06c213717ae7cf3c4f21149eda554641cfec5115e50abacead2644c6679d4c339c5ba127e2703cdea70ae92c8c95d97447c45a9989ddf92ef56a25aa3a86e0c9fbce37d40a349e3fb479f6b6ddc686fc85cec6fe02336fbcf0d34586ecc973b84d3e3c4bea1b7a2085cb0fb0740b727d6ebd5e8600e9bb4facce1cb2052c0bdbb8c55e07c806b319be17d5f88759751929028038284aa105221cbc2e4581fcc736f5521a356067242a9df424ee2cdc60794cba97b66ca39c712c4daf5aa3d6fb93ba4108f1dcd08cf4bc3eecf614ff318fef9ff089a037937866445fd25bcb72421af601264ab0d7091fe602cc4a928c6d8c55fbf1af800f4cf69a01e39126f5889781340a827c6ecebb9dfaa9d19f477701cd60804481c05f46b95e7d5979b8a2bc4284916d1227d9950bad7e2bed09ac4ad1c55085825524b016e1d78a3d7298fc1c427673f5ff95c2303ae4c778133af9f4d8b1fa5829b8475e720edacf46252ef63dd245ba312947d19f732610b4d892a848158b846071d30c0a037db9698402064289d82579ae06d3ae0b851ab4d0207bbcf43eccaf0fe44d50a609d1f684ddcff9467e9a150fb15a4aecc85106a32da2685f839a7e5ff18d9a227fcf5b5c3063ec8373b4ee95500c8339da79fc37f8f4ff4c9d887c01df0db7801cc8c66072940c6c412e10a9d36a51783235dee1a304582dddac0ad9850df77ad355f2ec805ffaabce86bc9955276761be99404f0b89058a5438d0d60c33a1bcee4fae09ba44ae7db14b0de9f0f0572d13af4ccbb3aafeafb40cf3a2106a6fb36b2ff4d1a2c153abdb2137b6c5d5d685f4ad12b55cb74bc5d274f611ee5c8b4aa8d4a74bd0968f452f71643079e510a4c3bb37be309fc59eac08a59a257e8a48bc9d42c4992b7a95d2047cbd33c16ca0bf4d4c7d806db522e67aca2de019fd4e0fa478a1c6763eaabf81bd6661b88ed3ac4ba2095919a3765af156ea62156b3f590ad0d2eeebb4bc98fa79519264306f8a12e6631f08b3794630e8a8ea6c936c10ca2f8ed069a2fdc07934f700098d45a0308c10db922aa991ff06d9a103f758545e625a749153394170b451b770c73759a83b8a4dfb084a5946ab2d409938291a278032b686c29bd5ff64f604c0db0d72a3c663b8cde3a1f3e7159d318338de638779a489ecb31bc9cef4d77f2d1dcf417a8eb536d202616495507b929f6896cd1e2a19de2d0bf384eeef5bea4ebf3558ab5862112a908cea74206b794dbda2b8188e65c54eb62e24505d64b90555e09883ba99a55318f0d8be38c34282e46c9d2a0317fcd286649bab87a6e045ebc036263900b29ee69247e442ee5464430ef8e3cdfa3ab5a6d8a86b2857112e9a5d3b80332139fbf88de7f2ec26a2d20419c11f700bd2c18afea581736e132b14bb228c53aef42773ff76d57e51d30e54f53e197b17cc0a6cc698856d321cd5399b6fd2e6d5460e760c14d7b21b6b8da6dc92ac72b5cfb89bb9cef480e07ae4cb810e6ebfed4fcca6991ca0521e71b7e35c0b5b8750f718a65fab4956af2e75faf3b28d02d4fe2c7733b4a79eb19f074f91aa7343546cd55c094fe6d82ab0d4f9c3140b58891053c09542817106eb97b2a051c43a548fccf40416d083795a295969b307c9a37bdfb17582eff6c0cdfd09887c100cc801fd3379c1c9686aa28f2f977a3124b9b02db5773681a9e984da61903b286173dbdeeb0c57e4770d208f5e52322732a8f508153bbf840c63223bb6e5b5c8113082830c943a9f35eb57a82b6ce94dde73cd1c2c00b2cfebf1c7e4b0a554b370c0309216639b09a6a9117f07d2ffa50223078303b9255336b66b664d09e9dee4395886f0833ed53faec59a3561331abe554ef7d96e8d2108e3f075f9cc9d2e8114c2027decc547f7e54203c57013295580860e07f4a4e748795f838183b01b5ca153b271b11ff7ad86c5c8ac4195d991e6d573ad1068ee226e493f56facc6ac038ad928f7fe8cd3c4bf8bb6558fb9c572a01e4993d02730c762c005e1cc02f954f4a382c904b55e8e2198d7409453d9062940464f2cd9fb465caa635abedc9c87be4b72579c6734afbe0ede36b1f7ecab8f0d4db32351f46ec3a17980bbb02c41b7251951e91f3cbdf6963b321b3301a50b43e52dbb94fe0e7c93ec604cb7d59cbb74d4201d7afb5f81280a83bc10f88af6eb8dfc8588913063feccb035ec63a99065d112afd16655a28962c65f44a89898fc832a0a91e9468a1315ad18bc919c11639e049a354e1269550017c072c607197a441fda4a88c751889b60da8b20f3e1e93208ff0c4229e9f5dcc8da8e36e3ca523b6390e9be7d1ba3830aefa7094323ce82a84d6fdf44331038dbcbb25810d5d1889486af2058d4879ccd0d5cac306c5c7a8d141ad6ff8017142344c8abbb295fcdec1d58932cc0031252d3a1997e2b4043d528d8fda5a6c6afb2240dec5db587318671cda358e9a8f11365c5c161c004710011bcaff7dabaa38f430c3abb9b7b32110649009cc7f59fc9bd238885df61e36ee9460785b6acc6b10688c4f37daca26763861802dcd49aa2835997a3d8f1e5e0ebf8efe328c00021392e582b85b0e4eb0686cc340d95521971b92fcdeeffa2ca84bc735c046dd38ebd66cb6a8ca2425f303f269f2b212a952df678eb0d2306e006e1eb85ac530e2e1629f74c4e0ca22ded95aa30972bceebdc85bf37798c7320c2aac651e86e48c6fe781fb60c0490cdd1d018876f9e49a3262801b22f9a2eb3bc65f4ae50bab39a13c24003ed85a44814cba51226aad5014229dfaf1d0b857788f810a47c67345564b9c32454b5b6a7290b9a498947d1c7d4189eec893e1468601ad1af6542a1faa77d408fe147b34a1acf6d9242e472277e59e6e2955237260cde83273679c24bacd78116508e182aba39512f0ee24e2d55c97bc00fd25f1460ee851f60eab8d42a8aaa51dc51fb2234396ea5b0e13df02c573139cd280184259dcc653064e84a320babbd0c66187fc22fc93819c14659c785d47540a37928c8263916060d35cb9ee67a3daff20cccb5281ed89bd1a67961cae3cf71e0612fe578e2517456614ba5ff2720b85db305df2a14daec5ea2eade360c44f48536bd6b7f22deb7a2e70efff79524020083707d2eeac22184ac6edec98215676dad727f28b9383c9125d6e0571c319178bb5bd12156ac1e635bd1b3f907748712bb062993a86cbfc0c574701b56955cdacb2e9d6c7d5afb3c096a9b06125485634c28944305275fae5e93cb95ca319f6480ba7a5163e931097d38d94bd253cc722e5c61094ec764442de5a400da926588d328794cf2f0e57704f9a8ce393a666cdae78ac7d79c10556772c1ad39af4353ec5b95ca6f03af1b2181c779c2c22090b6fc61b7fc92eb200d5b7d76a89385a6c90d829becab005fe943915083081869b74dcab01ff8359a2a642ecd4a9e0daddd266823913e53f559f729b6343ab6ad264a0f3a5e647aaada4a43472c26f2ac71d65c0b6b59643c06ec542d0ada21d10a715cff5bb47f51c227908757ce86d7f80f61c1a6779837216ab3a9296bb20f771927f811aed126cfdd95872718bb2e19f5298ab4780da644412fdb623b7882a50c9d7690c0684117c5faf21d5f65161551346b3ab54a73afb222a92ce8737ccda73a435a43a487b70c66d1a5404f72c43d324010d97ff96f1cba31cdbb648eb77a4519b134c175ac614ef094ec521082f3e583c5820feeb3ce58b4d7b52d8ea774f51edc43900f9246bf40c87c74931556f675026c5857f7ace8a7a3f0f34f2b88150de77e5754bf50aea1d88dd7168b3e1d71fd60a64b16f8cd2ddfa331f78ca08e856f1546d4926daec7162d0a3fca97b5bd12240f29455fa5eb072c27695a237cd7b22be485b5f9bdf595c5c28398a355fc31d19b76f0fbc86cb455613fdd2b9802ab5257d0cdc7e9b68f09887fe4dd35e474c8573d92cb01d3b376128feb1fd69ae9e12cad8193948d0411e2ff2d1da7851532eaf5792a8827483e0c87f74e0e1941bee6e1a89229a3ac953d0b0cf6e291392991ccd9ce159cfb4baf06548b17d05650a446b71bbcfbffe641a9afa9ef8091fc37eb2b077dfb1eff1a97e19c267fefd623ede03f8caca711a17bb946ccc64812fc484a4c63926c02b32b90e37f5f051ca123a4f555b1f090ba360326c0244283626ea8fb7f6ce0403576451841ba98f7a4f5609ec61e4775bddd696b8dd3502f59b5049f60ed70521e77057030eea387e2c8fe13245931faea01d178f8be4150f28f8e20ce876057919e6632c41d3c863dc4b736ab1fe0e53f46d330915f8db74525958a1ea531e82f6ef3fdbc18396c686e289ff0207ab8fbfae38932f3743fadcf4c967c3eac50a4759050ab00be2711072319b2011804ea0e1b915d4d91679db7fc2927bb925855bda6d90cde88bf6ffa2d15c1dcf3a40dcc4ec980e6b2bf3cd0c24629a7ee137b6c103833c5aeb1a99c4e2efd5106658a8fb91ad5295cbc3382fd09330f13ebee221d732724c5ce5223ea6fdb89e4a8657b9570c82a86d488022d695c29a741feb16cd09fda438058e7c2601aa59674a0348574f2dfb3896850696453f41df25850cd3d2b22e4485a4e528514d1aec55b6ab96ed96abd34362d1dae78c2a8bcea0b331508b2d9c8270461e11a4a2cb5b83fd3881d7b47d94fff26edcec11c99e4da3293de42ee4b400a02e2b67646e801aeaa3fcd735953187843e882e85ae09da8c54378538c0a403b4e8d3a1683d209f0d757e9cc36780056c30ef493514e5f243fe53d21245c87a34e0db460b1f6b2b252fdb7902080354a939e4f3f66f434db9e5d88278e46b111aaa104126915ca5d84a263e3dea3f4d6f17912765dba6a43b2eca3d0cc6453c06397ff4ccd596b3aabbee3b644a24b0ea404b0756fde2d3920dd0a015234b4e9f4936bf992ebeb042a557038fb007c63722c7ba07d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
