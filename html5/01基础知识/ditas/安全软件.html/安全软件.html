<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b15e42f4d62eca57e1832848603b55bd0ee6e376131e6b21f698798c1a8913f72c986a874e569fae5c6c625e38f5779e29af3670bef58b1229e6a6fdbd85e544fbdc13e2b5e45dcc6fdc85dc145da92f1144659aac68792cd8660eae0585828313b8d99423ee8b5181851bd7e173457434f196df3bb82b6379e9cb32b608a8034652379d70db9aee6767af50c1768f0328ef847ddda89508b7fbd802af9b967b36849360e45d8c12fa196edabb823b00ea1dda2981b1be31277e4e90f96b185b53ce907506a60de764ee5eaaea5aaf1f9c82064e53f3e0439dce4cbd801a8de0ace87ce3303cca518c540b6a6f9832bcdb5195711bacb2a9b79a0f8669d47753208be273bd5c819e0125077c1db1c0800be28619244f39892db73ed2861d491b5bcf421629470393063c2fa4f6bbf44cff77ccf189899181af664cb92342238b6f4e1cb9dbcb7e365ddbc94ffff024b318ea2b457016e79ef6dfd3b01948187455aab6b518ffc4803907ff548f517fcbaa34ec12ffee6b1ea3820d1482e38ef8432e965370a1c3aa1552685337ebaea57da45cd8bf4b2f48d01adb88c9155bb18f8e7fc696fc3a3ba252438462aaf5fed91828afbceeb716911fea9a669ba2bd48e061ffa2033f9664f01f7766b8780d7142c2dd7060037249a64baaf60bf49a7c78f030df22b217995b93c8a23fedf7ed570a26c7510a1101991e190673feb062c31b6984536f3d0c0d72b4fb7adc6ee853e72ce9a41b3d85d399911b085915591007b45a7e79ef9fb4b35f800c470928995c7d7b5dfb5529e97e843cb5ec9a55d689ecbe4ad0a377fcb014dbb46098233cf7629e05303a4407cb84f19155ae97e77fa9ed9a2c1ed9ce5ed75fa42215e36c5f688c0433a3951b99ca6cf05eae0b2a1efe9c2ef15ffda869c84e84dd19bb5e4720bd2e8bab6ac43940f472e4fb0433d7a929b4654fd02a1463c4bad3a949537f8d6633a2cac42af0f559b501a443806675046b0c4c76788b0906e88351ee38eba56f94c154de0909fb6f35117fbf60d5f991a9540495bc623a20e48711ca8ec6083f3d537199cfe056730c56fe36c5fb6f944497dd9f5d91fe37827cf20e817fc4bc96c0b0d26a674271ef5c5b8f9f2529ebc224c5d5016df41d2eb3098d5075feee0215c4cd76e5faf3cbcb108fa500ac67bd82185103a8812e6d3d4db3bd684fac7e18940abd671a4ab658eca4dcc056e5d0831e08421ab45487d584fbd68f1bb5ba67b16b5aa1a1e556234e9edc734bf52428d9ca561d5b043605eb80b2cf3e25631efa8376ff5dd090102886b442ebe94473ebdb5197c91556bf7479742eeefad4523367e6e6669df30cffa18babea48fcb7b501dc4b0321387b96a960d6b5e26749e53e076abe458200d5e9f52f3b9d7c7e1b08f71b8125ff656ef67fc9a0aaa50eeb2b95446d3d1f194176f7483962a5db35cf78db398cc330e2e21e7d0bfd02bd070d9c9e5d23292d3cf2152884228c2fb067eea7daf198ec852cea072b768881770a7b4c34d72bdcb51135d2b7262cf19e6fcdae4bcb778c2b69cf137e22dbf3f31acd3344072c36a90c2f01d644a3d9ff303933e43a7609438d73730edff093964d602e7358f49c29950299a8fc8701670a8962495ae51f1cefc0e1473ca8d5b9678023977741c354dea704faadf38280513d33e1bfd7c9b749fbdc5b796b6820cca658007fac68836f355de4f4b928efc491bb424ce98bb406276536bf29ebe6029ed6773425b3ff56d0b3f9ffe65203e62aa63e17db984c36d796d9a95cbf096d6ae9769780d73077b77c9da0e5b6e8cf260c73cb1e581c374d3423b4a8ea68c307974647354e054d72a50713549403486723147b514a56b3e8630515ee94cb1c156e81ee9b964ac0625e3d2a752d58560363dc3e04d98880415579d16d2f52ffce488a0f00ea780eaa55f016a1d716d6b07447abfe26f59a3fe72900ead3f7cb6e0fe41e1c7fcfb07dee6b6672f100a3c48a4df0092d4292d110d8a838edfc0a37eb5943e687f05e427af46f9275d70d2f8d443a550a442f78095b908430faf215e2f62ccfbbd7307843225f0d512e5f2e15aadcf6a918e96eff14a253e55c32d997358b36e75602878417357bf2650aef773af6b123b3b7df6d907d7590eda623e55b3deb5b0183bc2fa0c951451e74b5b0f3d5e7f9c3886f87c413cbad7844eb2a83cf47aba608d0c61ce09b6ec08855b42997e595ccb549f998f1bda68258223165894e7626dacc68c4d6f13c8873fd4bd9f8b148c1ee0f5479583104ec6f6c9e83567497d49c708a65c6acbd2ca28cc9b3b84603f1a2717edf054f698a735548ee3f6bfa2af10b86afa5a9d4fc3727ad886c23a2a1888b7125ea4a2f08e8a7a855850e5970729722e772bb3a5d4a2ef479bd2087147ff2ed379521cf0cb80dc788d49a807a245272b93752716b1a4d7653512876eb3bce9ab990c6aa5e91203b1de17809426ff18e4615eadd4d9b8772249874450e78ecfd67eaeed0b407e73ad36d278066f9aec26c1b390e59c246a379906c565fc2bde1f11cb780f51d6f9b6c146b0db8026b3e4a44a9442460c37ed591d32ad3fa84c19d064ba658af658fc553222e4b280825aa4ab5a81eac759280395886b71bc2967398f95d16e5251ae09514e1540983ea31408bd178b67fa750e9a08a24ec4615a007a2e90899ff66d3b788a25393eb88ef7a99de9c9abc0ebb15e1529f9e3707ff9ced96a1569f41532b1b5fc5d3211c1f4f1365f90a5160931488d5ec5adf87d788d30698fca3f8d95dd7bdb4313fba27b58864606e6e6e1550ef11bc82930462a37ef4014e52821d6568b580339f9e876d4acd0be1729da75c888948ee57cdd5cb01c7d5dba2c8fc0bf7f1cf1f7107e3eb07aed7d9edea039994edfbdbd77a3f8baeb65cb25e387829dfcdbd173906f71351f8bea305ca606485450f0bdff604f74d35121b2fca6d7695a273f44468cbeacccae3e418a195f6ff2cfb2c0310e05db0accef30c820817f60e412b0926554a8120aca52601eae4c3c30706a875716d907dfae4d3b04b8bc2ac2a2086bdadef77b63c9a0949276f8bc38225f2e1a5b4c49b784572252e31303cd8a18a51a89e53ebea4dc857e7a45c8dea6fa7e813d1f47a85317caac4b36dfee322d94fcf240cb036c84067c09f7c074c706e681af75bf14c58bda3f4bce6af7a2f099b80bbdbf602d33e28902823079ab7234d7f7d6be3c3c591772c0a2afd609024315cc63b7c9facdd1e4b4bd8b38c3febbfba8f2ded398cd043d301f90fdd1e846cc9d004fe80c44fc1bf52805e7e286cef41bdd62742791b85df5a9e74d73b735bc435caf9860fa8ed2fbec0938e57874a4330625a1195bc399ded7d2643ea76c02a0ab37ec82cc92e5cc6f634b72b1013f63b05379a32027d91a7c4d4c8c718f7bb4150ac620db9ca2183dfe63394e9ef76bc7f31921f2a9f0677b09cc9715468281c2c897375c4fc72be34cfb088b8b31054f1069a18c6cbb563c3f7ce5a014628115a8bdd298b1690833499bec363b45b88f8f1d4278e52414f08ec08cca6d713736dcdb11d1207b4a2a1ae8f17a2e1c7ec226d2f63dd06e814ca63ee7b972142d900009ac4a9ffd85b3a26d2ce8b49f1097e74e9f9ef948836b31347f6ee6bd8c5e7acdbb292bdd84d64659b160bbbbcf0b48eb8426aedfa9c579624ed678f8b359ba2c96532206d8b1682483989f220dda98dd8b5b5d53a254491aff22aee56c46372096535a443aec1dc9dcb3543686a6013cd2dcc101bad8de306792716d94b6396ae7e89df086741ab30901508c8a30b780ef713b121d79c6f72bc91df041445a4b251ae071aef29a084beafb305e34e47454497042672d6b5d68a4001060f1899878c9a94eebdc8ed0ec7aedf524b0e32bfc886f7564c58ad1f390fdaa44fe9020c7ab7c9ade9cdf056b1e749f17398e3203870cf29cecdb977032d3347ca1af1cec503c44fd13a74f610e8ff4cc7122564bc3d9336a9cdfc1e9785a6f3435f9fedc5462ee83729adea013ef4941ffc7c0c9ef84560eff08e0213f1c8b732f83d8fb74c9ab26aa0ba7700cb2d9b1fcf1a916d31c80f2cbff1397fe5988990c099dd35e88fdf39fd657095cf4113fb21ed542a7710fd8a27ead9d302661c783d78abe040b2adf127d381105c702b2d1b930a1a2d3b2f0eddff8fd939d47d5ef402e3eb57ddd6d536af7465d303155fe26c7b8fe08ff1731a8b66c1376adef23865358e455515aa3fcbeccb2b0ed14f8dd41cb1afc4559ae41327959a1a8dd3072e5b553cc4b549e5f62e46e918f83d3ebb3c5e65c8dd890e9f672eeda2f3766dd189ad6e686680958439e443f07fdce994c1a9fd20d76cec13c6244fddf09c22a90c8a5104bc68d12d989b9b84a0a065e083377eb533d931440187a3820753050795a3104e396c7b5044b281b6accc92eb9e6b9b84200c86d03997af82c1103718c9ffb65322f0c713e464cf923276c5c557ea9088816b78248e2ce44a9c4b73be1d0cc2ee02514785cc2d19c8de8f635ba85991a107ef72af64a7815f0b09bdd46c7762a3a0b1880bf9bd2522f96e9c739bc44a9955446769de5f23e328b31ed6d0906b9474c982f2861e3d1cb7fe317e56144996ec4bbc0f7277dcdac91154166ed2e59bbaa5796298d63d36b227b977ada14de5380ad24afcc557d7ff099beb336d3ac8f0e959620f7641cfbc538ef9c7ac0661c4a156f68046d917b33e20e284e9978991d29f200dadc4f4d157a4a528c2ec12c582cdfbc48b41394bce47907beeecab2dbf37674d1b7e923aea079dbae1e87b65cca80861d2680564b8afccb63a206ade06be035d1ce32ab1ba55295912759c1356dc38ec7866aaf53faa83767517a9907776b19ba9797859dda7150e31e8d75b9e69c46028ed0756f95e72c049d0abf24c57a8eac8110c50bbb2075dd7f7f8557b4ac9ef1d0127ade3a1adcd5b61350922e9df286c4a4a080e5fb0a4b12f098902c5c463a2d02428bf0297938cafee118e85874e5f5ac4470186e2c7d4aff5ea104e5e0abc43f8cc97672971bcb6a95228a6e8f6f155e8a8aac170be5a8ab0812ac1eb83340b7605abee854b03f4980235cf160cfdcd12e3d6da217182ab6bf4c7177554d75be47e274decd0646cdb469dd68c3ae762ba3b936166dcf89417f123ba7fb5bd41ab4415d5bdc5c7b2eaeadbff67394c794660c1498264ed4453d79c91842561c84e4ba99d814376171d746a2f098583703c734c25fefbdd6cbc7defe8022c77a8158b20981c408e680ab9aa321bf91c35d308e19e4b4bb551666e92da7c74bc15a6fc2b7f9cdc1c8e549def32c048dba406c5e3687cb3f2eb5d9e420358c5352c85b9adc9a61b5c08772cf079cc18e99fcdc579bb2ec30321aa56535a33cb1ca63088a6379c94c40caa3dde4d966ee22d446358a05a1f503fef291973f31f8aaf619ca9ab5b8b6caeb3be0013b5f4cab19d561aa5a1c68d7d11a837573cb74d52de479cdac3ba46d349ce3aac03a0c238b4f31355f62fafea479bd1b8a2db92ddf49d99b6f8a5dcdb6277c36cb37e7d2f010a5136c5ea3b097a8ec9fd9081a95947d185a6981fed014bedfd340172b3af0cd407c256cb92beb54d916262a328d1ee06ab0b6cfea00ba9e761d43a8acad59454220d05d44582b7270c58def81c20b31273ec73dcef42db8a2e266bd4b89fa49e78fb21649c0e4c142ee413e2bf3df88bc4fa169cf5ecd2547693a202d71aeff9f21165cc147d4df41abcfade1d481a275f54df16c583007a5666f36496483c48ab10f5e412cb5743cabf9713af4ded63d2b82a9dba08db6e664653c8cd36b449a544fcade59092b56c6310c42b96d394d866873233d0b0112f3b9e28dc7fcb9682886891dc11dadd30841dd6e86befede385add064f18d90c181079b5d02b6b80f75c502350c69336a40078c8aa74389fbd66e4026d8fa8185bb9796147de436617c5a4a4cd20a6b5ce64fc357f4c796beaff1d8606f21aee7e7adce83b5f219cdf8da4a35477c1fb12c0ca97e3413858d24c0517018d91d4013b865a6e08f6842e2ab9dd692e286d72c43fc37ffc8546942f93b4c9ab5c05ac3e85ae47e0fab49462bdc266eae9b63f4c1bc3a6e25208f800f1aa17af189e90cbc0eea7ef28cd176dcd33beb52a61b850e0257191850e48217f472e1f9aaef8b0cc21d5781803a163c91a03e2fdf7ff043cf6018aebfc33414289e49351b628487a02308f6f1a560abbc432a9e68713125125589acf42aa1c82dcafae59ac65c642a422a0b72a966e7e89a60c7e4cc13cb222fc42ae7e1a6bed688e681ba8d325b7cfb4920af0071b4b53ab4ce9dd143beb9632af04bf2d2c6b5c0b7f92b22b03d3dd45c5a55f8bce456fed653a09f5be0a40afdb6e693963ce33b4874dcbadd773ca0bcd718047d9364b090de63a06152c64968adf90cfeaeb9a9a6aa966414b1d5dd24092d9ac515dee4fd80fd4d09081a2932643504c29fd305443d12ace42c7353fecb344dc87024d46306d44515a27840f2cfcd56a106a3e11ab55f220d4214b919e03abaa142a2cea473d17f77da94af11ffb7bdc85d2bdae71af1ce90d2c82f1411ca15a64f5c03dc691d31ab652210cefce030b3650d7912ef6fdef5c55f55b937ed41b7ba9612e209f790d390476e5533266f708a0db304b30c408a9ca04a77decdae68f3d68e622d359a1570db3655de095dd2f6d062c0b1324a249b66d0658ef93fe9e8cfeac811aef7bcc19d78eb7531e76d7d01c9be1a6d048d17f22b66fb27cf901fd33a99ef44af6b51a29eba9496c59348e0e573b249beb3210dc511275567779a42314fcdc7e7ac586f3fdec9cf68cc4bb03e12f46356bf71f9a5ef626b25b2913467b27c8eb72d84a9fbdd5c0d914cf063095a8909f517c28eba28a635e5019ed688a0d1923375d13dc81cd077346fdb0a306e5286f21e408bf336068d3259b7152b35081da55fddbee369fc54d0b8ca3b67c14f33b7f25c736cca58c572903df9e00b8e817c1d05da77b4a42430924df8f10a09fd7809d317ba030ae39a3e632ff174e9602d235b19c8973204e95c40684cfccfb9a26eb4bc8674a8d04fbf492af8fbdb7f0acee30a3803bf06db217a4d9f5898e08d5fb3f930d60cd34638f09ab1d3d32ad1a79b5a8c4eb4f5db7959f86115e49c2549f99503f40809548b9c2a519394b225c6a8a351d6fa6a0a5ebfcf485c5d9a9fb3b2943eff5c86f5cc2f4a5f7fecc1650a45df0d21de4ca028f18bd0a4360ef0e14539c65c3391d5cf897e774dd82d3e6882051739a806986850c0ed3bd3df428ce455d707c9ac784ead859e163dfc2a4a0b856f2c376aae7877db16c5c65aef718b33562f5871adaa74cd40f771254fc27c34eca288159a777c97428c5a809a57d1d286c182ecdb9e8ffffd663d1ff09970b1ac2021f8ceb0e3e72c3ebc74fbee76313c52b789fa7b4eb8cc8ece2dca7ed283e393aea3404bc2c8ad29272bc1a9ed5d491b2036d698087d58f4076129563b55426fc45ced7e317e34824837133ec693ecb6e9707b39a6b65339024a522d78c174689d5f4d70dc707b0a3ed95bb9cb5c88317694f43e641f1ba78e5b18fd44199a3b7ad3bd69a9046cffd798b5ae699fee2429ba265065dc32f21cf8dbd13a78186413f8974d2e9bb38ebe7fb0576c9050aa2409b2f20d4bee1f9394229005d722d0d74d9815ae93fe2b71b3f3b5709b72553a2615347ddd4bd1d4963e5dac91a5b567a96ba0bcf8d6c418859d1fa11fa6854dcbafb2ac42364b010c157f64472254040b8f0ffbf9733757e37c197472770fbf43d828eb4c8015790fcd6016d03a548327c802b800a42ee8923b1342f1ad59c66f9ff00b239a81459b51d7052b44ed6a2e330e874590ae5052c27b41c10eb47dd97204a09794c4c1bacd53343467fe17b7f4a9492298c69d3e9eb4183f8a4a2f9511e486f6caa97eba2b5e3fb801f809cac11fcbcb11729ef13c43618784e6fae4d5b011c741d0f70ebd705e375386682f84fc16d5e9057e70a84c94dee5cb1ebffd66e8e1d08052b133088af6b51f83a90a85e05687b66906c46f64902bb198fac0f5676c37e1351a54a4c64bacaf51849955114ed10f5e99937085d04dedbd64f46c85b1a0c345b90a40658e0865a8f32fe9e62f4a886e33f0475f37d4432181a732bc452ef4750ee44858101080d05d550359592ce62eb9a34b0f310b7e79d3fa6b101e9e8fc3cff6899b0f1584f99d3a08fb4c3c1a5500a86b1ecb05a609f6d7aea07440440fb297d6011d46bb1e44223bb7a93a9a441d219dec3445a15621df4336d4f20d4a8742f48a90e733a352c3b0fc392c74c02b503ab96a48ffc4e94d6260972f02f1aae6f6bdc1c382c666ada9b800e8faed4aa180ace7ebf8ce45b533494c13b745370c7732440ae9ccd5c64f0933f1401226e2044125b1e054b9c48b278c197ed0789292e30a56868fb553cc3c0e7c9499dce7466f7f470c8aff190908d08792ba92e8ab398cfb400b6818c81aa17710c3e0ae09aecabd743acb03e3c854639224aa4b150df037a00ba87d28f2d37d63215e406991b2466bb310c875b735ff9ba6da1f354080aca2b67666a11b2130e445c2d0ab0e9a3c664c3724d778f91fae4b4c524d27dc3204d099a2fa5a2cad2448175d4d0652defc2efe682cf84128161630bc95075e49f795f572feae87e9955eee1c13de0d32e534f5ffeaef0011ba40c6e491f07bc4cb90128bd1b968e38d17ad12fc6a7d9366dcd1d10fba41e461e49f8485455598cdab22973edb0fd9bc070877e89a8b0f79f976f3a73f059bc4512c698cda2d06f5ea847cb7df6fa1a72339d2af476c126ff7a23874c0a7aecb4f03fa4d783c7312a5cb2c7d28191b9d53916786763bd28675952142b2e4f7305845fb939eea7ef84a24809e89cf46be65b3af996c6f22f966f8e2987179810fb05793ac0432c58a5991a138c428897fd0b1681dec010bc6df3eb7bc06e7c5f6d16b3ac7986a9f0413a6db6133e8eab06cc312928f67da0eabcf834ca00b72cbcb656f7db4f7343b589ff49423caeb08a5dc5b9eacbf0215face1584d5769b991a1bcec8622583cdcc85371b8c2a2dba97b25058008ede1b6dd6471f8740ffb833a8dd2f2c39e6de436363b931ee94e4567e6d733d8b6a294c1d554a99e15bbd7fdd8b8bf4b3bd0bcadaf7f130ed6b2d541fa3da24f8bca6e700a2ec656edeb8332f1b12d4a175df4b4a96fffe8adfcc3eaf262770030b2a6a23aeb6bd860dbd7a2057a6a1ef38a1583a5d672b188b2fe59048d580e9ff788c2ce0dced45021d155fe6c922d9686696d16e84b002ce17115d9013ba7167abb3163831b0d282736d9f1b9d575c5597f9ab22e2abb0785b2a930b0163b3aec8125ab25e59cb538141583dd088e4f152c2f138eff5a460105c664e67428a7219f74b11e471dfb187b0925761fe7c4362ef0962bd6f4263c299b2df3eca0857cbdaa8f446df3bb46ce77975ba4a54c74bfff5b1384034bb545b23db6aa0703de7cf8f0fafc5a096a59b6aa601823a57468101ef22ec67244a20fd0517a356fab709bf4141b0e947f97702cf455d7c2b320e1b4ee99eae43fcd375121f07afc1e9e7c2a7726b7f07efc5db298dbf934591cfbe912d40c57834912be043aa9a62082fde4e3f9fdcb6440afd102f43f13ea5c5da25d240eb0dda03ea06ec351cd7b75080a8389e51096e8eba1162e4fbe110dc5f3c97cfb38fa9cac81e18bb8d50a6b12e2175880331b122638b1188b243f753b7cc846bcf1956ee4273b5747d2f67f6aca043585bc245c2c1571242cd13903390315b6655fd547561fc8cd15c5cce45c79cb9d82f4cc097ffab82468264ef93e40df6a6d30bd44403835968fffb86e9c562f06005458dfdbd2792b7ee31e4357a57ecf95292a3411faf24fef59401fcb382f5600c64eae8cd5c0165efa9b62dab320cd7a6ff761bbad912447ed30a76b0e6cc5ae1313e297265b514931ab7b31bd14153b1de111d43442667ecbe6ffe8fd00ca2310c5e9102b8f3d78486e06bea1096b080913376e70e4b215d09eae4e70262b3e7d0d1f6b2a2c7d98f79b8c800fc08a2b4774c43fdc2a23b9c9b85f724b21edb77d03dbf200bcf2cc51659454017d6cec5802088402e2072a938193c268acf80f87e223388cf15330334cdaebbdeb92d3f466de2d32a99f176f71a94253695390c97009147b11d42d13644617ea3e817bb9ec521cf933cec63e4d2641f0526c875f86e278532757c4cfde04959a77264a044d90c9a30ccc1c1b35d918e3f3874a9f47a601aa34565b9ed6ca27b58912c27957771ebaf41fd15d18c79b8a39c79157f91fdaa3752e65fae58d998c9c4c0b00baa0e6ecea9eefd6f1509b1f7d40ba1b4855411bdde2a3d4e726040698e84462aca03c1daf6171379cd943e54ae79660aa7491b10ca4913266a236c1d7a9304947ee2f4604a5777df36f299a10cf9fcac0bc817a9ea356a020977a3280fbac0e0f7a736c0fdd76aa35dad50f02578d383f099e1ab725b4ce5d1a2b093db9561abfa546e116749f5254f9c268d98f432ffcbb9a2a98d7c910ccfc9cedcc905700ee5b243b67805b49a58a544430e029b254d15bea1fbd20ee86c8ac04613089f236b98f947004f88d5dd7422adb3262ed2069880533813005d9871d181cf85af76563a1344ab42482c3e60b17acd867cc1c19e02ef5b9c3805a548d9732c9cee6e243cee80098279ade6de1e4be4af85437694a29b700c1c7dd4aeb1238bc5bd2a13eed33c09742d74287513b60258c2bdf7bea6dfc48dd11c50cc71706282f7fae76808ea4010699e4af493513840ac0660697fd1479292b7921997cde9cc45a41d3881be5b48b5c4ea5cb4a2bb8cd252f19ebccf9fdf1ef944451a49b3256c961dcf3da3d11dbee61c19d8498c7dbb2076350f37baab5f121e808199aff10d7ecf86b800042ae1108a560a7483d550e51c520ccb4426d0014b7907dc692b51cef5ac0adaa56294e964c6ff6c493e3e5e1d080196086576cbc256260c1d2e9fa1b7c8016545140d52b0192fa878213d5d7afdfe5f1c290bfb697b7ddf31c364d64b58aaab192c2fa00e05634dfeb8d7210171ddf0b6904ac1f56d33bea26e73e03ef0e5bb5cb7c26a5021328cdde0ac014c4e2658c80d2134dc6c662d955ce1e786c39ff453d7881132f1b1716db58b745df8909e0ae79066b5ca0fe60d177ae1e3b4103dd6e81751772d1e3bd67bd3a912e15a843aba7d9635817e88a6a87b0c87717eb47ae1a5edbc9e4149dc020ff98a8a20f1c8c154814b95c7bb2dae3b6c7ef532e666ee2ffb0cf934d3ca398ef2d26e32dfff9fcc337c80299bcae7ee81e25a963bbc6648c4ff306bde811e7e77a31fe1c3ed9487486267175cbeb077b97c497051ea2a42f4516925bb56093e05e83a743e05ccc6be729c7a2abd7093a7c9e4f9cfcf10a1b0c90257e4a80451f8be54a30371d14a34ec0524360051c3dfeaf0d080af875317ac34150bf08cfa59f11d28f3f5383b0d005d0e4eea0db2c3e48154bdac32f62040f1f87a7a3af5a20f10a14955f3f20f6b46af71b8ecd8339391f4798af7492b44b8003c2a034ec76255425847300075de64ed4f84fe5e9b4c40b2b6901c2e21072911f1c3a4309eac6d5badd53af995f61bc77adf18aeb77e9275710b90c81b4d0b275ae9dc48fc3592c5e842924082310066123c8cd3fe99382a0af2aa571909313b43fdac9954f5f9b9036d8b390c2c840fe1781c3af19bbd06874a8fdd0e1acce0815b5b3c3468f62b1c9c468f15097c2f6694cbaeb87e636270a3c99da00d60976924b67e1e44f9edadafbebf59e286ef638fb99c45c60ec9d421f3271518473820f351e90d1067b387eb953478df42e46e08348f0911af8e01fca756cc5770cd3333e3d05a19bb656b58512f8f75cb254c44de5b2467848af05bdad0fa22a3b305fbfe06a5911d386a012a1cd62caa8e060d3e250a6c8ecbc1460fc5465c334a55c9ebef5070863f96f57d6f6823300084e1573f8847b50aee73bdabb6ecedbe2d8fcacd40c55faa66d7273dadc5991a060cc6cbff41df94cfc8d017cea2ce2ef0e514198b77e3df535f701216fee6d0460e5fdcf931f663ea99b9bfacd2b6b06d127c273fb909ba610a24239fa542b000ea971943f6b3f6cc6e06f26d5685da4f40cbbb4a572c3dd65ef36c9bfd298c30bd05ac218c79f2aab8450854dd114e9e34ca26e423c3fcd3c0a33ee596d4f70ad0a490e7d9000308ed56a020e924e86e52c63586b131c6273b46322225dea00817d15d5d94c780f00dc6284d24f9306810996757be1d313d39d1010a826095250e05837d1f655fd7fa6060d2ad3add758dec4774f0a91421a08ec53cb9fa809071728dd00cfaa22bd95dcc2121ee8c843a7258d027f4ecefcab74d152b60cb59960cd3d4fb5f8a4fb1e5e932da9b49ba5f78c12d65ce4be27f32b9f14215b8893118c6ec165832dd9164cf409ece92df3cb29ecdadf7feed3082a8214447c187afc28eed21b9cd82fe038a28db229b652224d665e288b11d93f66c79457df5b2cfd140789e2f937976f62a7e42b8608759f323e2863d242a396673a201214561a65a0d086c52ee43e34c525a118a3d7b8b2196c8031deb0def03d2e62af2587c1ee62d4f569a68e19e3b179579071d6f0455533c9b369025cd37317ca57dbbd5325b1bec180b064bfb7f84236263a6b58cd732f688f2626e21c910df4c60ad0ef7d29688ebe2040866cd2b9afc2220ed59bd2b1ffbae5d322a645011c1762320a5b52c1019a1e068294c0aa73cbf292ac0893c9d291075160fc2ad1c362b6aaa2c963b8902d1b7efb031d1de0d2bfca91c85f382b6df746ccdddfa39da74021db92db3263d887004262ad95a025caca6989fab966bc03b7bf3d6d6978643644be54070e9bead1056f4681e14ab7eab68636e7b2ba0f544bcde230e6951ae59ebe9178cefc81ecb7530340f1701b5b81fc74656871f980db041bd26bf32783587a948a35541ee6d5600064d58a7b8f76d2a8740caee7ee30593dc702574a1b9b850d9eaa969d02d2dd83b79fb738e344652e9970b92a669f75142b143679e156c9ca34e5df620c59984bdad6f1461884481aba80448ea8cd5acd9337b4e88b678cf65e52bcc4b0c3025ea2c12249b2e5a2da88e547704491f315eab74892528af8ee8f2b65adea45c2334f13e514c56163dd983497b9ffdd4293fd6ae243a16da05563b580d7fb1fb6a300f945ae0e23424765beeda7a33fb12b31e83ac4c7865f93f3118bc0ff664a5d1bd61cc640e3f65822e32dd1b68cc53faa62536a22dd55a4978b1336c12a7513b51eefa62dc48f49f0d58d70e3e1c20492126d2794efaacc6f15d357c9c41428a52109ccbaa66f085788a714c8c155c8e4273c140f4d3e1a493d51ce4b3af3497ddb78960dee637c09abe8b1750e634fac4556d95b31938b3cbefd187fe1bddbfe63c3704161b1a6f4330ae1f771eb9c9da97c8f3caf36c14b2249746a3cce258043a2833df9a49b165c30d06bf09731deca58de6fe7f73667fa6b345c49ba365d8b050795a539d0e6a7dfa8b3c61e48ea414eaab3ea9e775623100d19bc8092fe155efcc7d63c31e002c9e5b6972585aabc9e092a32ed845480d9b2b222e4b619456d2b561a7e57894e2842e362e3d864dc73f5dffadd975e12188d7f79f2c98613d94546a6caea45272d7dbcef52fbfabe6cb132efd09045490fa3b6d3be65926873424f77476e4ccaafa8943a5fc26a64a32c7529dd11512d412977212b926ce8c3982713649d3b3471d340b46b2fbfc7756357c565e669030318fb9c42fd1fce32fb978c5687a45a31459933d8ca184bae56de94f8c9ebd3ae04b9844e25c146f925a7cf87e675ac837d3a75b1a6c15ffb8cb48e02b1d475a91a57ac2dd554cd4c1d8797482e12c2686439235547b44c730eb861017752070636e2b8d225b6e00d16e3798c6a4b4e50445cb0f59a83779d9c7a2c8e617e7f311ae53cbade2d37b269a1823440e3cb469cae564afd6e74b0343e945e52af545f70bcd66321b2bb4f69411ab69d952251869282185b11dd22583c4aec2de6cf6e6bb47968e9f1ecd544b5328b81eeb5d1a3d4a55ebf08baad3f9328b02ec77934448133684a98dab3f418628f32f360ceb99f63803da7a236b3d25ab52f2ee5660e85bfd4d097568f1a8699f9d991847439b512c893cc0e2c24d17d97ed47bcdc0620e9434304f482d2032f06cea0db68afc975869a88f593a9c89695c2c7314d1511ed0e22eab03794a6c443c1961a54d53fb1a7759b31d8618bb6db55215414e996dae38027e942d3a6d0894c3fec1b9ecf6c603da1d901f162357adc6facb53e4f9ae62e4fc64898d6226161407286c374e6d871151aff0e96f47dad6f03fa4d1f882d0a16764c21dfff93972d1c6d58164c251c5e72e28d045e6da2fa18b2cf6d4823c3c7e4cb261282754ad5a620075e1b45698bfb5289805773328d1a6404f03ecf668533e92ab690ca1fb32cb2cb7d5106255f55172b9aa2b06ea5af7b2c51272b2959e6c52329a30bb98aeb7a74a8267dad30a83abf6390a4ef10607815ae753966b70bff273bc6a9a0c6e0c7f5e7f46233e54e1b3d2e92960a81cd4c3f5cfe1ae4f125d5ea4546430f89aa8691f2401cc59a0f51bcc6c8831ba0f2ada15a40368ee7ef3db992c79a658f6fb94600df1f60986327386230b8c26c17ff69f0b3b2d573b63196f8a45525c7c0c82616b8477a9c8896046b977960eb8709c9edae8829bf48c3403db72f6e55644699f72b67c91871dbf71c15d9f5861ca0a35685c8a739f1ca46960f12aca247c2267b88feb04386faee6d673ef76b808a0b0a38d442b4f555fce51c2e822e76e9210b3043e0e6da923ab74725a9055d12fffe6276befb3c29d87f5b0264634096a472ffecb6025189f1ced7f38f1b10f50b5c31bd452bf2ff78256d273fafd2c81a94f3c353532ddc2bb3ddeb7861e680585bc8bb2b4969d47e6592166a98a8635b45140f6a7a70580fa914a5647bb988fedf0b939f4b5f25e436e635efc0a27877b62ba63d3ed0c93c5bd2e288876665bbcfeae3572dd0d3797d3562565723da0cad8d8c9f45f4b32d1cc18389b7242c0c03f478079f6845b70fb2df53606094fbe1c0b2927266e24ff79a46d72f35fb7c0f58195c6f0c8eb890ff45156735a854caea3c4dc0947e44cde8112fc4c98d3d441cc3a270a85e10f16959be036836e48e5b93585c06bbb68a8a8b60b29aeba6f2467591ace640e54f04fe5a04016c22036bfc7ab5d161241c5da109ca915d8c5633e1118c04872683590f1d95dc5bc543064e61064cb9562d70a4a4c280e2f37941be5cad29ecd8f66c2534fb0d80c73c95d40d2bdc01917d8e680dd78eb5cbfda3f0d3ae5f3253c278e1f736d6d8c5fbd145412143074c06eceb1fc55aef87f3259078a342181dd57afcc3856a316c2858d6853c8e6098e5c24690b660a9ef4ae02c69aee60d939110d7a6db6fa64d3f2927fef409716ed7581c6e84b287fbffa421fe41e67b7c64c15d11336e4cedab7c8428322dff6ef4e5be3fa0a8381017837e140ff79ad264a7d6315907940e3d53382e7288d1a653cac41c35a59f80569fd5f4a3b6c49aca5968dea019f100285df472d58c517163c050765e4146e248f0d79a1f2df336ca86736150448dc656c76b198743c573a9a9a79ca74394e9288e80f9bcdcd8259c0e239cce57907514d7d17f0c6afbb43fd4f8c438452635feca57164000af4d105b8cb8cc706b12fa452426846000e54a7e0b0e9ae05cbc6dada0999a7c18ffb958d7cfe23dedeca811b7a0da7b2d2646d10a2f069cc37fa23e1b973fdca693c54d75f6febc083058b22849833ffe0ba5e2a114d06bd4b8725b95af9aaeae6010d8d8ad3564f9b92f748672b4bd99a9af4786dd41869e373537b94e0316039833c91dbf0abfe851fa2072d7f2cf4aa952909d06fb94424a1c75ff1138bb147ccc295f6e6a34b7fffee195be4f1ffd543d4441d691064f15d08fb82f7e85285d8190ed0a0f96614363a1ed0a504eff49d9171ed6c5fb58a9a6e29d2cef1d4d3b3ea13c2c598d978020be1583e2c6093af345759b8668b5751a51b0226f7a6eea9a42068d8e27a1d79518ddb05b1125d63a02e4abb99737c3ca098160a7fffabdd3aa772bebd4920880e9565ebba51ef8d437a2f46c9d2991554721303737e22b5538a32fbcc4370f148c01d95c69c66407b39a9dea3019c987ba97adb9f57078c6f45b4aefb56ee13b100f9f2593d61a23ef4e136db1d456b594c8bfd4c4a2a0082e4cd3b608986bb45cacf709957506c504d17103fd516fca482b05312879688bd6eb1a087a3572972bf6f8f0e55b70f790eb7a9ea79e67ec34053df6a615d266fc61577ca09b390b1afdf8dea3953656d0c896cd2fe91742af2fece64057589dd7e05285604987a07413af0f6cdf0d6ca0c1f540f41c16b090e5f40c118822f95152c67d965b27428f9d481c2452652cf6d2a815bf8f051814af0877d0409400fcb8ed11ab4ff5f4359fe809ee6a9abdd68bd28408dea012b88167e7b12e00ac8b296224e07ae54c466886d3e037a94ab04fd50c2dfc4cdd90eaadc0012a1f79fa6677d7afb3cc9e2f6aee365460b50589bd0dd6f48279e9bf702bc8525cf68aaefcf207734f37ef8be87a109ff5a3f01d51be398bd4e764bddbe6fb9fb6a3d81d364a9d6bef4d59e94e5aa84aa20bf90fb31ff0c81c08401ea98bd147dd82a949a56093926755d7ee717bc0f6cf932bda73542e74ca8cd2d852701f1535ebfbb8e8cfb1db7fb714f4599c21a5cc4b90182f4fcfb85eb05faca9643c1bf30005eeda6cea3c3320bf7b0427d6c5908c08c40e95aaf25cb190c582530e954ee8c7cf7db713beb64e5842201f9ee35f7c98c29036651df3c7e3064478411eea014f96d08a90fb94ea71c71a48ff948f7bc4cd7d522a1b7c91cae993e29120ae8d964bf7b31c2966c77487b4402c8383551a18a9a000d1cd0182e4ab3129c80d991b7d9cd9407efe0ba11a09a54c8bd55d528e3a16569d5a4db9c2e60aa1a47a44e5f42fed485907482a70b310381db3ac7dd550cd2edaec1e41ed4feb0584696360d17ceab7d463f0a51b4b82f777ff65418549015ea8d81cf61533d4056473efe4aa68633a5c9851908b26e15ec0020005d8206d540e92050fec19ba239993f3428c193d14105600b4104f7557b27e8e3e4205adff9b4954bd22a49258c3c3987cfd3a567f51dec6c5a9be557b705ac984798c2b9d9ce11bd61c81050019927c75585fa1d5ecac68d637f71243957371c6b649a03496891d4dfb669518f5d6d2a541f9b9f3272f6f66872dd05b448d5bfdfd0043b9670eefffc0a9d88582b75bfc1545d4ceb5bc4d11f980f0777224aaa840d07feb58820535f43750643b0b18004bcadea59e164d01634a5660cf9dca4e9b414cf80729ab2e9e957967a9a29523705095c3c7b9fe8981794c092f213055f2a32c3baeb7414cb89903e805df583e122fb73adc7614d37e0abccfc468001b7d4e64e4a5957c61ab5e651dfcf78383cdc5b6a0c9272bcf4e3ad82ff2786fb6f51b71247d17476174131ea6b3307dc70904eec1578d0b230ae8b12512c525ef7bb6003c19093f5bc384c4559e9039fed35cfdde81a4fc56abd427051166bdbe5f523ef14aac0e4e5aa17fce4446ae5376fa8eb6b5db85f78892ba6fa08dbe896e0c7f3d48549bcd79361cbea54281360fde53d98cfc458f24bc5da94a8ef792f0a645a1fb9c5676ede5c9033dbca3da08bb50bac409593c2fa94fad3bc0890256a5626043f3e97c292f185b7587860e2aab2ee186c9bbbfa31d46afde76b7ebb8f31ad7f4b9be11e1c36b5996b5c9dd948b7c44f3cadff1632735ed8009ad74ecc9289a08218b8b4b0b6f119775f8a0572db040c7844587f75b728a5d17b718440944d194d30f12fe7ebab2eb0ab2698ef5cc60c1dd5e10a60fe8573b3d8e7c05a2cdff1eeb9572c2f76f330f710c7ebea9068d9d0a6dba51fe66f9d3d47f41b9872dfc6b735a5a037522162c103d0b2254481ee6507c30fd5e7b7ee1c24b2ac18cbed077a62e5d2e22bf4a9329fa62dfef7635fda7d1adf0c464ba378abed079756e2d5e5a2e1ea64278fc7a13bdfc0ddbbbb3dc6694841b89ad3beefce50326a36220f64d081e47597ab5d0e5149049e7aabf591265714b27885dbbea27d5c0872155d3d4691bb10494916e5d352d9fedabeb4954c3a06a8c472b07fa2a5d31d136e886be9be52273f376543dc097ce7634d21c02379a8514f1a80e54604a92d9c9fb92a15926c9b8b4f651fd3fbe7595af3876fb9c8cef3139f774f60b3f9f53ad894b7b0fed98b27bcb2746dbeed0621cd5ce6fff5726fb921e014b3ac60dfd74e8e511eb6ca33c984f4de7ce8a47fe80aaf6d6debc93719adee2e58c3b43f96e8710575be1a5164b557b256045c1e1efae66e6e1a024f7dbf0e506368385eccf25bef290a1b059c8884688265abc57709a21ab4790567bb20ff146e16498e601599b54bca7c4d9e03ab58b02ecff331e6dc22957fc0956ec093332a3467473737a523dd50f80ec98d92814c45e513ac10baba0df01bbe74bca71c8051807b1b7f43a642cef9be527b069a8f7860a5f3a082a89eb419220008e2263e1883e039d6430b54d36e30affe64e27279c87bc1d3e452c7ba14abc793e896bd435419bb8a1e2ba180d9c191f62ce268c3d9d80db093d8b0d174e8cd00dc1d6faf20432e6f6dd776e2aa2ada433ddea89409a054cd8b9e59c9bfef0e897d4c9825e7b2b96cda4d4cf12bbdb149f5d81848c9368a48fd0e7537ec667549536497402f2b25b65dfee76e9193835a3de1749edfff11b08d60c86c796bc2e629620449cf0d8bf275ecc8130b0ef9524bda0eabbd9267e26de4abcc691281b9a392bee92bb76fa6e7046f4441237c54e7994ed924c645935e051b92f3ec5888e7f671e9f0b52f86a4647a21e925edb26b175e17bbc486f04edcc211fdd4df8df0dfe064bae7930539d9085c7696df655a479ad34706ac6426c96678d6c756a9d30864cc10c8c283d247d45a319fae6d95b529b2b43ccbc4343fdf2c01db6f5ed19e0147404d03f2216dd269e086d0bad9c2e467406260aaa04f8daf2c7bb7e50f85f5b30017041ff5e633fc76ed7224e5d8fa0c53d55bff31643da28a63e4c38031a0060c59771603806fd15b5640449044c099fb3837ac426efa4846d2285b2907ede44f940f30b24d95676fcd00adcfec4228a55d22f13f56cae82e48315b026065145f5dbf70506e4bf43fb28b59df600887d96162f4df8b887f0abc3e2f56c46d035d467ab144b656d4587c8859743a4dd14a31c66006cbce5810095c2d761c60423de615f665749f390b07bffe8a883fe6ba1a2bcc1e64de135bcac2f4e11fe39890fa8f65d247c8c1e54b01ccee87b5a8207acf6e55a19770b8e3f1bbb67c96f26537bfff54c57ccfcf97f6c6dc752e2c7c16c746555cf9c56e9498da9ccb994acfb6cede2333ea6e8d179fb764b58842c4c5ead85462b45d4aa87638006a03853a990d5090a20d64b828873f64b118629c432a6d12394514684e540df5cf6ba1af9a8ba8fea3698fc7785b8be80b160a32e9b442f006cd72bc6397d3080e8efa9f9566bd25f040c9e504d4881a578dff1b4748b6afc23186f936eebe43c30024f53bc60c61122fb16ef6d1252b501f93bdaadfc6e9c7a5d0d8bba3b90a98c3dd6ab975661f12d31384e1ce24ccb61c12e2f8be9e23cb7995698ff8f2d7fc85258e1089c30f96914f788a4a03c9bdc4aeeddec871d297d03a2273a88d99221a8e9952c079733d9d7a7b2c40136c5940946cfee73aec83ae8ef26b0e36e53cf6dcb0f743cf3b3716623b7a7edef658e33ef83e552e478b1ac9ccb70134476ff3626a423075c9632e74182643b560296da4757ce0bbb1acbef8270b6a2132198fbc91511c5d5cfc71112bfff0abde9a514dafbb023ca17c6115d41b14d0711dce9681e6270b3bda3d6c273f030dbc39bdf8c30ae64685876159ae9f9cae1db01608b4530fdfdcd3686ad071946de228857d36fb30ae2108585943f28479572a3975bdbccef0e82e9cf4628ca63ca0b8b1eb9bfcfb7d472adbd130298f1b93315c7023bfc19dbfbf7683e2f1ab1683c53b7f3c090ab2c5c9d3a7ccd21b7bbc109237e845e03479ff56922365ef593e4b44a7bf173091051d5e8d8033f48e1f08285dce4e3c9ea1611447b6273f0a33a1591817d5f3e5a542a089d20931e598e6b8433cccf6f7e9e8cc1a10856bc76c2008770662fbea379ebe507acb4eceb049c82d445e8439ecf8fe5f9386d0a2c379e456a8a021c9a6f66815bff6f9c776597346450baabdd95cc8cbf2897dd4d551a19e75e6b19daf525d1cfc4cc585039781c8edbaaae81097efeac4c7cc50f3ca5649449929c9d9322deb560964efe19b58e287f29702b84096822789a313b3abad7ef9cc863015d881a6973360a83ff7a27d806f2bf8b4701ccb537a725fd5088b07a876d6ee440b456676d1801e2a4b8468ad3884b28b35c1908feae53bada48d92a61d8998ad74693247c835ed28687e7f667d99d8387a94007ea4f9e9e91c3144f78cf89e29fe4decb8e563cb29a823eadce4d97cf41f9c57c6856ec4d6215bf303dc73eb01d24e937072230a17697a6889aa4702b1d29f5eaf28c78f40b42e71322180fb857b7f051d5d2ebf799d3b767fe0be4968d5f419ed6c2fcec884b0a10b6168db7c1963be13956d061e779d14ca7452db067603ba011405ae18b708d0450350cb04bad5c98018c26df132b4978cc404649ba9a091da302bf4f49c55ddf2fa7e240b457a542e7627ca38680324419ab5f80f7435edaf20a79c6047f4faef095e9fadd7a86b709e3d9d926c32f86aa5b92fd31826d0d1b7d10545d535e7df3e45b9211f05b7353b4a94b74a18f03d2c5a03ee21a034481b7e15fe39f6968dbab930ca86d3796b57d750139d45654c5a4be68c4324d8b4b258e11ee7c8e98d0e0ced11695876df93fbd962f1ced1269615221a28d8b1e38c3f1dd6d50ee691c355229dddda1f112a4e1d46cdd4b645ebc844640fd4130b47b9dadd60e248a74189348e77a033351148b4159245c8171f3924258c060ab3f2dc26adf719ab1f319b86eeb39525750af440b3e419019b05ce6dfc515c98743b5d36960331b85419998e1ba931d3b3f934870ab6859f93336396b3a015375840cb5bc453d2de6c8d3177968222b004dedd60a69e778f3c5df93a5292b215da6e68903117cdc798ecb0d0413affb5dc916a1c7e1af115092ef173e77240db205158018cb46172ff4baf1db5d8791f83d319cbc26c8303b4748d57ec8751f9f0d2f495eff36a52cd92250100e53b37c8e93802d90f85e53db73619fc1d1b0c1268b82ad5362538d42b5c7511eb5ef9e225ad9116ca96ae548f4bd98d995e21981cb981344aeb3a2a837150594285cf8fad55df38e2a41bb4f8758ac1e1a54a6463f8e075d95d4efe2468e97a864df5b0234d88995678ea97621c59768304b2b607967874c362a84add096dd45502f0d424291b1ed9ba1d4fe230383ab42e55f575f0bf069b6f5ca7574fdc4c03f63c728bed4003528d4f5a95b8e854a270800f34a12cc554add7999f0b770898d83abd540cfcd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
