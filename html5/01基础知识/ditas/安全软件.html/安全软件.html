<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c18669a8b41d53f682d0b8491e346991bdf424f427314566270383aacb2c04598e9e4db521e12cd1c2db943c7d965c7599af7a5fae0e7d4861d49f0a55ab38d2ca2eb209d91034b1323352544d5e0ce45e450e4494657c937ae8a3dbf3bced8abf09ce608af83873e4526b60c15ce09dfb4a22ca10d6606a7b9120cb4f2acbfbfd49c10c82b7f87fdaf98c34d72f123388b5124569a4225db89680e32f0b4967c99f64287c3e437e03fd81405924da3501713b79f373df7ad7d2cffcc71114328ede67430404581e37b4fc37d55d9ce6907d3171a95953805a21dd29a741512635bb999ff8403b00ad7a8b439957259a557c2f24c8121f99b2332014b51f2a1fe64f6592ead27aa4ca273f6a48b48a8269a7d371ac23ab4de827dada30c019c4bf00862720cb69b767f3b0166fbccde70b8476733116bf397340650094ec1ef6572cb6dc967538533fbd0916b70a795a7f64842709ab80913b6e6a03a2729b8425c16a1b761544325fb5976aae61b3036f56a559a18819f7dd64cc603f62867efa77ee9ae7b99a0a1c2b328efedfbc37cf3a10d6304ffa3c0c491f88d668d75db458b81ddf05f7eef0113773400475f4114b2415424931b03a653daac134039836839fe592d829ec1a0e671674d4922608e43d6c226c2390b3041e6459fcd831dcdd9b9bdfe50ef29acef60bc5b39c2ed8d3ad29c870782a385fffaef11b09c777b842fe9c202ba7186b9c84f9650515edb336afe90a08f361a49fc994cd02b79f2676a78d5be936f834c6f550903bb6560449352ee955c711091babbf8e91cecf16586bd39cc20da277678fd85653626a37e10a84b3f2147c01b55eb3463720f353beafc32bb6af522d3a92e132c4b85057f4b71712ae61667e5b33ffe99c2129230c1f42fe2aa1f8e0090a34972b1d5234d4be22393fedbd5bc8a1c31f60e15c54e84b31e64913de3b27ebea89a6ade703400cf80c2adfe0c9cf377ceffc8d1358ed37a4bb5c0063c4960bac0dcc2d9a63e9979a2563d36ba7a9090d8e0d74853e8539305d6fd2d4cd8f672e8f56459a76901d4124b49fbbe2465bc1079a2269593a2461a7d30b6b886f3fe1ec513db458ce3c4b2030c8a0c09cf11e9dfe5a28112fc728a410bf493b4e03945e3c11b3aec24efe7406d17c54f2d2ae15e8948bf14fc8a88f5a8a94f439c65411a0049fad27d808ff9d76ecbb60629db3326e085aa9d865230fcee95ab59c6d74480afb389920165f4894e0cd663c1436b8ac07e59b4665388af685278fe51a48e9cc38cd7f2f6b8d0887039dfb73904d1abb2b8a2b6e7811c122ee29b03a4deb18f86b4f0581f1b3984c462d56a0d0010b08a783774b29e43481703ac335e81177d62d748f2a50e844938d9532142baffbef82163ef1427572dcd9097bf6f4a416e15d07bcce795515f0a71d6bad23c595e33e9cc237a3be34e9ab304cc01cd1c2a7b92ea3e16f67aacdd990a3fe01014d97082a8b2206ed2530927f8e219ee91d0ff4c52e9697f1bcab2ad4a312caa369d2fd56f41da5cd1043d8d1031af8f765d4d2cbe9c2aac279d848cd7ef998f34c4e4a7ede2a8fa40fcc85029b1954c67795e642e9239e83584a5415f4295f1670fcd2f2a1a3d5c389c27f167dad5e4640cc82dbf1efcf24857bdea84fdf20f0a95e3f3c37bbd950a45c0751c519970755f77eee356e5dbf42b13ed2111ba4445c2a8fbf5714c45d8d186d764533bae321a299f4b2ec7edd20e1983c33007b4d5f6be79f757900f62e3f5a70de3b9441a456b2f17988df2012e63cd0dd8374e1cb71defb5792c695cc73d9cd67619427d2db2243bb4f5a97a4efe1a982c1468ef4304404b3dc399ff52db3b4449c8f386ec802cac6ebd71697dbfe2f2ca1d501a8a8bae01c1c340f456967744817be63f5804e2e54121b11ee6243587ef7b140526563fb6a535cdbc07ebb7e9501094328b2fea8590ac72d35c9ed486268de6088c05021c0819bf25f53919e21e12fd43d3006569612d0d0783fe5fca60ca1366e4cf257332b940fbc4e20d46d8573f2bda4bce9c648af4511f7446d70db8b8d444c59ff2429649d9caef021f7e451e152f192101cf4043db8179698751462ddfb12a6bab0dd451aac52fc92481895f7a0220735c38c6aa5aeff44a7b86ea56b326c8e10387fec356cb921fa323b76b8222b588aed107bcca0dda84f3d7510f931f0b1c0b435d105469aa1f67795fc1243e78f87cddeb6851b028be656f82662f54e967a3a5449d456c5e67cb85879be9e276eed4aba7406ded58eaedde79b0570b22d9b2de42b674d6c8a500a6bb9d7e7df59aa73f7d3e49c2bbce7e61e4e4d0b48deb33bab4d3a39e92ddca9f6bd341a15b6e351db1b632756d682a5ce50642c1451f00e3bf48d49c63ce95603ce763efc19a373f4bf430b4d88e3f1d4640f9633b67a904743ff0e4bbdcd219bcd465e89b2271b6ebd272a249864a09021e2e0af3af583af0d1a6b6aba3967754e67cd3dc29d5447644437771f3318b1defa0c530ffa186453e5e300b3c9122bbcc113ee9bbf7f0b00680b76a1fb62ccba40dbc6a74f15effd9527a9ecaf0399fad2fda4b74420b8d2fb50da4bd1d1f35e65e6e5e5ea5d45d4640fcacaacac942f00b26e71261c33ea81d85f5f1954a87d240b3f6ea81275eac2b0a86c834a29f672fd2b6f5a42d51c7f6fd180d998442a1d9f31ed47db94a66086a506b1a26a49c70a09f1205391800f2a0d5bd0bb15727261cfdc01bc8f9f975dda4e46a4a0845a1925fe0360f4ed35d9c2ceb86a325b43f760924d2f11aea8b819806fb9c85e1fed5100d5d4ada1629eb2170688b99cfd946e9ab03365701b5d8a1f94613366fd12d85b59f90dafd19b9580cf6a3551a19ff9191d240bb2880fc2ec1673c3ee6ae6fbf356b60ace438e20a7ead3ffc3a8c779ecc28990bd0c0d71b751aa6daf7ac170b94eb3b2b8565a158560abca0319b92ddf651d1d818e2b8920d53b473dd3b59909336728f8b8c8aa86f4023345937d9dc5a496512e33ad80bb42e56776b87756c7bea6660d64a452dec6e46715d19498115bf5f8d5c53515a3dc56ffc47925c6a353f96f6825a87fec5828ea00bc5247fa24cf8f70b00660e7e041addd45e57089c05bb4fec5b5aa6ae4a023e66484762493e9310b6b9080f28e9ad5ed6b79551fd4c4a0fa29e851b8c61a46221dd00d432356ff2e50f536b7c31bbc6f43b532a3e6ceb68699628310a43ad20cc757d043330c0f87235e4979ef2b5c702c6f4aa4e150f29f49658288666af54554fda12ade023cd384934eafd230ce986cf7acc3f6f1d3c01f0dbca39300447441424c920aedfd919cfaeea232a32199c77ab7a47f79afcbe52bd8d66db17ea945e486a90b95817f1033eac04562ed7de7758ef12744a01d56fe3a5ab84139504cf053e033f1ad59f3fa6bb5f995868a2bbce05aefdc0dcbad7a2f83ff6756cd06cde89c71c8c772704c6000c0ff70a450d23f801f8d73b495f73b6f45359cc9000658516c353a2cf09f89d2df896365de2a7600c42b36fdc91e31e3de92ac4fcf745d5dcd8ad4a51e0459d6016d477b187d0fb26a92107cd87c55ece806a385321a97360b292078f69ac7a520438380fd47dfa7c41c43c48c21216d82e0014b0809a977665e4eb40c590212528dfefac5489d0e98518dd887716470be78557c5a1831604ee893c12b5d6a78f21d53e8e879cf28f85d196ae71b2872acf34be66f56c3e26bf297c32da9040aa85d281346c6e0a25e41a245c605aa6af49e7b13c4b5ac27047d753d2b3ba3cf2f50c4567fb90d8b9b1dea6ca6040ea8d50b4caf38ab6c0e0e6103dfb944eed9a204a5f68ac5a0b1cef5a606b9cd4c30e200ff49f6c6902673c1a62a994c153daf57ff20d6ac36b443a26ef3c77abf22010d3199ffb82616495c97c402b191b83e521653c79407bb8c40b0f5abf76d62ac6c09f079d81bba24fbcdb74284f2ddf548a0cfa36a0ac921b2e1b14d46ef0701e9dfde7aa40e58f6c3c987fbb3eb50e1224dbc46e800b2cc41c5be135808fd22aae782ccd14e8acaaddf2a8e6f9777a1ad63c120d271aaa9f39d84738392984403800c7ba2462108fa5af3788c37972869d8e839b6d264ee63c27465164e0846358ddd89a2708096147369612e4d1e6901729da9f99ee412702f12fc0038433b3774f703ae26e8a6e403c687780e3d987b497067c2b90d4f97efe9a5e912800b9b57acea8093debcdace0af86fa60ceda3088b82d9f41e4b524bfd243c8cd8bca82deead37e3cb0bdc93db264bb30172c8de67419c752500c24001c1971b6d16e794caf9d42d169ec980450258f9277e9b47d99fa5baadd0e22d5f38822a65beeb0b9c5f80a03596f9f8690bc93ae95ce1259e3bae9d837253bae44460d04e89773c0a63c7e0b11d402a5538f76ebdc2f13011b5c69f44739efbd54b32765198351c95d5174a73596ffd723f2b3cde15c105bce7eae84dfd5c1080484d5ba09da1f0ea9e6afea67c0c845157bf3b9750a9be0cd8eec72a0e525d7a64570032e3c54abc0b85ab2c887f389c6ec0a94d284cd0a75bf9af9a515d75f3677fa839de8f7d184db6584a98d2cc2efc17ea81a446ddeed2b661fefd06f7723e678aaffe85f5326789b541a570ecd961e2ed67fd541e3837a40f2fec9a3e190acc24feaf714ef6a272f6a11f6117f35fb787f75a519d7ad5aca1b651b1616cfa5d5467a49f20f0f097d885433bda294556bf451e948082992b8612d56843d5eae0e8aad7f11dc4757725f5d8f3221bce8cb5ffbe8c92e98e62be5ccd1dbe5b240105699c0ee670e96baa4a89fe951d7729de5030169b9588d759351cf25c93a4497a803d5b03b7f036402be5c34f4db0a18e83f5395deba26fe519883197fcf16b10fcb6818aea5fecdceb5ae4515097ca13eca1da8d8f1abdd6a277827a7bb56ef705a4e87def8f5561304c780e3f284bac0db6caf94d5731419cffe04e83f03a4452ff99276ea9fce0b47d8936b359c097889c5a0570b7e4ba9f9472d0de01dbf1d757472bbe700ceb79369d77d7acc8519b5313ff4bae362034245e34c5eba29a49214a2f513381acbdfc5e38df960d042c54076f6130bd1e55b6a8719ba0c392cde8b7cae2d80a43ff0e6dd4b2b991c9a95d19ff5fe109cd764b8d29becb832099fcfa2fb4b152f8bdda1ee1d9d3c690260d6df27d54e4df3406f643b8d21adbdd01a20b3b62a7c240039ba1ddeef698fe9f906c3edc0b70bdd558dd7eef7c08a927e66225395c60e6aafa2806c1e4b40369fce8352d266ebb7c02e0ded5f9eeb3c9dda248d5730dadcfa7ee378fdfd5254c8ffbee2e284e6bca86cb8f9e29f308b1fbb4cf429a6e796e9d52d0550a00e8745d907ab2e768b2a92396cdad635d7012496fe9620b09f4da462955c4c059d1e38a099ea6d55dd41f073174e7de92d0f6fa2d529cb213d8aca11fe12dd5c21b6db47e5d4b59b1d902c8c64123f6b868612418315c230bb550fcbdb706db3609e7dcf01aa6db2f93291dd616b78d8ac8079c12cf1e04f236d871a20d323d904dbc81e079af3e015ed5809e4c4ac83818737f869e9de4b11764b77c42c24fe23e8b9063dd5262b75a223c5678bf46ab4ec3d56d6647c54e0b2ae6455ecf6ae7e2f8a9f23832656d40aa172bc14205461a5068fbd70763ad4c89184a5e2950601ce1ea84645a57b25f86ac1b9f074cdd579e43f125313662c8d12be739bd96556ac4191c299ce75bbb6a67020e358645fc93977bddaeef23a32d29ebd4c4444405049afa2493bfa20f10b0911618bae604a93a7d4e199156f26b8afdec8e95b005409f4a0d803560e3777bcd0410ae8e23e507e6c959789df29a63f52cb8f6740c583ee01fee4252bd59874eeef6ae7164f45f3532979b095074da6ceb62cc01508ddc436bf5fd200410d5a6ab0580fd673768a1f8070042eea5f23ca48667596a116c6a5c55fd9ffdb819cdfd9347c98c0dad73b7c4d0e6af83d262dac069148462497daa2ade5299a81778f0be167c77f34097b2cc114b506984bcf12765ab906b22d69c3bb14ff2b6cc62de68dd9d743e87d83409329319ce6b88168c84199ee685a238e788847876909761cc86de114ed80d0ca3037fcbddbb0e99a33e2aef8f5281c2e88cab7dd39a043d9db452959f7f995680cfedf0bcd52edf6e41dee1a52a0675cc3c56d7cba14b3ff4e54d9805dfb65f68303d9f6597d5d89707c97d78cc11ac4be73fd9d8b0e77c9cb20c6afd08c467d04dd41ec8138b570ac4b7ce58ccf621d1bd8bfe657e4cdd64d77caed2dad10bcf3f369e5db764b75f9cd096807b0be6de691e49a34db594154b6e906186e978450630c6f84b547eb761b6b1cca8915208622c4727e936789e4344fe5f5a085311a1b3aac3d0f53f6264394570d7e3da58593c3abd62dff9f501579ca61d3f742562814ccc29d8b0158a2694b56973527a5213169bec5b7822b7055b6ba76ce7358d74483c9818a7660c9d2508c63261f69de4bf43c707fa05d09a739da09e5c4279576a29318ffe741c3709a665a84f22753b38b36c13a9c2a134cf4cfd8e1bbb9aabe9afc736c3314bdf081a387f41c45499edf9cae35a6862bfd1596883342b511faec73685daff784c786cd4f45439aa4ba1005d3205679dbc7dfa6cefaa4d1d6361b527d860c6055159cbe9af4154fea690ebbf6151dfd9b57beb1c6fa8d172504eef1e05b1df4d1d65be26312acb62aabb2d46c4dcec555f9dd79086c3a9250328ac19549fbb679aaeb54a0d8619e16d8e8f1aec032511587d3d2163e208cad4f1e6e7f49cfe62f68e3022973b59df0ce88cdbde7ca47e1ee426d2970ffebd59b0de5b7c02d9347a74b459dfb02a4e1ff16aa224cfd7c59b863680261de8bd57d7122bb2ef86f3e7e4216c5c1cc8dbb81f5988cf408978d3364674186946763d6cb9d79e7206f4b740555d2bb63cde30ad7c451270686f149080a3bbd1a6c889b11a9d0e8c98865effaddd72c6e5bb563e9f1d35f66937d8844514b33e469efe5e80e6afff28c4b66e6123a82223282546c73c678c6b60939b1f1c2480605225c3af57367c5d545274e5df92c596da9ebad462adcbd0e5bfca70a1af172dea0571624fa3f73a82721dfdd07dc209b1fa6ce22a7c97251616d9622a7a2a32fde83388a39e2e1b60d1735559acb569378ff9982ee4aae6f7c6aa60867877de907fd82a6dfe788be761f4e8d2d1ad6369b85f18e778919e6d65c48b692c52a42dfe35ced47be5b02db57c5893c9706efd3aa95b2ae4a3dccc28a00aeda095711fd3478a5a2f908dbdd66b06742db54df0868d8c26f888ef7ea329dbcf189062221efe11dcba687fe7eba824de8ae2f5ce252b30316cbcad47ca1bcd16be713ce831f51c51698ed5a56b9b0cec86e63d4c8e1864d1a942788c8a65450db9be74653dd12cd2ee32fc7b8352b1851b5b8179533e7272f5baf8d00235974a6b8f41346e29c0e5bcf5d9769bbcc3b275c172b258081d621c46cedf19fcef808f10341d2e9b36d1926aeeb43fea5c347b253b2c243eed92d5e0d74751ef879080d6810439ddc03a834ebe04611d8906a14547a647f4a99c9d949e953f6cd07774d516a9a7d39b619621895ded5e169656e86dfc92d72f09bb69599ef232f2179e1b9c87396b69024c4fccffd248bee2a01c0de987504a8491dd646b30e38c6ae5376d644a29f09e37a54f327c926c9631eaa7130e3f0971768cdfba2ee62957e8623381b58cc007d84c4f8149f027de0bd34f7483c588f82757b8fe09310c338c869889b4069be446d88ba9d126ac9425c6a80ad1858ece32f7ccccc8a84f12a29624ffc71f891af2a798751fe0460f70058a92bbe89df77bcf9686e502c0f031c7507fb74bc62466a1d0387faa359ab783b5affec397a6d01320e03439074ba3e2119f8c9ce7b33923792710094ce36f15a25babac5914cf7efa18db3192691ad46b1faef696ebf95608594f86b211c2d8c61e7f1576938fa9fd0acabcc5f45686af5c9c319fea8e3b7cfb265ea19e5646c68d424f046a5ca1c96b4b3b64b2cf371159fefa3c3f5591101f94d071cdb8278df7db5d74419c0e2e6c3478e5a4611b9851ff57d33a31e66ac70f8d5cea05b17e917de9f2c9acca8d91d381dc4b4345009af60b5b4265621ffd310adbbe4ef2b700e347f7edd9b24a37483c1adee0f0670461a977e230cc8b76c96b64ba4fc82c57b5377d5c97a89acf6ae4168cdc86f5af4745fef16d44b7b382b27c93fc71d23da686f7f8e6855cd77e527e68ebfcfd29982a715b36e5f2cd907ea5a35838205504a8959e73840059466c97555de698c88b860a5c85634c1c7340addc14260ad32a9d59cd07f28a95405458a2a2ea36b59451017fc8bd49a277cbf337e16dacdc3ec5bcec327268e2d5f22d4f2cea51ce5d776dc0593e5f98a8b53add2db241fbcc6f247dd94744f676175310fe4607edd72cc73edac463ca6f152bb711bd4425e51aecc7faef0d414c6312526002d3f835afff11d643dd5ca58000ad2bd51e663c4cb858da5644bd9d7f61dbf29505e29285d39d1f235d135e51addba3ba776e64dd99ece3ead78aa4bcfac4f93dfc14fd758d7c75ce3ae721539e2494ea6a50d3907f59d3161b13889164ce685fcc3e5200fb624201e4abe57db8a7b68790073518b6dd5763488c5b3f0d235d834c5fb6236ac95927c9485b25dac4f8fa0cb0227cf6f56ace56416a859968604cc90217ed7fc358e0d3ccf584e2c9f16b0a113ce933f9b42dcffa0c4dd3240f5f1fd92cfa62e6ddd85199e468ebe00561a2cd703408128e6c953df56a8ff196617901e643667d45477e20680257be96dca9f2500d0d7ee862b57275b40321e0f22b7bc0ad45501de9fa3b6d099043715fc2808b700b93f388ba6bc37232a79fab5772f0d6d341b72e9afd61910dad6c8660952303191ef90a2303672c4766e41b0b176e0709d6a8c527f0b9f7011fed32180ba1cb8a3cb3a11463b26c18bfd108b2e724725560d21ab04a34e8cd6ad4cd3a66ff97ed8b1146d492a27c2f627499b7b50216f86254776b606b99e73c5c1d395fcc577bb0b6f0e51fa3cd50fe849b4c520157fa98b73ce1a21bc1e2fd39155895c54662e6333f77b0525955b27a5bc598221479f7ee9e53d6e0270cb1a3767dafbbbe583f1e53d3eef3f92cdf0b5bd3dcc5a25f5649d6504c520154e3ca6171c1b99ba6f5f130d871363f23d8d3e2ef44be87a3e504b7215500e53561b4c870f581065021e3e55d5e8981e630da32b20189d475e1b4f8a0b9502cccfdf25be381a52ae3b63ad8845f369aec919e8783e5693628eaa3e6f0da21f8d52abc0fc510598a2b3ccd9a002a691a67ddd688a04ad1f84eb6ca6dc0ac1b39873727e78e41cb4af6142c394ed837474a40f380cf413c22c9229a03215451626d6e22228b86255fedd7abaab3b6ba9d4b05c34d8b478c5df7fb52bed61311e2b7f43f00cc48c693a01953011335852913a25f65717eaef979aa5243c19a61e60d3b69f8530b8c031b85f7ea047ae646908b5d7b81b85dca8c98cdee302a2d0aa908ee653116ce2bc9e9525ef431ab33937ccb2a422db59ef0e11d04519fd2a2133c481192f47e532b84dadb8796d526c565fc605b589e67fe81d8e6860adb23f5a51a823baac9dc170bb51826c7f991253eb1f273d50c2ea80cd22d027f5921ea460179539f59471846b201729d720f53477d58de5dae59a740c25cdd21129dacd89ae7051e701ecb6005a727e226b561ea45ed3792cac0c65c7692468d9c25587152822474045c7945ed52b460ba48e40549c6fd2eb9db4a901e479051de7ed4832bdb7bfa6712c142cc4f60c37327bf45e18651e67a66e69f73d2fd5e5658817b64a045885d86e590f267e1fa95ca6bf8b8298d6f43feefaad32ba7d7297c4181bf695e5a277b095de534983a97adab4323f9780278e0358925f8d284851a97ddc2125ecbd277737fae03f8a7a0e8644c753049602f5586ebf26c6226676de008587d8404d620e70e67a91fca8b79f61cdc03a057b080eef4b43959d8bf79e388e386059ed5f248bd2c576be9fc3b870cf960de7fe6636dd2eb28ca33510df95441c3940dcc355c6455e99e20a46bb340fd17ccfe8dac1e581ee912c6761575e70499dda7d8a5ee2244110440c7532c7036bb9b5075724dcb348f5f2f4ea17d729807b8d466ded6456273098b0040f275b793bfb8a71b00404292ed86219f18f8cf986ec53bb25d35fe133c5b1424327cda97f2fb8cb2127d5c41e8a93abcf020a9d96a142052e25a88bb6cab3bc1c89bd7559ffe9213f25a318324d74833cd585abfdfabc476c6804787da6ca8df0937e79282518b0fd04b08302489e876e3216561d941f99f6f57d6e34fb8e9722e232627229bb000eaac97799b4a6116ce1ee796098a3e739abebc104179eaceebee336573ab6c2988e979fdf06ae3577e11d3cbcbef6c61f00595c712343901fc13570a9801b470b95c17078b83f9ce821b137f319fee73c80b9ad36564b92b2d85d87e99fa36a06ce72305fcafb592dfaeb749c74f0d1636b2ac44df52e0e3cff69e790c9153e39e56d7ba6fdc5f1b19f985440f0ce8ea28b5ba9549aa49a89f4cd3e752564dfbd9e190d3d3ef817cf913da2ad599952e351805283bd70e2b8d347bfd86ac7c2c4eabaef7733b0d0d35378741f2c9052211e0b674aa0d30ff6015bef4109c2719af04108f5c22aaf0c6adf5e84a583338594f69f5775f131a203eabd6b7a7a7e828d17aaefb39e898ed1a5eb85cf4e2aea3ea256f78fba83df2334c3471f8843da8e5bde9af97dd7e1e7e17f236557d07b60a9d4b9cc8d9777d18d5711f97784db53fa9b3a86bea7a3f34081d58a0f35fc4b57b577dc9610774f9fd78de2c96cb4fb142890c272c8fb5bb61a8207594ff07c914715c09b09836055130a4910b7229b9581a325341ef434fc09bd69ca6b03891e96f4d2176f4dd0a759829488598b6b780328a3226bc4d6f60c15388a5e23ab3cd92afd3d85d328d49a9ea01a68bde9049d9f94bec012c0c81dae338c7a65868a30a23d2771f5360648e77dccd142e9c0f09c3961e037689d61d4827ed3213d24038f5d86d542a89575e92943353ac357705a333faa26f7097c988e108a8c44ed444169fe2c87d674f9c8076764f3f42cb81642616a93ad6ea256062de3c79cc612b003bf49d93cb8ed9527495beee251a1dafd44d34362da0bba37ec2020e22e95a7f3079196cd1afcfb5b69998ea64c7b445e2d28bcfb380997e1b037ae37b09b21639f11b8b63795a81d95b192c9148060167c251163a582d278e18bba4f746154444a150ba8933f11abaf8461bd8479cdc461f9484e2a64702dc2875cfac1321b90ed778691316ffdef642a3d141938b91a5330b467a1bc963c635ee38eaa17e933360a13f9dd5bbb79ff8ff25d992c2f13491705a88b4680120d1b563b24304fac89db7587e8b2bcb3511b8e9fbe1c7932b7e7156eabb788878a83dc39538a0a0cb29ef1c54e26e111d3f231e1d6e1b7519b56129f2e78ee7a34c7c257436c00904e9c90d40f75d6ea1fe5b7db4444bbd491595688e044ee6538db40ce4382eb3b15dd00f97e99efdab66eb7a9c7ed7dee651c36b453133be91f99e99fe9274e30e50efa4768bf628f237d28c94a89e2c31b7bc286686328b644c6d3f7b5608068239127eab8d87e7fd61ff5442c042ebe7707630717b8544556aebd29a04803d44c6b97c1c206119f3fca863960eda453d3247ce2475f880d4cef8139fbfb5914eb44bf97ba620162d1a3129d0888fa943d0cad5f294a46abac66698a48ccd13c6d22d84bd9916193a2a506d55a45439e4429647f5b221387b4fedfce293fddbc5bf47d1ce677563e8721cc5aed33a92575aea98518b14b20bcc0cf47cce81942bd3ecb90129894ea698a3d9b5eb0f6a0cccfbbbf129a1e0c2a0aa921264b5a3a3da7c92f27236e5fab0cc1adc3e424b767ef470b0a1a4b794be3c4f91b5b8c3cfc3251b780b19320ea8b973c40d02a5d3136923909ed298b625ac0998602738ff69804d0b52deb7dd93f9506decea63109be5b4d83daae07102f425ba711ca235c9aa8007035589ced0fadbcfd73a2b1bbdcfea896414be5efbb97d69eae891a55d79e0a4072a52881f51e170277e452868acbbf2a1a039524ede632107ba9b8c8799ea3f0fe184a90e121d74ae3a07c6e72c2977c385a2991a7dcf76d32e7fa1414fbdd85da12525d7ad2c334880132a8cc19976310b4fb634c5578ddcc90b24bb07816ec5794f2271c8ee11959df8582f064c6724ed61e885b3a30db6cc2d81eae132a1c9668f19dea31edd41bd084a051cfb30f37c51efb10057d8670ed7f82c5d5b41d8184c60734e15fca8173bf14430ca8d497c4b94f677422cb7e8f198d02dd881e23a5574ea33b10fee1a96d2e99d13ce0f8a75a1ba6fcd93051db3d9792ae97d751403e59eb8822d0506320bb093d39481aaa0a12535f0304904286887d85960b7b626e05efa1c93d2bfbb4887a20b014f0f7b29f61ed6fbb45762e074410a48dd6552b14157adeccba3e14eb625f4da51ffa3dfe127b828229aed453dfffd711fc3d93349852b1815c106d8346289ea53997e02823f9b1827e3b2955e5dbe3b8a0e2ea3040a33a3efef3c0dd1aeaa45886800d4594a8bf80985117488b2f1750a6b8e522d5f2d2298d2e5d3f4218f32b8e008dfc8c6f72fa3c87b81174c601592ed6deda6f0fca05f7ede4a0a03cfc46d4487f3ac5aebd40baf55c7dcd13a5e15e9fd447e81d2f1203eed3200ca81678a66ec0fac06c28e7cf58f043ceef134a64cc5dc9983dbabd71bfdcdbc72192a242c36ce7319e5f2e942ce825d3d03d1eb4194d005cc2beedf94d2a7f35e4354f345b6309095cf0001d3bcc70cf88b16e385e9122484a37b64bff0a3aa6710985d983dd44e1e8799136c327b573b89f6aa98d5b5915af6c9d50639c0eaf05d66392378e3d915eed16aff633ea13ea95c4dc6044c1d0a191b07dba217a9eebeb16c7fad0d1a996322b6462fba0c5cd2884518ba427b21cd113c35d7da96bb57b5288616c919ee45220b9c8061f1f7f2d25fe8637bb84e0c03821788e715429823ccaed1ffd582fad66168645594f8cb2b0634169db2ea548ea8796ad91d0e58899a40499c81e867b22b93b564ad98a6071119a4448b6dc002d344fee9ca2d82329244c7aeead27edd5010bbdb68af839fab5837a43ab7756fe41086cfe78b8e3b59c0ddffe2e2d28befdc91b74cbd65761067d9d62ecc8500e5ef7e6ad47c8a92d2576f241bcb6acd81770b70a57b32e07dd643e3d6eeaedfb1c2716a98087c62dbf33cf2293d015ee2fbba6125c593197b6a3ef465e363ebf24eab9335c88636e39d0c2315e7bef1c9d90ce3e0c365b1161ef92dbf6d59e7b66d3d4636d1e1033d004f5775617197e24bd330b845d8725d2a05706620e40f6bc7430d6ea1f106b3c58326fdbed816fecf678aca40615d828fd8459272024c0108665621b4190ff33ea2150b06ca8eaf07557bb9a6f11dbe9078b7c3c8466f2d63642b0423b7c557567300faa7a2c4a1cd10d2d067aa480db44b9e5d0be16ad3634dadcd5492122a19aea1277302800d401ec72967d3d733d8c7278df0ffc6f018b76fdb7974631e1424f6a7dfd619c8e0faaaf24aed3f9716cb6011a21cadffe0e1bce289030f45b2929edabe68d4583c6c37d762e8334c041c3144b91b06228456dfa10036a1f6172e29273d8a1a4001a2016468235bb71bc9ca60b8b7f55d5d2e2abc76f821684d06a10c54029986cc8ecba6c4d7052d83df6fd53e340e96e452d0f7e84e80840e8a58553a1168c64fba1cd0b32f3b6b6839149dd13054cd48aa241a1b42d6ed3bd0b5a8017bd2a8cfd0a725e64337e5ad6afb1273b6985abe8121a0a5d92a925279a08a13675df84a78ddef24ba89a83efbd40ec03536abfe0e6478e9efea42f0ec18dd46c21fe67f2923d5be71ee651f683be9eb6f7af44448aad3f1cc3c23b05ec0fae26d58f306f69c87b3c7ae01168a969b338ea754e562e8a5968e18c9149a57ad0fd479c68ef79609e8ce804035d37ba4af254fdc049249cb029ca90bd7ef2c623192ce36c5f00695703b20a9a04f3546affd90b32406d6ba795b87307617df6ba7f453a34cd899c0e8df65be76ab0cceaa9dfb857df2484d5ac5f63974b9627e98d2c5b0e6e2600c344677a319a6030adbda085bc7b7892031fe70a3fa6681a6919f64f2cdb6f86384e1f7d5f82db320e411fee4a9f3210d828a0157887c32e01f22bfce9e0ba21ee7a01c362bf06bad28cacd05272b831ce2b35a20698a3cc2260f57f483ccdb236bb9e130aaaaf392b170819fa92a20c39bff4735cb9457610989a4e263e32e565ab064e383ac8444ec47d383eac9028c6c87522e7272c4b758e95b057035cebff740815d5583cbcccadbd2f4208e70f2421bc46f766689fa7ad90c1d1bbad47f15e09c63c184ce8a364175954ccaf7bcb4e12d1da4fed5df0858741fb16f8c106277ba1f97cae2770c6a2867f881efefc6b6a92c066d727f300edcd509186ddfadf252ef2d195fedc39ebf2c3d1cef4790abee6b22fd45e56cd0820767b4340d1c9d1f748ab08f217d0677b0b8e89789d0a0731307ff9e722241878c37f1b0027e30207b5fc9d93a658428d4b2df2d35f84dbda7cea023c87fbbbbd70499a8d17e6cfbc6f0e7b990fa2f4eae86bb20e499233189a9ff207e39842a376b27b2520811efbb6e5954cbe772e5775cf88d056fb3b00198c7d3e5f4d1306928c5d2f770211b84bb6ecf7eb3d349053c73292ca97398b3b54875e33640c5539bff3c1dc400e3eba8aafc65bd31c5703f84fa276ce9fea94554ba0a5c604e6fea990eacf86702992049f11dd2d385ac31308ada852821ba4569475c45f99e60372afef465eed52209cda0ce029f6c12c6f2ed0c274e145488e9b483dd0b2575e2b5f96fdc1fbf839011efa05898e5c2a57839593e08f0c4a9190bb9a793d84523bf422ae8b21a74d87d1630917f56f4d32a84c1ed7fe5a278f3f51f79950506540cfabce5abfbe42c35e14c51162ad0bdb19c19216abcf3190efef0846fa165dcdf45fe1ca59c0484b1c5022cd228cd2e9ab079f9bfed3b178353d3e1191c20f42683f9cc21f2b9e35b6bf8a2a8f75095b2289f90a5df0e0b2a7820fb1fd612f6c66a98b61c2166462e802c8ed91a0d90c43809025c039ba197f0637e808c67a12cb974509a0ba0b3ea74def59b8ea488b8080fc878736072ef4e005f596dcf2a2815f0df02e7cc160994336a603da57e2b6a02d23ae03cd77501ba6bd1c6ea9ebf1a32f426575007362b35b4672f9116bc6073ce339e93fb258d7df0aa1d349e63ed6eec6cec58203eb32623157f7184f3f41c637f71e7f7ecd6016f0627a60d081334b9e85e2a7a0d97727b1050b39085a9700941ba2ae29bd239fecac1f76978efe2849a8ec296b3472b57705ea324d4acca42d42c09e76520b2e6035a3bd4892cfd6f4701cdaebf293da0977bfa5e161d225d8b031be3adf228357595a99d8d2ccd2b3e3dca189c9ac76f46acc36c9c2d3079dd41f6a94b4705abddc4db7d2ff3772ed5432516239db5ffb46e04a43968f5c401e785369c5f190285f5fdf1df40afca4d94165a05cb794e10db665481d164295fe54cfc7a1a2894ce878f5ec9ecfeb2ee6c62075bb202feb269ab0c602cb39127099295eae40a430bdb76296e13aa5b2bc49ffd73dc1b5894d424580b2e3e9f6bed16e50066004e86501a2f736b748afc1c1e9464c6f62afade48abb99c9531fc1f8db06e90070688a90d743967467d267e810b8f2662b7e1bef8200c43aea6a8e151be08e6c72606843253b7160b67c71788ffcdfbbf3dd288573e019ddc20a19a0ce998d29d6c7061451b5f3fdddbf7626fdef5995c29b7b38fe5148127aac8d4de4ab3c3c59e7d53cd0cd570666e4af5d05bb8f272ffaf4c569c747e7478afc762d872f4e987449a814cf9b39bdabcb90c6a0fdd5a428562972060e3070f68c286be65bf7c39648fa0061509d6699aaa83cec8bd13e8f424089b71d55ccf621079e713868ed3765978cde97a72a596b0f7466f23aacd525872d7d347902a7a3b409c8dc81660e272806ae474efb6360a8cabfe7371e430328535d42ee636fc1ebce71e1302ba57157c359d0e6e87fae759757fcbb2ce22e8d934340867450bd3db036a3b5b1f0afee9186307aecede024c3c509bdc73823a96b6c63a797440a807150d51a8822bcaed56405dfe27d1d983cff0a73c9f0a4e9b5c0dfd29be0d9e622fe1faf39f2d7198412c7bd37e6e468a293b333d9d00a0e73bd6b8caf5cfa079e2b86d944138020322f7a30570c45726d686b7d8fd04e260157b481c902ef70176e2f15927bfb86e06dad043cdd78bbc98e20cdaee906328c1bbda97c0be75b0478ad1f28dfcd595920671e0ae4d4ffdd2d3453602b5162bfce22401d50a7e20858575a4f94de8491cc6c4c85e1cff175f190cf3092124f8a4bce7d40e0ac88ea91b9df48aa73609f599070984d7ec45c04a1e4640c6b043e53cd4a8cb0c929ccf3dc428335a454ae9ce58515ad82b0ec088189737df7c6247ccf57f54f4d59fdf3a612e2ab9589881ceb873d029f5bea327a6e66c310ed346005249934f95fc690a64914aa39def6c54306077f39bcad3dda04b0950166cd40ca6a0a0deaa67e971562d80b09cfb46ef0637be992c9e7ab9431802ef5c959d35d21b4870abc439620ac5ab22f51e7f17a8f2c61abd19393613b0bcfef90829964a922390054857c0937c871a1432b761826f131f5b880df192bdfca6db7fad25a068bfc7ac7d48b36ee27ff09e53fe979c8787d38de63d68e63dc2083e528bbf80aca26669e1faaeb60d3a6764ce8d03f16d33b66d7f6a2222a41e37741e2653f0a9bdf61c6e1a6444bb97bdc1f27e884b7db8595e67c460834f1c4dbbbba4136a9c79e838229dda2601baf5ef8a68d03168c2e575d0b8c304109e32a8e3e2270f25a7f4fe3885276a0599bd2a73b3dc36583b852f514db98e987500c60d75e1d49347edcc1ab6dc2b0020f144cdaabde9dc2778bd82350e184966db6795ceea057a14d11e1f38b4445103204922b1064740ba8593cac65be9ac02812f99b68b87fd47033d647654c5d251522e8edbd7eb4f42061c8ab7bffff318e6e8a53e08058c1d532ea361f32b9ba60089cd3fe8f8e5657707d8449d83645bb80197c0a9828335d808783671f61682ea58e4b7498f60490a1e156063b02c057d6422b711c5133f192a8fd05ef14078a89072379facbe894c60c5292bc77dc28ffde921c6732f8ca0443f4277b918f6045d7e121851b16d0db5f0a1b424ddc38108f2fa4b565091cb071cc1cd5b4fd7895e36e291a08d23444fafb8ff3c0aa4efa35868949bc191b4f6b1966c3052ecf72188e8a6d49c6e8d517a5fd47a8dca5c01770ba77b867c8d0c4ea2e3c59f08d34c92afd8204b55dd619596c0c18da9b9a5d115404ea41c21ac4be6ef5b4377c0614276d0298144d7f3958dc6a579265b2aa528485fe995172b009662891fd5cfbbe8dde6e3ab65b3bffb7de32d381106eca3381d9cf74c9c2c59b5fd0ae4fe813e134cd9a81a587c3b5c8fa4c8bd36231d8829daae2f6976498d5f02ad7d56eb6ee2b71c6ca0cae35af817dbe3aba64497c5cba3c7f32125c029d0d3b8f6e5e0b16b7fb20f773b8c67136502ae9194f92ccf79e6bd70007b76faddf1e3f87d04f76b4e67bc02808e7bdc46dc99949b1b041983d2280e00bd7e89bef83e7b03aa9b556c0ba1a1691e37a0ddbf03bdbf4084a7b513f191a1f94ae9742ba59c91f6cc5b8b8170ac9f12f2053d8db3f8705d819524037169fd1e8c8d9f84785e099f127a72252bfd211f92ba1d560b4dba51cd401efcc0662523929e49b694f78d141de0a41849618cece602bee320b9d13e0155ec6dc03d653a507bb99a3852d84cc815c910fe5647102776f03095ffd870ad00546312ca5c9a1ea0e406af35a6692506940e72f472d0c578eeb3b0c578c590887ea190c442f6cc677a41a90ab9e744637ddda9370ded5305cf393c74e7c9611f4e64cf2d01aa5aaed04a607a4fd6f3c97a2b39ff5daf7d9e261485bd1e51b6de18f225bb6afec4c7205e85a46eeb2e99bf6ae01d106638dc2439c0384b3d22e94440508fde244855d5560c75e39ca7cf937962086dc48712d2ab036a2f77dcd8ad34b7615c8f76f33fbd369b7ecc71673745a2c8e532c5344c9ffc2d4f7ee25769f5d598e29822fa2f0d1522eee0bf321ce2fd570f4e05102a48d5c6cc271f679efd5f3b296d34a9032bf5f92c460e6660640341ed5328626ce115ff614747c968826226f9c3c8a5c5cbb9244d60cbf44f95f6f0f564ae677e031e396078191604bd9e1a7910aa68ad5e7a61433ba4a070c2ac282a95099230669a299b634edcbaeae5b0751299e0a6e6b208d09087a80aa0d5ac5fb3611ea8a0870f9ed7dbaae1205428efa416c62a0169c92df1a39562a4ef70a03d50515f17d05bc1c8a77bbe70ed71476b39806e268b18bf6190feff448c5cb1ca9a3fcad6f9ca0fdb65f51b96f15e2f24c19be18134d70f1ec837faa4da9d6161972749c9af0dae9adea3826f2bbb4069cad086c11dcdbc976f2cc0dca237528982a21960f310f961e3d13b595c0680dcf1777340cb0ee7d4ecd6b63b4d2b3f2aff3f5bc806ac58ef8d6fc2822d87e9f3e1a104cfa3b2aa416ec360ee4056fb5b75448428bdb6533f33fbb594a0eb248aaf532ccd79385f2ba299ce2c9b3083e0611cd55f99ba2c6f18862446725680d09cf0bfb31b68101de908b50f3b818c9dc420cbb6eded605bd470fa100da0adb66eb224671fb5ce3dddfe76dcedbf1b474b8a6a132e6064e44172c9c18f93224374ca7acd5f0b73b4c0404f53231a66912161800c44e5e75274f5717c28d730899830cd8ad8a00c8cc4ce9d2d59840ba10389fe2a40a4174985d4471c615305e9c89456950f1391f6c4ca8e2461e75782edf67fab7f9db056ba49c1ab9f79aafdd7b608fcb89d22d1a62c3c47765e9692c27fad45955dacb081b78d28a2de9784fa9471e4d3857611d10ce28ff106305af61e451ebefda8f6e58a7872924451dffc40557930edf0486d418eb7cf23807822f8e2b48b0c013cd821358d847f0160401251db71817c374a17d94943f33e5aecd3ea799589026bf38fcded8c8078db366eccd1ee61c84ef7e31a2fad28c069bb2d3eb2afbac3c9977debf1bec646fc9698b6c8e01bb907fbc8552db3428d042a018659082a1dd80a5eceb5b07d7f5ce0dc1f8da0b608093fb388330b81ce33c45ac6073e8956520f14a38896ef72d69a2008476efd7996de22b673a8a35c93b900401adc4fb26c2adf8eb9e2bd236bd8251abbb4a61c8fc92dbd6725f194508ed3036be2b626e7981c72bbb3108c529dc9d0fbeed2a51511bf9522456e92a1e0eb21a2d4723a4c09743240c69dcaaf520f4f2bc44cf85710ad7b6356e74d6076be64e83c5712059bed2b7d8e6f98933e1278c1dec1733c9d1c46bbd7f13277f35c59c61e8188b38748fb56fec05f158c3a5e2c16e072c0befd14fd02baab42f8576ef7dd51e26b5130ed4364e5d9cf29e8bb8f3766a8ce50461aa6e31c21bc1c31d921483094cc85c9e5af10926a9a8efa4a5d9c373326636560daec5795cf823f906151c6d32e606007a36ea29bbdafd89874f7c285295b4fcd0989fa0b3d88404e1392d347a5ea856db6d3ab5a9d16806bdf6cf2f0ede93822b47514c4ce571d90b8f710f7cb8817919754b24024630544d7e7a1a8d68d2e22c239a38f106c86006e69d50d05ac975b9b2ab5c4e983f8db150e3ae7f81095467583450e2ab3c74249f939bda3b63432f6d5e3372cda8140ea491bd3046e780bdfa03c830aa69f3e6e19445da46f047b9f6e00fe43179ae94174b8322dd867f04636c8968f7f8e0558dcd05254256936c1b53c156b72fd2f8c1d8e5854942fd7769a63fa29b79158a0ebe776a1a2bd0fceae9e26345be2b240b0a62defd416cb602d01098717824edfba07becdd408b19b049a0b549a131b4fd2f3645be7b7c3fcddf4b475feccff2efd1b817146cdee816bf0353e428a9227a6c6e5a9fa6d66b9e8bd2f0be43c8c0a24fdcec9dcd617a041f9504a83488f1e9139c48ac41d4adab029af14514c8c32c9e3394f8025c233a04636aea44cdc6dbe492854a1e6a27444a320271e75d226c5868b087dcba2c2fcd0569e2338b78e5eadf86752a8f6f2fe081de2f559b76090148fd309ad261b2fd095a1923da28ec05ec425481a91bee2f67098a65d2d67336d0792c3fc80a4a209a56109e80c3ce521aedbbb6ad29370b074aa5aff6bb93147c3bc2bd146426f88b3c684ac7ea52cfd43fa8d10c6cc9e31bcd94610005e1009ddc65b77c5bddb02949f2cad4b03d134e679e2a8faa992c795052007b66074f37147b1e2ecf2ed417fda2fbe25b5aaf0ff566ba4767bdad400620d9565b400025b5d5cec0d95774f8b3ee8501e7f198b380aef499b9b0e4f6d9368758d8caed929f89bb39820c6abbafe21ce4a8365f1972a51ad4571a467dbe26b206fd0dd16e582fdeb40329ccfc11300e9945a26575b7187a6410e73ac88e53b18237b5c83e9145949f9c54bbe40fc00d6dbd5bcbfcbd25b779ba8dfeff0d6970e5a897c7aa15011247ca8783c27c36a2e99f79bca01c3dfe1b2ecc25ce81035cf46c508b8ff67452d99a755d360b460d427f322480749602bad2195446d17eaa681c7443bad1ec49c69d9fe4e9c3c90d2c252eece93c229731197b571aaab636ce2c1c27528836a3729efa7add682cea8fcc37493c5319000831eba241f036a15593190516f47be40621eca79bff1b6e7fb3df8d96ca3054547ccec9d2ab42aa5171610b74a1bb7b91f25942ee47a6ad0229a11129579ff488e380ff4dab71b1c988d22ecd9d817f3018a20c6b27f7a94a3f6199ebe63305458cebf58ce96068e59731224f20cdbab7ed0c889a4ed134cdcaaf2a0b9fcaa25b548f482134aff5ac11adcc8fbd30e492c7599ff84060961fc6d7b596a756b0da4cd8602f949abe8ed945025de371352e364e0bb1d3082a87ab063a26b50f9be36f20939a0a22ccdf8c3063e3c6d71e4047318759394359ca5a32d6a9c6be7b7d38d30533e706142e83031e8f5cd09b87b9e8cc7ce690b289d608203546e5a8e05aaeb1d67430afd55ddf4be76934df7d65a2ce398b90cd6bbdd5512011923245d468146f63c6924ac9429b01ddbdf66689ad8f8dc42bb2a7eaa2d82a3df4704fd8fbf57cf4f150bccf43d49e584b6959d5a0d9e5f2054396758e6be0601dc7c87e9c13a605ecc93d2a7a1be49925002d5afeebbd82a66c511cc89ea1686542cc171c6005fd784f3bda8e80e7e60ed4fcdce01d6addae45c4a7711076a3ffa1ba52e84052d1c36450d48f80a37567468ed78ebcbddd6857a2a8180590708c91ac90b574fa7e872d64893896698f955190616b9caff4fcd8919cec2fac01b6baa856814d4d1bfe89d3cc181335f9e5635ed5621081b648f27e4af1dadbd44c0a3a85cae20d5ba90d822c24132629088f3146542400292111baedb26101094cfc94f5538f1450831470109610077a2127fe47f8df598fc809e28583fb9c9edfba9442bcf5a0e252b37e652477f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
