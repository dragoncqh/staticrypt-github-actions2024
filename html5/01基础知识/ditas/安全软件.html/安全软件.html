<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c32dca748a6cd32477390aaddedb76d3086bfeb215585dae8d72cce3785631ae4fdf08489996a19a9ef935f40c3214c438dea9c0be1ce957015a53e23d63f20307833c40d18108f47ae2f5dacfb9185befa8e4af772c53b3b5617d166f7f1501150c4f3931d765e6c674b8b4d1427f469e319784720528aa372012a0c91795cd1e6f763ba784a80e8674c7b13711ef90dc393134404257b3323130076a81306eed21112b5ad2f13a43ed4f3dc254992f71cc9f1de27694435de28f8d43f254c17490b58d4d2817d336aa25fee6675e49a4a6af1f0d8c3d177ce79d3a49718c183aa06e3d447a65c14d3fb9b3432a5a006ab882a36532c821f78878424a5d52ac9265c2c9f243abb779773c373db87d22a2c268b9e586e983e0f2204c060d97dc06ef54f89fb0c597204daaf5b11ad6ef7c0b741be26747201e09713fed1f118f69038d2d1a3eb1e2230d8ec0da8438c088db148b1953ba544bd78f57bead6757676df985c418b5a06429e4536df46386a93dee8f153fa3aba85e48e31c48a04ba7fca8ff927437266866fbf5a89c78f09971e2b418095cb4744381cd212a624523dfe161a10aadb5b4fda3a203d9d56bdb2eb280d6b082be942a5e8b189350c66d28de0fb6db9345aeb19d792c2f5fc50cac38a8ea5b3be7c75ee19adbaedce61abec004ba1430ded66a41d257e19a08def8a90b2b06dda7d26c278e750cb23684a287f6a723b7ef18a9f8972e7dd2c10e1dc206f7b3186ab4cfa7439445246b31b9a6307536d198dd813718692b476b92968fd8862fd7095ec3806f541ba3a5b8fe6c183fab9996803fd6d4d1b9da53e78e0c9c2dc1dc663084fffdf437cd0072ba391d14fcb1c20c0be19975461fbcd42fdc43071ba9ccfd5dba86effa5880e99d78100581634b440cc8d36d06314191ba5f4fdbc7902f7b018dbe9b49662f31526b71db41aff6ef01cc3f5f115e3fc8b7d6173d320961da42d8035cc619887d6a03c3f1ef9a9116c31792da5c1228327dfdbd7282ebe58f6a2786f8089640513be38b7bd3be64fb57e4033cc53dd96dbb6656c18ac7c788f1a2bfebc26e6f24f2e56d0988911000aaf62e0e7bb2e5f1dade09676c8316312dfc1741589f79421cc967769b20ce8655b3e9ca9805d5881f79ff76dc7f9b5e9a2ed5a319eebfea98a49b30cf4935bfb44b947ea2b8a698fbf5f7560bd5d3eea53c1f0c8eed9e273ac079e77f130a8aea26207df22cc65e85f5eb9683cf319c170e074d03830d71621f883ad2a57a57a7bafb493396b631570761819d712127cfbc24c84fda32fb963f2b6819dff10906637c44ab5fcdb78a4f1cf25288e22f3d78ae2aed9479f49dfef9dfdc87e4e93675005534c5bad766b307b188e2cc4e587ca7df95868c94747aa59a68783bc6d22110777f5a5525d04a1d3c8763fb481232bea38c0c03a7a081c5bb49d89384571309c136635f1141376b9a48a99080075b3b057ddf20f2a71c6b10fbf476cd2d1b8a654535e5b3633297ce0f1b01b4e75c945ba159ac3890db42b63fb7576d8cc4468daa5c8c0af46ccdee007b579f714b92b019b25faa46bb109c2beda91ce1e094e5198e6a51aada98025d0fa923404087d4d244c99443193b40f9807287c15dbc6ba2644b83edfb7b29e4ae21f9f63a42ab6f5499e727f68388d7fce42de1c8a9e1f70584bc8f87b86891f91f21b2efd6e62dabef3c7c7b2468a6cee79894f0d9eaa7ae5e8c29a8a715e0b7eb15ed1c3f0552b5438102326f331ed81ab0b142577c9984600e4d7507ddd6ecfdae33fba0a1ba4d714647e1582214ee066bf6df83aa516eaf83a795219b66fd5ae2adfa3b89a18cccca0d40225c399b2779afc32a77ad9a8b1425377049b73d96d3fb395d6661004486404397fbccd73e4c02e3790e1d9dcc61721cc625b725f6226529c89e76177ab0972dec1bcad206f924d77e40e2c999a8ab59e44853bd3bc200da18a424fb5ebdb05fa0da70bd5cf5165c3f22f673978e29c266feebc962709ed664a0f93b291397ceae24febb6dbeff55bf1cf305639afd2eb01b0fd95b0807dea68d8ea5ce6eda681903edb0de0c3653005f1198ac99e06202f0a0e5bf2926c91d164630cf6c6eaa8b45fd2cbd16e90b2c0c162a0e3813b87651240ca0c8d8712c1f863adaf7f56bd130ff40ab453b6da8abaf9722f5fe6757bcd146621f746bc6f86a0d2d832c0dc0d9b3715efdeab926b31a78da0a40e632256efc6db64c4e956a413ac4f866e6e78e7aa5b7df1faa02f5e98c47ea53f5850181adf7641fe82d5155fdd1cc83243c85726e38250fd189360a518f655f98fe869e24eb1b01afc5f3d1a7ef29a4dc36c214649e1f43602d6cecc07862683027e37c52c0b01c158e2af45eabf1f50b2f5a20b282323a090b774562154b95842b545e41780c276ca43d9deb4e5c4356fa4919ef2ea52af26d0c0f358769170f20c2ea6806faeef3f1eab38c086f51f28a49d359f63214f52fd216f74269b6b403cbb305ca8d4dd62c51ad9581c4473fe24b500105dfc0216297186d56ea411535d963076c1adee8ae6ddef4fba8bbfe9b7d862738c381800024b2e53d0706f744171167ae4c1ffe61ea1da2fe897ceb9041aaa1d52f1b56003e52bf073a0795ab4ea19194f9c570933134531efeef8667876a16ce515a77bd5c96a75e8c638a80e77e5e4f38d5f7b54e2fa6c9f417d1637c63a45680df06c2cc03da4b7a1c0843b97494a4208d14958d5f7b41a9ff4a6e607d34937614439f072316e886e2fef04ccca6ead9e271d4da1feebd241e2c522f930c3f8817f91298330d319fcb386fe4c5e9db4891a7fadde94f67f1a01ebec275fc646ffb9fb6831b8eafa7bb80c1ed0cb2220ac03c4f700df2ea8d292d6676dbb91395bf7105d1e4a1a2bde19c20bf3c68acc56ed50c4a4fbcea94bee159fa01456deefb603c07b47953280a5bdbc723fc824568c335fb86d2cbc400a27a93b612292829c604c6d0356eccddf92c45c98b8e711af8cd06cd0984ed4032960a5b4f99eaf4e57b75f6af6f9c1bbbf226bc46152952c3fe7c1cf903fb7a1857e8006295fa43f89216dd5549ec4299552f02232d89c8c4f74a94f1382e2de40c27d333668dbf7945d5a53135fad30d2615f584d6a590ecfa93805032332c40c52a9b4b66de3f68b10d09479105b5c6f840e6de8b56b725a67e6f48684e69c1ee6e60df5ab1d357f6428dda0c495e1e10ae90399fc0c5c8c378fa2eb19ab3c04ee8487fc19b5f7012843cac1c2e115f379aa5ba120ff743a521e49bdda8410111e6a79236bbab612340d0becf2239cb2b9161e9dd101fd02ab4091c3ca347e399ee370267e475c832bedc95822d1f0ebd33988b72b76d4293b1763da7634635dcdcf09d1335749577da6f4be839c1481406415591b171dd2d4fa787e634f049c1cf5acc0c41e35aee6df78e7a1b3a37cd070ff8df4ee3de2c349f8e49d9113d21c2d136513a09bc7acec1c5e45d346babdf7b62464e4cd2c677fbe7d08dd57ae6fd95df1a7c521c91df32f7eb48187e074ad7eb423fe5ea794c9b53dd5f3870251883095c133550bb9aa136be2fad4f4b6af66229b056a23d2b4f84482f9e44f275bb7c40432534c58e4ec8ed40359a58012be21f9d613c30575e8bc24019a5cba157f4ec6bc121603bf39e1c3145f04fd564b680431fc408efba1ed0d2bbacb80f998168d5839632f1e6aaffe0f7345a5f3d7e684a8149ebe1387cceb12cc2cf1a948695c33ad188764c36a9ac2522ea3914c8c060307ce6ef0fe7568d24ed800bfbce644f8a71166ab2d71f31230428cb90c7cb094973e76b6ff70345d4ed827eff299dde753c8262695b5e76142fa3583ea618534816fb89435ab3e270fea4d74fb9605f08b0743528e89b00783d1cf8bfec7d5afbb8bbaf8ca46793a9182dbb04e5fec454fed09250ae58c8df1caeea3f4018f8e88532901f7b0d53c17bb57ec155eb014ea278355a0f9d382bcb09ccbf854dde2be52b2c0dc92e8375879d0acbb333f224756a125eefa06bc2f36f9212902d82902cdc09342ecc7ebcf98ab232f357f4d5be9489db8de80de1646d173aeae3af48820e74f8ba0e123eae114a05107910a2b24cf879d4dded983382736687777fee498f0d1d276aaa09e1f3a5502a23ba2e87575f827ee4869bc61747ec8c1804d1b184db40606221ac9b57acb12acb064e909e41fa7843851918cd79722fcd61c01d3e665efe862d41d35af2c8e964b0dcdb5e22157533addd1894826fd2a38ce4abd10f4f128e74460db606b5d7917778f0ce716fde1f8f90fa37d1a321a450791cf18f2ff6fea3673c1078a00d6c6fa0208c5eb101ad21fa00e19090984e6454957010cd5419782c9f121c9ad8e4ef2394a9f88782b107f5c054f8cb59e78667a801b3e712f13afe5973ab3a36e6add16903f0f401e4641dbe10d41de704482d7b068ea85e6f481c6715856cb36f5fa1ca51674e2b9fd6cb899ffb8004284718fe14630723702e691c0e82928fc774aabf82b9e1029f8fa3301b377432dd0ea41c117ab0a6b526b71237f9f54e638f659e45fe611351a38b47eff6da2f1c271cda9451ba61f52607a915e552b14996ccb38171a52e3d51530a50b3452997626e74a95019db7294cbe7dccdb05e78f295e7a63dda403c0f6ac6cb46c7cff09d295f8f36c648817ca3a9919826325c914a81acab9339cb760b00227470d9d18844e470c35ce576d7255b6a4c71edef0164a687b920ef07c5cfc5e1854a9176575d2732ded0c4f6b50cf2a3b7d71219907fad40e31e99a5b7d87184945d3664dffe9a093ad0e2d0aee8333bddf833c1ea57feddab8c779b4d7836d8318833652fa0154dcd25417cf66c6198fd6f854956255a38af9e2cc09fbdf690719af3ae97bea58d4125c06e38ab0ab91c18f5eee042bd86728776297554c5d30e9b400aa650001e9ec5d2abc17b26176ce2b888dbed6258240c090cce8d4d47b695a3ac71ec23e1e01bb994ca7e291e1332fe65e6beb6574ec4f61722ac963f633530b087869db8fe6201578a9311388de6df7d0d27bc3cb011aec77373fe78553fdc38b392c92d8d002cdbdb3b0db20c2df59496c39c66ef2c728e977bd30e247e645950b8a28ca33e2ba0a9c2d2113a7f235817424267dfc211fb6e1f05cf1cc9639593c6a90bb4e06c18f4f1c5bff8da7f14a2062321048e3acde27c6adb9c9104670a0722a546a5e79e1d794f6d56edcf027407be61992639b78f23aaa8d1f250dc8845a494f0034c5150edd90e427cbc970dc0fa4082705447af05fcfb419e427eca8b5d683cd1f3a25c221870c95d0ab7dc231cc0919de5541c5139573cf2243928afcfd7aa39882b9d3a3aeb9a90afb034687934f8e300eb94a3d13435575c1e1fb86620656abe9607aa88e26e4ae9f30596b40b24d48271338902e05ddb1ad2d47d84966efbf9aeedeee787faff06159e577e7471e7aab571e6f8a92c016822b60bd1d45a22efb27d8176e8be8687651184383b6c1e1f6756b7dc422804ca60ead88c8e7e7f7f19839627887009cc65e5809afe7429d6e07875dd4cbb08efbe8ab45ed2dc1e97c425e165a389a0b3596a42b85280eaf8cb7203068e31e55d2690d841091d0314e5363b9a32e7424d6db3a420e120f7e4eac283250c1b590e862b5f90efc366b099307a4e11594b32bc464623c7e62b8afdb39b2adc833789f9841c3315cc9572b7a241957c766d676e93ce4f46ad257b4daecaad76e0191a4517ba560d1dae9f7b65092eb99bbda35945237b3c447358d095dc8868ca962a131e82a90e4a5f7fcba1ce2f9d9ea5eb97b766a6d906af485cebbc5b6149c79a9b1d062313298205e89a0857724cd0deae407eae0a0fe3c0724a592a4384e44431f01d1510fbfc84031aa136213f9d6a3225321c2b48052595602a5dd6a1760a309d703ab94e276c0c2288fe35c8daad93ae89c727a5aa69a2afaf12fafe605661f90cc3fd40588d9e8ad4310520f7d34822d43fa494c58205e22c3f8fcdd8710e9716c9e400b3acd4d9bc88658d16e2bcce5182f5a39d60d0d1a0276f4a8b3f91ea468d46426ad980ee3f7c920f9fac2747b0d3cf169ab200a37383229c4d7b0e5fd047e279d1cf6ddabc2d27262308df0b72588a6658067e552a6be37c48d815e9aa3eca922916f901854a20c35c985cca5c72ff2da0b6738afdbead7c7cb0f5d6d85dbfb21e03d5d4578ff5e8088cdf739f3fc2d77a06f8b9040aaed6fec3431d290fbd0457d712390829e0aa04d57930f963ab4252808efc9c6b3ad5ce7fc5876a29eae2a9591cc544ae8dcad98b63ba22967ae22f42cd19cdcd7c4b516b8ef9ba755564ce25a1d5463581a7429c3f0e1b9195993cb07d77cfbbaff25ccc205c511d16451e0faea96c1ac5468b01be53d1cc6e8946738424b74378e6418b1d4030abe57effda763abaf20d0cfe308e6aebbfd98d8278ea3e7e924843ff8bd7c3274358ffd83a17750a09475e42b24226ea52c833acaf9fafa67a0272e285544887176cff025bd7c9a3b06b60b36cccaddccfe2aede99cb80ec786cae8855e4ea9475fe71bba056c8101b9410d675082cd95e5ad8c50441b9a9bd455375ababda574c3d11afd2fa11c1cbe7464bebe834ce77f245190be0ce05e79f0e7a7e83b91220ec691e7b4a74d256e25f843cee9a24b602fda5e4283408b22b5a965e8edd52ca7ac04f0ac280863fe6aa2029e405f55d90cad9c02e648396e711eeb09e0533779ef24f396f7c1d74bb7c4918d81ea49162a5a3c3bf13dc56b24e315a70829259604cb9568c5c95169bad0651e6f290127f2423e33849e1eb4fdc85117815eea17f7788c42d76ca21e8d402222dac7b5a5200c335fa7db3a05cb28bf15540c293665555c73de9f8f75803b1292cebc7d6b5ef46f939b8328f74cc819eb481517c3d884e0fdee6cc06cd43fc9e6720d309b1e1d02791c7775ea089bf6654bd81c3cea12a39f8ee9ebb695af8827bcfd60275630af8c787400e7ff96597a6c629ebd7626721ce4a71979841fa11a5e9196c6dfaaeedb37739c2cd56c3d9fef9245858547da74ea2c72bc9da585eed7240128151a5b83131b9b1cdfeac494c7abe3b1984c3f8ff034dbf8c8321a4ccd45e77b940e45ac5b9388dbd63b85c490736adcbd6907df95536ed7d4dcf8be09d1cb4c46ff12307d1a43ddcd11725d2c8cdfcffbb1f5092874427668077cfdae468502a508da04e3818bd78fd2888370b8eef508a81037745631c7aec4a63b052d2c9a757c95f04b618bb22e53e8565d02fd3791cb8bf45d422c7768c0ecb088ac2b35ac2dda7d36ee5be1e3d9e1d69a82f85e4c6ea815a60e5ff752ad0c59b851409356f61c26aa505dce9e59f2abb3efe948214dcaf7d273d21008aa172b0dbe5f21674a970cfe16ed0b161278e1252466668ff2348601fc473431be439ffb7f7e1c5e9b2d56bb9a0fafbfa9649e538ce6d54f3e8d43e80712f0626a93456649bc52458788219979bfe0d5f7325862f7db21c91fdf92b0f679569b70d6dc58986bc049dc3fe681a5e0c9f1cc4db0c3aeff307bd4dd9ade4b6df5b40907798e466386f671cb355bdea6c4b6271837c086f69f76be1bed2f7a11bf864a39c231d7318972c17ae8b6cdb31dad748a85c3c5fa1fcc37366e09b1e892e4de01d7379e939fead31cc3e7ae240ca6d6877a3dc1c14d1dadaf5dcef194ee6e5b746113d6c5373c530e811fe6e948f1018d325eb57167ce6dc5a3155f87a3ae4f017f2b991fed0c07b272d6acd8bd6991cedf0eda3de0ca7c8719169cd7d805bd4405f88a2d8469dbc988eb4f179b34c60374cc7fe1f68366020027151989f77a2620463e0bfe789c907f24ffa729f092f8f0f4d67a0ffaa16db4cbf986b60fc249f416a1a4303eda0287bec502f510d7c97d48783a503ab0a583aaa98831f6e7c791562d399d0ed17fe9415b61ae37ae3393d5c1d5d8c693cc7a64dddb1bc8f03d6d224db150853eb046cb4015bc81476dc48a8921b0eb942ac32aa05d1d5355f6026cb6facdafe8a8dca7fe0d98acea5a0c2d72b3752a92e49334b304f079589728f87362dc8f8340dfa49765ed0103963a20650ea05b1b8f3a7567e9042019fca07e5a4e83a7839998b47fe40d2dbe92921db388dd22f3323d037a0e7c0a0c69c700f35aa18f6e0820129f5b8dcdd67798e9d428760947698aca3d8a74305d0e978ac992304d78db8d02c432e57630c7b19945632cceb53a76e6844ac421679cf6ce542be6648e37b580e8f7c79a288f47f04e54a53470463a029ce145a27ec6cd386588be775a822d9d49ae69966fd63fad6824a95c5d51402b9c4e354fc63b4bcb6150b0c04ebb2f8458378e9b3b5ef6e477190e8f9ab5a58aab6ca40714415c793e88296cc7a2951cc4ed45e26a2a576ff046559e78eca1310c7fc6aceda483221398553d1509ca1f1669d0f8dcc5730586302d506988191eeefb0a1cb364fd1c50db0bce9d34eea196c0de458c2152776178ed51c0eed60bc816701b21272e93f9399deeacb544f871cd2906f63bed228fc4c88db54a264f090d0c4c7f58736c3cdd8348d7ee8b52207887eefbb11bb8b4fd46f32a42aed4ac8aa6fa5dd6967b58c0ffd21a2958ead51259f142b4d38c25eb63e294682fc375a0003192f2e942dc1fbeee8ed1d7a53b4c061464d432d7673e307eb3ecb8e5b095b5c4ea45b60fce59337df0db4230b37b24373a1bebee88ce381d1787aa3520a9169aedd7c0bab5dffa7d730cf4e8cc94f75021ed11436b65e9269c59296b3ac7224e43626eedcea18a11462bcefbb72c3cd8deccfaae998b9427af5be04cdfe84f20ea2f524867e577229e5a4defb62d66af5400fe89cb983b651a3ee590a19450e8097d99ad5f8e2cebf0786d552050b6a84383340365edbc75f0c09a1021c1f2cfb744e9b1a7cd4ae5d6db6b92d28904421b63938884dc93ab96df01b47a6354e27a71a973946cb811f29a34ca98a4060d102f402d37e3404f84f9aa1eb8d8a8d5ae22e6d4ce0d134df45949b2ba6d5060514e4bcbc89723fd04b10facf72b37294905324b98aca1b50b69f6f19176bee249c6f42c241fff7d846880eb247c1fd3cae96b4b0541a80630f4c4d113a72f06815a45ce8ecf45ec97e229e7285c91b3ba98a8fdbd3d73262a9b606157ccefc83f3047227185066f10b9fb4cb80d04d88371312483a4db15215d22c8f5d73e0d08c6b06adeac73da3a84b5841b23a99b0bb174df1aa2a828c953b334e2d527a6297fa5190c912e940e7cfffaddb75f296203f038f9cd358d200b967ecd00da54ae9dac7f5bddc415e8643f661efb65285ae410531cef8c15dc7f28877211265edcd82ad9e9f1cbae751209a263faed26fbf1c3be5e6ba6145c5cb2ac13baa96f3c7e8c7f475bac056d1e641c8a304280256cc0c45f2a1e0c0cb48ede58b26af889aa9b0cb66959984c9e521ff2da51d0b5979956b28ffb54ea9476e3abfde52ff0914dd74ac15eef92e703eaa1821435162613733b2f9c587da3293b023cc375398324fbe95122f417af283e3606c2ab82e937db3d0feca8e65a2e18ac699996c7c2c3d6562aa6986f36a126f6a85d56f1ef50b6dbffeaa5a314058365637bb210f282c7fa9890fcdd697a5d9dacb8836d212675eb855771f74ebf42d0c81a8a6174ea9fc0fcdd68dbf88155910454249e9a9c11b4bfab1b6042750f9c427af2ad655e200c8ed9427f4f5d67c08cec73ce5d6070219bc759053991a432807c569a715fd1a0d0c77b91ffcc17b098401eb4078bb29500224723504a61da6ee4b96277a3b71ec9a51304e1c94d3da8a1731e878cd4ac79f33bd6c23a11940286e566d97e7de7cec0128879008454c9fe3f7672aab1a0c14910f737a0130b2960be42c7285a6f3c794ac09dc455d8cfcc22306ed77f90f63e8c4d36c0d17544f2d28d76d0b97c7056ff14f3baa86f2aaa4a8e262de0a905dc1ab0f6e41d4042904b6570b1d34d04a5c1f08dbf3bf648f1c3adb918555b086110c759fd0bd429c7fe052210a830e04d7ad64138d76ea7f2b6d28b0691283db4c9afaf64d75762e36c17732184b567c4244374cbebc59c4a4397026b11070abf50dd0149bd14fcbd5fdf0bccbaf5e8bce0e84a08900ae7555cc3f8cae4ae3336ae2c4c2b2d10e8eea14d81f6327b20b1760e7d194848b861256e99fc77c692adbb5bdce7e3ca0bf0ff4d6dd61cb79c94bb20cf34c1f890de4fd9a2395dd7c59ba3ace0ff9fcf792fc85b86ebc6af3889926e547f5d7c9c957a9a31a919ab21f4a19ac368b0ce60cc686accd9da962ba23749ce0ddea4899253115037426a0d9dec91b04319b89ef21be9a88efc81b745efa6760c03face8937444ca542f194d167111e4a29d8e98602dd6c9a35bfbcf0be5878c8d3ecf22f16d1d916f7a5d04ac1ed2565f04f301477080e8df4e1751b7a0f28dece2ae6ebddfa618af75830cdc9434ce761363570ab52b2d83dceca7d2f680d9cc8110a315072e195443e5d5c09b387bbe9b5e825d50115561a27c47794909ced854752b61c7658258165ef2eddb40d204e2f69c85f4928bb0cc7fd76482d4b1987b78dabf51f10ed7333b08edab5236a98c379953663950657b7565b9936466799e8d8db1a591586db89877ef44178cb5bd029c190079956cd74e50ee02eac4da8b7de73102718d68560e9f32f818479e3aad4ca622aece68bd16a75480cd00d259172cba68e32694612cbf8194230eb53556675b0cce76ce7df0e442475e32e7d5a1e20991cdb057edf04d14f2c99eee0defd87196ac76d8d9da9570148852b2a632c2ef828b8b1b25c20bd9b877f0974ddf424371a5db3b8a914cb2c8c23a8671e92071e5eed269199a98e1bc74a89164f1920592fc85b82c685b5df434234301e3414b0ad4e891a661e5482d1ab48bb937549190cc91c7be6d515b2bb0ee24610f3713af9ce01349aef81d5acc6e3c97d6b76973d21cb834953d378c0d933936f1d97469d7fdeb6382420f6412a282ecd98eca75d22f2238498e8885aca21faf108e869517a6273685533af1f413db306d6bbf537ac0dd3e756595a07ff33ed5d5f53d830cd8c30d7dbd8f2b63e3d0ad9b6f5a6d7af9be6319e18b87ea3a4ea203a02778c41a56bdc2f4f7b71960f92ef37131cdd38d660b88e5aaab6809f501ea4c1636c05563da97a388eda140106cfb28d543e4dd5a43d3f942be8891fe598cd60e666334b3452d4bf28f95866fe103582201b98fdc8f80935b5f49adecb22a7edd62c315eeca8e3930760f7bdd00ca4bc443838c5b2790db81e62b9f693edcb6a652af1081f3ab2d2478915b6274375dd0f63bcfe9aa1cfbb0741c3bb1081d48013d2ac5167fdb8c1ba6a2eb2d1006c2f2088115bdfc52007beb795e17cda88bcd090c8828695dae1091875c7b6c062fb6be752d336b4cd5abc891a79126cbb7adf5bd2c9c0d984c047c100870b0aa09789e9a2eac47dfedc5ca2f45274c0b2bfdb6648bb7e7f4790ad12ec17d64c1f6090a936b230bffdbc07f9a130401ea1d7de4bdc4d48e0e6b4f6570ee6d80fe9ca09685adcf0bf306ae63943ec2c409d61caec4c9095f0d74af92cfe1640cdf2a9249d2d3c3ff1fd5809716425b97cfe6afa2fe740596887ceff4f06bbe4f49bebb140588da0cf00cd9f3f2af659e035be1c2e6bec394d190f45dfc5329a4a6b55fd3bf0f1a4f2d4e8a58849874058ba7cc2c51c932b9ab76a1c85793b0cb5d03223a70ff72a4867e458632bfe3030859066e08f71e024439ef9330429d91ab7511a083d61f073b4dd088c23c8816de0ffe358eb982da473775d362acb0dd1d0d987f84a4540067ed5863254a30cf4fb5a706a9159b4f4bbeb79686c2da8b13463f42f26becb7791e82dfa8b776f25d799c00a1ef5194c846a3e8ab063bc6d10be7af4d1c21f045274c4ce3be393dae710d8f4615714b4a1ee807dcae90af73914b0379897597ecb7d9c0a80ba801c67793ed7938f8b1bcb2aaad820b09ede2ed3aab231f80aacb27d3efcb03b4a19db89682f2a147f3592d731d64aeaab132dc45d3fa8f2cdd40b25ca31348d147d207cd80c283a8895e389bd7283888b09f6c14b80231a8af50ad85ac1ccaa2749931ea71ea61f33425a86410ddf07b530ccd2a202bdea7e2cb181b7e413b1cbf316faa17ba959e12f9f2e791ce516b1988e7bfcc3da5f9131ab2dd26e90c2c6883d6d48a5289ec7dceb4e728e8b68c1ae972ded385cf174d75e0bd67648677f6a87fbe4a44036ab3aa23e873078f37641ddd85b6819d530f24512a66a92727e3da8a1caee5c8d354b3138d4e9502ccb0b7d0df719aac6a4607250180dc84579ece635e36fcd64b7a6a3e6c8e8fbe403b3087b59d9e9a8d8487411aa5c5855110e283bee71001a89d89d41d6d006b4ff8c5fcf14546674dbe240c591ecb0832d3ae0c7f23bfb4396fd6f6cfe984d5d2eecd996c5e9250d44b78f42b0ef783028264f9d824cf33552c34630da3390feccf37201326d2e8c64327c8b7eb870e1a878e2f6a4bc36bdeec54ea98f97002f61115d95455ae85e8a802a77bc600fb95aa300895e8281f1e7e0e4adb746c0ad9bc6e6e1d4e787261f71fc5b8ea26be5f39f8fc27c54a04c63b846bbd138141bd6b7350d66b7b1b86bf1d8720004f76dd7e5def54b5df7b5ba9784d8450a7a36908c029fb54a32a02848b79271375e5f14f14af78a09383e3945c8cf890b790ae1885cfdffa03ff8bafffe33b360b38ea96421ab5c4672d5bf4e92adfac7957bfe029a3f0426bc0d8b10fb7c57cf5be660fb142bcdd0badde5eb1302047edd4d1641101dfa4298083c1e157bccfeedb50a4ff5affab2d65f5d5847c111903041ea9ae23959be944cb077a3a50cfe871e32b5dd8364ff43558751801def61698935df01b42217a333d9650c95d3bf116901370715895a9026603f70208ebdc7ab46f319cc3b9ef67fc1b88512ecef7f06b388c874c63df95a4f7fef709989aea0b63071ef21ea03001e1e848b00e03b974d815013257a6fac2c37531725c9afc5699f20981429b1aa373aaaff770dd7c3d28edd640137c257dc360324ae5e9c4c575235ebe15f6e21252f3d9be05467f772ca0d8b08c1dfd1bb3bf1492680dd74287da151d53b9d30bb59eff758f5acbba736740ec64faa7786fc03fbf7c24a81f19a0f920e58356af2f4d7d42fe233682c16ad463264d712cd13d594f6b6ec6d4d886208025c0e1a901884bd9ac55e4c31c8117e69fabce2ca73c9a1b2783907a9b6e304d9d7d189ebc730e7261f2de9a2868f50770a9ceca81180f7da71fc6cdd36934b642add96a30a69c51725fbef38128cdd34f43f642454a7530f7281262b0e1886a991db14943d81d56816678439588a0c60494ca4bd72962e637bcd1fe58d0e81e7520f3cd0d11b0eb5c287afa282a749a00ea241d36c04a7c75de9c4aa7628d3c432206e6a6fe4a5f857b5618ad43ee906d0486e5a6994ed734fefd8d1f4ffbfbd187e0a844b877e77a23a6ad5db8785ac261c4d1b3e7545566baa69121aa3ba984fe7df34e0e6d39229b4740400ee2b456ed4200f3b9f475ca5efc96721b0b42210959bdba3877c258854914389dfe58c0ebb87a6dff00403bf37c2c4330eea26fc32f13824ee48e62aba2e4bc5e2413867806abb81f90a88845ef12de02bf62c10147149ecd2dd262bb6aead850d65f4cb482c23189a99d99c13eabf5bf54f78c4cc3a46401fb9e4c0fc00cbbaa7802caa493a6778df6ce77d8d8330a65171ce461c3937f70d7c7790ff35a4f309badc95eb0f5ce6592c68b1736cf053fa17fcde604b23f8d8bd46104a6726399f844eb6a7f9a498fee43263565fd1b1fcb15b24b5eb540cb9fb82ec405de7efee12677e64e5e1bc14b662574db188f9a59ddfd9a69cfd354e5587643b76731f3d692d46d162b67253f5f325d965a6cce8a1118283a58bca38e18a336594738e66ad8d80da6fae86a760faf88a5ef59aa9ede33c97f3fe5791a0b86f897e7a4184b23b3a83b7bf6d6832db7dd70256865731ad49703503d16f3b265924b1465c442932fe221a3e291d13557c2e2b990f5a4aba1d224f9072d9474e48e1772110db057a2979d929590ae460e9dd9b2152651cbbdd90f36cbfc2f4aa47045cc8a3e3b5a81c0e13f734032abe789882decf79041ecaa64f0e1d4149f531e3f15e9e959ca1a28e5dc8bb609037aba91672d7842f72bf65a7801d776b9699e66d5fd2155b571326ef23b40e0dcb83835d7fe87226c3f9413cefaabba333227897d5cef16203ee3a81ce7524cc43681de743e97c8acc33d5a3fba4a7dacfd8a346b36c62083fe5d53e4ed952c4a2dcd134b80c9d84770b42490271cdabf5e24c42a70095b6290ae6259af06cfdf847ddb56bb161c716c8f47a0510f5e58f0e6b97704382dbc1da479054fc22910c1ad7593ad3526143add908f5346c9f8c3083f289e7f3459e65e1ca8ecb922aa40406c0bd4a2b0acc38ebfcb3d3cfa1bac68a71bca188abb81e4e37216454f6273833a4adfe45d59a8178b1067f24029efcc83fa7fcb4ebcb22b5ca45455765d3ae09d483c6b3abf3812382b515488b72de4b4ccc267d7f075a5add94499c1eed47f807d0d96e84bc8a04420c7b677970a5e511619d954a137a90533ef0c1ee4e11d3b637d2d9762f89c66940d549c85ec9c83c3f9a16bfb83eee9d5a2e53ad5bf475efbd768f93a58f4509fadefba7dd4000ee716683d8d41f2193907bb9bc044b4d7a0ac6f5006ae8a9e248d6011ab5e365639f49cb65a59ba0333f447856edcbcec8ab3c75f25ceaf92d2e6b3c15393c35821daf0dd35c31de6b91ad8e96c27fbeab422618a1151c25cd2e6901827c57ff47f82b534a29cc9ef4d7b2a75b808e918689a8257fe76cd63a1eb05e0d890f4bf7cfd92c336698b3bf1f2580814b3a7cd383a390410460e17d9a52b1d328645753b3bdaf0a42b53954da8746695b8f3e0becb3f50aace770c0a7c52990395cba01ae9da69a2031afd486dd4e41f63a81c626fbc0b8d2745c0eb0d7ac8745f8703a442251082f3e05d4482dc4bf6f167ea2769f83e312c7a11d8b57a1779f9825692ad941425beaf8fc4efe81ecfe07f932e87d0a991bccd187c060602c9b71c160d8aa41e2ff438a6f07645fbb5a9254d221e469ac0808122dfd5a61e33a042a0cee399adffef6038fe2e0d3e95a98ab6ac2f2c41a230a8081f28bf51aa344054cf2fbaaa929625bee4074f6a78c4681251f2ae9f74b68ed540a728186d3191898f02ad16e20eff0f652da18cc3529e7a94c8929f477ae7b4dcd32e820f2171465c58e6b19706bb0452b846cc1bf7b9b29dac25a63abd9c80ed17bc92c9aa30b046b8a6e111addb31722187e726b90b092a4f537edd35a89296e940b857dd3611ee835e2d40bc04b7fd5e3e7c3dbcbf4ee5caf5af8eb69eeecf6422d54e27b5ff2a8bd4e88fb7f567aee7f153e24472fa651f355e20eed29280f4d0a31bca8ace79c208b550b39e47f32edb6bd37298c37d7ae82691d56a0722e6ddd3364e151adcde4accee1f9ba0db7f4470dab3a47a3e19d7227cb5335d94b8e1e51407f7853eef3c8f6e8ba72385a7fcfc289c4f01da7e960efecae211871f9e1ae7fc96c62e9b2a14455acd574230c964d53ed00baa782b579b15356a0879b7672c10a38d5a970839db8ecc9e5c59bf6f271f7ddf8988a45fcb8956b7b726a0a57464962e1bc12296dd0181d26b25f216e3bf7456559a600ef5b77b976ff05d90baaf2457529a6926a3c5bc6e2bc0b10f5610154ccc1a075b81b9768b7e8b9d7c819e4959b3c37f6ed44f8a3cf323bd01408fa2aeb9cb4730877cd83b25685e6145a5ce4270fd655bafec3d8d8124ad6f024216f1711533f3510a1ac1f93b303bd1cd2dababa6823f8137f4dcd4a811ef5527e1b1fe4d80cc180952329946ac791a427dcd0528f0e3c871ea467bc94953b86f02171cb815c24a834d3b76842422661c57e6201ec45b363d930392ebabc65b018fa746f73af31f0811c0bfb0f57325ef307474d96f307c526d6f77a7593b436d00da1e0cdd06c74007b9f1e50a2c48f7193d86b871d9785adf31b535676ec25fef19ecff33aa215ca1136fdd38755153c06cb0920d4d2684cdba7146ffc69b60ef463d5f6d2af59b0c381de79ac878d43ad612299f9a8843ecfcc5bf71e6c91cc25b491b99a1556f5a47ef6c8402a62e58e9efa7f628a307a84c4aa94d204ee1493c2151ca735d47dec392e66ba0e330c9dd8b802157562cd5cfc998a5df95b93586f7c6cca99c5c33d7eb9f9f52e56a6bd77ba925f077fcb4f96cfade910935260db35aa7219ff75a31a92c0ac718dd06321255883deb857ebb3c3c9860bcb67c78fd6e54d24940f53b3db3838529dcc96aee4b67ffb8b4b90fcda89ef80da0e497dd44d4dfd18ed121d62efca452b782d9d9a3cea4a6f95446fbc8b7b4272e40248640cc8a3a5b4f8c61f5ac80aa0bf81e0c08b7fcd0a360ef8f47e69f5a125d9de491593eaa3a11c540a7daec6bde78616b70c721dd1238b5622abc4c4fb85eb1e80c864e5432e804abb4611d1fbb54ebf92f59d3b3122a7a65b02f2c0ea56e22e106d1458fdb09d8e2a4bfdcacdaaa265eff5004895da00f3a69059940ac411dc41f81f4e4e859a78f868ec6b043d42b312ccb5eb2dddde8098aa57618db8a67853d8aba821f6dcdbf5dc7bc53568b4c697192bd8f5c2adab3694dda7f34d4a08bc0bfc42b8f15a3b7f73123760f229ca81ea23de1a63ca9581a32e4fd29eff6a3f4509bfbc1c6cba0ca4b75c5217d9938b983331ab7d1d4725952ae8953c1c0018e8d26157fd64a2b0b797e8e87bb35f01ccabace4dd4711ebb3cceb46135a9a1eca3aef3f4d42eee2cd278d1e3bd966b6bb021662072f0abf7610da97f8489f63e3e13e6b2179ff35e0422c931fda38648036051b0d249be6d012fd0d97b04e2f56d35505b4062a5a61a82d904b6adbbf5ab02d158c7f5333eb3d567e3dfd2c108af5e3b24cd4143ce2be0bcfd93fca94b221f140f93b15c4bee020e33c491c733425bb8f08d65b03de510cbc6c706f3fc12ff6658ecde6951d14f051e896c5b583b3c70f7876e67764a1107729adf842d865bd32b856d3d6ca9abde61ae4f772fe212a733e78704b8842a257ac6f94d11b6d48fcea8fc6624671151c80b22bde8497b6b5bb4d5a450282bef079ec8b4acf01eeec46f0db347c06b393c633308dcad27d2caa3aec4e51e76b3c47e057b67d88f59c8ac1646fff7636e7f3b129b0ea82a4cd706181c8c32040686ed63c216b04ddef667ac6a821829dce6712a63508db8e34fb7918aceef56037e7bbe5d925a095e3b719514dc7be2d8a4360dee5970b0c2e7ebe75f5e9178ab38437ea63ae94a7a689a43c997f187920c94eac2e0f02052a513965421d8801d663d69e93d617a01ea31be4bfea6ee7f34849e49b2119e11ffc1aa1ab1830622b3fa1ee9cd545b3716724b06f831ca1abb671b1e6c7f1b2761b40087cef6cca64e4ae59e7428e226ddde36011a22e1bf7284825ddca1c345e96365491dd4004d30b914c1ad525bae147d70852e78e56d7d331c03ad39cc70808c800e77dd29c454db6e7765af8598c0f38637fe6606e655fd0fc8d7e57aea265cf8ebd1ff52dfa63641c2c901bfdaeb09a2744ed901474f06446461af42d902b1b2821c8b0c5b9bb5cc9659554e3133cfa129ee2a74beecfdb225f98d3d3db79d5b5c92b44e8108c53d7c640fb8ca7a26eba8818aefb73887242ddf5d91324ab21ac207fd5fa3f0e19038a66e2bf442940e8759cf3a7a2d1f1d107f58a158a94be0072dc4bab4dce11819ae84598a26d12f4d831f193ae8e611eb409127dd03ab113a12f731e693d5b182facceb63b79c246bded5f62a90b10759715376f3070c016f1e833669104fb94c40df2fa43aedb5d098e039bc7eb6e34b05e2e65eb06edd7bfba071033f7d5a94f3081c4089452ae263b3de6ddb5fc30d1848bbeb620a482cad3368374001b4ab8963c443d7172ace97e8e461d7785827170bf2d7bdd1cff57913871b5c4a448d6f894ee8e1e64a62f58d1b37436ea01d19abcee5870811c9eed2aac3fe7f7d8d20f7d125ecfc9ae1dbf1bff8bbe8fb755f51b938f19a7f931ce8d6a05708594540ae00aa9d7954d71bbbbf0bcc56de8f2f1a2aeca7817e17f0b4d30beba517d074c2c6379e3d3a813d839225da7ea85ae76852e9de8ccb61d5b2e8f6a09e2ce897e2bae97cfc68409eb5469f9b5f72f5bc69551d56eb690e9037f82f22739fd8c118cbbe5b47f599d6122acee3415a900394423a858412f028ee1dd24c8225085df6d644741eef3d60c63b7fe4d1728063ce0a0d90a5de7592bd2b4be7a3f229e27e6dee049d09658e8d0b50ba0bdf3ab0f380f70eb0657a1ffd72c939a94de9e4be3ed1cb98652abce18f88c4c841eca71dfbf206f30933b71c7bf539787936bd5f816f1e6891756233727673ada24efbb4e43a4e4a06a067805370266c610fa8b059949ff6dc468fc5a28d739788d59004e1cd6abbf1bc893b01d95912e52c3a1acd50cee3d9542d061cf15f3f5f56743a51890e73070380bbda5f294f260cb835915c3e5af33ecf8d1c0eb0577bd5142214997805a64d82ab7074cf84d89451dbec13b20bfb2fd09f13f8d3909e7e75ee9e8511d3ce20fbc36e5346823024e454349fda178aeab9fd0e4c6f9abd7249ed1d029118a6862533e58f06073ffe087d51db2a504f73ec183a455012363504fa86c60eb8ba4a3e5aa04a477b49a0d3af8c1740e8cbd52a0644236952efc8f133f360b11ce6226e00d964695c9cb5b8f9b5ac58bfc54e78e233b2cbfc834cc98bbf96202fe8380325f8394f94c70a15e3a49293a1304f251a8f5fb64fbb34dff7a5bef5af2a13bdb3337f7c7c485ef81886fdc1caf582a1e533c4f7b175b1934e1397ee9f7e328426f47d8d6d536b394ecbfba51c201794c9c00e9074ce8510412e09b55086ffbeaec4a138d30a169d43bd309fab523cebd437df9fca76b463ec2aeaf6dde97b1f2b279bfc2d62afa42dca1fefa28d9d590b7d73b73c4a960c865719ea359af96bec14aa768179f55af99d72effbf210d864ef74afb8b0bdd9ebdaf8c71602e6bdbb3b8084bacf59bdbf52ea8fc59eeb5e5bcbad7ec1126fc71c7daca53384a2ebac70bab6f343898575dca90d5b6d78c9efd44fb466c27119e0e0ee190f4bbb84226af5c8f1745a1ca77a1fa0e93ec0b5561630d1430a843111b5673e4cb1ec2b2e7651ebd4625d489422e60254af61468b3917f37c871b817426fd76d8a8814262e131d38c257639c040cad07cb10bca159191a835568e0938b294c0adafe3cc05c0e7be7c61003471cc2c969f7fed236584ad24829f57239aae3a96aaa15a6e62299bd3d2f81ce7a0c3832755114bf70aa24c1acc65411c4f8115b2f0bd070175583ae548bcb128efb3880796a202d4cba8777cb4b69fc9ea79fd6bae085a541137fc90c2eee14e83e705a15b0aa31a07a4a588a2e3f8de8370dd826a259ebf146b7c58a23720c6da291c1284eb84926ebbc9eb78e636365def057b74fa5f79fb150dc24c84b3ccf854b39bae71df744b880bcf6e3eb45e9b4cd5d8103cd679e89fab5b31e9fb8c7ea265df4fd26b09d8a6843b18e2cba0ce3ee78b1a576d2ae65c3a820f5f3c00acfbdcfaff2f0669d41c8f45f54aaa1f7d9661b3c80c87187275bcba1a56c21314219df5fa238de8037d91656391447efceb89bafc6b57841c7a947a90298e1b8ca3e809f00291b7cb97dad8bc49c15a1305d73d8a3cce8d5ba2d1c0c62bc2ef097a5c8cd994fdcc63f0c98191e75deb8bd4de309620f0f811a007cbddc024684d192eacd7168dad1e2aaaa817f4cb920d9efc269ada8783d9609d4bdba84ffeb5cc93ae9f633097c0dbab27255070f5da1422049714f60fc5df7cdd3367e7c04610257ec81865b07f14864c961c16162a0345cce325ba32f87adc02ed0be7253a9fa3b70a36aa03c38c3b8acf3006665e18be9978ebac68395d53ad134eae2b8f0d935c2d2a6bedf2e0247fd6d26f096fd37457bea87f08206adb321847716e3fe1922cb1cedc0a55bae20884cde75456f54849c0569b739605af21f725cabc236c0eed9f4fdde716550bf3450089fff5d21185f399f3433f1adbe1bef38e8715a8b170755248a1afb6ef55ea2f00b5d3f3bf73f5808b3071e3cae94d04c155f28d0f619f0d1829131ad328b38d6f610cac9cc846a671004f89b16359f02ee7bd6b63f305ec7d54cbdb189a66fdb47c78a11952c244cac430fe85126163efa051ec5cb4ae334115aa5f79e5e9b030939ef7dac18e019b550eb50800baf8fd136a32d6fca4a4151746d639064f59336c1b08b4fb943590be098ff6d4ac900ab7803731439f98cacb8a169b0d20db5ca78af63e8a771b22aa1da9f079817816edaa47d815f0da1c2dd926b13eb673a89e14fffe0f90487fc0ccd38fb0b7b84bb088c3d9b523d4ee7ce523a3a8646e4c60bef8d15013407f01a56e0b431251f9f7c8b097fb501644ebbb8967126aa4cb73e355edb4b86b7e49a01713dd10db543407c988d4d3bce4b5a75c881e5c3222e6304549353fefa0d56573795f919b1221d750126ed1e6a39535046bd48e7e1bebe812c700c0caa8931f295a1b1888102c3f5d08ce61dbd1b39ac1354b1f01deb03a06efb0f584968c79e6b8baaf18567bdf60f36f9d888025454c3a2d7b200c0ca15bbfdb4002e35128cb132ec6e1572f0e262a12a389d8caa282def1143f3b9e883753e373726616b1b217212186a651495a5596c7ff32883a7709a2ed03eb3cc59836b38d6a81a18525ee0f63e5aa64ae96186845df52d200e6a04c86d220f7abb2e6afd3b8845e841162f790e56305095e31056edf519362072ca17bb68d0a060fa1f205ded063e10930bcbeb1ccb082b266942ee37e28a3039800567e985363e126ba85f3ffebfc7df44866053de2815974bfdad415466786e8b187154648bcf3d4cb5226ec6ebb4f186ea1eb71abc526eb5f5c157813d8a7ca550635a47852108328c34826076d3ffea905065e445e020c83469f552de19436fcf07902daea1eb9bc94734c9262b5fa357008b8a13624ea03a63a1cda30843e0ca811d7d13ed7c2beb2914bd4a5ca7dcc60f1289e534311bba6629f9ca83a23e10a5f32fa258432f5b3eba52c68f5de148ed8ad3c61b2cabe7ed6abe8fdd0784458f8cd24e161a567c226482b706408ad06790ef458171102094c0cd86e066625b920b16c7d1f083ba04a034f1aa68bb91b9c9127e739a753310ee05092445f917c2433b665cc3d0d84ee1d6b0e86cdee86e9066feae6ec569a9c8a308cada444dfb1e8732fe9f6df74d24e870281b046a59055895c52e28d20cd2ce3742fa8a0adf740a060bdb7342ef185b31950dc3ec6f4047f96727f88c57e0ff98d8142ab83de1c9175e6552fde65a68fb337f01d1819ea3ad2d20b7a2a77bf8fb60cb2d276ae865a12904c043e338ec9d0b556a8987e3a29e16ccb0888e041f3181617ca1c5d8ee088a840b17ffdc3a482009726cff25a4e49c9fc842d417378b86fa04b2ecacc7ffea4dd4ad3dca230dfb655d6df1f39ec3db765591cc7ccb1970ec98670776eb4946429179af0b2a750e3da2bf5005d1b9b1b589b611c42214fb2ca1de5f7f344b726db9bb5d885d98b7635aab93d0c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
