<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa21f9cf529fc8979de803abd147f6d7e3280b640ec41310e7c0458e244eeda3ce5d54fab079887661ada1a84d0a60da26e0373eeb1e3e387f881ed45e3963109dae2b9b10a935e52ed2e3a6aac8392ccea6c2527947ff758154888e068bc797e9fa593833072b4ae0063fbe89c9a243d988252ca263f2c0b99ede38e88c78c9d20624c09e9ccf7c87ab7560dcc9c5c886f75a0946da73ebf36d3a10257aff98820101caafdb4ff4f38709b21741a9ddfa06bc11512d95eb8df7903901ccd1ddea982e45f81423d742039c26ae58e6681f4e87b5fd0b5d452de6f4cac40ecddcec15de2db9b059c4c96aefbbad89def238546e27d7e001ce1bd1d5252fb5e58c85f0ff9ce1a535c286de32475980454184f44750c10e9798d8708d6d7e377e0d53b1313816e1bf91d79b7a24c76f15dde831cf2259472a905262571ce96f345c32dba72dfe64853d115ec064803cc291b33e28c2374f9f241fe79a465cd63c434a6c3290b3592fe0d73e92b43ff7beeceabba5fa13b81e0e0a14b8e63f09f3a992af4c8bddc57101a26f96d306232db14b137f84a27e9e9cddeb3295e5e52a05832f5511648e6ff2bbc805bf696e1c940cc193849a70e242b2a31026a1d84d3b3a718f2835f2d0783ecf6bc79c2d26ae2b57166e6b32a4364e38e4281e129d71738075161ef8863d9c7c68c9743925deb6329fec4480f715c1b4e3de1bc2d3321724b5014a398f715befc2a653faf3f9482f880a09342e8feaf540b4f588175f1a3719ef5253a0e37fbefe6e90f7378f52cf5e113ec167e24ec643e3352223b3afd36f0960d8d40c3d6737dcb0d4e94c868395fb69cb3afeb131631082d8819f692aae2d6fc4eabd805ca06f7935ead2713bcc4743ea6eb539ab1445bdb3d19265a03815882f0efb0b183dab760681290b3fea1f5590e62dbf5f004d62f0fad7ffd61e09ac759369c1923cba65d40886ffb665aa983ae50a6748758542d4d62415a3ec9b777bc76c9ba27c43d5b74e9b76d62fe4025e619280149fe9e629ea026aa9268083ec2efa713406bfecce0d7991722a27eaea3c21fd6fde811a724f3550fe79e21c574dbdda4f52520eb941a2034f1f3381d4c76cee57ca817cbd30b7190094baf5c695c313c0320fde674207eadc42d79c65146966ae4f3c81c895a7fd248e67abbb4b7c179945aec3d503efbf9ad78dfed3cf86c2199617666a8fc684aedcc625924326f39fa80c4cd69f6817ab8582e06ec5bc7e77df8a5bca0c33da9f5b7de6735f6cdab638a6d33c438425c3d1eeb0683875368c562bc0aebd91bb0667b7407e28332f7fa112e48629e55dc83d3a919e9d8f7b36ca605cc9de717df0933ca15efcc46d0639661621ca154c875b735a0affa01ff87f23cd8b67f7acec185d15eee0ad4f216c09273910739e6d305f00657c86f43d492e6c89869220fa61d9baafa4702bdd42d154460a1e93270fedf6f4c9cbb9c6aa6f404a26d04b6fc4cafd0f4c10d003227fd1343cb598f6596c2f0b81df0c9351756e15c73f95e5a3a5216b64e264b75a94f66fe6983857d76b46e1a41ea7161dd1377b7859eb31ab31e285ddb80561d5bbccdbe7738463fe0bd8321479bb81ba14bedf2895541b7073ed2d53e3dda5cd8611ba95ea3fbfd46a6bda17dd92506f275de5f4a0acf1085d34f9c0d5187128f1e2d335197bdd45d5f3951636e6bd18ef89474fd6048c5ab3f6b2512f6b8bc2be7667695f1684c61b0659e31dd2aea5b069f296b6059b598f3a4607a9a9ca9ab20887e9e7ae065d20efb8bcf1d3a29d72a3dea8347adae08d7d5debc90161b32648264355420052448643aec092c4f6d5188fea90ee269bab8b9176be4681864932a62de8410db71c4f4ab6ee383021f0f936d73c704284d6efa615989f43ed3272ee2295b5fb8ed6b966b087b732e3950fdafe4fed0e618f250b39a45c221e934430f2b90d5c565d87dbcce40427e8aa844a65a8ad513ef039c9028731c036e0f755dc9398612f2d3ca3342fe30f240e7eb33ac03f648135894c2dc4b4031db958042d5d9e050441c286f27618710d9d7a2431e482ac5e993a140505ceccba43cb66eec3e477616c6006601c47dd6811041889c65cf03a97c466584babed232fa724507beb221742944bb45c6d5159fb00e3f8823ce7229594681605d2c26d96d2dba9f731cc80ebfa8958eafb4d41b85974bb5cbe540e78025f6066c468b3d8c06b0824374b073f53156f43df864418e97c16c9bd1c2e74491a93e6ebe4f8d4273f627e213c2518626880ace30934bb6ab5a815252b47e877d7c2f800eaa3b4d4c601a1b422b978b8619dee4f424867b1f6681eaaf55d883419f4239804fd28b1e72b5b42ed231f79edce6ee41f5cb81bdd99de7f8476f1d91c7bd123470cd236d7eadfb15773a7faee1bd9ebe4bf55e533fa0b37337c08c8903de0ad8a9f2fe5a54987659e94674f0b4ff8ae4c8d826646f55636c92af38de44556bf37493344b5da7acab90709e3d20eb7dccddc14e2c0af4bcce94079561ac97a810127614a1a26e09e161507ad8021e7c74547d12912a3e07ae2c5c9b955d8c3647319a5ecf29f6c444a56906521ca340b4fb69bd268cc336b6c0136cad87587b4e15dcce0ecc676f1ccedea90d2104e4ca6dede3a3c01bd153ea6326a31924703bcef2fb944bb2324d870a44e3e06727cf120d7643ebdede22516148953dc2d505ec39ad36c9a67e13ffdb76f78ff1b8bdcdb3c37ff52cd0aa6783689d4645bb8ad9fc663acf57a3ec4c30871f50069cec94ddc00a64f1110634c27e285e828961b09fee835222a7c5ceb08ca0f2a40eb24d0c59497a21b326cce317e0a594a33a3e3eb1906dd658dcf50684daf461f22db77b5bce33665329920f8ec10d0031c1a7cff235f63b3a092b6a4a362f1c0ac2f7668894c15513c301a521b7a69b336ae6daa4ef96cbb142956ddd0bb1ea48a3452c6193a7f54ab233cd6c50668f26dfcb11c5007f54368545ba580b5121795df5ab0a81acdece150a40f8eeb0e775b17da82e26c8882e83faa3a696fad73a35f4f530b167899664aa78a76bba443714a3c73eac39f8ae9bccb352ddd3c815b20b4ab71fc1a22ef0ce9b8fdd433cb0ae303f390dd1b1301a41f2bc14df371525853af7fc4c20a2db7016ec1e98380e2ad8b4f69500500f9cc9c0b00569ec63fb8401ff70d8fbade6828bd2e6bb874dc07237ac65ee00c02ac40945c532c6f835a1033b3ef48fa62fe913eb94c15bf5e467e97e242ae62a6973cbfd7d8b0bcfb3b35e753413ab54d6c8f4330a4cc59cee25e1cd1ca474bfc8f8c7a013b27d69d4c0763768e7f0813f7c4590ec083a37f1a55e74f207f743986fbd908c6dbba19ff1e65706a34cab23952fb7c523f9f815785e5190fb09fabbedf21808cc88cf83ad0bdde461c9309452425457282f47c73689b1dd731ff99595ed53cef1b1625096e916d59140f8df25399f9b270d3b00cc0ee816dbc02e253eb1dda2e1d894f9e985d7380d3353a2cbaaeebd189c474146afe819f07182e924097da485ecb924f251352f412c284ef08f2325b47bbc81d66520f62069fd23f7453cd71ee1dd3cac028f1c481a3b1d97eb6cabe972ce91435885afb401f55ba4f20293c326f4df15d5304d274b80243190c855456d9b320f881fa10eff0c87fc816fac4ead96cedec20bddf8886989911e4dfdefd4128a4e63bc558d3a7e6155d13515d2d62d65d21bfabd7ec8bf588814e1011fb02b2310961511cd758296bd5c6608d19e12ee854db0beddbff0f43774d195566245d0023f6563c5f36313141b07853810ac950f49406a020e844dc9f4a19bdcbc97ce742af5e04eb1c703da92015d7eae150f3c5d49c36f90c234a14e80aed80b41f7df187cb411a422bb37eb757e8d60574ddc6b462abe513f5bc099051704a8721e86c3d963b6034a3cf1c1ef4dcb88e7993f93e5d3b287c96e49ca0842aeb20bfe4bb060e75e02331f98885cc61bd898bb6136874145008092b3f713ebd7275dd2148d7f22cccd358ed1516f77344a76ded47a1ed810eb33e7a2f65a60ee1dc213bb4c668c294144c90e345ca2c101a88cdef2d428091073e1d81d769070276e1eeb667f984c3dd527a2a9d6d0af03fa3fd401d831533c5e70602a3a89411dc3da50c15b2b25c186adcb72364d081af275f15a7bc96e7802e30c1463c849794401c800f6f502dc0323f5a885bdf2f5b7646563761a33b4705e648ded6f32be8afcf1486f903e8899db982b3c758573975256e9e40a778d208dbdb9405d9cbbe5756b2cc20aa26654c4a36649c3bb50aa11e4870d641ddce28429dc0ef779c47eeb8287f1eaacf50f348adb807b3729f4bc5c30be2c1f0dd4a3fe84207d74c99390a730751a015cf4a2405e50b4dc4910545f049a0c5c39c79015372e3666d8d6b3f1c69e59c7f29e03a337ecce3322afe9ddeb76c4219ba85b16a401379e1e58ad55075326fe2e04a5cf88d7e563a8874591aa7cb48a55260c49cff2dbf1cd30ebe2b36aac827661cf57c1be22a5291579ceb6e75fa8e7bf781c761e00b04f8fec001481bc208e3aeaa88b677def8ebcd7402f6e92af4d75770fa11e1b6df07beb24307a43779596a1cf9d7719701e09b7c46f6c1ccc9464cb0cd0c4a96e9c08c56f1ea5f29df1f67afa4d3ac015511ba947c8589897c14bc1628afd9e0f4e537b12f0348ef43e0d4ce1b1d24408e60d10c4a99ea7a10901ae27d3c4ced1c0fa526d08ebb748140da39afe40e69e82b9c8ad2fcf1754fd627246a50d7d57297c82619c1e7d09276e1cd0a5600a2806b48a35c5782fb71f7fa0010dbd960a3db11e86d8d0620ac9347515f7b8332fdc264ebffc02f85fe411e4f2bbec2e440f55734828bd7d1963bcc8a1240e5fc95baf5fc446e2334647ceaf6c82aa4e6940e91c27d945c5f1cbedd9d607efe24e3628163247ad8338fd64929ff9e003e8d59c6bb6d6b208fb1fd5538be875df1490a91c8a0b0f80a26ebc827a9edb2aafa0d93eef3153ca4da690841db15945e90f368dc606178f69c63be4b40879d36dda4b71c2f0f631fd52d59c4344abd17edf3aef73da09b269841a19864f007e20e244f36ba6c102a8b2476725446b4f4f4b319f552d7414bbc0ea6ec65a695666bb5491aa847f449eec3e77487fb242a60ecbde31323203f3179910acd19b7d02576c92fc3351cbfcb1f3e117ab0ab3da722f112bfd494def41e6ac356f7f0074452fa9e431eae94bb206d628ad9deab50b46c79a05ddac411a0d41bc333c6aaf80a62453ac881154124addfce87230a4b4e1e88ada93d0c75882a3d35a22e50138846e7a195cdfc2c98558ea18c283448ba381695e77f24727432873413cb1b81d88567eeef05deb084348d5188a326f8b18582aa7bd91ccdc37ef6ebcbca62ecd78c3b9d2e573846de30efa956f8a15ae3d1ad846c643191e86c135e0fca98bf4406662a9881f8f3442d63629fc346fa9c5d31f244de056b70175af098f3f21d9250dd808649876852299dcfd8201e36ff4fedb05220922c1644c97879d3ee3f6079e51c01ab849971d3edef267794a7eec7865e54598869f5c69a33bd3eea06730e1fe53abfacdcd9747895691c18e61dac4ff62087a942ab49723599065a08450fdcbfdc8610b7420adb685b67f23051bab1b7a754b9aa1432e94f3bd60ef34c5340679dc963ab32719e16e97f20baf1ed76b01b75fb57a7c1f71a4c2ebf460b183de389f90ca80b35e320382d990c7b22736c886980909047f91af609ceabac323a886c65437ca3b92682625d8213be418f51ff2c0c62af245893d339e4e17a1980793e5d5aaf1249d60f36ae4c67a4682afc5fd08d3bd1e2360b298917d858f5f0bafaf9a7a030f041787548b8209ea3534266ea0d181f6be24563485ac45fae945b2f72e7effce4117a40c48fca2d43f9d83311b8541df6d89c5d6e00cd70d3816b303ef9b240b6d0a33c56189a18da9089b19e19a93399fd189591ffba25bd46ed8a5c57086c7da77a8b704dc73fda240080439c48b2c6489bd323168e247af8d1dac5c5f7fe569740523a857bbc22e479381a9ee95048a547aabf6c521a6a4e434c16867b8a29803b2b5f62898671f272cf16a263404ae4137b60676f8e8635618e35ff35891b681988bf38dca5b5e099201a6ed39f30d4b24423f075d260a14952769bcea14bc5011140f999b692e9d18740ff015da8c0fc230a82db85d0d3fd19ea0d8286ca205a2cd2e668c09ebcb29966d3b07d32656e482ea6bb378d585259c14c4827a53d6e8e2ca651f2a58f9471099b35b4aa69a61b3d543bdb603be25da7f5a02994fcadfed26b7b155aa11ebb585a747031c47dd116a955c9130beecff17a4b3b2a507e9deb8c821d2d2caa7392489a81879fa19bfde4a908363e4336150acdf116f2b01f0ebe6d9c0cad74f79ab441ae0be764595c103975e3bd1c8005cc0993d7f77178c532762a8c4e824380bd9368ff8e8fe317e10dc6698a9344146cc70395602724a617000ee25ed36263548660a864ee5ecb6eff47e61da72f77766c42f879db09c99706567964d54913060497a83f6d53ebb6fb5422fd4a11e65136ea7b2a064f34c8003623bc188af927b5b96c3841c26260b54b95ec2bb2731ea4ca49f863a67f90c3e9a1978ae379d62a0273cf4b29fa77e558dc0123b42be523ba2a8ff9ef494d92b50fcf8af5bb42e9a8ffa9cdc45745c7b824e8e846067595d2b0f1404f5d399dac01417d3fcfbeda0a40268399071e9ce9492a4d1fc118200a72e44fdee142ee54de93d746aabeac3faad7f5549927b1749a63a838e629d5616d3fd6dbc0fde1fff2063b69775b5ed86328c4411a1998853af3c2be63ce7e873f4db9baed900f66dc1f0f5892a27aba203c6abcbfc2067de9a05c5c7f8aa318b83480acfc202022d53adfb4b1e3360809debff3085f769fba9634235765006a9cd40a05be89f5344a0e4349c04f3a7ce6bf87fba6f272abcbc30c7a094a8890652e859f67b838c5ff2aa009fd6a13b017064b0f399d399bffbbbb24fb81cd242a0be86be18bf009f9d9a824ec4f873e0c19198b475ed323ed0bdacbfdfca950816b4e0ee1f205c4d2be81595615fd2b2a92c4efaf7c4f0697a00299c084d4c1e727bf5013ab9f45b33b1e93694d9726f6308e71de6548cad9de6a5f5e063cdf2ddc4d44395ecfc7728c30f225a25b81e6dda6f418e5bd601048f177d98ae9a5ae4095f05d3b481abce33a05223347037136eaf7448d692717ce3dff6ecab49a3e436f132efb85b96aafb090a066ea12eb451b8bbe9bd791ede58b9577b4f36ad9ed4ce8fb72ba69c040c9fc7b21851c691a2789720256a0e0acfdc2bb0f68be4ac4e27722b81b972f5bc141580d750f4b664e9cd8ab2130de0183d376f15d8dc00c48ad79a3b45c09f321a375dee66609a3615e34486afbbf2ace49270a5450c350d67a98c05d740ac329fc28a6f184f99fb1f28fc96fcb733caacd3674ef99fd4415695e62c2c8c5f6804a90db4d19d2c498dd3feb9dcb7e389573b4d14cc3bcf813dd9b031e3a48972acade3d721e08b0fcf3b9da61eb3e168fce86150a14da80fcd47b9330f68e259c579f249bc631c22fd678d80947c19bdeb27b1f274ac4e654557ef102a80bb0639f07333c526b6989855bd8ebf6339777aa7032368485cf1d3a8be58231c9d1ef97b670442b11419aa1ccb3b8ef4d57186704fbc248fc0dee4dc858a8651743f54b56997d531570ccbbbc4776adb3a24ce8dde0f8d9a6131fa28cad29c41d3739e2e85b14701372c01906228f0dfa838bfb9774dc1d70495cb7aee6763a43242bdbe8524b483ae41f27ddf7b600c815d9b982b3f439f91a9157a9c77892614e63aac6d6c9141556c31f07b41351baf4df79b14e0dbb19e0f907f4a6191a08f2301ba838164a187c8be2bcf0187d48b570177102dc2b126b528b7665be8d85d8d5724dfc67af6d78b85de15239fd144ea70dc0d8cce8879bebdef588557e5b74e6f366fbc0f40d2524b139da4c6da46c03048c02b94eea1068d0a393b77274fd22254d3a76926b1e0173000734ee713bd004865b2a71d4f24158cc2894e25f9588dc56121a3c1b96ab33b6138816acedb7e8389e3dc15db5daa0667522831206b67e9c96b0ef57b10eda015b928f59631581d3bd15df4b155b95a3679dec275498aaf0d64159b83117e8cd0942de25535ad3dba5a557e3beecf805bdc427f03108893d4d5732217b071c870b22c4bfa1fd10523da7158e9ee226cf8bf0f853473235d34d5941a4d6bd0e0500f5d76581017ed97f201d85519055521fa53871ff7f983ee9b7b3ca30d78d14a75a116a6316a2445417b47404cea4e838716bbac7f69e32fb9042da6f1aa9ad1a0cee17da53001405950593d6031460c3f3798bed007604fdecf8298570d7dda372627d0beb10962131fa14c0846b2c5c8ab3ade4264325f2a0d6aa0165aaf8a77837c7ac6bc2d2c37dadce603d3b32185f5625fa0fd9a0e656bca47db09ed9a7587793526e354e37b84973c63410a97844896b7b992dabef19fb1fce1d1c0170c82ad120ed45cf0b9e8a83768dfd5a8fb3ebfc158078228d556a4b077da513c08b1f3f1ca5513bc729b13c2c0ae59ded6b73d0c5a6991dae4fae627ce1103fe752832e277597d694243494a3ac29514c22713a9e685d13799fcf9f7257e4d6630cc808f60b1c999c1e8cc54b40f75847b411f2aac8ebaeb0e789d40b1a1233fa32ed56541f90f970206313c06b5e1d5d663160d22a8e861ea2898e4201cdd9634b529174509240c7a838949dca815b948c3688c25a39f4c300cfec0ed2e81f7aed5314f04e576bfc8fb638e068d09ee53eedafcc0b64b9aacd6ff935d11490ccfdf68f12dca9663bc7d6f824264dcf41f38836066095314e84b86ddf74a2f5f96ed360558ff9384cb62e4de5d7f7bb46099e0b5ca89dcd108ca612a11a5dd358d9d45b3aa91fa1639a941648596a1222ff53b334d380280178c21da73ddcb50f76d8c2a12831c7e6097f069ba934182eeeef5485679bd07934393ac32a1606b628d8f86dcfc7c82e8d14ded08184a65674330523bfbaf3d0ff1acb1283fb426b7a54186721232016a0b88c3e295ad7b64457ce5de0f33b20c433e4960bae6d9252bd9939140262c1c9bfd0dae94203ff1f2b2c681cb47e5a4b76be0cafdaed33818973a922ac7dd0fb612cc0c90c5d7b4714b5667d6302b9e458f7316b3122117b631cb85f21062b7e50e6a0e4c1cdbb7d24280a17705d896d3c2ecb9bd89b5eb03c5bb6b26d9a69fdbd46c0f15f60f4ee3737a42500e07321baef6b75610a358af984b2641522d6bafb87762e2e0b8e5a3195dc30f6bbc7de8c83d1b6eeda08b0adfc135e6e847bfc7b0b3fbfe6a097a382b21d82326b6b4fe44457cebeb34e359b0e3e51d580ac16f632fde990caabf2069cdc412379054f42dfc1df036ee6ac75dc662c7b50221be3c44dc65fa6a6b37124191f4454d694efbbf78408525e0701cbf4febc8fb3670c8ec075055e3cc572029df581259fe7649b6402f4745405f2f192bfe111180ce47506ef77d035334349340e1dae26b79c46b57bbc49fd0fb2601e8a1de41720c15b302c2107d6bf4424523a974ebb1f3d6fd88ba0448877afb533dd1270eda600732f9032e942affebd68b837a832216054eb88a1b5a462518d2549dfa7f9d2ef9325ac508c340413166d1de0565093038469f1ee89617a7b5c9a48f57de14ed8569658fdd475aa9e5220b0b670b1fa94d67a18a9a798db449ac12df62d80ebcce093f866d8e442756a35846ae2987b8ed57528e011922846bbbbf3b7cecbbb468fd2d3e951be98cc9bd3829644d3250f61c54d7339745a9737836c11eeecd4d9c1d975cd06a2b874e88de2f30969e27006d59266ffcfbdd2b7598c8b77664c22de9ac5c34232aae15c21ef28d0398ae6917616f02bd41a1fbeb513dc4b1233815c37b4a4c8da7783cf918412335645ffefa3a0ba7e321564c89b45bd46a7c1eb9b34ada7af6047b09cfc41633ff80e36ab712dc9d43a88cefa696bc5e8dec91ec105c8e03550b160d9e50e3d5e2b2e0ebeb82a9d5c91c749e52860ce9e666d021e4de66950ea73e6b3fe7433380a1a05680b9ee373378bcd1e5e903218b38ac976485e9484dbd52fe0915f36136fe22bb0e31adb1babf0d6e537a43d0bede399c1ebcf555b98277dfe5a9dbb63ca4476cef0b3b681495c7f47c8a159009540ea4b8206c802df1c08816ec8f84f5d1a64f1c2d73782c4e95e21943cb3f410c1390a9a0979d0939ef3c4b309b4684afc09e3e40817ab086559e53317fdf9d9bb3dfbcde24712a5456c28d15da944d2b5285c3478dcc9a17eb45bb189c054c9c7f15d59b15c6bd09793048863c2addcfc5fba2a5dfb41ff17be9e079d8d0cbee59545d02e2be4ecc36edd053ce42c82ffaf86f4c66ad0ac2aff06b27e2557c9342de193ed7ac4b504aa97dc10d1644ae5fcc09e814d5e9d5a3d56df42c28ff13ad07920b777d95bcc6eb08d6a8ee269db6baf4335dc669b403e8bb94a7583cfc30286486258e034413a90a0ba52f36822dd031c9aea74f34eedf459f251713cb310baee1824b2a893c8761767833fb42105af56b98de4c76db828a313eb156c97e97d7ac500bd40b73d913df1eaa7f3f6f6dea7e122794c5d6984a2a99a236a1c2c5567a06f2c1c45e67d8b6931e64aae4a3ffb1dc446aa63365e85260b4ef14228e59a3d89945e4bd942bc490c0665c34a2947ecd2f0e3c1cfc1b879988464f09a8d987a5c3225e627dc7ebbd3f943f969828d6490c441bf29b4c3a6c188cdf21e840b9b40645fe9c33b99bfd586ffac6bd1d10cea0d13750078354cf11e3482063f24e6185656e1bb9dd8f2d222d0e319e343b89687f955a7009eac76c5b1b8572d4c83d66e83a9713006470881a8caae80e1d2ae55ebbcaf58d5e34ad7dc965472348190dc219b3e0f36e3a0da1133859624deec06779484fc6b64526f5bd939eda566afbd408b3d508473a10654cfa2e7005236d8cd27865ab6b905a1862b60d204c97a8b7e6503b8372147b84ba96cb6bead5026b9a55398badd148600c7a4a5d01a61c72439418dce0301a9b18935bf50c15f193d58602d62e50329f45b398f54e78269d65ba0b6b8d62a7224aada0701ccf62039ecc72736b16b4e5d860184e91f23787f74410d9d5fc22b22f3ca2654b9188e667911139189220376ce8c708c09aba7a60374fbdafd4e1b1c48b160ee29e06991a3f50ccad941011a636149d183b8b393687b03cc95dc2fc0d90fc145484ac902e20b626154dea1b28262d450ce75371261e1a1235d33e9f1b6d35f409cda0e180d1813a7277f0fb3423bb864e9631adf1e5cb1f9ba908405154283a1686844771387e3a111c2dea45aed9daa3c22e011d3c5dddcec7f4c711b45b06fe84612f3cb65d74b46720d77275d4884f13b15075129f553c04e2f07d85b798160d7ec89e316d452f899bfc981088babc135f2cbb6f3f6a7d329a1c9915ba4a779ffbe19f5873eaab14e96cab6fecdf515f2abdeac660a9d2d07b02907a8976b1fd53258868d8c397daeff0684cb9eab1af733a0ec164a7cbe47ee6ba9fa7e5edd0ad2f3450713e9461b0326d30ddb3b7af308ea9a203e63894e53875b176e5fd5c89fb4c8c2f1cada6e54d799a0891b26ad15ee04f998fa0149e535512cf10f2701d60c3122afca92f7b10972d78562dc549ef70da8accbca7c30db08505b734294bb8729a3b332842fd1216121ff7e9f284f20ac0494a5e50f878bbe6a69e0b594da3b910667e9cc2f73e4d066f8b476ba9d23d95bac6ba0712e24926f6db3075cdfbd4b756f188105e0d263e4989a156ac7bccb4f2a22f85d21db75b9b235b9af35ec8d7d5432ea23861eafeedcf61d9335144f57909d3616078dceb054e45a66a249ea186d49b2d3f25842e650076b91c91c14bb2be31c544a79c8ff5773f32c89c63020af8cf3903a922ef8f33b05b8f08c6ca4364989926153f2b421a7a28ec4a3a0663481ba9a5265bd715823000aea221beddc0a3b5c10433f2bcd4757313b8e41cea6f6a235f80f0c074c14878de0be96e62540615ba1c1575a87c35dec4a5f5e8bdb9272529c788c93e21334742bf4ddb5194da1e0182de22b0b7600e54ae30fcd431bfb4fae6a417ec8efe2bb1efdc2a36d5380894dab32395584a102aad10031e5b551df8261539414bdbe519eb03a1eda80618da4d3f92dfaa2d86750f48442ab16f04ba297358fa9996588ae988358ea22b46b9997dea373b95acc889675abc7f93a40f7721227a69e9c893c209f789e6c63a75d2645d6967527e4a7a35f2e769d729fe6b578547416f26f673f89fcb9b9b14c8679c643efb576f59d8d499568bcfd4a3cf9c67851a45dfe8db1f7162be2203ec11bdee78b0b1b9c0bf1dcb28e293714fc8275d173e739998e621c2e6f3da007e2e3b5ac603601e411c2baf08bae6803f8919e20d71986386a09875053839bbc0928906210bdf88d39b30c3467873511836c4fad69361dac99a4c2695bbbe9545c4942faeafa72bb87e318972ee03c66564ec2690df430fa7878d39d4b314ef898c3f5a12631c113407f13235ddc4687e9c6c40838da27da074da85564e03b25a46eca64fcb308917b94762117485d111d73858fc5e18a641283d9e061578ff5e1dd01d11183a70f4e5f86b433f2238b5492a9699f65f6c63e4208802b6c5257e63c908024a882a3cde4baffd9fe6f4ada6466b1bcc7b038e571b7933dc2ac1ff7ee388a82d13918703349003c9a8b1010ebae35c22280063bdb347ac281a1cada7dfaa0b7d82a421bee07e6d82fc5732a59c92e69f3f23ca5db9c9d89eec027a423066b4ffb2a9ae40590dcabdb931945816b27476f23223c77eb62c7932924fd38d32ae151dcebfcc4b79c5edc9898b265f63b6ce640994084ab46eaadfaeb3e611143a7b55fc63f1665805271785ea3a75d0f96f8fb03f59d5a6e8bb2da011abcf225d2d5f11d21876ea3d2adc0651ca24e7165419058254ad17b97c691a45c2eaba234f0ca1900d920e1a0ebbea0c46786c624e803111d0d276f21cdc2a4748a0ce76cad3f4f24984fdd99469056da3be9d359793cec95506e4ec600845986635bf5ca8f7fc62f8f7886176a3cf120f0e57cc2a8b93bd4ffe67252ca926e792b89c54be52f39857facf0ab65b0ee46c8865ec751d3dce82c3a8e2fc787c023e2f702328cf557768eb60655a809add538bc8be7055f4c7730c24986377417db212e34668d97fc9de0c4b52304fb28c57a0841157baf95c200ca2c7387f9da536e5c1d33803471c98341e91d1a50167dae57302c05bb17e5cfd5a3a20f61834a25954f2d985a16b21862b7fe95d88d1c795c0fec7a4fa889beed4b57440c3f26a4fd216e140ce0f5211533a652ea89410258702ff46af59dd74acb1ed396dcda8cbb9583987111353322d97008599b3f55f85b6d4cd45c27a4084e46ad95fdeecf748898bce75060d0c63d88cc4f2ef5170b90381f28b3887f7575ded0517b6a3e2a16c48dc634409ffd9b165b0957e91a63ef7775c1bcdd78f0fc55416fa4b34abfd962490b7dc8dd47f420cd02248293aa773e82a3de2c78d99ce8894c11c399f423749232799605e0a8119d39f2f09ddc707ba3f1e137db5c6136846d5a41be40685cda3b9d313992f8b9065cbc75d11c666d4f0424923eadbe3c0d739fb9c4a638fc0aa0b8355de5ed6b722673273aca6b837c79348d806e99dcbc7d30a67605c66cde9070421d8c39215e0ca6249c80db7aa23a9a46f31eb8ea555adc31ea450338a406d98e22faf3366f2a9ca1649eccbecc6671aa9622e8ba951eaad5e68053d50e25e75288bc01db20f205e2bc71cf141803080fc88839131873ea14add7314319ca1b1dc101c4b976832ac307f9acd97b3f813c3473b84f54b9c9867f4559f2a2df6f5e2eb451c40548090f1d19ce156e9616c61714d695e0ca857d7e296e29a2b1313744c6da1a84d3a54789e1386fc63aef582853d9f9fc7491f8880b48ff3a2c11a067e7f5ca59f12fdfe65e05eba1009f99eef1b6426871261060415b1ea8654adec8bc8923cbe1e7045beac41c8114a4a174d6bab825e91c60e0263e04dd77aaf8cf7d1e03fb68c8f4b4cf1631863c7ac34bdc96ea2e39cc54f819a8dc123edf31ce16e51c43391ef8704c84c56acb0ea0a676fa57a93f2e97993211081c67380607f5d5f8f756e1f7490af2ddfe6109dbd7ecec9ec3f22755f1296f1cd22f624c3602910f6fce35671131f621369a64f2c2c70297394e8a176397ac1ae13fbbce8434b7848f07ecfee31917ebd0f2c5918638d91cd4851d14ec13ea5ffb5e70c9f17a2a24553ac8184f04692d99fa2792c5887bafcb847ac32222895d14346246894b4dce259071a83032de5175af79a95a015745c5fd9fdb3530ff3f7284d48559dd1d764a5d2b63d7eb751a09817d202b451a18f6c3480ebe4b77c2187a7a397dc9af06c8afe34288cd551b8a16cb41bcec5253935b48c838aec7c6b822eb2b28a839e7a2e9f0895b355da682cad3b3f863357255b54c70745b520650186eed349f10f82e115275512327d449ca7c620023b2b4d4fbc6323565219fa021da25bf1c88cbcc0dba4e359077aca919a0cc099fdeced8b8d197bcfb4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
