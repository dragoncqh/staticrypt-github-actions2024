<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"daf1fff98d71d436c6219a64921aa4eb5a4c70f2a0dc2a42eaf27e83e1b3b3e5dd28ca81642d741e98928a1e25a11152cbedc1038072b3187decec8a38b691168122d6accb30db870ced0da4553ca3b3e4f1222cd45c6e60ee3f346e8f06e525cc1cdf52290bd320919aa9136f17ae279791b41a738b7c5f7021daddc6270f9ef4007469227ea7b304145467b77dba0302ee4f19ee3b26102cf1bb6a5f77017768e17a2357f2d42c3ea2a6e887f09f67467052cdaabfb764279ad8646cb78b33a52857560feb274e2d669cd53ea0150062699a2569e87ccaf0b9fbe4a88476a9f35a74bfda8aaa817d755e0c0ced1d975e89964f98a916560295f0a735550e81711c557894a64cdc55be25213c1ff29767afcb11be57dd5ce7a5abc98a06698c52ac3ae65c5e3b576f99ae45dbce3d021a4f057cb480ea4ddd6e16064ea413991288a42418a40290474387584f0750c4c16ff06ddd871a75b1cb7ca7d9978775e2076b71018f33b6a9b345e90404f4a49a1b7224ef59d09148d1093ee1d4503bc578e43390d18ce61605af3185f843219a6a11c8a6c81cb357931877ae1e23d528c94a3ec8cdb23961cba6fde44110f878db604ca2d4844e9cc4e25d6c59c568366cc454f3df84cb64d4516b2e462e2d0839de80f3c4cb13ca0f9fc62382ca29dfcb3b466469fc44f563617909f82f7b294234041357d9b47281a147019265991cd76556cf05d0a87185cea5b2455dbbe20cae5e51ce73f9f618f8ffa756d4a49d677ec2047f5d45db39dbe5e98eef9a1c105b8546f5b40f7ca4d7735d20837e1cf3f3e2b8db10b3f266a0213726e29dcd5111f571282b659ab46f23259c49fd99aa2384435372ef6ed9696093ae6e3261c1c986afda87837bef6b27cdbb5d121f23617f0fbb8e6b8471ff074650c890f3c3830d391273dc63b24da3094783d0802b1a6a61273379e7eb538e9d0c2475383afa61bae40b86cd2ef02afe2358b9c4e372cc8a1a4c15635749096b8aa739e4ca9e34095e65cb430f6884696a54e0b0e9bb5e2780bfc30263450d2fa249ddf9214e161573da577add35b14de6866637aecba69b260573764934885abe05e5f6046584c73a1bd7dde225504cea740066eb3a76fbddc0328d11284ba47456e3b4ecc940b9b0b7d326c2e97f5ebc932136f841eb93e80f330f2e30c1ded5b296354d48a2461b83f425418ab5d61634cd61a392019ea912a3a831d61e6aa7b16c48860a45cc7b3290a886b935728f5f21aff5732deb951a6a82b8a294958c04644e3d387213b1bf70e07875952a04c7cae52591e6fa413c797d0aa31aafb81b7c83d3c2ed3eb8d1b7b361d101fd9e060f8317f65cfa91ffcbb2b00ec50f38a9c4f6184ac0951584669605b8f3a0d1a56e8093fe80ae8e2a4efc0fa5e5e9bb3c3e50485e0938a84dfbc6af415b1ae59e143196408e876df838336f59a093bf5883dbe0e0dc385f0ec56aa979b30b2e5113c62a0922ecaa2454bc52cf43e72f6eb31020dd93c3f7498b94613e18ca4d5fbcc95a9dbf353e2c916ea342bd06168570dabd701745d27de21d31422ae056d05643ed3a740c162bf0f4804428c4eea241b5e7a59f7ec3ec9b3531beb1f8ff2d94e9039b636b92fca79a6ff53e6c011113514f4a3eda71fec890e423b9cd94ee8cab30cd8263622dc66a0a306f08e19f4dad1d4a1b43f34c597420f5a23588bc76cd21b54c573f62a8bfa3cfbbdcd2cfd9cf5caeb9f76704f37b5462e86b7dc505f0ecdf02a15c84504445f4a93d30c13c235f9054ea2a153818bf711d668f763bc29b3d5007da3f849a2046cc8c838251cf167f0617415db4fbac5ac80f9ee14b0ccd6f04970c2123008b7b57258d3b3e31c9e2d1558cd4a023382e2be4d5b59cb9136c834594cb64753e5f3153169b1af1cccbee3c941d12296ed62eadff332551bd716d0188b843b869e77dee3567eed044b6712bef6f5d274c7a93b3394ab11706d4c09cdb9185ab489210013c02a8e5bcabf7edbb3e5b5b50a4e084f35031a473cafab6f50773c948729e167605ebbf3dfb5112447ae44264e1d555493d65fb08ec267322a67941f72624a79975c1c9e9c7b320f4ef44e34e56d29aed50b4eedda85e5581e6e2de8ba2510206028de0b0a64fc051c6f71f6dca56bc85d8b4460993201cc641dd98451d6c13b67f4170cff14d5f17397bb72495bbef5aac38c2bdbea0e5bef733c7d8cc6628cb918470f5a1b1d9b49f61703a0da3e0834957b433cba3973293c1119923404fb36b3d945db5d1a07cc615df849227ec9c8245ab974ec3b1c1a106fb4825fc466a81ea874ddc11a3514686f516f41149836a1a918fabd797d2751ed2d00d2481e794d2d7676d60578f30490b991fbd758549ffcf9372ce3bfd7a521752fdba3d53bcdb2b3e0297f865d719016f6380dd50f4506ba2acf51e76bd3ef108e1e55250b149c5e4c54d3b1e1ad8e0a0cfd830790cc7c36ac0189de9724a40b6ea19edd47342bce1dea61ee56286a13fadc7b88c7a3542faac108c41b7d4e63e923f62a4d6ac9c2069ae8671737c32735d683546f3fc953e185907e8b822cbfd5c19b534710d74ba7c092b44940914013e5c01209517523aaae3ffd4aac204799e77deeb6b13189d278e4ec73a4f8df25f73d513801bbc053d0df94088b2c2e400a4511e753915f0d655dab5845dde31a42eac2919970e7dcd71ebd4d10fdfca4192ae120402429d7cc5c4517f494318674b9ba6d3b0a17aa3b210b123d85b104e95830318de7f208115b0cea170db38b4c3396a2acf9529b6aa387e99ab58d60d74c0f046fbcc075e53c4c1cb14abd1f1212cbcdf077dcc7c74685a1771d652fdf6b657cae6e06ee4ece5953cec8657e9452c7a37511bc25e624425a401a1f34fbbee1f778dcccc64285af6bd98a769811a616f8e19bcb3b188401e08a84323fbfea75678c6c23ddef01d221564bdd1629f2de08fe8c1fa377438a75fcbf03e835d285ea56afae172abeaf34f6e01efbb45b38cb78f7c7f284d4aeb1285d9f744c439c05f8e1b595c6522a69a852ebeb24b0b4ad6cbdeb0b37936ac6326d0f5ddee036f6cffdd74ebeb6be36266decce70e22f844da278fef62552403b599db856c9a53a929b4dbf18a0ca10f3e69b951d5cfd7bd485ec82e8e80482e7221f7c72607507f95d1ebdf8bb9b7bf8c246a7258a33b7b45905ba04646adf39feeea2f10f91c7214ac7ad3af8344930f4749996c2b5eff54a911990d3bd0c78ca0c183ea357c622c0026b315d956a51979bc8d166de2f2dae0cd60e4480e7b0fa3e5d9f5fc0b9f1c5f81bd6d44a55cb06062e7b74c48c67d54c023b9c1480df09db4d3f50e28d019e574a7cc8b1d08e517053c3c3c44d52ab831710328c81c1a596c033813716c85185dda4b5a0d38b2fe404ed37241679c5a88dbf00cf1d466474ebceb8b058924d18bf3e77e105a59e41bcf490c975a2a68e52b5f3f701ba0325a6aa768a5fe4ea89ff07c0e42bc506aa1290a7d05a36303b0d5cca76b4a529fd24a3c515eee1f2098323ab2b2e4a33e35cf2805afe1037aea70d4c44b20da949f2f3927057cd8a9548441eadaa386730d952df7b654fde34f3d894712270156a3de7ed801f89b396e77ff63151606a62260a96db281e78a72194d1fd2b197d70b5bdbb54c146d3e9da0ab4420cc2fa2a7a598ae85e5756af54ce867ef5e0759cad9899406d7c3d819b975af2513a6e97ee5515f23ee37792d08d5998ae43bb14b445ee14a3b550e040a3c4f63b3a774fed82121cf083461e8f0e02b90e32d22699b4cdec511b373582a81ec2e058964acb72aa812fc46b8d32776af22f1df90b30dc72e88d0730eff20b4b88e1396471b0718369166ce160f20832c6c5c466e9f575bb17d1658f3853785c4a08a9a63a8455564cc4e93dfa0402699edbfd478b8affe8008e7b782c17191ef16ac7073da91ba3b894638c1671fb17c7eb677d5572c6bf49bb61611d0dd8c94dfd4481aa1863d118f078a05905e3bf548b024ee76e0036d04c668bb9ea74b2c2257710b9662a804bdb89bcefebce60729a06d92c22457c7ca170db126c8828e12bf051e5e472b013a5f16fa35483c63c7850fa6878e22f7c3ea1534148c7f378bfde69595f28e95d6e52d41be7d252e2522ec0672012dcf90a1979e8faf691e0ba323efbffd02f4d156b1d6405953e62ed649447474df76cbd1170e68295364b7f89ddf455ac9dea399ffbc983ca09054d23304d243422d11262d52c8aa92ff152b19568896328338f271e12dda4ae1dd3eed1b6e1254e6e1127beada2817071fcfdd3c23ea2ddc64f8506816cbcbb24503214fccbffd3daffce3239c3207fba3cfb9bc0c679b6cbbd0e2185a4c2bad4f931a33b81f181c2f013b2aafa45884b75da3273e1075a6a09d19c005924da408ced6f2118f61265fd4e51224d1396961b0fd7625bd414ffc94a0e9f9d5883d771bc4d14e432433a8fb4be905d821e19a1f8f086c50ac809b924c745c166bb7c59d81eaa6edabe71a76353b3a5987b56aec553526ec8060c50a3805a4e441e19f74c0071c791558b11249f540051c9b65e791aa52b574108f531fff6ffff9a4f03f158e0fab124ebdad9f1e5b1842774c60286b98e3c78414cd4dc0fe04de648b2a1d03dec646bdb8359449fb1f4dcd3121a0b9a94bd89ab330efefb0991cdf6eaf2b16c0b8b1838d3ee41a7357f250a10490547daccf664190365eb1bdd6681df94ae560a39c74daf0b0239c25239c7cb8d4f8a41e2528685145a9dc75df50bfa58a755d4585ba67b0d03135b7bc039f0cdb0a69ca21e7e52c623a316bdcdcb9a138c72ce1f547f145fbb451a26cca493e21414f2a1697717b791eed2621a5fcedabf7055582d3f77e09e89ed6760451225463416ff330294155f8f88fa3c69ab9c66e266f2c60592bd4d326d7fc67b63897a8ca7a0a5059cf994f2f44eda262211d5499d39606f74e781f2afb22ea3c073a45bd41e57cb226b23476737a6523f1dfbd9882b190129674ba08428bca0d4f385b05291d91ba274199fe5278f15bb8300eca2fc4cc1298dd9306033967e91689946911b71e7cd6422e3d3c09bc398108429164c3da7b3b7680c519911e54d332d8130dfff1b2825faaa1bf2228a98493a86bd6e6838113293e9d8a351ac6e53acfc4e570374ca4015a43098fa495105e73accb54c0ac9219b3ecf426a16e16b6fe3c07ca0069ee390c212f27c9c4fcf5dd3935789107aae14112d0231e22d5ec7132a66bdbe8d0a8799a2fbac6eef709bbb0c55f5eb49fdd1153605952621247fc9c7e0921ab2dceadc86fc169efc055211804ef981e09bd7da60001b5bf98ab4a25cdaf8a8883e549ecb9603f44387f156cde819d1123f3c9caaa175c6fce7297a41430d2580828d271fa1e8aecf0ae66e1b85ff4be8ae39fa6c7093bc166125585f33b6d4c172949e564443cf180dbacea97df33230c79f6c8b06ac31a9b1dd928975613501c1ad69c83dd109c2168c03dbc1e8ab9109ac5a5750683f70179d53f68cb406e4c8e8da88f329651978b58c4832ffdfbf64dc40f1641b6296366a91cafb39cc1fd1257241db35e9c279a9c46c148ceec8f4b7ae8f8cb1b3d060e19f6869fd51e3e8c5a55d5f47406fd72656ed4da8fcf5b3b50c6f1196c5e2870ae460e3cc2bde51e42bcd8908423ac5409165d98d950f2412b481c348a7387fcb3bff125b581cc93a4c63ba644eb788c2165534a7f4379b4bd44008f83908739b01cd184d66a29c393f9260d1c5eeedef11ea4fccdf78e8593a67434de497578cbd076acb4e8f876297f04e2347ef70c0fde4726d939a37555b24c980659105a4f468051274087505a58df8202f0606ea311d268aae428e4e745c66647026460adaa5b129fcb660da8c020357e9f5cbf06b2bb5e4a7c646f6cbdd03f0717581baca1b6ea181b77174f3f2836520041da6c7ccb0e49ecf3a11928a74d1256226b557650564b9cae6101c501171728baf59b0c269e7a85e4ee44774259b405104fc7c348079cf5564d1e1257b952643b73977f6b60c879115b044bf2f79595eb0163a4da2f55a8bbedc7bb3feafb958bc926623b84b222597d204065408dd5356c1207c2a45654da7b6026494f9e071ab97f880877ef94dfde896ad0eac6dec4af2d5dc418777759300b054d1d35a0f5968fa02fea4603c6bc93d235de2fabcfdc103b6f5327e4993d5abbb168340d1aa92e439328e9a3868e82454fd31d746f7f7433a6d20aa40cb5c0576b438185b4403bc7c3fc0b9a3d39940e301b81cd0b8d6b82da37636b3b8220a788dcfbb63b5a120eae8b67ba62fe711a97adfa56ae75aef7bf41959c848add58d0a032543fe1833137f226c20152324e7d4ac7e4bb9eb6b0d40fe3af09ed443ab8d7f5db994319bc5d5a458da5feda7c9c015224e7221c634478cb5fbf8832c598aad46b9f35149b3fab82bdb0063ed5340a2150414fc1234f63b81914502d6c24f82cd687ae9aeb7297dac9686944be077752886f57c3623b6cccf0a67e83efcb6628c790a4783030c5010e55694e7b58c9ef0662c7deec655eff4ca398c77183cb0dd21a4ea46218abe67216f6934b2a03ae70d64f155d7de4809c4037a49b078bd8431cc2dfb2762e52b47c60bf45f9d8bb1c678dbb4167dbd851f8bd09142c663c03b6a1752981968a8f87ce7beb71e2708995845eb307e5025dc1fdfdfaae025d8ea487b3d8cc3246a81adb4e1982a5a8ab66a7ce39794aa724f3f2800a318b6f5a8890aa4b2de9f4904ea988ce17ba5549e103d01e47fb537c5968aa455d68f8c8669e43d67ccbcd45c2991b2542386d2b9548a9baf9758e4c3d10bc4a8e2b2c5ff48de2ea0b08aa281a3b359d475adf71e8be68c8a059f47dc47910d7341b7cf1b1f1cd56d86c314bd5e30670c29b53a154472fb2f2465276ff97a90d72e0629d0bb1f1d3ed496667ebd9267a3e2f0745845172891e623c29250c6c04c64c524feb28f70c56793210202d3744fe4b185d238328b88fb5ac4c18505ae4f00c29866f95b2455cf2021ee174a92e1325c30d8be39eda49a4f52a08fff291660055c14da29436a83724987fbbacb0d3a2a184361b254d6cc8c9f6f947be8797711bf18c4f3411d22c68701f61c882e8027b5d17366e0122165b8d1e48d93e72cf7b784808e0ba5de2a8db24f27e817e07179d0c732a396a17f43ce28b80ed71bd5aa5b06c8724ddd7f439ec635441cde49860b9299e751918ffcf3fc622a30cfacf020829833f6b9cbdb0a063b01c335b1c7bc41cc9ad082e95d9569e4a93c7a9b058eb0dd6986dacbef05a78d9b165796852c9c6de081d3063d281266c8a8ac7c947f9581dc8a753aca7fefadbbd2c0b55e19d0cdf52c8387462ab9a6bc73bd3e0b994e1113d1ad81c6f27aa8cb23374d1c7a193123823160f4ecde15cc16ba9f2b176adea1b7c62e2ee8b22597df97013c976feabf3e647d346612adf7ba4e9df29b18c87a80971f2247a473f5e088e4ebb195e0e99d2af98a113292fcbe9e8448547abf1ddd00cd803355f9fefbe56deee4ca821bd96d26e36f3324bb20604dfbfc6ca75de58ef10229568ceb9d299a4421d60841ca37e7977fe18fa89f60a379a36736bb3821d7f04c18a4af09faf3620168cb071d357ba2a3697d22ca4e18b673f6e2bda8058f58bc9f1b7ba9801e7590ad3bb968c138c95bc529bbe20f2dcd8ac781dc84e3e67270bb95932ab9c111eff31dfa557f4b35570f44a530fca5f2be14419c80be42d796a72b4b31998ffb1d1c069a7478e66fdce1145664d384595a6e6ed702861275012f5944d4305cf948130e6d1ab3a9830ff44a0333b5a5b287ee7e4c31ff34f3d81fc81c00f68a3fb82791e07610d6588fe4e3eff77e127518f53aced2f8b339aee867e31a340ee6f4442560a2cc49b52f4c4074577dad32f0313345046861a169ab0484978bd9ab8c9245fb6f4d50aa3c3cb76e5f027709f3ff7e79f769641fcf91dab3a62c71de351444e553aaa563c3864ad8ef6337880f788f55dbcf5507644ef04fc4a5f295041133adb17ae76e8d4516f062ca640342c7c09239b68476b9ade13730855b208e4e127e4d73ddef51f8cc85429b6208d4185d5d7cbfbd8025b8ae8bd9fd48869c5b2c17f6ebf546ae497fb57d72de76f119463b09387e10cdbff3cfe1eb47136d24a2b3320f973144b42c25084872b49a738b767a39658be1edc0f06b0ff4c5c8d0766d43033d731b356fa4432abf56f1e9d720022d056c37ceda60cc8611df2401cbf681898e3a7919e82b060f42eb286a82fbb9d24d48cb45e914d581bfe50dbf687b50cac8cf3561267ee3b95405b35daef97c227f30736d28a678e5989d282f0c2f3348c01da7bf1b8ce31a90c071b75e98eb525eec1413f127f2b36443d626ef727912d394d26592b7cce673dde5490399dc0de9269e51f744929f8ef11479c8e34660172d26580e3f6f82362b82123c3ba2e0d49e1781ef9d7acd2814c2ec3da8d981957376d62ded8057f5385d31818014b15c16d494de02a4533afa95dd202f8f2cc690125a578d735084e807e89791a5ebf6ae934fe8967aba0315a5e28f419015b722160df5d39f1fb41a201cc9cf81062a346813184523a1ed35c5843fd18e9668dade27b3da27b331d481f470424b6af82f5295672142ed1b6956fa4683b34e886e4097ef8ba7768b9d23418b4361d2f89fb116d2a77bc69577d6f3e75b3753f68d22d5bcd0827af3f40594c2c3fd2d0ecb5ac7b754d3082e6d348a46921bb1763a72e8aa748e6f223fa3f66bae43f15884ebad6229897e543203aa1f98082ac07ed07925ebe89f1edb303e4b504105f3d9ade12791b71793f4f3110d93ad3c1460c9926a48214bc0ec8b20edfbe155991c58faa477f23a192e11fcea20d341e18e8f6ed79f677cf3912459c1734360030f554bcee7673a1214712bbfed1c604da58d65e98c0498dcf7f1674193507fd3cbf07e06ddebc0ef3b54773996b54351e44f56d94c5520a06ffe56355039d026fa18819f67e572dc7fced362bd49c81e9b5130f9ad0a4cef35b49c3491f24517a48c1ed5f7c19780acac847cb373d933d335a607e52e2266675bc86dec4c3db90ad4f9eb2ba33967e2f0a50c00f85635d2b207b29f7a23d99d3c11472f76153b565c462670edfe7513012508444a476a6c001899c83ce3e88c03518217c383e30da01f9c89c9ccaf360fed221334a82f9a446843fd5b72174a0b550e50829d655516f6c68f54b73cdc654da10a383694b69c473bde515f2062fee1db5d54832974e9efaf902e1cc835a96722ab2bdf1e26b196155482447aaa92d3465a17eef20f430e0ada40d126747c9340ef93d8a0708b137e85e7fc8a37996cf26194d5d5cc3f5f98c87bee3b6035cc5b923a2b22e80c28546cc9f8d157e9736a8c671a99abd199996675092d57e5ab3c1b17f117bf4fb2ad1ffb577992e5a78a6b1d69422738aacd9d52dbc415ec326c75315de9e8a4437c28073b025b9df15d0f6227b1d8a5ab84753d4c56ec1542c1a72561a6c39305c82c0db8aca01c3dc4eda87b10f3a53e315ce63d0669a4e4e06dead9a457ea3e6d0777c9c00f75a2438667d9dfdbe797aa0e86520d90988f5920e7716cb1c6152c36acf24583393052d872203e174d0ed8dd805db00ddd663e04cbe82fc32f841f69711c11d5f4c42194a92e868ec70cdc90e90b77b304db6a94aa655f8a24c9ace33fbe7c6539ba5a8618ed04b581ec672e4089c9d4c58664c3e7bd73f11100ee9df5794b836e50adc96a1d10d61bd884ebe95f2ba2662fdaf6a1c073534ea41fc33541a33d603d5de9d17eb0948376e2da60938c9975f3fd41a523c34d6e2af677781d7dcec73d34d10fbe655efae4ca21d7bac28fc74bd9afcc04e5e2d7f54daf74f22c301cbb6716747349b9257e936819c64677fcb8c432cfa5f73dd482fd00f6090450a8f07099fc94742cd1c16797b4223058aefe049171c1d87b382037d924b9854061796b45ce0e616a46b0384068e2e4b7db418d47a7bda256497950b3619d2c8786e689f178edb60bd30eacf5a44ca400763651752a1495e6714132246aa7918175ebad12c9a9e79a391841432dbbb630c45aa3b228e5231176499c4cea1ad928fdcc65b5d49ba604b1960b273a81f9722d03f1099069cf4753c89304eef88a617f8826e46456dbd59d0438b9253eb33e2aefbc466c8ef8489369792085c75d2b26119fa8ab32b1f4ffb7104ff2db3e65c633cd9c9f55f3c66ba702bf426138ae0cfb3dd37340c5bdd09c21f5eda540435206c7f23ec06ebfb01b7da79f4ded8abc980c46e86b78b90f5ad172a5d1eac98d35c901045f607c5d6f41443b514bf1319adfbf56a9aa1ece5b9330dc4447850f003eda2702383e8bba207bda18bb7f31061fbf73b4611c1aa6ef54ad307e032035da54f02e21baa901232d75c5230adf73abc25a2fd7f8e5ab07fb8b5269361dc812c11f7b764b46e2d6353edfcd102532540bbf10e2420d7fe9f8d34ab9b0f970452142ce7a61affad3d19ed4d17d436a5f0fd9801d2eede2e060751c78ab78391ee965d53314a5b1b076d91a7268481c7982856610099944a62abc44c74219d93e7e0eeb7ca603c27b72cbd98b08d921e780df70ab4ce9d7652f5e86d4b4efc44d32f5db234bfb65d8b738e6955189f9548ceb8d028c4f12eab8f7e2b94f757c8ab70bcf0b97810258ad83b6ee92931a20db9cd55b3d47ed7d77385d67620241d7b10f6057b5b30a7a17abbd258f56bbfabb721f116b83e3bdede55f683ac98406b23bee5ea9975492ee3cd2d858cbef61c2d49fec2eee0910156bdabf30a7454ac8d9c24602022fa26a923d0f81caac555a1cbcb39606dbf0a4cf58e7d6896551841bd3b7cbabbbe877f2d48bd990d658c3e76005d2c15af6125260d95682362f18eea20446e26ebfde462f45b736e447ee75c956ad153aa3a9494bd5d75ee1b2d7e31928886d995d819015fd9598b41b0bc349c292a95b2d04f9ec0e477f114399e8bc6d8e2f25a5585741eef556105e8fdf9015d95243fad666337df090435187f2503b0f5aed97ba0de708a763efdad621cfb28a0a6c8ff9bef4c4ddbdebdfd226778fbe31c52e3f68d0b6b6afa59c3df857db0416e46395cf2b3a22d29184946015d824d5b5686eca584e0a9a84d81f7932c78f373fc70286f1c06ad4e3877c6da9b258c9f54151624988630a980312d374cdfced51484504059299ddb330e1c046ee088d74866f443b33838d7c3ad6700688380d0a8b6ff27c5fbf593c3f4c968596f86ff6bc5db6df82211b4935e1875e0c4b660e92ab22f0b0b930242822f8a34561d3d2fff4d45f3ebee4c763b3b463b507053fe081c99b5df103386bf01828197779e650ab463168ee616e5da4189291ba8a7349d5a9734830248fefff7f4ed6fa6ce203609930d862d4858d85f25fa6b054e49659b50b29232c1c772ea20d4c9ab6159a589c2a1ad331d3a349cae9f2ff5aa4bc046c82e4e2f71d1deb3360e97feaf960877c9f32bccf01f19604fca2699d04cdd1e27c16fa9807c9053c71a1c2a36f9b1d1e4555f6f2cc51e08255b66651026aa5e6207c8e0b2aeafc446bd8b4890c1d10f0a9f141069f6a9b3c73a2ac6244cf0b1ac1025f9cb0b018324dafc1325f2ac2a71cd25010ff9704daae49e2ff4b49a423aaa419c60631769cb80199a3bfb2d08260f7ff835152552b9602437a6f50e928e7cce1ba72d2c4fb0c0281f7f281a01483b8d92e663d389bc0e8e02d067c82066b9704f782746ccd0c6a577d6db846b47cc10ae80c9e3488a53297391b93a24dcb11d23324d482cf580ef1115384f0416c4879efee6bdf7b70de71bd735f6c7ebd0d69f7fc631441c12ab1d310a2596786d9d18ae9a8d7717702f0a4a53569e36c80a81e910c87a33a44a9477c56c395514b900e80266785c6f048e2732441a0ff17b952c33c231a81fd1d71fd21f0793f685e5e7bf68f4439bbaff8b00aef7a9c6dddbb703248bb14e8f4f8ac4faa140435b9540a26b9f8563a72b506d05d81cfbe6f64cba8e9fe327810eaeb9da1a477f8af4dbbd13656139df28cf3936bffa51e384db05243d2422f4cb9ab6a9bcf7072d3f719974893338f878871933cdfbbcd46a90b30a502e4b35c4ab8280585d8c031f8bec529d38e64b32cc2a5f427dbaba4ce139aa59f4bb6d38b9118c345b6cdb0132c74200d29ed77555db833a3d65c7f1a6ce4112e0d95d29b115a3e7747ea7075ebc51ecf8e2208bdefa74cbec5ffd5804c7268c7d61f8e483ad8e8a0e2c0ade2e9dcfcc2ea722a278096d7b00cd4417c5dbef49197c554c12e7e6ff2e28f7e8af711469532d30b43a939a09f5a8d625742ee5cd33d86ac0a254e47acde58d302c481174a53a3addc8d02f7693f26eca4d8b1220c72e652a5a317c88d7d1e21683ccedd7c60b9a3fbfd498dbab84bbe7d2facb615a2f7cbb9e0ea7fab2587e9c28d08504d2e6d8593fd1c598fdd8c7eab6b90adbb72bf8a791545d314736666ca4c970f9bcd5591deef1c14e1ab0e82c7d691906a312a3fb57b1ed53aadd22908a8204942dc4c6f5bbb19cbac340cab290f777d436e2c79d0ec2b9e54ac291f03810fee20fc71bba4292ddb2d292a11aa8de6af0d70ff7a2a8f34688d82a1c354db2f1367a550b9312864b5d564a3b7229d57427ce77d78ab10cf61e3e214f92cd41459ae63c2f61e12b942a7f3684945a4f99313d26ee015a91555997e647bf7e9e2fb4dfa2770be58325c53e07efadce972e492ac542d2f675e33e81f866979c498cc3d1876f3d06a2fb860ab61428597f1354b5bfe25bb8a72422b2b594a3afad9739e6ecb21261dce8cc82a2356199b1ad3bc08f83e31684b3333de36524a0651871cb103387436f6442a0dd0d03698e0698c6de31409708e1fe5936f3b42047e860fea1708b354175dd0f0cda67940c2084544a9e734dbae2023e8dc6382bb454d4f40df2fb3ac7158b96dd1afd6210b59bb80b925b3a20962aae1bbb69b889b75c346cdc8d102c1cffbfc20686453ed6a4e7bd517fdf3a23919e1c9dfbdfaefcbfabde653b28839435a06eb2f4e274a9bf9752d3dc5808fffd8149d6dbedbfca0b67157d826fa8a91b144eb3af60bc8ae3f907b239cac4549467d6fc9c851857c0680e721311235336e9d9153bd30e85b981e2083be214eb326a4f2b7cbf98da3c2ee79ce36ccba3a5e006cc0435bc7963254c10d37f3200f6d8c0be0a2c18a5898498ecb16ccdf6b52a9f3a83d81de45519fb8e0eba87721b391a245adff5abd91c72c02bf42c4e22d3856debf31cd77f5c64baa84c821ddd48d6daceb7434344f5c1b6a66740d1f7cf9c9d7b7a2eb0741c9db6ab9e3a417815a314fe1c280aa114d993e2d206b321c163cbdce5e7e54eb3ff12714df938dcf5f648f5d6900a5267f367c544e3a642c7901eb69b7ded5df58e66ea2a9af757abdc147ea26efd66082bffc0f9d7413d101fc36b28ede51e8156fb162033101cac7753a977629874fef50bac2a683e543bfa7d1aa9a246e1d475f2548e6129e4be88b01e18a71993062783f39ebadee503947159c89c8420a8b67834c7bdb7ad9b855b61530877c680cb32b1e896a0c9dbc501b94ed905995be98b3b7c5e381c8a9cc4ec247a588996398da89e2d28ad1c6e743443f4054e9045c92b507408fca7b7bf52cb3e6c6505eea2313cd311ece5ad47a9e29ab9fc8f6ef167c7cebf722be4773c5f2d0bb6c64c2e9e921bd13358900198ee7bec29291139a751a10fa90074e2421bc6d331e2e86e591989c93570bb3fffbc9afa2ecc8a1e230997e65e9e01dabb66adbba22974b3fe45e76451257268fbda9700cff71911be81ae678a11985d97b959743828e831522c672051240ff4781d5c1fb51d0f07ade69ef1257847cce1730a04d8e22b37cc9dd64e4e7bd777f2370deaab72cac1638b5988207475ebd86583843fa21e879918b228a163f557e153419de53efc886ac985ac909f0a5fcb7c251312e8ce2ad0da5930859997483f926dfed3fd69c312f8da8a4df781600654b2987418fccc87b4822f8c34141cba3ddaad5ea2c0f2971a21d0a0a1f7236e6a356fd3b6399e6b031ecd3717bd6524ea7f4dfd349d4b748dbfb232c00553f8e8824baa148e2d08ea9f7277ff38e3f70677bcaa79f41587881c6e3fafd910dd0985aab97504921e3b9245548b62890a6a649fd30fbad178e2e532dbb2c6d18cec4c13154bf18389c5cf75201fc19351235e21f79cbe074ff72046335ff761619b18390382a7100ca732fb5d9374ea938c3fe61e8eadb6d235760e829e7d9aa59d8a77c088812e6222aec10a0f313599aca0582216b411e97841cb9a3eb66bfe2a351c62d6cfae38efb54ff4aefedf795b508cea3b332069634933f14acfa5a92da982a3e8d72eaf2a47c4244bb6d3d4d61fb84e1c38a2fad3c907adb6b07751417296df24933270f823b35c6b976e872278b9b485c3c3e2c30531b3feb31cccfb93b6a0fc1f2099f9b8ad0968b6f4eec9047835509686a0901f0341c429b450e429a3cad4334386db3ccebb61a5319bf1b80f560ac63df2c85f584347b6a01eb66430f9f1e04a2779f2268c39fcdbd77d66b65ec77cb24d4f9bff3857788ef9d8efe206dfe9f65cef1159f143b55583c4ea5182415568b590a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
