<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df42d6750e0e8d971688ff3000ba0b4fb456a0e180acac35c8b3c9de399d9a55153ac5c699feacc98cd66d544d0f6dd2531903e993b69dee3e21a8b008b912ac7aa33bbf1161acfea299816bc2e1a574913656936e058c661a1483809d20ed06b9b535f6379a74d2c727ec44f0ddd4866212e08b206cec60962f99f35aba725a7ca8d788b0ef6ba6c644c87e85a437059eb1400511fbd3b54ba95655a407c448243ef0b19da994e1c7abc0e3e84f007f0dfc8bd8f2642c1f34f29b4d64c44453704754a80aeb34dc19516c830e1be77d352877c15addfd1f20dddce98f0bfbc05ca4b192253177a78544aa457f94d25fcb99ec38aa150a1ac48fe10d78d63246fbafa14f5ddfa2128da6523ef1303b2ec357c42526494147e6e705e7f0a03a710c7e318b7d5db090e017b5a25a4b6a7494320b034446c6f33dd651187840c3252760a812e76afe15fe2651b6ebc63cdcee59349452c75d4a3a83921580c4a65537be765d792f3d0ac79bf4bfb55f5d5f234b4510ecfcaa1ce750d930009bafa2d4cbee6e1d2c582828be2f127af7a5e37070c7cb2c92dc45d3cac02b07d92cc71a0d2c0cad29ea4b1bf126eda437e81f4e661aeda2dd0877761ff3c13260350f0739d7dc0291b19a7a33b7fe669741e60bfe2318ab9a8efe7503830d0e303ef5d8ed80bd9195ff84157d7e63f85324bbfbba96524dde9800571301f6f234646bd827b10b08f77a95841b38929cfe234653b47877e72e7bc2fa489bb1f21cb89e3357d4cd8ae2aa57a37cb9c9f82376959ebb54e813afa3841e819aa41ae5f81ee4fe6629e22a2b3e935ea74f3e417bfa81f8d86ef9e7426a1bbf96231a2437ffd61499cacc6d1bf3db28f872202301ea4693d3396a4ad532450e3adb01df616e6ec07b604c202ec36833bacae9f9e4293adc8a0ef5611ab2d12be4fd296effe02d13e68d939265a697854d5897f817f0037a8f83f57d673aca16c6230e97e94ffbd8af658c6d0fd755393c1526a114d5ed60547c38a1be00dea60f546899fd98af2d7941f02cf6731d3014afa6e620af5377bc2516e7f42a9d71fbf00f42a23830168d1483c3e3d355aebbff4c92a1e2a586b51728c7da2c18323288249c5596e969d7d955409d96f663ca243d20de88ede71fd9eb9f357f5a1b4b2bb183d48aa9e03e717acf90f48ad6201e9772d382803b4a988513db6c1f9a7a18e35ed101cbc53e52828bdeab3cf0485518c976b7aeb2d0153959722d7955225add7ff5f39b329521f19bede34b02febd262224d58fd27342446e59236b3dd7db4575c347aa6799d24c2dd2a1c44baf89443ceebe007d662c8aea3057c865e68b8c3621db93f3ab820a9af3c6213bc80140f8ab487f55b97d4742e2a91a78a2ed8d6795795d1ce5814387f80b861d005001316c0914451da030ca0cd92e44aeb426389305078f38f1516610f868d4517f706c94dc3252d8b1feb5521ca114040b59d1837ae0c4c724f3929c444e7dae332ac3e43cbf1813af2e5320a2aeb1946a5382251486506681df029972624e24fe71f5cc69d18b83c68983c23dae89391bfc2d4fcb8fbdd22335a70968102ea72c14132a64610d9c32b6ad1847109037060db777ae648ebff3dcc250aa4d622eda4a39224d6d9f23544bd8b712e2a274280a49984b10969b03b854e03179c8de39192e6409a8fec4005035daf741b677f573f51dce79d9fa4e608f5ffc5e6ba6ab0b4ee1eaaf3373fc3904240281f77eb0fd248c231756d50409d429a9be5a381cff88424becc4f491a6cf6248f501152df05a18f10195d8ea5173dfbb39cee817d9ae1f89925d64d311243df845c25bcdfeb216b6e20910e2f5b184f70fae0b1501c0fca50aabeabbd57487144b2e37ed365dab4c01da8ce26bca3080c87d7fb900c17abd83c41bc7038820e73928bdaeb537a5ebcf77bb82e1161547880fa5e2481dda501e0feef8a70d6c8df1e3f30a438caf815088bc97a73e1ba648f8a3a418b282c6b52b0abf20a632df957e3641db46d2c42211b04862e5986144a4cf2d69c8371139950752c55b7173c19f1de372d55ef2ef7ad2d27bfc56edb9dd9cf83cecfb9b9e23da9cc3a48a95f7ecbd78575cb2eee086afe0ea3cee0f01bcdba9afc7840a5cd14625b603f19ccb2d6e4b31497a0ab7454f36a995925d111b649692ae6097ab2b59b74f0466435c32928d15669e4b5f414edd1d2ea27b3518b425fef5c93aaa4e07bbce4c8f1ea2c2f7bf3f79ee403be1ce2bf5a2daa9f60d0b5098ee463f6ef3b8cc3c95b1a5701529c939547e6248341763349f3d017786304c204877d90bacd8e753f1189feaedf88fdd1eaa6b589b831b36685bd2c53a667e7d4e0b599fb3f6896755c1f72cc1cac3ac960a1f2b0933f40be3855487c9c2ce893c97dba828c341e9b08c1e5ec56a3cbdf674f0fd10ae88c5408a7a0728d60ef3f66ec14aa5b92c445d27dacd55bc5733c3de2f69e2e46373005b84957bf8b0ecadea75a03d5ba3c770f6c67875233278a691c38cd3cd2493f5771a0dd08aca25cc4baaed65efcfab7b79b8b7b8f3f9d39e5c546c9ad8c938f4780d7bb4954e086a987b0e1a8dacf59e44340d8bd8eb9ed2e91ac8de8624c5fb8bb08bc2443ac9e677ea72adc246a4c1b6255a4f208cbe456580a5c2da94815e57ee974476afd126276b2726f49a7acff2bfa74568205bf34d16e81bb285ef84ff1b1267add9d47a444f9d6572a53813349fc75df185cc622a5c761de1bee13041f20f0d3ccbb6b0174f1848b70aa4b6f3b1e96f1fa2e4fa7c40dfa17c4bb9038bd876a254564e75289312c9b6a85eee457262cbb8a48301689d3ee79dc3775e1d59b78fe5db249448d0240a0c23a143b6a204e8f5cd9c9dae484d5a9df084b57d7cca47ec2d12bafeabd6fd25a0a87d862775b44a9c5ec517dca79f00961bdaebca1463afa745f2cafca010299588da36785a92b31a3d7a96d2a583f63d44aaf56fcd9d388981702663ab6990c09c0022f8abf7257534453f97a53395156cb96244fcb2972afda270953726f860a0c6bfa1b5bf24c443a0f5d49ebdd978b2f43864af22d0d2b6cb0ed9f60fa7bb75a5c821b103f832e4aea34a8de380a1de25107a8930bdcdcc9f9fc04a7c317e32849812b057cc84e25d9af33043642dc303542e7e5e747ad2b7d11eeb90ee8a80d5e20da7396b8e277fddef29a7b689a87da549b6a323476be39d57edce754573a5d01e15b0e0bd8a8bea0de1ff2693ca419291a7870cbf1f10c04927a5668e0908cd129e450645f1fcfe28a4456e66cc466b3f522d996ae4d0b51bab86850a7bc21b205556f088852f4e9bc12cfa3f1a297f1ea401e70e391b50f7ffbf1f4f5fe1e45fc27383036ef8e9a20dcffa88a4c23e9e329ea2c7a9c58a227bb22169538419d660cda2b958b49b9a9e3d11810110c3238b8c2d6c54a11b61eb5674be831ef783b02da9abf03cba7c081a98ed788923df396d830300436556230a425e94979ef5768cc071c5d1b595e4f4b7729e1a8909fcaede5b769bc39cb5b54c24f526aeac315c7e68387343719ca47e8200f98092a5f45790ee6ee1d1db21204dc5cf625086b2c93f3a313b5c10401fadec6279fa1b595000bf84feb687534bcb845101e6e1d97b91d9e7f9cc75e0ca6191a426ad5f3d1f7112359c8c65b54a09a550ea18adb64f84d43f34c6d356a624fa110ee9221361325b75db19f782f226405fd649a713a32c0683c9747ddae86af6828495234d05e0a2f931eda7c71f8f4621a46c6a07e1f04c601556f67157a90f2758fd0ce2176f7518778f8aecf5b2bc8cfad437f407aac3be455f74242536e888db5521a66267de0c8dbbf0ca9c2c11f7ae2865902af4dde501d3961a885d621970622016eea5a92bd69d5b4dff9ea0740c84934783de81f711bfbe15ea81a3fcb93f2cd377ff7055246bff4b5924eba6dba196772f0b62b08819d4f30149fdd9e84f0a2ec5f8942b2686ae045f4a868441f0817a3c0bbcaebcd784b6ae91f1d8aeff7e36ab6c945e450ec16f790a3e7b3cc54fd62e4cb02d94a1e290f88f687b58d7dcc377192eac4532ec3c6264f45bd9cd0740f7f0d9557f85292f649c39e92bfe2df7b7f22d29ccfe82ad1ff6a0ac624bbaaeeb7899d9a1e2d1db52947d97c9f35c3b52a5ac89d9c268f758351719885a830a2824f0b4becc6c12b0a3945d4dcba6d514e1d1a32c94c8b960c72f91061a720a28079acd724671d2c7fa34ed3c40cca94f454bab65e36564efb86e2cdf3302dc504444978f0b96dafd17a0925de7f4d352b67ff2c10507a72f96fa53dd425053e8bf2ebec7059330303469059c29dc509153112040add9340707bab03fbbddd6f45d1f3058e3adc263c775bb536259ae7e699811b6d131eff74eda4566b4ea88b12a60995f9cdb304c09de431f652b9f54bb08883a946de503fcc745367dddac1022ddfd61842c588b6d5c8ba9b913397c6104ff7ed3eb6a26d1eb7aa9274e1aa1efbd22091ed0070f4ef0b9ffc6cf8422f6e35a9704c0233212bb4b9623081e10be92a0e85949a636389ecc171e2f558b60b4f8fdb6132b0a62cbcbb3ae4a935ebb29470b00ecaa9866b018b2218c65a2b2d6fa302bd73103cc60df26a27b55af243fca0e1f995e3ccd14eb21b4d5a6eaae7a42ac3c6e6203895588aa0f41e03acf18f5eaf77b2032fd6285f6b52fdb157e77278628ab92349b0fbc4e0b4d75f018cf2489f4b2b02a815971bd2d06cf725ed51f2b8ae06929b75a51b986060ebcc8a00265bbb86c26aed012f027625568bb7ee3c6f9398a3ee7f475c9fce3fde13606f66f3ecdd8a6abc3505212cbeb3229678daf75b20dea57b853bb424598a455d06cab5eadfe950823bee98aa37dcd647194108a58560829b37a5650f0f0b9a32134d03e8919bb9e1514e8b0561f8a912896278e57c6ee3502b39311a48cb5d520aed7f5ae427c76ec361405e885de6e19c9dcd818c5665c8a59bcc710f6fc2254993f29801a496efd4092453edfe27d35b8cd2d810212e6c3ff1d8be95cb01ddea33e776d9a874e069ec19c07c9362af1978bb4354203910d7b83e14b580b199d084459b51cc174231921e14a4fffbfc0ed4d176d41d1aa0bc923f6fa67776b9ebf1f8e835d6688ec81e904d4c21465c5eecb59fe5d20cd29a69a7d54781472c12efd506a0455150ace15e5092b1d2647a3e993c3f3278bbde5f826b028068e6e0a6030d4917a64d3cabb82b3011a3614dbf0202cc7981ce8fe197d5aadbb04c295781e44ceef0a457bc84c0d9cc009119335da7897a7ed2d6cc7cb36089a7049eeb52e723ee17f3b1b6b2adb7233cbb49286f0da12ef02dac6d6706bf495959cbb055c561866b9a16fcdc3a22b6b2e87c874049eac4c56233d650b3914a48810387a3bc67b086bb0ca8ecbf5bee0e9d40db84a3456f9821417401d2e38bae9536f5d077588485d18e1b0ec638cbacbe2415db1a2a962869095ca696da82ea06c4c38f39421af23140fcd0484d76d6929a93fdb771c852d58e00ec1faee9c8be4cf81cb0fc8711fb69c5d80800e62c9cf7991cf85a8826b879a78854dacbcad4415a7b3b61fe16ba47147223414c3d063ec19dae75afd28e85e226ab7061a9281cbb0756ecf3a6e4d405076b51c12befaf4624e6b8fc5d14bc0dd85f1fe6a3ba35b0b9e04e682253868587dd1b1aa82d5745744a594d1514f4942198f52b567a11a4badf7fc8d6886a167cc1c883aea0132d32318a3613d529a4875ad58069f03332409815c5495d7a98798f75aaebbc4c623699aa59111520d67e1e14cf01da4d4003076733d60d21307b6c7e97ec99affab93719d5ed73caeb0571b99b80cf1a60903a488d68dd8a7c74e44c3ed476df16e3ba94e3f40f644dc6d5aec875b646161259dee1d4bd619e2a4a2fb0557bc73a4089699af98ee7ee2dc4417eb453bcb8632d754e6d1e661a7eb3e43e5108add1d97f45d0db28aa0b5ff8812e7a6f43639e3724a84fd2e5294282fb2b562113f758b670ae29abd5915548dbf6941d5ac7caad1325e1a61bed619173e9bc5569d410a16f1931db41729cb443aa3ea6a969e72f8cbd4353d336014ef2480f5d89f2836429742953f67dc20a0d450d491d3e209b814720eb44974ae325627cd34ce16dc34cb09b90bcc4587ef660e6f406f347547527a557990ee7c5f22b1580023c2132b78b3fe7178763825a6f059befd4df9fe46a243272f4791ed55d9073ad2b29fd8d73805e58e9cf6d2ad1792f9e4486672d116980e5590346e60992f84137c5ad97b16a88ee68108bae5cf8a9e07c4a8a23ebf7d08caffdbbaddc743300b0010e16637cbabc256ff0043c6ed80f2970e8d83cecec61cea275276c65eb5a31340fed99ba785ea6989d5532c7931f26738cf8691d15edbd80a232161015af77055dafb06ccb4c5d278ad341c08ee86502ccebb935abeeefce670b4ea18cb4c4a522443dd4c63b33eec2dff64bb72927650c1bddcd053576e36274086c4453d4f95efd014350ed9b25af7bcc7d2f8ce8c6b92d9ee56bffcbc83b6f72b5b8ddc48ad0b1f38a624326559104688e95f7e044c2211095a8b21e6616847846cfbc89b812f4adc80e745d6cc7f0c99cb372fd64ca0dd5d3e8860c82dbf2d57f1ac0e82c60b681aba5f7c298a5b7c7491e5dd39fd5d7768bc597b5462bc9be9ce378b66a92efa75c4b5d5e7118dc44058270781356e2eea825910c5a83f0a63693a468ad2b4a71f6cf6422637aa7c84480e509b678da5ca47c17e230634b6defaf4edaaf8013a93d9c256df7f0bfa5d6e2f6af20845b1b50a56892b29edf6118d76f31934137294f163ee50a892bd382024f514deb3847c8545a9d9175e6bb2d4c338a3d283358d39e5fc2114259e7c6b6353e2b6a41b536267e77174df41f279437ef797126146144de60a4fe666ec931a28e11c1163485721c839b18264739a7c0229c6867ba6167894ca8e793982bae7d18347d38ce42d61797f2b405d9f46f6734810d04edbbddd445c8b34fdd32cd5bd0f64c342ab472c733d417cfe19768c7594e4a0c58696de221217510714e29778cd829e97199c63211e80bafc24fa7e80779ec2053ffe540fb9a10faefd4bdff25bc50f034b2bb8511fd81e3545207a08d5f3bfa1537cfe39ba0d0fb87328a355af52dfd4b17541af6d792c60a87fdd6c7680f112ff65015680d5afd036a16b83d85b70d3ba3bb14f79e9b9184fb08c2a5eb5cf5d274b699f3aec0a672add78c9cffa5d2f1e4e83791336258e2a13c4ca363f7dc87a86ac737921f16b538a3cd7b1dbeb044fe9150be547db08dd47dd07b6de5c9cdcb5c066331d784c7b0f63a8b1545f2e287d5ff6028ca70993e0207017665a63106bb33e8dce58f1afb6918ee19f6ec9f8450f0621b67d78820726fd11c3c35038efb0fcaed905c61186371501d6c0e5b0f81db22415213f29f34c4d8e0ac097b6435dbf8b8feb3ccdffdad3823c2b2a0181c170b094e606f49d8ddd4a89c644ac47753795a8a2deeb540c435685b63a1600b8fa0e9198a00a63027b41720dfce934c456f23450701dba4a507389473065795bc0c149207b62b06a0402acdec2cb10abea7ef5913024f176bfcbf61ffc983950a9a71b2b8472aa306944f2f11d5ccbdd9e97dfc178065c10c183807df3553514a62274345cbc963514b3352b761e8dee4b5d398843bb0aadd1c428bdd46d83f013c6e8c6c826d883873e24cd96a66cc627a58549f3d1ab0073b795ae6b0bbdde26f5491f5fdb876f261308c4be31a05d289de44a05109b8a2ae8b9e89650300e7f2bb6f3611c5f1b0e2e1a0950b6ce8d9d55cdcefae371d59eab340c554bb66f6cf7b1e623e5d1a9742b43e949d31ff5bcf172e6a7dfc803a9560285b5202df16d35b734149461e8c598b9bc1aadcc8fb96aa6c7da54f58a3c287117482881747de8a88e34ba1ce8d8ba23825bbfbf41b6767664c5398046d9c36158e5dc7a1a032af10cff7c35bbf89da8aef3a1ee03a4b8503501034993e12e9d13f89ef83ba7f8b220d88187b3aa6cb9557878ded391e2d7957e3cd61bf2675aa79472c1c25c6ce56f52de1728960522623fb7720009a7f1232a26741b355035ac826056d67d1014b190a61029ca8fe216a36de8df515e596ee05acc7c8c07db4827732093943922ecde96a5e9578ad616b19f4486ec45394dfbed42d15272505b202fcb5f4a65e2c8e7623c84b9f35d461114714471db739fb034bc5e7259cf9be38843ab416b6bb7a374f0922dc7e80c7e37de8fac7daa663ea173595c9cd88ca46377e24b5784c1babb8a49c249db753cf2998c4002ed10c35101c62263542fa73d83019cf7e549ef208fbb0f70d13eb54db306014b428e525d028eca75e947b62df6df0cebc142477e96440eaf4393fd0b2c375e59ed392d91cb8674aa8b9df24b95cb7e21edc707c03201aeb0be245546acbb33f9e028472e3a4ec14f820cfcb14d0158fa4778a29ad92946835c36c96e532e92e83c2c863c652bd18b85fcf9a43bf88c17164f37a86286584c4ab8d667bd8960a4bab9456f7dace227cb7b375ef2ba0faabca9baedcfd60d5ea90bb7daa1b7d14e2736087a0b38b64c167bfc1f3cb9ee4681dadd7677eddcf0cfb98be12673143fec0a9c39a6a60450d75264037ada09f6896d3e1551420729e447bdd4e40cf2a9e40e7f7b58c5bf16c4ca0a3edc511cf0cb3e1fed5b236c471995d493294b56a6be54fff5556e333ba860b2e0389ab58ae0fd197eed7879eb5eed7481b1d1fb452003e5485b927989dbf333a984f22c0b27e0baf554466d73dcf3069e1988c0e9421fb5366af8c87a0ce866b12e813c96cda980ccbb5edd54bc6bc919b1a37a8932191db284da1dad37955514b02982ffe83749f9a66d2a15fd52f39262c5c797058c277bbe28bf8766c47c2c7001decfbbf6be8063bf16bafec7a4728e605931d763eb8b487eccfc3a7b4b86e925710752eea97c2fcdec9155dcb826b11503db3e09caf34f4a4b29a5ddb0ec608113f4d4f295ab7c3d4c759c772a0d142dc147b8fc0c4edeea839d14223bf6a25ec6afa6f00298ce8f729c10cf1e0dd1a9da75c36bbc61599cdd682b42cca6959448571b3f0a699eff0447d02b1787390582a2ce4b4b17ca8d3020cc0992f5ad13fe259d33f4e338e11a03dc01b279d7eb7c9d90eeed16a66f5ec2427a1c706be1017fe5a0a241747753349c94a80828b9272067637345a72113be40b8d1a6a8cc536a9307464159524fa82690f08513cd17fbb8c5d10491643e6bcca0225ae0349420f30baa2ae63bde47887c57b647a5fee89ec5f3c0999247c4bf4c5fe3e32eba11f4d03868dba4622cdf9f5da23a1be4a8ca923373dd2e5995582a45f42d45b73e23f36d72dc7634a63a7fac523b10ed0cd473dfa1ec42bff6618a307cad84be856d38d6ed530c9d90025b01b3fbf6845c37b8a4a316fcc0d9a46e673e6421673ab549c04f1a5c1628bbdfecffa7cdb0bee57d9ef318e115f5541699d5f8e2b18d02fd2644b9eb0e94f48062d7abf437496f70a492ae06dbd85ac710a1ead8bc45aee93a34d6cb0494420287f9ac74d670b39006ad0bf31a6ea489345718969faefc9335ceea7c59e513e424f9285e9aa532d436f8e641d0bc295a536f8b6c24324b07caafb3c5362cbf9d10e76f553361e8f2bfe219f2cc6230b3d37b6bb9c66e9a679e4cc58719b428ab22b692249a512fab560c1bae3251b5c98c50239f9ed7e1e9e11f5ed7fb3955fd4ab495568f623b2e95c09edcb71240a58557b0986fe37120dfc1c4d63432860f0847c8081f3abba13b1d21e814ee228b2b6890b51b5722fbaeb265403b5981f5085ae05d5f21ef8666d4e944d0b3e5aaf4904b93df1a76bc1dbf70bd3dbacdbda808b21e2e0a40378f4eefd51d5050572c042c23bf1214b72c47b553af18be35f0eb03b180ebe3b11bf6018163e1bf70d79405e558ec9b321e573ad165a45d49dc85e4d526ffc55151d2d49318a37703a9b23c6cef7281f7a7b945e3ec60373333d457d3633d41983e6e2f572f51b029974d7f17d2cdf1da50e2d2b0324777ed735f705926f2629fa008d2a7667041428aaa267ec65634c6f9f68d837c512355f91e694bc5204dc6058b966a0b64271c86d42856c8929e9070e4d345c861ff8010dac453ed13883ab7c920ae04c1237a8c9fdfca33dd5c991fc0a3478f8380f54413752dd2ad156606068b1bab718d4a28427c0b9008f1e2b28e0572a472c73ee21ca83c58e672036511b2214006bb827bd8385e29ec7945b9731b77b2b0aecd77160fea2d3bd3165a08552372f24d850409414733a37b3178249b3863c05da162303daa929cc9fa69938ef9f05454fa6ad67349227f5ea0c30fca6433f6ed7ec4f60db9fe40e75fd92f202ad294092e881d939f741000302ea0ac9f51f629746be95134dba8788c6fe2670c99f8df8aaa622bc2dbcb6f6bd6e38a3fe10b3758a0179220037ed522ccf7a3ef1fad7135baad6d9e8c510450ac934079bfc542452b8d20a1463a20d1fed50e9bc9c8039ee8e53bd620d271b56b3d9310828f390ef0c5c73281de85c680e0fceff247bf95cf69de39425538d2bf759a09a5a34d65bf7e56cf3786c331e006192603396d225ca83b52ef41133fe1a7975061ef4c1ed906c3b04df9cce2a974f9b8dd374c1dd78eb2c2059bdf51341b0a805c297262938159990c11549340b5b67a9da9d545a1b58c4a89943a0a5d6a1c176ccb261eda451bdc61e2132560264813735fd989daca51db1ba52fbfbd7091dbb91c5f1b2fe092d3dee45b31a159ea247184ad9cc6358f969cfc95d4610cdbd936a487d0462bc351a0cc6c06af82f42fc0049a3709c3f29db23a0182e239b01c28c444c41b96c751ed40a2acb49da1c0716d875442906478edb0d6fd82d89c4dfedef511f68ba3598fce6e9f89e7023d3f25b76607424b9e6813b96a5e77caf1339086877d7214f0714b0a9394af7af8e13437efab59730744f29ef633e3680b47175300ede0f9ed251ffda8efc8bc00223d63a91dec79b234d51d4afa53f3a871866cff13a2495d801155e516baf382ce35c81d5e55e8b49284e6588ba32d2334fbab91fdc85acd1ce64bb8716c7ff744091740c3e64336778cebdb6788b6f5c8d08144fb3115c8e2de5fc0444037ad25a3e0e1fb83684ea8e762fadcb90c26cb8e4b1618fdafe419fe71e58c9b87b033b45d53cd8479dd0022bf9d18ca905e34d2b4f3f176246db4e6dd3fc41eeb06910c71dabb4ca2334b11e95aeb308a0a3dafb86e69ec051dfa79d8f1be634c4692e3900b60d76101465e269332866b8d985a57e09d7a0c73af9b0f2f6d9f64e6d900150b50a950582c27b556c1e7733855f5ef4a6dc117f8e0ee4d7f3887601dedc10cab96db076bae3e590bbc9b8c9bf8a50892df0cbcc59577baeb5650105d50a508826b54e8dfe48d43dfdd6b74d2cd3d95ab0d14df9a3a3fa483dc4a61222ae583b333d2a96c9e71457aae3708bccd8e8d98784ef7011c28e5ce876e01e647ba3bbb8b04de4dc44ba4221abd5b707d025aa4c447b0c756b8dcbe0c3cd9352df39c788a31bd8f7da8d11d3205c5b78f758a5c505b5ae3ee975df6f139148f06d10d714ed588bbdfc7a98584561c2a723679a7b7b140d2c8dc3877cb2e2c8e791a22bb0a41e7ee0552f43f7b31ef4c81031fa68bab5fa41d5d74a21ad9f74159965a74c0bcef42c47af0718e471fcea8879830781da614a111bbbbdeb2b1c797384e05563cf3222d208c9fb57341a5a418fcfd56c4ba958f9c3c2637971892002e96ff86d0e8811199aa97b1a4f8aa63708361d85eef95401f51514b0189fc31b2616ad66d8f5afc8378dcf374138ab08b4cbe3d2b8a3474979c7f6009baac6f6c86c270bb98399eea7aca1d3e460409840e006d763d22eb7799b801e433f23d4b7661e38531b276825e5561e585d92cc643b9ed7a2593bb855ba1de03e14718131956c0224c07ae27e11852e023ea66a921bed259b3999d59df54b7e3ea6b4de1f3253dba66944a39a2ee160283c47a88be3e294d3edfdbf64c3bf5f62c3dccc7da7c05abc017f214cfc16c79ebf8c8cf4ae8cead75ad0d5797d129ce54b17ee9409ffd4659c0e46ecfcd4e20a2c8cd86df0a81734d1f412cade0c5d2510ddcd43017d4e71ffc2d9f1c276814141cb8bfe6d11eb8c51236f3b59b3147c2c8e6008756a67bd86fdb140ff9f5422a89f11c2cc9653b234cadc995fa61080a1306feabb149c7a08515b2b59111c49f7b5cc50ad7749e3ec49ed80fe3515bb14c0d0fd11fb901e311906cb74a805ccf31a30882a9b273c06db46cf4cb089dc90e2e709457f089ebbe60a69342499844b4cc25f6246dc9b6e307598782f2614c1627b126067a9b4d687a1e12744376e6ff9f4ae3269c5ecfb9d97d43360a1ab4fcaad065bff91d9bdd92cf18d9ead1fb8a72395ca44fe0e9ab64fb25faa9559fd28129df878a766b39e372bfc6748c603b94938f71b52a29fd6541a6d0f7031c00f0dd209e95e9e097d4f1da1eb6f703799da806f395b05015e9f0bfbe4889dc156501a32347f24b6a9d204dca2111bda7ae942e200e272d7e0af27a0ecfb3c62e20dee8f32369d1942f09c3001aebeff8e206bfc046be0dcfb945aa8f3ead5e9fba19d8afbbae916e9960f39324411d1a8627568e1bb6f473bc6610fa370655c8dca7df7ac398a079f2578e678b6831d47309c9b876431bf648f64e5010df05b02933a221264be31203744af744f62cc4d38c6b0a2a01ba2fe9dfdfb9e83bf60073ec35dba39f763cc320d61fc0ffadc4eab1d44fb402447e116cc0f48529f40fb4f53c6a21c3fe8629e2e0a2c250e66be2229b45c8491867d3323517620e2eadcdc67709425e3c9b819c335debd2c246ea2c102dcd5f897eb4eb07cae1c4a7dba949430f1d949e5a6b664d518fa878f7b80c6178aeca4d3acadfadd746ffc0b60f8aa7550ef302b9e276edf59dea1ada02929bfa112f8876c68b28c8bb891a16b85cbfd6b484f3e0c62149c1459d0a24bc51d1ab64dc15d27e393a06af235c9dda71fedf24f4207669e1030ed7be8c3dda00767b825644665d0e19bf67a60516f583cc3d338481a9f57344fd4ba07e5f35904b4e5656b7510d4d693b4aced7f14ded4e38ae7c147cc441ef44ce14bc3b3adc1a085be65ba96fecce658932ecb84c40fc7a4e9ec2a244e558d6755a878be00c9c0aa95a57a2c14caec2da3c9959c1b246e3ecf2ed0e2dde412595507610e2229b01d9cb0d31f6d9a5d27d0fd2f07f5673bff87dc7fd1e239c57f599b90cf54ffb77a31a903cc170993b5c755c9ac476ea844439ea8788398243da007525519b1fa1c6a606efa2aa696efc418fce1bd391f2e2c57d049bc73e2d92853862754c0c01b2036292d4cdc45a16047cef79f348a3bd99af16055cc221ab548c3a426a58b2051f41fac7749fa42d5d5ba381b3a7cf430f34c34c32b396f8c2490fffb0007fd91bcfb8b72cd00fe77bfa63d45eceb227788e54abbe698d8dce81bb83f9c3cd1ea5cf171cb2fbff31afdf6c110ae85a2a89d976acf95b381c3b7b23cb843082a49b918502e1c1136acd95b8d2ede5d738aa3fafed7179aba3f0ce9d9f83fdd64a158f79ddae3d1955714891a6bc7729467341b6efc2817a08d99909fa9bfb37360e96368a4b0183aa0d03dfcc9f891b495e20b2cfb463630c78507eccf8720526342a90afcf79f67dded707e63dabf9c879b02316949b3e318a1e2674901eff6e56aca78e7d574771a9d845e5180c010460ee1cc63dc7271ff2af6daa5e5524c0eb95f4931f55e525ae124dd4e3e2f58b2ca642ced9fb678d2228fb093b31c3698bfe5be04f59fc60563fed1677ad4e624dcf31768f74189ffbdfdb4c0fa203206c7acb6f5cbe869e32cbfd638cd55eb691b17325f6b1f0c79ec0bc416a692b0d52b8ef54c2d85233c37bcd4e7ca268b58d372f3170f07a415ba784f56790eb11035b4b44de1675a43b51a1a7767976ce2a1ff9998b85900b7b8174c74b61bf01bad92707b5087b271bbbc56990b6286408a2f00c366037563d1b9d204b1a3c9392a47c8b271b4f687c0cb538b0107af21094c61a7229d93fc4ab9da0963136542f58707541bf37b05091990803fce8397e0eff04f032147a2d7da2dffde8c89aee71405b502e0869ad7ee087525a89e25dd258878393a32e9e26564b7dfc0251d649b93e955baa24f99a0e19b2ae4698a5f562d84c9a7a73b2b96989df412286a69a72424c02f298fcea23ec446dd8ea3e71f13676a7da814766b012fe788ee3ffc00a81261a2f2a38b0706a9f13df01489b536e9d319cff5c53883db724c4b7020a269c6185682ce5b31ce40e30230064a68877539f3509da19390e5f2f8a8ec2caec9eeecd6ac9d77534c67eee9155452d0b7eb1be011d3678b0ef46fc68b69a2d5abb2975895bafa703641b783b4b675b83c16fb52483fc0d4c40032f3ed1a8eb492f3e49d8d94166f8491ee93ff7a6b5385b0041df7daf782ea3ecd047a4f74c1f4cb2f64fde6c87cbfb7ab924709e0653d3fd2248e8f890c87ba980a23d559c4e31e0cb669f60be16428fb8d2777d175ef49c1afc93bc74f359318b94f62ca4f227ee5a1ec28c2fb9d2cd0ffd2ef3326680b98bbe98d9534ac7e76bfb7184366109dab1ecc46fb81b47d7cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
