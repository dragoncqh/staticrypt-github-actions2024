<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4940ef4e8dc5e2fb569992a75195fd0ea4d3de82bc330c507eb470d0fa0921b966c28d39a712c5281b9629df2ba08fecff3f13bcc5c787ed3544f2decb157ba18d77f683da56fa9391d5030bb24edb23a21529b3edc0ebcebaadbba162c99b44cbb512446cb68436ad98ba3d13f99272e73661264b04e7d1169eea4c9644ab102e9f80724b9650eff2bff52a225c40ee126be2b0e138340bfafc6426517c17850cac9b602f88b1a41f583e918d89f60f7cff4c4a706ee8f1fc54eebacdbf0e0e34269892f0fc8dd743af084318e5e338a9e3164bb1c539f7607b45df7f1a259aa2affa3bb9b3a219e997cb24720c11c3fc14e21f79671b82ecd67d220b820b85ccdc22a621fcca0d6d2ad0b136fc41120443453be885a837f06bfc6c7c1a079d186d2684e91d154fabcd7fb06d01f00238c318d9aba5a42c8784b0ad108dcb2858c3f11416d44519c7aa96c9539f9baaacec285acf5b5d959fc0f45ed81f5d84fd7a81b509f4fe14413f32232da8a16d73ad0302dcf74e58d492b2bdf17b5a820ccf9d6c621617c4941a7771b346f5b5b20f2f2154c8dd1eb0bddba13a68c7fb52a89c8d8ea03ad8edc030ba7dc8cdef0db9aa0cbb662f1861388685ef4e048113840e591ba60fd4d7e43dfc8947b56114d6c6a67f42ef8f4d511b1cfb59f901a91a35b0f20eb486628290d43245bee60b872c7433b9ff35133a48ebb609075ec194658d024d72a1c054caba4a9b298bcbe23d17d6f12b3b18a5a488d0299e7c97a95a589b57083be003c8481ce9561162ba8b251ea35c93ac7ba28cde90ac645b66dce62459d2c19fcde5aa0ce376282919043986bbdff1b5808d21bbffe36e5cb91852dc5fc934ec57b9b22d0edeb89543eddfba7dfeb3b6ad8f2b4771546bb01ff4291f6b56e2e4464bbf432e1d2e10b63ba54e45356ea4a9fc780a6701adcac1dc2f2e1345b3992d8cd218ee08e4cc988ea4157dae3eb063a16e240e33c3c31813b1043c913ac4f7c988a31e9e6592d2609d6602479e1079c8728f70aea35fb44bbfa1929f0765ce80b930c9fd51c61887cba429e06e1282965f56a6c831606a926043052bec286d3332be2aff214659637fc51fdb91c6c755b2b8dcd73726190a48de4918074691f11f341461ebce43c99a92b0592335378d14b8e33c51f6b79e606ac1c38e78fdb0a954b64c6be7a5364db02a64d7265a87e88003e0a4bad450b3f5aaa8f877e15ed01fb5e543f494773b88e0b53bca48566d108bdfab801d2b083956b2888a0979f0d34568ba691207402659698ec770229622af695db9ec950bbd4e3a3ef955bde2f811aaa1bfd99c029099e98f87ca0c80da656079d91e53d1d034e0b9b56cccc65e4cab13f3e3f0fad51d9d864ace8b7e12d95d303ceff77a4336bf047dbd2e51cd6a3d70bb938e8b409b0f8daf12164d5b5f8f5dcb528312fc0fbc05193ae09edf7f9aef9e67f88af11320206dc132961b1a5f02d680f7ab458341eea4233f7f6ad6f7874e4ca02edb374b399d0167c9601493043e94466fcb34a00ca0ffd4252cb043f5a34b3d2656e129f20ebdad6a4871d4499d3344efff89445013aa959779f0be989fae7340a49d87e5889014c345d2d016ef77aeb5a184b4496c64aa930ffb68d21cf13530de03d8083ed6476b3fc667d2d945e63becd554582f2785210c16cac6e67259fe6d199d0c44f17e4ab3baa1e216e4f6371055298cff2355482f28259c8136cafb6d9dc247e34bc18cff9a135dff675734b60322dd11f745250ff265e7628f06978e2e15e905408d8925e6bc9abe32a48eea1652a051a37b26a49bd9df3322c60d36797d5a503df97924ff38dbfc4d6b4be1437f72f832c0e54c155c57f92a429460b41bf07e5f9ffb483aefbe656ee61ab6eed8c62cc01eab9fae73adbb08e313c04846ee6392a059126cf78cfeb01bd819ed2d9fbe403087a3ab3a04ecc6d2415d50e666029aaca7853718ce9fc770a9df81dced8c79b753946354bd8a9dbde92d925d6631b9765af801d9c0664a570b9257bd7bf5a7d1cb69cc2a6fa2170caeb5204276c43e8ee3c894778dd8c3e715921b3a31b09c6e0aeee1f2798e1c235730ac555384ff9a8a6e6b9060d1d6775c802ac2cdecae127851629b9a69c8190c7059438860d6d85e251349cc9809e87df12a582665c77177f12ca4d610e76a385fc0fec0eb200e12052b88413392886c56eab4e7b9d4eb57dd7a40792426db7bdf93c9dab7c89fe33e91c96ce65054548f5d714e761020d6fd0520ede9a352584337bcc332f203e64428cc04351270ecf8622d664deefa5765e0f409a1052b36c162e2805052a0178d24d63120ad84ac6b1b16116a900c7149db6392789a117a4b5fd5c1bd5459c3a1148d33481774c9b624bb13562d3f64aa48c2e6be91e70f8039c63e3fa64440475aa5c8fbcc5b1a621b28ed59d3e5f76f9917db991f6cbe37579ba40346634f52cde579360c1f38796411fceb274eb122408a6c9c7b9ef3bfabec45df6e3ff983fe46c300d92e83fd5706de00d41f50d595b85123f9ef43f2da265f235126e37c1cd14b0e0d278fcf83fe544a33cee58b4d0146af4712c285d38e3017c74574d665bc35ae6b565a491571cc1aba5ba8441397a990d59c5b902ecf98763357d240bb87dbeaabea42244661c1912a3ff085595d2e04a16b6a49e402b0d7ae374f5c6ca973b7c7c908df66a4ac1e0a40b6bf90964924ec89a95905595d44f13aa52e8c8e7ad353e8c623315b6dabcf78dd76d9d351227fcb6a999681df1c3cd792cadc7202a23d0f604c7a931e8e16ea7e1e93f9bfae1034f3a81ebfd303983cb0faf14749ba92d425980adfbde878df56d8567b7cdfb029d7b6e5ba06b33ffe6218ba7f3e97654094b630f48d093df10d7a04b7c94ae22e227a339fc7a27154c85f134f28b431c7ac572996fe44bd32c56e12e1566cb7c4987d251579fdee89a3d195e2b719651c9a546a33bd2bc89c18ce394a29b436bc1e89494937cfbb83e03d2ce9cac514145a72e489f7f106a5abe667702f38c4ae4196424cfa8c36e8a64ff0c31d6988296a5ef0a9ec7d92b73e8ff9b0fe1034bbb7961d005daeb8c604a9d18346888c8b58d711cb2b68c0a07827f6dfdc51a3e0a76a4c5eb5d654977afb17e075b1996ad3064daaeedc97a32c57b44bb53cca5ca2305b40bb665539f2645a90c09bbaa199d860d624da61fad2d8979030753a222c81c6b238c02734396787e0683545b2cae793ef32f5114c25a39940364c9ba538f6b823a4a2a0a32b2f6c217829047c167a8da23a085d717e41fa8b459f16179a52027b0fa79067e9493501cc67f8cadfed7894ccb66fd781f1318cc2cf58b11db233d6376a7a50d94111388556c1b24f166cca6314e489f0372f45dcb7e732058e0a0a88338c93b094c69e7aa1df00110b7c53a10d8d3783786e217031aecb8a163123103dfa58bbd6841fe2ce5094f04969c659309c61761571801a01e5c32a506c94ca2b055951597f1254ed51eb5380125968412e470722050de1fc8976bcd8e105392ceff4c1661276ddb7ca1317c3064ccc81198dc0f39dd265f3c707d3cf3089f0edb4aeb1d85bff40eca83c4fad8503a9955a2da8f8c334cea0294047841c98fa2c12ec895d429ba58e99a1d0439326ca22b1cb3c4726ff7d9ae7f95b9c1d522584d46e0cf5fa2453be7c41e839cda566ff250d59cc64822788578a44b514ef919cf7b2af95c3dbe6f1b28695c49049e5c206423aec1a6d6d2a189abad025304a7b3543555e24a8fd0c80db002de8cd0162028da42177597840afef1a2e12addc31d37af0ddeb16918efb9d28e250c0da28f8c74cf02f02e0301ceb9678c11e00c7a737b705bb5a87849fda4af5646f9c6439e3db38bb0a00c2781fab20de6b3f45e9e17fcfe4310130997eccfaf13e2c5061796003b5ce2013b759eeac158605f8dbcc54400006977d11be55953ad1c43142ddbe8c53b5c9271fa0127f7f94eeceec2f5e92eed89fc243ab1fc94e24e640791ab2281b2e70340eab228104ad564df51739facadc4b55b4d84045bbb5d53193d02feba15df9d2f86789416709325b6adbe52234d80edd2d22287ea5c18d73b120cc14e0bcad36a2bdf5e8b41ae2fa6b74b9f07dc2e3e5f1d5786ed476fd02492bea9e612ee11fff0bdc7d7ae3b173bebbe0364a8ec200202487785b2228cc127bc32ac3504ef0fb4f04085dd32b65a31be82294723b2b47eac421428727aff8bbc04d8d79018ba1c0242ab6f982a76f02fcebe13b84faac515a420248dcf4270f0a283efdd53eb37c53a9836b85d80ddb8acf105e48d2b6071a831d659d3c4fb9fb173bc4a6e80099f60af26813b8f02155ff7db1a7bdfc6ca13109f7c6d0aaa8ec08ce5e50407010c1b2b0c4ef62b2d402e8936a50bc19678bc2d966693e7d20cc626088fb9471693a58e24999a4df91a445948f606e65cf225437dc8a92111021e8a7a881d54174deba358a9a7326740413e3465aea4f650363ad2dc83b76cf26da8c03af2d0bcecd663117ad1fe1bbc2c9fb207a3c57c1d10d7516c8c635f1d06fb43c1e9c447d82b7e79ad52a4855a8fde575c8da61bc38a5c13746e6a5a1dea334da35fdf506f658591f59c87c886ffc4aa7a4d77986bb3e71baf9839f5b817ba14ccdca5ad59dfd39cad5d7e0210b0d67bdac65d24e9f25ec54f2c1bd1251f2f53df53c6952d5cf870806165701d9188eb96d25bac9eff86ae6ed6a755061d544a5ac9b7cb3817e3e1cf380fe21c8a1ff76aa7b01d1488759452f4a31d3a09ab2df6a65ed99d189543c5c5e12b1ac4649e4721f936c51dca6db5e5b87842b4e73ee6ebb8c0cce3a7fc69ccf3c2005c42b95de369525ee3176a1b58f59c222625b7692e56d960f7dd8c1d6311de4738e8d3d7b3c7cef279796c00f01015906687330d3fbb22baa25249b05235a87b4bffaf45e793f90b4f16dc12a0932446971077d174fa8d58f0ebb00c7fadeea47003e9671e21084243685bb934898e134afbb94a3d302aba3862ce6e36ed36f90b16bf578d9e362260860492836e2bf84fa67d468d701a1ce2186efe9a8f4f2a49749b679624243e7e3bd7c854c769c7e8dafb6db4a59576e6602cff1d7292c313255f41508ccafddedb4ccc904e980a2b525f48444a45a222076595421bd8644476db43503a0c0f4207f57daab38c9f7f277bbb5ff15b0220ba6f9f7ff5649883fda51d03ec1a86d79f635920cffd60e08dd44bd63deca9eed011af108110b00c037d9ea392f931c60da28b4819fa6a76da1bf54c8b71540a84d0dfb2e24c110a8aa7b65f913be8c5ac19f6828b6def34868247dacc1476bf9251d5c52e6af80a6a1ced3058b45b8e26dc81c85c6b3e8a3d1c2c8f164bd7bef7dbacf54dfe83b473688b784df5d333ac4ef41c9b561ab495b3d863f861e152972de19fac2da0a5c3f21651246cd8438ce77914982ea5427c831d8961273e19659d2b8cb7c1925272523e648b0733fcc74f418ba073a3225936dbace0ef43985ad3a8f62ff0e3b78d7559b5bf20f1c3c89a95b4978bfbfc7468201080e4ddb02fb20cfbf59bf8bea6ed75e3b3cc26eeec3725c864f3bf2051696da90ece34c4da77d5a132cb61eab07f1d519eb1f5bb9f57e9db06e98a218d8f407a9dd90431dc48023823ca58cc627b7a9a94a546f5865d296cb9c71a909296fd114ee6230bbac1745ab03339c6af4f8f79d60d291158dfdfe389d4d687fe2a8f18dd6dce4e60eb6a7839da196e8978b4a0718711b86a4a189b7ffe4ed5baa4469801c509cf0f8b68a8256dce44f804230a2cb7caf315487667e94a30628aeff5b0fdad8e24d07a02a2e8005a003db9c625b86b5a212f46850f7d83d1ee74c59c7d4996734fc761cf7432c26ce4b495369859f8192fa97a7761af4fba5d2d7b251ef05253df2181d4ffffd8df57345c5b4479fe7cf3390292c67fead725d879380279a2546d20af53f9bc07a4b397a63044d23bae12fe475c416cd818cae5d5625f99a6ecd50e73cf62d5fe0c832300507229d9eca705e86b0f17d36d4dcff11246bc63fbfcd1e515ee9aaf2da4aab380e953a529dc7043b27bffe9d147116c908b1ac3d5d43baf118659188f49bb35c4b3ef5f6748f1715691e9c6bce7fd5e514cac9581a2335932f85457151637975b55d82ff45aa0126d255c00db0b0c93c4a18e1aa4dee2094e11c7c9ae4e6855cdea4975acd921d905bd97bbaf76cd84a703f13692ebe18f1f55040c54f54b1a9ee4d5754190179f9469c5b376f086b85bcc9ff586664bcaf84ebe14850a1fdcc4fe2bd883036a8f46b54e70c70ee3eda7f1dd68504b456c303a9f64a16c674f09ce12d3a301a8189a519b5330f6a7f74389766a7cd4b1eb107f4e84932c5b6c3f6ab95fa40d52f70a8b7909d60670014aa6f4547e7ee35d9353246a38eb0ec601b5c5e091d69fd0515dc632944dcd28ac793bbb0ee51c693c83f48683fc4d965d017bfdc9161060b470ff5d5ad3d2ee0a4ae577c0f3b0e649a1a9c544f266eae8606700158c623beeae67987e312dc8ddd0e34f40523f0a7d81a3465c6184f8a6b67d1e929c49263821205d4e1667a88f32ed0447ef22c4399b100a4ae02d3670272ab9d3b75217a196700cf86ce73c76765e9faf21ab8329fb6b13bebcdc3d22f3a306a85900fc490e0dd0d97e69ce239dc9e4f1c8a7fcb3fda74941e4e9f4cf47a1636d8f9fdfe8c974b24e8c62faaa09c7d22d70b5b9a892e7b6c294c319894716921c8e3a756124763455a391b9638fd552db226543bd30f982af7f2b8aa47e34b5202a0af7571221aa850e0ce0885d1f5fe307176541c50d5f2280856ee7c560bd15eaed45216eb2178f52be7a1a8e2f175c21d7572c0639081b01ca40fa48897a0d0cbabe367e0b28032659f4754a7a132ffe0c4c92d3a75124ea6fc0d1cb84b4d12cdc8ccb661636949eb971c8ddbfb53ba78bee773c04b86a752c9dd850d790a596e937968145c8796174fc3bb26139975cbfff8ee999f21a602cf23a157e6aa392e2fdcceb2c031846a50f5bc060df04257ce2e2a3c34fe4436dd854a98bffd3dd1cf455f77fd58cbc99bd51c71a7e836dbcdbc71ba9a34c86ba8b37639e149bb3c502ae6fe47864dd62736d4daa85cc8c76334f54ce5e38a57d75d4da76bfa3335b12d739e751dae116bff4ecd32d04fd557943899c9472e3025054c738b1f4e9c4928eca15f39e48f87d7bd39c0c571571f48b564dfef9e48f38230bdb57fcb9dd83318fd7fda0bc7e19c089e40ac7b286f2450b0074d21c8f5849939397ceb0063cef4550a9f82105021d83d01f3b8b14897aa381b0d88d7f57ede4f0064b8ed1fa160725030c42179d59199d007edb45e7b3e75eaf34792f9b5882d4438f92bfd23b061107fa9d89ee9da8bb319a9078dc9873fd981ece0e1d7bb612bffc0496030177d4515b93127ab3ab6c09fc22d0dff03d0ccd37c70efe740dc1ea81a780aefc6956b7d851051b94148afbce205ee264c07db6d6fbd551bb8c051139d1de06408aca2f6ef52aff158773bb433b089fbd369cdbaea92b59f40db1063ca46cd4830d77f6664e4685e07a86f02665dcba91f5103690107c235b761ec198f66f25e1eaa166a342db6af4e9728e3c7910db57437915a8209d6f2bf313b47cd070d04c4731fa16965cdb796c7f155cbc7797b1e16157aa64610d090e46b1eabd0c54270fa1e0777d33f184737f9e39b3b1eb02d8d1029e16c2e9670d48635da7c6ad386e08529ab286a81be2cd36c69901003f5d475d5ede9208a1ffcf8443c870ce5146f8beb106d92e496477d45910174802ce954aa3ad2dd41e28b647e1185b8f91c0d4a65327489f1cc369f8b0b8499ed954c20defe2b158aeb7bc59c24f8ea644ed3ff23591a04ae6b12540de929bb9ab7d7249177b5ba1d98e4bc3a7bd500baca33bd25e793f04234cc6c80793a602c60c801d97ac33e2e9c2dfeaddc1a82e978da7042914a6a4987f933d97b032f5cb3bc1e962718c6642d10bc0d422d183389b052001a0866e559767a5a4bdaeba887c87a71757c6b0d22b78981879bcde304ac1b2de8dfb3835bd180d7bc9ff89627c80e4d6b51d098f5bbed9e762449401b3077114c27b14769dfae215b69723bfb9828b02d97bbb28b13f319d398d2fe6c85884835a6531be2d6ee95170c415a40fb45366a038d6071faeb40924b0e2b0e9cf268a1a5f4015237f5bffa0657ac3d2f2e9b95289a464305eba1e815aa3569570a357dfd266ab5080e838c75aa032725226ed0d91232c842f4bb80083b174f0a6c093da0504fa53c308cb2c691cef5d72933e772f94a6a9d4d67bdf9a4c9402d59ebc03330d3836c9c0da149e39bd3854b57bc5d7929f799feb59758104242135c201279913f5a6fb648a1e72071e2d4640b8add3aa7c461b47e8471e8221b61cfcddcc82d0386125165a6e9931dd7b0782ede69e967afebd5dd690e44a5bf703a5b46f4f4bdf7fa2851db6992867319e0750bf2f486e0ac45629ade1e51f8d38451cc21b2572032c8867b78c78aadb9bfe845cca76ef77c92bfab4259b26ba57da44100257515e92dce05da451a7aacf56f00ef6cfa1cd50844bd654672157341b21f144a47f5ea23f6aa833e9647c2fc4ed02fb4da29ac805e2a03935f3600ec47e98c3a1a8a068b96bff3f9cf1f8f7d685e373654c44c773e483846226e829d7a9476e81a967d5f9089ade02855fa278c2e5d61395d9d0ec3750ee33d3fded0436c2b9a2f3e555fb7c58867e9224bba6fc8019ea4582610e3bdcdf8c12d98f20df21871fb435a63d2e3471438965d39b2875f8aec0594173f180478d298064b0228a247f81554d2a58760577c5318870f9e6579d7a755a077b2c486c9ff62fe956c4b2ef891f3a23f76f6c9bd369eec75fe11cb174ab0a7e295cc1484f43e6d831555dd7f2d221ea6e93c80a3e6e0dccf5c3b28f1ff601f27effdde4874ee0183cff75303d8054d8d26dbf3669389bd35b54e4bffd33a33d45ef4eac1b6891cdd0580035b5e703faea21e388e27539e55eecb7516a8137088ea0263f3204fa162cd5d7266d41abf71025eae46dfcf18404d670959069e93b6522fc11997828f3c3b1332aa5d8e75469e029e13d2b39d41f2e42afad27016408db0b0d2d48bc688c5522636c0049560cc03b16fba0023c7a0c0ccefb41e9d3db202bd2516a1d17ae810b7ae743692c89268bd999d937b9418f0eae77e787d7b55b41c72b8720c7e3880e8e6123c9870203f0f8c30395cdf03aafc55f0cedd28239ff0bac0748d2317a4ade8f5db1ac48dcacd33742b6a4ec4fb980e145533c183f319f2cef5dbc2c73d3517b3838237fa39124682535876cd1bd2714c1a3ddfe72860535484a7646abbe0c6812eef00309dff574622762f1a3c9810ac11e80517ab741cd8f35df68797691ee87364b5e7356ebf80e22ee52092b74da1e3a3fc0952a8e61e6f74542b396f9642bb12fcedb496a7409dbf125bf1f470b18a1328387a5b1829014504e62d91753799f087c8c70947c4ebdcf849b8ba7f980fa4b5dc9159a93c2ac652fc6167c33101c334bd02bf3f6c4bb05a57e41200a00e921d5bc34f2f1f59d0cc5dac477c5fac0af0bdd81c9814b58e2e3492376c4438218d5014afe9f21c9be545eef49cc798ba9f838848b5871d4876c4a98ba24a4c90a0af40ce4f745dfe50685f05d550df8ab3afe29568c513b969703847c88e7ef77aef74ede35e7d760d05482d7b968a2db6094abc267ae68ee1b4f05ac54b42fd851bfcd85e2047fe86a564f6fba7f49430bdbaac3786be0d320997bb933bf9d70f8f09972acdaacd8ac00173335155ffd0c94418e109530e7e931a0e628f55a79444768251bd31b8950802a6b43bae6f3054a29ea5c035e9dbcb4bb2d044ceb6dd8d257ca68c6c8dc361772699ac463d45654940ad488e59e4011cd75d069bb8cee4c9f9f324b0a11573677563ace45996defce3956feb8d7d8569534447b9f9b4e0b15ef248da7db5c67aecaf0b0b90fff204148ced0fdb46a42de39850445e44f69188b10235c9a266170b47c2f556afea43695062e40be47371656b9a29c98c2c11d749d4945b9aa66824efb6670e34bc977a4671ea38ad7241ef0ed41773ea73ed5589bafb703130fe93b36f9e98985106acec6805a6bf39033ce092218bd05d1648fd29d7512ca2cb55512e344af0cd7a71b07a1776065eea47500dd14e75b3f0ba9d0d72af53fe9b493588989ca5f1972e3e495a35cd033b2926cd9f72502a155e31eea0f1385cc6020fcc6cbcbc707610397a1f58308fc624f54bcf518afe6d5e6799133b2cdd0cd019c6827d85f6fcf85b93755b08aecb8b46e3fb9a783d5f8708675a01e3b49af42c6c5ead1ec58286b9043814c3f6e34e3678171df930271cc6d302f965f7692f7d32fdb68859b09e95bc45d98b55458d9f94dfa6766cb6a2be19602f50b67be71cf95b540f0d1df1d018311441a20dccaeff2406d818929c7fd87c896445fdee838c60ad813c547e328fdf20fe91a04a19a5e4827a658b0d167ff1b04897e26562f667a4c46f0df90d88acd8f072a287d48814c6d30a0f55e053dbec93580b05f966e7e21ba3e3c0667c88ace748abdff008692472d222b7f3b12aa4ee31c5d66f3a7bc74b4e4bf7bf12dc91cae931b9153079703db7bf6b7d8e127036b6968dbdd9758fca7342093984cd30e951bd7b3e6e697400529866b846826c12f3c772983b75d965eca66c16764063bbac21d9dd4d97b378b2cfa61a40433d91d4480cb9ad2a4f6d9b121f754769155195d9029c23cd2001c79306b1efed5bdbed7e69d737273a9d37239d07678f09bade9d3527402122c53983d5fefc46d45a0cd4aabf8eef7196df9c838eb5da774b0c1e58f8bd58088a2eab0fb0b354e21864f83794bf6ee0fe9b5c0c311443b9802ffad38b1013a14a352366809a03474fe2b894717d99148a23ca57651ca62b7c15df4403e399095b897929ed52fcd2d1f8f65ccbd253da627600ee6e59196bda51e11d6d0cd298b9afde57533b39f7f8da2f14f1ab090e03471a6df8174c803d7103975fbcd37c01a7dbc75283dfc1bcbdb9887e38007daccdf16972416667328601a2301889197a94c0f5af67f239f470e61a02bf57769638ef6c1ecf36f4abf2e9631b824d76750cccd883058ce2bb4d07ac615849a7f68efa6ec2e2cf3a71db813bac838968fb5e0b65bb7e21ef114288c53ef6d7f5df134381385281560d1a5570d9ce98cdf0b7c3674058686a76edb2f5b62c8216da1c1044851a699f03284643120d6e9bfafdc85b0aaf94195a023d0ca512f112408aa3e50ec1f89f8bf7452f2762f916c4bffbc35a51c2f12c75786ea9d6ece7ca28553a7155f6f46cd84cff1e3089ac736f03e210d79f9d4346ee197148e45facf34c10dab4f8e7b26c9d2d846634287169679627cf4f6bddc11c572f2d4afbc3b5f5c4a8b24d7e28bc53d071d337d24344fbbb8a4634dd93aa4ebb6004d6cb8f8c9e8265c8c1849c9760f5476cf1a3d5bbee9e900e4651c098a7d74a56fcebce220af56f924d7f10108cdd42ad8a7479fa8270bfeb659ec5ee35f48a5ca0d1f18d4d81287ff85e05e33f1c9a65aef7ef572b265e4a9db7d8a0f07094e10f7ab87e799771f6b3488cddd584e31710693507b4eb83d45f20ad610f3f7307374a1acb53e006e19f91142a0eec45cc8c8266d3fb9ebc5c71f4f70aa3e3a8d90ce171349ff7329f5b0e7b82e684992fad083394da1b8def7d18bba9d8846507e865eb8e51b45af5f3db81600b1495e6dd1cf01a69466cf11441b5d0b3a42da9bac1bf4591736749dbfba38542bf2504089603654d884956bc120759ae033e1740b352c29d8f69b47bc1bf2502116e20423161fb1ca08b03d2303d0b9f5b50a142ee01057d90f0704de2a448aeff31fb80e5c937f2715c2c89b072e50d4b5f522feff295696d7b959f50167303db4cb3dcec5ee57e049fd877a170cbb1163af1c98afdfcce54cdbaa2837410c82bb82275eff73fb614caa7df13831f979debf0f922303bff3f0333c5df3ddd279d6ae43eae64fb9af21146ab840f58b6faea4e4941dbf541d54dc4247fd6d04e241e63394ce8ad19e830ef9398462d39ee6472afa87787cf3a411255b6fc3a861c6a3f85f956ca6a0ecbbe73652b22221fcd3abef03e269e043460a34e449505aad4ff34943f5ff1d1de0417da4ac9143038a99f7ff564fdc05838b68417c0501dfdef62a55b8f4faa35f9c029003835180542825b6549f8aa6f2f99939dfabd15a56bbc1fe9581c692fe5fdcf2bc8a02d6cfef6623c7d6b751170893ac1ca7d2f4daf04a101ba63ed27b7ab72e23956fb884cdde33ed3168c1d3741a2e1b010a849ff924079fde7dee93ef5d6b62ab4b91c0cd8d13a416bf0c3e3eb7b66c81b1b9d0fc476ad7e380af695055f4278c9b23593d36462cab5362db47e5da8a6c9c163d8a4b449d1e9d42a5a57203bdc192c86a7878c3e25fcef843e3e90941fe499e8e44f6affdde4a9236cb524c52f7a37bca3a146a3c2daf6e4f6360b6d0eb3acec3a28456390d9bc14e40ecc87f7ed031ed5bcc3e4debc03b6c782d20963459bb17bcc352b6b9a205419cc230e1095cb09f71d424faf8c0fb9bb5340fe88266299517788de0fbb83b2a30d7f74911fcbb6ed61563528993ae4ce01e44865edbcceb489a443537ed279118f8164611f223330948e5f3f9a0402d645e5450891a955635e963db9d01f1267cb13b6bc6d6600ef44bb62e469d3936aea8eb00c671f8e1a5935c3258af4f9d22ed78ca751ca892a37ab6cb01605367dcd8a1e75b637186a8d8d9e43175e4a3e99247e099f722e712dee62f34ff312d4b453cdff785a2c18595d95484a44c76c9443570532e319a9ae7714e68f18e41270f029676d3f200369f1594c33ebe875b7eeb046448a187e0bd2382b8f3b014d165a2cb1bc125776e6d5b12b2ae1f42aaa6f21b08ca34177e03bca84c6811724b9c36b73d49c0aefe3ab327c66549b5cdce4e6002affff09d7f46dbbb0c0ffc7b9571efdf50e4aa2e77583d82bbc9baa6b1d40291fb49f3e17877669b73e0d13faec611927dc8f643837ed0eaa0ed5b93e0513d5fe1c39ade7ba110ba980fc13cd7d99e61cd0a837906ac44d96d74a4faa5c13ebde92e097bcd5b250c1328277d83809c288e928b36d076e6773996460da8e25a14e2a32b607d1192b6db4f4b6ff4f248809584673db4930c56351b928683f317dabfb57bbd64e837a0ddd427367219543b99cad8cdfc150e6ec99354fb2a900f3e5a6496e50b8246af57ce47bf488d6dab07d4d244f8edfe3831a72da099c9ffbbf555608e609575530859c244a4169089800bb5f7bc58c8e8df6c790dabecc1ddb7c2abf47d94c5b1339775997802e9ae3bb7479cce4c9cc0a89c332d054021a1fdf645d0004404a90f84d8d7b996990668713bb9f4df46c20536cde58d29f770b110060c18c4aeb477c62ca8deac9847d40d9d5043d50d1bfcfe2142d8a15ece2ca4d05d8758152c0c19fc5b3503802faf68489c85fa851c0b7985beaa3e1dad83473c883c65f081b2bbee02861c6d3a36db97a834561e47e5e31340b563501423a693ab31008adb70f461fa756837a29b3214a63e406e898fb439834c112f41abff6cf8bc3ae7b82923b6d76afd6f189645653f7006565409387e77b089c6b2a85a19109ffe64ca074ab60029d9960aec6dc537235f65d7c680864eaffd0c33c7c695f515bd8b44a342977b420fba2681b882fb3aca9534fe09dec7ca0494761cf2623a0f8e0c1d2f9730a6a658ce6154da040aca7725c6e0f85b27ef9ce0c706b927b6791f2f25a5be5a568d289c3eafaf42d1a9cd744a1e650f2f18a264b13760abea9d934c147d8d12aa66744554bd599bd2be597a60686e0cfab0ad685dce015d35e258535984393904eb3a3686d73e5e0f7034519f3514e0f26600c97090397ff34f4585aba753dd2717bd1a12b0b34b5bc928c26d20133322f605ff722594b6b3988587a19c3ddaa2a01a7ce63d57908c07975930135f58994be4c97ac18d6f390c362f0a8e9930d0dccec63a9b2a9d80dcc8f43daf83644a8bc4307b8e832edfbc94a18410c612648847dd3b9400720022835b3845dad4be594233c238aa842c921b20b7aaadc5a222f76e65b8bc514d3d5874d18882729fb98ba3b28089081056bf1a8da480ba1fccec488ebf06cf7ae63e90a78908f98860b56fccd011fa7e34007b58caa690f02e62b2f7dd8fc4d0f5aa9eac19359e3bb95c3e32b2d1ce2aeb53587235e39776cdc86baf728970677003c647eb3d6050c2718e0bce4f3ba4b936f2d4a516e73cd45eeca9f4a401ec95ab409cdc3e50c90f66c1e85aff0195d6193256d08fc2cb0fc0fa3079cc32208b981357243c53a81faac2e27b67580f9968a9b944fabb1e6b2bd6a1c564aea2467e96a9f8c5b24bcebfce1a8cb95cb66e3b65d1c748995411da7b178371a747d3be308743b9cc76ee9d720a187ca16ee7c70d837bf90bcd0099adbaa0f97dfdb0c0667c1f15135cfd18274b61131a09db7f6cd08d436e55ca5b37a1811da3524c779f21c66a47f9e6869d75f12efb9b127937167417e712b40d65cb628246844114411badf34f8d49a02ae30dccc1ac5277ecd4321bb7896bddbc4a09ec181","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
