<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b168af790be60b661fd47758f9a228aec8904a9edbf705ce64a40720dbfcee320281a34768d885c3bcfddcdb61be6083d73720bbc048829585c6227741a59ae46f120cf95b9de3864d6dec0481212a03e306480e77604b69a4fb6c82ddcc8428f7964f82db6ee5c9ffe95bfbcb256e0da2c0e6a5940f130ede12e30aef7fba23a7216e1c335c8203dda3d6285bea7c3edccec879f15c32cc07b84e45cf14522ba6b000a1b773b5b4e3456090b8a2d88a2dd97da8bef5cfa7de3470145699428cd97cbba31ef0c0b6b1f1063a0a222c0617176ae1259f5104e8249abd4719f5d72cbf0371f1f85d29f95a135279b5473e40938c7933dcfdb1e2cca437e48a848957d05a8939c2fac38f86b84b85ef683e2dad3950ab4539ba2ac23daa9db16832462847aff35d934d7b359784b26ecf81671235cff732cf9e3925b2ab0b22e6637f89d7db2143d7ab44a4cc403ecaa5a8a7d0ab32c6fa95a688cfcad5430a7ccafbb261396860144e902ba14303ef4f1658c5ebc83c4201655c712065883a7c03ba8ac28d58ded6ef237abe54e5a9df0e57b99b716f71ed29751795d8796ecc7b5eaa8d2007d27a01736409d0efee98031fd88ae17a8586416219faf12ee66ec0f9098ad4b84b99df9cd2e31589fb13a9ed73f32e480b738767a6741672fe0c4584a1abd6c55220696ea368af78f6b8e581e4ed3b913de729bd787e26e471ddcb425b12e0ae23e0a5018cc13f8a93f84416f94fdd5aad6db3f29876ff40defa04f265b2c3af9a0d6a8424d9911dd131147e54eda2fb63b4fd78efc030cf0d3882c9c3256b1fd83b5675ce0afd0525bda20796c4e595893d8793e05a847f7270de34eb58e069db050bf512c5b2e7bd71aed4bc8b111072d606c164e0f568b8bd5cec578cb258cd10ead6885354116b8355f4653aa4820763b24f7022cf43198424ac90c53883715958bc832870581cb0be413f84c6509889c9275833f598d042e80bb2392d64346be9c50dfd7cda4bdac57755387052441d9d71055e831029256e06ff6c90eec8d1d9c20cffc2793660e1cb94ad912842baf34756ddefdad63ba57a4b371b0645248bdb85f69ee29ff8d501f78314ae0684e8b15094737935613b0d93372b8b64e31814110ea367ece3c457246af931053889704ddcbd38b65d3ea8cb2dfbbdad72200d185b14ee7054acad385270d278e20858ec4c23ecb878a01fd934395c0f4603ba0d9c128669e2be33ae6fd73a80a56716628f8fb30f9dc87814a157e0dd59faf84f62dfb8020e9bd5700a6717b21872ba4d36b5404aa1c6d6a96520d7ea80bb25aabf8c2cddfbd44df9c8e2e24248bee3d84d95e0d99fb3758f2b30e724c24e80a8a4adc2a8de4acbf4df0be4fe6f5ff4a60b3e5d97af0e8d052a18fa4c121c968e433edc147a0d9bf7201d6cca0af50023762cc644e84480a34460f30954fccde2225c0210f441d0dcd1451cd9cf80bae79dd442da33e24a19ab86e3d7ee962d5afcb66f42f60c5624a3e6971e4b48de077721aff76881c4ea87eb67291762cc6275627bbc285886fbead7964880207dded83d7b12958dd8aa429f0472b2ac2429303972a34ae3e5ca4dcbf20ea60cb8613efcd33f0b9bff27ffd852cb390c965a28d5ebbfd740e5a8f2a64f254d471387adfce5abd15e7b2b21d7260d7709ffc5ed8dcb2585208affc23ee08d61d8a0375611fe81852d0e8d2702b3c5c72b78ce23a62767b3b139518c9fa1b1935ed7508d6fbede06a47c1f33caebd516bb40a79c8e3e9478373bfd375f90e9f14e4382938b18173552cbf6d60a1c33d918013098826f1b09a25657112b5d331d47fcf0e91d52511f17b21023de9b1a76bc7dd36b69263ce0b2a212562383089ddb98539248d92113182fb10fb5370aded6907152ab588511aa7602d8266e0d1fc4561f918b5c41e41548ab5238d93010c620782f43bf1a5967961534b0d7f0c240b05c79472152fc968543c4346b7a75e934e06f4269af2a5080b66e5663526e4348d776c13901b811701f0b892f53715a4712ca13019fe410afeba35be84da5497ae150b2915c8729616ddd355ec6190b8f4c9d8a085dc1583d2f23a25dcb57013c9a9293319be3e8b8e6a6c08b0fd0973b5761d9444052ff0fb857c654db4c9e5525fbc8f3d261de87aa3e33b3b0f2a12551186c2f8006eeb0e17ee429803b4933a308dd63d5504429f8cff89bbe8068a06afba7c07657c4ab0f520ea35e9d042f639f66e34c7328a64e80abd05342026f8072a710c94d9327802b02fe7d2911496a5e52e575bed497e865df7c864beb99a72b46295359c61ee74995e0ce83e1434a3a96409906c726af7e33f2f1de2523a20b306d63a9ea945ac972d5466c4bf9f878a302d376a607ee2a287ad182cb1c4a58a9e3971b9824c9be05f485e79702c02a8d99761dcd4b335d1decfdb64bc60cc75d2e028b81ba2a39ae7bfea9ac36aaf111c5b397c1d9a43050765ae68e7a76f2ed0aa087d855811008734eef62a7bc59e68e9e44f0a98478eccc83d72a1d2ac47df408cc4a94f7e8eafa9010267309d58ab0d3c4617d9dd06c45a8eedcd03f4a453a021d6f15eb82f85e4cd71ff28410e64da2f2b2557e8e78669c7d3d7c5d0f1c49dd569921b5693518c7afef4d4ce2e81def350826cbf39f2e8c66a4aa07eda11da05ddaa3d3589a34618ef0c0bce98c1e8de7ee43824bec65710d4904f01ae6f0e119fd9cb53a3113434e0ee33d37e811733d5c9ac95b850dcccc3293a544ebd6b6c131ec2fed01ba42a542fc98e471db4754672ef1ef635849d81fb4cafa086cf81ef7d78dd11d6947e61e3cc27c819b99c2618bd59d2ff2158352a51e2634c44b426c397c1a6ed530fc5f8db93b26f660ccef31ea3ec83cf077d97a1b52600e97d2304cc0bb24bc4293ebb6aedc8d0e3a1a7305ce267d6f87bedcec7a2cd7a725d899bfc803e04f0e246588775ea3b5940cbf871cef917dd11448c02dcd4835e1fb94387822427b5b7053db0f484194b019e68f12c054bb16f6561132e6990dc3ad0f31bce24678c4fc9857d802c6c5a7c8d4d393d490dc0ddaa40fb8da96d4b634e8a99226b9384d31f4b6a27ec2ecdad6658d13b83112e500694bbf103d861dbc03d3cfd27b9370a472634b8dba9379c9ca67aadb993e8cccb15fe11896a39223024d2cdb73d3ce6e8dd3f01f61b414b2676d223876a4340e5d896802d68aff128c343075ab92c7803fb833b8d267ec8b95822a04f37d613bfa19b9996dc1218f4b9f9c19c92a317d6239e6111d080c26625637388d367b7e7fbfb519288d06cb388806ede31023cb27077ad71abcaf2eea7b48c58bda8c0f5d392cc593a04b328f0867598645f911d95a4faf20e9b651f25027e1ec97a64c2a40d260dc8a323d55fa7239221716a0acc50eb81f15998956f9773b3880e70b5b434064521f92f84741b8da03d56d4bd6ba05de9fafab10fca3de2ae6c8a48f4711cf3ffb54f2d69f2cb9115216b0d11d7c89c9a0fb83e331a2ddf9895b35a543ecfb87c2f3fa99893a5f0c3cb5874a78851d38fd5aaa6ae7489982fb4c4b03958ed3b81ede87ae69aa3248792e4cd7c64459fb5798044763a1d5e90d33cf98034c126748026e986dbfe0f86fc7524a576f86c959b7feb4532e6d1267f74f80b0a3bbdf7c95017eec886adddeac998b8c5e5eba346c5a68569e4f7b6066522ae79c836acb6c2356cc5989eb371ec6529f9eb0f066ffacda3ac6b4968bc9fa030e28c51e2cf207742505513e0a8e13e6ae4be8bb6ed48b305f8ff525fc929e4b2c2e3afe48357295f7aed16e51a66bb2edbfa4bed92dfe6405ef32d2f89f319171079556ce0877b3a0be61992b9423fc6412bb28f2451b8a8bbe430d7e7e9f748c52d198e192bf9900bc7893c4956ebb7d7d3b6c2ff18952114c0fc0b265558b168b78313b4b5e80547c738bda778710466a8ce255a7cff4c7785f09c76f50cd9fb2488fbfb59fe77daf28f1d15788621e68f8c818cd1811ab59212bd075a07fd1414b78e9a16d5b7c3c6a54e547d4bd62a4463a6bc72754050879531e4bb3292aa5f46f811908681fbe843b32b85b15b793750dc81c944a5afcdbcbd98cee60d1d9e760654d43e73f28ba51a7b1596e28460708ae5cd5d4151a745882c67b0077aaaf85c3eea4706a04d00eca88a930723a660a50466248b2f86a1f99152749108c5b826eb383f2708258b70fda157a5cd7e154b2022db09bbb6cd3c6089da4894ab8854e3a7ff7f80f9d12c0a73ebe92ceaf5d38c159a9e96bd834644ed0c99adbf27873dd5de358a822bc6f502e60ec3ed477762f6b97052dd40469b0304479bca5a6af1414349346fe386abe8bef8844112a570ee171970a822376504b3c7df243cb00b5f3688e70f699b2a57507b708153e208585625c36eed07c9a8e8fe23ed9f8e9e792a0501a2d56a9ca96e27c13e81d45c0d47ae2937b36a4db5f7214d24b881d5b0bf421424a5bb91df4c89a37176f6a033580ff91d87274537890b7a155b46f23a21c1cdf7e98fa90971a05793ba833a777311f872d4de7bd5365078e649fa7269b469926c0ed0dc7955da397e23bbfbf60f443d1de366144f9cde1458349913397bb7d3f9bf8e95762cedf439c88aa6941c41c6486bdf9eedfd8a07a1275778cbdfde28b06e43799007aec88024e05223ef0c2df99b64fb282170784205d952fd11f76189546ba2eac15b39b858211b919eb7024c70e47a1d81ed9a78db8ddd806d8213e7a0a418201b9cacb70ec49d68be8c923b6922c07ffaefd9cf1c3f507c6be9407ec210c72c984b3bd1322d9190a248db6dedb61a63411d1f61fb422da2a643c1e29d4574f04dd33ae6c9d8a8d32d2b87a0c3551bfcbf3fe13ec0687ccc8818f480a8e4dc265ebdf27f0215b59218f2f6af0728482bcbb4f87a9c8897769eccf6f9233109aa87021acab29f956f7d6a62f46618a1e329f0c2c5192ff5f407d6d221d17283d2143caa5f7bf2163949db41cee4952d3ebb7cac8e50ef3d536a4ba4ed31dc25441f96f329aab0493d9a705e3d73f1890a3ca18d4e7a16dac9b2021732fb661022ddc6a4726fe65e51db67cdadf2c4f0cd071212dea9589b8f808c54eff090ec681841bfe849fb0a9da6867229ff3e74af2cc373c565b701810972f10960797fc3c3eeff79e8574d90ef7309bc2b1b771f50cdf23a8f2a592347e7a5449b148980a7e44edb3d8bab477f1627226bef3dc14c467c53fbfd055695dc94ea17956405d2a6d1578fa3db8908a9101b248de5ade474eb35170727d0d5d8dad50f705f2d4739bbd44902eabd1f117b2cecfea1d8c6400343c0798703ff19371934428d60fbe6e89a3c68349c3c323c8b072d356ccbac04722846af672fc65de808fcfb9f6410a7c53a370947588a34ef2219bf53940c7dd0b26f6a34fec61221ae83065dcbe17d4ad05929295023810c2bed42040e3a171c77926c9ae0458d77902bd48646abaeba61751a566678b8804a7ddf7d464182ca87c6f622e16db8a36dbfaa38e517cd06e07c5b742eda4ea962752210b6a26a6afdaf38b9c036b1b23fb815814b55f0f63fdd1264de0078c9eee40b98ee8ee4badd660040cfc41c27fe51c38b02101213d2d446f6eddb09f990f9a2f93abb0f1c56c97cc3f982ec971c72d5f33730b26fca073ff47ab31bfc41c6f1c81208d910e5be5e696917a5d4ba2062174d80bae725bd7ebc948301e79e1e2434f88fb388cc7a3a4995fe8d5e8436da5eecc9aa98360178cabb54fbe8118e9fb4abcd5176e7e274e73f842b32949b43083a703c92e6b1704d2a7abe222067a66e9ea7f9cab3a7efaa4b03c25486a91d0c9d5985a138d5318945a5b653a19a1c4982b05c9ac485f0a3215e5659b12c6e353e4c3e743e2c241cfc749f969cc5c9822e575139d56f2aa8d67977f5081d0d5689d0ac38edbc45a95ea9d74131dd26b6c55d5c6eb04d278b0b0585904d124e024dea5d4cd3754a5c74aeb5472d407a3cda74f6647d591b440cbafe8c0dff7be33e7686a5bc87464ad1f72d07038e85a2bb6756bbde0a09af95e8b7ce5456c0dbfebd2057e75f4ed04fe99a68f97701009f597b396c5169a89d312be0dcb5977d06fa447ab669f9507170ba38f23076f55fb0567a9d6e1d4b11657d72b47a7a7e4861d8863decbe4ec6cc35b4026195e609f0b1288c1d40f0fd3ef3f2ed9b5bb1b5ea56af70f9962465a0b0922ae628c3797d16652c8fd8c8ec0fd44347e88fc308de287cd93e73afae8b9c2d803a29bb1407167940fb67c7784abf448c21206a3047c49907d5445abbd139759b3bca3773f304d9c0f9a3f7f8378fa5b1ac35e64e9409f6c1784c55d19848714d092ecb6910e92a900c36b11a84ca681e122863300afeadbe3865bf221c0f415696dc296bd4c04bf9ada6ae878dd9c132a13245cd0066de2f710593ab04ee160ead3edaead781b35afbcec7a74d0c465ffe4c60995e561dee9e83058bd9c37a11a4f93b39f413d716ba02bcecb6013a0980f7c1160da21030361401a3c6c6dc93ee892e4c61fe3cbdd37c782069ae2dbce05454142621c88e21e79a9e85479472f736febd0d8ff9441f6795c871c04cf0ec5ac04c24722f58d6baece85b43d77eff1b0e5fde78048d22e12ed5628fc227d7e044b41aae4aeeb6b71840f7c160f8f097fae009911b31269e8f0c3ef73cdda9018f46047d52724a4ab63a710bdde8cb80c540bb0ff561f338687d11f2fc23a0c891a3e5ed83ddf19c8a6f42b70838f548b59e63714a7c98186863f07775ef6b66b0eb6006e5f1ae03b15ba12f53e6572ac94ec692cf270a8989d683971c16740e59fdf804a7f842c5e4b675d8c988dc7d008c33f1ce26af6aedbf37ac5ed5334417305259a597b374d5bd3be2edaaea6e5d6368a6dd161910611edf6d7223b7a9276c85798a03bb30416498720b83f0b55a834cb109872b5101e5fc82cb05fcec4c4b1b5ddd3208163e000e0fc5531e2c869698f7489e8fe53c9bcd20055dc1c03364c01049fb8be7d31ec8045385f33e235238de1672ac89254fe47fa5220b19b5f562bb1d6c4a8bf0bdedbc3aa9e7fbfc9879d2f6df00de8092b29fe52232d29a985b0b282f147f3289cea9952e03e3a09ebb0f02f8db923d59ac8a29867563da9255612b43e1134f41356630972030d2f3e8a0872062c229a18631374ff172c43394b7e42a64892053631b0000c65d81b76f33dc0bfed697c99486f48475044349fdd7b4916ba684e0f8c437e80c67ae9f854e8f448b157218cb5e5572de04d7f5852cee736321944ed99de03c7fecef2486e641e8a9cc31a154a1eeed58805f12bb2bde96b174c35420bc7b6b4637045be3634eafb2bf39c2739b1a08af1e0efef1e31bb2563e6f0667a6e6dc65ce785510191a5eb971797630a24392310486d7443541f3832fe479102f2c3fc2c7a18ba245e96148778aa2749a373a17d43693e85f8c8b9263abe21f347e31e2e59a34dfe0d5b9ac9da4ab31988c07ecf31a31e58bc19ef0a83c2a940a6836108d6f8df2e352f49047bf8987a0d4ed3627dec26b0fd1042bdcdc7adab2eb67543e17f4da65b17ff07bcafe41d810df51c31d05281a5f1ba56e4edf9c471098e18986bbff9e657e17b17e1c2c7269aa7e268d86cdba2d2f6f714cab59dddf1f12980414b184205c27d270e7fd8e33222ca98139b7ab01a312456f2aaadffdc05ad86598a22b61f8f0d5eb974592b4ea8ead48bc42f1f96d8bd5ef6bcfa8d3abcf181aca6605a5c9aa171b57d4f4384a13a5747ee59931fc5ccc2b2019e99ae4c60bb0e40f8a7836724f3fb87e096a4646bf395f95eaef6b0fdf734ef987ad8c5f3667f4d7527145f38d054bfc174f4701f612c2721d571fc66f2d5016baa75bac6d2c43aabc74d0f1b3cb56d27d3e37fa88f094d4049652ec2ffc037f3e4604200190c5852d732afa4af69aa53553243cae9f5eefa713e19cbc12b1b5a583b0f503a545f87deaef4b890bf860865e94c379123834b58c52cd80e282e0a88ff51469db3d8f9979d7eadcb57bd3555596deb5781a13d729ca4e5ca89979c9e8d1d0802c6e56cd9f83f4805194b351023b31ec922a07da6063021902a3b3fc53859ffbdf07c33f5e5b585c196ab9457598f623dd32e12314ade687d8b711ef61d3aa56416bc9318683206499c480cda014be37aaea6ea4d9f8e636d6e7028b9aad0ef9b34cd92126478194603f618fee9186642c8a0a49c4df67cb44836e6927cb7502db92bd5f777997fb452a6c8207216951fca022e335360416a5f3f76b5f727288c960004c64bd622d445a7d21532b035181724e965d1d1163dc72feb6bac812c000a2ccfb4b91f972a8ca0a090616baa3afd4bd8778aef6f841a9bc64caa78c6dba78f1ef81c1f2a464f929ce809d0137915d48f1bb224499ec26d6a2cdfc6f97e3012239a3857e2d26a2378bc4be7ebe7e8394f946a3cac32c796a2035ee6c8e99575a1f8f4510cf560440c34c686b92b427178056571888377910f3d714103a64ca4f68493ab0fbe7734533fdd55b27e6285ed53a0f1d17fbfd0a4b51d43c7827a0308e6672edd931ed27cc84a1898e3f4ae20cd45d989335a8e8e6477dcb609edb66b8867e8b23710c5619a23defa7dcc985e146fa6bcd049b86efac2468e783fc447389e4be33b4fc72105d317041b5fecf6c809d2c5831e17b7ef0207eb28dd2c1bcd37f7362dfad3329c07df8618b6153027273bcd7e258294e11faaaacda309a3eadd8c80101df2dd6649e1f4d6068c3e4259faa0f29596fd98a6fdb7fbbb6aa50e14395d6826671cad14344a3899f64f60cb4a71fad74df01ce7ff9726958f021da62fc80785eb5ec6a0cc09ab7b7628f9a6aaf30daefa00ad72fad9e739122a1246e8d053655b830158daa9af7734eab976d823699cde91a599071e2584ebb495fb4dd95ba80d5861626edf5dea989af6d01b891ecf86319075d0276fec94a64e253e13b0903920a9ab8e5d08c9cdff3a79db5ed57d4533b7a796890e002909dd0eb49247b475050d57b337b1a5aa69293ea7cb34afa83f4fa285d968feec0483a7df12c276e8977b2877d81997ebe876b6c12128505cd921b34692260a6a6a4102c9c7b1fabef46e06db44b526359f0340d7a8fa29f5fc90629969d3f5ac1222e5170b172ccad60826c808be80e70b0127cd7b6eaa0ea5d343809cfab310a9579b70c03d8a232bfb3592ab18b6733a3bc82982f3b2ae672de964d6ac3796bf01824acffcae3b1becfe8b25b8d569f4f7295e85ce926b5cd1b7a4566fcb6417c044ab0b9141a28d6321e6ab3db0f5bcedfe61a28b23a6e8a57146c222640dff7f2c1e90ab5c302db5d9c7b72fec3fa481f3dc4ad889205fd376869d10aa6dcf4b3c1500b88a89f9ef19bb6a079ca0f4d75b9f3b0f81f4a8817c4d6fe5bb9b148cc3db898e655334f6a9fe41a15aa5ca3ecf34aed6786a6c901cc0051df907569a3bd04fb396033fac6a326b0585eae308f6ef45451746cb4e59b07a2e9f730dba31df814bac912cedd3a09abd7bb709608869e883e720ab23dbf12e002ef58cc4743cb134d901b39c973f34fb436fb90485747e37d31aedee7ca835d042d491799a6c4a86498ad4f12a2c598fc178511d79c2bbffc2deebc2c3680ef7d58a3ceaffb531b442149eb799edd5f5d53b5868ea3f8d7da8dd8b550c19f2f5a04230891cd5c2ec89ae94c55ec80f6e70e80b77dc553f94390680f26b5b0d10420bccfab9ca7cf3851cd2ca60f3db52524ffc007b99185d64f2408b9a66a67f894a238aec569bde7cb9de910ac7ffcbdf90642ae7a0f1644583d3305405eb00a510301936353563a03a388ba2c0a3a41221c9967360da6d6254ef8d359d1fe83a9ffe22b67633248a1a09649f40d11b8a0a1393818313bd5998175a8a5e44efa8c362ef0d3e95d072f5d04ba579c7abad06d928e2807e5e98e5b392fabee28cf845f6bed2bb929beb17af13f8abf87adf1d13db9d67f6b7d96118cddff9561b57081f25f96e25e69a67cc2edd7b74bbc5346db34ee6a15e618aa364093f648a3780127df05de112b98b94c51d5f2a88b0e6c97670bbdd10b08a7f0b5fc1b2665083ed0ae5f5428770a0fc26ff9faa2a64553985d52f7cbcfdd90fc3a2eecf6da59f51bc13247b9a200d51ba43aeb3b13287f1383b5d3b6d8558e2a8659cd88706ed7d36f1654a328ff892d03420ebbb9ba1d21cde50cac494fe78a8e93af48449f81fe57f69fcb7429efece51bf4a8e5919a90e6fd7e1174c56e1d9e79ca773aa06dcaf8e0fc077d3f7e4809a2059aa25a5932850b06a385dc318728d37a8a661cf47befdbc26535c4fe4a60b2b64746eb634dbb9e10bf1d35ba35c54f86419eb0856a279130957f7681f645ab91202972bb82310849a49ba35ca943cd33480edded4759ede897c403dc1ea9146168ef39ca21671c94f164731b8d018929cd7fc8df269fc3036b9d3335d206c99b6788ec73d214f1ec70b7d6b3a4801b18718ddffd265d0a9ec65cc73321c1a4735de6b0e66c890ceffbc7c693de874a63be5f52db8218bac9c7563c095d19f36282bfd5c34962d91c11df977f8aec993fdebdb976eec2f5e90565a5bae97ab958b29c44f1053dfe278b64339ddde565717f9a60261fbefcaad4134572ba2328dbb2c5d5ba6545d63ea76ff437ade2bb6fa7538b2ce18f4e094b43de563c1060fda0b16d9cb98bcbfce9b0866a8dda0f37bb79c5203083e0e21016a4d8f16cb619afdb31d247e99037b9d190d26771fff85ebbbb943c12f4ad00deb2ea06cc3a0b45fd75260f1136073fc857d9da6704f2207387e85d00855060372f529606377533e14ad300933d33774df49f38648088614889fb03a4f660103eac4c758c0d4e09d8242e4abfe0b6452c67d11d0e9d18b4df85a8a57f5994991fdc8ac9e1f3f6e3a8fe41f6e591775b21f578b5398ef9978542c41015454397c81c9350f8951b02d25a86399ad194dd39b465184cccc16bbffcb23e3aee5b06cef086567cf22f3ba0d6651d42ec8f65b59a462d675fb93aff9bfd9d3056da653915528244609ed5d2d1a47bb06c4d4b63b4f0e8b63ecb14dbe449bf7e0d131a7e2080010414c2230a7f8a253c2ef2517ffe81b2ca87895109809a25385c0dadbad100b6be27ff8f572aaf0cf6037fb148c89dfe2427466c1c18bab690a8a2bba5ec8c0574dfea17a3c1275a02f5323e84853d6cd4d3314c3278d4dc092102ecf3aa8bee990025a9f26c7e374ab886f5d411dcc024fe0dd2a09120c75d590ef8fe68b62d8f3351838c97c210e38f34e894ef9fccc84fa0f34f281bf99ca8490de04ccd1c0ec21753c6d83d3a4dea588dab3c305488292f06c6e3fdcd36cbfb7c8eaf1766bad7a6636cd772355e628417ee680124be057d210a8750c61a5cd179fcb257c17c492c1aa542b7e442de30b4258e0615d703e00aff48eb41a9d0e7716cc26cd6f34faa2347ed31e8c78b480ddfc4369edcd116562ca290855a6fb8a1c869256793b738d2ec99ec0313587edb3ee36fd762e0f0f6fef61a1959e119cd44b7ec1195def1e11e883b29ead2227bdcefc778172d45a96854514d54c5188281a6f711b17ebf47d4ee1f63619d348f73bde8d4fc3b12ad76139db7ec2792482cf4993e4d05d0bcb9f1a1c1ec70047d67b31a781d10bcafa9185f6d2900c53805cb1921c3f9002855913f8b529fc09c96fc86f2493a8c0bf7351a123a7660147ebce88bc33543d8d0cb2491964ff9c5e68fe93fb3f05fb61fabc67d1d2906268b30a70f62609f5987dc8ea35ebb93815a9da6b8de70cd85faea5259ff59243f0199d104a51e0811022fd2e90ddff8bd4a27e0857babb04592423caa89cde4f467524bb2f8af1cee1c6d802e8aee79648b459f2e403d904325cb4c28f5b1f545c96ca9c98bbc8af58cf2e72069cd479c868c3e13c763435cbb41c50cd16ebed6b75f28fba7e3096769ded7120cb0be3eb1342436c380d5cea15d1bf27b156f1467c5090cdc201bc67a3ca2377daedf516238222111f83058ed1c97039faac92b934f23fad5c8d04e21a0677957fb78ae50857d4652c92b8fe93da312e34626ab4bfdb724340a084cd22414a0a821284044858005b8fb3e09d6e4fc6cbd9f7342058b1a24880b849ff650b83235d4ede8b42232238e6c1e25df8ae0ecf4be33f3c7b00c0c743db82112e71448381c6f6370ca4ff3946f2a19b784e29d192b36cb2f0c1dd22eb9a9e2a0f8f4d47b60468c40220418ea4a65801713f3aa315fc2ca06d630ad487027f7d11e869dbe6a47f14e0b5440e932326697d018109c738b47241825e317634bb537b7adb7b1c6adfd8d0e283729f643327a3a6c640761b5eb2624c5df044f51273c488e0cce60f0b097d9380328cda4764d400ded0f2f1bc4bc9cb06320d3f8da920d0e32dabb1e425bb96b215f17a1bdcab6d6e4630f5fc771409f3294dad9dfb899827b61e83628b12a5c3d79a09c39a1865e2eec05261c94679a093b573c9f81ab98c91e47fd218fd168035a0baff8bd3eebddbf6a1eceda828d2df1c70b3b929c723c3016424c033c318fd4b3e4f62f35614a3e0c5510f501eeba8db088ba93f8e4c29de7c2977931076adba71967fef1228a80937b7e4f47612e57ad44ee06d62d7969f4b9f9307936ad526f83d60b2ff70ef6cde73544ba7dcc14101600f465fb94acadde93aa4d537add20fe597f1f2df89ea1130d09762d2d7ec2f2e0dc412c0c6dc770f6ccf5ce9f21ee67267f9bdf28c215d38d789b5ec78c3bace854ca6a27560bd6fda8e86f1f712fe37b7b7ca8f13dd9d4c0ad1632d8281e24bfb96908dc4b09dcbf65d6157c1323e5e046755e487108db3d529914253bc13978b11a062b631f72012c6a15054339dc92f430403ce210afa97a84426aeac42dfc75cc5be21a309d5a84c7e0f85d6d2ec53d25792dff633273d791de00097649223ccd058d67623ba84d7870aebc140dbf58e3992f1441a4ae77eeed3e66c522f5b415b084a04274e40fc8fc9fdacfcd5363ac0a0add8bed13cca5d1a31370fb28e9d84c57d23b5a2e4c6bdd3f6d1f340661ddeb254c239c5f6ec28835618e3699e050ac53b067e26f3b434c329c9342df1086a314c8762ac9d20d484b39c2fe01da2d4dae8bd21ba7980cf44b7e8db81a7d9fcacee568467baf39530543d175917e86c6a210ee81dd6b08da92512e739cd3f9a902f245cec9bb6cfa731857f5e1de0b2bbcec39d0ac2348681d505d0f82cee73461e529a8925607215e739eeeeac7993f85ab87bf8583f454a35f7c1cf4f6efd008115fd83641fb11f8cbf5e0912a755057d15994c265a51fa80b81356f7754fa827afb159ccabad4a7efabf2d24f8393505348b4982f0970462cdfa8e6e9876a58e173553d3bb509110a87f696960398a46ad174b472d5f7dd2112504ccbbd27bde23728dcb4c19b43ff64ec977d0e130935ec6e7b5c265de1dcadbda78d581543f2e567cdd80f63b5c0bcc97577b793cbb9e24c4c9459fc690b362006993a6f31110ed55c27086f41ceddabd950fbf13805dbe415d693d08411b559f1ed61e1eb4a9ccf84b5f601541cff3f09c8bfc5517a929f90dce985ba1181d8c4970098df1ad866df2423055e89cdd0c20b70a3113434c21cfbb3e5e89c64a5dda19d50106a7753175ded2c04cdb66f4ad9145621bfb6669c4a24e62782f972bcac64c7abf7b9d5187ff6f4e87c98dbeca68160b844d5d6eb8892754c8d29006f5b487ef7791c5a60cffd161deba90e82c6fb2b142cbeac95b6c9030109da399acfa1b797afab5e4e0a91c7740482d2630bd9d076fca934086aa825c61f3e922956ab4457d1abc46c4d0f7785ba90ae351c90948fbb3252fed84013de6b6b92250bd7adbf057c7a08bfde20bb70f8bc16779972ea2b83d1f31fbb7edf997946c180b450cda0a157942d01e4cf6e13ca77d59fd68083f52535341cda381d96ba50a32295f5c6ef0af211e6187bf6de5b2566c1915a026855a2c244ca462b54438c11495131c827a1f36208a7079cec1625883e8c908f1be671b116ab0630c70f148d13a211d9f028d04a9ee2f2d2e59b8aced1b8c7868d21cb8f4ced48cc5922d9e04f464f891ab42eae9ae874a9a5eb6473fe735f64460e58bd901e98fd59c41ca87884ddf6f17f03cbcf9f41603907de98d5b9728957a8cf411d2d983ea183bb4394e547f6c85d7138377fbfcfe99b309b759ff6057446d81126840f129870a193e73a65d74c2cbee8665edc52160b900d78e2c9e0a7f50a2d7b30a4c0b8e27bac756b955c97069df8c8afef3529fbc69854e5fd5181f0fd4706ad2511bf03eb6bdc0fcfc3e7c1cb7b6db04564c7ef5ecd3efbb65bf94daffbcf902f5deed49a8c01bb8b849f1c6ae6f4656580f4913c90032bf5523add101a0db26dcc61ce47f74aa88a490950b77c051108a20f8f64f1c63d4c398ba738029c673cdc72aafc878ef1b57eea91ca9ef925f1fee4e0fc581130924234feec549380c7b8e4660dd5e9ab10c2ed3a8b7b5e0b824f434549be8b814ec3edaf838d300469a8da54042bc00c93c835280ace27b4e03a79bafbf28931e6c8b21f14af4fc294f914163c7899a0dbd682877d24cdb72795d4146354f6f00d677dd31cc984e17520bfbfd28c7c6ec58c9a4db427a39bf145aeaf1ab91678cb98564572f5fce66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
