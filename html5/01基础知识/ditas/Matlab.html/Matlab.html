<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2db668c9a54a8bbf11de2fe3607880ac103be9029b3d308e9ab8aabfa62f0df89295c57e3cf5ad583fc66a30316f98bbba078f8dd654b448049df8bdd710bcd5b8f8e28c0b392a61d74556275330f139303af8093c1bfe8b3a03864abe71c395b23785039d6e2c3372b29edad7c8281836f6289f9b34c749084dc973b68b3fa0d2d8af498367157cf5b28763cdc720d129587267dfd32396a74bd5318e7169effd929136ceff12358b83c9194c62a5e21c9eac1c66346f572748f96b84f27407ee8519d9823672cfabd55a24be4f6a3e87fa8982f80c67404e3a0df60c451f98d39d6f5e4bd155c3e7a43500ffe6f13b7e498d5de9c3fc94cf125d3efbfddce96268d5dafcbfdd579c482b46ce932558837d3cfbbfbfbb363c5e7136a536082141d43854ab6bb8f519bb34a880df26fecfc759d545e90b5cf0a54fb63efc72a67b775044d3cf73caf4eedbe0d84e3e3080952d726f25ea0f2f1a43bf4deb939c75738aa72c78a34ef2024997e887c5c86e4dfb2ceb19378e62719f4dd4f00df0fabc3101e5384f3e318a2d989d201bec526ef7a4e742813f5c8452a9ec6c0fcd0c386593b56b8c1f0ccce751ec95511d95afb369544d43e9ace6117dc1c2f80d0572754be756060681e7b5fd429049da8d9dbe4a974a27cb51d550c935f6e4cbd38239e3dfb6f4507eb1682467dacbf8cc47da71d7fe7cac9d36b73f1721cf6095cc0a0d994c7530c9508b68029b0d7b588ee86003d7b55f883b05313f31e6b6f84b124424a78336c135ac452c1d1326d0ff3ee95a1d70d58e834a7beb82544b754e8dd70fa283629189f28af051a9527a9ed0435447e4b395b206cac905b3f31fa3e0dffe10e7c88df47f885536cb92b67a3c8948d8684c559c9e501eda6f3b7364149ce27b1ad7586d9183ba2b3bbe6d7f75f83a1d89d70ecc53359a1bba2d07eccab3d69983b5f54e5f7334a890d3731edd73b0ce1a19b9438f910c68dce95f9f139219e64f54c6d84a357d2d305c23d9923399714c6e18eaa09eda84e903e36601905bb824074b2c8a5bb54b115a73f92c783c492c76757910a6ef335f683db311873cf26a7c0c02d820ac1d1b0e488fe465317179b983e0e204c5a5721b3262ff3ccffeb3bbf290a41d2a9f1af465c2c4875b379bc6c3466d4b7f3d3e190ee77efa8edb8b55ff141093154edd31f4f988af3003ad1f877d7e415469eb54a842a2cffea80405e22ba19ac20750887afff3ceee44a1c04b15533a2e6f51437261170bb1b1f14e5f73a3b949411ce8035a56a72485d493d72f6ba38797a8f1ee1221ac199642acd82acbdf09730b5612644c289c78229df043642a7b56cb13516cb482e68dd5b3df1a15fb9f9912969e14c10edc5c080e788688d33b82cdcce549791c95d293590b8840dddc3be5e1c0afb31e0c5f771922706fe92977556003e2c42594dc6a3a11f31070630bb9de79860251ac8549223366cebc4b14de0e5404318e11bc1a78d309f9b4da946d17980f438766214f24f3ad9e1318657b12efa5c8deae91d2d75711208d291b1ce8c217d21a3e3622482dec707c29b900458de2eff41c6cb995086899e20dc36e05ab6acfcbb0b9e41b9f2c433327ba47adeb97e50ad8d4dfb51a488461f6ef3c0ded21686fa2c4db7a5655dabac6f02faea7d279ebe1de7f52cdb30e2bfe46c80a8c2537f7c451eb1c6d576b24dd83b8f257baf1ebea852e52e0a6a99cf825cdefa9f55e854f09210e9de4c7f788874e47b2edf68c85ed692e1f63dee448a59c50733100de32e00130c4c905e8fe714dbbbfbb8c0cf82597f8914f766612725c497320dffd2b86b4f4b3a4dea8ef22db5b28ec0ddb8cf9c805edff9824049a18a7859835e1530fd5034b5f30c82a7abd1f54c29ace12b5b3431166e9e97df37e31dbb8de91683142c56364bf2d48487496e95ae851a3e33a248b11d8def6fd8f77eda5b7212d4819c5153bd6eee9d2c49cc38a7803652b7643a41af88051ec2176c0158c78fc4f39adbaf44e0d388c573aa9b7b1907e66dda0d6ebb60acc3ceb60a76a9fea7f17fd499d0d4d61da8ea6cdee18c7b279c4288ba6e84ae9616b4fa8ac07ec3755339620ebfc7c74d11da2413870a293958c23adca104e5071c580a1fbd657d401db215b33548ba0038fe50ec745ab9edcbb69f1415a0097908c48c873190133c72002e51879e976f0b1dc3e09dc7dcdd77d9ffa6dc8410bae76df822c1efe5aae7781718188918b99e21efd50eb218e5c7b94c05445338a67d99c06499cbee115eed6a82ba334b68c784f56292bdbbcd734f8a9d69598e9f22c02b8fbeb0624c862ca650a1889425762c8b3fa07bbf340208aca521f6627ab345da81210bd9a134e9b6617a6b589e06f5595e25248b127ff04bd04c91a0581426445f814f41abcb4198253aeede5278048ebfbf907e0c597c308748220b65fc0cb554729e96667e74775e577c10db5e606c5cfe157ed96980c7356591c989ad8c2afb1f6747cc8844b9443064c22d760785f1504b7be43148dd59690e089725f58dfa521e89f335f24735577c79fb5c39f0ea95c747f77d0db3625cb45b2a7de38cf7817d0b0862730a446282e50fb000950f4683c4a421faf6d756d60cbc3680f2fc714cf05b6631001cc98416af6e07b1ed43b0e7976abae92b9c6c5f3512079cc52293640f04560df2542dccbe0553ec2908b0b957f0c730f7feff66b7c13a6794b57201091b3a6081b91c98952075991dcdc10c67c7f647b5edc1b4c1cf5c66bfe9e35621e9b19d3fd1798ed11247681f6d39ce59044fff16b7ae84b13828caa101d97c599383f9a0430575bc9af51584899284d96806c6b2629f32931b05aa9bf7d696b4eadba17be7b083976996d81ddd0f11349725a41cc83a7f46c51ea50c762e881a9dab6b20b506f419ce0b62b3517cadbbce98c067ccd72bbe4db91ab4a60e7ffed1c2f45a7ef683b0b6152339066bcb104f822772aac35326567d4841ac1522001d9a526a5625bdea81fb6379dbbfa1035cf68db79baf18184b253e9ae0ef549cc2ec2d8e5fa937722d3e661f2e3bef61df011c6499fa9d29eeb7d253175f1f334e46f064660a86d6f956e34e3498b324d6af9ff6e26066b75b94cbd1ee4f4916c34fb6e8cb783073ecad08f6e40d283beaa3c12b7946cf9d63504a38a9f7f5a9e7bbdfbe3afb5d780630a515eaa736b3f085b2ec20fbedb56d2b0dc829b578d0313c5670ffe645b02b3d1e638c9a26e2afac1695c7f0c764c58499b3c1453253eabb5dc86cc4136f61be44748b281375c2487f5c70588fef980a4679faf405de07209bd2b424cb42214bafd148d1da45224235803e30549c1dd681bbdbcae845a79d57accbd0fb937c6473497f08d2ef0a521ac537e70103ca3b3021ddc53cb4ca9b72a58076fb34872fdf30d9c4e97ed5f16bd928bbd86130dc6ad78056d4e6ed9a7013098930bee46bfa0ab146ca6791d163d3d2bb7195d42ceda2cadebe1a0259ba31dcb1771d4d02550b4080e296155ebb2736686ed4caf10f1e18040eb9e6816e4520a012f6e43f08a0a4a23942f553ecc154798646144de7d638395a0e06e09af60af09a009e7851dedde4422c269bb20b54d0703bc0443a64ebc6d940b95c154e05741f0776d4a7e07ffcb10095a86fb2ff1eb8c139c86c4a7722709526209df5e62800bdabf81c1bd9ccd9514feb29280695ba752bf0de55d265393bd27e086285c0dce0a5735358bf00dfb2080512de8de9aac21e5c12a95ef0637c44087f0860db28dbcc1b362136f0edebf74b75c8e96caecfa779036d98ce582c14d9a8b93f4d797d529b4becea3c3d0189624f8a6cc425c609181142d1c78680ca5d2919022f6a523ad20a1bcff7c75e2f614a9bfb4d90851cb103db2a31d3c24b06c440144c92bffba852af313ffe28bd18c818fff6c3ec656973941b4cc4437e01b9dc4ac946254990d1b9a3e0a6aebab36c320116b302d1105749c1e7fadc731a5bab1cfd19a2ba27e7c1f77f93a8052b6cd42c518230fe9d2e5651c2d4f6a21f3fa1ecdb4c017b285c045ec3ecb85ec0757d6ffd4daa4bee03a540880a97731a033a139472185987a968e108acd1e1198075ad72fb598e06d7fb4568d22314e27ff92fcc39bcb6e120ae143ea7c7027ffe18d4a193b12c5d1208227a4e2f8e61b307b15a9ef1437edae40d2cf34fe69d4792e7b70e17c84106ea58cbe49b18f833ed3044a681f5fa5e69ae9800dd3f138f33fb6d039903e678ceaff71e223ed602272fe531edad022338202a6130a3494630dac9f756687eb6113eadea421da7de72ec182a7f306fd93c3b1d5f060f61788d8c9943a6cf79de77a466d803904ec4be533113654e4f9cd88ebf016a861c619d37082460a39f6555480883bd163dbea45bc90af03b205993f678b042ef86d94cb5517ad8b048b638f0655608ba18f2ccdd7041bee342a9b7aa64a6d14a89243b46d437ab03e7357f29c426f5bfaad518fbe68b73b9fc44b39cfbe0e1a3cd9f4faf9c969813dddc773bad7c1c80557c684a5c5bd6fa44ec7419935b4590383484143166a718b74403bd758071a19868c3bc5c3cce5691c5d6214c7549dd77a691da28392cdbb578d2e07e8fef7aa140aba1dd03d164c4d735eb967c981338f3f680f0efb97302ef9591686f2f5e8601fac5801622f99c1d3cb2115581afa3166e74352c49171111c9537b9b2255530d2040d65f29e257edd6fd46066db3c4d16997aad5a0a7872adb905bbf40a177e06cdba897f1ccdaa4da12de82e993a277014698b93aaf00bbebee602e9ea07d83527b2ba5a40163db454ff2c1d2368a5aa7f53656e641637f4b3255d6fb9a970b9a59d3a26e255cf78c483e7a45d1d853a4282c587bc9d6b80a468b9cc74bb3b30b713311ac91e7602f27ed49d2a1147a1c00706c62351a7f16e1cc6db6ffba82ee55693cea2ab177ec8cbeba093d1765d9f15b4eed0639cd26537516cff01d1cd634f53c7658de10951d2ee00a2c27361fac00618fad5833078332c4073c98b0e14092fbed0e0a9e4786f8aecceea3672cde04ba01acc20a4da7cb1281955cc0e3f464c4d826f9977368e9a27d9376a64bd0eacdc04c3c87f48c65f4f188925754fae63d7f9cb7e3c27bf15ef1db582b8e67f799a78aa985f5705297a9bfae80d4797d85b58c54983f41eb7101b8921bc7efecb13a2fb593580cc40bcdbccce9606752fed87247993adcef433092937f45a6be3927e4cb4c37ad63ff6b40f650cc79cc70c10caee42a96035176549ff5d421aee1efe2188f4e76c73bd8d880412eae1326dc0b6609226e4aee24d59a5073f37d5f8192dd4ebec4057f4cc4e8c95055cef989b921d655079dd070796a5b58ab566617dc485691bdfd649daf0ca4911da44fa514c2dcb3222896d2da096c575dabb1294eae25c2d00457cee5aacd81f307d3e731184115591a4c9e119ab780d73ba1ed52bdf93d570d1a6ff64eba21a6f92f6bbc7955bc50460a91256216c383091a462f3b571a56ae19a0b97b98cfadef17783f50ac0e8edcadbdd3da5a0736d3f31787a0d9db665cb20bb9e6daf7ec3284a95d171ab7589bd12406a307ef2af57673a5dbcef2325e4db7bf56233a8c1a2845f7e50d98666335a5774c0bbb4cc7347fd1cdceabab450d1ee25b60656cd34b01cbccc631c8ca3fd7ffaa95bf79caa4f763951376af31f2ce658ce1c3706bcfb35b7d2bd9c3d84f1632ea705a4b4586162cdd1514d574d6b1492f76d9bc2bf5eba9462a329474f0ffc67d4a346a44d6cd8a8e7c9cc7b5ac290e15bce896c26c81628661b785798f67ba04e7bde322fa5f350d67f2a8ede3ff4f8a418757a147bb552595a88158f6fa6b598f6de9cfdeaee06a6f0d1f1f801b2a75f33146e9c413247e79838124d7d38933e14d5c16ba2839997aa82f8714f6fe181142dee1bf383625ee29349ff75d318255db912c9b7baca00b0dbd17d0533b9955de60606cd6fda9ff1327cfb62ea2542a0e7871c56f26f243d892e03a6e64de696326548a42de9d045b22cbf35dfc0a75c746306c7f58a1d02a024fe148ba1677850a2391765e23f36441dc57157987dc02cbeb392b86ae5ad11c3506c8e9843d9e7530d1c753c7133bc82d7a646b71f5ebb7bc831021ca329a30166894ea2a84d319da6b0ce46fb9d7c5d4b037a652ccd9facf8cb89a32a332f721cfc102f96ff6b2474dd4800d62c14b7d14cf09416268db795d1f397c69a88fb8aa75bfbaa9b5d4f35bedb16c8cd4d2f52292f51671a4a1e4ec5bb91b35b9a8654b9f60f1ff927b0d6d9bab34554fc396db31e2cb71ca8d20e449c32115c6cbd71a27db0ea73a4ed34e3382b01753856ff67d10fd6035cb26f0d9f749cd69f202ee809f1b660aa215a3c31ff166aa3be0e6ebbcde91c2df35f99774ccea14a047fd1d3343bbcd885e0cc6f304f380718c4fea22ac24f1e9c2940584a2b7f5b6dd75ed62db195ab8bdc2962fbfc788637098385f8819f687af8f0527721b9ed1c21891eef19052f66cd67c539ff648409e2361c80aa5f5a78ce26db500605692016fda8a4de610500f0ae11c4d1c65dcb1ee924dfe445528d24c7a5740a80c17fb0ee88bd1666da3409c08cedafc14ceba95e4a3fbccc1d516ebe96b63ec505b9de63d0cf2f7de8086a1665e85a2917087fa6cb5c8ded9bd91272b922e8a905f852e07a57dcc4d7a093a898a8c393ced2271eee272afc7032c25a9f26163534b969445454a5eea15c5103fa659278e4eb74bbe09d88865ef8e0091d602d57f370af91394234bbcd71aae121bdb72cf756a17babb60acb178a47df487416e22c2865304f52d4a77e8042a468c822df9f2269a2ac68ef27f916a1b6c0e4c40a934b819aac838c2da754f2c642a6c7aa1dfe8e0cf2288763551ad1276b72537f033cc5374e833d4a049aea472a092828c3ac1ca70d32a8d509a84e217675942c1bd4b030206576f68ed874cd66a4316df8619c22e3ab565f683ad2b595ace0d8b15eef66b85434426ca0866c9842b690b11670a7882e50d70018cdcd8dd8bf6d699d2115e8fbf500100ad56de9e292f314738be6be885d04e860443044d4300b16ae317a694bdb85083b9323835aa5d5658d77b507226e4bb6f10ab10077f68b5ade0af5564446d9e7f14714e68957a04b5e4cc0d7c8b3a3a152bc7816d108cb1515d10725f1f9950f3a1f1afd85add4247f7f2513b70f674a7923fec8071a10ea1b395d21d87a74a4d6394baba82ba1d802b107fb458f1326c5f51b5ab67e86383db9965b12725b89c684bbcf558f61afa2a95dacf126138f64bf056a841f00890364ec83ca47511eaf42fd8286feea4d2a6a34c33c97a8d10bb5e5040092b16bd437babb8eed4ee0d0c5dfd93ce8dab939cb9522107e853dd4767884f6b08b42c0f6b9bfbde2a82ff2a0c065e3a095826669d311ebacee230a0b5f33a3528bc7714d59d859b92b5208633e673648b13c047f950658335fe716235b36c8b8b39c5ed799dbb16e3288581bcb89414e07dddaee410d1b140c7104883a4ea2789987f9e1489763ff393c73cad04790f0e8e019544b555bd2e7cba300ffd8b35e68b3964f403ea662e0a977c274568720a4adda24c02b6434ebdc4f3b9de013feecfc9485bc2ba555de8aa589e43c016b267498b2485f0ded66e4c36a21829f1873b11e7f0ff24fd78c2291775a371e82cb6dc0673462529c85dbf83dede064c18042ac8bdf830b2080f8de5797337c8f221437ea00f9144850cde6b2e2a81f9fe0cc56ba94eb6b1588732abf41d406ce0cc9d71f4b2f9c5b62ca1265344fd5274cfeee388d3f227f92e9fc9fcaecb1ea4f1ae764117c61c8a3d52292035ab713b0e780b08d92119020c9c2db996f0d56c37dfae51407dc862adeba19a36e55052eed8f4b66ac90ef72b14e5a23f2a51e38857dd1a89a5bca0f0320a97bcf0598ac059aeb19b93e66d1501e3421fd6a6e215f56de7929cf7bcab142d1af4c44b647fd972d3d0c89c6daac4e9a680cdbe14bb689d0b30cccff462a415716272cb78031725f47a657ac7e7d74d391355ed579bc6985c9c44f83bee4b0989848938434b3f6cbd7099843f9600299b97a0151d820eea28586d8d558a8587ffce19d9a726ec5e238d2b800b91b95a616a1ef9b3bac9bdbc17fcdfd25c79bbd2553ab87a4dd1916be60ce46eab9d2b94d5e034fc7ed2b3305ea514cfeb40dc4f45db1cb7e89d5eedbec56cc26f61330cbbb094f54bd27ef8950a84041d73ce00174e0b33553d25164d6cee5ed30b930cc0d0097b01ad682c9b17521d7002b5c8f37cd6bb0d6580b79f02a279dfd4fecec913ffea5d303b8b5e7aef19b4169fd7066271f6ac844ad6756d45bf8e192a34fbc23cc7a9b5fdda07cb7bd6fcbd06d27ae858632f3826618513609c0f5320f538675b62f871c85fac826a7ac3fd23d17cc5a8d0ef21e1b8001efd30b0bdf053a97ba23a0cf6b34c8a9067a383874e50c206c44c61b25f936e4794b55d14ad47f259dcfd17e500e584e0cabc3231f6c0c4970f13e2cd68aaa78669e5ec5fb431364538435b9ae18f8c0888f3ce8d94d1b5bd0d15f13dc97bfcb919ec3c140c5225f869fb1d48a4f0b6a42f5d2364e9187c5063ef481f9ce225763492ac79a3283d9ebe796be7528ba316ae6add9e2d5ae42efdc85be281e6b8f4e607ebc7bc242a0277ba0f43f7d7bd7aacdf051547ff6800ec05427e2259fe2684ecd648e34b84d50218f0ca552873c0f63672fc34abae85f849dfc9c63a02b2091de89fc7bde7bcfc21755af73da174a80e47d97936e399b08523580b80427f0e0ac147069e5eae3734e6f773d3871c01589f18b9d7eef6326c870c99883103158785139cdcec5a2467d00a3771837838bdcbde57d02033859c5d1fe69a9702db475832a5b65ca63d42d248e1ee90a3d46cdb4efdfb69989f9d8e931afe53bec16ebc75ae04ffa8cc0561fd004888dea0597f369db986d4c8b60503af5cbb5eb025c9751d1a5a2aae44dbbebf370e662bbfc9e3ada37570753dedf0cb0775b5989c4f58dc88a733580f92a98dea2ab3700dc2c6e96a2eb579b7234555058e99c23caae5be2ec45540ae20139722fc9eb6caf0999ab5d11a21ecc11531123c13e2bd5d4a93244b750c65896ea36517cbbe47b21b5d39b185dd848c34ffba1c5a17238a6b8d892092370a5d497cba4f7c088c1b6f1e1074438ecff7d7271404b5b5b836ee7495e0ee5052c413e8381f727240d537d73ee309305f2808a75962a58a984e7befdb12cfe32442bad5854bdf518de0738135af13958d594bd891a1fe94c9e65b18b5b51a3e8026b8881d1b766bdd411cfbe81da59ca2d2daeeadcc0510cbac0b30f7afbb3d5bedcf4ac44e0b4f4ffcf2ad3dcc31a4385136d36d04ad21690ec95de2cb0a8729ee1e34bba59550cced2fe9224ee9192fd5849f0c5eec46c4c66f9b82d15442c306e43dab13863d1fabe3426b34c0a6bef1d934b51ec189f419d1224dc4dbbff037b7472d6fc2126f2cd34ff39508488e2986d9620d0e126265330ddf028d8d5fad982cf9435d43a502a3f34de323960b839263d7ecdf232bbef01630c66a30db917f6034c2918a95e5f4d56168db28b374a603f723e33e7c695f83e866b9fe4e56425686cf736f8adf94b362a76665595d466a52894e9a9baa029c1b0b155b537f5676fdfebdb63efedd2109d051c7b2ec8038ae4866710a0359ce57d0211850c8117d1e79ae24faee3e92ac26132c77a901f26a51cfc5a4cf45f457e90e87a85cdf77ddc24733429c45cdd345323690b7ad43e43c1b33056c40aecf1546da25dc8da014d8de137d9a105696e0b9b6c22467ecf8a44141f628d908536c7f7613d9f6fe3619f69e81a299dd34701e3fc7233e9e5c2534248799182d3a552308a57f6295088bac95a790d1e371d167fe7427fc5524240157e46058cc19066de8d319487955a2cee2b9cf377ccd94c5d32793d9fc2db7cd310c83cf6f5e9a2e5da3e740725b445270316a61daba4df177567807c8103efbcad05a7ebfeab92d8dcd9b4c922565d3d0875bf9593a6bc2061b7cecc815ea6349d663311b0b201c85879d87b35abc9b3a4bc7c5cc33f6413e63fa5112a3f8ac1754068fd039817c77cf24b461088c00362ff55485e9a185f017274949ebbbb79c814465e7805b151af53d4f3bf223a4534b33221547bc4ff59dadb1bafae929d4b23e8b653e9d0749b2aadf180aafd5d834d026bea0f6b4320b44cf503614ac8dec2ef551e1cddf97c40b2948e0ddbe8bdb6391e94d3f1958e094af84531f71d163c99c99c675c48fa839facae279905e329e50d5c81d4fe990a50a2947cf16ffe955deb9fc46d8ccadc112c763312e226664c3598c167d6b432ffb55a7023bee288a6e591d10a5813e7327ed2dc38fb227fefd4a77bf04cc72bec9fa9ed96e7ebcbc4513f179e5d9755eb82dbf12bc92804191cc38152911c117f01c2f1f16951bd68488f39039fcef91991aea242b0fa512cb8e6ff81c9f4ed51077f58b596ada9a09bdb45b7876c202479fdc3b57a8484fad49c158b2d55403d9c1ee9d0b632e83213eada0e69a5d45c0c52b5253036b643325159067eb23afc6f35aa0d95abff448964a49dba7800d67c154134b715818a7f6e8a1c3a2543f79b1e6c4500a76ea71e0bc307498cf126b918b5e12b222fafefca3c7c06f62ce1721a30d5e9d8b4b8271e200d5120d9ca7554e9a4674286b4c3f314215277506625f7b83276c2e6361fff3e5d6730a1e003efb15a9d1c6529254047329ce3a4c38f335329de7d1331a8abb39ba88b2f562ab28c2f578d00e26323356b7ba9e0409d5ec387a38fa3abd78e040794214f0678cf7d244a599b7bcd1fa389cb4bf54820ce6f5f9bea737f4853466ee080e371faa0afe9ccd392878d9362fff54175a80d13d92c64bdfb98b6a49fd21ac498fcd74fb9e84b15f817e5874f55bf6522bf1f5c448b1a17bf6db3c6842b568ce93f59d00ba490f926d1e8c7abdf5f001f07fea2c33dc04df6caf87853d5ecd955c1850010dd6d4dc904300b204949837f2b002df7a1c78c4963910634c4e2d7972ecad5f5e8733babedf0ae5ad5758228dc3255ce8b8062535630a229b627c27834a8a4c93032d7bdccc96b6928f599843e5e26bc76a9050ccfa08f69d9b99e865495e0565c412411bd14e7195cc54b76d16e619d46928826e23a6518dac85ceeac0e772f089012a333f5ea30a6d343eb84cfa584c17173479688348427400ad962584ee94b06ce691619fae4be21423b248512171721e2ded227722d48360b569b91206cad742c1c01119d34b4b5ebaddf85c76bef297371e4948efd3fb2e77521832e89e4be10a0c1d823430c5451c0cf1808e8c6be7717298905328504b3c7d464ab59e8cec22d719c8862683dadc36b00ee01185efb95477168a9d0486d214ce54c60eea746c2ccaab0e1c967e4dd4832dd892ec886a5beee4efccd7cfe9bab45aa3db9f12b079ed538bfa6127377c065fb77e22c02dae0fa984751214f45e7adb5b37c7e5b3f9bf612557270e931b76f57bed6d85f74adaa1052f8d4611e72f9b0f9db62aa52020f7530b34202100c4d4e08aacd8e1f37fd9bce43a3a716539b2f623d6478d004e78ab190415f6984e623e80a8f9413278619e973f04ea25cd4313b9c30593f06a756ef1299961a209b6b1da916658eea46083b88b0e1d7a4f7ec4b988cf9a8829a21682aba24c6a28afab9416c0256f9c287b35d4d9b3087058dac61cfc83e1151099698d046d6ad0637584f77665fe553ad84579c0071bb5adc0fc24c1186d6219cd4ddb535760d3b8d3abca52ad8b8ad6649bd098bd02a261139e70b933ede762b36ad27d9582ad9e15f27ddb27d8379236e8a56bbab35c19a3d10ba7b9895aa59cc87c5ea8b4c443d97d4239abf6200da5ee00dade4d455d5af43d54a70bbc59174c7f35d8e5e405351e58094ac81f0da65f629b427085dcea731bf6734e54df437f3bb5c728cbb9e9169f011425b194e3412cd5d5267b4eebba688741a0bba61a25e2b22d3dd15d52d930a72f0bc11d273eff5ae5487f277de4d77301411eeeb7cbe90b96120163206a552b5217c2fd0dc543ade24b4354dd25c3e7f918d0ddc6b986ecc42faf0a7d9a6a92ecd9a156b5c6229bb4dfa68355d21d0ed4ed48bab3c28e9ca82db82c286606d7b465607b9207011bee1ff7bf3c1f7ae244e7506359af98aa4c6370caa5f6ed160289f875294e3d141cf10455e3cf739f6d65e2456783968aa78fe771b591c297dfb74cb9ae2fc6cf40e4662dccf681f7dd4107fbd4301b00f5e3376c902f7fc1ad9a3f86903519700171c331d8eefb533b7f64afbae6f47dece18617fda6d0349e41e968621065d0650f06bbe86e141e5bbb0d024fb4e10199442038f3b415fc98438998da1b12003b99139b9be8d5cc5dd5bfb4783b93170028faa953fb5fb8e941a64efd42279620c7713d3bef22ebaa8752e5072eb9493484375188b715ecc8e17bba29675eebe708645dd53f55d0263b7133b14b1cd1f5f0398a067633eb5d91a2c2fda92b1662a0d4762e6721c49ee8a80ab886ff660e48649bfc20fcf514ab2d189160400e9e63b79f91df9b11593240468ea4117fc474e6c26f6a4dfce0e7d3e4c371e6887d30587ad05f6cfb3d3e85e0429f40f45c5d95b6963195e4588c7d9d18ed09a0b864b263d6ba172a25804c6543f03bfa15afc9ef078ffdb04f49eea6c1543c46b46856dc3bb9b34b1b2acb8f2befe7e6c674149591180ab43664be20ae97bd32a522ed103e8d726c9aa7627fcf7edd6fdcb59978355eb04d0262189b97ab65a6fb428b4259e169e4df949523df581bb00d11425846f6e45b65fda83612df5226126864ce54b572ebea9b5e17ab985870215c462b3e03eb43d1fb50dcdf89c2e06a729c0eca2ff302567e92b1a5575239229cd9ec2588b9cacdb51951a0505a6c79515298738cf338e6fe5a5c0e20a6bf376cedb85e5924718f99684c5d9aecdc7df12bea5e21bfbca04ba221d93c6731792675a4de3f94a18144683e0dff76884cf47eb88344b0f279eacf2ceeec844a3e69c7fc3bf7a8081b28bd899aed61469f2a96b16c287f0e43e179a670ed070e7acf635a97231d000c709a888ef08a96925dbd2ac6cc9e6e6ce7ed2e8f077635eb14d072f5a8c6f8a155f49a60d73a1e041f947d4edd2934fa0236d13bbbdd93ced7e0f51a2bef6fa4556cd204e976eb2867b0cece4ee793df23776ce1a4043130c33f8387b2192fab0a373a7ef21af5c096548ebda53e388374dc1ceb87d42e46aac811d2d6ebd0b937e65758eae2d25b3e7438cabf4f03aaf68a5955f6f730a7822ebf3fb9dd16df7bb5f1b579089aa2684501be0659103155dbc8cdd94134168de6e720cb3c38e58d883171971320bb81bed8d2471dfc03350e17aaa2f0115863e132aff877827a6d123dfcacb71e45cad15510d91c9cd16ecde164f03b439e2de0086bef8ad5b1ef446420a40be57fd586808ecef394399155004931ba2fc1b7645731d9d5340f621da65fa3105546de59d4c26bd44325abb243d97963fa0bef866d5451bf68e075a7c81fa58754e7f91b335672f1964391cb416b2bdb567fb8bad870db30fd24da78075c83e5c2fc5e3d0b38bfb4f6f5c13669c84d5a51f51f97c37b9265c7b7a279dad80d2e57d2977a85bf2658a666cf7b6fa4738373ee03eba5bf017dfddf75ad93234a36c7cd7e4c5cf3fabe8eef69b807d6ed9ad8338294fdad9a4f95f3be4795ee9677205f31a8775b7052a32d812b644053ee3c4c6322d6764314804b24dcbcd51e84a540d4e6e2a6b5b986049e9b0c59721be0887ad1c0af7d85b59c09bca6a08a22017ccfd2b98b3cbfe43b06872fd7be2e4bf6e1e24a1c91627ed268de5e7b078ffda1ee0b8aead13135f186f08e313dcab784a1a434c0e29ebd56e97af048b8af0dd1d11bc01a723d346b6e924e4a2db131ce2f179f6ccb4d9761fb721c384c34191b3be40b67de75b097c5f00ece6bfe0cadcf3ecbc80fd0a1dc7e5d10c05a5031d142fe2ab2c55936ab642bae292870c49edfbf7e867aba8419d5c851441f34ce57732d045bc51640cd9b416dd00ca5d473b05c53bc492e4a8c026ce8801323bb8fc6f031e248a7f675f24da9af6c523f0f1a6e25168794ef86e057251c4510ff08babe65b6662c8f3f7d066b1e33eed761359103435c274fbfb9c61568313a0ff6d7129133c7cb04cac045473707c88954cec3b5441f2511794d7a2ae24916e996a2d6a91f4ff948c52ed37992b3c810d7169f07ddf97931c305333fb693af38a71381cef3f575003db32d52cca5784ca79f1b63f00a0d762db6730b59367e8c3aef47658d5ecafba6b3e5f569e00b3107eddccee655a9e73a846300dfc9a14379f8a90bef23083c4bcfc21d9293a915d2a4d97021b374b08dd7ef985a8bf539d2b07f0ec9fabf9ed5d1e01e7a0ed7e98fe6f8a10cbcdbd7295a22f1a4bb6d92290405e45a4d2c04fe9cde4a28d368f49fa8f1ecab39c5d4f656389d343ee2d7b704a25d3644b07e5f1a80dee296983274b8500895f08ff1a33ede5f0f66f9b39f655fc23e8b5be2efcdf4bfe4d3d06e469e23aa1aae522d0db144e596fda6e35924782cf0cfa96e0d7b59f501c3624617ed0c4b47174c6e60eda64a8a82356d9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
