<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"156c82652e9c81cdd4a38ccccffddda8162fb859cb263a096ba0ae69624ed694ba67ebe8d66b779339d4e2f5265b4896b91deed20eb5ed7cfb6b71539aa4724ae60097db5e540f62a80674a6228f2a7394faaee216ed56dca01dcb18a2a64798f34870a9bb3cae16677c6e759f58e21cf922bb758231736a46d158314fec97867c07071232fedb6fe8cff5904eb147a6d805d0e63c83bf567747a721e061a8828a9bc52ef6638ec361b47e6a1d7d44aac82fda5bf5d2b0bce8c2906521df8b8bf8b6ccb0af2dd10f495921742449e2865a78480a9be426580428e7acaada84b141dc42178601c79e6665bbed0e6a055c7794e76d56df0f3ff5ff899fdb8926847c2eb0e96e2a7f644f53a370e165767049959fce27df2245e2993769b5745ba16310dcb75d42e51e63f72855ae0ac1dc09d8380cdb13626079b7d05723ed286a8833a37dfa22cc1d264480f9146c68c3a4bda6e964703c7039d395f2ef3dcc9aab4801be71a3a43d3f0669dabf758f10cdd67439c3dcfec87c100e8c92412145dac062698fcfa66440737f9166127a10be0365109f44ed4153a2687ab68a1bc2c51a668eb125dd428f5f88ea83a5ed009b65e23515f22f1bcaaa55e1fe3fe180cf2d9aed7903fda126f016a19dfad2e34fd8d43ab35531ed7b5b86d8b2f25f31ae8cde074ad9e7fdfcb088587775cfc14cbbc678230f35b97117494f741ecc2e4dfabe40b2cc633f606dfc0a144491ac47abfacba4011f21f0280ef00c70edf692ed7d7394b05090391bdaf2fe7fb199bc98ded164a2daddf4a580a5e51498359707810dae6663dbbc9bbed4fab2418bdac3d3ef85f625bbee9959676ed3189e0c31839450dc6e22e6ad22552d30d34696e172feaceafe809eba09a6de849372570381e64fc389e3d6021554bc18c336f83db124f5b1ec8efce27f6e266bcec6ad5c1a332e9b7145a8a6d6cfdde71e7f860a34d55f5e5e94aa5bbc2c222344d62e10efed589a86e15cc9c6e66b1c1121692a5b6dd774437fac0e295e7e56ada7602e6579f49fb5df64f019532d662da72e7f99943f3c8bcdd9b83a0a2746a43d8a0bead48b6e9c30a6c7f8ab728b19361fcbf4b5b18e8b34e3c03173f8af1a609a048c3650f3a4e7d5c2a03133190007368769d9bb851f6065a21e5a68b3c766c9f488f9ca98e7037a4d8d966214cbfce1af801bc61e6cc437448cf1d2916af3d02226ab8bbae04425bf12dba763814c2c7a4421a280f1abc538d4caa7b5c6a323da3eef637574f076b8faa1fb069b9734f94a537922720c110cd7e6826925e0ec53a08f394b95e128c18f082d784b9b6a0e8d80f40b603a98a467610ae5e7cc8e4e3b0920283938e97e498c2fb49e29b35b238ec256b7b21e8130ca312d71bbe3eb95604f2cf82d35afc55d5bc3bbaf02ec5211e0e0219c4c2785add07977178bee6121d84093d0d70aebd560f3eb55fdbae9c5ccaa690b167d438666745217ee4272091f0312d74352d7637f28881abaa197aab9e0946cf749010615fa476aed804e164e0b4b8b76a0a6c7dc8fabbe707501594c39708b2ab2d575bd5556df54202e7e5786095c054707164c63aa1f657c42c13a2a609af9c09f1e0fb61b45679c137afa254bb98324a1d7af8cb81565b3c04c484cb4fe89028e2114913ac5f2be44f92efaae4ba43aaa5bc07219df804481d7deb5a34a2318e7f761fdc08f04c0121080194a133e4fac8ae5e35438b0d3960a54fc3eed38d17359ef4dc784cc3a78f19b7e82aee4496ada3af261f9de3805bb0196288f2711ca0936f905a180d81505c92acdc77260d1d7373ef137aad9cb7ca809521cd494fb7e7b52012e9db27aec57018552d54c67303bc95730e33a4c0a80ed43e43373d10dd739d520ac0e81aa21ab71ea3d60c7fe7efd4a118116c3f23c6c4abaeb0ddf221fa4a09a4bf315408b9faefafd0fb94ddd89c5a8119b0b95b8ab116a53a1d4e56d313b4bdab9726b631fedbe02c7deafba121f957a220add45bcee412e12f36b6cbc6d465a67ad6309cfddc964a63a207d5af2da763f22fecd0b675cd2e73146246ac000b3f5986ddfd70a3c99a8a8c38fb96397396328fa5154b17928501929998dfdc850aabdeef3c7655cc0d6aedfd6fb40694da451cc35ac06ad27363110f28faf59d3fab0278f409d5e05b1e72f0408f0ed6d4c2560b2f2c531695a5f3058af4b18c326b5a02824395b5a00e88b85a6efae8ca1c6d12715346036411aeb697c23ca1beeab6ae6b82f2ece437f193b8042b13302b97748c3f768777460cd2873c297e65c17a0860f08d731ef6308ef6fbf85c61ddfd6eb4e6dcd6297480b97ec6c22de64fb250e07483682a92e82b57957f92c41b9426f19eb25a86f883a9f8bfce77fc0fcc5824a97c43f5a4db7b62f3a1e938d7e52d8d15e1c6f59dd8d40651a83094d62dc69ce98689f0b94bc5adee1e3c5cce9057ddb822acb28ca4dd5e6d7d149d518c288b746c7825d664c68b3dee46f8646e6632089e5cd55436aade71825c8aecdae9f15da7f6f7da365fb9ed3a4b36efaf1fa59b08e6d85ece309ed4f007ceadfcc67a8139d9fb04bfc893c81814d87bb8f6c2ae619c1e2fa547b5d4ad5d2f99b4383116a9d0c8f2b4f0a0aef3d56dd70c99f9a3bdb33e61f38806c3271d2d343eab91074a284cd577d770b9718c4f8681cac4082e7ed96f9e9c99a8fae3d335dac71b31cf70d63e5d173a899b288bc5ab24d560541d3d0e51ec427da9696f579d80879e59f0521a74abc562cf58a12723294f2606a08410051b5970f3926f75d7f4cd00f5e27910c3f9a4232824042fac95be4cff841198efadb9763337019be753bb69f09ac1f46cbaf2e96d474d61e14b2133d78f24e43e69db184ce780c5b48f4043ea4e9326b5bf67805f3c097a874c6714c68025c3e9d6c7603d34c2619255d7174126ad4cc24c1e3fb5e4f45f99f0cdb5ba7748b13dcb2af7a40914acea7d903eb04e7ee264af9bc8a348226e5ad3ae6b1dee5dd10767a03c67fcddbe8e5c7cc1fe6269653428040312ec1aabc0a2b47d1d4b815762517750d38a9ad5f532925d33508471ace2e5f613db685c46543428b559172a8d0c67526edfa1698cc399bc69988e8796e7a500521c868cd406df233bed3aea942c944ca7c4a0ac19bab9b72e96693cb834c4fac489c85e9a6ebe5ba9d74978559d6d9fcbd3459335217136ed59f3fd10253d0f41f6113864bad4bb7bb9d80441cbe71682c86e45bf76826c33f489dc47ded82ef862b20da021336daeeaed2c091e839b5f07d05fc3fb74185c73254fe4ea218fd0177d5fca3bda4a6a2418fe86af78cf22a4d60ac3b28c30ff4e2867fe46b56832bac71dd2466457585cc626ebd63369d8ffd8f2850fcdf860af08e75992fdeacd2c6fe19991a28c1acfd2386b9832813919aff4f95c48cafe3f6d57a5fbe823125a68898bf4cc65efbba6d0aa7fcabc2dbf2970bdea6243b02deb03de3d0584d0f786ae6a980ef4f7d09e0d718fa26144d540ade018b4853202b4556f64f5cfac826cd593e7b85c7cfb4d8343f6661fa55acd2ca3142df126322d42de80111fe521b7134caa659afe5851c2339a6858c177e98e1eb13abbfde0a5b1f1c3321088dabb73ce4a47af14503cecfdb7aea6906f6a86f657e9b61256a9a4e41042b635356ae8a38e66e707e7c27c2f58d5f5a07fb6ae06b2b9328c12b4a9827826279684898b6c14003686f48686e40fc2761906475a0f540c07764256eb0a00986a3b3edcbca9d6de23280c5b72831edfe87b038f08832128947519cf2d9e24173760193d6c5e7b61f7a0ed4c8fb45ae01f2f07552ccbcfea5edc1d4ad30c449214c8e2786da2b69e566307c32aaab6f17ee6d363e463fd0902d1a30f3b6dadbb9c7744f737a8d695d6ac2c5d94c071730a0e87ac19468d4a13bcba101ce6909d9174748894765e78281709feb25546898dded2a67ac2c3cf20afa2f3a6cc038a4b91654a451fefa27bb8e6ccdca59ca92ddbd1de5b10a9623593e5ac8e7b9986fd05c00c76ca4885727ef6c0ae2c44671f774d655f1988134e150886160897f49f3db58fd3d58a2294f095725cfbbf643ed04ad8f974680027dc3239db905acd5e5c9a907e577f3183a2b9d9e6e404df44b9b3a4e455914bc4095ee55dd2d4ff175590a34c158b2fa9de13b47d7714725199230a03e9eb96e9fed37e528145850ec54fcb7ff4c5607f9f54f8affd92bfefc4d2321686609a4cfb6360f664aa9079a9f43eec18439f6679dd9d4a7a5b850bf40c54ab36923c67d02f86bd870cbc915250cee45d0f8fd759bdaa29fcc236a78aae5b67d3bec695c85d59afe137dec0ce248dc735fdaf4b076b7405d59ffb1b839b5a3e88cd96524973ab908610c9e7894d192a41a46bbe3f7ada8c74352de5e766ce28d0f6c4b70eac2ae21134cf6b4e612bf69a44e80fb68e90251c0d197e333fe03722cde21e06d441757212a9e98bea6bc377adfb4b4a08e97f4b323cf5853316ef18cc40b7315f9a4b7962e7d73190b60550838541159d5398d811bc68f908cf7555e4f9428590ccaec56a3f990558bba50d4da02c70dc893db737dc013680de37c0469cf80e55e4671d34b4ee9d7ffc4e17b7791ceeb8fe66eaa1c55901413fff01b8aaf7bf4ed1fcfd4fffbd61ba3382ec590c11bfd998cf4ddbc9d978f266352b666dd7158d646c8753dff0806dd45091a68e10858bd24020ae66763ce4e134f739c3d57e48fb80f3ba17a19f45d031252ecf949e146310d6919702efb9cc457d8d3b0f8e5aefb0933498a7850d7094fdd439bb2af16394c5fe03bb3e6bd2bb9dccb44a9ed312464e2d7f97b0adda866dcd0a5ba6b37cb620e8ca2f1aa04815c701844d7b521864b08503ca6ac14df251130dbccfa281bdf2d3036ec57376e6b236e2b04d99fa5267360dd5703b704f4e3c89d89d1a25b1b4011f9e85619bb7703d27710f67e35c13aeeb8d387744e0b3a8e37bcdbad9c755e1589604bc1e2e201a305358af22866cfbbc5d457157470ac63f286523374742dd9de2d9357dbe839c5f5353e18b78d864904abb02d77619ddac0b9c5033c19809b30653006440cd2d6629183a923cb5e0f37d62b2c928c54c3be157124acd1b0fab0db4f153a9ed31c3c9431054c6d106246ae1acb3dc070e14f449fb357841cdb631ebea0ac9c3edd929924a4f3f4f64d96da45a24331804cb84a8c699a2d7bf962f7f2118d7b403cb69d549060fddff21b2d2c109fae3c861ab6cd1683607ceb59baf55184ab0f66edee823a5bbbde577535c380cf185cdec395ae8e605ac6066e8de0d27e264d67824127ba5033993168ba570d33dc8aa5447913d44abc6b141c486b595a6927ebd3196bdebef8016fde9f272ff926c0a78eb956860f258786a48e8770275d5be2adec246fb6328b726775123ef4b06a23aa7e09e4345077126210bbcc6609d164e18bb5c6b7c1cc39dfc8575b8065186eea4ed9aaa49b22ea3a82700f601009cb8adc28c844ed2902f7e311e7dd9bba1403d645d2651130999efb56150fd64b4e5977ca248c35ea697690f396cc8e1a86d0f4ba9bad066feee7583cb73cec945c4b2fd0607aac6a4fc33b1884b361f643b445139d6440ceef43879f235b40e079ee8e99a05a3009c7ba01a993a6632ac81500ad4e57d296016f6d22f68814e5988c1c29e730b5f228361bfe4e8ca41993a20afba1b13fbfc4c350be0d9afc34f3f4602f04a560cc5e60fb8385478b521c9956b7def9b5696fec0d1df0e4638ab833c26def25f8d1155c9f27441212dce854190727211a403ba4c6cb1fb101ad3ebdce7785382ebdade4e8e5940eacaa7a34abfe008ab06604d5d1294f9f794c6ea0320b1a8161ee979a59e36f3ec9ab7732cf0ab20039f6e80bcab7372848eab94c309e91c41e5fe9e70b32916109c031483dbd10c5ef3c15e2e0c9465af37cb54e2bc9a9e09887159fb0f25bbbe71fc9653e877e61d093a4970abb16af6782dcdfa52dd4c9f482480c444b9139128cc4f075d69bcc978f005b5a1f98d942590eabb0e4b39437ae77a53a4ed93fdd8b08b43ea86a6e1b5aa5f46cc7d3201a5ae70c29e0c384f4317c1221b55242fb7926b73d2b3fa7d9d72ba4df7e826522b0e3c7b0b144eb04f6cde2aedc2367495f97bc78b41c0e1d0f2cbf5e7ee7bee87ab25339d96c060887a1a01841cbd24122fb0307a7335412f45e7a98cd6c7231a04109b72e182756be258db0bcbc8e629296d0cb955046c3a8f6460b57","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
