<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8e3fb73f7a79f32354b392271d121ad67e720b6372ca5c0ae259f2cbb2c79ff51d9a349835e6c168b2bc78e60ec1b79297b5450397ea458c8fd74e94dbb0dbec774be36f83369a988ca9419e214e07a3ff34b043898b13a311442e791f00bf9d88df7717c4d849cd9aa889be20e27b9d39ea0fdd7fcadb3c1e8b9770a17fb17f57b56feeac7c65197d27d0b6b58970dbe75f7cf1d7182712a6c546d96fe5ec226c0c0a450b556664ea9b7732d1b23bb38551e79ae98e68d0d3d857905ec9593f82c3fe4961e9c641fe1ebdacfcc0fb86e807db9ce43e15cc9bb0868c1cb17555d0800418ef4d681caf113c348a1b986f17e472d4b1e7fb037057d6c8ce4708cb765549a136496db027615984bce92ce2ad92ab0817b21b7dff46d88e236a88309e536568d957bb40f7fbc3b6edb73349b5b099dadd88936d4df886b9e1adc75108fd137b3702117bba30ae9d9e2b2d99f5480b326e76c22387e23c0ef8f60a6ab2455067d4c0f2e438765e35a5c5921d11c6fa2cd70c2d1cb3f24a7eb910023a7c5492d359dc45b57ab41965c2fa038c58ac37a8d944a8eb87457a5f315d1be9b6b5045970e28dfe727c1e7e6defc7c9b08ce74fad4b3db95c997a58fe88f34871abbec9d1e770963fc61b6d4c75bbe40d364bc1b1bc85868b0b094194c8f5bf586eedf1c1ee48a432179c7c19a568cdcccdfef3aeb9fa7d7872d0d63aead304ac10b6ca9d3cc1ae936e4dd1cc68194663a2ce62eba7ed3f6f335c5d0fbe09b672a329af6aaa3bf8fa41873d27304f1bdf55adab3b1f9443b395487d92371a5e14373b241b427da808a6c3ec334ae00f0cd5983ff9d92acc3fa36cfe1718e55f15d6295792c6d5643f9dd6c97c0ae2fadcfaa0c13faf3b206cc055633fc518fea29d6d3168a696b78d5d5e0c3a2351de777262295dda9b7f843c4accee64d643f61ff0e01635d4f6da1f30c3a06dd69914b2b2a25c9a00248002abca4288f2fc8c9109287d58a87583e49520130bc681ec151cefdd5a0ef2b513bd5064bcd9cec25b21d5a7289fb7f4b9c10e61f0f51a7394e052f6a3c188680a1e6b767d88f0f1b63fcde99c5a94cb862d6c98c45ca92bdb2d177d487f70fac78b417ea866425736b2599a6aa22d67c416f542f7e37d6e6192af9ec566af1dd6c577ecc1372d2ad4ea9dd0b268746bafa827852d0c8fa966976cac5f26a2833a0d49512cb4c3ddc53c3a51dab92e845593b73f41eba48f55689a050931df3bf081244fe36dc59574e0c64d0a466daffd31e5a6f75ddf4c37ab6d007108a81161962df566578557e8af87f1c9bbc3df19aec277bea97cfddf089e12a4d88ee5fc61ef4b9fcd6ccc28beb4cdc8163d44ac325241651060a043fc0e5bb31854975f38c05f02d818abea123f5a928dde2966c3a6064e19ed70afc38665b45da4b37b278cf14ed8e29eda6f83f60020b6c31b924ca03db03bddf59da3e25af5ecc827a1dd39515efbd88fe4419e0e17e3a74ba2dfe46f0cebf1f908e51ebc904c1a109010be241eba07f990ed20e633287beefb140fd85a4b1b4ee99b9a5a01290828ca0c78fb70fca49a662102330ab7b00d371d28df2608900b159388478683f4a609fa0be747ee66a3da7198f25cd1f0af4ced842688cdc3e7f8d23808d4c831d5a3ae3049e37a1f034157c8ca39dd5a0516c0c69e71d98010f978ec8dc6d91fcd661e09a7fabe802e5548588ceee610dd99d17fc1e239f1fbd25b2f6f4d3a7fce08a5cd4ef35d63218d79db2dbd6e3d8c4257aee5eeff2bce8e9fec2839ff5526b2b01b091bfc0902dc4d650ee88ca4539b88494ec655d656b45755b5aa73f01f28afc7d0c10de772e8222b4f8dfe7c5961329d4f62b228ad51940f748db22bc1fb06365a9ebed1d91f022baeb17c4156f47513f6bfb5272418a801861770c4c3d9f08ce7e2fb02e3228ece05ff22150d3ac623cf469247065d4db61248c5b39cbcbbf9cb4ca7115784cef31091ebfaabd3108b9afd5586f7bfc43c75850bd6e9f87dbcea9860100b316eb98f4e5aee3b5796487cbdd49941a309c0ce85461dc4ffef30fe4c85f826704144428fb07663d90f122787c706d6e147dbec0465e98fd1b2c4ba34e90404aa2cde4abd9d32b6d743d036365feb13f970200fd937ddd7e68a377ba63ba31cc8f7431e58ffc374cd9f6faab9f96c32f5fa185230e085b2448821da756dcd4b3d82ec4387eec003595b3f5c52679d52bb1dc5b8a3bf7de9c7bfb898ab4a24a55b11cc6b66cf5e9d882f3ef80dfc7f71f6030538c6db4d891e3e883d01c899ca566dc718357d9add42d4a4192fb78a894b8eeca8b434b7e9f6f841ee3216513bf7430099f048c6801967b7fe54b6871674e08bb5ff8272a8b2d9169bba9754d00fc253f9d60892f9362d283ee48a4f28fc4e5705719aae5ea3079878a7d506739ce6649e49de1088673be899b02b94f123f97100976ad9674f44a152d227937fa7c193cd55bec1b22ab1a895181982c9167d801271c6bb83ea160ff8c7672eb834f90408a98bee462b9e9af0531b66f27c64847e62cf47653924a62f0ec2f3a86bed09b42fcd9aa44635ce40e6a066385a8ac00ae5eeb8e5fd5eee3d6c5cf2d320b7b31d6652f2f7896e1670c4a3eecec426204a1e046e30ddca0794914aca9cf426f440e6747277fb290f8652d070fd18738e61efd06267b9901c1b8d44cdda13137960cd1c8279aa84e2b7b84cfd6c319fcd9e0def29fe7da84c90a2ded7b68e5de6a500c1d42e45e240908a80a4ba581be17cabd4bf97344fc1931cd9df092441b2111f5ab413083b0e1e5e7cd953dac802ba07e8f465d9b34dce660696c9fb534ed116c46c30f86a35ae1bd9b96bcc86c6a7206eeaf4566e32fb141d8ad85f7bb232ce2053b8f23b770ea3293a6652992ca6b664414cceebf9576fe475010c841d2a3568d297a5fc8a35aedf75987c19d70e9c55125358dbfb5453710bd839e7afa804fb59fdc4b682ae57d6f4d13482140e7543b75e1deb111f299354a943bb29193df3a80294f134db078df1f4f436ea111a00480d4eb4b7ebffd1e581a459b3b983088ebc60be571f0940839219ddb1972627193bc35f32855a6c08222916328068f760abcf91d7228e8ce7d66a3b860da2a4bb32d9c8e208c94deb54169fea373e0136ae12949099894d3644beb2ee573a7a272bcd8ef89a6ebf9c8fcb7ed118dbbae9660e30325c9b1b301651537a369ca18a43b91f72dd783af12839b85c0a3dacf1eca279ae782042fb1064e293d65564628467d07ed71a5079f1038a745e1d0c53eaa29acc3ddc60df8fcab7397256afae2e96772976a7c45b74433d83ddadca05b19332b6fb7393713b3d86cf5a2b0f9d96e98594b9d36e0ebd52743c8a246d77e5e46440410679c8a77af8f08a3b40556d47111bf72135350b6eb504041e6dd3e3e22e9e6d5452b276832fafbd9b67d52b14688d2468931dcc2f81fceedca6d593b29ac79186f44cf1ee26a7652827981feee6cac92a85cd01b460e2d8aa994b2e288b9d36c63901f03561bf63ca55316e539c301ab21cf71657b8bfadb004319f6f26f5e4349c40fd4833f896e074cd06832e5e5a7b73e8c32573ab1de6a3536e5073eece6c315d39008cd4efff414f469ed67ae60b880c17edf7b0c81a8910e80169869851d7797ff9d8a2f4b9c3dd74e0a1d7c56af1d9638e8b057e49bbc3db6576fb25af43d9f80d6472b9cd25d27cd00dbe2aeb0d975bb248345158468d2f06cfd0934773083d1f870b8405f65f27720459f4c0469a02396a754bd066bb569ce8a742beff7a6b52e217811c961b6b565044ea5ddc08f0e303fc79498906425888ed31d1cb34e644f62d918f2c3dc820629355d5e5e7f5686ecccd69a3aeb08360b8af8163e86068d7329be0f6de865f63bb0bd58d8368074254a2173d3f280c7dcc7de225b70c2f5752fe10506dc940f2b7b09625d10ce1d5a7159c7876309830c073e061a4fc67a6073cc3aa02d2df64265816917b526e08b1db99929e7f3bc91a0f06017c940e82218973d5e0597a02fff40b77d2ecbba3ecc94d8bb7989d1a094018347227c63d9f5bfda35b1779b2eee237ed2fa89505abd47a4f3e99a4e745ebb2a70efed93d9e10ec21b2f40fbf17981913ccaa7e7130d11290498a966a548f87245e4dfcef6229413cb7260a45c93dcf5ea8f14b94be5f077c92c43029e2225169a5159e502e5d6f65791fd78a5642d31ef13c4e2187a93debb9cb8738e0c6750ade241ede705a55cb8f7274fd8d6339a31e9d5a2c423c142da2d697b19e1816e0393b8ae78c3b9b54948fd13837373596abfa206f291b360b38aa9a6d07297b67cad7d2418e8d8eb6ec0aba0a1f1559e18b69fd694fb13bd9e03a8d60d789edbeac01c9a2212dadceba16a1c8537696108480e65adbbb741e22d7be9980a850ab5cc59cc5056b0cc23f772bec9636c61a6e9ea25389f4ca0ab2e76417a0c618e5eaf933a598c9e382d0b5df9eb9422f0989644ffcf57b023ef17c2b78c75133f4cf5262d04963c274f64f3c23efdda3e936ef9bde77374fd6af1b2468efcba6370d875712ab2a95edfa750f1cb5981e65fde81e2b6564d894c1d9d56202ccf935a504b9bd01d2b7717166604e6d5120864cd4ca466ed39a026f8957a64d80f3db057d1518635679bfb7f17d809f12969a285096820f240dfcc220aa816c974a0e5551239009ce812838971b4ac7eda8af92e760dbe078b6fa6e961a6eb95539e5d2dd7595eab031db12409496c5ae94004583ad33b9e456f1ae3ed0e50750bf83b7d19f741d6e66616b0d1bc0f8a3498aa1b464650560a9e8c457205e341c5be3ac8af742b0544960166242570e372112947eba93917ed42322bf1315d804b658a766af7006d16538e8426a098f0076d0deb2e472305cc9e70aeadd907a9d092733a65c372f2e16287fc00daa65f2920a6f792d9096a496ed74b06b00ee5b56932a3f72c72c38d64cfaeceefea4e72a6fe0b525b2c38d888a3d6c204ea7f26b085a2c8490cab5ea698344198e2ee558a7d7a946861f673aef110319160e1f6ac2dbecabed0fa8e9b1c00ecbedd611ed9c062fd4ebdd3411d54574d9a7e6f04d141d26d30a6ed12291ad35c02bb341a46077cd2c1e8cce6bd5d698bda282625fb4cc5682c1d404867401fbfdf687dc7ffc6e252e3b62b791dd0d714c1705481706a6757670b3e4e03506fc1fa9d3c6efc67660139f7e1ede3065923408848be8a590c4711821dbfb89c36090594affd479b8d0fca9ac192eae1ef9ba1fdf95f32fa8fa77ac52edce28acfd0527b70aad6166f053b9342d8093b471db992259b9d0b13f284205101b2b7be447f019d9924a7e22a8d0a25fbdadbfa33146ef368ca97966701375f2d1bbe507f6f5add36ba7e66ca6b2d2f68ae63c3721e1da63618d7be7e0aa3ecf801d2fd193298a548a7e53dc2499734ef340756d37526882472eac9cd33c916e53b8143ac30ac8cb372b0833596eb20fb41f27b3bf118de6bee81e66047c42699c1fcdc94f8da794fc9cfd53d694e55363f1b28306df6955e9fc2ab3e8649471c44f6661c26c0baa28cfa1f6584d9acfb04453033072812050962a2a8fa623cdc3405d603ba76edca2b5b7a8978b39729f4b788aa1a7c089e69c00c02796ab49470768e17dc72606dac76dc75370e18d0b4002bc9893bf08c68ae2e89373e818f50f625892b747fda687df4f0aa10c63501ae83d9aa6ee0db2bbae9696acc0e5d114ef564c9b24ff75adccc0eac0c63f4d643084e7ddc901e502f5997da5006f5425d04380e77e5cb06b4bcee057829118d45e7fa2320d26f71369756e91a39b1f9e5f7b3763da595bb23c25fb031127af88f98d7de01acc704880788ae5cc1b4c08932994d4a5ea369c0ebe13a08a9a7ce2247fbfcec50dfdb86fa6c5475b9999c97ce411a9f01ad0c7f8f2ceae7e17bb332826a5a4acd6fe2ced1a886fd92e2e337259703e81c6ae685a9cb69c02149c51ada04c89c0f510530667b2a5f39821117391d7307c89910fd89c3fecb99dc5a9c2808696fba7fe4ae3045407cc259fc02f0630c0b980b8cc70ae0966bc3beeb34e97db6b47533d39a40618ee63d195baa865f598ae34f5169f22a165d64d011b22f5936af03b7d9a7462f8e45710ecd8d000def4d19c4cca0a059aae745d932b600b5547b339b21376e2e98430d2dd432c2cdc7bc52d5051b51175287c037d9ad0c5ea2f1baca2268462c803be4dd1fa8034a1bdbc1fd58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
