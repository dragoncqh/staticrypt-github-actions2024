<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03c7d449221b406178a75c1f9e74c3d2b6d6bd262c022cbd133f85f7c13948c998d6c6c3ab0884f2ab64dcb4c85f93bd4eb5e981436e9ecd8b5da2fa3686db03cd3446b85c79c83cf3583893b66dc29f680ab7fbc1ccb9271f79d53feaedeb6593ab65b328cd4a94c73f286497b7c91d800a2373e3877ce74449f4c8c8a21065633cae3d636df2a94e3d8a50e06d85abc398b0e336c46a33d937deb5ff08d321b31df526e4bc955bed9f980d73cfee770911b1f43e1144a809572449f76aedc16097da3e357c9ef8ed09292a72c1612acbbaf8493eae77ade28151d0ae86bb3ef3b4adf152497e357503bc5ed7a4d8cc1c613568a1cff00c3141d8ba2aef61e6c2e5e465ffdf5684c6e93c8ffc4dc12f511864eb110f6e1c4528093374dd18ea2736d42bc4dbbced6be2b9f02e7759f25edadc812ffe45c2ff176eb96c6fc4f9833caa0c0746df5d0b878548841a3b063f2f5fb8505547c19c83014f561401c276502cc8a71e4b35b89f2516fd5a205d61d4395761bf2cb2fc57e63b5e777d6fad08df75c40f7c32ab142f331fd6c8b738f2a400151a66fda2394167685925ced3a20eff94e2dd2add5a0f9e11c45b3083e1f64083a6a19764a16e8852c9e623fcbf7025b43bb9e3846de01560867c84c4cbd63a48e49963a58cf40a3195122bdbf09a37c37d6d5d30cbbb32362d33961956a1fabbed9154955a3c5e6ce89c156a05af80c400d02d9d36ab0134480cb835c57edf70f20f6662eb5e0a2e599e5377a60e3cb9a6cfe72da21b89b0c0f591a226a169c2185479fbe9f10dbe564a70d729422a43b6f74ae3e318a8b36cce1c545bb9893345c542a0cf4412f42a619afd247d0c0b804e3bfb8dcc570c37fd70adc22b5ed0d80dbb015e4d60cb41b8080e80ea1a08cf29c76d117423d6dea7785e8b94631ea9c1f52c2d89e4e1b09208a3ac813b0c20a3afa29db5f9d9744288ac3e6f9f4237bc960db4ce1335f7d01bce8e86e82df52e049eda9c2847c6c83f598ceae98dfae6bb04855f217c3636cefbe053b7faedccb7a67d33829b7750633cadf380deeef7e9f4dd3260101adfced93a7d844de1aec525702cd7d447a6588002d0d900a99d8bfaef5eadcc5ee34e1ec3f55afebc3ae50f3139912d2ea72b05d3fe5ba6095b48c8282901535f796354c939a2535f217950028d2bf8ab0280a1c7691d01601447376140ed0068d674f452ca7447885b45e01d7089af3c0b27ef11cca7ba198fef0beff9e954e06ba9b53e9a62e55caadcf31a72a62eb099a2a47be27b9e991d230f1d36c5381c1af7a5b0fcccf2ba77745ee460641f6c1276d1c50bda07ab8c9ca78e7be1d435257ba18d28dc006cd5ab2ee15c8f34fe932a9925c90279068d266904074f56edf4ec207827cda777a3ef648d2f305d28fb9ff30efc7e0e4b17148f61a304e4ad46779c8cc4ed50fbb3b2f320444ac60401a56a535c78a50b8ab635c24868445c4b3f51da5a70a2a520029bc3b5ae8251e14f8ca6cc7368711ae667e6c859044ebd77b722e54e6e5dbe06ef82778045874787a9e05288d94f24b385a37d12c39fc0457940b8d714a52b880e9335701057a7f79f02e113632e1b2001dfefa2d5219a658d68ee9c89026ef77f49d421cfde84c76f0087009c368310e0a72428dbf4730f9b4e91cba3167ab875dd515adf9356ce191ffa03049e3a757d0230cfcc4db575f3505ea37507bb2134822cbe94b9375a3a5eb9d527d88e0a339dc98b95d53e51642da24f23a7b54ad6725e7043077ae452fec33c59e8bac339519f7118dd99870a0f1bf022ecf1a0f3f041366d63d1cc1f3b7d399633badf87355164b46d7833ad53fcafbecc8bfe159e8839041a1f252a03be03838ec71478467002be31f8f1bdd213151843aba6da968b5cae34eb6b017a3709c88d6b0567cd5b353546361d123fd936b7b9508648eb2011c5ffdaf9b29b91bc19cd812aa349cca4320c5b65de7d0f0323e7778d097f7b8ddb47fbc018079ab3145512346173eba4ed5ba8b468b32d32324bc2d15c475794d25dbaf8e5f1281ff89d61055c1d093390cabd58d1f46083bdf824952c7053a48130ea78bbfa689dc5e93ff45c34ca5622927204ddf82e4cf0706f839bf2942c86bb3aa694f35b9942af93a9cf43f880658f0ed134480c153d6f71cca201a89b0a664dd242554ee69608072d9163102008e77fdd2b23c1bf00c9da052a7dbf5463df96da440c36e4d8a7f819c36eac2da4fb7091cc0dc2c98084639721e86438e79838ee946844c381358e7e1dee381f7b2f73998e85fb0cf6a837afdd4c70c37ff16b9cdcbd957080a913a843c2f7e5c1331861b22ea29f3b3a2dc9b0350692c8511b02cbd8831444c4292ac725dd6ef001df334ecc99f41b7cba6e12e6dc2d691b4a4b6468cccee7f384d768dae98a752285af4bff28ad0bda296a03ffd9b63ca47710b698b07de9f95942bdf2438b6319226e8c5e8004c576dd2b56c7aea2b24a9edaa9708ac2528372ceb5c50079815057b41fb19de3dfa18c790ca1814c3b7e344f0ac76d010845dd41bdd36ede95f5e3920f0ced4a54c2c43232b78b8c3bc20b6c774ab20252e78275967e95a61dc7c2daf6e0a85ab87ea5466fa4b82cec6149c8f94ff7094817de3db3213383355bbfa13b9026745b71a425d4a7f6f5c3840ff87d5d131c04fa4223cb74f611d7745c3d8f567196af9a7fe559ca05e621233299467085deeba3b8f894d9108d833ab85bf4261eec7fa5e9e8bffef0f6b4a236f74b5a5de95f64f4f9e37303bf7e05761a6e64fbe8b628044ca5309228d545cc8a73bac75359774ec9bfd50ad77833c52d62900d1f1544d01ed54a4b0f70286b6bd2e94e2019ce3c5b9e6fdb9af5e915990f46d5ebd158689a671aada966050289c6d1a27271c5e1769ee5c4732575cd114cc54c1af43c7a95a95aa6e963a4e38802af6dc3964e06c9428461cb5c3c3da283b04c49b17c9e20d60976a0aa689f34bdae9269d0c02984ec21f0dde21879f0a5c3f0ff612b5a145b9d827ae89f50ecb31d361cc10ad441c1a08501f594e00cf137be9b02986af656cbf31506da7d31606e59cf9b38406f02229febbaa90ae903b08cd7cb8efc48b0cb3a13de26902b9936eed91a1f0723a83828e5d511822d44bbe63a0d75bff9345b043f8874b6322fff5d0f79435c9feacc83f19d5a4b0fa7bc851eb7631e58199658bc9ac4808933f8aac87dce994ac148a4ef60225b981b18d176ff1fab30279d53bdcc36f4ae51773fb901739a4eadcc606ccee4c18d5ef2da65d1692820a02764f07b5d213f271e8984dffa001e6eef93b19ad944d5d730c93e3029a1b0960ec20af5a7edc9100d4dfce5f99a085cb88ad44bc16e0dcc826a50df48efcd58726bb606dcc2b7b24969be6668714b19c947c40a1c00854194712ee706f8be5f0f0552676867b55df774d830dc90a41c2b75a8c49e16943791828ec8ce3b71199bb2419d5725930774cfe9c5d143e7fcefb8292be69596ce8806dd9a944811a60eb131d87184525f84ba6ebcb885da3b56aaea6f9a169143d8dcaf3288ce9b0bdf589e8a3b7fa7d8505058b67946254e7230961908ee04e66fcbe2eafa37175ae18eeb5bf8cd427e66c9dc0c22b5d00baf0491d61ab0f676b7a78461eb618c007a2e72bbf75c35fa2047724f1c9c88114b8a2995c44a84969d521b5bffd23ba6dba86f6ec3804940b4756cc1c51ed58ba025824d3ae8476338f50d1a1f89d22b5dd44cf11a21adeed89824c8229073cec3146bcc782056c61798946ab8154b79bcce3c6d9a834dc25b9268ad6f21d84759f5276eefff3ee0cd617bc52c2f0bd1ff556beaf99f51b8d1094d4f1237a3dd36c9710a84431d23a47f7cd0a0060bb82536dec1fcd588458cebf2b316b0018702b8479887c44914594cc49a55e58d2b526c95bd8856e57b1e88839b211d303fdfe97f1c3a201150eaaed2c158499671177083ca5f3dc55e9cb542dba7bee0bfee6a28ad64dc5cd09e36d185e2ab836638b4717faba531dd0962166f3c760bd2ff376c843d3edeedc272daa830b60fc5407b3d2dccea072f0b6c2b524c71325939f958ca5619772e8ef9ff502ccdb0f5d10123350d36e2976549af5015923afc396e6413142ef7c99e0771d67b6e488eaa0d0c9959d7c7c8998142dcd8502ed6b89922b40e1806dfc5eabb1d3154b135b8c89f63037822886630f3b3e6f3624e42c4215eb913d7fd8aa8d70e1c71a7262e9117a90a48bb043bd792a1f0f02bb0b5624d833f374d73c2c2eebb76f0ae57be3afa53c24be656778ee42faa4a1c99b0f463fc82e38d7f67f008e249dde6281fa5b5241e71f05c9f819dfb6be0724f47d2e5607535af8167e6a5f324efce24e8f139aae1e68e420b64528227ffd5aa3c5d6235550f674e34fd999fee1112e7784ef79925b08b1d4ba9f4c98c431de6775ebf2c686d081cb28d2ddc636175eb9acc0c65c3fff7e87f0bd42ac807f202cd3eda14752d4b99820f86e08e2445fb7c8b98c02d2c11018aba063479712b94ac0563a3ecea1600450e8f74811a332007b24684cce373baa398a01c1686e2bc6a6eb6796a5aa4a154a4efbb119bc4b538a613fa62af32eb1267644d4c31c142e296b533507a7f1f0b7c3ee9d18fbdaea7d5e4747c6dd6a42abd7c1a3bd62095f4a10aad6fcbbefbf3affab53f3040f4134ea0bcfd83f6fb216e53dcecc8bbbee7ccab9026c300d4f52d729f28d3fb1eef7b74e34d3ea8c68f91a05b1f08e76af4b0cd37d6ffd44c567b00136f688047b5fd576061082779d4bd9245b9d52b162e117c4e5a0b7456c5fd999fd8ffde28a0123785a0b42d31af6e439b7b04e7683b04a777d0564b755c1f155bf4b8f0e74d2a7207b8252ba7f84a917d398ce5b3cd308f38b75e980825812159ccc77ef7082b6dbf9671f00fd54685fbddf9afc8a6f5ae0ed5fd3848c6ac87ebf8fdea61d384e37851c2450fb9157e07390299a48e662c31a121cb211bfc2ee5d0489c1634e24c2b9474fc570dd410b0cc8bded69b6913fce8d05ed7a5cd8608bccdf9d5aee5c109734ab1b17eb1a340942d7d4b214b86617b8f201797a609edd3a8902f229cd39afa906410070ea25645ef74d44e0ae5cffbd7014400cb4b1c1930c6fcafa510c34f06500a45627f5e1f995c0f60e3ea30c23cdb20f910f0ec9a5a28d4285f7b40e862fc62a49f6ae7bce0d24d66119b1d24fd79a0647ddb393bfc3dd04aa135b098982ab056d4f85fcd52f0d8101931fc90a1b1953fc5dbf40e0a949e0791507940f65f0f48131a927317792a5ffe7788f1b29d5d347ddcca7f1ddd70f5857b37fc967eac16d9bec76c1e73eb8d1a7a8c50244694f06c765cc8b07b3d1ab37846ffa77e307c22707a87785ddc770c1c9de3075c7909ff47842fcfd10f08d911833f782d8dc7aac537a7bdf79e7315c169474ed62087e6b1ff402e1e2b5a22a6e91b4d59cd337274f54f23f7f9c32e9c1254261ee62962f0754ef0586eb4b9b9fa76f671f7b854fff074e21e3b0446266c63ff71f80cf6bb550876ae89f43d94aa2f2f29809364564d12b631c25bc4e72ed0f3ba690daae5a6d9a982a2b4e65fe67e9ce6c693210d6742bb4a0e343169dc972bb5dde52313148fce7b5bd4f2e955f24e3d8e8f2429e7a6726b890349992d531feb04ed9ad7b8ba1fd1d51677e6b70af06a0e84bbf1c846e86351bc3d515ef0d7c0a96c83065f4b80c34673bea9e25ed9fc271c1b23f0034bf48210152d19cb8bcde7abcdb3c0062c64c04c7c7762000f312c4725cfe5ee38b8a92d932bb741b422e752ae4562f2abb2e0a85b232e9347d65ca012d8380f49d8449a83f9213e03cbc473b56a894e1660aade9027c2f588306d40fbdd9d0caa8a7e52243b34dd6aebd2e8315188b3129fad29cb221eae493c7458e01e9603c8b712a945abcd5102599925931e4ceadb4fde8bd9e7aa3e8800aceb8add592608a55eb2a1db466d18ca41c87a2e84f1ff3a048bfc37efbc5f7d9a7bbe5a1a115b8210f986544a2a7124d6a6a199f3fc20b83d09d84b06391d36414135a18c3a6a6dd2c22e1d01b17cd7b0c6d8f25be551ce0c6dbd5b72d5e0d501b16346b48e16360926bb9c44f0c6a75d4b64f57867e8c451644fb8126faf56e477fbe91d78ee7c6a7cc0c3b1e37664123bfa4d2c13af1e77f9c638864b6a0aa4349982d32d9ff09b09afcb68c86357b4e2e9849ecf9a4ad58eab7fa1ad5f03637b3433802a6f0f6d563be2b99ab77cbcc5f49d90a253163182afde9d510040af199544782f2e8411b67308480d6413eb9f03fdac83ea6642275c3bae6f96487417dc7668eb6fff04e3a40b1da16bff09b5e3b658dbacff75da5817e9ae3ff754c6e7e30817dc08c5b57a81b68fab8fd1a58aa30c091fd2cc64196b9f4d4f0567a13fc9d2dfa60bf99b8add66df646b1f3bb0dadc88a7fcd5262da211e8d08b0423984ca0d582a84b28f68721f9d76387322e870167371638b6d39e786a8245f22f92ba7b45d33a58a77881108ed83da234e31c8df78b0391bfbd3903bb115d95fe66665374911311cd29f9cd9732da2b2d90202bcd6f8a0439edbae57af1c149dbafff4da3a0e02f022717572d449cf900e270fafbd4ddff0c0cb64527992036d741cb16a088ed9a19f51f6b4f757937e68c679f67fb9a01758bbfd03a9c388ac4f69c353bfbef3dcbbe449b426b33ef263811f563509f1c8b1c7f890a00bc7553aae8ffb2c13de5207519be28544a23b06c5c28c9d3944dc439bfb700534bb3ec47f04d60d8925bd38d46d4dc001aec814ef635dd2c78b58ad577f4f0f06b6b671287030e1255c235292e421825d8d7c5a39d3db4d5a8a6006975ae6475f70ff9c8b50b7acb4ed78da63c1202b9a3efeb077973458f9d45842f65f58110d1518edf6ee47576c977f4fa16467d93b52af6c43266e9bbd2ac59eb733bbdd1bd9dee705363974241a792d1ba680b3139668d2fe02a877d7721c9cd8a609c9160c0fa81b276b50150edb83c4429bd2eed94baf9f24248a934f444149a5c24bd7fb96852cd1fc879de886b9641e5dc1bfbac1ffd4e4565931689eebe206417316980c4288957b55f5351dd80b408b8570fa48cc5a85d7fdc602beccd70d2bc924957ad7aefa01fe714d9aca4f5d0878e93639cb03046d8aeb69cfdc101ad66589d8c74234a25bb841340c670f4477bca2e3ce529d90eea330f624bba2c3d7415200cf917fdfe5880d04d9f37e2fb45563e594b185309dd372cc1d514d6ef5ae739e25cf8af249666f769ec8929d0bf52bf1e27eafab757d81765d98ce223f02c1c6e0f9d6098012de64cecdb30820e98e369f7b680a0c38c52135f7cfc93ef52888c1b8972bfa7af26f42110e87c6c54873ce4b7268a24b0513bf528f65baf7d537c850d98fdfe7cf2b2b55890530b1099b1967a3030292aa5e98688f82e50836cc39d2f163f696e07b6697554bdd9d4a2a588876aa9de52a828d988e19dd3984128537314d0dbbc04070be706941fc9eed417d3869591ffee184fb922e2350c5fc3d9816be97ca9eee9b0304c0407ee98b66a08a0fb51dc48180098abe6a18eb3de967e6a9b6565ce88f310933f9a9b3d29472047736793ee751eb35f9f98bbde9debaefc9c9cc05881413ff970ef5754f1a67fa149626d721d78054c54a6aebeec8cb6e7eb0645dc78d37bb330bcf1f0e6920c680948a5ed309030d1d36ed780b44cfbdc3499d04af71dfa3c642680fcaccb0730e9f4d2c5f9de57ee58c01eb3707b6d7b7ad7aeda156ff02371a048e87dffa328b748f8c27dea89f252b153e60ad29cc73ea38fc86188420257bb227b8d1cb9b42eb4f81d77a682be3c7586715f8cec44712d1bce5f65bb1828900e8e71f24dd5e6a14483a2e1da6231aac4a1afe621b58ba9f2ff0c09f75f26ec971476bee2d1cfbaf5760958296fcb76b45b6abde4e79a02b2024b6f531753ac8ada031eb60e91c15a03e7d78cb7ceaee645f5b30151ab35245a0e1f402920f8cb883ba01c370db604ba9b4b59d2633da9f24f32acbd42589ec66886a6ffa73196e170baefaadb4a536b9d3932042bf19d13e9804074917eac9a993090a4ed5a05c721fbc338d268658509bd98b40e176e83d260c17356ece0bda0ef88e8080925e591a7f1f3f6733fa331af74c82110e2618a4f2a6d0ebe1fe72d4c538c75d6357e97775c9052ce0986ba1bac33edda6a40d9488968b11aa209180de57289e6f2ee646af0045a11b4c8d6d1f09136ce1235ddafa55e697bf0ef2a874605fb104c03d8f1f5a6769eb08b5b76e4ab05860dbde50c737885bc5ee38d867ef2e816285dd39ff7e43a4460098b9ed4f4cab46f3e0a0820a512552d0d91cda7496095f5752e7498655beced18f1c325308f1188793077c9930d76e79a7730ed557f57a05e4591d93d05770c70f4e7a1aa23f127f2ac43a8910e34c93aecc5aa36e41e0ed9b4589b697e0c5829f7d7bc684f9f28b181d2fe53682777753543d689a6e1bf3a746ff8e46a55e17b00a0330106f2f7c70daf84267af104ee2b338c331c8b954ce2f2856301fc813653c7ed8055e1ac070ff1ac0d42fd712ae2c126eb2dd4437eaff7be990c589245a4020cefb0ae7a33cff5ae356179dd942d8b39c316ee1c7f45e8abd931b2e53ef1735ab372bb93153262054a5e06818449ed6507abdd19d772608083662b7a3e4d28ac10aed4d8ffb6f715b645617a9c1ef1835e58ef95b357223a7b88fbe84e5308b33f01f0d8d0fc8da0b7222d6bbd21d6fd8f75eda0cb0fae1a9b748ba0929655d98cdbe954061128701ff6de84e3195a82d962f26c2f88ba08d39ee43ab8e701d5d95ee9798b62246de029ee1c3c01c54b9a4bcc417cdd6829426bf0c467e66619f6a59c531e365f06980f8a16a6847199efca753a8a57b8a4782e5881b56e3360c5bdac461a28ef6e01dddcb117a92a61c5652c021a97a079d21977ec6d869c95793a649d3dd551f6eb2db7c1b6ec2b783419e00058bd81691e33bd14589de3fe350fdf92d2df73e6b5ba3455963184999bee06ba6b53de38616686e8036ae4c9f8bfdcb1d7b0c11837ada9c70c859226270ac5fe190548eefcd252378dfb1ae879200ac9cd51f301f17e38e55b847ab13107e3e1dd8b946a724e80a091d6fa2c1af6f10ffb5f86d525b80075d205ca2c27e3d0442942ee7e343d4b7dc07a247994dfb412fa45f2fafed102881053de838c9d8df8d68bf36e48d636cfa77e04dc832cd51b55cadc49ad67284a55f46de0fe747e6e14e1652a0b663717a796cd36c90f9aaa6f81eee8a3af5adce6b4f2916d9f3bba064fa137a673d1cbad9a333fc7cda6dab33d06aa0497cfcb3c9b155c0eee1952b9ec61bb92a5d01083fd377fb1d2e38953365e6a8b80608eab53b07b7d292fdc6b69f780b5909d87bf706ab112e3b4a2cc3c505d1e92e8b118ce001bcd9c28dd8554048fa5bcfb4df3e7e0b42dc391e730d32c6ae6c24dfb5119eb0d678e65f3085a4dce1ed3d9603dffdc9be55f6eb71a0cde4874583e73f38fc1125de528592656495d8f81bdc95e6d7b2539d44559a7f291aec74df635eedcb46f8ad6b91140433becbac60ec3e316b70cc65d1f54255b3e164835489542b587eca78c149a7f863117fe1a51d003b8488133b009da88ff989ffed7444c97230dcde56c2ea8a6dbd773aa2d92190b594b73b08d52c38f23c1b390d68e434c6002b229d36d92ae3bff9e87d3ee5a3ddaaf1751e98fc3f60726e0f5e37b880542b8edf3cd70fa99d502d8b85679ff475e777133e7ba2e725ddfcdeb6b8cace992119b2feb6e514796663049c1d286c5ebb846cfd167928ec403fdb65e384e7d75ebc965bf573540f411564a9b808445c7d447db81164dedf5a2331c7ebf1e9833b03e61ed451099827b9463067bdbe26d199172bda7e6a5223ef35b7b47d32700f49be9f53ac1e643f25f2cc9cdd2948c6e98766f7b3b82f4f181a6db30719be052846c3e7cef286965a33b4c5b3247a4c5f7f1414bae4ae0c4c5c303e252fd958c46ec1ba0fd690d1c072cf5be8c7b3aa37884c176f5030e7a3c1056dd0179bcdba4726d9763b632f02b5cb22ab19e63f42a87908a9497cc9fe8bf1fc075483f5a4c78c068caacdfc5dcda06ca2a8f10b3de1c71942fd100a996968a2ae7e55fb81df2ef1979f7cb39a6435775338e0f6bd9908b296064638b64854acee0d4320798741cefeefc251eed22931e0fd88e0fc79f6093ea0d06ad0583bd6f774d1218525517402f85a1af6a3f18c6bfaebfa398bcf6d52d686c3ecb5ba02b177c15119cf2d4957703348f71391501fbcd69c40125cda794cb19630a9a5920da78498bd1ee3ba8c0c1e794bb239000ed0bc3ed39a9a98f996b66706e68eec638abde73b6517df83bf5b16ae89cb9370bb9a9a79069c4aad1bc0600c6e54daf9b269522b8ae1d6d038e37f0700b18076aa9d24588c496e8df75731b17fed831a9db61d1b2e6bd7e9ab18f5b13592cf4d21fd8cd55e6094645bbc0c98e4651c0cf13e11f71f0eb156ab8a4feeb9c88fc76973446dca037b64f3dd7896e3656f4c0113aa1ec1708b3a935ed5249f74b1480bd9fac2b1690e4d59c46d7b1ac41c046a8664207d160d17d593b2dc263ec638a8ec2eeafa3c323e6f1f6db21a3f09c9a3fc22061a54eae41bf740c3f91c7d4d6954d8a7be74536f48075818c8924aa521b5d550ec661232d61aa17514dd834d030ad84a955d29a5eb3c7274839d171c93265bf1287e879128b3c6f9dde4a95287f7576eb0c246c18d99d2715418e7f5758533a949eb95d0aa86f357b1de4728d4b768081831469e14cb65f13a917a60950f4ce6a57006e13a0c11342a0d7edabfebf8a68bacb58d6c3529f322df239c62bd31c1d4d15b12da1891763676459566e7a0c30e726cf78ae934aa9a6a04c119e0545a6007bd1ef7dbe0ca7287e4ffdf728fe87fd038f5bfc7ec7cba1a30ef22414fd13d2f172c50bbd7d1ebd701aeaf5b6711beadfe54ea45ea670c1a2c56a0fbd00319dbf0398d81e8dea5991bb5f6e76007fa70100828613809826eb430c16d6c1d5a8224cbff9abcb253b8a9d9458ba99df60f552ee9b7618cf52d7dc9245c6d93ea1b617bb62e9b21185323ba9bead4d82bf1ebee18b79058e22339a8608ef0e4f577c9752c4a9166483c186b0919165679ca2108acdf2d61dfff2a22f63da2793a111583dd82dbebabede9649de0c78cb172087f910e1a8f0b8d4c49f80c34e18cce75438aa680f1c574aabdc5f048aa3576466a743c820d148605fcb65319ca4183cdd2c9c3ccd99e0642bf6e435c49f3c4460dc6427d79804aa2da409338d2b8a89b1e51786aca8235315bf0f17d4addf05ad1aabd72cb0bb8e3ce4b211d11627005e70db142280f5197b60af966d9114f09a8afb3a6c461b525141ceb0e5a439261c3e6070cd87e07b399f7f3ab77bbafdaea35778ea9fe5adf0b2b7501503369555a50f18b173273ced32da173e23610a2d93e0e8687eaef912fc6b0cdd5703e90283b46c4766ef945a4ab3d7a9ec5f10f2563b471cd6a583cf0522defb718166d30b8b21f935e238518b19d0f21ee8c85762adfad044362c93abe7363186c4b1ba57c4cf004cd745925136c5c1cd92cc8a19610e597b453baff5257f303df78b9f896a097cdfb19816be5beabf11f0e8d947ab2386413d615b66a67df9c1daab9abc994bbd2b9c26a5ac8690a75df845eccd0bc644339dff1ef2d52d0b9ba1efe294ca9adbd545d3b494b6491a3da772b79edd0e99b35446bc932aa3652f55ebbe4e9685a0cd11e2e420a21647ca80588e01a7ccd40fe6a63460ed60a5232f4dddcdd0bbb9b66d73848dc86aca11af1aaa6e5adc4ab95ee6423699f5c3dcf9e5e6d198596aed751d4763ee31f4e757f4bd994c0593c643d015d81fbfd4858b69bdf95615b82b3ad0580e71b7a3c9c6614636a1ac14d6a90468a2085a164ad2268805f1311861e0e4b6eed7343d154aa4eacb6a75102dea20705f7f31b478ec9b5d7aa3a15abf4295d6568416518f6817f07038c9e99f2682efd6f14a5bf03622f387addbbc385a5ba4b4a444656c9f20d05d98b851884d6a20ff36118048022c746cd5a277d36954076dcf272bf5dd0272681a6aaddfc549eab7b3cb4da9521c8d1eb4ee14d2048c5bcb6524be6403939fdb3b04f09ad3fca08b58852278ffe5d880f379d23399b6ec802a1036c1888fd261d8a4056551d69b838c4885aef86a25826ad3fd1b8082fbcc202a222dd09fd87bb39b357d1a294494fd9bd194d068acbafd5df2f7cc9a6b8c30630fe1f5b223dd56120fc12ceda37724791eeb933e1fe3a49aa73210587a522b11f96e35a7ce71ad5a0a64242c9e1c224d963d53a1bb1923f1931b16812574bd1b02a4965cfe6c644c24853fa0185f74c85d11416fe3bad69e45fbda438a21fe01cf1fd03bdff81d76190ef8f8bb309ca3f9839deba882419e6704ce16fb11e56218eb1cd213ffd7f5971f1056127e80bbb6d8fe2242d5b5864c6d48c8bfe9c4c9c91a1994433e51e7ea34d9e6d6dd6a89ea594f3ed945e4bd57ca2c1121b2e3cd74adb0eeff22e40c206234bc394b2c91f5ef168415d135dd5dc40b81f95a48264fe1f240a6979a4d1017d02e27ea5325a08f07518a9e632c4c736809487a6f9020fd41c60da4d1b4bb30538aba737badad68e96a3b1f692a764cd51dda70100bcc6fdcf4d74600178401f9f6162c9b9f1458bd1eacf5bee0875c7d2bc5b37914ef2de2194a8f6e7351cc2f16bad8db438e4af67d2338162f441818af67172e268f88fa2d923b3ad8ee003b429720b5cfff70ada2dc71ca14ed7b00669119f13f0897ac3893deeb7ef87a5dd9987fc9b484231734b9b1a4c4a2781a61aff9ad11a985bd7901f66bdf28d28c7e5001c781038375adf4cce6e64ccc643221233fc6ea3c82258b9fc90ecd1090c4ff97e94aba07e4209b2c4f9b4f2f7ace762d8636ae5556dddc9a7db6c2371cc0c19b55713654f82876a302372b5199ef4bd049e93a5bec9321dd08eaf64bdd9d46cf08f9270d57d16f6b7cd0f856e4c7638541d491356deb7adbf637bc30122143ec3e0765ab07719755a5ce05ebea45180f3f919af15f87124ac508b8be5b463b54de0aff19b25ba65db38709defa359553c9956bcb0f23b9c7ccafab5957b7f4965c19b65c21c8b3dfac2387b7790d66c2fe7185c231e98da494c6af5192b27160d9df980a039f0a6886bff41213f6f1c8d3d2e42984492351b79be3f782b6916dc9d10f22cd448d5bf7b2aac97db34510de209a044a3b5cace6643a4f284db22e4dc30eb50fe89d5d72f16f226c6ffecb0b51eb72ec0dc486ba751c967f6c6f0d0fd8ea2bfea3e9a4dbc8d82c258344196ac81a9bb1ed107be56ce72935d76b7998eda5f1d1a0b1c55efbb267cc0d416c37225d2ed5f8c70ba4b0098451edbe75f2ce42f97f6595445c2f459aaa9ad3806a12a7c878d53fd348f1351fe0988e21b24750ff276250cfe891ec661189db490ad5f50f791f9a368ef13e494401aa2d082ac97dbe151fe41688a512075e4a620855cc052703f969ead2248285205e06d344bf3d4fedf53c40d5da51235b345b95de2b3d4572bca98ab89f641615fb8f9a9a33da309bb052f4550a08a71b1b82ec5f5c76aa971e8ea85d964154d365aa41c0445560bef6c725a1e68591f3f18b1c80ac22d3b6c0e80edccf797b0121cce38f298f3429c53dac1044af423ff6a7f0487081ff3eab13c7b9a2ffa74e13f24f8085ec19a4f16b74961538edaa199a3b1b107381a38da2acd776c4cff9d39cab3baeb896ecc99185a264d88041c1c61bc06ce37046fc182f89576d528b4779032700b0c5bea357429345d2e4d7ed85d9abacdc5eb577eb8b81d0d7ea8d0f1cd9bfc350e1aa102c90b6879c19a09c08eecaaab69a90526c22a5527882a64c3b9601d79fafd83370a96b0c92f7e26c02d2ed25a32440b2f99c354064cd76688312db99434b11f9f695f5212f22b776f2a1f2e97483da3543b021e4d708aa182cd639e27631371686c75c4318315f6bbf4e4cf0cf8f7c6e6899350b14a3bbf50c5a9f103206eac0d18aa5d48c3bc043c0ee9cf8d93fbbbe509192512e1a4fbc6475292bf35b2d284cd9b7c5b92561a76f58c1f1ea4fcea0ad125206c8d9144d477f200d3d10fcd8b1847afc23cad6bc2dfbf0fc295f28efbedf13f0a1fb89ae96adaaf87264aaa2aadbdfc7250e464ba541911db0015292d8745324651de02824fcc2d6cdb9bde91f386a8f5c787319d72f26b24add0d493dd28d596c7b4dd06772261cfbf86d308e63c389ef6e0f3a06a161ddf219624ded78b1dddde696f3751dfc05f6f981e2f1bba940e3359ff8fa5d0986b0f1618d19d1422d970a42c0459c5356ae1c477ed8edddad6d7324ac538fe0b15e9fb5fd1c6655e00ac973c642fc22f0f9997bb40db0c59f0096c77e55427d20632eb8d672a76d657c0acf1dd571f0e27a5a12719d96209577ae8ae613b4bb922a7281f6fccf71affe872a8058284e37ef8cb72c6cd70b767e70c1004d1b82d529f6abddbc2cc16a09c296b064fc0774e621ebaabc92b87c1fd617506f42d37240883a037d8b711178a31f935d4826f693fbff14dc8d35cedcb6e992cca3fb061b609e15813d3f926f4350c2c4ae5c805ec4726f5b015f02320e12379a80d0cd7d2f6522f3da0fc066ecc4abdb4c792fc243000ba6bc535a26346b368ff10ec7bbca3183287057edc7493e90b383f72aac9d934daf12ecbfa2143c78ea1796a8147cee28cbe07c7f15c905a3e4a7aff7bd18cbf90e2bc6d765e612f8d3f3263a6c5aa266b6ce4fb069b91a403f60dee971e12e3a3168258fe8992829a4e4b7a76ad98819644a1492afccd31da18e4fa87a8797929c72bedcc5cab72161c3ed2dbca2e0928dca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
