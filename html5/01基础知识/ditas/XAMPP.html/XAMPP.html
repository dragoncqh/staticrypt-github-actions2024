<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76551d9b96a23de7044e0aca776a54925d1490978860344055d37fe8ed3eee951be2b8d9a3688185092a8dc88c87f1cac1bd42540379992eadc387fb9003a0922ecfdc9bb2995b7d4ccfecc7fd62f101de7e288b045256cafa832ee7309135e7754cfc5284b08558b8c242714c646b35ba82c333046a76e9a7e67940099fcd4e23eeea269e77b9b8da0020b0c6c9cc2eff0a59d853de4def6d6589edde1a03d8c25ac9b6222a70214b10df638008e0a050e2e862176a80a9d95006b1faf52c82901efbab44b5147b98895b169d87f98970101de1ac5c08bfb0ca287631e330408981a0ca1125723da169323fe9e2ac6c4e1569831c5c91f16be53e8551cddfe0c8656a4488bd414a58c9130f1ca845f10d453b3c0d5810b36375012d8ba63384f43879324f32ba6e37158dab4844badd31a050c54c6821f0a04375ac67c1480a5f4b14573125f56827752acd53f2462145504d548955d8cbb057ff9b5be9216e56d36d7875ec4e6850e663e6b819ef1026278706fa0df4c6f0b9d2f5069e03d256ec957cb9c78ca37988a4de9a48c1e52da60953e45df6df3ea4308146a53c27ebfcfa1abe950765ffc75a7c69bb3d8213c535aa5ac903ac326d9dca3c3487567b2ddc93a0d51aeeebf8e87819664e5fc07412ae142a672454076a8571b28aae9b5ee308ebe6ec8472e18a22a83f701e2ff7063138b0aea0a3e2239ec8b0faec7afe9c62443cfe4954f8b49ac2928ced4b2009425b2458e9e62866d9238fd637ff5e662554920a3b1502f923725f0bd36dc1db15e5428ab521245f4da9c371ea055c027b1412267705a74c7467f23a80a330780419104bee9829e4ac54c5e4952e1de91d192b96dbfa22c4129fe06ab58a8334aeb251a116c96c1d8d0b19cd700623350e7b19b462dbd6799846d231eb9de259c3d3ec85ce44d6ac3d42e135d1401cb0f8bae8b355a749bb82259ff3f272f144ceeee60206ee4c70a69b1e0b8fe1061241a587f200f1bddd911b9dbe13475456dcdc9e4cfa3b6697dcc8b56c6cb7da06e1e9d8c5f2d04ee70b41d0f55681f48835c3ec0785d849deb477827daa4321924b2b61dd2a79ff3bd48b30df334d203f646ae09d0c6a884215086a5ed85bcd881a5b05eeb1125c07b299b25e8e6b195c8538a7b9892038bab0bd422e17a78f068cc1bc42c4a4c7b0196a044393885c1c24abf9234c14f6436ca6dfa751d9ce1ecb4bb04933b8fb60dbd8865dbe0e282019a98c54d6b170033eed9aa1bdf6d1943e41b07e8713c3d6f394a3619ff29c67471126b7cc0f2584558205dbec6635f2f5ca361469ebd9db564a3d7c6d74bb72ea4af34895371511e81475a8bf26886cf5cc9595a01452f3dd501249ad43c56b74743ebec8ef0c2f341973e37bd281e536c41806182f28e2e4db9846961c918e50a210fd428b9ff86810c7ae8f4d3aa3422cacb0b15205031951b41c9fd8f25a463eaf0a4ac3037aaf9faa50bed6c8a1e1ae339417387c8ebebc078ce8c544101e85fd7075830be095c05ed28f59e66a958b48e42aac109b29bda39f660669117a7a4eb219f419d808e66c35b5125eca70330ded0707c78216279632a57c9de94e88d09be2486418a008f20c4740e0600ec693c0dbbc659c2f9f6c703c3a909853b317e32c926103d184a6416a2f8eb224e9434d589f81ee41ca4ddfe1053a4c42b57d4cda4e4f5342e99908cf98a2e82f88dd366474e3398c1db886159834e6f8f3e4baea2fe61e238ba437df73738148a9c652c4a4d7ce53e567d9262c42965ab2ff58028488bca204152d65a58adbb26c94facd37418913b0edd2dc8454152bb9dd534e4fa4ab0d2bc5cbfad123feaae6f06c266bc2b7bff15e6dea09dbcb2a2beeddfa50eacb481a99d7a7141e4a0b69a168bd1a12ebf26904eda46b9b377b77e6839b399066d275a8a5d94ce9fd8ed72e49c42252b3584e16e0c74f196081f9c3e84df85f3bb283f74ac876d4ba209fda694e3c4a0d9bc316b0d2e8774d9bfbc5200b7a67337a2323f32245f8df1220a538e24594f49e9fd01c92244002a00e5618ac5f0e9b969e77c3bee858ebf2595685c0fd60334ca49d1bd3a714e35979853d28daefdc79a0a1afd18fc2ca640723856e5c35f9d4979c4236f5e65f4787558caf44d28525b951635ba53c3a36cecb50ee17d95ec5af8d79433c64b9ec2c5a11d0d74d74a7bad858e371d87a323a281d673070d6ae528d181dac4fb9ea7a715105cc937f369c7a7beb491bd5c4b068670d3e648a2e53c46d2c72e3cdf8b0ee09dbeedd68df370d387c8c5c69304aabc5449b28eb278aa6b9ebef12293d1e981bb685c57b44bfb63223269bc2684eef38f6c34b5b78862cf7833268ff036a7f47cb5de8d4a8123b3f5463f443d21ad2d7c0769ad0bfd9fdf9c37192937ccb7521f215117fd73b78db2579a9b09dd32ba5991b485ea1a8bb41705f236740bf212f41f2c7d998951fd5c2d6d91abb8c8c68321c91ca7744432fc5abf0993c72036c71d576d885c93a3e1f6d772be117173c5d9628561ea9a1eb0c5a1f0d078b67b98123f3f14e3e0c73c9e6db029228e6d7d567e320ee6e1893129f76da3d647011916a2e3bcafb14369db92ba8924e4fe186c2cd7526ef8f5af1e581a9446a4cdd2651bf80d95b1dc24d5d61ec6324377928d986886f665c7b97542e534de0f35b159cce9aaa288ba975747d1c2b12d0f99807acc0ddbe83a4485dcb8ea855f7e1a40632496277b47ed8955dcecae96c6143ce15739db866cd43867ef9e9bbe0362bddca471815513ef3eb1b42464a437ecbf5f0808d7f3796c4c2db7936f9398a614811f2d2cdf56780c06fddd7666bc941c8f50e55aef3dc986428d6968b783fc0e501027e81fdde4236255ca48d212f839a66d42e45ae3881b0fb6c8027ccbdab0290c38c84d5952bdfcb8ee01ee0a064a25855a1c08c5fdafa5954c8f867f5b8f5c0de4fe5da4f24a52435f4219475aae24c5e0a0a8febdc131ade09124e759de7723d1ed35eb8d89c96b42cbae7afeba9c65b414adbf5ee6c3d1744eed9a18295420c05687755db6c7f6cd217b43377bf63eacd76419789d78ee15109408ec80b85792640a01420fea31aeaa19df73a9cec1499f042f2af8e0cd9caf3971e3f913de0f6392224799e4fa94b7997044ae7781cd074df1e0630f55396a360fe5ffc31eef66a861d9261316ad9b368a34e062b41888eac664b62e318c56d3012dec6cee6673f0bb208c11be70462484bbd0d7b3bbe6eecda788661ae01c587f677d63d8135165f5bda8184b073f171101e00044568d039db218988eb506be3fc6ec4265c5857a012d229545d58bd3653ca494b948cf7dd4721a91ccad65d22097c951842847338ad14c3797dac2f16f35eab43adf906bda4200e748b8e1ab91b97936b8ac6b56efc594c995288b3ba2b10ffa4685c14a0b5d6d9de14a7f1b2397bc38c8c82e2e60307b06c4e7a89fd45f22b2940ce631b3cbb3b2c49dd27018f4b64936e55cd0c3650713b29e34d1dd320ab13858863fa52cb3406b8e4955eeb270d4b05f4e69ecaafd837d8c77f9a3ca38a777d469156284c614b087324c6d369d7e8fab0e2a77c93301b2b0cc338e09234ded43f9db6416b9afb35e8fe0474b20ef777933ff42aa414946b407e8aeff1dd4b9a07dc09143e0ffb50e064c2a3ef0e67217be4da68a004c2f604ed74131589f3f20e6b99f3c0afa499acbef7a428c2d28c4abccc48e36630be0a419f94622252e142b6def0f4264c3aadaad25850466f28d569a10e7a6c86a98ac6ff403dc716ef8cb37b5d893dfbf15ed4cb2b73ac67e519db2108d77afd4f93c9a6807a223e53a3345db78e422e1bbeddafee28cf2558e3947ce959d609f55b44dbb86e614c647461e37e628c03eaf71792538d9142f1a4778ad797b73bb513e5224bd7e5216dddaa7d1183db36fa49748a55cee4d21e5e17d57b62a0be3348888d900c1e85dadafc2a37b41d45acbe79826ca6d9d14148f5f6e61012e3806d3dd04e4925462d3b278254792c35510a478a4ae1f1c483a590522cbfaae55afbf6962171100102e7b26b001acaa1d09025145e72dbb7f88db4c8645cfdb619b76518e7fddb2664dc535862b2cdaf3b0eecc140d31d7bed0b148ab38cb2e44a7ac3f076a584c3c062cff3e4fd9ff2c311896649f28b08d41c40d3910d9d4ecb1624cc00a275a5cd719e572e49fe8b84be7d3fcf1ab5be2106356dc5de8b036e89966981ec16dc682a325e712e7ddd9ca90243ad26e3eab0fc82f473a5212d6ba4fc76a82a24d89e1cded983745b8d901ef1899a9dc861ea73024343a8bef9f9488874c630768404a8df577940d950adb26ddc941ee6db5d65fd4a8f66a6b2509c8b5143763b79cb56ab04c6ac64acf8bbebe4271c7c45452b31387a745186ded32ce719c58e38920e118ce4d46916bb5abba66487461c898e1b5119e3d0130fb918a55f8459cf3c359bd7322cc52d501fa6a6afb9acba0261f53041d5cca14ec7a85338da40b4618b28cdac721fdcb80ac76b0d607cd2c2e5ddead6966a21e76d81a29c7e163febcbecfad8f4c554c6c89940d366510d27de819b03a6e312c2eee109b3e8a31ac65c66345a84ad0a6ffd8579b02cb3af9e2fcb99af9fbea9ec12aa9684b2911e52f357685f9f11a6d1237936ea07f4ffd84177ee4f9dba552471afc3f03ac822c8a23d1edf9bd6b1c66ac21b98d4c2bdbcf28bac190390ec5812db31f42c94af070f89f62c91401430f0322aaacc85090b198f1888691347a4c814fb53844b1fe511adaad12550d7b8f75439fd6456340120a2d736bef947076e51753e549972fca5903292a560204c125dda56247342df4e189fb3ab9a3925b40784fd0ddf4213d176baab3bb1138be7f4442ce93c465a2e95590641851a12b5f0c8b9f0bec47d8adbffbb9de7ad15fe0f3ba34df6cb4e95ac1cec2f3a619c8fe56efc22702e6f0c0b1b171fd25ab9eff23f2fb9e45bf5eba6496df7aa33b141d18270cd36a4d6f7afddb0ab78db13275d0cfb0799b3029dd83750c6754964ef97b95deb84825ebed477f5e013e05ab78ee871512c0e5e2bada07cb03833c2755e47c6cf00a890c0bab3a9238a11ffa38ca5d18e2c0205c5e507fe87ad5ac1d035337ddbefa66f406140bb19bab1af7ec4ec310aec6f4f9cfe8db57f1c37587d1638ee77f35866a69af5b9a22e218647aefaf132ee209f6811ac8130e1c62295d8d9782f278bbd6db021b292b06c49ca4c2a6b5a32e47c3e3481a521c1ad118e9bc477f4d83c0f318071e3e8afeb6547ae65f3a7cff4b2f5e3a5334669f538aef0ab1d344b7a499eef67b286da5ad8d7ce2491f349c964b9be3df8148a65c41cb440ff7ca514af6c40adff673a60fddc46e3b05b7670d5d32056e050af02dfe12ed69a6c2c4507e3c39853678163af6cdfbe85f443cd391a6ae88f84cbd434892099ed50ff44d1e32f82c1a8094154270da7bab901f23bc9ca11b4e38b7d456a2628989fcfcb391111bb2a10572a4e9e64f6b818886eecae63c36773bf029aa2fbccdd4f2fe36aef1b8d621483430be0620474b3dc038c40b610225e14e43fcf780ae3abfa2737fc38b208f3ad140ccf015986fae1e022d914f36dd9706e0658baa3b6ab6acd6556485e06e291922230dd7fa7abcbcb9f0cf6de8e51d2460bd641dd0ca9d515f954560dc312a64011b6ad7357c07574bed9e7fc6e74234cfceef3eabed6b97198f99b8988a0f316cc9e43aa95f538521cefd9223142867ebcea972475f4a6b39f8b7ad0b63e64b33fd36a8b77657a52cf22b0ce040913d76bbd4086e9b1f9d29aafc7fe888616070f5c85d06a6de673025b4c5e1ec3ec4c81303d92280ef5321ebd7cdde7447f7529ed6c048de1f628c9eee8f91ca2ce714986d58c7ba8456a2a7c47719d4aa04241a41ff35f766eb997074f395232d03dfc6a5f3f99b058b515448b6a5f0c14263ea8987cd1d3441630f34d6c568461fd9b49e7f3e9a166457b6fc7e3d57f00fec7021fdbdf8162d9b4f3e27bd7999c4425c00bbd1e5268ac4fb5b5d000f28ee6ff0c6c70e931599e4e72bb597af69aa8f71cf846e9f1e4c013e1391ada13283d4f0447abaa6ffaac735e2564192dc39e9a7a99a3a9139663f59c327aa4b0a8d5f78d292112876f63694081e2b2e73c321e3dfc549271b045e6eefa7238033dbca6353100204c304009bfc2521bbf2572b611e4a84f525e429bbfc7d82697b904b5ea7f2562f45a70d5c90b85adda0a70d7b13b12cd3691eb0aeb77f972f655e987e9795a0d4c5590b5fd56d03315027937ef6a8455f014716dc21e2ffaa22b608d19485ad25fa486d51a46df28841a2066d05335c1eacfe4fbc3619bfd3537a6d8441cb71c08fd2385e0f98dc1b2c176679c82be43394242cc9e094e05bb01488e183e7f196854371c69819ffbdae945ad2d92c287f6ace55ad8d1138ddbe15f508eae10c3177f02457d91940c26f6655f24bc460a9f5e59cde38f7bba2b0da88ca0172f372d0d08642f4da041e8bd98ab3669b3944515fc9349a084ec317a6da6974154bb3c7850c18b818d2ef614f1e0a442f35a3dd90412d86d349effd4d8e1195d58f0162c5a7514636eef3c275b0f5ccc8818ac729260a1bc9d0ccfe4441b5c7e757f7187a0a0a89f7b5ec2c8fb7cf534615ca7929f9b195eca3f200b3643a5f3063c8b858533b7eb7775efa90342b7f62970dd38e6dbe27841e90abf93cbd415527f05fae692ef58a0200ba9580af3c8f459a9aee2aba3960ef79b6408549c5999eed4ab914a70e7166b91e75ddd4558388705cf915a97054ae91dd76065f031ae3b0ede68dc8ad43d8e5e2e0ffbc6868479b6390598ca4795b850c21222d3cbe46352e586152a745b3395cc7d0a1c750cc26e8e3cce9ad51fb2f06e9bc92f70962b5e11a0de399f30e6b9137fb90b1be1bbc1ac692b175a6f674c16436929787c07d88fd1d063d28d1ac3e68dae6e71a6e9fdd79de8340ed7daeaa9ce10ccfff1a0aa49327762626f2449d0ebf0b2ad45d70d0b2fdf5ec3936d2befadfc10202efbe472c4ed18c24b5700496c955a51c8e6488ea47bba0cbd263e5d3241e4c82cd91b8bc73dd25a3cfa61fa569a56528cc619aea6fea3889e71bde02909e445df2b2792d14791f26131db8481dc313c579636072b6be7d8b8dfa48900181a003ea36d12ab2cc49f4cff7ebc56a482981947e8989898d1ec0c931b54615700b09f7142081da893a5d977fef1407f020667929d0d284108b98749b3af33f05bb6d7ea79186d44052ce0083c87f1b55fc5ac5b72a9184c0815a7596f04fe2cb2dbac1a750148c00e43a9cc0398146de551594ca6c135e1ea517db0a7f0e54ad663d7a8d90e302711d874bcd932e81a80ba7dad5ea1250b2c1b2cf9421a8f3142149f202df93de104fd4566bd7bfe894f9509ca9455f3aebfa84c06121661fc9ccf39812fe2b0f048db4c6770fe223dfcfdfa2ba2903bee95e5c77dbfac1b1f56dd9a405544081bc97033477fce198e06dfbb98d8693acd617826e3f0d7e795c0752f282690965d0e05e3ba491f426456dadeb71352462e65f6a2535180617c8f4ca5bfa2ebc4ad02a287700b039eb681c4a80e21d0235458124b897288abc1da0ff614ddf84f0c29c2b6dffe1447a34404d80d1e3df48ec307a7edc923569e500008bf81325247be51a214e9f052c3ad7929301e6914275fa6cfaf241848c05a39bc773a75b80349e86f1d1692dac0f5be255dc9633c0646bd6e15f7ba3d9f5934f48a17ab7084efac905cb4caddfce3bf6592dd46760bdde3ad76cb37e74d8808dd3ca2018f86d613d713a2742bb3298349c5a66bbb24d561e1ef4db2c45a917c69e80a24844d29b70456546f185316831ed74ac134c39bc68bdfa266e1cc121c6d1c80fb58e33eddda932e7c60fb3da9046f562bb2a0b372e448898b49cac98592ef9c76ef0bf2d304e1ea417250d4bcefb98bdbcc499caa689d5c5a3f9d57a95b15ecc17cde2a72c9bd9852ab2c5576b3fa93c905a09e01f31631a45394b7fd5feda71619b2f86a45f054af5421120cde82efd703eb4ef1342f20ff710023223d26f97ccf827329d2474b57f19a2e8ac364be75a5eb919e37f59f7220996b8fd32401168d7380172de698e96d842d57c5c03c66f672df62a783eeac22864d033b896ac3dbe085eb6430887694f44bb2554c1bc0c0043f0096dd32afd636065b21453a8a8b60f0e99674c6dff4c8eeb92f9aba69415f180c0b578935ce407a9fb57d2f85b23f2de42570dacc22b6212d14deecd4ebe7e5ccfa434dd3cabd4ee41aaf2dbfce3e5878e4db11a4ae7c8b9e0d4c463b48abd35955b90aed36b197cc45662a798308a8d28d076911393e60f56bf221a6e9ee8f2424b300aa208c6ec4f48101d930353da6ac0e2671ae6362ef27743e7cf47023382461e5b81bf2ea00c1c38528a4b122a15923cf85f77889d6ed414a49ec99feb048812597c3067ae8f32c7f127001fb970988225bc44230abf0b6d3bcf77e0919a9bb78f35a8c3c60490565b6b2555cbda6397d78d2e1c19c2858b3cfdb297ba090f2c58429fa32c3b32bd961a3a504b79aba998da77562c93d0208b45b245b258dc5c8bae7d8c5032647f4a2880ad4f6acd1ed1031b58bd60dd82308966d76587c1a20be6781554a39484cb8c4b99f90c3d5955ac3ffb8ae8a2131a880e4305130dec370b73c504f16341a2de31bd128920c0c5817226e4bebf958dea17dae71625c5b2757e2edebc7f23e8d1e83996df19b1c506fbfa7905ead118b1d7081ee22220ca5de7e7dc2cfbc277ba66da7d5f92563b246550c45cdb6592dec77e1139cffb9944bbd7143f64e826c685bbe475f9802c15aceec27eac8a3aa0ae12723e3fbd690526bdceaeb22d3582d1b94fe6b5fc569eb7e78a3243e55980de9efce9164df5089f3690173f4a34fa82ec3be010012785bd4a974aeb1043ba271a872c92afafeafab7e6b1aa6c9de6e33c370caf28ceb21c1806091bac73048f25b020e6cc624be28beff1e3bd7eb12f7036003ed39d3f663d5b67909c02aad1343c8d9887c07bff69ed89e3b979ceb8ac294dcbff52260198a1932fadf6a7344fc902468239071f9b022b23da1f4c757e3b5a45f624dc806a8dc42e8e0a159d9d6f6f39c6b548f07e09d6a508dd9b24352b4bf3dc0cb11091e87d0174c85a1ada4a94fafcb56359c89b8e040fe4157ac760c26ffd0ab7df44ae5c448cf54d94a4d59c7a1c28f88bb40c526017cc4539bee40f23068be31ce60d409f5488849e956ef7497358a8d103c11a17d15324b56f7ed73283215d1febd95cd32f680db83c4f16374ddf513ddd6c252fa2c7e309887dbb46ebce92f107b2175dc03293b258393094cc3156d628298cd25faa446417c55aaf8ca932514c787d371dca9cef3b94e0a21f82c326c2ed0e8a634f0fb994159a67df2d74d54e6759050dc1c93c971dd4aeb0870e7c4196dc5b165efd0e2f5689a7cd02cfc6e910d4bc8aea87f83b806e4063ac4e82967e8932b42b70c4259edabe8995d2d3ca2fdbd20b8767bc015798f374881699866a1ed53f5cc561f588b9fecc522e9d39a9769535f88a5be2ff3ca72f148e6fd1f71a1ac146defb4ec6cd0c377b9f20f4c76f716e42496f87d94af033b9236622826938c4595e0ff8e0b82e64a520e085985e75dc00f26a47aa63ec7e4d6f9b5853cc2fdbf1b205baaccd6de9d8a4287dbd9782d8a860296630aa1d9851b10665b484379769f946dc33deb288f99ab237383e0d97e1398b6e7677800d5f01afe4df02b0b41f76826fee45301088329018953dd8b597ed9adf10501a77cc3bbbe2a43ec353bd1e86e66f549b31f68a67061aca761703f399da409a36e4c59f9c94b6ac78de36b71335412d2f3a7b7a155743800f44c338730aa1d5a2861993c295d957febbd15a20798cc2fbf021a9c2657644a8d27c0c89b29326abbc43a0ddb9fda7d4fb5b9f68641c97c6840ac9ad210ccfe9225ba05a229f50476b2b3c96d63918eb423d992c33742c5b2cb9211e0bd4e1461e0d74f38720fea0daaa42dec908ab6fe49d538d9f6d70a9d667a64edbe37a90b394c5d62f5e2b56e19caf4eceac53fb2a884547bbfdd40ad40e12a82b662daeee1ab3e8691f849a6774f65c1d5231ad001ab96cda1a2b2cf8edc353ec16152f29c13fbe4e78c858345a9c704c63a153a62bd156fa7c50f13034c93ece113b7c8b0fb6bf151d5f6f00f453fb7f0556929e6d86a87b7651ffba211a355ce4b820998ee326c8692823cfabbb458546f212be597f9f5f25aeab27204c64d9a68949d3c8c814707bf69b653886886b96f3115f6bb9644d55c2d7b7d1c2a3d6cf6b744155557a6b26dc4a0120bcbbb3cf1b8eb1e5fb85c9a9b8183c8daaa6b451bbe0885b1a204576c92f9ad4d416ad3e2d328aadeb256c9d56b512ef576d55d025bea4a6bc3307239d8e28c3de90e4d0c0854c16c09c394f0129654fb8686c85f4aeebfd40e1bb7ef80de407b136d5d1d9c8b9e05557bcdf9c1bb527b51b78b9bb20fae4d710f1a44e2142b74f19bb3317e11943c8bec5e06de783dd3e80863ace9a956fbbd2d8f1608b0dd4f2c3801f34b960295297908c615e0a5ccb28f95ea1f1e0690a44f8acafc5c734e7382961485da90103f7ee3b65846a63b6938df1c72207d662c7ebc49e6922fb64ad8993139493687765ab3a43f7f8f8f17095326b36675ada0d702302166350e63cb85c6a088fc945b5b499c4e691576df994fbdcc43928fe33e39dda071d27d19f03e93722ec60b72cac645bc915b3b2ed52ea7383a1c630ed195b5b6a14c90c5f7631da11a3237a8ec6e30e3c4debcbdab8c1fd7e016fc6a563be8267d46496600668127addcdafc23196b263d434df4f9e7b869c6b6a489a3aafbd101bc2255edfc6b47bdd182569693961324c2d3c716c4a6e3ec94969671b4b79929d691425c5cbd5ac5503980e3f9916f133be34f9ec3fe3515709c8251771960008fa1dee470fe188ebd9824930737dba0b20fc20e2419ca7df200974e8b89c603854bc1a7be275dfd1dc2885cb72912d3e9d0c096a821069913832dbe7601008b00babd355de3a5bb30f7c705889b0cda3954208bc64630f204ae378a8dc7e4c9ad756e44bb3a49ef95eb184c7b003db12cae5b70f7fc4f0f5600e316a08f699ecd853616b314a3d91aa037ce15ffd70c36f1f22f92359da3b4a6aba97cffacee1ba36373fde1dd6c81969f567eb17fdfb2dffba038499e51dbf4f84c0dd312ecbfd3142189c47795ce5d21641221a049e9b0a9b64223ee3ad3100356541afad1542e5ff4bfd1d320d391493892f532bb51b83689bf26756fdb993b7b4816f50ff891589f7af25f1b5e369919aa7418cf0b74e2cda9e33aec640331f2db3194be825e5022348f26d3c213354f11cfdb4d35ea1aabfe04e8aa9f17b3262f0b695b9bcae11fd478d784465c4f893016a521196f32a1eba1177dc3f9372a7834e996c9a4fbc24102681f3baf53c4c22ef8d734fcf512336f15eaabb4262f8e717c85d961bf17623f92fdb4b1b000ce5825ab9778cf633ee7992eec1dc1871b2dacdfa42cc30a2f3fa18f5ed6fd2056f6464502cde064b663e41cb771f973515842555113900c3055a653f2e6e3d1f990946cc69b4edf958723840f4f49a983ff643d8883cfdd51680c6e3385613da957f6d7a67a61d21839411199a17f08eebc0d06111fffd1af96a64ed5f304ad5564debdf7ccb6849f7ed9c000adef2d2dd114db690c9e486f267a424a6df5e023c4f89ba3a802e6f63f61e1c5d0a1c29db45550d1a2ccd5ae6be5ad5434eac7db33d1763f6e2c0c6f9ba3043a37c5c257e78753d544ac04c302b5bedb2b810dc87847ccf29422f96c943a3a4400b8bbb5dca7830a2aef62e19fa4e53c68c953119544360d3228eb0568cce62cbcf86be082936b565d6c834000c338d4a96f4969f2a279ebbc6e0126e14234658c7b04551957f64c4fb10caa35efc214550f030046e0fc7996b753fd0f112f119f36ad247b093f6c01cea3e0a34bb6d098a6ce429da16fac9de41f45fd65aa0d6d9531dff3343e7f030ac924459048752811dac9e2fe7ed552e78088481f17e52a96d91151781ad9b14ef5e6313aa19a9e676b53b494873196e86629fc3d042a83c7a53fbf3806e6e10b4c8e89d3912822725ba3818cc340ed78d5599265a2c5ab752d271625a676875041efd7ef1f1f1be435f7552ca8502f6c4be6c6aa1c99269d8a0eb3e360f6e39729c11d136521ac0723fd5d6bb7ecb152fd5c9381b9657daff6cdad7575c2a1ba08ee4429ecb6e036c2069b6d9d62657790bed9b93decccd5b6fead6978f8cd99d3ecdd28c1040f99d8c7207e847edd17b599f9d6bb1c0fc3377b7eb2bf9844bca7326c0234cc5e780a70e95b553b10eebd991f03e48b87185aba47c1abaf53a3c2eb6abd201437a0b9590e07800fbea0dc624a712250b3c1976c57f9c3ad8905c8349b30026c85811b7c685771c0661f9f7dc817c3fdf69a3b4a65938977a0d11cd527a8dc77eeb826ae06ee4a1549a389b75c4de71746b28e1431aee8a86c894ec03c6444807570ebd8b3d75da828b9426280c57c210bfe8cff107fc4815acce7d78c7bc307478baf5fe520d04a5d1a7b6db4cc1935de3ae4d372121bfa414e224534a0af8b4245fd6f130a410f7409105f1e3f197471d7a154dbfe70672e9ff60d1611a262aa1e6a74f4905cefc4819a0d80fa86b75fa89b8b4a88b18971ebe41f21cf3a1ef0d92e094f7e4dbec961cb849bb95a8af46a76bfedcff2e79484d5fc86cb55bb4a0076eb48bb8643c5dcebb1419712e9a7490786a1871dd251b1657819f15314a5e5bbe31ef13a9b0a70bf5d6917b3f217856b4d2cb55fa042c7b9ab8e9c8dedd0a6d3c35eddc93f368a36c3a2be0aa3207abe972dfe2e3b5d7e429ad98fc2263807bce5932841d36747714c64c3dba5fc6ee35a242e00ac1226017a1f22f5b69414f491b6121035cbef4facbc6c37e84e80cb2ce60723f2a180187ffbfb70ea204b52a2352472b3cbe2308da81263bf4d88e2619416579b2342a07ffe846eb3b1bf5869d19d226115d030fc70e2864f5dd117c4b07b40e9f9f05740b4e8150b2106de228d7b73b9b86c347416019eb0460f8b37030323d216c544d6a05ea53cb56f4579b4fb876616bddbedc03cbdd0fbc14d5bd74a41a03bdf61ffd0e5c7d099960bedb4ac695168844abc6ccb4c8673e03282eea08c29e8e3593d98b8a67ca22d4649e2587d38c6e6f6539af6ddfdebf122899070397c610521417e73f03f050b6da47b6cbca557cf80e0a464c069a07044e895813d185263f9d14d9ba630b965ac21993ff91f9a8c0c268229c943627ed115152184fb0c490975fab93b205c5151fa7ff866944285dff2d568a45b5616fbfd0b587c3969b773b9bc74812ba4dbd7e6c8e2eebe829ec47557bfbc303b20a70e602d0cf37c499979fba1754d6ce36fc75757ab95fa0f032b9b944558f31f4c011675f57ad0fed3ef53b97ead42f062d99ec5ceeddff3025663edf089d4d92bbc8663c721eeb7ee2e6bcef339ea7e85e9d38f9786a83ab96395aec9c2e1bdeaedec1b0d02fe2de31c89ec21b1f3bab6944e0f100ae410a98ba61b6fd7e800ed0a9f8319eb08dba2166d2f2e4185d4aca2ad925f0023bed74f8ec66c3ba0602f58389f378ae133f625c5a0e5944ddf6974426302b937ae578f7d2cfb0b7bfb797bd68fbe8a9fa5991c7c85702efa7c02a104ff224d512370d450bdbb9f6d074e2ce67719bba5583dba2fb720afc817b5d4c4f58aa1f72956cfd281182662777243f2a6d9e5951f8af1868616a82a0cbd00dcec0120b72eca7f2121a0f3005f0dd12f1df6badb40aebedf6e8069d2290c00c081ac905ab587923e815d15e97eaf5573c1e1eb377b3746ba59d7754311d9a9900c902d4bdca22aa2e13c5ce667debd17c82910c3bdef219f0389027c4d5b92a6fa653e86b8da0fc2f7ec07b487d587601146a30a6a0144e84608287b85a64b101bdcf1289f0cd454c09a7005e1578c13491b79aeaea62a38edc36419342a60cfa6333623bff518e11f5f06e84b39167c7c1565ef6fd1e083e05ef77de1943669012553bb7f2f19214f667d7e2346b6d3a9aa0ec4aa83ace067806e1eb317932e56a4b67cca5ddedc7fcde10aacbb7d1b5fd240311ea46ac95454c80989133139be9dad6dff3869089724c1c4ed0b7dc11bc11bbb55cdf7f8fb5e9a3a7d0cbbf343fd74e3740aec44e38a31bcb36985481f1b5bccd0504632ad0b70aa371e02426281967405316eb94419fa0e6d5c9cf33c144d0a232ea4678a35322a55e25bbdbc341838a4d304fd3377ae6ae72076a785e053f6aea73763e669a2d355b8a9f1542061423a0536e744f522d0af614fc7aa4e66b1de8447b34203e032676cc600b27d0f6127f74f3b451d44a363738aa75faa97fcf13a3bc1d88bf88a3edc7baa57df26b86865e111d0307ad2d37891314639186e03187c5e9f980ccae953d4a6ca9ab50faa66d0e3709b3fe0e6ac4d0541083762b7d8bce8d3ac06fe5704e4576b60f2998b2437952c0ea109e732f893c707d32dd921ae06ab6f600332e9738b38006150e88f093ea80abd2d8e99793126faaff2238fbd2c02f178ff036e7e65fdc32ab7c320452c67624d28781386a502ee09e66af32868f089da8de8f984d6d213cc24e0bfdacd735e1110c0613e6bee9a2eb325d0c176a409779878df542442352788f2ed7619b0f5a5a6dbf521ec736553e87b527d9dab1b78b3a21757a5cb9eda14b90c27f24d552bc4c7aca247c89e68e568c1c7195945924d81201e753a3871a8977558a20b7487bfb04f0b3def0c2dcdcb0abadac3627f1ed80739f668622b1e9e5c267eb397ee911726800ecf2ba9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
