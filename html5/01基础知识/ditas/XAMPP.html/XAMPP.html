<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a55d55ae7309a28fc669e67e22601dc38a2569d031023a333d6876bd1c1f2990f2e34f4844b2a690768fdc57e1c924b31f5914689cb20a3de3713e14538408f5d3a7aaa7203c5b184f349d5f5492eabc7cffa624f884365ff3c07de51fc70bbb0bf3c59e33d60c5ebef49160810b68b37ed27635c0501269ef66e665632a4052b83f58fd4dbc133f398811d248c5d705ff875c46a5c25d2e8c5ceb3b992053e14f54d284d580d4b74e3dfdee6d4c491f7681eb97c060a324885575d22b0c3c57c01a215ab0ccf2f09a53c36b739d877c80d2088654c70f933ca12ca42ddd968a3953d2e1ce58a80f4889dbdcd467b6223fd103f65a3b5110c0a6563dccd53d9aeecfd74955568e3a8ae95b4ebd443d768a942d34f62a230207dd51f6e39b0fef352a4e85cda64c9f3fa92c67503643ece771869c2a651d3e78c413ca442405d0ff74a008848021eacfffedd70e988c641b421d72617c040458309828373538b09fcf1b0cf3f42af39131c58af73c8517562214325ad92f12e2a119b5fc30263b3ab7941dcb6e8025ec5323e9fa1553d965bed8208ea01f32b4af812c1f235ecbfacd58fb642191504fc5bc0e94f9edb4768b3a29e33874f7f2ab88188a12190f470c5f5718d590a02e95fbdb59faf091481bc8a549ceee3a1f5049c88a2794f19f216eb192174d040512a9b52b0c7fadcf3c8f50593c558254d649528a6fad855bf57152184341affff76877aa4cd28cb3c2d7236dd0afe3b07d83ab284e434190f30a781751577767b82de3add61ea66ddd55697cc69d8b50596f3aeb2cfda6881f510334d7300ba45bd172e91bfa7c51a1b272579b33afe1a5285bd24396554624e0769ec5e48fce243ac87c33d5e77b52db689e18af32b7bdc69d61de387af7f22f3a6556bf5d12589fc2b242de38e81b35807f2c4a957f2d8aeaafdbca735f5c69f3bcb8ef86108c86dd3eb2c4acfe4b33574f759a242afbcb9097abe2ea10e41113a6073c5bfd3dce1f449043b7e9c4e2c52c7ab3cefaa34f6d984ea13c438b959723d0c3f3bb6b26177203427322850c0229ef0426c5efad8fb87c5efb051cd8f547fca5b37166bce4b5980cf6b4dd47607213590b6850b45440e725960f7368a6a0387ff1d936e03e4e24e0fcd7fde38f1999b5e03510a2470476657001a6f17c99aff53bab154b8ee9697705939a69f7eebfaa45df85783efb50ba2e89a2de38b592610249a63a86d645fdc0a8a1867fa8161dde50e90a5c15a8614bd110d8567df0849a17ead6e9c5194dfdfaae1cf8a0f84431dce79ccf234ec362c83c9807b1796d248cd407c2ff26b9c5abcdd20bb947e4f111955a854378e9c7c00befca8f5b603b5ea5972ba2fe2e97e4d4f0764ba546892acc97a7445f87183d62dabdf9de6a35d4772f3cebe0015aecc69ff6f7d179c9e35493d254ffd1094933f1e86c4dee82a3a32dbb6aa28441b34551a2541699892a4c87dcde9107b0e13dacf5564d41a6451939faa7316593d3a537c3959d7305da936014e46831422c3736284638740684c23027f4d2eaa531aae65c9a2348d8530dc1bcc2b2253840bb6129dda0d35930f6aed6b55fc06fe53588f344e7867c57fda415700f2015627f620aa23c1831d34141d6b5a9963ba0083ae339eeb0e5f72338cfd3b5bcee214dc828e6d13e4d4024a87b60de14a8fc1b7c0fd49b215a1b75bdfb264a435a270f64cc9874dc33f962ac51ef918d577b05355d427ad4662d8e791e4e08ad0d11abdea1e98b5f0aa35082784559c657ec6e7318a7060af99660da9f0c1cd17657b53520d6b60fb5f5f745dfa0ce35bf8df83af4f43f388194fc13be55c5d73bf28e57ee9289d27f75f269d48d09b081da5b11ca00401fd4db312e6a78316691a9cae12007cc8d1391c9a256ad7344f648413b8771217ec02579e72e63a1f621c587d36b03df2aec0f28d2c99d09f5121ed56d84904687bd2d46f39ccada47778ea78832e8172a16bfec394842784394817a2aac36004f8685ab8b0c4445a287ccaeeedae642b32ca2a684984b091bfd7f71775c5813d6648ad0c18b336b16231d41c5a5706f33ac20d163fa7b629bf36dce27ef481091e09dd76bf32a56aaade7b1f2a0ef53521e0872ff956e6a27d8450bd6e0405203a45f03f59ed5af495a2df619d2548dca5eaaf3abac316dfd17576ab77b4294ed8687a9ee3295f371e928635a26298f97c9e7d931605ca60ff677be66e29022dc984f43a8690c1e579de1398f53a7e2f312aa9b2ecaf508212ee9b0004a49d6d640f83023676f7b33406d718411b4dd81ed07acaa6ac0a40f5dc9595e9ec01990a2afc80af61c8550e9c504d69b9789fd12527707f64b4129730b6cb79dc7b528ff1f0478179b065aee83ca44c652ee953df2bcd3a77a4cb872950eb4c08ba55f6cb2be8c3975a9eb39dd2b4c97aad6276cf066e0d9fb5b50e25f7f672beedb3ea010218f863ebaf558ebdab3065d4d2f2eaf57b6771570f13ff8d6ca05e5991feab85b238192a64b0a849e750a4471bc1f3d0c49ff1e62d09bf9bad4b06b9661417b9075fe7fdb26fbb0452e381cd8d20a72adb766873029eb2819eb484d9ffa987da0b3aa9d5413dde92f376ad2b199689d88a7f623e544f11eb35e5f1a1efec956dee47ea555467681459a9bdfd63b67e5798fdd13b2001b548f5b9629d8dabed07a2aeca4a69cd294f10b3491f1465ef8dc63645054d7978718e9a90c947096df2c9d9570a6cada1fc467e37424d27ad3085a4f96567f6589c0a0fc78a163197806e0e8cbcd07764521d553bd963c16eb244be271e6acc0ee302acbbd02fde4d51f536b2ad8fc80218ca174b54d877c2e61ef900c3fe2d3b0ebfdca24b36e87b1d8a25f116aec55ca01b4b2415d958cc8ed92455066d58bfb369c193c3eca0298b7045d7635b7dfef47f2cc8f1f3e0df850dab63aefa90dd3e73576b527ab3a414521203e85c827bb9be9e1bc466f2b7677acd9b11c5f18819d8141d62a0e5b703f8354eafc75948a2a8bf80a8510709b306300fd9a42cb3717efdc9d8093d87087d95bb3ccd059ea3360d482c802b4fbfe74a0d5389f51563cdf7de28ec995eec2e927fef975ed14d5af6f7453d0ee166123891fe0b577dd8c1c3fbf4be12c6042bccb2320456a8ccc617f03d7901e91aa119111702806ef13cde764c5baeeee1192fce24f7cb9d380ff74389f84deba3068c74b7c940b9c2cf9844978913434b44ad51dcd2975e9e8883c865fe208f414c4743f9a5b54aea9eec5a45a9c34317f0c9c9cf969cce4b326a1da9eded08e1fb7612c3112350d6e81161023312a309c4ab4dee1d71b25569ed30977acf1284b24e49fe11ad3159c109c32f758f293e0f1947fe46a52d9a50ada03535d5e396607eb1ce6b5985d28a14e8f19f67da83042390cbb4f7f6b785812a9dcfeb7a8b9f6c4c160710ef1ac7ffa07f365d0f444b21504e3cdbf662445ef17219c90863f9cc10c65b8a1d4eb0de3f09391e147db69c60848f702c259091290a64c71d1a6b8149621a90e7a73834a3632253a413e8ae72150a3522ea700f569fd80f6d5379783f15052bb4b452208c3748a77855395e3d4a980eb7daeb8de879a18296f34bbbb3081bc2f6d8acb0d69400e26b93302d69c5785ca4471257219e9a6b8d60db36da64cfa679036a586f57d875210bf8fa8250b6495ab40a23cb0e4479eb9d85223dd8097f0048ab360cba02cb32eb64267980bace2a688f79b9ec191f0d2f17aa5fdee7f6a17c21dce734bacbf10bf970973277792c9d775c90735e4ea84d233911433d326f9e7546b6651313031845b09c5a01237b02e783005b428215382b0e564db4f39d95ffacd4998ff450f250e3fe7b6be1af7e09efaf55951c479119f2a190c8f93bb0aeb654916d04b0249f3fb76546bf01f0309f9977408611681421a5aad03776b324c435ef2e287b22fc9a599f26836fccaf20dab958339f89cfddb3b626ac93c66b6b112629e1cc20127ea1c96dd011f74c83661a7a29b020aea75748ad22fa2d891bd7c5caa6c34e05745536053a9362e144203296687d552a4a59bc0d18a9b2dc0e8f62fa383200c04a05e1988a37e8aef6a217789563c47db0cfab0a8c80523ee7dc548f0fd15e8fd67175a8740b751441b76837fde16ceb31074ba4d2f45d75ecc3fb3f8c7c806d8f8fab58711c23cb6b5128cc6cfa8debcbd860c260a0b57233e6b83be5adb1582878a801247662fd3068905de20561cc427205b9b0130121ba0da6b525fc9b4cffc6de5fa40ef396872bfb2054f0d1595958d38cf98cbcaedbedbd6cb69eb799cf04076d671f99189b6ccdccce35274b2a222fc492240e04c5b54fd6fe1fd8e200f38668f76fe985c16dc291c41d3bbccbceb262b65d358a4e696c23101fb04327ac0bb41b2fdbce27f88f76abb5dac952a12f5217326e7831cb132e487070e1cb58368dfaeaea3c870d58de63bd8eccc4926a267ac98d8061df31d57d6264fb26f33cb4047a0448e93b10925bb6d5c80e1e0c3fd4d7cd16768a3dc3e47025a9ead860f15da414d97335168b4b2592b80078288efc82ecc287dd7357506fd7652a097aeacedd1caafaf5123b5df8bcf3043c47a2d3b6d0c5ac0e8ef784648391de2f4afbcbc0130de1e81b8b045b5a7b11bc155ef8a1501ea39ac387c55579d9db21e3e6d11454c7e37ee4a55b3a2029d3fb3c1221028b5a9f55c7eac1bddea5a5bb63a577c78f197ebf83076a0f3a94442d59a69e1435bce8e8dc04b41ac9a9d5ec0fcf21a4be9fc854435ee98155d2ba4b1e5161c00cd84594d4caf7dc4fd106b688c9260e56c12a76fbb9fda77c6735698099665be37157fd796d29ea73978550d80dee57bd7f58eb0cb306224084123dec31ac91075c745e02f8cbed1786e95d5a3ededed733e9bca2478ebb692964df50e7a6e630b34d846aefc2745688684f760e617dda6b2b7e53734f9d0580d179e2b2e4fef6b06020210517f4f67e61c6fda3e6880590e862fd2dcc9bbf07cfcb476409922ffe933de9c780a1012335d9f4844439ad4fad348e4f7fc62e984814033af46800c763d1b2aaa280572bdceb6c7c8696cc8838adf3fae294fc516ac2c9f40866bb24655b0ff53bb021feac940b88b9c6aba858129889a3765e066ed459d9a6a35d33b8eafcc065dccbc75ce14d7d1fb3a0fe26878f3bd82e208e5c43f0eeeee7bbaefce6fe91bb561aa11bde765b62ac0d4fcb3ce6fdce921d17b06f6b999512169943a6391a4192a6fe028db83701662822632ce2675725a5a2b5c17d1f961ea6170fa0b6dc479df18399bfe9c0222587de0175bbfd5ff1373cc14137fd68b6c88f82a4fc4471fd4efed4aab5e0ed15b8b8b3b9978b8dd870bb2eed5213aa0cca22e0c8144a295e29b1905bd3415bec221fff2a3c24d9074b5763af69d870af6d6500efbba1c01d4fe81b6af7fa9b478429c0ea8395d2b5f177cdb5b2a2de407d5c6bee3a9e3b6b02b972698c5c7b8ede104fddd0b07459ec8cfa65e73e14aa2a26cbade65e200e392ebda16e7db0ca2bcc076fac46f4975e9847a1c074d846276b0ee57924751c5a4fb711e4be0cf8ab2a1f359d5756b5fccf87a7fc14645588d6ad064d6f9fdedfc9bb6c12794702381efeffc2cae38a921902e5278e4552a799664851efc4d990036c25532968f79f9620910f1aa7f71d13be92826a6ce65e12593963aafdf8292a56e66b3450cd65a51317a4ba5ba397c6dbe1dc872c65fdb5006c3e1913cde040c45d5bb3f12612eb0313ecfaeab79f17c5ec295ada354cdc114c8390cf05600c01887490f1bb1b72ddd3878fb8ad7c0b23c264ad36c010b68785142ab6a82a57cbfd7f2d3c5349c03c451c113a96b51cd49483ae1b507ae73810bc2872907af9722412264f73a07fea5339d1e096bfe604995ae63427620f6be51520f10ad6498b5dbd295b8e9a4cd5b115461e3708e3215253592c4946b072ce2c62e678ce95e738973303a220cf6346e33aac0282b21d29d3e613419df81276c04e3f16672fc149b53da1dd652d9a76e0ff8f77653e9d096c9ac9456770f8918ac9dba5b26893eebb74090957b7b758106cedbb4c30c6207f1c914593f7318ff0234676a0264119cfa4ff0f742cf1c185988d3004aec73fb2bdf04c9a6790c6c2a59fff0e2a99d003bd63b276ac1b0cb9386b1730e9830c74f1fc0698e6d7333ed26ac41c18c55717d2e810e2a2bffc59a083f3da4af2f51301be6865aa5d2494c3394b72d4d7683c3012bd8321f9597c91295583788aeedf02cd96383c78da5c349c0e319d3ad4a188f9c6979d5efbb371d305b2a6682352c41461225828e8899888029ece18491c8a811f1a0d1ab610094c5d73d67b06dd0a3388a33dcee19ed51175335c9e926abfe849ea4e1149e8f7c450b764bc69ea4900dc6080d85691689d0635670ae9573a4206c1b87a4463679ae12542bb5c7d6adb27fe4e11d0a99cc3b19e5019e7a754734b13b7c85728bd7011a112919f83d897f7c7c50ac509fc5c83618f4fbbcbda37710a0fa00901bffdebe70e495d40a04f946929b094354c04661659828010601c89d07ac1c930cc7e398419d6197ece873c536be9ea4abeccb16bfab269b39105a9af7b9be73b9bf29de5190fe805ba48f3fc3b989db0774030ee2f95ca561b54a9291c221b4ac82452354e208665fe05568c81941b4e802cfb1a190503a6f08f97bf1a9ace93cc66534b20cc98eb8c8107974d30b4f1a99245d9e45e657428aeac9725ff35c6f19197d08c3e996a18aa57ba23645026fe228ae0955e198af47b3c31bafd8510e3b69e313f6f9515eb9f5a00c935ee1e8627f660898bd9762cb835daf0861460074f95ce37dfb719943b6c51a7f898ddd0fa1c7f887650429e8850bf10d7071c0a8cb8aabce32902f1aff85493fc84db85c71cf1efbd69be5d5c8b7fed42caa15a7fe1c643b63a04d7ed4c9227c355009c9ebf30533b74df2d2152f1368b1bc5810721b59463011bfd764a03de853d1fe152d39900a76c0728053f52d441d2a5f22a7e43215bdf5eb151a437c86b60448a1acf9ef9c810c028af5a34b84ea443e2540a225bb72b5a70354bcfbc6e83d9a1ba63eb10a2c419b387bca2ab80907f70a22eacfe51a01afd2c1910f54df367f18f3512741e475f3abe4be4ed8be9563a9e698b569d1b740ffbad05ee7eed8ffb614dd2c556dfc74cfc7deab928af0d1d936741eb156d68e6220796c921bb4d3b6a6637ff9f35cb6d57d66d17b82253546e7da7251eb2f252aafc3437914e27a921e478b48a9f0c528ebe9d29f40572047f4aca47a6586f2b9bd04f6dd6b3f7b0e12ade8b12478ac81b7ad2470dcb524ad5b6b1a9081d0b33d823148189883f85a6a395970874d6a43e9892e58a6c63578f7875711817a8721489e1062614eb4720e65797fa12d10d1fb767cf31a19c9e9c08558775cf82fa3b8732166841b07ccab5109b2e2b483eca845ff32ceba9930ba7b5116eb616ddb5b64e907a8a7c0c0470ec9202fb8f2b8fb8493a93b124c01f57f1e1206c65ee7e859067214467ebe0a960b9df0e218afd05afb99456c2b856ffc8014547a8075a924a158139f310ef7fe93df113bdfa9f2b3f2d01f58eddc44971b7ab1ef23b4f9dbc7344724ea1ab5cbacdf046e9b7ad53b2629605e66f626bbfaedfaed1eeef830673650373c59ede6c2c837643f0df64006c52b0a176f6471445e4fef6b8dfb2bf4f4534d4a6d1b5890ac44ad3f9a818308204db2f68e254b1bbea2d7846ecc6107cf71074f8418b3c290a08dd10caf9b3243d3639644b961545e2bd993cae5ba3ea864a40ebd7e5c8b54358170c29d1145a5b94ba81a31eb43beab10890dcfe7d205dda141c71545e048770c50a80d909ffecbc1741df63555fd9dfba1f6a1ac6a1cd9b891c0030a8b4b1334316f3858484280d52d84bcd211e85981c6a508fcf36b7f9ac73c0dc3880c461fccb9758438942221947dec3f9f45259f69e015310b33d625337b43d3f8aa57f0434340c0d602ecd2edd2bec5965e7d18c507f1e63db9bf57b6539df0c36dfd1ccd7357bc2c5f770f9851f621cebfbb9e69f1149204fe13bca7d036eb949cc13be81203df510a9e12876b015719bda2c456a5f9da0195be97a93b7f6bc526cd5c404084de9ed0992a4a6ae789b4f0fd4a895fe18a1583bd837b3f40c2d92494e8ed9ee551a22df9a5cb14c18004ab71451f7b4a6a275e18f2fc570618fc515669d53e83e9ddcaa6515705ba992fc88e0edb8f4cea1393f469c5ea6234e80eb01b72ac835e7a91051f8bf93249fdb4b08e354e68a484a9cb1305af6c9e7eb0efa07dba1cd62188a866a8914206dc790c3606a4eb9e4c050ac0030fa831f9ab7ad01714ad5740e1bee96c3624c72245b6f84f6fb06c418144b23d116846d93ca65f992347b747f1da7c05cdfffed08203f0ba16a10fbf1817e09d21a25a2feb88f7e1a6cb170ba7f9254712659750be406801c82bf467dadf22286d5f8aae2a4f20e7ad8b25c3927fdbcbcd363d2b0bd1f0d623a7d6d346fc1c2d337a451924a70c7ca8aa830ddda1419bce04b095b87eadb8f474ea6bd9a80c6e5374a1396364cafcc18510da883c391785f380c4ba83af25f4d26a79759faa396833b7969c9b3ff15b0450b28decad799fadd67818e912447d63718688c6f3076bff0958c091db631b39378b7d21386158bd3649690673f26537d2d41bc9a79428822a579b167c4005872a98745d2be11c91c751bd249907c3c074fc1e95406c044bec21074b98927b1042dd334028f1ed85b37ac6ba0aa61cdcfdf8a05562ac8964cef020c59e6772162470287b71d18842cdcdf4d7fc2d8778597e519e215d2892a9b2c0bca6875c7040b6d361358eb30493b1a666b0443486c0464caed3a4e506001347a35b45b1017c089519887e0e482ec6d7edba80a56b6051e609650a96a46aaa26d9daf31dded68eb7d99f57209b4d4d5859a8e3524f7b6e92b0d375daf295fb5ac690866c99b7820fefea37a467f6fd49d58e53a1d5ee44cd1742e2e1cc9e56a25e8d2493dcb69a3240e186021830fcb0d0fa826a3a4a3bee4ca7066b0920c472199823790ea380f93bd106ae96df1c5d30bdf31fb1d971f745524be1c840db269bdf07dc835557c5bb7af06a65a84614c8f9bb1a02cf7083c41ea785d3cdbf4e023d9242387496158f169f6e60b1a730eeadbaffaddf79504324531ad766a663e0d8ec9cdc7e38eb21f3c8ebd03c49046f150eab86e312b32ffb000a5b9d3ffc75ebe21f76e021c3eaed0e123d018c01e6489d3ffdf3bd21af60fcc7c3a690381d1abdc98e2cc17a068cead5e301b5b4ca2b06c7c59be0209c5e787f8f7d0ffb1bf05b0fef7253717a04aa756e9498b84ac098dbfb3400829b4c1a6a7998d44c10c767586584f056a1c61e2676c1dfce9db10815b59d7adea8eaca9d4476ae41324a4fa5dd210a5352350833197910d6d53d732b6c98f829197bced61a6c0825e12a4548801f603985fd44068fbef36ee1a55361f1be5e894f2d7e2e80a6603176bb695b1874c2bfdd472cc3cc0b3870978574f96b22af3e68acbdce427193e1b323aee19ee932a042a35ac1c484b272e1922e998db082dfe53a09e5d2ff522d4028aa5cead8e8be726fc5f9a56d02ad2f5248fdbbe9ee1566223da7e9aa0d6bfb8d9a2a340ff228a26b32662de7814727a16ad3938c0710f5d5024d3a5de056938f8ad57b1e9cce739c6f716fae2b7feff610879cfb8e9672cfb1394d6a1eb616c656a28f8349c67ca313f5660536f2a00cf83ded56e8bc7071e6c41e46c2f1bffaf2b6ea336810f79257d588ffb2a4e62f75f192a443fe2b37c1d9f69877763f0fe1330d7200c3900110cd374aa1a83bd319ae70caf60e547ad7b2879c91d4e6c971d3602fa34a02e81798bbc6d29ec8e2cbb695ecbb8acd3de4d6ada0d0aeeeb8115377ce21f82295454d6b3dac3e1b513770e2145f87835273a089bf763ab8c4f0bf850e1d0efa2b63f59ffae9e298b909289ca75e90890789983b7fa58d374defdbf0a658aa0a807b1e5d4e01415333f7e58ebc098ae9f523124dd2f44742b12aa269625af2eeb4dff369c574c42ae0e13735726511f786767f90546f210a345379cdb181de6298bdca9ab820dee089cd8bcb132f569ea31f54bae77236e0d661241c9e10a1ce6e3aed671c1768179d2bf17cfd9829eb85e97cc54db1f0e85eb58655c7145af2de774e7933b2f4ba97f310cede97ad7901bb5258ea0916e1f63f98501fd604bcdd33fd9d2505ee7810548c705b957e3352c51a29a86fd68175317cab0a6f43f9aa9ae174acff4cd465e6725db2a7858ecf553238587e1b7eaa75251686b8bda02de24b430d2c2ac3ba8dde5d4d132c9dacf19cec7d016218ba2abf222a988962eeeda18734bc7ebdbc2990e6ce435a6cb455660a9e5143d6b502dd82f13f4e310be782905897902bbbdc63d0a403ca4380ec2360f0c35f29347ab214047b8197499ba3f7a8da71476be6b82968f07a0708a478a2427f12c1f0ba8b1157254f61e2476659194fddd9451932c8667e650a7fa7cbf68f7ce9c4543315a03dbdaab6360e7e1b3b5fb9c8015fb7ff8697dc06556a2afca377be265c1378a95fdf5bfda5509defbe18b7f49345915939363c106724750d4d21a45fcbea32f01d5b90ade5d65b18791bc87485a141333dd3e703b9cfd718d2a2cc22c3fcebc22cc97a8a4190f3c4244fa6f35be1f194537a882113f4fd6d3c4fcf4e335b7ffef8abb81bf8b8ecd23f2c3d1a1e33cdad256e5c9354cac3489f92e0c5934569dbf5cfdb0f719bd46f603433cf1e6d06dd93d907038a63ece4055b586507c8a68296a4d48f682e4fcd08f2cfc64d138c06ffbac714a09b3388f694ab92ed6e76754a4c1fe381311f18e32d1b5fd12608c7abf01161391ec295aa8b8fb040da2808742b2b4ad179caf449aa3b9ff17c363b863c20e505f4e70f3e9dd0577d0e448954ce793993bc03055570958e1d90f09c3ceba51b99e0006c678484f38762297b0ae60720e3ea80ba12aa7cebff1e081c3afda3aa4f273b4660494b826e42aa51a76e538872c50afed839c079f2d05e62c3dffa35daaa64720f43112d99c1224d5561b2726b304abbbcbd05b8ffcea88f61dd265a51fb386097b2df3ea14bb319b915dc736e075684d56ffb37c3429186039736fac6a2c12be8ff6da9a04762473deccc3b3281c2ed10fb4783eb58067c99bda02f5475624e48f64553471ca9891eabf250404999bd1f8e2b5cf32f71f72ca177c7b1b54dbd2db64e3a53895d86b7db7979bfab5a301277028926b8860520df7639b73d14f500fb6f45b41aa2e86d260712d0b716d96cf1e6fc8dc52354164fb6c77e47c70b64e5d2fe1ec7387aaed2348951d34f301882559d446b49dff766f2114abb7a08c0c8b0b99b067746c3108f3e1549ea564de77bf4c624c57be55df040a69efecc6c4bfa22daf85d5c99636dca854439101724e5d3f2599bdda4d2441dc3bc3ad4cc26f1f8cd6323f3dc0842a903ad1db74cf8e8414854061e23cd7d970fa7ee165fb088cb40b85323c5d3360d644a42e9d0041811f5158cc5b75607d57f511e3673a3b26d2fad308b162ceff456c6258a75ec3e6c28eae388218df40c29dde0a5ed077a1183229347ab7a6e534ba374463b27f48b8ade5b6b91f3c187edfb62c2b2690f947f9fdfd937da5ff610867bc8958fa7c08aa666d33597f4888cbb0314d7877c7f28da4ad7a645904297c9fca7315bbef318cfae1ce663cf69a942c0258bd6e08ff302fb03ad8cf82c8f3657cca1728955c76a52ca8bbe8d779cc821f2dcfaf0fcac2c3db452d24a3cc8641d948ab9750998cf888e2660058113d2f956ee5a24727108c45ae14133f376f7ae0cef2faa25395a7fa93f438271c697b1400862b4abe8126301d783cf28ce5adc08cd93a47d8430c1b0e47e67de3a21f3484692c92a6142b2e8ad4a7b4516bb7351db5aca7a8a7db01e144a2328c51c84abd22d974e5def5a6c228db6630542fb95fb74d240fbcbb5ebed74e1eabf44979b0f6e4fb150b4cd1ce0c6aefa42579153e8e1244414155438cd3d7eb9ed43669f44150581fcfd81bdf020079b32bd60750f592a6513fb262b476b9120600a467f9efb90ea7d1196d9d0b95ab1268db5807744d5228431d08246d23749c6e6f870fe2da026e83b72ab79d9543816bffd471b34110da282a2f1232650681d339b57f353dec804f39474667e198053a55d6d858f4116e3622b9c3aba68d43e567e6bddfd92b38a26025e3eee792bb81185fa4555f27b299eddcfdfc448628c3c757de4f80bbe90eee4470938539b2588aa9c47fef6f842dde9c033a0f93dd2ac32e1bd85aae41dc94cec9e5655f7eb81a21e762f34240fe4619c7407101b69f746ceece456c1832c80d41bfc90d6bc92bdba6e075ff794877600b32921d5d7b4214739cc8509fbc2f0dd4ff7c788b09616df61f7ac62d4747a8ce280ed104400fe1561ebae92d418bad89860632b20b88693b2afbe9a6af9db1fd443f6a8aad2c37c931756adf9e5cf380e424ab89d49fb57e13437d56da961214d9034898ee8764440765e543f76c9b7a6d2366329f15df96c5396827eb34e89dd1d48fa1aa5017a6f33c0244a796ccf240ac59e4f41db4ccf2a2fcdd1a414095baae48cb76c70f0dacace29967199356a46dd8c369eaa5a6dba7d1f63ad5e01d966034f0b6389ee05f2bfe720d57a93f2b729814c9cb1f21201bfb81e301e223a11975d389ec140dcaca1139e887c55b5c49816bca2cf4d874fee76a155dc73d6245b99aa697b6ab09d08a5765a4ae236f303ab746c63d5a8bf6eb42ff2c30f37454c827435354346c500d6aa1f8174b903e440c44a1b47a72d943892ce37ee4b778d04184a017332a04ca839c654fbfa549c8c81b79901bb36a3c7844f0987a17425df8b9c5ee05a598c4d4b528514492c8f3d6b66593063aef675399de7ce1bc8c4dea61e1e56352fe54e03504e45e5207de1964261d52091e34fb88b6f8f106c555d4bcdc8ae5cd6d867f2c2b78a64b1ed1598854ef399e907c9e4c4ff94985278ab0c7470882f59e335a864ceffbd39693027e58f64276d0cd8de5aa0a717d6ed3e2f037519b3126e30765acf9db1ec5bd29657a5b81efdc36d1304b84f6bfe655f75e0990edbc83af4ed8edb4a4deef92e9a03f4a1e46de0e8e9c1bac143014d332f6afe077306e519a833359208b434529753ee8064863560985753eaa4cac5a2abc75223dde10041192d8c99f808208d296528bf790eee2848e41f47a61c432881c76e9b78eb760f834000ed078e1ebaa5547e31d56fd3fa118e8f5e13224ec30da956b6de89dfcfef49e3fc420e423d0f6e717d87d43016f988cd09c805e5ae4e3b95391e02dbe6ef7f0f9e1e9cac808a3bdc32e56a2ec9ede599fd56aef52e22be39d81f0777485c7d03920d1221e9d1b578a797f942ecbab8e4e8e8e7c854ae3480f4bcae8e3e4bf9d6f7c1c70f1cee3b601006b35f4a0027a933a02075a37d05aed0f8241b3b821cc89056aa2a123307c2af1bdbe7bd1515c11cdf4bd936afee12800e4d5aaab4af7fe3c7c1fac6a3eeb6b7b0a6f28923f72ad1085385c345663467bd117e4898f46b1efb2124888e9397d642728704410e6f107fe637493e35e254eb0776c8040a3d6c038ac5ce4fafcb3d699dab6a9ea4cc41802f651b28d9430c06a124597728a3eeed5a32f6fa0fde7c3b36c21dec7ae63fa7ced9ad91d0c681f1ddf19bf3c6216b2e8e5d108a2cc2e383dc61adf1c79996dc83eff74d4729df54513c318bd548c6c74c57a889c45eeb09fd47163759ace859456b90bd65c2064971ffcf3bf4758afa200ec6a6abbf8a9bef496408c5be2972739b3843eb1fbdf42a599eb8928ce6f197995b38f6bfda61e078a570ff2a7165305564d6356566113bd7851e1773a91949fb0bb63c899b245bb2af57b3e2ce297713a3a6fc3e8a69d05aa19d898656f3396c0c501aef55bcc42b0bfadbaca1c771cb0978d4b9e00e44ac9a73d36d4eaa29d9045e73d2264ebafaf8f0602b6b3a592459401d37c481fa1bc3e0ce8688e47f881e277f1bd5c479c818c6a7ac3cc88e0a13146875f2abdc0b0fc2a957c6903aaacff5c5a42ed0962f7ac2168462e6329219b7fcd06047a7d37ebc783680e8707d05315e1a57027601b616060c350ada46d29938bf3e4bfde8ef925889d9b0ace4b419cc0fab9a71ec2cbaec0785e996c51af54c7f3278151ed94b63851f6ce49d5700cefa41552795af54c921526bda47f175cb950f0284d0adf20c937b32764f25e896073b49dabefc20d5b1fc8091343a708815fe842c7c76f53d85910080cfeb3fa61a5690743abfba30438cac97ed6e55d8fa846b13eb52e3068f320e14c608d7ccffba6fd0fae6b20e993fc8e7ab4f092d7efbf29f91dac34540fda94855e8159695814386faaa20710d46e9d0be6e5fc7faa8b9fb751ee146658b95b1cb5ef4dcf1a9d6aa13bfb6e7b0416778301d5e2cfbff3284be4cdfa5400490f49e46620024809a647dbbc7d88d4bc9b772a6ce2195dda1336fbbd0f5343a7c8c5da2ecaafd5797c40ed0f2bdd5fc10cd2b623804de0b56f8eaedb28461495eadbd0584b19ac13b5d81e3a63f2de1d6082710d78ea75397d6492457378ecc44f7af214223fbacec0139a5149c932138b08aaad9a6aa8c4f7801a1e2a10e498b3b97c04b7d78a6c9a7f67317eb74924c5f17d2c33e527535775879dd631e76f05e9806e7ed082f2f1591870b55d65f035aac3010c38c1048783f5a51e6762eabe99448498eec91630f1b92a2d33b31e2bca5f7b911e80f4838fec82662e813d59d54eb14df5ae36fb1822a323d9ff967a88d43cdd70c1deeda3b9c7202792fe14fcdde3dccf1fa6d40453442d49a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
