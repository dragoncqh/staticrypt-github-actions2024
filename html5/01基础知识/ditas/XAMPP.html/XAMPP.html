<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ba6cb19ab43cb61eb65916a1d840950fb63ecfd5f85e2191bdf98f36b891441f6145f00c3b992df17be185982e1e0bf85e1fbc9f8a07bf1c00346f7d479fcaf432dc3f379f6eb11f7926253aff3915c1ada255e71691495ccd71b9cd763495286539c78b2d055b6984b5634c67f0515225f6005ca8a725f20c40774be4e54173119c006cf65b27777316fff9b01690c100af4713d6aa57a3dae2c26b7ce49f94dce522df07919c126b2834999aeb8874dfd2899e9026fb8ecd328bc6cab67e24eb07fe8e22107c329e5ceb50f8b47f79403c8dbf8648a20eef5c44e32476838196638451ba8a2b050f7895b9643ecaacfae7be53c389ad96f4dbc464286a8fb292191acff676c8be7417eb1842c903efd15d9b153c379cb2a8b297ce7be730d7683d01a8fc2a80707d67337d1ae5d050de10cc15ea74593c80a7bba4e0db8bac827bdd25f22afcda4845485fa092fb1b56cf19273b13d5e2e1bb231209b78fb74bf631ea201de7ac9a4053cdd88ab9bc4b610d4a6b958f7be053e8be6136431aa5abadeeaacf2594a22ddfd3823ac2ae3c709e6e492ae4648ca412dba659720fb158f5e791ef737c202f8ac7a30b9a6c6d9c155001f0dede904247fb5f68644acbe6f19b924b53e45f71e0d1d3f49440b8777e5b7851b283af3744b0212d51c86d3441cd423a5679089ee80729cd8546b0b88a9acdc01d4b8646541c19d58cce4681c3a89f233af8a6850d2fa9e2083c960327f31e3425c9ad77bacd9787d543f45d5ce2a69532093eaad863d8a6215a057f6cf12f6a6cd9b54cdeabe00fb2ed8f117d14ba6bc477a82c1f02ea1e4f6ba4305b666d15a463c1e40b3e4678f74de31addb43d1f74360a63bcc6d65f23784b2e725926b3e88acfe1816c4d435059e44554d6b11ff57507075db94014f51f9310d1998a68d0e3a32e2665eacace8d01d815f2ff64071b9952abe28d3880506b5a051fbe038524939e9df212f243615009b2788dbe191bf76e5ac71056dc24df20e0b92dd6a9de86f32e4ca887ea74e26b8142db91cad0fd3db4f696ca79375a54cf3f6b423991c44eddf39d17b8386692d77ee0d7408af800bb3972f0efdcee2d814b350dc5389f87bc88984435b60dc2471a1dea9e2d913e708086bf627e83bc47f093de5310c0a804890e7e7d9d01894aa084319086f504455b45f41e3802298a52adf055d7edb586191aa9e78b49f5bc4c1514c2aa93cd762081fd07d99513b04f38ea5c945fa655325311a940cedb5388ec393dfdfd90d98f07187bdcff26991db6682d04e951a8f446a9905f7818c667d1b2e8819b8efb6558f182d0c0c59ae441627e1d5141c24f1512193d370e70a44c66c7718a84cbc066a6c35358a035e074b4d8a9ad27f92888ab06d366d52b3c56203984787b85ff6b2c5283804f56ef8da3585deb89c2ea5585aea96aa9baadb7f3544adcd7ef40742c83adef09ddd3c78bbc0cde1dfec3130ee0da0b63d655850508996f0e2088a6972ea45db4c7714ef799d775e11fd62332747b97f580c72ea26ce04a025d5ee3361a6232135cbe235270d40591ba23689b026a64ea98144c9f7f1b6a84f89ae0f5863a3d817e7fe48833fdcdb6ca92ef77b119c41c491fe8e73f56933dc036562eddc33e530b02c570ffba96c7bd7492082eb28a6407e7fd8344175e07704d9ecdc989c0e7fa20673b9ad414537421c237aa56b0976ad94c760d65fab84a671a3af7ea73a6bb6dee779834b592636b0a8e964235cafa8b7128ec0d6909cae5fb5e751ba1536421029e55a9c8e045a34c263f235b3ff4ac4e4c5fde5f02faeedc2bf2d1d97f95d7c23a07ffa67e528c9c0429489c680cd6f7173ae9be63336af9be8b299153ada9d9d6df4211435528ae5e1a4cf0d427ff0812be57a2a8238f3263936b33a451c966c64f6eb9b610d7f50a9103b8a058606b2ee26a2ac452cf3265a96699e891e414f9e5dc89e0e3df1d531fcebfdcc5a99feff2d3608686d4f2051374aab96fe60aa6741b65ece16009cd2e90118fcd71bc239ffbd9d0ef42d4fecc433c820f5b9744d98e2f00afc4dbb4d5541f94384132bac0dceabf853f3c2b3de1d99b3815820f12cb173b0d75f5ffff821d9718b9f45b157b118228ca151fdf1886c74a2145c04e2808477c48eca8a7d1fe7f6d9b6bf7c96ac741373bfa57d8b3ab4f47d9119249fe899549ab2bc54a66782f6a2623777b98a9196e79f27669008d060020c618faf56f641c8611af016a5da9fdc0e272c39b24eed34ff18d48228eb46a0fdb0d31e8b51e673c9d22d7b527dac9b8cf7d23cb0ecfd775d50b101602d47a9d5159c12d535aa62f9240f6fcbf027dce49cca3e1ff2cf3bf8927cb7b1d0e4971a6a1cef571eb2efd4a43c3f14393749618f28a569bf642922d64a71bed990b12655c50b2408fd50c4eae065638ce3111af8feac6656106168956e154c4d2eb829afc1ac15ad7aa4a6427e65608c82265017401405c0844487c52c7c3dc7be4ed9a07f0dd40958e6e577bf1d98e7e4fc2443d861b0bc31a6cf7dd5729160b8d1abe3a38a4318c76b7ae1c994269cd0541dc95f28af1aab99f3096a71c8ceaf98d9c7fe76de8496eb52a3ec347e1ffcfec1443440f50bf30c35d09d4300fa1980e41f638adcfee70bc9b589f14b2e278b10013f6589d50d7f47a633a8006cabdf24b8e1fb205b83dcbf57431dafa88f410e42b27f54d430e3350ec1e20b36e0328bfeea56e3147c9d97472ca91fccdfa8acf1f19d13a1ac94e4aa1f96c8dfb28e3020569da86d5065014b29b3d38a5b4766c23baeaad164055946ba9cba4c999e715d980d4239f1cf38ed800a5dae1576bafc2c2a08615600af4165dd182297a49a50bff3562f234d391d51217dc9d57653133ca745b7b1ff07e146784ccc9254ce00405cc94016352358eb64e9778ab7dbd72ed52a8f73b7794b405d3fdcde343d97338136171802e070d9dcd9425779e172afae083b0cc23b1905ac91a4de362e13ba4a2d26c620b0fde2fbed67f484b338bd30c5a2e22defe61cded8e460857aeddb9e207284add0b17a0861e412f0a24964c2677208d85b15a1c84b1819ec3ce0f237288074a3ccd31bb56071b28eaeccd5c7e4f0c2722dd2929f90651bb0a6c9c0c33b43324343803fa92f258f58c83ed5269be642639b85a7a5e03fb28476ab783890c464515e5b553a5dc46236756cd6fe39b7f08b975d62f6ac2e86e64e5af6673a653533cc2ac43a65cc2cf1896d7b18944452b0156cb65282f30173e37090e06966c8fcf036de232d6e28892e6bab1cfcae15a7c8ece303de5e85bbe3704d74344f3b565449d6ca20df7c919998e61c8d380691437027f5149ccdd4e799357dabbf567b048b6545f03e0fe22e70918cba1ed6b992dc1d3d6cdf41901597aeb4a51b79127b5795ab085d3da468db60ec40ecae77005aca2aefb266a933c0c884df188cef651feb12d990d1cec812ca7c8689dab304894bcdd592b30cfefe5c7caa6e55c223859827606e7d723fb11a5ee217585130a0b4dc77dc8b74b1f78951179ea42f56b90816a1690eb500b9cb26a1ee56d9122b3c20034a25c152c76324de84bca389485c78966af33492f73368ce9620ce381545e7f52240a72159005e7ccadd6eafa3b0319a8c441ed4db91297f6f9930df2e5f45f3f101f6e28717a20a613fb949e4e749241902f5c815f68dc237fbf40f7fd1e34c5b83487b44a463fd963e1e1912c53c417d8f1efe00a754bcedb6d2b9ae63cfd792653bcbad4c5233625521c0991822b25ae040755f9c59da8188eeff59aa4248642572951b6225bd8df8b69282a2df7e2c636fa45721169f034c31cd23e3f53f158a4af97e6930ab6a0a9ccc7b9b5195c5392138ae8e730d57379df0667b4383e300aba6e68e5365eec1d5fcabf9cb90ac5ebc707b0e4e7aa970b4009e511cb7b5a8428d885f30087b031549fdf5c7ae08e2dfb67e06c957b04b2da37e44d742d9e32801bae13976e6b3d712f54b9933208228d401a53afea8b8f0264918156f7fd17b541b1b2550269b69f4af88204f4b208c573e396ecb05549e5c3b0e5e81d4e9fecd203c13072ec350555a328de7093fa380be1b54c979f31c5c47414fae3b523108af625c50a2a3c637b470ea7b1ae681e9524f4cb30eeb2107a1c380967f28715afc3c5e8029905558d0eec4994937f0b95aa939079b0ed320553d89576add8a552289c0d8ab4fe207d490de4a6d3ea8f27bbfa0a7198b428378f06ad784ace3212227162d190c8ee54982e77f71d73cdaa694478102d3727f4c643da2be7ecc1ed4417008a0b6d29dc9dd7f5362688d79f18db95e9517aacc2f15817823342cd7a7c9297ccd389c2a49b6826b30fd73eeb13e1f07ca47453b41bc1e9b659fd9524cc268ecc79a39264ccdf0720e050e1c4a6b1f4671a1537f957ccc910c5aa4b92a2a59ba71049e1d29d70a428e3840d5c052fd275a6d85490f7df992d6b00319483414214e818f90d41c9ae1fd2aca18596233845e255bb4de8cd842dceaece1f53a41663d12258ac311eba9ff021bdee2ecb17ca171c4e15a1814e7ba55c6287a8acfe8ab5073b96bd487118907afae66487486a247e9e6922565e2a3301033f6dd71c9be0b810a5b5953c53cd36c9c2cba27a5e2f91d700289606ac006457c5fbaf34e6d32b202857fac8848f1151ffd5f35322b8289d884ca01a1b72362478c0ea2d194bfadff029f3ac312af55a64a2be0e2f4e0ec7efee7aa916b42d4221accac109ba3919f215a2e86bc2a9382d165156171e48fe75f93cac5bde113e05f0d6b451610d76fc3253fa1d92e16520f3ea9dde06c8ad0abd7385c1269ffcba8363228cf52303d2a5a388e03c5e9906ce8b23a1458cba02dadbfd5f66a21508adc5275dd256501ff427d90277c444b6e7cd706221e4cae14db27106396c6b03d99b02709d52e090807d5bcef97723fabd271e85dd2c1507f5dc0888ffd76f5b011383d23dd305e6bf0b0b38da7dad56e9e1ab52e4121539827ddd7dbc6ca81b929c1e9c417110e2930f779323467301cec4f1fef206e044efbe0d2aeaec2eac2bd4b8d6ef1fb14c050387ab23d6558e9432de8371e121974d72e84b3173e73b78ba571b667c94da71b80be5df015bab26496fc6e969ee4e9c9112b7c4f5d7e3b794e1d37200ee6d48f3c9d13a65de6717cc2b67606e4dc0e04424ee95df1254ae339c1d0de4b5b6b2b11aa90b4068d220a05555461256714bef6bd3271ec1f28e0f620b9f7c12e3c4b9d5dba3b64d63d298749aa637f4d2da593af72e4f60486fe53ea8f9da9cf1f8094d15f6dd3d213a3d19de2e718551b0991250601b8a5133217dc15258d6e7ad6b88347a843c868f7bf80495b08fa0dba5dd7e341b431870eec4e17790601eef74ddeb7a6152def654fcb8f7cd44c9500cd459daa9305ca0f9aa8810c13a27e751a7806623690b5c611dc7db09a9bf73c176ef54f14dc15c09b39404b5b34f988b9732e52ca364afa0f2801780eaa8078b0ae5141079c0525f516b8712ba86fdbfaa4614bce993cfb6102acc2a33d17496bd62e7727b54aa8b4a7a560fe4426b6dceea57d5ad4f030de62c2548fdec89f0c602313f9c653e6f644ed875b9fb6487e58dbf1fecb463f38b79680c82bc1527cf9be0fbe041585ade3624012a320f5ffd7929392672bdf9f4ed7a860702f2e3c0669da290617fb0278278b2d34b214afb1409f60bbad0d0f65e698ab4480eddbe7b8e10ef42563e280c647765b94a382b8e0a4ea55d6acf2946071dcef2308c6c54f2b798d9be0571c313a8c12144f64fc472ac76b74b80b50a322ae2d6e706096e89e6ca228d66688ba0457b4b99d73eec587f2b76e09763d2f0d1bfe497af8ba2c06a044b010110216e63eee1091042139624381c754c15605af64b967014dd5a437aa27ad41e5a47f61c4573bed8625538a4c08a732386f3ec5258e67eb17df0e939ef034629ae926a1b2512c13fb69fca0a83b17345263df2cc86eb698a443876975e924939afdde8aa0da775eb8e7f2238358ee2cadb6c57d8fb933f8645d9c736f1f9b75cf530dade82c1018bfa895107f2593e2d40fc106a2ce1c4082f31d8ec6f7a51c2835267ff93561d7633fd9daac68624efbdac0be1b1721db68713ad6a1453b9258f01a21cf11da47932669cd179ae48bceb4f2dd0b49e439ef16d40e24a775bc92310fe32121ad4cb41f4c7bc9a4b8831dae93b105f3de573283f51e89f025becfda3647d38e8aaf3926179ebe70612cf45c9d21028e2909c2f4dbcfe9a03f60c78ac3eb75baf049d416c78d4a23a0ad6d16dfd899c1c492b3910789f3c627b0b773f8e6398a7aa071ab5e3026b5e134d235c580e12aa59370ebeb17111d4555ca1c5ff34c571f78f2330b242502ee026062fa415f37bb9ae4e3b58ecb4e1f7a3ee49359b6b134b64488ff012c12c20ed253e4236628f3faac7e52d17c6e595a1dc3491171ba0bd59dac4b1c91f5ba0287069370ba61ffe26167f94e1c01768568330a6338611463395e491e82e5b31d8fa88a069f7dbe523b2f0e664d81869883f30e36de373dce66f2a5273a1e743a76b357003f23d964ee1ccfb4e78940812dfd064dc748674746c68a948ae51fc5475c91de28c8d341c0a2e97e6cc3326959bed296157988796533d44fd978d70dbaa1aa1b943153f357205a5eac01b6e83400d2df956612098020cc91a917d5e131f34da60f70357940141ada1bc0c3ba1aae5a89b2da03626aa852fc00adb7b28f1624eb2880861da95e0bd3b2cf68555908ba2fda481407fc3fb4d014096c2dd1a153a402e4e72f28ed832e842eb0ca97f26a6bf9095ec5562dea15ce4a8a0506904c9f3f93915e2527344090eaf0bef694dbb4ac3926ab66580a2cc7713f40fb5af6d1125c93c906595590824f5d3e3fd558bcd1a3d5d9180e91ca3bee60779a7c9cffaf8171bcbef9dbff149fcc9234a8dbe889b4a3572a43544e034787fb6ea87bd49275976f8a1b813a451c41201647fa7b383c2d7e1f78ebaefab4f87ac5ad7f0f52375619e3328814c3aee844db5d8efd7319eade197f5ab55a8167a283583843745f92f40d10db29fe6fec514642a1a2db77d4646d77ba44f5158c33a9d8160608d537b71114a91719c6e7d457def7d16ae18cd90bbc390ed2489229d74e3998c0eb61ad53e18f1a7fb85309eca9c381d909408084ac45979f0bc9cb0d2417187ea91dafccea2182661e8eddc2d9e3b77c9be35650194077774e5a285e8f0cdb0179e7e29eddcac57427b63bc4799e57e28d2765adaf4575a083453afe03f7256643c853294afe9d5ead17e4d24203d1f774e0a7cb8094667f232a7b1abd07c920e3270ca40c606b5fa3d97ae27ae459e21cbb62c714b9057e3a35b592c1ec86ca0fbae792730c81c2cf7ff372d2f02bbad3ae1a74358deb5eea9cac7d716f884b2b99d86fbb74bb2ad6fc6921a2977b7d0a931ed41df62998c7c90f58231c2f3cafb259c76cbd2ed31036144218707ea14a254ee6a52bbc2fe0bd6433fe380f3f7261119f2eaa7d4f387510acabf2e4593abfe3d1d52aa1be0a01372a04ef027900db1c0e16a168f3126b3ca32b810c7900ad6d4c060ae28c45c73f337ec20b7658d2a1b1d270aaaf5b16654f8d28a0d5bc512d3ebfe099b948682d958061a34baa7ed684c509c6b678f6170ae010b9809feffbdde9ba12b3c4078e15adee778c09d032db2b4e0386d27488066cb918141ccd4bee308815ea91930bd69bf798358f2859e2415d14e5c1c1c45d699ed7619acd7ea737c4ba1fcc0fef5a094189f99fca6eeebcb6365889f173136b11356c1233a0cd3dcfbfe57f160dd2d5c0886bbaa05dd1ca0c2d870ea9a9978c9154884b4efef029d88e08fda68795d52fbefe10bc6e76975eed900813a17833fa009c7b836de5bf69dc3844bd86b50a7d8f3471c8d57dd5b06f13893c502c2c9c19fc015ae6b181bdecae72d51bdcba6a7985a851144d7f4915c1a498f1399f3913c002d6ac89963343ce0990f22e3b6162bc386fbd6739f581ce8710ba2fd564b7c759f5ef622d7f0bd7bf772824e1a6e6519ff4f616d331f01e23cda7d7f8c056d236800135a9ebd792ce8e5900d2f6bc4491955394d1d99a66da5c140a6c2c38a958990418733c5fd5feebd7b0c3c99a6132bcfe94fc910601ca089dea5ba7d34aaa76be44c7be79621b733d3189d088d9a27d6967a6ad2238c5248c8af51453f61c857ad903ecd9cd9e212114a394e44d0be1d009a085839991bb2f59d3c6341000626b310bea1853480a25e3a611d9e8c5c874251255daa25f8c44ac0e29afc3793bcb7252ff2d07ca11ba7e40322d741e04ab9c81c3836a0b607f54e89ba6a4d0e2cd1fd06652363c4078202336654a7518a01fd9e370c6db79da1fd0aa2e595bd58ee5fa3ffe2d5c3c596a9214d346557af5067c54dde7bf4b9afbac9bc5dbb6d8ceadb72d39aa0e57f44340fbbc8c60be671eba052b5dd5d90a485b3e381f6d921d3af4356d838699e8f9d3acea71dca2980e59116b9bdda2251325f525cb11d118aeca3330fefb7240385774f04b88267012bbde58fecf0dcdd937ad6d3aae1eb89b53ba31057e9d01f8bd7b0d848fed5bcdd110762d509db310a0d09cba4d52dfd1813d5698b6785b2e16ac57e2f68322a098e677f75042d278b887408618d909f4a4008f5db477c8c6082c4d19e5db94249a5176d05aac81dde41194a580c137af015190c2f93401549eb702ce1790b3b8b22898441b3b502d68c67e2c081c1c10d640a444bef3668b395c752b91561060e317e2169aed1a8b8a8ce8187bb588e2d47fa805f89c3a11e96c308150d20f80f856b5434e588867c692048a13e4c84c6154d18a44eed90a0dd70e31f939b8d50049daa07713f6b54a9be8afbe24b02b42235069cb9eae8409ac6e530987c32413e8003d4596f76062363bc20474d2a54bd7199665468844f8a72e4c10627d6b17cf8ac56fd25b97cbaacd75249a9630afc7682da0593e8bcab46c78780a4d77b566b85208cf1aef0df3ac47df965cb48a50413d01a50fc4b77ce24c42ba70a9a4f8d47bd5bdd53df6a20ca5fc4b01a420f12c7e6c6e2e926f779cbd5a7592ed5dbab7a7b6812c2091440835be720427b92fc6f368569ae42f9ee76bd52a4df5048404d568976a3fced2b2e37d4416edd9a4ca7b857803211e9dea942bc6a0b4176dff89189eb1226c4073918db46ff75b56f8777fd4bd31769ccc1f37d04e6b0280f0b708e03475426041c642c8ab4c759d9eb539fa2a1fa9fd54277edc968dae365f87c4fa50d07d707ced23a7390f9cecd85459fc62365ed79cbcbc400801d7f253638bc7a1a9696813e947fab1fa66840851e49508c115e304887054ca526eeaed3046ff849c1cbec98c17b53a2f6ef2989c9884b8dd939839e4de34e296a631b85427cc782fe32eb83b355793ff3cba8c08be751ae6d3a86cf7f365a9b076245bc57f62f0e391e86f33ddea9d86cca3b528a01d8e45d80d3a869ee37ee83fd69e71d8f9114d131ffe605a7b1590296f69fa1395d70027e2d821f3dea4f4f16d0ca6b9fbfc914f22ea0fc46d985dca7a5efd0b959f8f71a04d581856e4db3ec32f7db9506403b956412a6d5ae43d67ef21109de68b8d0e5d7012d7853f392afcda55e754ccf3e8c5c5e065fa4b15ebc8d39b5538a2a956dd3fd013e2ba6cfa1dac3a05b009bc4a59e9d7f311f50aee4cb6fcdef851de002ad8e521404ddbf85b697a1c443a0b9692dc5eaed2000be276ad2f0fd24798548b06be8a7aeca57633e4434be16eba58109929ed32b9c303e1dcaea346675921d3ab9d6c132c3457561baa881a2f7a11f7fef973a62c9cb8a675726eaf07433fa3ee0c1ec60cb61689d0a926c071ecd4ef2ace9fc4674d5531578e006962780141fa40c48a931fc423aad0447eb2d72e0f91b4b936569aea380b0583e5aed331e871bca827e0545bf9a2049f2c4b558d0b0b08321e32820bbc26224dba3c1bf03a7328b675f7f61b3649f03c60969358539a7b207eb2e02892980cddc34157aa3490ab495906b376b2f64ba80ef64dff1979af688c4add4849f39e4af1e7e2cb756d75ffded303af5bd1f5d2f567156d8b605ca852e0be90c9cadad94f30d1523141e13fcc1585a7a71e60c2826ceaf2cc0abf5a81de5858dc2932260fc6410a511d68cb2fba192b9782582c5ba60998cc676e113d3a98a8a64cc8e42c4b38889b9f46de7869b25ca06e50fc00a88e474bd1e638d98222afd72ac6425b0d7fca985ca4c217624b1ea86b197431cb01f02dbf1d39bb65384d1eaa15642e76979ffd45f01ab3922a98dc0848472952d23deb75e54584bdb06423393327fbf105827651ac3aad1d974dc4984d511ae954e602b0a5916f10e5ad8e14e455060db99c9408128ee14041e8879ac969e33a49b7a0c7448e35e08b00c59eee6469c723ddf514aa3ee82df88f3b3c9e9cf7eac06f2bcc42954b8987986f42428175912e0f12df813febda976289d27431fc8b0104213c232eaa4cffe36b9de3a80f4c457a07e859d7cdc9003636fa700b53739c67a56d5ad5de139872678e41ebcfe4c5f37ae8d39cbb0339c9c3bb764bdef192fd48bb7d5fb88d90971302d1f450c37418367abb4a16712e291055ab4933ebe41dffeb7d4a38ed15fd82013689a254e937bd6616a88f02f4efb4b8797965d6d4e3005d7ba563358ed1315381190af91d1667f588e858192b680e994a2e85db3639fdec122e3401a5f57faf117da4bcd921a85ec762c6e0ebdba71b6b4317ba74b8eea13f3f5ca478c5b22ba57cb8947d3d19da5bbe31ae23a1d4ee427dd38ce597ead8ebb5d033f3c126e03fc33eecb5bb49781b9251e1497692931745dc15de26b7a665129aca2aaa28574ffb0f5da652ec50ea379ac7dd643a0944601c0fee35a7c0fb7406e727ebf45bb8fa9858ec6ff36631d1b06e3cd1a68ce138f624008694c64d5144253c475cfae550df612d8012b4a53ac2b4f56a4234bb9f217fef184ba820459c32d7a1783aad55e88071a9366af68f35b7a9a85ca4f9e3f6969c1211c8cb67f888cf1ce8bbde7df59b027621e418c6f5ae3106719d1487776c62db69d36e783bb804086ac6e1980f234dcff92f35aa5faf0e002879af7a4e467467a7e46a25298e8dee8c47d3549bbd4148b8dc796bb07deabd69ca45b3d625bab13fcd1d13db7e7898a274b419439f931a785ee439a6c4b269b8d51122339a3a89499cb17b05937ea7fe5af79e2cb4e2d1ce771f667df346a55163e50f2d5dd5254bd3332acc41dc5a5fce7f0bee8a705c70e45c78aebd8b443b4fa41a6b421f824c7875c4889d177ccfac57927ee8308ec2bcf5dfa5124c40212196b901cdd01b80b008ccb484ad0e428ab49afe954651e7ad91520133236f0df0fb6cf368f5c5fc0280c2d8db1dec7543617b00242df4465470f87586acb3c848203a9a4e338ae1e112eff3c5e9c2040923d842434985084aa0afdc7636545822ba9a3276a3c639597495ff6741fb31bb34160dc80b6d3b44e860b5f7aa732f818fd0cf5e2d6945460ff587077587002d6f94e369e261f8da3bb6eccc4eac8d7de583168d3c8dd6a46f85a379a43e166b51a83158a5fa56e9a333a58360942a41520aea3bb4ed654133db40c74b3b0adbb2df9282f9be2376269b011d4b82eb2664e20add01a065b10bd66ebd8b2dc58956ec7c2e425843df9de9ddcdc8104bf740bdb5b56b261b1245abc15ad5684e65946ada5f6027032a62cba70fb7b282b2211d0b08d9ea936d8a8d5b08459e0b60f6ea84561b5ff64cd71eb36b1275db5581c28ee8559e19115cca045452d1e1bd7bde3714b58a92f3ed04d47cc339fc48acd5bccdc96ebc5ed31635a4017598861cb46f0957e55389cc73921e7f227cfb3e8f53eb54e607997115012b43e76f95233c31cb8ba81ae31db73f86de6b2a8bd627e3660b0438937397d30b4580821a58218257676d55aeb25416194de497b482977a10a11a0ca5d7afdff64bc33a281ae29b08756ae4af7c9ad5a6c32274685c349981392165696d98cc43531d46e392cb5f8bc1f2ce0b24d659c187cea1f64f2f81301875f7a9e794e0c4c9301205f6dba346b57c4639c7854181b72f8993e3df3fcd5b3dbf9d66ed6f9532ddbc95637bf233f5b2ee386c5f355a0d2174daceb79659514ed77bb0c6e5f22f4b6551ee06dd8f3b21a34a51461b7b75a158706c411fa86e1a22076521c216be71e7e7b5932bfd0c5d16ee6fa01bd148fb4be4ba75d8f14d7d96c13ccd45bb52cf236c629d3fef939df4c5d0440a68e510d9df811eefe29d2ee44f4294f82785aa7ebb60b127ad220a395bac2630bdf9952596b35373f6fe0e2c79fa5c40e1ae05c370b43455165c63add6ea6d70a32f8cba9baff7a8b0e38ea74d80603d8f43ba88cf852a8fd6487f8339918226d7d32df9d38aaa9bf77860f918e280cd1abf427fce823e0709bdc1d5e83fd7b826211199995af89c48a5a96ccef301ad8832a97a4f4ea9e051fbf87b0682356ff5a4f1bc143535d63a724cf17836ce7c6c7ea5763e4ea92ab8868f16a81a29ba6b42c927518ad906ff6c10490c005224f622ab725b40547131910c6ba36da04b7f669d9429b95b59a3dddc7ca518f8fd996c69c0b31779c0b378475c321602c9d1409c7dc408a6b3d5848fbfea097dee61a3997c22a514edc6f5f6b03e24b5a408b6da1474927959cbd4fc641df9d6b512edfd893463471f5661d4dbd978cf2524360fa4c132a31880497dfdd3fc393c70b89bffbd58adfef9a01f3c9133fc1cf136d25f90c8ae545228380e6373b17a3f04396047f69b9a60b382ddbd7149b6f7badf034a7bba0a599c42863739a6c032ed2c79b803aa912aafc90644d6bb4602ddab860db5f105db6fbb53d96d9b27887c003586d3b5943a86c3a755b921dde8b34362a9639214eec87210d2c5dc3ea8ad95fa6804f6e6f2fa0fa0a4eae957f4ecbbc0efee8447f41cfc2249ac784d551f155b3e85a7033f26aaaf4e970708c39607a9393e13a423253ab133076aaa8e80414907ac274a72ed6bd272e8b2d9989d69c061985250572195ae31243d56bea3c2407f7f3a1c240be2973d51b1eb21924b516600fcc6df9138d6fd4a1e0ce21e3996dc8a9ed7de99372dd1185228c6e4410bb5b55759829b8dddc06c839a1f47ebebdf0fba5bdca6c79cc9e499ec2202b053e0643653aaf96e85675eb029301b65b77859c88ee3a3e243b0fab76d12c717df50b5d2e8a1f6c036846d3aaf31a8e489852d86e7cbf388d14d60234ffd0e7118d78ed4e110fd78bfc1a000d99046a4d2cb4a2054fe67ab848018ddd0bc7a0fd9ba40d334f398d8be768269160f74d04747aaddec6a27b55c00c01dd494df04a1ad784b37b64b9ca2e56d8fd3ebd963e71a7dc8148dac0d248bdecc6cba3943b1bd87bff7d991fa0d28493139d6f13b91b57f5d14220f777f90521d9cd62ca2609e0ebac36fcec584ee063d18a14b96804a34bbd035be7c81f8131dcfc68d6031466f7e508a1798c0f56e778f8b612d97cc937dd79121312e10830b5be749862a1a4c3bbd2e9c2eefdaf93f961d1c46d471f5984933bbe7417163f8992c30f29bf392e2d19a56469a77775b0eabf0038222e6725c3ea5e8d934dd04856aeaf3a39578bc86e904b7c485bd58cd0beaec4d9ece682f091af4200023a084b08b7a071eba48262fd247a07f31a326578ea2cd5c72124e3cdac99381ee8652963b4cee22b63b79cb53e5176278f5aab8c3adb98299ff36273dc44693673b68196f0b68a7be31cc2f96b95c302fc7114c2de652aebbb4c3a840a703dcad2f28627c6f1edb8e4035f755b8ad73f93d2fe1877f29e3fd67f2496d1eef72a8f0deabb28db25fdaeef298199f3ec49f85c8acd0ea29f5a9a37644d769f327960e6c40647da2e91bd1eb3f346bcbfeb95c07059eb78682b286efb5b2826dd6f5c1b0058c103fc7944fcf9ccc8b5888ab86de1b312115e095bdb614382871e2b9a8118473664e39eaeeb756ed07f80887521f7a94e021763d904928dd05408392feeb7f373ee8e754bf7ee545f55f9bc38c7f86f1ac91fe4c2d6422e0a06482949c8769a51435832530444d0db49e2fa4fca704f1783eef8e198b8c58504613994a2ff247ed74b68ea72c6a1f111520802480ac06c561b76587849b2bc106293b8ed848c7e8c3becd07bc422badc568c1abf6b274453d0e9773170b92e461f09ad555b464b6570c392c68b6798c299cbcc5cb51ecc2756185963cacc434c8cb5f8e6567dbdb72bd198b4010cab9a99602526ab8b4ba9439d7e17738986c764486e9482e3f198551a3c30a1a1cc517e2efc7658d2698cdc6e38c3362a8d3bb5d51c15d3b9af4689c2df78c61b3b4f644eac33c1417123bb92ada808a446af0ead8bb40ec3fbd14b2f86a9ab559701a2f559cf536c17907c1d31d60938ff0f10c237679a2702231136d7b768ef4128587219534578d72b8acd586fde5d8e841d23b35932915b50e5bf1bc9cccc629a07ea157a45b42247e5d3b8f3c5d5154b67cc3f76024a50a0b23c06610adf62c1a299891e2e096b793698eacec41053faefcdb64ac99ccedd2d21aea6380efdab5cf829bc70e868f64acd30d3ffe2380129dfeae3af250d2acdf307891a72f4482be4aecf8dbbf7beecff4b2ae58e1bf00de8bab06eb5e3a4f69a9476321e74b8e75115a10ebd64ccff8b249be3c2e764be9eb2a607e398f3203cf04f5a07454f56cd5c746ff63df9ba4057b4647bed8edab122284b5465f464cf064050e766e64543d8e38acf144bc7b1510dfda0b959f437d9da8ab9bcbbc55bd6c893bb79d828c505fa3a361547f34d61bd7176d7a3b441db0c8cb4cbcc5f7dfa929d987046322b1ea804aa2a5420b1fb8ef2b1f31a5859c5a10076f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
