<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a66f5f58371c24fb43a462ef1c38cc10a59680626bdaafbf239e08f0008bedb948c71e5b06978631f36bba4adc89cce5e5c641d69f1afd0b7c0802a2eeb3f5d8a7b8553c9911400b8b03f9ec4ec212c97aeae4d7d4a78fdc684d3df9cd8d96f1e22c4b0a387ea527ebe74397a13762f808d3cf014cbde7ea2a5589f70999708a094b648fed4ed73e0613d596b7dd5508a434ee86c9554205c3ec15103993c7f3fae39f58be248bb4f5b19b4ea003f6885daa7c4f537bf031c24c14642ef34ec7120e192757f04aa144100a6a95a8ab2c9c69642e1cccfa6ab85d9df6c9894f043600fca6b9b29532e8d4bf39acec4311f8f38910ff262f49a01c18532f47c4089f9269a5f7fa5d56f586702407a99eb23efb816ed8c4b212cd9841954ff0a1f163d73a642ef4e76cc0dd7161b29bf4fc06a3a84e8f84955dc948cc4701a9ccda633b3a5dc05ade66e98cc732ef5cfdf988787857c646059b8c0cf5d43c75f0cf2d9da17838d99a5b198484ff2b32ed52ba6a9414c772cd1613e89420abc40953592afbbcb78c474b49836fa3e21b54fce1eda37bd24152471ce6f35f868dfb0905939468e280540f54359b8e2690da1903b6a97bc53f17f7d10261291a98918d88d294b48a37058c31b5a5dd5d71f24756e323031b41056a14ad47a98c29c2e1795113b05764403590062b2b70d1598cc3ac4c96ffdf7de069a180352132b0250c982cddcdcdb0957d1f67f7a2797a4c721ff075e4eee52e4a2f4213809dfcfac5b707622b62ea4b0ba797488ef0af1b4773940875d0b2fd14b98ced1a58e9f3159ae5a25de49eaef9fb2c2bcdf79515405fec678ae14d962361c27c5b4abfc02ec12c3de57abcea8b2a436882eb8ef0c2a8ff7caf694535e670727a56e9b000d4f301e4973ad9c514d4e7baa1168e5d637bfa9793efba8c6b262675af05345c9075bad9d52e30017a77225d0f42420eeccfc4a03bb16bbbb4dc3291a745975558fcd9a9a48cc6e366b1d1504ab1fb0d25047da824295bd2e3fe1bec6e22a721642fa91f8ef5149ef0a00da9e8d4989579edd89e9f3cbb9faf92342d71de2a800944d2a6b9d510b3e3a92b51a9362136e6f98184dc39a474a20bc2f98e35edb7485dd20d07f7c90b95f0ae9405642499f12b226c24716787d450fb63338cd10e24c1b1c809a2c2992b84c22892f5950461d33510c325075c23486279df0a6862e1ba17d0ecdeea3fb148e2c3684cc7b13c931b5ce2cadbec29e9bd9d4de93137849be92ebcce95cfe0ce2570af1a687eb3eb0cbcd0e2421f3c5c56d9a63d097047e09552bd3dda05f89020794d08a14760fe62bfb721561a488610ed88c8fac4d991b5ecf372a3af3e38e1f87c787b453da0837522d980532638ee1e46bcffa791f3345e47d67e5b3c36ff3fdb2d0c714a6ef10d07fadb3337cc8c6a26fc85a737cd75d96e044377e3222b1a45786a0d8a7ab06743385a23298d388c75bf78bf0e0bd38c982338b9309cf96328e33b883769a81ceb6b16f100610524a4cb31e5220b20d1e2804df887c18b5e9a4b348df267b0a268ad1ae4831467b6165ad704723168f57cf07cd9847b616e777e65120d7ba34b28bc1320887184bb8deb8128ee0dc1eaccb9506b19c2f13666654ef7e4d5d8eb72e900cbaf401f2a5c607983397b2767ac59657d569ba4d8a0f369400f33e6361fca2556a89f27e4bb387f363980e2b5a4f01737c3ce3310c058a2f890f32332c8133e0cffcf6ddabdc9622dc015ef18187acccb5f6514e2b96067cdf02f2e10c33923f7642727ffe6507594c0195f41ce583352efc649c74969458162725d4fa1927b3f464cfe52e4f2aab4634ec2cc30aa038664b1e4f58f0d9c9d8c009a2361995b6927d3e52bf32fc1546d2fd7e23c2540abe4d275e2116cbb63fa9e7cd37ca9051ad9913d0cf288634783ce21ce06dac872c92d0df66b6997111eb91fdedddb8597499fefd3fb3325be939e48d6038da517cc93d883a35d4fd7f44e4cc23fbaf4988bf80eda5a58036384e7bbbc1c3a22037d1b33be4358abda7eaf13ab03bcb0c2eb10c6589353677e8f66695ad1518413600166db4de7c07ba31ba6fd7ebc930607fb7dd3b48981fac28f765fd57eb8918b9b040b5172cbd5c6e076e6eec801c3b43e304da3b1229fc7f6a368059f6bc0980de70b9d05e8baa0b2f99c71b4b1eae2a05bc0939a16672f1ade305257fa3525b3e8afa52d8c2b88dece2b57b37560a14293c5c0f74e0821c970e950c4376a91cb76cea739254d9d38a6e64d33b6285730eabedb6539a99bbe212f72f7bbf75ad9407609e3d94dbc0a794f3cbac7ab276f386bec6c60dc185097ffcfd330d287533d89c8a7ff3b20b087f01b6a206a0048fe0911bac399243d9ae99016c7772bef745d5da2025379f82bd049a88a12de1d807ea111a4fe2256ee04e31f1ca874663044e7c1e9daf02d0a7ee9d4ef25a66cb3efd011f6213e776d9b2586667d258ace3c6adfcb5a7fc40c04c999bb4fd2f43e5d49875488def6603c99866f479f2178e18cebca030b908dd6326b4bf06e4c139a2d4ca544ceacfe07f28c096d835920fcedd8516a0a78dac7ccf2920a5a867460a68f6de14002928a59060e48bba3b77acdc6174a9272dcd9fd4734466ce890e288ad8d6ea63eae6b0e82ec0d1d012ab7a55d061764ebd87c04e9c6bb8d852b8e73a896ae46c53c7ba75265922ad42785a7cf3e0fd1d7d01acfd3a7a66ba6446b213d1553db30dfa91cc720f1694336c4cdc590f4d303c31f7e8ac5cc896afa0a300622d3ab57448627c245a4fdde758b56cf87fe91c4de8a9ca8fbbccfece49fe3e62dc910711e8c774bdaebc592836032609c51efe1fcddfa7f330253e313b46ca892a642c33080b0e5904517d1ba35775d73b50927ad8ae684ef6bcb9e1e99f9964ae2a7b27304c47ce09ec33c5ede6675eb0aad3164a3215ea3185a668a1befac3fafb413af7a4404e872add49e3b4df589ce7945c785459e297044e4637d3133049b0ea202cf04f6527bdbda738701b5710551e0c0142e13a3f233707bc1bd5b885c7ac5c0939a24201f8c04c8415a363da5e5132e32d7066d5636ddb5aaf4e74f549618d57d060da4023299d867211668fc0527c52f3bcf8572b350b8147dd3b2f0000a616c6ac8cb1fd9a1224ae1abb08bcd61af7d2cfaba5857ca95b415eb473509d82ef0fec11a630e81d6f7e792574e0633620935161a382e54e67e1400703ab5884334c6140294c5ea69b3ea4ea1de2ef79479382b2db82aea4c52111e5426df0d2604f4699e8858d39301e896dd2a11e0572709edca86236b7f05c0ee806bafcfe9d54aa6a4206533ab7cf570d48a7069b1276bd9c31c3ed0d76a777178a84f56049f69ecdb6489ab1197a862da9009aa76fc2271c1920d4c42957c7a30fb5b02dfc33f72bcaa43176fbdde257dc4f75e6569b9549421c037c73562018632572279c291d1cb0a3c1f4594db3f25987acce7ba00d959cf2a6512e0688eaac97a734a192f30b8af0aa16167888c2fe440fea46bdadb7184ec08ed811896629b45ab8652e7932d5358e96c8d803287e6cf134959009ecd83fb4edd5f23205a79a878d045d67f737e66af1c4647a0c82071471681d248903e718947c259c6a1816e8860515ce4ce0a737eed7b8912c4920db9e242d6d7ca5b758d61b29c7df64f923d84673cd1077dd1115de63aace6ac7363d36d84f2eb001ce568955dfe1f6a6ce6a41749c4cef2b1f9d3291944dc81ddecd3e93b5a016656cc82b70ff71d6974dc14ffe9361280dacd4ea6ade77a4f42374f96c4afeca9833ce93ad3be35e51efce3291592b71023c2a30d0452c814ad487642055a31a7499b09929d31fc155aabad5dba3a264e3b0bb1878c93772984f56f7ea22878ba8c6e2c175628d6b2f2f40797e6b4ce7994bcd437373700e8eb462967324d8021c786849ef7201f9563d6145be4574e93afc81055e10e9820c20d89f0491df4af57ebec1827fc2b236f4c1412336a491379d9410d77db23c0b306812e3eda030d25c8920437ef95c90ba609c9299a81ec966f80160d38b6863e45da4f11dd6620e7c79a823efc3bdef2e520bec7143212901b366633e62fcd3e61c2767b27f1261d5d378cd88b5041f655687963296a4bded11f974b88dbdac25430e36e7d872aa12a1278704a54dcceee00158381eacc3b53e04ce56353622ae42d1f2daa637fb1834ff4c555b97c38eb74e47dae9e80f169cc0266055cad72ed264620e6d96cd3fb5ae9f09464fc30090cf4a599d64a87151ce9cc93eacdd5fad18a93b8227595286271935cc8c1ed3d6316be44848d04c53b4124831790c7c54149c6e4af357fea9fb5235d3beed7c6b1f684bb464edb195338231a9ab24c239dee72920fce46b61a11f4bdf22c470ef527a2d7ef197c8e825371a8a37722e589629c29cc50708738080ab24107b760ae4ffbffedd7a80e646c7f00b2232bceaa61253606925b937cfa23515aa01b93d64a6100dde91a6f86b3a8904bd7d10ea7a7a2e82423fa9c6079c0264e0f95c13edd7bc13a259cc999e8f74cf7cad69ec20fa44697ee3dd8de130696fada32accbc55ff46d2b2a01619fb28c27c9e4c46eb2acc667254356123230ffe6ec372d966d243cc11c61b3698a168e64aedfaab3fd9e660d85198b992fe5ec379f7db33a9acd8b77c4ec0ae79d9139785fd8ec9633a8422341d0f285a40e6730d60ff2362aa220c46ef06ec4d3f9f82a0f4f6103bed8b0c11c52f74f29aa3fcfc27fb8407f6612515b3779226af5762cd5d518a6c45188e7d334de8061ab48ad3a1038f3a3a77df8ab35d640198c7c7eb3f76d113ce98c5ee0e8d219ace0dd1347aa647b51f84acd0a3526c47bac3f58c611b363a55873f0957e1cdf13ea4b6efa5e1669233b98e723411d66e88861c28d0ad14913189194fbd1675d7bfe73324b11b5e16ee9d46c745b1dc17284c1b29d4aeb2823d6eab95cce80120524958506288c14105c299676675a7042debb7d6e86bbab4cdd06bcec05350e46ac3e611a8f640bf961f332ed1f7b4a26a37f07d0bb5f3ad7462167a5d2734f15077957ae263623eff94b402be9db4c3f7e50fd591b534c99ba9623dd267e52d318a227c991267b90bd6ff8b49b3cda4d209dcbf5d18fb961fc06b4077ed2a31e9b716b0939b6944f0f30e137a4b28b434c4eb70f87485a58c915b3b79af3f84bf28dd94c999c3397785ddc95cddde82c04b9ff0faaca27d8b2b72d0eeef96c8e076c6343ec68b44bc0117a3a47e8e3c74d149d358c6f209a913e5198e2970526c1f7041b8d6b224f59bc61eed55bdf8237175fa388565585be95031e820fc6d3a1eb5e3529cc8b9bf365ddcbd34bd4234197ae08f9a8673262a9c3deeb75b8e2c28d5f083ccfbd78f4cad91c9e328eb87bfaf1dcae8568a83c9e2c9eafadf9e92b6965f5a7813b25ff1a26bed0e7b3bc7c9f67f87406d4304d76791e91fe843b72246fb66854e4f35d464b7cfe61a1217487d85048eea0e296d648c09db2380adba65c9145245018e2a2116d850ee2ddce93dd55558e1c3f4aebd8f27c793cca0fc845d54746655336fbe3623b8115e7ffa1dbc5ef866bda68b6bfef8c6e19d5564ab06657c9cd7ea5643fd0dd0bb583bc65129b48cb9a9284f2cd3efeb2132041e77d077cf3796421ae3076ebbd47a1af0a77bbffbc3bff0d159b6d37ae9ab97a4a0013b8f6d18a10d9607420d8229b757e973696870f053c4b4edb57c291d736bd026dbb7b6bbafd2f252f4c079ff3c77dbf53c4008c53398d0c74a5a71cef848cf2351c625ee01da84683423bd871608b0d03b63d171c8305d18e60c7b19f87ebf04d53c4c32f145d4e7da722ce23ddff5d4578089a1181c0cff46569ba0ba39dd4d046b524cf908ca3ace9b5136e37dfe8667b27f4caaa9219defd6a5d4b028f9f96c7da17eb4f59eeb78b60d82e554423bf9402c444ae46e82c246ca2c5cc4ad1d4aacb678466fab97c7a08ef4c31f5c0fc7c833b9f53f198a8ece35723a04c7c53fac58c949218b669556395fcd6a475ab5a1c114a36a406ce49b54ebf0052f9ded441afbd88d760f3afdf45888e7e6efde1b20b202da125e05a68192e7f413bbec1d63320bf23e42b17d72f3bf8b78b8754b95e90a8d044b31c9139fbc4cd7b4e7b9e21ab6eeba185c7c3b0beba4786a91805489926a8b2e1eeb0e33aaee72093da168a1a92a35b525db46b371e0a6d4416310cd143a406f88a06e32039e709cf17a9de4533fbe1df67dd6ac450af8965a27515f307464e2418a22bac321b892a73cc0dd384861c254b08ceb8047cf0813c48f3343ae23f6da451ccd794536491a58ecc3a320e3f9b6fac684e1ab9668676b6925e9a1ae39a8ba33431239c5d79cb4beaf7633432fb7ecb5f3ebed2de2d07a630bf260a5b5926b9cbaed9b51f73caf8de93785d94ccb20d22eca70d097b0199f32f68c17bce7acf3c72311bb659f37480542b1138e63cbdc93678719af5c37a97037e3c8d604274c24d59640e7f4751a1d9a0a6754ccb3870f67170a971f24c5751cc71b77995c00edf551e07205bf78898bc00de6dc9e05b846834a345ac205f5880fa662172747ef3b8922735708335edc1edd219f2c105245b946f28e3a72413c8d646034bc9a0de041afdae6e0a5b105b959931e3f50040d3de297881e60578b41e86198e8a89c603df9e29460ba76127aaa67fe753023ea78e4bc361bf76434d8aa66bd2019381eb2d6d9a06ed64032e38649887be5ce5c608fb1ce90ec109b85ba015a72539520b4d277984298f655aba4b368a5f5283d7493b2d07a9f396cda9218d10eee6b6fff2115e345b93b8ac033cc68531037260119d67dabc4e6051f771f77306b07e0c9f80430e3493bf985a7cdca0d4a5a88736edd7ac3d3848723036e07e9791bb48464fb23e0c8c8452bacd6898664ec5af16e3ce464dca254609ea2e5855de77a707a5416290102de404563328f11e007b2efc0b3e29a56219f40b0e9b47c64c50933a8ad2e3726dfa004d8892fd8b0964fb4fb4be86763de3694eda6366c716d3b67507c5998e6151505a00760b367d0878c8dad4108eed68dc612161b64516e89f2beb75ed25958008821446bc32247bb0a09978f5eb7e6d30370b1b088c1d4ccf6e7d0d5b83407066d6389ea720a3fa0ab4391499648e6def7a5dab38aac9fb9f531b34a3726bdcf6a894dc4b64f062c44f9568ab2091be0b793d3a32c6fb18168cca4df3e68a6ed6658b82c2964bb8e1f7c5250d792ca77354633f0edb94da505ecb5baa390d32b7618fc37dcb0354a02d73a5e8bacee94c865fe045bb23dbcc4708978b0f9adfecd8d76e142324bac9faf1c6df4b57fdf54de8e8912f3ee692024f50546edbeb34632fef78d30514e09def05b229df99c994c2a5435c793977052d09501c5edf22e6a744e1603ca8a07b4754744bde3ad6cf47114854b7a22a4c5e91147ccc19c3af5509ffd3deff9733d6a7a5290a9339cf9eb25d8f07cf624a223f853aa7515c3110f05f1cd565295f414b343a0a1abd5fcf127bb99ed1fc6d3e8dff1c6887cdd8f669ffe70471e5bd5dafed9f3b680a9ffd1356915e2ad92b2ad53735b0db22af055974e66820e4d2babc021a19dd8b150d453827647ad81590db57e25737658cc8c0454a714cb5247d4e97abd59cabe06af9858d9df125cb386a285a91ee0a98106a560d6a9d1e0f5f12d07f2bf09b421b9a1872fdff5728a6bcd7861d517b6ddd3045bc80541a4d7eb2ee18f1ffd846b0c135cbf144d3cdf2393c07bade528bdfc499c208f329b122968255b8fe1b816ee1c05147fefaf40d6bbdd4fca9564668f02bbc63b5a49dbaa68c5b7d71916943191c6b2eb8a70dd93b74eb439b9b7169ef9214eebdeff13c04c610f9d70b3c30327150bb149c374a9f84ac514a014d28d4d2e331e6525b53ceba8c0ec2213364b6a2e38bd12289b7abf0c404cd1e5c3454a055dd2da0b53e021db8fb0d21a93118ea14aa9b37a73d3b64321de70b75264174f6fa05262b030df10aba92a5f3c0f80dff06021ba53b4d25a0d21746ae7f4d3373d584a39ce52572e466716261d6e40d0f97d6662e0874f386cf7170d30320ddbf7b43a3ac27df7954e58237a6d2d9bc3a415ac48a8be4986467572a5477d31e3174df67fa2ef3dcf21a4de520f433e9e0a103d831dd891e1fe8d69709d776df1cdab900c3b24ffdb5d8a6c1f87c377f7717a9812fc24c1c3eaf40c434098b796b724d39c3ee674d2fc2d9f7362166fe33518c5701ea6f71735c1feef0cf2b9d4f3ecfe3ddcc655155d0e07d6be60f801646c28f75fc80c1c300118c69ad4f353321f5334d75991c975029af1321b97565084cfc20d24f143690db70f8ef7a8c6b91f7ef21e159356924563f27231ad74c5a32f79a6c74f17e4f6ef815c89c661893bbd72ffc2430566182f2619d6d4123bc6a73654dbda40429ad51b92a9474ecca5bccc807917e938a3991ea38de6ba33e92d7218f0713f9bb8d750c1d09142d80ae4986613b26b3b443ac939a776f486b367ea990514410ad95e1a316da005272cc114acbb9c16eedf5081f3e4cff6fde34df619c00a7af3ea46c9656b3b3dc87db0f22779bb505d9a820d0d76af6e3b89726df1a9fae6fefd3f78d46952bffc90d5944a7dd6a02c5f8bf52ad197c2a5bd588f2208e7e74d3d872af9ab24c15cc05a03478bc7b18e2c1fe5c957b3b9c3209441f4896b7bf4d4bfce4d7f7a3f689dbd4a1629c5a177b2f1b6380cd2ef02e9b17185b660c0d1b6f951ffd0eefee69dfdd6dc107229dc284f8ca826afa61ae179324a57d9c645ab38ddc69d6f674f5038718f838600945d6814b92f21b14ee0bd7aa6b4f78d927eb4e92078c2061e50d410d63aa4450c18a00240b42a4f69060fa44f2b87ae6fe4137f14ad72e9ba3bb96bc969a5feeaeebc0091b4d854f58fc5a4baca6095439db96e65a9a0b25e74b344b383d5b31b768f15b51bc29685d1f4d26f651ebadbaea83df85df89f741097db552684b3e260ed9570cf87a563ad6058f79a469165430ab3faadbb971692d825160168eb204fbb300968a6fd9acb08ccc49322c0a570ad5831ad12e304720de46bd509999298d6a8dc85bc43aefc38596ab578a9ead0b2d3c161369ea2a7b1067c1f0437238900af12598e39956c4df44cefed76b56db89f464a2336d022541d77e8d0e2746baecbd77903ca29f2522293","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
