<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61ee41950d1bc8759e84aee002e318b410516d89f784d9f3a035a8c7c1a48e90f7c9611d257db4a27078011bd5ebce897888183f851173172ee9bd3dbf83bb9ccc36edafb92d967448402e17da0c91f1c8eaa71c0e141bcb8c227b57251d24e92a70b99fb387c8813b59b6575dc26f06fa24f4f818b60b7c159db6b1f10b7bb9642540a39847b2117f5883a26bcd244f79d058bce6602593996372746ca839b66bf1dd0c9cfbe05a0ff18e2f5f1bfec9ee2ff3c30ca0a40e88d5ca3f2559f49b92b91d4e78d1dab5dffefd281013534e9efdb4137b1f257986880d9047686d976ef45b77c60d7f13a88b76d389b9a5846805f4a152015cc58364c81baeb39889f80aa7a5ec7f9537726da015346058f7609bcf95fd7388679c0f74f4ee2588c42277a02f2f510b7ecc0393c5573c342bf4ff851e39021639a6c749ba0276e17fd3593bae71b835b6d2b337041cfcdbe20cbaa6a26d67585b4e15414cd65284ade0145a3a344747c71b6cd3175615e23ee8f5cfda55bc6d10b96f2876d3835fb86aa89a3c1de94fecbc69b429055c717ce4a4d7a58dc0f8d818183f544340559c15f133a595fd50af6001a0d8b6178dee460223f4eb904b86b86c4a336ff5fb5bc64a2a812d36c6dab4d6fa8924c1c39e06c2790987ab700307ccd04dbe286f31f802cf1ffadc966c8195770a0afb86078b0cbc7b11764d00b111cd17dd933b7a7cab9f04e2c81700b658eaf9272b4358e6bb8b101d045ac93af520351dfdcdd0c58ce72c847c5895c9f12ffc01caca64f4e00bf2f0a32b3eb6ba4bf8b8bbd36f7eb76800aac69338d82b70a0dd0d0b9ba7134f09b0b3bb3956019b2f27ce84710b514505d51c3c032deba2dee7e2160c5d661a5ba90efaed0d8662ac820442cf2e20627fa16dbe8bedaff3ee033f71af6ecb53a39553bf013578705911dac63c1dd7e19760c2e7801b215dd3a3f299cb20364278467dcf7687489b6ce06bdb483b72b0b0775fa33bb1e55bd6fbaa87143487b691abb76a7b722d53761eca6bb568ed984a683a247d39522f80153f3df1ecb7bf45ff72529560a77e3617a725ab924987b328580623c10df3574783456aa387e53d6c2b43a153d3c887594bd223f49eb7c91df4beed1d7408bbaa5773a5b8acede31b8c782046d924e6eeaced94555aad035b2c873787117814206a53be6e6c814eaa230b34d88f13326c729e76071176168382307fec72346053feef13a7ba4104ccddee60e6697f51a944b5e91a0ef780c1c0e0e8444f323e402001662db63a5cc64caa6339ecef3c7636a1bf57efda46976bc0eaf3c5fc2c482d547874405e8ddc932e55a72a37542957adf3aba56557e98d62c7b2cc77d1240adad8bbce16dd8e8805e1ad400ca597360f7d3e4b7c07d305332bb01037e895347ddb62998ca8cbc6eb85d8e8ba84ee9952a1c81e7c0ebb7be24a3e52dee51b2d470aad4520e02a872a312c793a6078cee35ac7e03659511a8267e1278292b94d728b0756683b38b650a46cc68fbe2710e9f31a7549387cc4434bff318fe6674ac6ccc043dfef5e8c45d1197a218bce3039bba2612ebb80822f68ada8921d8247b2861d7cd1ed688e22434770db45305f39bf9cf45457dbe21ad56b1eda5e0a4c23a83410d6b96112eb01c64aad154f89a287562190d058660a05bb3f3d49b6373bba432853691c5874c1c093baa7fae803186b763270a90d9dd4d35beda18c7b0f83aae7a6170ce64db0f22174506e6be26971eb1ebaeed572dba9c342dd4d21747daef95fe64e674a6e2c5b7ef94471f4aad25ff8108d7af0adfcf9fca38660bd9555102a0b681933eb2fb98a3bb019b8e1ee6482c916d8bb3657f3e4df817307315e4b2eeda365f7ef6a901872223b591bda93b797a16ca4a3dcfc9ab46382ae47c3df8b83060945acd1a6a2c047516f5f4f5bf138a80e03c189d000f1a1fffe326c49a749699eee966f3620a6df51c8e18f52f3b0c83e20853a6bae7bd065f7c6114cd8fdf1a7545f00223057bc70bf2ce33089233202dc26c8ed98c3c43fe4312c127594106c1a7be840bbc9675048deeb27078a62020ce6bfa5debf0cf067cfcf5011bdfdbb9d282d9546210c35c476fd8b3ae9b7ac4d33ab7b82a66a3a7e47dce770e4192280083a40bb14d46abe2b046d13d916505fbf5e2cfee7e0e027dfdabcbf32f78ec3d2b3827041f193c2b8bf7283fd44160d9559b7fbaac4b150dea7e3635713007a407bd671c6b635073d98ea1102f35dc22aa7a4d1e086aef9bd492c9f05cc3b429a844ee74dbb3d19f99dde13322fc93b0c42a6f496c21941689b7eacb8bbdf0fa4e9d57826d351d4755b337d7388cc991fb14ff4583b828a7e0401c7cb09d8fa4768f153da0992090fdc523846143cbfe64909baf663f762ed5b068901842bf52eace0a7cbc1983e2ec4b0053308109f26b5dbb3ed125a035f0fb7a90d4a566f2e77af06cf97c9970833976727c273246abf23b4739fdfd08b19d9882bad22643299bfe11e94240191857feacb607893abf91f5408f01cd2b3b1abbd4507aa09d796e59b812ab97400138c4f8dce778965b9b507cf391524ac1126170a7d5b1e1c9c5106e1c860a7105439c4c15cbd197bb62b9f7be6ab60a0995cef1d342239ac9db3374ebce6480fbcea422652eac5058384bd0489c15ef9f097ea12fb64ce59632822a96de3fe690fb7515e7d69d1dddefd1e843c7655a384285dfe67b720ea894bc34a5832c721edfe0e5502c767c4f68f5f8d7382fdb449d27a2abd21f037178ffb84eb05d68c335f7f9e8e7300ece6c4d8ab94116121e10f796a2299fc8e1a7a0219a42ef4bd44f37239d2e82eb1a8144fa3ae01e1dc7ba59ea6b7790f800f1f5a5335ef0ebadc43216d853dd266977cba32b89d205e67e593a60d4c7e72df32ec8eb7039a6ad861190a23e0ff742c958caebd56cb17aa6669f66639a8c19954b8005cdaf428f09934e67f015b5aff884f0355ae4ea4f2417a6bf757db734761bfc0c562e005c9ab24a993b18b26b73e4ccca8184a855997eed589cf5ebc44b6e969082bdcca7839201a6239532db3ca483486eb4122d4d305b33f632e5d1bf52a580a9c8053efa889dd6ffd8e53540778305f70d751a3d4afd991128ab3e9b687d9715bb6479c580918f48430936f35f186f0192ab6c8a19e4de6736f953fa6622d7f0229ba2e06440f30a569c16e13e2d94b2958b506a2ae945713ad04db19649c6e966e38c8a9d187ac99fd842c1c568e1c1b0410ec4b29896f35b74bc66c3824588a7bfafef8541b203d86cfe86eadb2bc74d1836c1b746961e82fc0e414574668da3d9a751d0cd6e243a2e3821d2b3a24d3aabe80c6b2f0a14f7cba8fe985fc609fe691545f6da9c75980137fc9c5c953e0845f0e7e2cf9cde929550bcd9ef077ee90abb3ca9136bfae494c8e302e7c8bca593d970f2ad35d3edb0eca61271f170c854a9cd56da9b1cfb43623c39333070b6a0e26bfbbeeb0831f0bad3f3c5458a287585b030793f2f3535a1a5cb297535541c04af5eaa4323eab91baef0c9bcfdd6b56c539bd7434fd1097c5ded21603ab1b351087de99a73ed6f002bfbd1b8cfd38311771c05941bf6698c96fe64a2bc65d38736503fa90234f30c38193be7a25172c1ea5f0f0f9120b2df198b1f423dbc697eb842b42c726aee71e54ad46252f902fb225a86eeede923de28ea87ec12407ff7a494d31ec4c773d878e468a94b2bb8b3d8f35979b4e434309abdefd71ba86945e3b0e52180d061996ae0378e57b63ac944e30990f20159ad92a43769cddb5155a1f40143a2104217ff735e86c978adc5c40c7d37c2f5ef9d15d2f196c902be4757c2e557dd4f98b83c847ff756963d5e4128f5f4310431a06b14efd42e7f4a609669caf5b568c32145d5c054563f33902e7d67d6204160bcdca419ce6ba9b200d085b86d149fc87a22654108592d8732a1624bd63ce2f7eaa50e5e68d8b9198b916f369803b2ab6a0a135fb961281d31f6ea286911eb051c88005645f95640929c5ffcadec4db0ad8665ba805b4d02d0b2ec13b359c10a35b737a5f830067dffdd131b4507ae71c2f5e571b956977f8007b2385dcdc94625b7dc2cf81b720d0fd98b3d9a055e61e56969ca67e643dbd8b46513c2512f0fa0adf27f661ce2d01dc051f58e0b376eb135384cabd6ca9598891e917287ca9490779541e271ed51ec1447aab2dcda3da7648ec5f31b0c8578489416d4ae18e60af94dbd333851d42ee8cde5da2a12cbc6134a1316dd10a62a36d8ff77ad8593d5d81aadada1f1653ad76728e41206dbd799455d849f4a4a9dba7a61c6a76ece5fcd0ebc62b4f1f18d55f11a1bc3dc7cdc4dc8f8d535948c617aea598cd7795d288ca8866fbec2d2c72df727780532c4a523d906d85b83a0dbe55518dea711fdff42a44a5540f51e89e08adac05399e6cb27f59554a306bfa39a12d5df55e872554fc744029c463f8c25e8a1e0e837648076604f3a8647e3d427c40782816cf7a301a2d7020b3bc1ad833704db231f1ccc4c5c6514ab87624fdce77559f93c1f8d07ab2dba1c4f2848af2cd9b494f1d5e97a40e186cdec4d2fc0450c51595ad79fc612004184b8312ac4d15db76e44023af1083b268eadefcbacc4e5f8f820e701cf31c62c9fd2d0c0e4f87871c8c7620d1c1230d04fc098d6a4473848d32020a5dfe1b1e34654b4909d2adfbf4c8e54d0dcef27eb1674c8a0687b357aec4853d6bc98473333514268ff24dc1cb0cab71297c8d936c6f15342ea637781963960d42e5015c5c0b426b6d7fe79f3b8e56b43b9a61117d3cf823173c519c8aba0d34fa0e6022da43c0a290f1700d2e2af4d1393f1416f97f4af4481d5dc6b682bbf41bde4805b8272fa0f042f3e2cb43f46ffc9abc4ea340335741b08888c20bfb0bddccafe2f379d25c20cc06ef2aeb7915e207bc0cc4963d0e6a303b2bfdd7435841447aa3f60239fb22c6e978b3df6b86530018ae7867cee802c0689ceecd9b78b80ca993104040f4ed7fc19aee3a5c913c2c2e10228c60379ba8b3443b1798bc8a831a5160c3c2147c276c67c82b92aab41370a2944386b490c866ed79d9c39a44bb222d981cf59b6a6b52a6307763c21de31bd77ab9a9e09976eee56c52d9dc1f9df77bb6ccccf253906bd3519f1fb68f7bb5c1fc5ac9bdbbe7ffee37c47d26e86abaee4aa47fb8e3c02f3078343a1ece2ba2cdfd121f8f0e057e7970dce23d8b03d23011942b2f3e46ac4fb834a5a94f487b5a7027b2470be7d4ae1b8dffd88880ae6b17be27e498b703d38113005bab311fb0b6070e70de4443f5a0db69cf1d686bebc58dbf70fe9f3bfc9a009542d8c3adfbb03a51c34a301ed471a3024ec28ec57c8c710a8373c945f69739972ab2b5da255f0d86287f63f68542a7830c028bda5622b1255ac9d61600bedb8554bdb43393aaa1f3d2cecec7da5a2203e50add3247edcab0c020030c3d4f92755335db066d8f4939b6fcd3879036dece2ccdc2334523e3d4553d4b664b7702f83161f087908d72942755f5fc513de335f7ba315011ee856ca290e130060be25ac59b316d688062afcda57b565b13452033a5047ad30c0b18ae11d20d3a22e45e653a50a116d80eb85e030aac6eb39c353a4a8d32d990969a71bd987769d51852da3ab1835d8cc6ecb3d477c34a133d9643ee98bad4d8851b0809f6247cc2a6d476d46e17ba1583d530e042fcaf25d2f1e4eb3a7d1aa18b680b652f69c602b8656545a665b1a0c0fbd423485956f26edd6e03dd6db2ddeca42c034e6a804fa6c617422e6f27c67383ca63efd87e265dbf71ea2d9b834da9158ffca37130939ba8617dfe7c143b5f99d2fb62a32dad18dbef25e3850802470c157a7a4727dde09c5b8a03c0088bfd83f02c4f50d0eeff3f2dff2c6d8310adc1009f6f52c6446b296187f136d6a83ea0a8ab9bdd8c8e8cccacfe40a0fe28340639e5ad31135a37d534f02f27140df1d982688088df3a35e3cbff49ba1469138a020dfef7b1709546da753d6ddeef39b375f14927d11ef33e332a0d08614c89ce3460f4c0f4f2bbe24da8e250b1e9ca5b9111e1a09359146404934cfe83086b5a6814f09f26534c19df312849d11d0b87a448a5961cada437ba5625c69e0625e04aa28377c6b9fc78800013b440b6b03a45f831ec662eccfa8226ccad6301e10c32b50f1e89f8d2a410df16522b1a8d62405fff9586092ddcf264afef8297e7dfb2cc3de9f052500793ed0976c55e151ce289e0de2539836fc35155fc25ea2a55f1645e9d0b1d715a27b1c33c6e095152dee64ebbf4b8f1f2c24ef9cf24bb97cd0871e0cd2909dfc840bc261f8a7782b9d5cbcf1db1b5163939188b0c54737d9c29665a91301561405d3cd6186f1b3b53551a7668bd9ea5c636f823a84f3c48366795ad8437126b6a5be2766999a6f31edd2e50ca8e065785c727e3b141d6c5376f850ea4c7444292b7dcb90a5cfffb016dbd1b3004947942fda2ec3827a3ba5369f849300e9b6f8d88a04e7df261f02ffa32ed5a82370a3624e9466eb5fa3007bcde144a79aefd2d2aed3e59e67e720286d0ac3306ff9c53ce5a25a16cca146b43d4489abd992a962eb3df3c70223342889f22fd261603f30949507b924fc6125007b890955f72a3d2ef32727372cd86e0d06f00deafa607ce72e3f4a3cad7b57897cb18c93924260224d21974a9451b92062568ff27c6488fabc031fd697acf3bd2aa408644ee6096b5f99730e62d645987833a38b7bd0902ea5e710526b5e5ffa533bc840e01a68a5196053838b4758a1cc238406847ddf51001a4228a08e9a0757527c0a419a2d65a0de43a97c3de8ee7178766a91d806684e8b7ec12e3c019026e44928c8820cfd9affbce1cb2a7c74ab1c3c18ee4192c2cc8710d8b74651440e0ef7beb3ef8f2860c20e6fc72c5fbe108b21df6f89edb311ba3398e2b9280064ae2899a98212e8f7659266bfb9a3c83bd2c38607ab03085840c179e4c81134f00cafe5e7f0248b273a2f5f0d8eaa459993a4830eb39487cc848d2c5e9996a0963b060d96c1d4e11d1bdf7bfc5424c9773096a3f4743ecbf8d4e885bc9729638faf3f6f0f751b01d76c91a5429752572458e9d3b6fbb6bae06c3234133c11da1c0be369b736d6c3d453a36928ac0d4e0e3d48aa220473cb5c3c2cbe8da5f0c50a77b2f96fe47a0c55c9682745e7fc922e13ac910f1063072e61524a673a63a8ef00d95ad0e4216b1e06df98f29756174db067d9bd9fd0b907deb881fba638857b370e482406800e7c57e48a4171fe4dc85aa56a52bec9fc4b95bdf72b4590ad78a7d6339deb9ad6a69ed8ce7c37ee7b5cc96029f3b70f8ee04376841b80453e899a869131497d75a38d341b7af74f3164b7159c10a1b906c609d1ba8c2dbaa132fcee8fba8af9566e428c302935ee1f5cbaf06e7730082c206191a19b615939c7626d9324f53d594121455f8d0f020f66e33e77399eb064cfa3808c57084cfa526e6510783c974ad8349384bb2e9b1c29649ec4ae45480b3a8f06c684e79b08c03ccafa265d54f7e3c3bb91f63ba0a06dc9bd2137a5fc83affbc3694c02da1b9c539a0e850e93bae4362bea8ae7967d94a9a948404ad793e27f2acfb38152efe741efb4563cca9c6296b9ed5448e14a7d7930a754dfe82066e3331e94c3d2fafd297291a26676e38fdf23aeed780ff310606b7f60b532081142b65882dd5a53db5f49b11b07f9943f953eb1fc2d4ceb8cec17f58693ff9a465a2f761d37663d931adb0e4c405624074e358cbbeb3ea875f38036ebc8efbfcc7f7e442c03b60e11ae28e5a84e735d3f27b4ce42828fa2a10bd024d45637926a5a64d027c36dc88fcf1decfb209d5b09924694a0656e2a0226b138ff9a3dff5e373bb67dc758a584eb9156ec86df508b222706781e8d5e3cbc0b5bfe4d4bc9ef6bc86d5be88907b8bde46c797b3bdf33218592e3d69f5452c1165040a03c37d1f7f88d02d4bfa8aa0d2ca45f070e0c65a1f5c26d1f308a6f3e04e0b5c96e517080e306a07a4f046d4b024644327bab48d1470b052ed9a1e3d4b06f063aa2605b1114cfc3df83e7bc54d9da4b9de3e48ecc8737a2326e7d439bb1163c3ef616e8390536e568a7c95d4b129d2f01ee6066bc34f8c9f334b24a881bc64fa813d20cccdb8c55856ea7eabcf4c8edf05762aecd728bc4fd5786bf2ac9d3f7389943038f13321f33af6789b067e05a7178bb2be36e339e990e6c7b24b6c5d1768e676195f4f2ef1c3bf2be8c8d5026266433e872965046343202c68c6074aa1041c5734c9a2871bd309f84e6043052a28e42bcce6afc7c22d14bce4ee4dacc3a628f6475037c03f4f50bee63098e3d7969b6b5399e990ba5c84546032139a0f444a49def3ac18f7244463b99d3685dafffa47c537c12e2a91ff1373571b12d09780b45ec8af6481a16f9fc84e0fe86951e97f1da36d85243a1e6d833d8f9b348fd06aa359d5112cf7696ddd3a4daf70e97e27cf633ad52a3cfca1a82e49e6d48be0fa57b4a6d747e7e4f67b447f9735c467baadc54edadd143e2d4fe27777f7244399d0e9db68daafd5338f58b516fe9388da571b2dfc692a802761fa002139092d0b9506ad830edc455870e87401992dee622fad068407deda935b64675710f47b7cacc05e6ee19954d643bbf16efc4ab8ac77ea25a371180115091cdff0d7dcc068748d279451b3a9cae51e5d4ce33111204f87302846a4a50f01209e2a221e2685f552421c2e01cfe91aa64fd17517c7323612063c4145020aba0cbc45b6e18d0b22eae81ee869719d7c9a3741a4c197cf220b4757d375b78f49235c304019bf7c19b421926116314779e8799ca5c5fd45c84c31aaa009b9188614afe44922bf8d9ecab469427e12d0bf89a0767a26a6a8acf0b51481383501e94a9780e71984809cf1549bccf5c4b45c0984c7e9a80d7d28f0aef460b59223d5781035d24d3f1278936039b92dc2770359e8f719228a91933a6510c12af1cdfd2a9a57d5ac160c3e206d16fcd6ae127a50f919f79b27a37c0f21d7e455275484f09a907869bebd9156cca05ff38054352199b25cedafdb0b927ba9c50e76c9b11a09c3df56820b8735beda4bb6b85eef14472da162a3586d64985d9e82f2624b6af7f0d71e3d724c162e2aa15451eb65e1d916c984a9d24c9ff1c5e44972d9aad2e4bb4b9148d71b4d6e65a6bdafe963ae9b217809ba2b32696d434431cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
