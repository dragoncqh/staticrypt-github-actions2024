<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9043ed2a3e3392dfff343564daee14b1dd605bca038c0a83d7bc572c9b0c482f8dbe6ab662a0b393da5595884d3d2f122a47a4495cc40e641ffe785c4127d7aa5411ad5a25bf0ae661a87535a3ea5e7b88425b22c8151e7e4ac45a48c10a10aa4d28298d871f8ba59f1147fccb834083cdfb2bf9840022c55a18462819e390658403d369c23ea51243927b1d23098450aebba045402aeac1d64fa019b6870c8160156f34ad985407ef8cb027effa318c70a761b302c6fed93c58f06df43880516f2893f786638868940dc0815b039de4b1bad39fbf37ef4effdf7e27782402199b49c662511f5bcedda5e06e71cd861f1c73c4299fafde0941ba7c9bce87ec3a84f5dc712599411193d40046d5b2615ccbbbd5ec61aea63af024442d802a50a481f5153f80e8b99a7455576b3a770abd09331690727aa78a6f40f8e7497e46b924f18773bb7425c8b27d3b95024f369345f9d13547bf841f87ea06c0af6090677ad6a550ef05751d1bcab484854fb9cd18d9754ed14b04e40e4585272e8cce7a426e26cfe36cdc31fd67bf59e89f54374b6ed8a2fe5e6fd97bb0024260110e9b9d2e661753b5212e0f88172c926f56a9c3cdbcbd917a70d55693d9c40cfec70e5099ace39c9836e38c43f9da7f61ca3d8d62fccd976978a9879d895f63eaf2fcd71b82a3c79227c66272689d17ed203eaa5124ffe5a50e2d18520a53ff6d4987783b92aab9d0f60c91137effa247720f325b9b4df4ef8162dbb9f59cbe687e429ce2d27cd0cde5fe6c46db13febaee7020942699e6ff88574c798eddaab81d36bd2ff33eb17a1b36b4177de33249bd2c62ebfbb2338051b4d4c5619abcbb1cb087007e46a8320dab22807d57d8df6a2067d20482f851751122b9df87555e05ff180b2636a864506476ded5594a562d087955bedf6451aa7512c0910d2da76c2dddbeabafb77b59250eeeb531b7b33a9fb98ea0620c5aa60ae2c1dbc240a8aec2ce912237d502f3aa017a78bc4a4fefb77ea41d2ef3f0e91ff9970aa180e1b0e8d8ec6f614078f2c9ffe1d9c7e1fa6e96f9af5893b5d946e7672427c4df3e674c92203fbda95a26a45fbc98a4f03e1479cd185bef013a934647042fe4f3cda294e23ab112f4b848a78a68dc025fbd31872075901517466536c113dde37f113c38c542f1ce70dab0bb31004ecda37c3f3fa3a9b1e69d1978a486998c773af4a152d3b5c58790c6cb27c06e348e894423f7d64b795564ee41d548eb1429be004fda997a9a86a1f4f1826680bd490369500d52ee78404e8c4ada3bcf16fe99631e80ed1907d515470c85409ac9480db9554cf6d4c8454905ad00096bff912652c071baf91c018ab4e895301f363b5046e4325edecc954925a0eb15b4becf0a909abb55e767d0921eebba13f08c8589bd9bb33eea1642b2df9aa4547203348d65275eaf2c79ed43a262180a5e7a28c006f029f76d5baac12353fbb5e233d950e796de2e76ffa261e8ce3a8223036abfa3f420f45dffb6c44dd9a698dc160bf73e30fd54b853e0ef7e2e58b1f132277ffe43b494506a3e4a69603ee45ce211a1cfb1797a4eb276874c4541eac14bf6a948954885482d1b4dd90a30cd1015e15afd42e853ffecfde9ff41b2653f5b1b2126041c235b188bd0eb998301619fb64f32a86cbd046054c4936a30b6982f2535e4d39ff366821b9f1743058a10b938f566f0a913f80b4993f82ad6cb44f8ed9c18d4c6f2a75e7fdc64d883ab01823b3bd39d1b3d1dd0bc95352fad1bb3f9040b11d727fde33ffe0305bdc8e0fc7532f1aed8e693f7a04ffeeeb149c4398f1c62dbf5bc35c06ffc03c5d6ea12d3ae7efd32e2eb2dd66037d260c5c058a286af49c1e43d23d858a77fd8f7203465ff37789b3aecf88b815b165c1b58901fa462ba6a33b5d7f8808347d25c74169d84be23354e0d05d8d3cd9ac720eddc232fe9a9069202f4ddae99d500ac01e67fc2af29610187a7078f5d6fafc18a9b57e892352634a4c633ca81d1f7170da5bc7ad07554a31cacf00af9e625d2876acb73865b0a96acd94b4abe36ecb8380d31fc7123b8be7bbda9af5085c34c8c3aced7f01f2be3c0270303cee509069a328449b17494595e6371ac7c46b1a69767a8242e2acf8830969d9ec80e9edbbe95e30b3867465bf8b25ea2fda88663a5e067c38626f27a4576c1c3c7140a60cacccbf02ba23beb82014f1a37a8a91662b9b53a57f2b80c9e44b3a5c258c1ffcbd8cef806145440e5429b7e974392555db99c18a2bd3e745f5af128ec15c11a677543bafd62058a729efb50c1aa7e1aad4a1d1869f9a4f5ef04857c785f498e85d9dc9bac8f00b1949b2ff0a0527b23fd2813662d8a69c48f38c1e27fe5eaa1d4b72bb369103276d347d48e0c4fa2c491eb25b7412c05eed5bf6eb4712af391f8e134bd2a8f3e4a136bcd0e6b9e5552abaab249d9ef9dfcaf3f724fe799b29deb57e0840a1c2e481c752a7a3dc62aa613552263dfb1de15337f64de7b7cdea67c3fcfedb735a53f095bc44e5c86d7b75b8a3242a5e04f878a66e64114e1f7c0c5e8ce15977882c15ee13d1b6b2ce0cb9d0f515ad824bd096ed38ef5317a3ecda743813936ffdc13ae599394f88923eea883dda92279937864db48699734a3881086bdb1f18214ed65423dc8e3044b9c0fb10b0ffed004493fd9b15e23387bef1e9aa3bb3b5b14534839a835c67511e07b10dda2a12554de4a3dc959f563e99313806dab405220469a50fc8f20b3f24350e8798a19d49e66f67841ee501f1bb869ffb566cfddc49d88ed1d1aa65d883c2236981f298155a6fdc1c78dac6a697a158193b9e69665ebaaffaa21d1a284866d8942cd5b27b04770085011eaa20595ae37ebab5ef3ccffa6f98f171ed7652bc98e185b0bd4117988b7eeb6be871ff92ecc325607eafa9a2004b71d621e868e60b4cd9d6e9343c5a8d03aef6006b288c1579cc42c195db54db266d4e0dc91bb5cce842271f3b3b1133a49913422bbdc1df09556d854e9453b3bda9188f68866533a74e38ccf745ae7e36f51050a6434f39d89105395056b9d0d1a913684dadd7970536a93a1e412c8fcdab02dfb4300ad08431ed0323ed1dc16aa628aa32f0b0654ec4b49efd84c1ad10ce1feb3ce5bc34e3ad3cd9af7d2fdee1acb2905aed4858d753573196d8f580dc67a0c9908e94c97554753858ab11e2dd3f83fd2766b4843b588e31dca8fcde2aefdce1672ca287caf56cddb6c58a127053ff6f6355c88a64e90430e73a985f2b31ee951dd36ba32b752f1789d5e0a0efe04ce0d8a8319929198de6f53185de6178064f43915620af5c600f3f752439fe1bfb88ae79b67ffbccd3d815993b1cc4d10f149c6aa02659f0023155df1e26394d3ea74f187f3e9d91a7b9dc3dcc08ddd151555dfa42637f09241d6ff501dc34a31691692f2e22ebeeb4f361e61d00049bd6cb3a5e1fbf216fe47f4da865c93240adf987a295ad45a204dd9f4af03652c99f48fae31d5d2d6653a381329a8f08983862f6e17d2492e1e4bc3727812d179f185f0c82eb29ef2e95d5f919dda58039d0c41dc1996d07f5d733aed1a669a5c9f0b2e1f4f74097308bf5051c718d676793eab3e33aa8b080f7ac0cf2e3be58673cc6429fb1931d3f344d0c35fa57a032ea09117ed1dddedcfa30b425bf447e17cf92cc7cd8dfb452e343daaebbb488ab6c3283a17e021147c9a12829ae712b7e32f768ccc6ac63b7a339de8fd7ccdf761b1ccabe02bfb56bde905a37a101e929089be2485d613135273f100bb76f6a9aaf312e64240f1e5b74c1fd627ec2730a27055990720effb9aadd7b8eb93e232c3ae61823178a90ca931fff41ca726992ed542687d43db7f4c371089289dcd785c0294b02e95da2873d6aa09d942c873789cc4a2cecdb9886a368e396042927bc03ec667f945b81fa8fa1a8fe4ad64195daa73a4de94e759a39039a05a8e18a3e0805102d0d1e96c9016231c744b497e71d13a655465c506155924189b6b82a5c461d63d9006db702723510d60f3f97d1e2964533d3e53466593c9e3eda8a19d25d903e5668aaca7df85da36e297ae02076ab40281bfcc86def0600395d4f8f427caff720fac082f28c095fd12c00f8302009fd7f1819a2101ac1d4958c3f1704b1390d25dcafb0237e22e8281a3a0a0dc4f36a40d93be75c5f89028ba2580543dd2a0f4e41b1f5fbbc5d245b481ce6671416a42d96eb8e9e711b19d929cfcf3e8f50b7652ce63f9148ad946c2affa4999e6b3f28145cb2898abeafac0035addbe408d0b8a5fac38e6f00ae4142a57256b697cec313bd6cb182d2cd8b38954f842cc61158de00134705f4d8048270d7bd45847c0c72020adafb031060c679edc4a82b1c5a9a943fdb90c7cbf719c76c09269d58e816af89e951c46dad7038e21f83e6d4c423919d4de455f7bab19829f0b165c94f1d45835698f40bab5d9391768431ff802459d54f891bc1cdeebd01f71300caaadd0fcdb09c1bc0bd5b35a8f2d2a3f9a50f2d33533a6230e193bef74a50d2ea1e249aaa0daf91731f9bac64e472a12f8e1d034577a5b194b07768e4cd06d48710d53e3e34bb5a4f5e9445fb0f00f970b7529fa8aeba692076d794cf366f140162ddbc9508cd0e73c75c476c2a96af3583fcfe21ac136a0658c5a307d40da23e0f42e15b2f4b2863a67e8c3c1e529e192f3f26eed6e706cdb0f2b049a1776b6cf6de7491e82cfa346c56653ef58665b8c869f56a7faad6d3674df2ba2335133d7d8242b7d41605bd3777d61feb7350d1f9bb4675ab511c7906d460db8b6a7fe9d3dc8dd8ab32ff262cc733a55730bafd846a96d4d6ef2a005c8595a86a0241d7a59c3c1d49cdea5192ccce9758a77f1f801c10eceae64e0119b9193568c5666dd072c7f7bb231fd155c5a70cd6b9edf7346b4250ebf1b3371cd7728d30d919f69e9c9b58aa9903b539ea89364ec833a1a35c32f21f4696dc9e0b8262f131c63d74bb5283cbf504250ca652a989d0dbc983fb1881e95e6e2ce2dfebc26451cf068993728bcf28bb45b198d1f0aebf11ba458839f55e55fb5ce851a0e551df9179b5c4c74074695dceebeaf7cb937b82296ac70aef89e874932b7bceaede126e14cfb4e4fe84892d0903138f176325c82efccdb37e7c16a85b125b26b7eec64b335aac6b9feb88232f4f963cded76e3c1429a882259c8115cdb13ffa3b5f2693ee4209414f4e7127e467b3dd0e86b080ce47591286ebd48df8e4e3c7128c31a989fe42f51ea5c0cd863d677e4b1b74721ec5c3e209bc6f9d66a63ea09dbcf1aad0fb5b5f19f59c90a92fcbfdecce950f90443efcdd6979037ddea9a448faacfedbfc2a05f0fabfe9b374cc78baea0448082d873aaaf485fd3f6d638519420523b8e454ccc549991cf18a001aa53020cbd0dc88af68eaa3f602ee95b876841254d631c9a9b99723a38ae31038202c49ecccb04dc28aff4f7cf5dd8259e7131270fd4bebc0aa7dcd5c739c6958de392ee3d6731829ce199495d1c76d7f8465334a8158ed520a9c13a94f8ecd8068e4a8899fc6b16b503567a3a26ca66fef3b5e35f29b79b672fc4b43f8e2324b1af309e695337f5291397532a584547d99e46c78c86413abddc829cebcae88a34a5178ebc3926ac0fc345effe0471ad090a38a8ee347ce6b8c6614c4082606f18e9bb1d8709d148cb22067d0fba087f02b1854757dd9273a7aab2bc5ecfa21545c2ead59ebab4a4fef836a66e28bb431e5a93a8139cbdc205077eca111f09294eb2ee589aeca67a5d8f8c902d880b1f7176b7fb84627a3509ccc947ebaa4610431c68d922bf0c25e88783ef621963c98429d1d017c4d729abb576328bc6ebaabd9bad1d2bb0ba10eb955d6f7703ff517b995deada00b837ecfc2f169c6a8a9cb58e657a8486fe0bd701aae0714603f86726d56cd458907cb91f7c251924f67c4d80898b74d08a4d3bac2655a42ed64507837ec67e905410d27237214781e1c6a1822bd88250bd94f2a81e0db5ff2f4df0e8f60090030633eb96f80f8f68a28907465312ad93fa00f719a4f4caa233df404a9fc5bb64ff10ae86894bbd2211bc653cec61d1f549ed6608e6116961b20947f7fd277b0acceb4dbdfb603191427b6420749eec0f0b3ea4ae346191d112af9a6de26ef17be0e61ca0fcac64426f233bf97383c91b696dc5c55df028d8eadeaefcbb614338609f592b72ff7056c3f901ef550104ce13573138fa163b0c165173ee977a4cc4fb64e0f3549b882bf33a97071146a189cf7eb3501f7e3364d85e10321cd74606bb16bbc7a545ef411b338dd36b2b02da152d453641a9e87c941db1e2e56391af61291fa6fd44fd040802516e67447a31a095dc3e832ae97b7422fcdfcf06b51cf7e911ed6f777b2ff65cdec79874bd4ac6548e9c7ea96e38693589db97b095fa805979a82def986f3982f24932b63832dbf5192742efe95318adf7eeac5ac1fe2def96ae2575698cd2167e52dfcf316b318e63f5459d23a368efbd52931924b8a12e057898e6b7cea52f5e7e4065a02965382d0a28fb39cc20dacf8c5c8b323021e44cbe0198c60b0295e58c262bdcff66779247e01580fa42a8af0268faea85f7d38dc593d1ebaf2d6859526459d584d3d859bab50310325407dfa0f3c293b5322d13f4919497c98810bb9031901f5b9874215081a44977e3f9ff66e63ad1f714feb931605b4b83c9a76d432082de2164d2df8c2167695bdd5708aa0994dc98e93216b1df7c714d7e3f29f327446c40d3b388ecc6108e18c4565454a8e474006f5916b10da59be99227548b16bd6282d2447b2783fed3b97287be64a3ff2aa5b8617b0ca16d866ccef4f276c6f0e8469293c233c1b79b31803e70ef8284b5eae426cdfeedf561c9d132ad8732bb8f25925a129cf18d54a5a03d540af6a7e7cd2f726493eb84ccc14903dc1e97971df48117a75c11db8c05bd216c688d238c2ac1d554c7b4d7fa33a319bb195dbff3dc4245ab9970158f218110fdd8d553f6c27bbae6c9cb56ceb1782f0479627b21d096b703d69b23c1091420728daa00e2a76ecd9410a772326c444b64f05ce18eed1add452cb9b64ac3e9b40ada5bbe88aaa98815d5e075b3f31069d34ad84faff5bb1a27bb9f2821a10a2221a8645e80af6a81dec9ecb16de314a53b373a2ea7a11f3771ca05ddddbc7db9998ad14884260ca54fd2561b2cfffa5ea7b02221be20f85e3c95849e4007d6e97632fe8332e42b4f75e584ce7ae988aed6f98799be32a8ebe25e07e9ddcf424f8fb67640d1edc3d9b882782ee3e6048963c1df9a6d4cb2bd8001234199021538d46690bc16eb3d7361ab751dcff4976667b6254d82d1487d98940b5013c96235af0620c142f59d983d9fef529dfe8bb014350bec07cabe47bd0f4b202ecbb418d4dd279d47c05395d240bad2f8300a73289d87d3d7c759efe66611628f45f7f2838e7e38cb2c4be6f782331a43215e3ef86eef838719368f3ded35cb42c05a89be945f2b2a13ff14ca861d594b7338be804fa41a00ba82ff48be43e36269d0f357c8032caa143547ebfb11ce54cf9d8e54701696453a5d2153161cd759638b3a2201329f8b1d49590c323ed1dc1d7f8137f8d1d42f12e453c490da134cc1407de5d1d27337a2874af3396ffcf4f9e9f3e59865dbaa6542bc854d1d2c786251872ccb90a11b0fae6ff6010a2239af4e6d5d670572b8c15aa074fb1ada85534ce46657c0251d5177bc02e6d317347dfb62d41e3eb3b9c465c546ca75c0f1f636bf19f22a5448618ba9260de278ddbf7f4dd199aca0aecd19d6877becb3f1e8e7d8f4928a37cc0bfa3e1f1a4c21ec58262280b871872100cd3efec21744801d4196718de69c5a0d6c6b4e06eef95c3ccd66c0ea10e858564a6abc718c58c746ef8034f5e98010f76e03983a53281d73871b2cd8f1def3a73cf8ab572ba126dbefac0d54b6eeb5ea4c0d74e505320233bfcc96cb9a8833cd9ec5505a9b6b3a9ef87d48d4bf9579f51a50482aa767cb5ab63d918e51bd96e43fe8b49695a4b4604f1a40ae57ae8d3d520906635ac0d4e1e359240055f3f44df1f039c3913f7945eec13592885b1c37a4bbe43ed983ec6538bb61b55c7cfc4ef18504d0399106cd12b7dfeeb1608cdc6d01a35ff3a108dc0fe38ac60c100512df3ebf7085224e08e1af421eee7a563da8e147def3f3c77c44a34d1b7d2e9d6596f9514a4ca493ebdda08ed6daef817ddc9a4e99e5062e02891e61f22f30855bfecb12e58f15d38cf11aaaed2cad8bb8b57eccf12f245d9a0b6478446114609a377ae3f04cebc8fa19b9cdca077c1523c846cbb0266b9c619d663d720ffa5ba0cc35de507d717c30f54efd583e8088908cc397a53e53e9a8836ed1d671b279b4fd1938b707fda33bd815e28e50571a042f7dfb7ae521a52bd78522a52ed9bd64e5d4f71d7641240a152964e812f2b77c16c1ba9832f3aefbd1edbbd05ab411b17078d66a7bef50f11b821bd2a6d99c4873e1b36f3cb85620c196b5678ca0ea6258f808a83d01a80126d57e5a72fcbf2a699e4fcae20bbb53273434c6ecb8bf35c099710fdda72150fc9b533eec5b35a59990ae054d7a21e1bca4730c41fbe125e64d40fd344fd30cb05a4cdc464a38cad80b9f0e8328ca4d11eba566f4592ab6cf9704856e0412d18daf2e430e1b405c873061103bc61ec2abed44453cbbb7fbe6ece83c44d59f7849e88e7e4848e7a8859efdcf6b669211777307885b38df6b7edf61632ad29a402c109d54b185e93b90823ac95a4e7061e45b4fcc94fd0a40d94736abf6256907c6ddebb9170362b6cb043347dad5e7052973449ebad86bf12245ee04a8449dcec986e69bd6b29ca8821ce6f87937254601cd19e42fd63cbb036287156cb1a10ab740265a02faa7c6c9bd3f6a366121ef8992e04b50c05d2f5ceac3f6edb548723f5c2d0539c9f8787e946c10647c31a19c524f853de8cee59f6a739e0d0177b050b1b9a8e478376a349ce0d1417ce719bf7ff748987ca29f81fa81296e26e0a6ee9b03b2bf272dc82d9ecda349d014742f5bc76657f4d22e6a6846e883c2fe27cdbd01d3983d8666c3aa19633de14de57b9ed6e4f6709281c18a89b923dea04d634404e0c2ad43b931bef08d6d52158ce4a545c8b6d553d651ba2025585fa235485de33300761009ac8726c42a7cb7471b2a0fd09e64b51ee1d2905dfba69675b187af3b1d9a8c606d49f2af6820f123f932","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
