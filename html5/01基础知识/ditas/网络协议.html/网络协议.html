<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e71c0652f5c2f619a5591352bf1aa67db885b0b05659db4d0a0df65b2a7d2400ad4f0976c21d4203bcb386b2f3f8fcd0e04ce72ba9d91ef24f43330f3b0e436d103c89e49ced975aca86b3821e82af3f0bf9ffefceb84e28c42673a9dcb8d7522a4a26c4f03447685fd53769dbf5e38f7cbfd6bb3186afa32295d813b2962864154cf4db7a0de00ee6e078afb6ab7a4e9729347ed17aa46b4715732b5258e77515cef8502dc918b1760312c8e41961ceee91b1773fc39cefe70e2a78c5fa87551a5a9ab9f36bf0babf7d387b1ff5423e63e430b2c20ad60616f4115af4bc0f965309d76bf10a79d631c9e05041852dfeb27b17a4cc8ffbfb187fb99169607fd7143ec24caa674bea832d2fed4d5860181f93881fe7e9db83da6864eda03ffedaa15bc80e4e0dc35995f68d5abe1ad8c8b36ad6757b2cfdb913dbc3c41b41aa6bc08660003e671769c8bec788a81b7705227875b6c1ea3abdb8a0cdd7c147d3491a803de0c8dea0fca54501d374ebb0bae5c3f077694c8a4cd1b8f38cdc45ec664ddb05ddb1b2eb2059b54f5cb65a822ab4811ebea562cc1ab5cf822b4454f34546f33e554cc46c80eae62e81c0825b731f45b8e66a1e6d9b55406f521c3534f1f5dcb56791da1151f514ac5d6199ba7647b21de2f3a8ed1e939be6b13c814245c751150e09cb52721b120b8a27458e325d1039630718afe392beff1e9ade32c264345d0d71a1c43df20f48aa7acf9fe1cba9680f2cbf2e98048bbbcbbd9b0237b42d429be13dccc8802d218a05178b78099fd715015e235532b18a20b718df53fda79569aa931b11b39a9adc8a861f0e355af69745b2b1e4166c705d2bb394d664000c58276f7a69ed108e3edee790a689750698152b44a1d320215e44fa5052d36fff474ca028e1009f1bd5ab2791ff2e6f1811abf88671b3f2712962dfa72ceda06e072fd43e8f997655519c7fe9936e4942a3c7cc9da7d659e5fcd900642813d43ec465079a88733b67f7dca7f78d490f777f83479706406348dc424786cb3ef8a54dae99bbea37cbd930fddeea230b2050ab89c20c838e0d59376dadea0aed6a5f4b086291b8c7d4d7ad448236b10b63e0f450fab2595466c59f94dadbf77b14829e2d5e9dbb86f8f6aef190a9608f3886437f9ece5e8fb361a03af8b2eef21684a4be52ae143cb07f61a9c12f4c09a39881db6b7615799d20e6dc558e4bdfbcd3aa964f52397806ac13cd60728a24abb74cb752e03253679138133de2ec93832108920d308760eaf2c7300e3552e32295f5f313946a00d862e5e74ab6a2a185dab9b1284220ad43c75565b1104cc959ce5b0d7efef00f9d4eda926c2a9745e8e16e3fddfa86eaff51f8f03a9c1b84e2e428f52acb51d011c3ff34a2924f1b34861e90f28da768b1a791e2d47fefddab80737e79e39ee6be2e1274aa65bade1159ab96b6f79188d104d335317a6ab193023d68df3e39cd829f127e131344fffbea4fa8c8815790ac3bb819fa581580dddfc31cf7a0ebdf308db5cc4544c36f60bd29ff215cfcb8bb7874dae3c5eb052c678718f7f6a8a59b12d989ca8abb5348fe5f6a16eec8d21bca7f561194f50a1b49cc5b37af7c1599510398f7dac528d5ac49149d6a1bcccafe0c6126a9a6de079857f3be54d35ab72260e585f93e08c4c3af043c787400d7f28c85a598a3e3424addc6063d6b56af3549fbffd3921f051e0eb5a6d93a52a9e0335abe878497c30b3a870be38c9a1e6c41a35fa3370f5357b3454fdf99f76ed60c2897a08034812087f9287aece31f6d8364fda828e650a169f83597f734d069d5ed31ed21cb3d9246036e56c859aac5e14c531a193ac262811b4a695249b55e73ebe88edb93bf13d7afe350a37e5442157ecc96e2798235f0a32d28666b999ba5d3142d4becf83f558fa053aff45bb422ee5f0cd3ed75cb223ac39d2d0879d6883a7ba202c45801b8d58dda7c2baa781b67e72ab226c2d4bccd15bf09a06dbf9b8177019150621b3c3c4f4eaa825e4eb99cdf9fcc3030d3f603cd4d168690fcc27ccde364701ad05cdc709763e44b68ac8f11b365a8ef6f3a3aff1230747b548a10cd83bb758ca9dffdaae6362257f6d57b06c72cf7e998d9b1cc46348b8539cb10d52f17f960114cbd53efc8bfb437987deff72516e1a441f76e90ff7f79c6da45c486e22c1640e0a520f5fb70430affdff7e52ca72e45e495976bde4531817d1a392ba6273b75d55e5637b5e623a3cd2058c1efdab92595eeff8450b2071224680fa78aa33b8ae5370308dc8608d5273614458c1d25d5c2afb80fcc6edd949fe03cbf959a0a74db5edf17d535816b7f27e00b9124b3cd45c76aecfeb658420009a88857bd05498baa1ab8dcc1c5463fdb971de1e33c58a992afd37777a5a02968b9910a5cb850c5116083e68b9ae08440115e15ab418e59cd60ec0757345945acba2801a91d0730605ce33f833c829d4a46495d8c9213063c28dab0088d4402f4987472ca244734d6cdb00239d10358fe7691c7d54263ea7b33ef969292adabd04a690c34c6d1d6a4a85c9f9fc302317825649ccd5233bcb21b384d212c74e082c697d96ff917e17acd49209dff56f19fc4ab1549b868bc39e7f7862e3c684322c2226da8ab8757a3a97e42b8762446d9aa45c9118f1763111016513d03f3e7af9fcb297fcb82e780c67ad4522bdd287da47c00052a476da36ae61584020c2c9f701be10c9ac8a653681ea5f92e5ef1c2f8d9773446855adf64c631b18d76e22fc0ff96f8ef7cfd2d83f4c2deb5c930ab7190919971c91d9884361675252d84883e65aca3b12c41f61f8f7cedf7e0fac2b54f820f7d6d984fb0d9ad0ef0805512ee007e01815e5459221e94623c27a062b39a8e468f00b4c666ef41cd35b8d8465ea00e8f465d7b2bed55fcadf043eee200e1248800996de22f10c9501920a1c9ada3edb3d23d4ca1a9d11e441d27e5e439e1b887e507d264a08a517dc5126eed0677e37935c4f3964953cf9c10e51fa2f3962ea0acb631af13cc3bd70858aaad2510da5174de98bdcfa401087d14d1988c19d3d3711d5d2bbd9d68710aa27c9f41282ca17afa5f747db98428bd31d5c5ea035c611f9ea4a7b16c0db90a8e6daf4bf2e86b8e25c94f618200e96b56af1de5d24a3fe2db68a625d86f735f49268f84767ffcf12defeae3da3464ba456190b1fcc8b66939df0de7351e1c0b6730bade0f8152b76567f978a69ad461aa62d2aba8cf0e6865fa610d5f0c679128df44fe4db723a9d216af90bc99dd940e56bfa001370caa96c0c00f106dc32f604d51e105a276b2d9d9f929fe158b85ce4949136bee0d5a122de34426d8b397a2159b566091886029bb67caef1b72720fb4697270d5082c4379f5cb99343aa5e187734107b35d1d0f23f3eb12b3ada8b6c9618965c4a8dfb4bd92e4285aee6580c4d27958ed92d581bcdea2a1710bf802a1b12ddd4369038637c0366f36d836fad5633c978b362baec270988d5c46ec2a6dbb4babe8cd1b9888be8a8207fa09c929407a769f143c3a7787eed03231fa6452882f26fb9da54346ad0918e1eb954b967289845f85b9c167fd3510229437010edaaef156d0ae0f9329d5beb7cca92f97303876d0eee890eb584fa6b5fd67d4aa50f199142bd54dbdd6ad5b6675c2bba4ceb0ba0061a32bf36c308c85ab17300e5dca08c4adafa20b5260deb1b3d21c9e4bfb0ef68172c1ef2552b3af8bbfd4b08bc3697e15c0a4d3157261e6e1c1288e7bdc5892d942f64063e4a137c5d8d31343a77cd98e24d4bcdf012413b1af1e5a71b0b3e1aea9ac3d0be5e3e9069ae96f65c7071c5f59e3d26f3651538b5c3d66fbbeab707642c28550ceafe6865806ceeded6ab3ed96c502be9c2886ba5d2263f0677fda3f4a03057c0fc1d6c7cc57ecaa6014647f5e2384cfd0ff5ddfbad3ca1a01282723b152589736e9d1d640182d986f74da823c103c89de8ec1356c6e2d7735fa86a86864e1a17ab33aca104dd716bdae670e790e63c41e228f3ea780126c2f8535a8346bb6028f1ca4332aa2c88f0e14f4ac7e6d81b6991fe2a39578590e730ff3fb7309655cd26da5d1c6204b54cea900be095e1a50d3908b2ce286ea8b37336a4523d80b17fec54f1c8bac338b027052264845635ef87a8e7573f34b5a7cb4b951c29fcb1fafa812d2fd02625c2ecb2938c1b80f80b4634308781cc2074d0e9674be35a2b59ca84acd7d7e26a1b5267efaaf8c7cf05e8adc6e9e3d68735fa1017d937a6c40fe2f33672a58ac58df63d7e636ba17f8229ec490c9e39fb6b0fde9f4696ba58be375168a4d7caf45eab2948e7edec542d8e436197233b2006162b3c5459a21ae4bd20d1935b70fc1a6aa98a30980c5617c6784be4633bc9d1741e1efe7fc76bad04dd2ab344a62754206afc07f412466669c421bf1c52217eb5fec9abc8c435509125a4518474aaebef54962103eb86beda1c1cc6cd555db136f742c45d5b91dc1dadc7675a5a81de855de5a64b29bc253235ddb27e15715cce0bd363d88cc9a23383e223ae743324943a6d045c186e264228846b5a7a2f4764e710ef281268dd0beee0e53d1127af465cf28a904fd6f78bbcc1d363d4326b0aae420e52c47b63850fc57f4d4167214d785b6e932b7e5424bdbfc884468afa7d45c7c710e60acdf5baf8838bf1f0e5c6f42529f23ca0af32beccf3aa7fd4b38d3446b7b9d79c1f7b929ebb6af6cb51d82c1e127112837ee0123d8f1f485bc9f899439a4bdba60d822f525b9728fc811a3e7836e0ca226503c161b84cd9cf9997239bf19b8b73ecee31ac52ef5f64ba1e80d58dd1a1de725f7c9964348bfea75782b177c5231dbca8fa685c2dea58ec444eec80b4b81345c71ae1affa65120f9e484381752a5404a8f9bd511caee0b0152598ab9485e8a89698d2e7824e76634f0bd8c92f66a98e139948d6d9dff8cbfb10b9d996ff9b384220ba596d964325e46173114d379576625b5d8c15174a50b0fadad6601e48939f8ac37397e80188df91b109d9c340e41fd7a4e0fee9a3cb9ea12cde6929e92587d9e74827bffb84875eee5752ec4b8c7f0fce88ca0b4b87eaa30707904de0593076102ced51f01c533329b696de962c26b054cfba591678205c1d19bed5d126944459c8705e39aad1793beebf301c5c24e8d87ad7fd7a08e17b74273a801e0b9eb514d5d3bf9c4966ff1349eb8988d64cab277b5350653967c223dc22c90fa9564d1ac55dbac0f5d79d0a60980b057f64f19344a46c7228ae28fa605564b07788d615611de307f669189e0fa717b1012c8749569820ec16c6b96e6d46c3459b725a5b971b1d75ced14b507aa4227235389097f603e400c139c1d5527fdda361a016353e1897d3e68b49d881b7d6efd7ac6f6ad4950d02c4314020afde7c384828eb3c0591a5b2afdb07c6c282a1a5e93e8fc07d63caa039928c771ce3a398fd9056f33b70c797e897481cf025f6bb2fb5fa82dae4d918caed15e9d6720eb84fc56dc05fca548e17dc867cbafcde666241a527d9382b768b1f059e5649c28d6b584fdc3a355d2865d69fed0d48d13dc85a54ef4a10bcb2779d52dc288231868daac574edd54493269dd62336bcb0342689b2f098cac3e8b0e6ebd21041f9c7c2a3f868178cad8fc43abd4f75ddaba83bccfa9c3d42cdd34545ce24ec8baa24cdb10657adadc6cbceaea5acfd331c480aaf392a6d201170117ddcef9feb38bf0e6b876186a4a4664dd23cc5e1b757340d13dc05c86bbf2bea37ac21ef320089e5a9e1aa2e382b40923a4a89edab2006621fd67f90bc959c59f8615d2178400fbc872d0189b179c04aa842d6938c8254dd8d92b24af2c0667f3ce89ab23821d794467d76bfa347cd3835ba4997fef3fbc12a0d30d7844469f065c035723fd336be227ed910488a7a7b4f620706c9b9f096548ac211f990247c7f847ee5cb417b11479b6fee22f4f47b46f475f41e39c3655332ebbb2b861a5e2fe638aad70cedb8069414b7c03d708a3b4bae29f45ba7337ba9593dffcb9ad393c941cec767b7cfd19129bab9fb6c9e8fc079ca92c390f81132d65bfde8932c26250b92a5ab30612c49568a3ceb76a9a31902815d3e80cb8443b54df9fbd1f67cb18cde2de1a66e750d2d91b70178816ff100c66e39e9d7289a889122ddb226ab671db90acc47b075a437277a8b9770d7bc89ef6a0d2f4ee86bbdcb9b6647b34cd3a3b48b4f7014d8eca75502510f7ab8f94891184b3cd73fc7917ec72e18670343b1a89e614dfe1564be34c5f2ef01bd00321bdceb2d035d13ab9e87b70d5141ad049986adffd81aefe479e8a8fde1682a534758a17cb85d535e18d2e5d91cec2c74fb9da7aaabcd3d7825c79beddb3f8fec7a8363813a84e654d2226117303b16a18883e370ba94c862f41a3fd9626f1bbf0ebfa52ec3473b9790bc1a38f6876bcf36f75d59f116e206ded2c5a7e9513ca8c941295dcd69b91ba0b50c1fc154c5dda420c55d6f9dd0e1155a42b910aa1cba173c9d6ad1480eba1c7ed4a09a1dd3a20bf8647def257f4bc0ba1dc5947a14dcdf84041dfbc70cc58fe467bbb92afcceeaf0ca8e4bcc456ca8ee96e023a6aa120a83a993d51a7028e228c2e76c63418996e736ed7b92f6431a344c68b9e88e653ed908241af649d2e945efc5e0e6de2c0c181f00cee2d5727b2e8c037abeb610cf9dbcf47d91b49e451a231753395ae22b3c3a8c5e2a3c3b44788be3a2f862fe5899fe771724b7bc9ec3ea062778b56f8f534a643615aef832d657c08abbeb079b809ec5a5f34c0a155b46a9c38e3dba1a54e9c93f85de0e4f6f93e9a5e21e3d94cd16919063f5f5ed3f4785d7e2e2cec8741ae03cfc9bd3224541c8f844355ff176dcd984d346f7be2d3cef6f98edfce2dd0df8f6cf91cc4a29f33eef40838bdcd7eb5fc8591fcb66c310cb21c2436b72db4abdf3521836d776e1637b5ce5579508248ab802d157f10700e005d98935446f0497c0a7414a1fa86b2c1d035c72c5e1f992a9da451aa00da6b0784d22dc81e718c06c69aa07b941d447d9743f918d545c39e8813a4f969ac5676b73c712e4ac8b06f3fa0cad284a6713abe1dd1d8db4fd464d0cce8619b8a855c97e6744e844d783843a1ae130c66282a7e109ab8d36389ae6026baf9057a2bbb0687dd36e193d151e0399d8b74aa7c8c2ad630d96593269bec85033ee8d3fcb5f1960ae0da56d7a4f007f66e036179a072b963d59dc3d5f0125a282195a4b46ffa108272ab5496c1d6b8eefdd33fa5b1d524f657c367cca683861688f54ba40bb6439191044a92efc5604760fd4eb3f9a2e5118de5d956d9819fabe7e68ac0ee373c9985ff6319747363cc3e8ba7fbc4df4dffff9fc790e88964d77bea134453230a0913cb9fe536f7a7d6f6c2c882aaf4687c2bab6e4537c3c8390ccef55fc79d231f8eb60cb7745291ac627f3e7d93608c13b2360f8b39029ddc4fe806a6237d626bbc3a75bae2543c58c165219e6f1a9319062529da297e610b28e5e20789958d5bc1d512eb6a144a330cdb12a72dcdd12a69033cc9489ad510c1315765dd39b3bc0e9facbe2326902dec1eac7312063722fedaecbed2d022967a9f9a3c8d422dc931f7678c151415968a7689db7e85c0f644c30bbc07b9ceaf61f20a134d654cd7236a4c467002e241c8de4ef98654bd02bf3f19eb29383f5036b62e7313830efdf13298df6dfcfe3223b5aa36163cb77be9d38786ddc03641b0972d712b0e52158e70634d98227649eed1f06e47c9e2ec71a57d1d136ac6dc4fe65901565039f4507885104d3de92f875f57983a2894d27ac2a6575fb74fa69b62e8f40b7c68d158340eb52d92eca6582be974021c24a7312c52ff05cf76351c0f3fa6d94dd85a159af223f8247189635aca2ed76e95e7aae5478b536c438bb539172df09acc1ce2bdbcebe64cea4d714c5d0902f89c48ffd0952ea4dfaa70494e0edf77641ccedbeedbaa9bf397701ba4fed44364d12daa26a48f03244635e97cc507fbb991a028ad8396941ceb591c9e739c0969bdb5601a6028cb570804d00e654a0e1521c213b3ebbbf9d2cb4a9e40f3ad8baeea0bc3f67da4e6ea2580a797b8ad3b220556a3c6ddf39877171ff9966d528a14548f4f1f969cdd751e491b0bcaf7682a1952b03807956e66ec9a6b1afdd414d78b53ba3e12b2ad2bee58ba1e0936f455376315100dfcfc2b517f5000881e2e42e676e934af3c6118d8b8681d619b07e8b471a771f4ca616f1989cb171db636e6a41cc10a853d466ddee22dc66a06abdbaca85333c5d7360de2ca9352a2df1c18006c9d7fbe3745174a90476d1c6ccbfc48e5f13823f47d063fe68bc777dfc0f65b8a16be28332897be21dbf5c202d29e8cdbda1d9fa4eb2a6f9425bf1c01b02dcb9f9ce0caa193e8ac2d533550c7030a0df5630f576ff8a8da80320b870a1a5324aba31cce9ac764387a0c3cea86be6ae3630d843295ccd90a20d5d115c8520b0b555b7bb5fe23ad30dde34371c2e499eaa2f637bf18bc73334d73ad5f51f1df4ceb69d97668bc77dfc08a4e69420541eee1641080e0b6627231f4675f43514f5de0c775e83ef332e548263dd499b7f0ef6b2a9a9765c43c882d5f3ac3dee85b0991f7f4cae3532f131e96c7092ccdcff95442989fe93a68d31b334593d9a21215c59709ee00362dec461d59f339cf62142f0714bbab78eaa9d7f5d3f98b0e2eaee0fa998e2b968cdc2301b436934939ce69cd3c24ccffeca37df295526d077901285ae72dc5d6e2dc864e53840f642d8706d861c98621d7c43728af04716442dcc29f9c28b89fcae20efeb9c350a4b6e00bcb6f88ea7d2a34c2ebb3983ca79f85f33afd8f0edbd0573fc81cf3efea332fe576e8df2e5579b31f67f8c337627802fac513a550bc8889f20a32c6363c31b2c71175ad76fb49e010f9fda5d34934a3dc91e39bd20079633c69924c5267d91507cc305e61cf1e7002d1847f6ef105a7fb83477db2ede3b43bef840c62d35f5a7c640e93c8818be18e12bdfca2c54c8b7eca1c2beb7122b51945cc80e68087730c87d829a8f6a0b17418f0a62665197300e651ff64ffd8fe200f5c26befa235bd88810852648c2a5654e6f3c7d55760e3e3a79781ec2497efbff2e2370e7ba5d736f98e2a3131b17d4e39fac9c6d640440b86f17b78ab36efc7816c9fea3b84097de2d43e4f6dc53205489490197536cd7ddd21f1b18a9bfd3e918057c0c01649002f51b63d02872829e7ee2a6872198598597411018dbdc653072e63f8996e21ad6490be5f1514362402bd6465431c8f0edab5c4fe2d6ece47e8a9f736b9177f168118511b9649c5c39faf3aab79043b7a779fbe3679df00b71194a168cc4b9a5a1619e9173a5ad9d0342b99bba03adb8b0b726206f0df8758a8fdfd18fc6ca0e2ef0acc63ea2146d25cd294f6eaa4c4cd884ed9fde00521371cbb6ddbe068e9778a00f4d8287600336661a6d7a1802fab39416f84c844733c5b5bac42d94bbbd1251536695545c06e3086765ba58f33de3b985a07a539e90f99c1e2e490377d9700bce59d1e41d19465abe97f1d649833e5cf191e40a608926edd7e29d3342c9d773199fa398c5df98c63c33b005bdda72e02a4d190935480c13bafa0e7d46d313dcfef7f8917b6547c3caaee472af968b457fd4a70f87eebd9694409c0aec9a77552f3a9c683845e6883b904934d305af4a4d6d4e7148d240ab0f5db87a56b8fcd0dd8ea50e9e838086e3c93b7d8a24de4fda448b6b368196f6402e5b2c13ef54841c0f57db9d2b9efc2208068b6f50727f0876ebf3faeb0b7a5c2e42a36832d31a43ef6dda0da18851aedf857a59a2e31dcd58bb9a2be5106254f6cd32e2568f6ed5192d0203211def6cffed2ee87d946a25605871237f4ac043625fa93db0405ab7368152f760ee41563c1e266ccc1c63dc960400f3b95a52b7b930b9234548f86cc9255193e77793b622c8f6f7b4fa43971a6c3a75ca408469f19955e2b952f7304dcf5d8e1a110fa47155efdac9fe45fc0970c63707089f02ad1310b6397e47eb1f09b8a667c3b031aa3257eacfba791ab5eab7ee664e9b3c43fcf024fc76c47ae077d252cc5381aa8925ddf8d5cf3e0628d1169dfb03299768f7025cb5682c9d937ee7a186c1c961405ba08d197fc0e544281dc8cee4c956fb4c63406ef69214c89650b76137858c8b009aaf75e3d42e45fc3ae2632c589d3d78659032fdc0cd0cbfd5528168e9790b4e5a72a1c8b984c203987eb765e38753c56b9c1d03d6367b4bd139016c2ed8879b78ade8f3cdb4a15b4d21c8cbdf28bf4f02621eb4972ef2fd8c79d696e99c963444cdcaf5537f4f52f55ce6e2a390600315f3818a4e5d841c2590fb465a3938834ddd6370dd754ddbea3626403622ac0b3dda73c09829cf14b6682883755cc493e060c4b18dd563336fa31974c7c8691d8e8963ddc9aeb9659c58d9b210d2698b3d55db4441fa61c9a968fa74f3754da6a0fa5392f50c5605f7c6745a729a1c43c7b152a9495fb6599cc6f81384216e4ecb14d651c7b6a296cb778c0dd9d99c66b70c5a3adcf9265d54b49c403039e28618687a0a3721611c2596aad16ffacd6125f27c7f3242dccc013ba36c9142490718476899e2b0a0558759ef098e02019b2e556ef1e7ee65ec7e8522f60e98c14c4d766851e91a43b182ecf37cb8169ac44659d0367aca88d2a7b2652dc9257691c7771529cbee7d876a24d8e88669611e6d8e8ac9709ac60b2cae24243d398b0deda8206009d7d90c5d0dcebc66917e8da7b5abdb6c91be12a920ca196e8e9f17a755c65e3e62a453674461a4c7f338f0980aedab38d1db1073a1833ea657a5035478326d89f1eae4dfc70732c1806406ac2157c691e3a4448845bbc632177fa4ad19e29c9fee1e3963303e8f7a9715944098e6f8c092fa50ca3bd934593b492440335a7f6ab49dad0f4958f32298a862d9e47fafad4d878000bb3891daf98bba3a835e196325f7b7c5456c8a2f2b5c758667b5cf6742803fbb5a23938eb74f61fdd0af5eb9dc093f5a7bb69f9e47b19bb59e73407c0d4a8015af67fc604336e69c055cd5276727ebc645ff23c65a740bcc1318c7d9660f69dd09fb1c6da43d090cd429d13f75b29c6a2522c80399ff6a549254abfc9243e2fe6b4d4a84512e761f1e633b4d5148ddafd3df48facefe69144605f5632139f69804df7e1dd07ce84597e9019e49200ab4211731a786e961b3d8542fe5b0c70a860068a9738bf0a8cca2723b614ae7475fb3eec59aca258d1040824ebe6ba2c568d38f2ce5d290659578324a25fd30c11469e584f0832d3f3375162887a00b6d78329cf16c177094d66a82173964e97369eea1cfde4a24a28ebc75087951f4bf36ca9c5f77a6a2bb687e43c2c870007d2cc7c0b40e823d2a792730cab675cc2fe113d557083c464b4c5fe8addb97c225c850436a923489e7da3754b35c0241fc53aa841b3504508084dfc58dc7e59fe15b65f26a261df83a91155247a2231dcc855509e0d705deeba7309710c9af0baa4248f99590cd7d1d5e65cdec74eb48961c07b1520f42bdb8446d3c34c2bed7a5345e8fb24078c560230a7b32265468a8e8be8d243140344ca8b9c4e072a6061f5a73ed8721459768a630e0e182122045b790476c2599f8f3a0c701dfa3384eebee45cde60aa06b584744077edfb4fb618f82d1e294cf454952bca74c3fd69a0487ea3f570e4509f84a90cf1571b071b63f5cbe0f5ad17577e91bf23345c02f1ac8271dbff91b8966997e49a02860ddd6250b1b16d2d4b7ede71f578ae53b7281743146300e1bbbf88d3bdce0a021a6b8ccebf316018693700cb81a732d9798e3ecf04ef98eb0f5fc5efb4c32626f548274055c1855be4936af8bc08721641e45dcdc9567c9c711e33a0411615990f660ab123fef3630619ff858278af71086ce626efb11485dfd004c4c79477d26c4a6ed3ad5b8587cdae2062019966d3bd072baf3e7c84e1e0adb3c6a07f1f9abd68405675544bb1d87edf0fcc59274caa031933171b92b4539fa4fbae004c5bb3598cb2562ac0bd4daa2ec5a32d4297e25a36402dad149edc4d60343d4eb7568a8051f03e67a26f5f4994a3f1bd57dbd4791500b4cef6e3b7a35ec9979b2c8477d334a6858f2b053d7784c762cdd22b41d98b0b58fdd2933a34e6051956be48922d0f0e5e3f26ae9281ff0a8c475feaa2b8fe62f77e033184ca31f16ebbeac30eec0c1a44c6d401a282d80515034c4d5e44c6cdc6a0e8246749cfb321c530451a64ab3ae487e47be2505873209c7eeb08e13b92dec4ae079d615eb910f3f31d99a36e7f3978be5484e8e8441688020f2997365de7de79f2a57bc90f1d350358d5a6aef3dae5276e590176861cc7d01773dfbaab06e3173f396e313a5677a6a8a4b109f2a78bd81a847ef3e9d624075bdb1cf9fd8b689d74ebd4b36ae3cfbc4b0c5ae8bed644e9a19904586c998657888b611f245efae46caf78db85560f720b5b281953ac9d305b945908ad356c9f61b1dbeef644dfa3b571b22988d8697cfd2ad7e59ac76854f9ebc8e7904bf8d9ca71132ac031d7094ca659c1a681c3585ee22e75ebcc54fcb5e1503dbac4aadb32103492eb6a0fef81d719b3dfa8443f2e44681abb924d6227101d9523d4171b73c2134d4edd2b568c23060ece48ba3d6f2958adc698af4f8b20ab4bd52ba8508d07b32bcebb8016168810cd4d722a9ea6b715710ea5db614be34bcc7ff1c90ba54c811c2e2df8fd379e20b25aca127fcc32241b185fe4a295382ce0330ac7e55672b4a54cc5e2b7d97cbf6acbd490a2c3931bae20c82911d653320350e1b85cfc24be76d7aa7fa4d4da07f3b5adbfe80a2766acd2ebf0f47e5351d344c5246b7fd49b0eb81e8026a45046090a3ce1736c888fc2328069618786c83f11fe35a7eef8d8d69d0d46c104d49b21249b7210a4bee609f1fc5cc24097238ad7ef9a0f9f8a028aa99038654180978df6406be0f60d40192cc25c949f1cc477721e6d7e608f1ce0f685a24ccce5df28223e99d802234d56901cf95c803fad0d9e330bd0997c4f2218de3616dea690d5513e1e706f13682ea57165fd05042ad4489e4e3da420c3549436bedd30ec3b2fcaed86a60c26a3ac548c4e41f9c1ae05ae425a2bbfd5994c44825cfb4b3b6812fdec95b4eeb04c70dc9bc63f28c5dbc84d3fcc52b7e454b892cc00f3f4debae2d006433f64d099c04279e1ead88fa17b72266298c3159c34f1cfd9f9a9281fe655fcb1c8ee02a400c2809b3b2f906244667567f43b7f9a372b39158c9d03ad0930bdd28cb00e61581331b967bc54daba3dae08d05b91d45049c2c0e0966e1c764ef2a95fe34f67812bf4e75882d64524adc78c7817451a4e7497e63860804c433ed9ec23d90f901c6124b5e1dc1a10e93148a234d799b69c126f3d3d5f7b91ada402519a3588974a9eade80fa8e7a288a162b464df3db3e55ec49faf4ad6a092981edb3ae7fcd244ecd174a7d0ba6e69216f06cf2c590dee7aa1e6d5326e221a04e89035f6e2fc80f44a6a380e05a379d573b4c15cf2a4a056c007acaaa1cce348a48a5157e81e0198788cd4ce4ec8f34ed1196db05b21957228ac042d233ee1c3fab42a8d0cefdc3d73c631ae557c72fa5c0037c3f078194141d664b4f34432eb62c1ca11b41708e3fa22aed2c0093e9ef18c6c416bca4cc1b7c388840d89dc44b2d23b77ae8239260a428b982e421b241473ccf34ba5dc04220e522e77622ce6857755c87a19ce6bd33e54b5765e6679c9373b85dfb417034bab1ea2674bf4a0202b619c2f45f9aa10214be57180f21cf03bff8f24d3daf3c2df9d18fd90d56bfb6b87dcf6a90d249866a2bba90b404f5914a79e81c538600b008e495a555321c51943ee577d4107f61bcf93e6eb3883fbbbc5e9c985446ef3e333045e521bd685f61044e8c41772753e749f6986c5b6a119a5dd1f8f365a0bc935ee9a7e44190de151556f1ff7b8d4a0a0cda3ce7bf22fd62b52f7be88ff61622932732cf41af11d8b3703ae3c2afe3bcca027108c5bba01c3189e30c0144770e633eb544a3b5774ea73c1d6afc743cbf34f4674e94978bfc6a8e46bc744d81380150d178cfe90d9e097357ac008adf5d36b0d430c0647b773ea0f978c44ec38f8e8488c51ff0a9bbdf2ad2d71fc70f7e73d8a7f9488870dd2661ec89fac9a5575682a52c96f18f43ecd8b0cad44fe634c8899d52d048d179cb2449914098d9ed723f6185671ccc06587d96a902b4b5c44b23b24c4cbee6e7be59e4901568faf5e5df25f969a5542ca16c524e731e2cb1824f70945898320ca9685b2acf8b27e5cc9c07aa0f7df1c93b3fbfee6908920d5d00279e9312ddc0181ca2714d3f04a5053f8ec90a20bde35273a6aa291268f2c5e8f5d500b4dc9e0d0240ed09398263ee9a9d2eb364f7939140e259df85c4bf135d1d66a76e0c2e811edd6bdd08a6d5c972e7466b9306d2352719c5dd68c8b14b63b269ede35226c4efa6f8f497b0ea7a7039fc0d6edca76cf7cb5aac6334a0430f8e558f0b872104310206ca67a61debbda0cb455ebe983ba4b75aae9e91b6ffba5d9282c96d427ef3b35c8ffe01349335e0d73e2798998417e940b807222f8732183ccca6077d4af0392978b433ce913b29fc430eaee6798a8a9fb870e4143657d13cd69e61afa832eb539598aa563c70a26ba2caab52544fb936b06db2e540652a385afc5c19ead4857ee64f2688b2ebb80d5c8d528333b46b43093525d0e6b9da3ee416ce09b8b3017029624a79989f9bc9432f230849574f8ac8e2386aa36762382f6363e80777b631e003d332acc6e1cd12abd9818b64ba130b3f216bd0ae37a6a3385c5d911b9ffa9b140a571cb23a1412f920afc58dd519c965863cab84732500f14dafb28cc821143d577ab18a20ea98bdb5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
