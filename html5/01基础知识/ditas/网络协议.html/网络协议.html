<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7de527bb28df70f3a1d497373f505f2820c8c591b377da582a2a63add5e99567e48a4ce4569808db963e0d147c6e04a787a47a2bcb15c07c31c2e1da946da6bb68590b7b2fb34a5af0e5e3c35fc9981599fde3874f3385c6cbc097b64e28dfb05b7c2e90dc96ecf9db5213e3e36638ddb1b366a733887ba7c210247e12bf4352a3c05c655744a9ea4fc1653f8929a8d27d14cffc97f9977ba81feb89e5b4fb4d1df8e73275e637c115bec5694b95918849a6ead8aef4a3a7e9bf698bf3c4c6bf470c2559b8de7209ddff7cfe7399432421ec8fe362aec74f2dc2f2bbf58d6cee0040c761b446ce01fd07e2d1e99eb47f578cb1e6fc88cce04f98ec301e8e4d7951663f630aaa423bed11024e4c61afa76e0f258850994bf5a5072577519fe9882559491f01fa7fc185b09a48f7d8e07aa1d3a3d86701899f959d5af1918cb78e07b973a8473596728bc7d28a5215808dc232424cb7328a249bff69056d2fd9e83a329c8a3450b966808dc4246ab23669b30b0496e025ffb1e0936a0cce4e132ec4ba3b2c53356aeb77fbd3329572cc0559662a86fc424cbe3f9159c1e1ea14c42cdd76c8e49861a0fd9adbb0cb129db76c3c36fa52eec2bc3c42c8ef533b91a849b8a8de6f7cbb64e8b25296dd439523cc7358528271fb74356d61a3d9183dc38f72a2ed10ba2553764ccd6c1408213736f7ccaf0d1bce6ccb15a370b5603b542382bbf46a2086ae7137674de1cf426b0f64f387172b5b54177b5af54a51e1e349dcc76d632036b8474bb7582b7eee0bc5576184c530cc8f4a50a50220f0ad4d99875746ae1fcb819706db41389090dea165670bff4fca1c0d5e7a527c0a5a441f1467672a58e71695e5493cd95a935643fd9507e5109dcbec838b7223855343327bc67fd70e102dbb843e90689794d819fb753e170fc2fe85b1f2314ce61c7629d278509004b6d65671a1ecc86a24baa6056b955ef33fa6d469f8f38c97a776e67a8fc9845eb7cdaff95c328ee5512878dbf704419a8009fbbfd8e73bd0ee7a4f730f3bf06784f7b11185a53fdfbccd31c3d173bbc8bd1cc4cd616030788f8688205d8aab2cd983484d6f0a8774292ec2a903d2276a99ce7a5f6ab06d3fcb2f2cdc481b2bce681a24b93ad90044bba25468c19da0d579415b860eb7e8e46fc8f7691f1d5e0219648fa8ebd36845ce0726a08eda69cb6a3e43edf7333fe60680f08a3939909ae9ff2a479e7908547483adcd867b9621ad39fe2231500e7e20e961c0340e3a88fc2fb73b14cbf2e153f13afe6bc3d49c77622dbb256492cfaeb8287300c7f27a9d3f46845d97e3d2772efed9e3fd56bb52751edcb348dd8cd5c708e1704711ed556e6d75c88a15945dff1201e4137034fad6fd42d6bf881433b247172ff7fec37e0087921edc3e090cb2119f716367ae26558d9d4ecaee85c87f4b2211690e8630db99a73381c5fa636cc59e253bd6a4db98dc4bb3c71c50b2edc76e07b120cac1e4ea5b76057956ee321e6dbb60b553583943cfd069cab6c473f8941bfe64bf647185c7c4d244d7cc2b50e81525ce4e1f5662851b43637e2e1db5bbf86a4b2f11b84eb2ef4da64f479388dddd75b4fa1ae4aca5a56414a25c12d810f967ce066b2ad1b19971e6b0f88baea76470e2b49b610238061eb6c561e6c0b500103944db7f4d206dc973c9fb2e9e99156d926c7b7fb138050e5a5ae97245ca50e18845579a810b1cfdd37748af4251c730e4d3c1c9c2bff684e2df22441092a516702a912170e972658c883208aa96ad0c25859ac033e0cff290f6f90ea8c58f9a41b186e8260201d906fe5e80a6c0cebdd4721b58bf3813529e66a3b2b4e5a95afd68105afd4ca69d3a9b5613c9d090be9bcff7ba984131cc929c0e0c83a7add1db81faac377cea30430065e4b918a2de8ee0a2fb5d50ce376d274a421b514d358185bfd842831923a2190efadd11c7b5e0d688f056eb918e599d50a7460c9ac3a7f262d29e1ef2c480b99d64aa61bcd013ad9227a4afa1a67ba8321c063e6411e7f7b03e9ce0e6c10f2405235f13b1ee1bb0bc886e54a2b5f4b4d139e54da64d8be9a3e68443dd1239f3f2d3a537964e217f5bfb60723fc4c830bff8529e7cc47fe05cd654bf54afe66e3a70024fb437d26bd2a64c33b1b75407e744cf35a82e6f41d31b7fc4275da00eb138fa159ba0334b7db4c42bb528016a539a37bf312aa125813f55d68c8bd999b9e13f99f21d27f4e4f29973fa029bdd6827ee20452642a891361f31aeae8fee9898601de4a57fc20ac90866897af893ffad41b1ca3b6b659034cc8955786b5d127dbd816c1c1388819056c9f7f5045dec99aacb2964ab93c8470cd98a3a6358833d54a1b2a0aa63df682ca283b67a504298d0633da36e5a4c5819eb7a019863a2abb082d5b767157e697e6926eca86dd27e8ba59c7600c78fdb855a818bee2519e91e97266200daac9bfa562ea7fb3a1514a63678c971325fa10b8be38eec24258f3d91ae8ce5fcbcc2c0dee810ad45745d279d5c6c89d73f7c3491858f1254c76e25e146ce85867ed082c1b443c5b2d8e54e4f9702bd3413e637d39e3187a6367e28be5c56e93aaa62ae79dc0f880aa968d85b27a173b1323a558929920472bb3e7a73222e6d621a81bc502b579faa3bcad2da4556b8b1ef58c7786471d40537f5ff8f54f6112b53d1f90ad6cf05e37f3ef8ae7e2d8e3fb3f31d8030b4520ff1e5ec12fb711393446231792113dfb1381f70b182446dde904c173d5af4a3af24dd546f4e1cbd6cbabba8d373fc8974a2b4907175add07ab5fb9a822074e4018039eefbd98d9e092667549f46701a94f7c4df3cc10a3da62dc6287eb704012866574703e52c2206be9a6f247e643db2a56bf35adf52ce9b680319c4650d533bd07a21bd8c79784dc6a6a1daca3ab08f117fe9fc4a4c78a65602575ab5865de486f721cd00670d3c3fc2b1fbe225b1b555296591fe33eba53f0e3a532c768a6919dc438c336fc760e9db9fbd6cc454bc79b43cd34584e2e3dbcb2b14fa2c18c7a9c11fb47666eb1057e760f3e8930a6bd69aea1bc60be697329c354e59f2e438d06c100246932eaa4e3189dbe5dd63da3410c80b36b576a78870293084628f121b98c2fd2259f3b6a45ae142afb0b6f989edfda5865f975049e85dde5ce2f85f394e77a6466eefe2ccd6ce817d09df6df1fbea062b096805019e24073340d809e619763b63ead88fb4a0d54571615d8907925df45a7d07147833945b2f2ff6327fa1291b445eab0daeab1ae702853f9c1e8c8f1629d20377bc7e64d40cce33c6524d2800a57d757bf457b05a50a7e55b171411cd9a7558451d6524be52b9b645aa3c7186223a8c8441c9bb6e955f870d9431b5344cf50f3061e87b9c698b72467bed2fb2fed98b265b84a3a6868fabddb4409e276da8ec72b749b2db702fa08be1fe6f5f6c0fde67f3b5a42476ea7527b6597c298c0998f0a2ebbbff63df1f5e2f35bb33f349824a77b1f1f5ab3cf53dd7a29596e9a6a983aad99b3ac03d33364aaa54ff66a5c92bfee96229ddbdf85db1f7cfb74e40191d1ddb40606491b8b00af9be1f998fd92830a74b050870689207a39dab7507cc6d7f006305c886c718935c7a87caf9f8f5fd4d303bebc06b0340f9379267ca6d9be5c9221e5716a80ffdc1b34a9e9606197b37e9101f074ca4ceb7a01c880c3e83853ffb7f453082e9bb0a2bb38bf025ebdad8f19ab834fe6726802eb383f968262c06fba037338d338fc26bf239746969d5f23fcde4c916ba4051d875e106f4120dbe7ffd1f22ca0466150a66aa038761e68c34dca377e8166115ef0a7a6fffa2a257589637edc20f23cc9f4bcff2ed248590c26e154a9139bf1d0eb460989ba44a4a1099af79e25dc6af28ded130ebdb4b9cbdb2c09c5400bbd5be3be06749b34b5ce388dbf9b23968758557de0de4734847d382e87c100be819ea3ff7adcee584611db36f0652b47d5d21ae80c1dbc1009f7f19a208212e5220ff5028f18156950a4f06632cd3575e334e776805acd424db460e84098bd165b9fd4f8a78d0d26b7fdb2012d0974f2046adbadad1f956a7c53a40dd2197c5bb515b2e0297aaba45d50ced9156f585e9be83d6f0bfaa785fd87488ffc2189806271b41641df6a55919dc05b4bf927e9a89a89fce1d42590d908b5c09478528d630790640a481846c0494bb89281265c17ecf301e0839d114b0d4dd4ebc458736437e481b12a8f209568e4dcb6756793880031e6e373c1350f8ca1d189f6fbc99db5cbd876aeca43eca188c6ab841f0f2f46f750af2661fb24152c340edd1c73100bab0a69ebc58ae907e327fbd5ae44c3713c3f922eb1e797949e3e55002540c77477d37df6464b083e62ba0d1e9feaeb2b5bda72f4c0a1e2ae837691f67a6651387649759d173858823ef878ef94e224b5a5f175a6f3a84acfe725174a9d45185d1f4fd7155078812e08a934d40f4becf28a40f2451c2184fbd01914417f34a00f6b89d0f40cf533b5513f7e063148a5d18b2b346dc5939742182fec9db5aa3a705e38a6989886e153d1eb06186bcbf46dc049078334800dac984f5e4db702cd757103b8cda7d51df057331228e96361a8c991958a841829153daf68a82589016b00607444734cb0ea7889a57b64608de4313fdd75759d248dedd7c05368e419303c06131d65231bdde32afdf502e9f8c9fb3f7d6479f7066ebd125aa96fcabcadff849478fb312490f4cc5cb3109d4d63fce6237d8ba1509977c696e108cf21c836444e12151f4264cfdc61f78631eca7e2d2ff6a81ec1dc2e3a4d847260955b75bc312709969b4491b5b2cf00ff48a6b7cf6ff07350abbce0da8d524309750e161fff73c5218a1aa3ac5ac1698ed5a62f45b5af6b0acf4ac830bbbb0a67c5ad31bbd6e8419d99b811a291b1b3e28ed6a8b21567212d7bc93f72e40c9f580b1098a88bd4fe482377bf3d5ac72d76906b1171b735e38dd3c197bbeee6dda0bac0d684b7b528a10ddd59b88e0228db0d687670e5802b94ff8b13311b3341908fbec42f8fa37b96c41629643d9800cada7016838deebc664379cccefa2aa2c81af235abd49ec0db3fde61113a02a2fca2b440864f8cb4cb2be3afe4fd79273fdadce7a4a76e7b90130d3edc17aa26d4f3e02d7835c01ca82ec378cc37054c21d499f899d871438d42f2f0b47b51efd5bf5ab0aa2dbe1f0b105a5925320d118491234637683586b84b510f0d74112b48606210c86aa06db52775ba4be7e607abe40429f588237c080a16543de7972d7ece934ba823f67e5fa4e2d113899cf3b9139df2a6a6992ea2391405aded9e184fee9ebf82efd07ea255495a0ede3606db10ad16a82d90ccada2de7a4bb6ee503baaa671a082ba2911e590fd6783a75bd1e4446da2ea6fc6719278b96e62ca341bee5922e5164c06534885028e34699c7f84721d328aa8340df65cd7f4e8522d32cf1ead006a8aeb14f64a250c4d3fb72425137ab582ab9ad56b4eafca6437c1624902a1b30b8f6ab2c8970bacef0b59fffd3dd0a7ca740eab011efe66372f5afa0c05eea95ca97e035c6133157d272566824dc26eeb8cb799d5cdc9b1a934305a883687b63a8039533a9e6a2e078de65ac7e455d8d33b32f6365bb74827becc128939d3401254bc2d57df2e4f1b4c7548f31a732d9981c40c214a145acf8d981ffc5fa5da7c183442eae5c78e8fb48dc71f857e3ad9ced28b80dce148e954b7d95aa694bcb95d9f7fda6dbb16cf2c48cb3d2f0f50b78684194c9b8f0c19bd6f76b377c87338d5e762186b1acc01cac5a788c7e89ff0cda2fae54340f12f05a3582fb9d8b8049bdfc60ac8cbd7cc92fc522d8ce2eed0c737eb75a682e3253872589ec6bad0127c359d85951554add3d744b6fce1af546c45f8d698355eb6e78d43bdccdc946839b1b55d48553846c97e6739d4116d92e86ee995a97dd085207fb5d78ba3297a5837034eaa5f9cce5833fe76118fc0616deba6ea5d53d5a94e9dcdc41863d677aad1e437f9a7a939a2f384424103b4266129310849ab1cb7934e11d3e060177c969122c7de92543e1b44a0be4808b32fbed5d78c54db7ff8c7f9c5b44f26eb7bdb4da0566fb9d160b605c9bcbd2475aa83c5fb6cc472b513644f0cf7b26c0d8a8ac00b2e66a297ddfd1698f9377dee539590622fee778d7e12805f3e682ce0c864287152bb25a9379bb43a8f5d023b466dcbe2194b140ec06ebf71da3e41b5e2ba1799ffd59f9d4cdca45db2076ab4af05d84f99151cad0f59c4c652d534a350800dac5490a8a2d0c0899068c90bf3a2ebf78e4aeeb4075163c03ea59cd435c50a52939ba7121555f26743b0d967e46f1d15812d6d0fed77c4d2d6a5fe16e59d3d9e8991e3d6e3ec19c0b932d9b5085a8cd7ada9ab25c1d5f8ea83febead7a0a4f8498823818d9f11c55a9d9b53bb56b6ab9402347e3a01bb2b1f38d93dd4d0ca52f0e4ee89148c5ff9f33e63a03ff18bbfbd354485820acaf4be5db7d3207a75aeb80d5eeb429f6f4b3d57449a8e2be59f70aa81b8fdcfcb8772c241770d21f863645711a09618d7fd9e2c3fc9b6f11bc4f79466f22fadf9c5a4c11e8fe13720ef8f5c68dc0543b06f20df54937695bd0e32c6999f023a5aa9e4aec1360e08e7999e7231365df5a20434b9a39bd3c58b1953c5092e1e0c8c2934708361b6b83dc9a2629966ad5e3bf4a4e9b871cee7fc768f20192ae2f309ec8ec13a2fefd77826ff25afa4c58e1eb8668b5da1fb9233230a92269bec33a1b494e167bb44cc257ecef71895f800cbe22e9c84821bbb1cbfa256051d442f951528ccb2b5a095dcc30ae0d71129a99d4e5a4e8072feee4bb667683431527696d13140872f85321fcdd8b6a37714dbf1018f2dadeede18d9773a8a380112bc783ee2023d8955847a302222f233bddc749b902d09cd6c26cedd00a96335699fd531572613116792d06762d67d2694064164094606f1b8fe24d89a7f9d69669d9dbbfc6a039c204343db5a8c7aa1a12f75a5c3f0a27bc6eff9f5c54a11aa236f37fb1d7f99477f9d8b4ac67e48da469f10d3424d8217c556035ad260acc597de685397f68f9ab045912d57ee301871f424fde7ecb98b72bf59a8f3f84fbf548765ba5e43400232bad477f45340bb5a7b800d776022a91654235ff30b74d47b459701230c856a6e96fbea135d1cc2e14f0cb5709133b23962c5acc524f798d760280f08814127997701de7a9b18d16d8f888d9d308d5858922b68c7641022376f8d71160b24ff896171c426138c3cc8ca18b247b00a25810c522c6b67cc3bf05c5d9fc9066aa48b12d97babea9f918e16cb22f4851819d6429554f65e0a7997dfd9048b384a668f938f2898f5678644ca512504f1c8ea56111c4eddaeccbf135285ba9d3ef4be1586ccea6027a92a9c505e6e4fafe05529f639e399147db5eab4043e815c8bd8c72cc167035a97feb40e6f1a9588b5f28233a8e2c7b982701832e5f851edb36f8e81767b371f15b17788effb8fd2cf43a5499229e079d2870457fcd5ceec4733e744d44ae34d2c6689588aaff253ea196e6b371955f1af7bbdad731842e9d7b4d64777d3a465e90c508bcd3dda8207234c79745300c12a0104321272fdfff3e04c1e15f2ab766683c31f6eed6bb47b9eb2c07cd8dc8767488c79c87c04dbd5fedfeead62fbb73fee55f8d3e44cdc2c7e07d7fa4f31a4238a832e11181fb1203865e4e475752c67cf5b1e4c917d2bcc78d19605d911cb5ed16e74c99ca8e58867c86c92e6c2258fb0bb9bb343e7839ab4fb6236e9d0c35f95660be3f81391cee07c65c280116b43c3cbefba94108ab10a43950aef65cca58cff1a240e035038aa69850cd5c255f523659cc734fcac328df1727ddb4cf4ce9a035cf2ca83a5126c0c975dbebf70ad3b19d81f2ee2258a73a7c545d7b25d46edf3865897d6ab95565d9bf0eab1dd510e8d1794fb43c1c44b1f1b8dbbdaa8d24174efa8f2406822b9ba161797771248e3938b002bc24768591ac392531cbaa975a3d8f78420e23285faebf59552f43234a8ebf49ea1d129953e554337ab9f95f441f6d8c1bb0cf39996a2ae3f1d872ba1947fe06e069ff512e35bac3f4ff53071180050f1eabc93d01f20b47f88ee2952e6ed844b41c3b9f7834e112ce850fbd10f6694545b7da32b84648cc3feb663a8dcb179dd5da33db581662acff1ec696658969ce162f0da8d4889a342631a587b17ce1c777772d18a452582309c2b7dea150cd48eb2a34d3f5041886388f6669209e39cf774c107f1fb586509c3c52c2d23a4ee099ab2a688c7d78a89fb80cd61c8f3de1fd6db67d7c6e74fcb35e7a4fd6062c9a40be04cab0e891b2bf11b4d4de71a19443c425515a4454290e5ade68ffe1b8eb15abcd27f427bd4aa5fcbb05f911eaced1f0603d3bea60c966290d8fba7b7b7d232bbedda9ecda54fac7cfa8d23ba253e49b60782af092805923564ef50062b050140a67773de83dfaa1ffae26ab71057fbe416c5d9449445d1bef667e5ad92f065cd958ab159c45cee6f9337f2064eb99e9b3eb21eb7dfa16ff801a16d0e76ab072631c256ab1f05dd8eddf5daa6e694fe8aa77a14869d51b24230f06aca5f6f57f0623cc8749f704f4f06b5c9b154773c5f3db5975c74f526f466e22a21a09ab0b739d73caa9c4c2cd32f4f4a4b0cd8842020fbb1a6ecac669dbc4923af6c7b67446ed6bbc16d04e64e6bb9f8815a52c8b02536a3844ad27db273c718c34986a238316f3f3fab5348f7a659c41aa9b963e64d1a660f06a183373158731c3d340044ac0ee1d8553c10da590a0daf6b7f8a04678138f1236febfe3e8afb9252c5e3dc9eb06d399e230dcc029908ce55ec52270ef07243a4a1e057eb200acfb8132bfa220da105fc11b57121095a62bac9ea9178171dd15738532308ca2e5de0a9653068e7a7cec1605fc9e550f09f8a645959c719690bd9d47b220ad29e196f12e81516401bb6b8af23106abb84fef40f32a08f2893d23cc433b1b18b761980baf7ae3c4742c769cd731c94e15d9a1ea27a47136739500e05930584b051f896d2d14e83de2d27abb018d46fcdcc224c1b43dd538b349950bc694c8ba2e634209b7e05cc0a1b3bcd033348bfa96a0ebf186637fa28affcd6ac969e504372cbc5016d7da7d1ee320babc27c5bf45e01c86461a42d923b587f0cad2fcb9384f078fcba2da2dd979142b50ed209e73e0e28542306a6e1285d7777f932a9c9ef51a7e7d7b92e7a8cc4d42bbd31ac8ffaf68b173cad25893a95fbca6ed4b7f6b6fbe81ed12b8b69e2845daff0598de5a27e9994bf1865656ef09c19a5e061dd677fe1047be559429fbe96d2359df445616256857e8b2a7faf09c634632a7d74f0ed0e4c6801d61c51a9e667a40b5410d5021970a76104810c6d6c49bca50f7423ec01e54930337da11895ac31e45a5f44318170fd17a8791f81411fab5730c603a89d57213beb0d19e106c0b89fc2462347ba1bfc80e32a06032a6c825a9672b94242ca53520c81463d5bcce61eb4edbe4f64150eeca9466d39cb2831c9a6299b7eafbb1f1b1bdda6441c1001489d004526f77f4f7db6e0a9a9481d23e90442d36822ee7bdf5ce66efcf2556239e362f33cafe3301212b83c91c19cae7f57688012ef1f4e3ba6cbd4c5482f9af3efcafe9758e10323f2c12e085382dd88b2149daffa87d2f290bfe8894ce0f28104c3e972b8d2f3314b2a173d41f6312c575397ed501ede9d22a8f40993979d4d5cc95f9181db2e1456482e3cf68061eeebb7d1a5b009d521567579112e77375ac8d454fcd739a130773e64d0f5a0c02459b880eb362a1a7cef4de8ff0daaefea0333d327ba2f222d94f5ec9544cad9f778f682fadfdf34f7aa767b806ed6242e12bd61b1632480f0b4ed54041a86f885667c515b419b85dbf2fe68179fc18cbcd554d47fde83172d88c512943f95d4ac2932da13e76d10cde8cc09a12a0700949fdae6a2ff85c2b4b6b2bd13698a85617667c54acc0670f84db8cf010782b867d7b959a936eb474fb3124b2c9ba93b961b7505452a62aaff19fde39b0a75dad14059ef28001baf2b37c3d02398022c26d0898f323f125b7dbb35ff73f201effa994239e2ccb88d14dd9b7e25f15a282de7a14424607c6f52957467d871508fdf97823e28dbc10216605e9799c500322cf05c691fd8c65d8a6a53e961eb9fc73abacdcfb49fb87d65456beec110d6bff950c05a10f3fb2511ab1489334ed617e04d7c9af5a9fe97b515e3a4c3353492256c236f2dd89af4a196a2726204aa14db4407cac7acd1bd7ea21e95b1a32b7a849442f7fb182f8b2c399e95f4186b833359f9f4a10572f6f2cd2b81798da63ba56e31169ed9d3a35c883974741de045d7385022f499e93e133e8335f322f384f0f2dd21ecadb60f7681cc57c71cbe74c164c9d200dbf327914158b87c9966cb59d8648a6013010d896cf97b13291f5d988db774aab46c679529c1b2533751e4bc9aaf9405acc3aa5ee30774eadbffd0767ba0bd1552b8950d5b246c54546f2adb3770f8460c4a87e66fad51b6c61f6b63d0adecebe14354d6cb2d68f4fd5ae687f758414c2074d230dadd815d464150937aed9975df9acf2f81f3822113752d08da2b6559dc6e225f366636f7573499cb8c8d4d5eb0a70cdaa965161553e2fb6d44f6144043c397523026bc1299402305fe1811c03dcf2bb6140f31127d31e305d566bc2a1c8cb95eec130312877969ef5819cc73e69352c927ca4d87ce76bca3498827a149a156507162deeee4664245cd282554e8fd52b3ccb24263d90fa2f4dc81d8c594e07d4f690a9a7a44fd627255131f7775186a1a829b7a0113e3766401dbf7752fd86f87231a8f06f157e0839931cd91d830071849e115730c78ae0d208522872243696b7606767600f7a209883d2d851f40291dedcb6a258d35bbdf9da8a6fc2cb1e2347c068b30f9b1d7b760a4000bbef712216731c4c24adde3c00df13422499ab386546576b3e61fbe7b50ac1ab3e52b6e30fcbba7529634f61c3a56839cd1a6768e66591f5d521bfe40cac5ff6d358c55b383aa6a1567eadebade3d5f5450e6bdcec978b268d9853dc79e7aa96482b2bca18533d9926c744262ee6ba3d669e836d3558cd5e9ea1d17fadfb93095f0dca076840366329bd3b77d2093a7a75664a83baca48cc95151fcdfffb96a3ed03ad6aeb9df066726e9d9927934d5bacebc84b6082052ea938ecedfa4c269147c292a17dbd44e8765d448e810cddbf3504110df282c0f3d9b027c3a429c871f9d7b29006412464f482c19e9c776babb5882452e18ea77c9fa45bf24ec440d6c0ab5fb302528ab0f88d41cd8681a4691a92e9344ff992ccd45f13b274a4c7474706e793a04fc1afb0e17da62c3f37de35249dc37a4f84e243e38465736c931195ee4fba84095e17f4d9079570e20a2dea97aa8b2192bc497ec01227462af1b97a1e2a6dc7d59076354e2b061cbb76cf3417dbf026c97fd28bb028176f2eaa30f969695362122d6d97078c22ea651df9026305ee6e36e67ee86d5bb7fbe0fccaaa73c4d1337edac47b0e7916cebb0e00feb7ebf048c23fc2fffd8255afaece15434acdcff093180f94b7df2d1697c645980946b2256648e7ad6763e7e0329375295a145900f652578153ddc7c7d8b57607fb99fcc01c0a1e9a6a3494f83d4fee6c49b5047a8dac5a88d3a9e372764df2f7007275c58067c167eb24d82ec3e34fc56bc1456f3e03ee65f4f46feffdba20c5485aa3f59329ee17adc5c83ffa4a1d9d354e4845469c6ed7beec55cbde214b4900486341bdf9510b34b55776fb03aff5bcf4698eeddc448a69cfe3cb6cc4f268b02b8797178d236c92132fa2f6d54c130d8eb0a417860e349e849a3b008e3e2a290def2993833b673c8c077fd782c82d44de03ffdd7f047e700a1a1291932597b06995b9e717c08a7ae71103ff3f82adedabac8dc321c03f67214b01f9f65c1ef46030be443e0cd523a77ae6e881f25230934f4ca46a866b71f190761e0c19d2519410164630c077902b3f8b1cf2117ff3a73d5950a193a9f2996e5634fb4da8f26c5bd2569de6f32dd5f98b743628f6bd7b705d279829cd1ad013af94c166b5acc284e30b79f9a6046836e087ba6485c3a8250e491328e4daab996af65574b4e111ffc9eece13bc3dda5d33b3190cf663d345d070fb298e84624c0556d2edcc572ab0ff7f3e27cc97629795dde58dd5d4da027d4d52465759ad002b66d5735610425aa9c15f38325a486de4ce3302ea288dea34dce3a7dd04fe70c2d20eae2c7a30152f7f9ddcdf6edb6c75513c1716e25f56b48baba981d3f9b715620fea2a1201e3c2623d8d00ff4c3332477974daaa3c6730fccbc1e5ca7b5617a4af5ac2c5dcf46dbd4100f508f4839f2cf80c67fac9f08ce7125b3948b905a91a9a6e5dfa5d409011dbdffbaa2edd79ba2b59415b29b50044f9fb3a212dd2c6ef3e095117e71165b696fc01c9aad74ec9090c5b76347eeb7b7ef5f33496ce3f5fc3002e317cfb85e209e4f99867babdcf9d6aa88e70f368b2d127ffc12897fbaa559ff5af4ecc39a64d55af1eaf43a8ba6a6c3d52d06fae0d20d5e181f9d85866d21c85b3d3d33b1faf21b2b4dcb2133ccb276efc2205b010e5f3097b87ec8fdf94f1162ec45c987cf7b0ddf07edd9e7f66d201cc8466516d757908744806a6c8f79b446e583510433ecb0b50b90edd5eec8c0a90ca040adb6aade2a175fa07ec6ab7c10c020f387d2e9aff9b0387c9abc96e42125b59faa0375575a71653a9f1f2c44ddaf39cc0340bc0184dabdfa3f21a889b3fa43f5168c24d2b8e5d797534f59e80ba5394e7ac03310db58f8b011a3b62a38b7a3f6b0ad3608a81400bded0b619f02402821734d5bc9d96621b8934a4b8599cc397627c62fc77f289bb856c71235b0e59f8adf55acea656b6efe914b332bf9602dac04ee670cb0594fcd287dda184dbd570cfdd3496c99fb95d56434d7ba1df4fcee2d764df815e08cf9ecfb7981ff7f6c311dd0c2665fda865eb685626a4f9f2ab476a7705b94089d2cef0331f0ea32a916f7ffd123abad55d899ff496ad63ba964a547e21964bd4c1b9e1cbdbb3579226d458576c6a4bd40cc0c19cc3d2e3a70906fec1898fe5af736d5562013139fc870be05586b81fcdfeaf00df964ec756299c0add274be3c8d5916d19ceb763f744cbe74cf818b91cc744934df3b5b4e63c914ee0766e2c4b142c3801647d6e6bbfb034a4a73caca24045640b2fe65a40da9ffdd7c5a562c60813227f9bdae2d994efbdb66ea63c473ee3b1bb24fb67c685c1baf5d66ce3a9652ab48e163a8f68ae4654b89a20eafca10f65d02ad0e8a306c85e1f4c07c5a021c34c7ea0f1bd6a34f90441ae4f4e3f3e80c358663a01d6226aaeac2aa922a51ebe1050ab7c3bc0d79e5f3df81d80a5faa040d90ec02f409b5abe608f0e9f76ad1c58f644240928a02fc9114816b5a0243e2ed09bcbac6d936b7fe08a270b99a65b2957fd424e41fb482b405268620b02bf74f1b543eef4f6cc4fd58c9062be23e50d5c085518ab89d445427e6e3f121125734347672acfc1740fcb64cb3e9ebef410e64d5363889206888ada5a07e37dea66788a9b826f4b089bd286dc8a7b5ff488e2d8b027e9585f6f74f8bf6016cc64c738b1fba9d8f20f4b064d6a9aa05b71c682711a497d353053a484cf4996bf964d72f54b5e34d0b46776b6e48250b1c46986c460add79fcd061fe8e3f977a6e45b34f444edbe9c3a633dc53029db8d22165bf29a3e06519c255155c8a5695740bcfa84666c43f43195ae65d65b778e3b6707d384fb9fcdc84111be2f3af0f4e2700b182c9aef52eb3c6028dd089cb109015fbc1e038b555abc2bab3e4a8b81d552bb404e249d636481d3f2a456848ad05f196dd7ad43f04e80abd41260854d0e025a06c5d4b9e0035e93a6d288442cd5cb7ec96a060411795b2f3896935f46920df082747d8723892ef705180900a2e0f22d23e2b7d93ecf8a191483205a475fd3694f130f4dd2285c37e5d3fd2a4da2c6a4078df0dfe61f85ccd35a3d8b2a4ae98291a59a1bce58fd5690351ced90fa5f7c2c7cbeb81dfb73d6eb995656233e1f2dbae0f8674085bd0f3dc229271aa664c9b9461531719cd178a9a5fd7a84ad60ebfde991ef7f3aaed40b7e24b49a17990af294748a7de0ce49d51e14678f7531d5fccfce12d1209838ac5c7511f38325f86f16177a7b867339e7cb3e6205c134b53981206cbb112c104ee0b0362659bbb3b7cc4fc999f94ce23d9851831af9ad26490ea8fff8bad7b12dc48f5c1d788c842e957b1a95640f8e082f2f804df89e2cd25354ca3e67b3524e0401e599dcf3782d41db6e533078f72df1f261b2e1e24d79b8b6f700ef0a70c8b5ddbf3fac0ea06aeb711546e7a9b217b67240c18418e1c6118fba57921291e77bf8cc810ba39fee11a6d1b4b93c9c2703ac200ea0cf2e34717c50b2ea28d308f27b23e816ba64372eaacb0e690d12be65e94ad56f2f97edea3ce46ce7ea97be59f1513a2f38aece3e79628663f53118be76ed7a5fc035c0dfde4dffb3f7545e7ea243da20977c7d4f0b7bdfe7e56fa59bf2e67e2409116bb12b53557a1de0227e482c7d64728ba5bc66a98a16340e74b297836835c32df760a827c56560af81787358a83e31d8256789359e21764125074d9a51858795ba728c79e6dba894156871edf3b2678b1751b01409e2d837779b18c1049481ff0d3c5de515e2074b8f4a00aa4e4d96dbca4514079211942ff34a49e734d10d5875f0a26648e6ae61cbcac9e4283b4aba546e1533c4f187b23871f525bb044d1aeec6d1f257381fafa6c923601a3c7514f7c5a53ceada991b2cd65018e9f4ec51dd53612155a947268e310c9d82a98d472097d36712afa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
