<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1cc728e1c999dd58c3bdedfd6fb26390fd2c809e6dd1186375865ade684bb403070aa1e57fd20335daff22a7aca45c86741aa2114a2a441e61439175962ff24ae72dd9669101a5879d58b303f1ccd63781ee0b6a72ad63a732e0db27731c754534d5201aaea11b07fc75e4a173666f78cc07e1e490ed2094c211f894500722566bae39a64fffa45a0074463e1764bcf3de7c35ac1289589e5ffe94bfeea944373135ff17fa229f48206bbba841ffa2c1843673967ba32fcd15d9974ae6419dcb70a51acbe1c4cd47bbcc31242fcde04232c0952e6aa68a8acf9df5c170dc64a8666581acadca5fd08dc5e3edec76b83063c31830169eb4870632938e9480709f20536d23a28f8fc3fefc1687b67d0b64edf07761bff7727fac7c51c0839187ef81e6bfd336a0893e86f702890d3d2cdf74fe82359c0afe843e50a655cfb752aa04efeb0bf1b5a19f11eea16c806861377eb3ac75045be453710a917bc983cfe038c939fe2ea1035c023544186a68e7655f4e0db8d5a53e00c2e44db85e12014abd1496f0adc6b268df518e0d804ffc58d77b19dcae3e7495ed6cbddcde0cb238c3b4ee703bf9b00b27017ac9745cb845474a4a2548413967b7e9a5f163d430f17c1e0bcb6b8b38cc007262521c99283652f8bb606e873dbf4103f8ef3e06f7da4badf1e117ba5572d3ba6d02275692e37c3bc0ff02aa62622393a0e7b23507b0e5a55c1bea21e654f99fec38581c91f9e157b04ebb069604f7914dbe98db7b64000d99accf7eea5afc49d788e7eb13749cdd96ce336115c03544e0644d63ca352f5e0101219e91678bf3963111ef1059d4fd5e6ef95d099a96fdb80e45d865dfc6349c5070ce399313a230f6b95f07bc3821a31a6de8fe24905b28e64bed494b6f6c397779d33907d2b5dc3eb8063d70ad362ab6e58661803b4a72f52111b66495450dbe51d7a37bd8588bc64441425b82c98528610adae1fe80db8a2a594c645c772e74b3c4b24ba4858b4b020a2eb89841508ae5a087a2fb5896c3ba7799a5c8018f718c8c43ba20597c9d2e27ceb9fcbd5943e9e387d6a53c34df196e69f76b5325e4338a4bbbeac7dc58c0ed8a0335a57cd23b1a3f2f644c870722f5d20d61a092f5d0893ab82548aa40a01024657bbf1018b8daa22c63eb273be5a3ccd7c33535b6341c531f5b7e5b89f5a969e090af26d558741b530d6f46541676feab47d7f93fda06ae528996a31eb3900e5d8a17bc3eda57f9d1cf23b578f1780effad632d4de1c5b7fbdac6a2731686ab29ea2e0b2125a568d1842fa511fb09d02c5548251e6c2d67920940152c7d2db776408179157b7d234ca3dec44ced109341760c52fd2e7ec69d696a3c693826a21159e2460f90baab2aab4478deb18dfe0f67012744392f670fac6a5e22a4dacd6bc243fee287a28850f339cd6f69db6f35592fb9d84b2ffef5618fb27c9dc14f5cc0dc62873a7f37e2336c2022db3d98374e76e418d5ac7081d9cb05a335c50875ec88002af8807b50aa6b9594aefe2ba8a0b8b1dd5ec0183c5994556bbe4a97a3cca13422b03a24367f408c7d827bb43f77d9711abea4fe0d68dde4bbfe08e2be233a1b8335c30bf764271fc918a967267318b57ba96916d2448db5e89934e952909fc23493c666edf0c3670581504549d4976970cc7b13776738e1097b017df51c50b568b42af052b0de9b40fed778bd0137df9e823bb3c8e9f90f693fc3db275dc93efaab6bc0b96f1ba33177a49b3e10be49597d2f850033fa0edc173e93ebd8c27cc6b4e59b8dc6ba2217ab4d26597c2c111eec19ee84216de229f0fc241fa9078c1c6c0363e47773b395b7cd2a34dd03e3bed340115fbef44283a02f7f0f4505f356cfc33db833e5732ae46b37bbb5d833b7c4315c918bfdea7ff4ce0e43536c05149fa779907f237c41b88e6d457d8657b342ab669d01f80138c0457e30defd2146c8fc51ebcd1b8f6be0de3e2c789a30eb8500a916ea08d56330b7627b77cc04d11a33b02b1f6ea5db613038fed607f03d85821f3b06a649d7ecfe53661c19e8f2f999c4ded7e05ca7d64f1791531fefd811fc25386be9ef2a967209f81c0325c76ccf84cc99c7f0dd7c092fd3bef16a2874221d49afb72c26a39addfaac8ca163e65f7f7178cb759be022e575aba88ec38d30ce2b285fc2d751081587a95b5a70821bf87b772bed03a4cd4d8b9b5ff84fdd9f581700602d00cca017f02056c9a62b4dcf22f385704245b427dfacf7c41d06e5b851d3017a6d6b4ef9de869a7168079eaaae8838cb7219218ac74a1a46e74ab522311aafca06bcce8937888dd93ac6f80f9562b41303469847135dcc1193530eafa1e8f3565694e3dca67c99c9fec8176a4d3e2d420266d5d343444d5eb870891ff790d48feb7aa8e640a8619d2dc487d2d45cbe8de202ab4e21c6b5b60ace0cbbd0321ea8e606d4bfb650047ebf03eb35ad56d4257339a67f52e496f66f4aede036aa9a3c4cc832cc8437d009ad349e5e82664744d3bf6c54a7734e604f95202060110e15a2771f850c3c8c57467fb2a7cb8358cbbc27e13fea64e7d7ae79446e4aa85bd296627e24f86bc0139d80f39d4731c9de30fad1d409cb50636c8c650938110c086378328be3485548b68c686ee8ef3f80a87b18b59181f7b7a035bbd97eb07eb2d6912dc2a4ab359b3159ffdb6213b31f122a05d1665636f285e6701697f83755e2c156ada45c3601a678f3afbf63e974e4a7b30110fd3c06eeca8debb3aa5581c36d62c3eaef198a5214fcfcaf50c61ca710b5cf4d79605be024a3d7be022535f82f652c74da1170e22771f4a755ba6dea8b93780ec1558a335c4c9ab1a2ba54b37889e3e7633e7c3f810111f5c308a14b3f2f68f49347165e38c3a91bc461dc62532cffca233376389cb2967fda3c0003eea88b1f96d30cc4eea85cbe87b6df7765f52a5daaf7eea2faf48e9df2bad3f2d92ae8d3e35fed792e9c694d1f967741a671525a015bfff689eef8ef8aed1bb75400be6cd7ee85ec940eb4db7aa3d1dda49db990937ea6a299d3d7ef32523fa38ba06e4d80d246edc25774475d5c7439c4095c77422d6f86b8ea3ddf9b2b70750a51374bb4c46379a0f2e2c85bf405d0cafc046571f2e4422bd25feda5fca7980e4a20b1098d7ca26dfc6170c7be2b99cd29a6c6946629ca1371ef7977f944858c04300273cd11deb553cd2b52014ae998e948ea4e60aec54fcc5fb63b8093ac8c3466c679246a85e7c12cf3f383c4a899307fe46999e3f466921b7546ed65abdddf6dc3b39346f9c0977c5a6f65a7e371e0a9ccb63b3dfef6bc4c2a493725c4540a5f0769a4fae47ae10dca81777ff90abaace1523dad73689163910ecfacca0a2abe94cf8d25c4009a642296f2187e09a233e9cdea34ecb8273fb31ed82f34eb4f04b6be0a0152bda16f8be76a2e360e5248ad3734127bc7c9d2279c4f02567fad4652521d6ba552d1f1de69d91ffcf370b40768fb35f1702883b201a86486b4493e5c6699d335dcfa7935fbed1733104a072b0e4b3003307595b5fd11db986778c8883027dbc2f6eefe6b8f3a19586a5fad0d2f87bad7d7cccec7b707c12b1548bfdfcdf72c5e139117f3c66eb8ca764c16af96257ab3decae612a2d6e27fbe79cd9e329876a42f2792f09a70cfd1ef715c3217a29629e9df4250850ef9955e11c0ab64d96c08c9c5f8d158a91876b148991ecfcd632a52892cf0f99c117b0823bbf0420373bbfa4c3d2f856062daa0bec8d28bf53f4e024a749c30c2ad5cf1ca0f9d85ed217f7bde9cb494c78807e683ebf0d3454bbf2aea091480b2d5792907a11bf8dca42490dbb8f43b011c402e79c7253da5c18b1bd83447a621479496898d253c1ae06b5e094a15a6716d13c4e689721e36e54dde058149c7d860ba2bf498cc540dbaf17d706c1b8397b3451400e57534b34fbe0de83144c1cc9713d44ddbd09a9ffcf4c9644547847e235390c7ff5c770a8054cc778320f33a526c124fe66e7e1e45acf21634fee722f06d76bbb39d27c5868cd85b7427b8272ff2e94657ed0009d0d34a3716147a0ac2a566c2d9c1b669c4e0f4d893e55eb93c96df326c6736ec4e90d29fc2e0ce0aa5242732ba115399034ca1755f41601c44418cf746d42d179b9e64ee096309792f456e60f2b331482564501f753b311e9743107c62d080980918f8f56199d3504ec6207fb96ee98392bf1362bf22ae7e20dec74bb1723fb1eb72b1ec4d38e10c3e18fe71fed43641d0c6aa4a32e53dea8ccdcd606dc40d90246ccdf0a6fb75b6b8f9b3c4d4a56c1369af14c45d9fdc4d3f9a20ce114f7d33e1a3d830ab0915d739af4946f3aef127796015e4e1dde6bcb7d8fb6171bab456a8e56172fcb413a1227b8ef61c5248e658da4a244fabb66d64976c53733721f1ea0614ec4a1cb4bce46b1b6d0de2f29d9a6a8cdda6c6a34af8d537f5bacb3f0a2c5c0c09ff88d57fa9e0c9931a16db2b3b350d4aa6d7d0b4a0ff98af54a4c5d1cf44a705952fedb596b0189e335d20077298497ea50a559a08fca735f146e80e63db24e32b8b16fe1800fb46cf944ffef0e6d918988669ca8857141cfdd3604834dd03459094c7217f7c9a848b4c456d6343713162945c595d7f02fc25db7540e82adb50018f5b335ce30e61e81cdbf82efbf36e45223f2969941632c1e2eced68ca54d62f9572b9cecbd06476598ad9633e23635b2a528cd085cf45e0467b180905ac3a3db8fb0966fcebc1f31f475912dfe250c975cd82fc70db04e1519c56c37e73f7b39462404e33c93533c12b9e9581200e5f0a1f2f304d26d0ebd0608e23d76276401bd28ee474580a0e898f5dfd292babdf4c4f92d8fc9bb4eceead637d62568f0def467d418c92343ab2c6e564792aeb0a25bd10311ee61572e14f6583fdb07ccb5df939ea0f3fa91ac207e2963f47d470466e4794dc99dc0d24bfc661a22c8978597113311aef219bb4a619daf8431d70589e3a8929a565970d317c3cc5b022e224cf2592f566039a1cc8b248a3b45476f267512cc7e1ce38dcb08d2db716ac4093331d9a0737d3cbbd2a55a7721ba3e45b6018e60f60e18209de0e003b2d1ef08684eca74c2fc770fa78a94d2fcbbd31366de4be1c8952bea77a8fefd15363641c9bfc7a4b7b839a54402e353fc4a90a1fda3c4ef2cc50937d7c65e497d110b5aa875117969ee408008abbf32f8f21d1c1faf26b6e20d087c670a2f36f9ad6dc7c51f965f4dc0a44d37db3e850ace49647d50d454eb6b7a2da9eb011f4bc5aed0f67e37e214a7a7f09e8da4b71db8e91bd3cf985ed9b2db29bb586f5fe186cad342fa5a1620edd411f68a86c0b67a378b8ee3b738fb3312ee2cd3978c9b1e5c553657ba0d4004904b919734e636bc1582a837dd2effe8343c129863c99ec4d869998597374a2556628b0d0f30e83fd2dfd92685e8e11ba6927840b7c9038668dc3a355e83e7a1ef265dbd1c235a8165f8cc0db0cabfb6b99695b163e2fe3c28ac3ac4b2498a01dd901f381c048a925564544a09e745eea03a6f1bc22a72b6fb906e8a896512b953c64db616350c9587cdb328721d5da272ea4bb62797bbbc9f2ed0f4b9043b34404a8564a57a02b89df14cef2f5dfd43b7b9458f61775017984e76813e292d9c3b960f40b2a46b6c853be28febfca52caff5cfef7e9195a98c07aca2e03a4357d5749e70ef3beddd862bc67f79ced5b259f4346775ccb8a8449bd2b33b73410f77817329681ee6321e759db2a663cd7f5e0d5baac8607cc02c616fff2b6b7793c35251bdbdc4cd245425ee346ab8511b4368d50bbba25663d335d72bc9c2661c93687c5a4e62590b03656218a3cb23a09a9ca452435319fc2b3ea99c7b93dc21dc67d2a5e5f1974565362db7ea66bf665f058af13da06056d0c2f4eed1e5c91d563a19461d408f6a4b3ca1e1bde6a54fd0fc3c36a9d3459181f2337b0df61993e05df5a7eac01048ad80df25df7d81593821db10918ce91453f6198ad1bfcf91b786c5f5d56ffd2763595a8bc7fd8ab6c6724b3941edc0ffeff4d6900faef9f43b859380a18f99d30aa88ae4206ec635339231290dc839e34738ddb5280f3943fb9cbc19625ca334dd3b8ccee9415200e9ba27c159dcfb43429ac19c8a0c63e0045611b788f19c11eab8481503166c25fc5b477d8224f5e6574fb2159c0242f6aaa724620ff1059a7b7a47168818eea053ba3696157b1776de89b05d4b08a6478d04a8db82a5ca417a9a634809665ff1285ef095f4345b02fa28f5f2696ea09d70899d27828608bf99cbcf16570429b52b33af41bdef5a0a54b2a1cacdd36004eef9b259eb292b293beae716f46fb833bdb9405bd535d4e4cd6cd7ced42fa7647102e139ea840bdbdccbd7b235b989d83475a8b89cfd22deeb68e00c7d75bf6052227cb5868305f5d0d3b5b510fc8f5950dcc8f7bb5e317f59326242dfac78cb945601e57a577022c47ef4d67011c64d323756e71430913d6a59767ea6acbe842c5176674871f99add3bb670d16af65a8f1d06d9437e4aaae06edd6d6fcdcc1682191b24dde455972e44c7a703c8d045efc27067fd2d55289d2bdea834b1dc89cbeb5fe450dbe1cb36ce9fa88490d96ca2610bf3c5e7ae3723b010ef85c1e20fef1f7f0afd76047a4e0c4eafe0d54d16de8f9f09b490f16ce8101512b33c0953291efb3e5e225b9378f6635dea1bbb6c75cfb0efd20ba044d0db0c560f8167f8ae42a4aef187fe6600430282d66a7ada23acb76b395991e991d03942e5d2e0892cb2d5ada71b1bddf9328319910b41d6c81b3fbf0809092595cbf938d23529d2a6f74610a79f7bca8a7489e67e112d4c1fb06efb841a3f740165fa87dcadc80a3953f8f66b16c4a18d2e2fb2e645a9ba051e0abb7a34ff2d983c78a73e01c95aec816ea1e4e92d69bcd923bb10864681e870c097a96da37e4b9b614777f48ab4dec0c21004fd30bc7ddcd774e99ecacc8bfe141fb1fe5d8378534dd4d5b05ca52b5038b2520acfe45f05e6b7e22cfc14e2bdc7bdea8d4d249c75337e94a2ecdae829ae12f4ed2ec501f0aad6c14599fb5612f40cecb414b8b990df7435fb3fbb00638aa64f55f951e6dff85743510d36e1b0a58b7dfcb61194bacdbfc9bca88f59a1ad44cbdbb801c86146986df6246c86e18f7d47b5740d08d6657db2ad30b7dd7f75c441a44b0010fe66f5f1e6016506f31b1ca76023fb06afd4db77be331618c583341812f49e85ba555b9d47cfa860c42d567db505ef065428a8ba0079a97acfb77c74f6e6a5ab94bdaaa531322aeb221d23b8f08911cd95502a77feb4d02461257490dc0615e443a099281bc0580b66384d0f1706bf421d712260759875988c090ed8145002f9c7c413571025951b7fd2477ed734c82677d7267edbe1dc7f11e6cb1a70c9a0defa266164d472002bd58ca6b0559134892fb62cf4ab0d4d70e078228775895ad0a1a57e7cd12679e6a278f90b7c5751b1143a1af3b7e093a12b9439ee01461d717fcd9a02b2ce4d1d7c6d90fa68057b1b653a118d4bf6da86f009fd1b4f3f89b4a5829f241efca0e191a4bd9a4baf30a4c3fdf7ddfbe46c1e13ed9dd23f01fb6c4ba7ce38713d59e65088fa781ee9e54ee8329d9ddbba2c64008cd446b7285758c72c1f478930a95767ff29822bc55decd1a36572a30bf726983f9cf4932a5db05ea4840117512a708fddd6c7e781d2a0963994d7aee3e0627d7bfc9255878bc608c131b9d902b408c7d9598c101f7e92af7de6885367c6a0dab7b202353528099208fc6201cd704532ab8510437aa83f85d73653d4d5f7172cf5bc3e1c40a7a1e93f5c7ec13c61aae05ff4967951f88369753855be8fcd5cf8bcc6d4521a3864506d11121b5d1c24bc7b5f6b0effe08668f016d7edc902b65d833fdf9eb6e08b1e1b5e4de56a4bdd52bfec5afd4154b17c3ba6daa94859e215c08f7a96dc1592fb5835af3de28496df67b0cdf902f4e9a335f2c478ea1be34d492ca1576e0a3befc9e60b45d3b2dfb4567331a6bb164d41d644f5e11af0876cf12e26098b350ea522a9f51b3fdd874bc061ebb777b415343de0c0ba24ab6e5979374afd73982e5c853bc773408b845d5a2777185c5f2b887d49432987f70fc69ed3e24dac1986b00ae4ce42330aa8a20dbe16cfef179971d8efafab3336f812618639b1e516d203ddcb598fc1ee89050c504534da64252a241b4464d3c2cfa771d818a80564757bac568abd10665c62193dc750d04a3a321cc0a93af75688bcd0e89acbf2df6c00941c480b99d5edc5613421f8f8792bdb1597c9f92a621ac8e50450c16e2d676db0742a5ec886b41f406d801650f56046f98f5113b8b2ac7d40b7f5b2c7fe082426fdf800d62413f6685f7abc0f20a12919a83e820117a21c3ed9667a1de643f7bbbcac614296dd65294c70d0d1beb78857134404b7bfe06687be20bf277e624105da80823006dbb9dbbe5811bd58953d2df23352dae9cfbd25839eb51ef0218094c0a1d207b9a3e521422c7229b0cbd8305f34af0d155d048be61d1d4d61aa4fbd70b23cc9d634778c4645f11775f2185c2f5874930446cf24eb45587201da7b3f2b52772f04e3986bcd0793b08cd92111ca1b97c0e4fa832e65e6ce62c40bcbeadbaa18f891a80fdd16bfde4ce8a2303c5ba63802bb7c36526ef6944b73df8387e5677f24161f543a9daaf4a3d0181b6bfcc6600a3c9b5425bde207172e8630244bc0253c88d9b9d3ee81094fba6e142957f418782b961d33f068b8bde5ec36105f4d6a033c9905c2a3b2e535eac43bfc32483c72d403000b9d751235818ebd065818b7d2a72af396fb1d7aa85c18bdf23800794d7b30ac8e626e62c91f722ddc8282aa2c2f2fed17d51c67ee3154578f8336789171ea4cc57c174bdedc3c0ea79ebc981d8449bc899043dff62d91e9d01c83d8f90996dc4a69f60ada2ddc815fa54131041eadd6e2ca67a348469dc3f97e9c422ea98789cd642882433f9833107a3eed2538a1622632f55ea6553f62c85a73619230a8d7a0e5d8bf640d1bad9ed1dd2472bfa2b55b3ed2f51ae11d5ca6734e2b2394333e05679593208d1bdae42212bc4291ad7b3d2fb9064b437a4016757baac2c353102c498a4b2bc6fc65087c2c389895581ae0a929faf7d1039bfa7db4445455e3f80e063062e2555645e314490fc900c27ee240c8b4d9cd93d7a7a3f61a94b7863b4fde585d61e5ed46794691fb0d24e469d7d6ede3344204f6a7bd14fa1499431817a784199f80fbc567b820f17c92cb58676b75a61e5df80ffa5e1c3db82ec048498c043f18aeebebabcf11e5bbebece1ebe06e12ffd1f6be2f28e69b8d972646020d8376a71e35eb1e304cdcc7165b26a54fee82dc65ab70d42a4a74608879f2639547b784313c1fd92523ae7d81f2b45610d89a48333923af5e9ef5fe1907589ce5dc4f95093993b82108a8a306d378c4a247b969e61093060f05617fbca00c52d8059ae3ae8ab54c8429171575c052a597f67ff738b303c6d9e55929b9a1d596400b2fec1c0d487233ebdf9c72cf23e2cc0368f5bc42acd9aa07f5916cf0b0cd5ecd6f1655fb5feafebc427dc588deb25e95d63983af5462a0a9235ee39fd731b2da5388bc90203ef04f06f9bb50cd77364fdfb53c18939068fe491aae91809231c866915d85794d21382fc431a74849bcf7c5c613822e0cd665f5e0b0dd33d0ac2d1359b92387327275fb6f706d8a72f6b84efab6bc717409a9b78a534bd4f9c234c122d80cf5680efafacc058caa88e2675f2bfbb683160f23b32085a28bc7f8b83cd0842c6f4127c0b446b2786aba887924f72e104489b4bf4437273fd2c6892a01923f5fe05a4da78f2dc72f5adb8394bf8c43b7c2274f465b8884fdcc59a76fdf953a7b4e7680baa93693d44f7a0956657351c8e5edb7497f820d2c38f1f5c3a671788d6f7fe18bfa54286a6748d5c9160ebce9f547d4857da9d554cad7b35181ca83489ce7fa90a188c34479424929086197d05605492a24d387d2cee21267cecf96fd8f8afe2396430a3d00ab04e34e3cdde8f417a64dea3df243e6dc80b1e37f90ca8e229a3a0cfb9c6dc35449fd716c5db0d0fa2b33286a4433105d9bf7ec932420b75914e75fb27a15623aa8a96367f88f4ca2978faf1735ce7067eff9be576a44b5e45b38e4874468185f7115b068b8385c46d861c64d1e0127a1228a85755ae912838e549c7b1035cb30597c5aed3f97973d54d0c78983ebb35ac29dd2c5198421cc73fa9746293b6c1ba8fb683d9a1f39921e334c0a56907fb40f2c601c9bf06aaa781ae63264abf91eca1ec63798d4f1a5cc98a769813b55b3954bb8c7f33e750bc393cc0b7170504f42c41867638aa2f8391cce88b9dae63e63a3571ec7dbba992d3dfafcf76e3cbeb1ae9ae1f6552fd7e27bf849fb0ed3a32e1e8c00c422d34e2d8610b55723b6c67326615ab5588024777e2e5205d16a7f35566a1a102337c4c21c3552f6d396208d798646d1ca3935d29c9346bb1db94c0dfb3c3e5e4bc7ee1eff9a8f179ae254c01acbeca2acf2d1a81937303c40fa47bfd9d814f852b9eb7cb02c60b10e756c5f868bf1b061d72f0c547cb65f68f2d082a9586a182188b8f1fd2a7bcfabf0169c5fb8ff63c94ab06a04ec78dae4c28590c43d816fc3889216b2137e563ae89c825e6fbf1bfc4e57f04d24d203dbed03ae08f722880bbe66ee219f5dba4d018daba6bee0debb361add50ddc4d34ae64e6c48f93fc13ebf965c7a3eef9be89009357172d1826a41921b2a262fcd594e0c3943e3e1d0f4c2a9fac45685eca95261dc6231e14defb125bd83a1980609454863cc47b9477600c6e9852e0d6ad38fa16c5518ec0295189e704595f73526db723e91801b93127ea27306c5e49657984c425f27fd78e03ebafd3318587fef788debf308747bf8570f009bf1dd4ad4038b682b179dbd3654d25b7f7b07cab4d7da90f29405a0f91992704bf10db6ad77987b7340e01e35bb5615f27638a80f35dfc9c18976daf4362b295a1bc62f4a5c0de2660c28b030d07dd40b2079020935a43502a9ce8f5a379de2e859146ac0e015e8de696459f6a55feea38f11ffa362f37edfd4995d98567622168600731479810ab8a8b0fe6cbf05fcac696183a3e9b56878cb3fb3afc509ddf78283c2215565d3f21fa3631829b8301f1adbd8370fd69544a2313d45ac812dc56a226528cd40e0da47bda32423f98c030d8953c8d0e2c0fc30a189fc538f2a0ab20f95f6d4ebcc1a0ab9b186a715bb9f8b8ff34d852dc60def3681840dc93e0aaf43e8e6cf10ecaac1a7498b668eaafd2ce80138c9192435916126982e3be0b70e2ce76a0244fc365f7cedc783b42693e1e00c9817ccf0972326c174595c896d3a4522274942f526c46c4715ad0a20a7125a518580adadedb0df4cf4876f169dacce15de3351799d2fe85b110787dc735a105d29b1e8aa6c0bbc3a7aa5a95d6385521fc7072522f24d4d9dcdfa37e4d5760dac27a8c1ad2208125c081422771ca1fdd9c16945487fa412a68a8914529098832dce4ec3e16d8bb50f6c531426aed080b950a6376250b2aad299886499adb57dabd98615fec7c27f9c1f8fb3b05df10474d510945becf0036be995a5d823ee91e650a761e3ebab923b88a4897aa015e28a45c2cefeb86a8eb61d2e4b078f347465829a50f04c435da9bed38c9bdb5378e1027851b641926c3e2af6c0cad626558df0f54041ce82eadcfd7133ded00ec4d972dbeedb5257702ec6eca8659337e5ddaf04e451dc9357c1b91117305aa3bca620a0941e5d1dd6716970538fadf9c794d05c9275271e1022abd1548b6b9b504fa0ce0720a23bf26108b2f430afc3c7798ca8a5c574c2c90d19db3ec43de8929e5194c361a5ffe972c747c43dabae12092e1cca00db6929cf1380e03da755b142cd47f98a3676849d2614664479dd4342b63b68f3713b4f36bcf396190e5d308998eae48fd6b57b9ddb5c53c67dd6a0d8c8511614b68143671968c6c8b5ec140c9f777ea9295507936dbf26c0b4e06a7d574b450275c5e29672fe58e010a57063dc02d6bb51d0856ab86f2c145de61bea6658082653468dc3ff7d85ffb80d88f17844a8eb7dd6ce95569df610f89dc39a7488ac3a70ef9a8802ac4e59f558a93edadbcdac032b39739f56a23837acda2040ca6a7d358f637f047457a40dba8771746147f9c300418ed54ca333dd855b0264a84b4b2fd7ac14761eee671354b58e622bfb6188a468b4d90bb1ea79d42feafe222e7b7afb236828e637ac8c706e3208ee72611ce2f3ccc955bc65cb3ff52f2930aa76e5afa78af01dc191098698c0ea346e912c35410d1e0a20474c876493051b22b63ef7778b26ce639d4ff08974020bab482417c0a22c83f1abc96261b471c9b6efacaeda4719c9e2d5500bfa7eaa5f327d157bbc87e40c763f6d7de02ff07c7d834b053c35760e80bdbd02890889f1727baf820d870844e9c6040829e5ed8d55c13a9e46af8ac55d27a5bb1877477e879aa27f5ee7ec3084924e47c9c8d5eb8cf7d896d24f489e13c3df0c7db40e5e013b617305226e2ecbea08c7a490ebd4b04224069cda1db1716ac16873842a7a84d9323f7e1cfa32faabb176b8b0f2306da266bd9ec03cc3b294033562831cdf183acae9b8c21e0afac4682a03d730cc0e005c0c106d986df07b23c958f8294782822a6f98bf229175c204ba871cfd03036a2327366a827dcde530fc1dd0ebf0c4231e2c4c9b85f5eb3f406b52e6c27830ec1c774bb46bf93c4462f9887a856ce3f1d19cfdc8b7ffcafc990ebc6c0708d772b01850e51b7d6b662c9fad09e60aef1543894a4e818927765d1dacff4b912ce4fdab8fdbcf8d89f557fc13c6d00a46c9ef36254f56eb80e0bdb37c13e6fc92c2ffc15c88093fd976792ced35b0dd86dd67e845e72d26eaa33c75fdb6011eb4afdefbd8cbfb431afd401bfdc7dc7fe37ed6a4be463770c93e4bfc316b90e03d3ae1d269dba6409b9dbc8263604af89b41c7b1405ca52a90ebf825e1103c502581fd71ce36b99f20c9fb5ec50ab4d82c7a8ddcbe6c07a3a98d59055fc0bb1e8b0407a8a8ec9184dcafce5500c507223b4fe97b9d94a2e967ff758139b462ab6b4a787b1ccd34639c6dd35c12ee9176773f311a4cb48736e0cacfe959ebc3dfebbf5dd11853a9078474788b069f7ee85592732398b8b9f9c6fb7cb27d0a22752838273c0dd4790c15f97d005b8e171f7f78d340650860d80a234d680f72b353a3a0fd08c7b870b869a5bb76c1f6d92d1fd7c347457766a1183554d23c77c019d986e5844e41678f4ee14919929b5a9608817d6a98756fd1cc2a180e6ff368e762cf4bda68a93aceb4bdacd1c3b4197bd07299b26cd6f20edf3380d47e071105951182b3af28021571299f133cd7359251e52b51df90fa46af68fee7981a482c313d1e2108ef7f0b7f532d788a8eb8c4c501c0ba10fd44d66a69af0ddb95ee08113b9f78e5f4287e06481b1442223a34e6c2363f8ffab9014a3c6d3f2f86f01ba0e4f3ce64fb84bf15f9a60a28b5bbf74d5911bc7659d048916af5c6ab2f22584f7ffc1e53c17d8536e0c58740d58d65259fa57616bf5381c2c3e0553c138e6b1bf8842cf00c97521a4f8b83cc6d3ea1a829663771e184eb2d486dcf8d443e10e79fc41125280d892680e7790965c2c083f250497c8d6d1dcd97a49a40e4298571d756df4771cd66c808ffdb091ec66da09756ee1b7199ef1736b4febc19915128ab9291b60a80a6d977a8c4b78df67ec25d48f47eb396084841d165f95d204ad512a68ba9b7b507c8480f174545bba29ad6ef6fedbc359d7266094f6ca679359dee4531b689d9772480ed23471604aff62acae71094a4ac0e2220f64010ee72a7cb7dd21ca09555f2bd96d7493aa0805c6c8358b27f4f411be1c88f1dff3d22c626c80418b12688e9ea08f84a47feb99f5221e37d635fded8730dd00faf126533ee1f6a8ef0ae5c13ecc4a10ef6b78ed621c4d99a84f54e521d97a933c6578e67b0ab42a821fb08febd25dbc368fce6fa6acf3fda849048daba582938176716ee98167a1b0ca098f9dacad7b602a495fc1caca59b7f5e9048b8b63adcae790a3eb7a08c4944693676a8880b66568e63543ff1645027915c9d2f055baef7d14399bdec043c00c813a3d4ec10a6f874f399c672f59cef2507d22b277616020aead566caca5ad7ee3299451ba982ba45a43642c0f4ca10613e9d6a7b7244c3aead231ab6e1224831efdd7976c807a1af4676236224c1ea4f82b7dfe9aa4fc4efcb3ef4ee66c51a454affd7405fe119126324b24466f67fd76594b0e23be9ad7eb83bce3eb61b8c744d5aeb82163bbeae9772d8488bf8c003f989973ae35c4eeaa50b40f4ed25caafcb53e5a5f31487c8a95712301838a810956f2622ac9cba761e592fc53f761df525422d7944ee9d5c2aba919bc6aeca4a109ce6d4a07fca0f620a00318fc897bd02c1c94303144b2a98f185c6ae0a1400a21983c0c5ee523fbe999ce1fea2223abdf9cf4f58d4d796aad5763e4bdd4afc1d793940a7c840f18785ac455598b6053fd4dcac1fd7983ef5553bc00ba33213aa46bd4d147db1d94db67ccf116f5e081ec1adf3e54eccec71d2ed2a42780bac30d69dccc38e40ec565869d339b3fcee6ac206905a20001da32487035b246a3a4ad23ff57b1d095b957d9338f6205adb5a383acb8ddf51cd11ffa09a02039009afd660c2f52fcf3f4f151dd9cf72558d6327b1679c02f44866cd2daecb4370e12edf9efaab2624eb95a6b9804c84b1faa09ec158c39316ba94bee60de385bd2e8be06df3064c99d0d6805be92b089df97494905acfc382088ccefe0153efaab85370b11f7e9f1e4c7fe8048b9dc95a1d7a51b991026f784e985059981a266bf422b369161c71138ca4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
