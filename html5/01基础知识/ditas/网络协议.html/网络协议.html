<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91ca37766c956b4c9d858d431e81283a9aa25cfc72c627918e5e9ecde724887b4d0d1ab1baa827bf8a070e3eae855a17316d534b011ce74307e34f340ab3cae194340fd926c48d94142372ee33a97742cde2ff682f0d9538faf97e5999e52a1217cd16447fce7001b5060d52ca010f09b546d787cf2e172dcbb08193f0a80097c0e2f449a63ad6361a70851fc3c24772041f83aace677deaa70f4e1ae1f3c9cd05a17e93d3010244e2c4bb7e3a3a6d63795a735a60f4e3b423bf76191273c8255cc0cd3db9434cb2f5188759f8f6e23225d5dc7848e0b0895c794733aef97dce34e576db4264f22c0b8a11bff3b23101edfa810d829067fbc652b60d9186d365991d2d6f3d65864c15fdd37bb6334e6e3df141313717f368f29b7e3380b5649c18db3ac22b0bc7023eb0a8c5d2fe45944bdf2a180734f72b0e5be6b6ea3b26c655a2ce53dcc21446e7a3c1685432a9079d5472273c8a5531c8aae83972552edcb1e2d757f3242bd4f2a319ec42d213d3d6468dde911bd44c05b5c2f2c8e304c6feaed3a47bd6ff0033d0b29788903cc90383de407085ba3c1128fc851dbaebe841110b82768799f0f8ee6042af898c32ca13d99f33e8c78a5ce5f2ebf557ddbf2c4c3c2dbeacb5c80527fa1017ff30143f87a1d80232662a4df7f0148bb10c7a8abb0d613a3db3dce6dcd17723295adc166126da1ae2a853008f79b18f0719feaa3adc42449a2d578b085881595e3a6a51d3d1bd33d152cbe51645229a590dadb84bc699a0082947feb16b60c97024d847dec952ad5711b74de25b3d7863822958b5a6b33460257f4208018c1263b560cba222edde38b17f0d9257bea63071206bb531c5d76eedb8482ba48944120ed66a8010a69a1c49bd885095eef29134c4764ff5a68badf690499defde586f73c93a327e5775a2e4ceff5ddfc120f9dace9387789e1fa4120dccf498d3b21b411261154e4640ff21b299c58f96ada3a23199844fe8ba6682d09df759ec1dfbc8ea6242af10fb588118d6fefcfa1c05e91af47dc1c46b31857a0da90c2106b929cbe8bbe618fe61c7965f03b7cc518b2c3e9e5bae8ad54e98e3577cfd2a2f9bcb41ccbf5834eb237d1707764fc21236eb441f461242de92560b07bee655921c26cf304ef929cd2ac9764a70d39b5b1923a5c64bae83ed99676c811a2f8518e7c96a39355694692c9388117333fd4ab568a5100aec4be9ae8c1c03650bb87b1bd4900991899ec0f8d39a9d5e90499a94ab8b52df603539b32096873d8346331ba2eb25d77707f06c09a573aa8eca49b1f677f1bd8e76cf8f0900b5dbe1609a936226273c028c8e6ac243f2b0696f1f4b9e66822c19d630cf5cce3a60a9ae643ad6933f6c4708031ebba502833b03c0ac5aaba705ba48a6650fe64e35e4ede5d156faabd658cd2784753356cfc201b1d1a776b1ce4ad65dbed2be03c47f30a8af7f2caab1812f70aed7e45ab15075b314264c5326885594fe074a4a7ff0aecdd7606af8be5ba555853a47b105e34057bc9264a1a32831e332709524f9ad87f93d45a9800767bb033e020baef29604e9d42220b1d98b6ca381e2e5935408182065cd1d0b1110ef4c17ae68c3dea3973b8c8501b6a89c5ec4818a2f58a6d21610a31ec2da5bf105e877a83bae28ac9ec36614b2606b132bbf49c1fd8fa2c99638044bc66bf566ab506487cf6f399e0bb0b931d06f6dfc2ee9df88ff7e847ca6ae6b082a22046b6da8ce9c6cbceacfd14c8e00c4df51a2a5e2ef257546ecf4fd42cf56771e0eb2ea7e1ec39e505f5e54d2fca71bae4af6715090f42319ca4617e900cf94ab7965b8c602c4f367ecbebf1d033db3326e0bf50c04772edad0ac8f7105251d0d69d540e6509a31edd900d1a5a80c2b67d5f661ef22239032165d5f4dcfe5d6b83c95c36e81f853b8d50889c8824997b1f624ec9432f9e28c1b1f52cc8e72dc5915ddb2fd48a5cd5e126afa1de2d063190ee1821997ea40cacd4cb51959d7563a1feb599294b2229e2ec18dac3bf0d9e76a5e10ddcc856e7239d14ead85f20885370bd214adb56c31dc766d4299c19d26c5c766c5bc4cf5aaa9bfb50810c7a0248ef79d6a4c5a2f0cc79bb4f89846695a85e24f1df91585d181b22e7d819f5ec14ce5742628bc6f53de839d35f4b245c1fcd7a8f2f6d60d66725f7b9db552e3b7953fa61df146c4863109137f225a12441a31130af699badf8c42c65fb1ab7b7b118246841e88c56ed2a74a7de779b6ee4280e1553dae96ddabef128280b800e6ba54fd1bf8341874fcafc46aaa29834b391dd2c83384a825d658d76fe38bd35c4e350f5dad966a7e74d40c97ce0ff9d99b5d772be1aeee24789ed0d32f8876fd1b3c926feed3192f49ab38d02d95fa072a9c41a3844d7fdebe0187da79156a95afc99599cef209573204eb3092424fd924bb877307175fd3c7cab9fb970eb0502de6ba5482479f7bf4b59722173f0e56d730e45d4157ab74b64eb3bd496df06a04ac0e76df7128cffdbb561feb1f4c8ec748f3564aaf4f7c18a3388d85f86fe5068d3d0a1604197d05296c82132ba1b5123c7e16612f6372749d118fbf6171ce11b84277108616df5eb486eda152311b2e5fff559d79b155e7a9dc5ebc1f21c52cec2c3ad52a5261a2c472ad4eae9f08e3e697708ad711cc4b4e96919695c1d42b1a7aa5ce244d91fbbd1b26587afa2a8181fdf08f1e451a41377d617310dc4ece1354df940d8007533bd6523a023ea8895950afbbb9f8a49aa185403c3756819d17eaa8c29ba0f795c5e08fd19c1b8dac5f8467088b0090eb2b6c7e16005f4c83eef44af80eaaadbac1f437b66977b0149737e1fcabc5ba91c2b56ff59313db4bbabddf5d74e5944a2a91ba209e66d3e4725a862fb68a4310813cc941d6a75355d39e4cb05d8c74c155e4538321e6f42782d77db6b6ba8d145bbc8fa59c78675073dc2d86b7bfeab839b912ccae7875b2b358b7d31ada61f430b66fcf449aa19df4ea9358c4b5baaf33e6351eba7cebcb1ce49d17db3812c72e75a0ea2156780ead91bf226e8b56ba4e6e188d9f9f4c618898a19981b75162a9005b4e1a663097d94fcf29c7cbd0f16d0946fc6827425ce888595c043602286b599cb1771dbc3bbc607ff9d1b4aa7e9fef7cdfb1a822b0bf45ab7c22788f426f6dae99ed3d46e9b7dfa39029badc133ee3d4393474eac63bf88430a92697d4f335ba8fda8f331ad62f9bd006c0ff7e04d4212e99bf7b957bf52c73ef0254b9aa2711f16bae3157e7789f84ee01a0aebc52b451f5f083868bfd424166f2bce8c5eb566c1da5b4a98b3f3b3390a31413915d39aee3c43e85d5e788866f3bac56e416e5f3665ec32cb21c0d6868801e08dc6eab99af59c67647f98930943dda0f16028ad3f2ba1de46d3d3bb7c8df3c58f09432305c72e4418d4deb65cebb51b77cf9e022e593a23a4b0d854d77d15617622733450144431b3d67a3796a92d925ce21debbdfa81c2a4c6f307ebc38f2497f7442e8af94b0440aca94cc13a47d87c90ac0bc19ef8fc455e5ec9b1534c1c2d5f8cc0675a63c5c7f857227d662e923545065e46daef9f51fe4905c0bac8afbd083ea23f261099d1f07fe903aab3d0af2e2041d5ddc379d669294e38677f5b8167bd34259147b6a9c5ef42b7e4b2ae64f3712958579f89cf51d0b6c1bd38b30a024f9787627b658d514046fb492815dea83d04e679ab3367becb7334a79c133dd7b0542fc38cce412e546682321d5b50d034feb9bb07c52a58ee5e2ee559b6d6f4acc50c61145ae7efc3c23b8a6bffd29f0834f2c3d3bc2afc2419f70d4c2bda06a87fb84f0752a10620c28ecf502369753430d08c6a0a3aacc36059ebd9233d89148986655d0c6c74a0decf532df7ef86714feb1d629ec697fd2235aa04c2f75e7432b92dd213968ebb132df70a115de8245c21781566467c675b7e476e6e1e06d6ae0d52faa0cb5a47b304a27948d86bd950a81d9c347adcba7ba429adf3308a020e9e95df573a6c287b35658cc5b7cdc93744f3b9621f2bdf12f2c083118d7c2e72a89428f701239a6ae4e748f71629ba57e98ddd27c25846371721dbd31ef7368e09ffd3a12f8c85d4287df34e035bf0668621903041ed94e2c2239f35ae998b53d424a1070534a7296b90d123167e4da69642298bb60439671611bcf74e79f8f15389932323e09e910edc4d34b940a764438593d2e2692dc522c0e33fa068240fbcb06c3437d1bd8b78e98855f7f956caa43f7adfd2b37d14515c1ba2de0d49f6595a15afe6475ac2f88b8e2223d47139154e165951111ed757670c3c1e284dedd0a83592d1dd229740f1175e3133dd6b6c412158d0d9e9bbac81124deb44f5e2d1f98617d76b0bfc6c8cf2f46f1b90e4dd5c8c2ae38eb481ea4e3a50a893663d964df1b4a6e6e99f0445c35f915904c8bc4691df0559401ad0346ec2cdc0416af858166f714d97e827de4df88ed45e758b12ad30f4363d6b2d38a235ba1f329281fd234850f8d61752c0d90d7f08ef3390da2c20948bcc80e0f47f4ce3a150e0e4a448440d057222b2088973ac78a4edbf78441f4a130ddc7436fd2cd56c20040b658ad0a63709bb763f60d4483e2a4cb5248cbdfc971fab4758882035fca45d7fa1c0f34cef7e1ace82d8028802b91ff537717f73fca94b6bb085e5554b6f1098557ee387b92c8f8884970ef2e02ed52ac38d50ed3f9b33f85f979fc563ba5d6c382b9bcfe051918f1321c0012ead9c931c5a435284d6919409a39dc0021ed44d673264bb64aef5920134b88798fcc3deec3061cb768bd5b6287b8a100eda11ac2a3ea223bc4a353a1e21c4d5e930cb4248e1ffac2a3ce534091c4c49cffba542bb6a96f7abd7195a058c5717004afd1ff953860186f66e3757608240526f97ad4b64e35623ee3f5c71a6011207a31cd2c8d07c176499b3da9e1feffecead7f9606286ef6343f855eb44b0140bdeaeb22c5efcdadbe4f37429bd550cd460c1af042a970901968242bcd3c6505b520b2799d56000d3021f67dff7f266f157c258562a629815491a4c91b52aeb0060d686f85ba62923e6445432e76dbf814367fc94de37c2e6d0d7304eeab4e9e1c7b602c53d11d4b9b2a1ffcc85d4899e084c6a6b22cbdbdfd2d7f036756d8883a4b3f7a9c103f6c50d45a9fb57b4da2305fd9e674d059cdbac491eda9eaeba7a9c2651f19d8c18c35f2995839b1baf3b1433ce67c80ff55882d9940871342800bbd655432a1868d18083cb998f0fe3dcc21e33e6a554e159dbdbbc58912cfcccb0cf6b4db232850b60d35b5bf700b20fecb298ec62fa3a1c362aca4779e52895a24a1fdcb0178d1a04b99ed65af5e1335bdb1d66fce5b098f9583e2247ac14281d27e7ae65dd351958cd5074e8882a3d9fd65b543b58e0abd21a520fa274895e873cbd5525ab676414fd8f0627b4fcc242fc13507cb8e9925b6028eda94ead5d262ca994a1d66d811bdb4ed3f69ddaf4f177ab66f30a284bde091ffdf5e98b277f8a50cb571cbbe786b39154aa87e5a5e85ed9ff7e19e0094f131e8d54f595512e322f7d8e559f47e4a2f20127dfa32de7f5437ec5bffe24bc75d1d7547ab1418e8b00c4ade6d822da58b533f52a6530f80da85bd7d5686f1ac37a8cf8147fbe674011aface73575e4717b654a98a255b367170eb4b74d815eb30a8e3fc0f662cc52e60d642c0e69f4ea5fd27c7697c1481c092fd1a0520d6f0f5a01182d59a52ce7c124d3d263833da57251a89ec990491624f100750cd2be72a3ba8688461bcb6ebd297f2fd459d15e6a349ec1cd76ad713c3330c18ed468d118774d3dcfb8184ac7de3f78851bc1fac25dc19734f07f6b82e2f42f1702f08c38fa019e2f284ed6ccfedfbc97771a8ccfe546a9b67f4bc10c4b8ce1cdbd945e534682e6af0f08f685f896cbb3fcf20fe5f7e58bdbf4d59b6fb64f80906be0ac98895b34fcd91724bfeb70bb53e7a007cfecbaee628c4f21e81dafbeb72cf636fb6b7953b8912eef673015dea3d8f96ac2d76b81e8064f27f2abc1f5019eb47f86ddec286491fd31cb9995bb13da87bad84e6805c24828952bf89dd8cce617f6a74a41af02cac6ad710ac7d569fe7545db55a1efae77407a5ad95ab150161d21856cb63480379868f1df81cfdd91ca6d57bc77588977a05ca93136cab93d58fd6157368a9b37a44c91a27329afe309d56816de35bd404e358a8de5c23e0009d64e3112fb69bbf4060f5d96ff2c6b0b1b9cab0e7d1db77edf924aadb5120aed2af850cf1375ebd0e276c396eb482ea944be6d47068ff866bf97d1da8046616b6b5983d4def0809c3a2f887e866eaa35027ed56fb18ed15bffe3c40d1ad3f2ef20a1e143fc95d3511e9bceea6a4209109a42de6bc8ba9be8dc8ab5fd73ee2cd20fb46a15279d9b70821c636e0986ca69e2c0caf6fc996af8c6627d6a576adce8956a19022a50112e45809060089da41717b73e71d4e765d76955facea00f5c47c18149403f7ff0f9bc8ceeb702a0ec34f1d2100e33f67ca935553e1dd62c840a35886a756f6435b9de8f7ba7e49a72bf6bd4d95eb53f61210c6533143150fb4a253d2aaa7d25f935cef2cfaeb5381c7e45c114f27b8e90475781612a38ae54f91f00b4283d5147cf87c610232e2aa830f8e0c5097cf7afc0aeec0e00372559d6860446d3283e5f69148e3aa85711b3fac40b764b43b3a3ebb5ce04c72fe8e79e5f97fddeae7e6dedb9cb8f6ad5194af106a56fc9560659ebd89f02ccee223f41a83d1cdcb21e4d8b936ba90c620d7fd1c19c06a6eb48588f9e1a90d953180770870017699527cb6b7ffddbb477f098d7953e53bf6ecb569c9c58e6c5e79e1b432fc2d57b59dbd36a714c1b7cf9cf80fa30907ad8a987068c1cdcab079b0659e8d561da7990f793f1034be2930f640d441e6d4772d09f93395c8b8e63960e751c8d88ad3b70e45b8fd51ae35a328e6c0d8e5057ce67ea40c1db1013f621dcfe7e325b3f2c62474f2163d1d453002f9a7e083dbd492d8b370d490a40f4f5cf8b32ff8fa8063782d86a6509e24086af7b8058e0d944731f9a06a4da150c342603fba4ac18b53cd05987fb3af0703077fbaf3d5846cbc6d86f1dbe156aa2e49ef57249ae9e922064fb8b5ad3b7cb097c78456a455010de28cb312ae61e9a27962564a1d05bb3e5930e594b11837d0fd155328227d9dd068366f0f88fef5a07a2ef64e1b110db8c16584ab311bec1a4ffff77b32074e2a6f00f93c883669acd107cc53e39ef353bc821dca8e375ef629149a2585cf2c42aada77ecef0e9d022e076f2c5e88c67c280eb906808ec1dda53c2d2b3cb38bcda9972ebf73b97b1a3a07e8e2364d31ca8e4c0bd1a699966a50b3e7171e01993279eb8384e8181096a8133c363718131bef952a37b1129d8a28606299a905687d8ceb9774485f3c765a6f1a95e0e110ca61d7159089645e7423aca3823843a5c24413dd7ab27ef86122e7a12cea097a5aa9242b00a14f5912d716b4ec44e40f5603d152f329fcdd14087784d0a3b3f78a0e8ea1dd130d845018ecc43e776403b40a4f31f8ff521a65a84b2680e2bc921778faf12456e2f05c8cc5d3b31f8aec133e25042466d7527eedd2245aa1b32ea961422e8d704454cf6b9fb57b5da54e28840cc7096fb62b7607fdd58dcff78fd529c3e931c48da48631965fd737fcc5f06a1ed99e9b5c2d43c3590f5811e6525dd2555feb34c8cced32d4c8259c150edcf75c5eab34b2390506f33701d0116fae5ef5acf1a6b073260860c60f35de47375aa89e3fdead7ecad2ada97e318583c3f77fa37074ea51bd74a85501ef7250bbaee946451864bc8fb85e0206c0bee44cc176bf9ae796b7aaae0a04e014d8226aac670aa6afce9c9e626f361a008753b2c459103e01aebfa032611d49790d79655f45080053fc6ec09c1d21cafddb5fab41220804a8e067bab496b602a924ad9409c6719d238345961fbd3a78711022c45714e5c7a9631c38bcc3543cedea2f77b0ea35231307422481a3720b4b4ce7f2b1ae889abb46798844e7b2b8c6961b3a405da0e14944c80cf7d8430885bbc1c40af00425966881ec532330f7f6cd7aaf3b6a2f9ceee918d659e2b1fe641786a85e32706c821b4bd22836a6cc5b294ee8e56969f7e3c7df53d9172026da962767a5f9e8c0c8e93ab09cc81ef0c8b0abe8669e0e367738657f4712158909be2dbc310bda9c6e6476f0b5158bb36921a05c74f93c037e40176fac9c7689015f244ae83e6c1c1a0c25af2c2dc6611e9fca0bacb972d0ee761ceb9964632ff7729e844e811d09ca33261c741300fa08aeec61d4250a52f1bab976684d56e165ebf8ebff8610cc0bb2a45d94e3b70d10da4d9ab02b335dd69338c9953415bdf3939dea10a03ca86c1328c84c27c8cd5a7a59b6278da6879db97d4ca181f32b98582135d8d033ce5de1c5633439cf11a49207429f99eb2c2326c76fad4c22517923ff46667f63f0aa71461d290769900382731d3b6aef99231eca85c64cc7e5056f4d5ff5d9b8f43d45a3876369a990b947416190fdc7efa13bb98d7b9e68d0e4637a12c31c31831a1df3526931310b133b0f113fc5d9c37272bcd34a18d9f5075f9604466bbfa6603859065a51ddcd27619498d783440876152eb8fedce5b8e8122f0cf07bd62524fba02fa1ab0f5f544d9ae3f012e09639ac5cf7642c502433267de3f1d40837a92a51b5df3170c112296c3eb6feb478fb58af0b801e92d1a8bc5c144021e99e9892ad06a7ceb87709172119d1b286fe1d85e48e128fdbc3f48c781efbc966d65c3bf6c0ec6906e5b8c8f1057755c57cc6eb7747edc407122c22edd542c9edaa3a73def30dba4397ca2a339257f691c51d3d3f79de92b536635af9b8f958ce8548d743f294ebcddfc8ad4619619f4cbe3cafa86450ba94fe7d24b9dadbd826f5faf41554eb54ff5a067926c42b46693115d388c2149124118a7b3f4db91525ffe43c47b74cf0958d2cca1cc6fbabaf76d07bb6c42e051ad7c8f80d7e875cb85bde0d3aabf53be8f3c069f1fd184901371092e147fea357044509814422fdc47f30e806fba95a17db102832140b7b3352d08fd831b416c568cb78e1206b2d0d84a585569e774c9276abcdeaf120283e0690cb0a8339ad0451678c9448052082bf50fd1b7ea406a5d82564c4e4bd212c903171624175f21b41be0ae4127b784ceb78e3535b5217d8afd3ee657e5c146dc9cbc88c4a12e97c7513035262f66f37ebbf1415d69b020962b83b5dbe011ac56a9c3736ad864454431b95985385471a96db310ed2d6324d4fd80671679b50ea3599afec92ac23f06e374703283b08226467874d89159ccfd1d487b02d567b12303b306a4dfc4247f67c53bf3d282fbabe070527a84a22cbe4ce1093727b84c8a2bd088e604130c0bb1bfb8ea811143e3d30b962f1a9826ae54d9dd4ed8e4cdd85e2126a249dd8cfc000123c42a259fa963f0ff07c8141a3754061bef0829d9a355c9fcf70e46cebdfd95ae556e53a8795f2dc44c22e6f3edc7eef3b3e7e4477599177f4e6d248c520af26edcd7515a6c0e9f3f5c8799cc2da6bdccf75772c3c39e718a37d02ce953818322dfdaf2a756c9ae9266f2544f8614774b182132ed98130ebeeb86de95e1b0aa968069e76b5a8bb8102956301338d4ffd291cc14fe209746b0f0af42dad9edb5a2a1980844cd97095e53039b93caa799e300c2715a0f7fe82d66cf4e617b4aa298396bc2dcd582ad154635db64736ffc1d274f4bcac8586c80b94817ed8b9906d8c4ca976042ccf509df571857b21571f7e9ed4d1b317efa61fa4a88492887244c182c5cd8d62e0199f0dc7b38cd90e5ab86fc3b55be288b8a4978df45d243e66f47f4fd5730da33e823695ab0f4770c076bc491a1b99be678dc32e7a07cb389c582bb0a94cbf60977e013820f996bc32dbde3d2952a4ae0a80b2bde6ed7bddd33cad31a3c0aefbaaae60b4449bdb01974e5808cbecae453a0dbc69024a8d25f49c54eb67f2e1400897fedb7573c1de0b29039efe38bdc350e31e4429bcda0e97c3f162a11fa473df12cf476d3f23a66eea2aa362af440286f106012a6069196f9413a117628b083ce74e2ab485c6185c70adc8fbfed2efa8547745b8795f43300c1bbef5f0877435d053e4c7aaed24004d8d87184efad36d00cb5bad4cc88f1ea98ab08709ae3c48dff513c97514f7c268d072e4df944ce0d3c6025c5232eff22a767c9868adfb666f516db1afe6da77c73bd76d7a0a6e4f58edf5ad347599dae0d8a7d177045c6548714ce7543ad9797ba94c829f316ea14a0604e7ec9587e2d3f5882ba12e92c28d45b0348f88fafe165be52064c72ca6f257f03de1b707ea0a6c584d88bacac29a1b29ed8acfa3becc1aeb040808075a4205ea6023672e08eafc4c73c18fed81ef1cbbb4f57faf7ae909c1f56aca611a5e18013426a3b2868ced67c75deeb26849ff783ce7227278e644901740211b06339f90c5369b99f2783beec63c695e0c7683cd4f4dba7d3f4201e2988deb768bf3664a0a2a0bbb7c5c1a19517bf7d72214c8dd3b105fddc6be79fd5bb0ca6dbb0889f5ad85afc97d9f932a115763b2de0f5357f10116045b283a31c1d5cbc8c2e5498339655d59d2e689cfa042a2326a2e217a0c38adc3f1b917eef6cea68f2adc03b03dae4889c6adb54b97a2e69185fa39cea0dfed65e3a7a22f49945595c1ba10481562c32930bf8c476a7c4c38883d77beb9f4fe902e08cca7f3e15fd1c19e07b9647f94686730da4ce6ee743fa499c646bf41d2386c5e82e0df0628d0aab69493fea10d149486392a475ab8cb583f785a839a40a9136e1bce1f7dee761e8b61ebc90fefe5534f2e3ef780c6d077b87d6dbb93e340d583c6f86087058796b261ec7016f2a66ea7810b77fdc17a15f9148e93493210562a473aa7cf12c2e56d8a2ba857cf9f89d61ff215e7eb4670cb7cd03c3a6cfccd55152bb12d7a155c51ca82bcf2f780dfa9fac8c04375ff5fce7aee1774eafad0bc2b0d6d30494c4b6b91335060d558e340e7698e11d9ede959076ab7b6fe0fb799ec6ed3207ae123156fa6e81f577d936b8168bb9dd733d4d2f4a3a7d99e924dc5a3d9dcbd2e6a37619ab3e786c81704280c31177dc558b2ed4e5b7826aba71751e728b5167740ba84d6cd9d3ff074cb88dedb164786c922604ebc31b29f26ec2905f8753ffaa9f7418e0dd2dac258a0e5e3c7fe79fb087d932b848f262452f2f0f1a5c93f2e5076f7f74577abaa4be7829220f425ce7ffb7a0b5e8c7b75a83b3c03e97444f334de03775e111c0a7ce63b73910d7dc107febdce7274bdb7fe0c21cdb7d9d529bfb0aad5b7c4b9c6cf6c9adac5e694b1cb8f366afd42e29cf1a17cdaacb6a34e12c818f1181182789a8e702d238629f143b547408be9dd61027515046fb6e9846bc20c8ff000f115ca61aa4cb8e3529a48552228da5c6e185025a6d558c8d8796d3dad01acd8ba6e1efde20afb4129c25f5f5f8792556069dc428d2bd796f2d6d81a74d2d99c3fd323ad446de03211ec5a6993b82a90b01a80ce53a992bb8d1bc04542bda3e41e8ef1f322b365b1acf61709b759626720829bf07fbbf4b0968b8c78921ce6fd43227a8a490978db3865b6c1a5da386ee7381e99e135ddc77179c1d624f8f4f6b6a3ec729a4a50668b414791cf82bb1cecd91f22e09735de2915adde839d178ae39dc1b402607fa9c3c03c1eb81d0301efd4d9137b6a282cfecff0e899ac6ea0bf6b917a817780180fb12989cb8433977fe8daec6f1d1fd5989589ff5eff8f7ef10808dfc33dcf2d50399065a52a1add20abb329c3850c774b636603c0f034245ec63d2e02244063e31df3c0f370d53c4952032818e469ac2c6538441bde371f4afa0ab942d9dae8a16d31c2b0cc9616e63289ff0fcd639fc9dd7d5f80d8afd0a0edf9df8fb15c304e62606b665bf2e6358c77072e7ea469d6e2175566374acfa612482f88376dd944a4df486f2f706f6300bdd29cb2ef50eadbc27d2fc3b01710de2314c33880276cc606b690ac799a8b9bb03ba4703cb9a2e1acbc8b4297d281e96192188e33bf33b077fdcbb3a080850f680ae9ebe8cd9e23270dca1d36203084a7ab9961ea0107e18d413eb37a91a3b829056291c6b6977347ac530fd1d6d6a85ceb334a75ab5af53366cf7a2c567f8469e848b3f8e0b89f654b3eaab4bcae98b12bf770cc815e8017b2c37b2178cdafe48229e36c6f0aa761cf32c731fe444ad111099a16745662e781180247dcea7b01dae5b5881f4b1a80539f8f220e73a38b60951a310dcc83861f1f9ff1144ab188b61c396e41ec291d65cefa308bacb9f0b1fce5b49eb5d93092e28839fef5e2cba4df010a2cefde35013d8dfcc888ea05f2796809aa4e5a6727ddde320ed04a31b840bec1c80d729d58fb38152988ce116f1f1cbd958b0987d9d791a440c7bbcccef218327a9a7d0d4bce77c1424b37e673cb5c47f7454089f995c48bbc5e46f5ecf4b805197c4ccc3c66fa3122621be794680d764a9f641841ed46b2d03fe76a4f1eb999093cb4220c5e11ef7cac317e68b87d5c817d8713d9bacc2d496ccb9d0b4c1feb2a801dfdd7f7536d28c29d1239063a8426227e4a1695d96b2b85de98ce294c694da225b64b91bb227d7dc243ecabb78acd84a4e06b168aa535a39451ebfb2bcb18345db131f033d9255f87466463bb166268afa0e22a1f8f0870cfb4880108eabf09a059bc2f5b0e0af13b90ec4e8e11433afa297d11d4f6b7791123841d248c9ee3feaa3ed6ea682569026defd5f4d438aaa6f7b3698ae4e5c271eec8e504e67464a8d6e5a9d45d7800c5bb6011e7fd4fd495afd7adcbd298707d2cdd1d5f46a33c2723be5ca39d5a65774dfdca6bd16c1bbbdbdf6966853de32d47e1b7bdb2e409fbe628192cd49354afa56c24b797ed0680889da7a5328a4a12a2773ff0e680e74080d2792abe5391bd2fb589b76eed001821150dc1ad95bbc4b7323199c380a811f525a521cf28a20bd7d465acd4e5a191e7707cbbefb1df1264f7d81a48c14e0b7105cc33f3b10d8e50d90f8aa52a03dbeebe4ffce0104047b0b22cf410305c0ac597c8a1a34ee7b02294e1187f326159acf3f2b576351b09003b32fd66d5b7b64c97a03b156b2350bf9857b8935f7604d0de2fc23e3bcc5f96641453aec309f8f30b3bc2982a6dd86a1f70648c0751a9e094c84da895b0e3c2a79d75abeed3b45244ac17f9568176ef5325df332f3832bc3c30bc16633e92761daaac2609006034db51d9400405604fc85dbae86653d23075a91a5393ea737c326cb72a1362ab4d40ccdc5b635def72047a9bfb56c07dee4aabaf395eb09aa3e75bf5b81f1e03f405c0f9c4637636404cd772ec08163c506a65139aba3794cc0a38926633531df0d56b9e048a3a89bad563ebd56425184bc6b11dafa117531342d49346b3cb7a290b20fbf92a3d7a15b80dd831aea3960c86fdc5b313402354504eea99b95f8b4a605cb3f801b79fa8f3d320681622d4d5cab3161af11f69821a3f790163cbb9182dbe8c6dc1ec11efe007a2d29dd3a1dd288475b0c174c6dcfad9162245467ed1cd9fd634548db00380fc74fffe75a2ca4424f358fa349d73a5e486b6330e4cf510132d7815893e6256f6a7ff72d33f58c6b787f8655af6270b5ae7328c9391f063b37bb3087d2989393321f1a22f080864389193db1c0eabbdc4ab6f97071b37f245bb6b9794800feb82339f5f868ab1efa61684d57f777904a75dc2e397973e2d56b18ce3124ba1ef38cae9d201f4bb7c9c32165ad353956763d41d70078ab7b044af38cc3b2b9e98f69db117b5e2ed8090453648debecb462dbab1b5fc096dc449b8effe2be6e20178f3ddc5311490ca4dfbf1a73db399d54395a1371da8ad4a5a8fb169fa832ee2890a883861541ba25744ba561e09279686c52f2376a34f525bab9e0637763335cfe5b3a2d08bca84fb06c6fe39209b8c8725dbb5f21608c3edb101eb12512dc1c6ec58b166756c2d775cc33eaf178f02501dc773472c89b57ddfa7be7aa14a816a9f93668a1f0fa7426c4cd57f8980f8fc0c6d0e1acd01b538148af6cb4db0d34260351e8367af11ca5095dce1491bc018cbdd572efcbc20efe9d714502efe5668e33223fcb2db805f51889c1a809b354a298be608c8089524d6c967a5575bfe88a4831586514ed66fc52e0a1d822b23ecef5dba7bb44630630c7eca91299e517c2bd82dd561eea0c144bdc1b08964e7005202e2f5b3b32d3776c6b9e59222316e585d1c2663fec329048e6aa1b250222a07e8d3d7d86ff5c4210e1f1e45121cc3243d90fb1526f82ffe9494825b54ca3af42a49c90caf0c465442ef0e3eac85872e44229222b066202123f32617e90860c26d4e8292c0cfe3a3c968dc35b772178dbd5e58a771c114c8f062d8be6bd74683813c78a50def1eb60299941eea743b406bbe8d9e2b34d4fb835b2e652076467b1d0b4ade07d8f226297d278bd6f46222bd362b5f9d71ad60f6ead811c28327e0f880c43b49f66e3a36f79c922358fd1c785efab38dad02a05550f7529e70f8a46a6243a02bd701e1e4666d72feda0f77c0be4a72aacb5f10f02e6a75249124088498cb92608a9f3b6b37129dc396f60389fb3692a2f61fbef070edab13909778e0567a9f1537d3c2aa18f808141aab8e83a767ac21a958b34d7d66e41fbe63a9262c72d771f049e9300a71257ac7cee45749380717a2b109c2cdb8dfbfc661f34ab4f35534f4e14594b343cb4cc7fb4db0aea285154d692c42f04b18b6398e8f4975821490a84831ebbbc760ad4c0e961adda350709f31b1981a621158ae135fa4c96209ab626921292d3876489a7484270d3152e3966b9c898fd91f5ccfd7795cf9a90d9251335722d85875c0af8323821aeba1f346c5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
