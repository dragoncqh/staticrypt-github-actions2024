<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e902a0dea586264f4500796d9ce8d62d6feb4ed5e6c539f20989dab7dc1439a06ed4963690f58b9889ad46e2a951664fe10eab183d72d34ab1a1cc7174f0b8567a7be7d541b03a6326fb2563f003363c6e86caecb2652556aebabc60b22bd57d51f2ff8383c1d764e0bcf80a921379c4327624f15e860af7a51de73c75b56638618bdab9078796caeae3e07732238314e824fdab58312aa2e2476772d349fff35101304fc342b8050d482e7b65d20ad9b88bfccbe439a0f09a185006a9b4cc7598361b69af365641bf6adebe330aa32e8a2ef10c3072a427caed8dd352ffed5022b4baccd049159e71992756658fb494936047c14b12d4e438a3730bc8f44f993054f06d056ba64e6c2db1722040c3cc0fb58594fa74643ef1f81071d7327f7ad6f399c6657ddfe96f02c6e3e3264c19ba762d964a1e23a8f7e1d6886e50e747f35516bb511e9121576a40cb3edb1aac14702184fa0ec6c6be77cd6ddea306e2f2f03f9414436e6cf544062dca92ff2ad18b9e2830de64e429081b35968ffbdd14a26982c044d45feeeb4617d632bc4717db77b968e8d240a817c42c5e32e055e5683544b256d942e4c7c92d05f57d88ae1ca2f252518c0ae8a3e545f213efa4597aefdd84fe042b9465ad8fc068850806daf7d536e2535906e2c93a1fb9453dafe9cc3c1fe31fcabd60c13c92d5cce400e8653ffd4c1bc2d0ed6f626c3f37dc5e23ba4beac39fb5213a6a87d7757a662e470e46f76a1ad45c11b2607f650fe3d2715f1ca3b00cda19b6c70438e408e85636730dd60ea54b12f40a4f3b76e65df61206f24495f5c35e1855c42c9cb1262af6a0ac3e503aecaf83c29e540c7fa316270604ffda5aa21f5fb4acfbd744e5403ae013b1f0ab72ed9311c31c7f11930a8527ecf0a1979068533e189cd6761a447a93bc89b9a26fcb93f145debe49548c549b5133b66b98960c531e7f89549c0480c115ab56dd6fd76638b3c725a28aa66d766ab9800ecbe8fcf87fb46a89bb36f9be12bc0627bdb2ecaf7249b6bc7c4557b79420aa42c8798d711bcf5c28d9c559daddfb81e8b5e5c285622e3e3037461a92371199719d48619293a416ee4524dfb4c3f2a1c161f96c7c7eecce7e8127d05e776226117b33e2ade83169452b7eae52b8cbc84e1f49f6020c6fa4c2b703d23ba340b8337e41ffd8430d7c66f9c7a3525b544fa2f217caebd8ec8d9aef3c15b5178471a8ed341a8a107bdb3b4784ef46d44ef85df9bd1bbb67c424ed42dcdc4926e5cca97a23d78c3a5dd5e49e23091796282b9ca2b9d3d46d9c9c2bd2fd2ed82492fdd7595d012960e4a95dd6e52624649247682ade03e07a770fdc71d5010fa26af01326cf9a7aadc3f20f284071f5f640c9b894e8cb7db0cc4fc1a4b270f1f5dcf8365fad16f9edd1b7cee42408246806d14216e88140cc89a7e6699dcffca0818a2fec9bb03feb4f7082bb3fb1b2112ce89b6db91f57889e601fc3a21639d6432a3bea7cced052c2cd3e13dfc110bd418e9165687a9aca948d9d69bfd4e20031883a227fa7f610a1cc65059f3c036557cf1c64f467bc96428a6f930867f73e1737cf043d94771be02eb0853e2d359f08047c2e28864c7cbfa5408707633b72bca64ae5ce83908541f2349a521d3cff27417fe14f9e0d630aa51476626d6e7cf90fb6729efe61f22fb9f2a9f10e84e18ab9b80594c406d3699935517ff1f586fa8ad52fe9766b6a68eaf20129359310f409255fd6ac325b08b741c3e99b1a85a4fdd4d7578b3ab86b4f952d01efe026b953d7f923bb748767241e1fb7a8713c478bdb8508bd5d30cbf47e041624d396a820e6c7ff089256e1fa36074f7fb69fe273d16339514371adbeaab033658b68f1e1f846fe2fd629a7690f1f5bd88549125074cde738868185cfd31950263aa7a850fb7952ddeee354101682f759fa0936bc341adb53c83d40550f49dbb84c4e1103dbf10ceb4f6079a752ab30c9517b4faa8c51150524543b842be066601f05ca89916f10bfd4af82c16d3f7eb8effcdda40ac7b6998a509d017dadbf97e170e42c0160d4ee8da1448d1c0636a9b3ff8a6d056b71e90fd8010f8a6ca83c5cc3a7dd1525a2cc95cfe00229aa4975514bf40ad93c61c197bde5e4ac3264927de40c0da540efd9f3fc237561f899dcd0d2736961a35b99c8dbe5ebfd4cccbc3106f6bcac4b06797796224591c312ee3ac26bca584c22dad66d2ba421b0242315f2fb3a7f054cbe8d018cf7ebde99fd4a224a768a0def2a0ce096c6e4b0cd58a475515b88a8b7cb8f206049e29b615f5f2f59f8431d84f1a6caea3e6f88e6024090deacc1c6564612497e1d44588ff8dab66460bc8cb90ce410a7b6a3b0f621f7907b8e618c0ad79374afac862c497d7cc4d23c6f1cdea07456a503dd4a7d4a709ed323eaa6edbb812b1e2d5293bfd439c544dfe130188f5ee7b481e05071a27e5384e56a686df428a9bd369328ff23fcdf14b69a9ea16f746a2074e8b5797c8a593ccc4779d462018c877550cbfa4bb6603c48d33cad7b46b143ef4ad03a3a3c92a06a35f9779339a08f5cd9ecf9f6cbd776c60b4b4bba595f45cdd3cf0d6c24cfe4a2a6b124cf91d52c276f8baba07840f7b00f59ad6061d7f25c744d3863b287121a2263e2c8bcf23dfbbdff3172d7db00edea314333afeedee75bdca1bcdfa7a03a3f18680a2b23234a8e8882a10f4355b784c756ee2ac8d39684326f7d274ff38bfe791f04af0c7676864cba7f8505e6fc71d84134d7a14f832d32adc4f9932bfd2d8c033011fe55dc76b3efaf26cbe7957ad14599eb16dcc79ba779a31f0ea4ef318eae5e1b7bc1f17667c9b87947a80a03ec275bc4f2914668044217f76d5e111bc9556734dbe8c24df2e92ffa218dd129a3a2b87da4fe561b1a0af760c69367a8236ab201707b357ad462fabb1f3eb48393ecb5079b56595a9f68f139aa9fe11ed0ed4a811486cc930e90209a7b96aa8b7eeb23560c51c9cbfa7d163dbc73439a6fa844fc987cf7badc0f1429acd8a452f74fc6e14430dcd4a7be0288df710869a444c0d57699fba986c427fbb7697909df664ccd728eb9bd75a61a376dcafe356df149ea641a2ec5170d249dae0144ec8732f22474784522dcda986119a1b081f189879314e4e636499e66e99b13daed47120eb86fab574ad5fa5744443776849706ff6474a0a798d52c425981089c7bee6d667351fcd861deb3da609b229ccc5d8e323bba1de95006572508063253a7d1d24c69f0fa4815f62b5f48b4609534aea71b6c24cdca09c19a61adae3bd4b988ede29fbdf059f1db4795567d5a99e3bc458f45ed99b3f54f5734d3b6dccabca1fbceca9bfc6458b6f74ca9ff6f5f78612856ca92e3e21f075549a28d8c4463337fd26c7fcfe9f2a978721a235eeb903d143f733244b5d47b60e3856e9ff1b077d68a3cc41cfc1e5f97c14b69bcb9f05b61c36a0bbc229b87645177c9879b8ce499fabf4328a1378c359c05a1b34b23a888f9cf479efda6df530a7ad44296879df8522ac62ea88ab5d51e1b1426a4e5240975c5c62521706179b67b47000d314cb06e623f372fd5f2a8fd6f14407cd96b76ee85a9236d333c2a96ebd5bcecfa85fdb8ae869579ba433bbdb63111131f8b7c71c18372bd1561296c97b1031b5219eaf7fb1ef4b6807345b24c474274450b251afc8534f77b2f5b0e2ddd87a2c7fe1912bd3e4bef5e11b2ef95022128a0be49da3742e8a7f0484d4c1214b29c80736d2f5368f059ee53bd53f00416152b76aac64ceb449c296a3b7690a9b5af96e206d4280a69d8425ed2887f5a6c99f01138a9cd4dd953461bc09cb3c9f8717d8d197bacdfa73b17b5253b5b0c56f4fb0551b2704c6035b985709ab3b320d639f23f0d4166039252c2852e0c9897d0ddd02157e687c8de5bff373392ccc1af9918a391c817f6e44f69fb51fc5e84503bcf521e9728633247dce845bde194f34a98c1a8f462ac6191490f666fde35f4e011aa7ee0542ac79820a8206a83f824c990e200428780dc7600cbce3e556e0a4106596732f344776660df865a782f71e2331cedeaee431453af4983e8debdd5e2b8f901a8d23b432a9e33fa171678019619120fd2fb39c068c2b2b96e34e671e54ab5d3a2da243ec4fd91a14ffb36418bf5b19d5d12a62409884671c66ccb520805d63c92b26d5de52d88f69e61835c7363f5dc2d9a9a3706d735ed6f6b9c1c9f662809d512727ce0bdf73afa5247082dde0f20e8913bbf9925a4f9868160af50c7aecb9212c099ecf62f4939078eea690835f74ea3a6b3809de57e783a0ccc99c13bc21d1b232dd24d0c3a5a87160b8edec54c24059c06e3a90d77ca3da6b1a9bedab15e67f0f321a7fa2ea7758999d63959fa0ef73220649360c16a2022c777d6b0b633def722ba60eb302676aa147e39b1153c4b57b27cb8d32a4ce1f3f7b5f947b6d4974d0e04f3cfbda465cb361e90b0db87a3fabfde0074289265d2a468aa8d3abf31c52dc3b599302019d84114e54165eef146ce32b9a9ba69bb4ad6df6430c29ee0ed6f8f1626300be080f98ff740905bf7b40f678925f9d9d4a64e826015999d32fc81b0ea62c2ed455d67299ee80044c9a1356ce8fd20428f9f08c622bd71ce7753a2e9dbdc06983f3874c4e9b0ce7958e53710a0d7ebe5fbdccfa676605b7f31c36743d1d63760e58e6a0a769cae1f6231f05e26203497f95c067d7755d9729447af39495ac0b4fd1409d6ee825fa95985200c98f18352d03eb1cf8701a9c4f1e004336e45540137a1683694be0b98f1fa5afc9b2879b1b8461d8ed7ecc26c0aeca4903541d75cd26f90ad1d9a03f8537378d23eb5c2ed16dc9ab81cddd9e21e14abc036e0104fd87c08ea9a1654d1a27deba505e0067782e3a35709ef7f235b154c852bfb79443f49429c82eadb5457d180f2f180a4042a8065ebd33cab11d0ef4a5950a95df2447c8e18e50d71b8ee1b0a8cd958f830a9d793b2d0c7873df16cb4645e6d736a80bf5bdd4655e2376e3dfe202a0fe27dc5c7ee7793b760eb0c83e69bb670d691d973e6cfbde2251377327d6df46e229a21f391ffc566b49488b06731fe2420b99d2affe6a758bb6a1fa0bab8ef89f9defa41dbf3c65107ced68d9e95febc468482913a3d03c7d8851a9a0d8d45f79df890af7cde8a69d4d86d74d27fe4d157501972edaba95636240fa5d858d1f1511d0d2e22c7bf6b0a08454e3d20057648cf92e9a1632401af978af8840cc989815ee1dfbc1d305ede78a35e187e871718a1ff51985a6e3bdb24dc4a8f573e53676f46af8952a327e7099d3b627588476765e10543e3ef20a04edb3ce0aaf3d501c80ad38f416e95e688a6373b3b9a12da0b1e8b00c2a065dbe1d66eed2609821fa59d7aaba03d578d9b5adcdab51dceaa3d08c2dd34c6fd8474978131c52b687a201d2a162009d4b5598ae625b771d5b44b9b608c6cb95b0b7b8191a223cdd09499d3d411c5364f7e4fd107cfe45144f207508c60da009b6cd46f027f6ee3c7f239dc4ffa5cea173e2ebef8cc2dc4757776374c427cd5521332366f95c4b31bc2b63402ace92f06ce89e1b7400371f8f11fb85717abc212700d88c32a1a6076ee35ed9ad5ce1640b54a24a6a458fc194d9c486091b8377454793d84aae517933ee1e319862d80271d66b724982d33b9bc1788914c8a24339c6351989c6e6cedaed377f1c13d84d3abaa8a257b210a480fa0eb6d5b99242a6fb6414d563965d23fc8fbd44f1695c2d099077de4809f87342fa9cd0a25291bc80a96a110770fa1bc1947bcd795e1422671536a53994f721b7d813d88e32da1394c6162aa43d23949f3cd02622d38b6689fc2645544882d6f39992a62fa82733a634c3faef503709c6511a327ddaffeb4dcd525a61e6516ef4e7adb4e1f16c3491d4c764745a442941d8dc488e6e72d8dccbed063f7360b1e105e24fe9042e7b6c7c02bea74b7e30b2e8646a0aa3c90815b1f765b715da0ad213a5514acbf7be365dd19d49dd35455c292c51a8c1591e1569a0cd18334d80fa83ee00957620acf9b0ca4313f422e5501c70f7c1ce4519c8b1f344c2c00d8c0c9d2c2fd96c1c3c35f8b3f183b01ba5364abf5d6fd953e291967677d01aa93e76e5fb7aa138d4e934261265dc688edfb86e71a0bfa9b379f781f1e7778e1f15b65124e8365d858dbf08807f5af7858408915e9870bd36e9741a8bc87865eeb5b4d8d7f53546525963afa7960bcbedc3f08f8e28b2db78a10d650f58711b97ed2074a5b5b16a7defa43b4f6072dd12709fc091449002ca3d001ef5275008ca7295462b9714cdf13bfb423a65ca1db20341ef0b608deacc9725b7ba23a31e270bad109af2ff2e6d73a80b212872f68c5ca20b658ae599e3a657233795d9968d4315b0e5ac9d789effc9845b7ef0bbe1a7838d63ede2f119cdd87ee5fbb295d5d2d963ee796416d4baefe024ccd5f08c4a725b1c55588ea2c6ff0dee3b02094e9b729de89d1063b1c1011462aa34fc29fa69bbf1437719f57df7384b427820f189dfb50430865fb3735df9a5ec8c67283c5c600ebf965e70104c349b4b331cd6a5c03347bd4081a26e987eccdedc1bb357b0ac7763ba3a013b9c05817707f1041b1a7db6045f1a3462fd3a8ba54b2b0c9f7f9666d06f26964b00a811d29774acc9ae19a1ee08c4b08db4c6953487a921e76c7d966581546525b83a0aa84a640f3dbb71bb0113d0391ab1f097e596bf9df24782ca1a4e09ca28f5132da4511f915210b33cf553c87a7b621ca08e936b14dceac26891c0b3c36ab5987f6b4c25e26e5ad7f6639f2bb6a9640834ddc13809e3e82381c095b6d1e050db14843f8a260a1b4d390772307df2726af9873843cbee4e0213237474e07d2cb79138b5c6bde6b356b520aa044e1e5d5f3a7ed41cc8a44bf4df0f5ecf43bbe9c0620fb3b954113f3ee0c1702e1590c50d7b847f4ce650edb5ef65dce6b482bd9de330531ecb30be3bc0d580fc0cab57c5b4080ab8bd116424362882dd51b3c34c7e25f6e986a128b0312ac4d032186f39df42893e77712b0f4f33d5ab646e9c81490eedf9523c7734df89cd5993064a3db2803bda805e68625b15bba19dfc5ee2edb08c5a57fef20d3c2438451efc92666fa40629a15ddee993b12489bf36d6e83a11203a21f44f8be6a66890e444cd025676b96f243296acbc09becf68c925bbaa9688f6f9c050a695a3259689c35d2d69c55f3155d1062dcfe9fe62a316b28802567b1b8108c483aa202304d99edd2dead00be771798234050d5750d8073dd1ff122f3185d8a6142c4bba4a5929e604c024851fc060dbed58cbe6aff0c537f86ece440ce58ca9ad11e123f4939ca0010802c7c40c8a098f22e75e3cbad2e8e185f65f7afd2acc2ede932da67b3cd83f4c280cc48b0ef68e03d838dbc4b1b9aaad40caf20e6dd3f245292838400b766c86cea2cc21d53c0290469454125351cffb6d2a8b0489e47f1fedd93d4e82060ab4f26e1bbe96aecb39e27b22b4cc2e1f106b81844d8549908c3fcc8668b201cc7041e8c5bfe16eb11d48a5aa7fc1e8fb2ee106478ab0d479b7cb2b238e8e807472941205b96432a792ec750bbad390347cb27ccbd08ddf1be414bf1920659df1421e595159385dd5ced91a19175688ca77c263808382ddf7535643425d5056195592d5b4bbfcf59bc2618ee4113adbf395f787fc35e2e387d5c8550e1f8bdcb07e273e9a979ee23bc4c0605518f69444be6ba4e6f249984b81ad0afbfa2a759444b30096d50b83941986a33abccb42dab785a820f56ab55ce13303e42b1d99b772b5273df6785288f8b047de3bdcf28811af7f7e7fd931df909c80b33000c87a062199a4876f9d3c3c282874054803e065e11412bbd56c2575e8e6e3b8ff5f1cddbc75422cf7fe84b21f161107caf3f9cf63c4a4489a24157a0aafdce0e43f28bd13e9dcfebbb4ea56202fe48b7e3ead7f7b7941c3889f27d36081e518005ab8d3afedc3a1a89c0a810fb2ce45d7c18a90ae5f1a6fa74864203f26ebddbbc55320c526132cee837ca914124d28b45bc08582232aebe30c0bc02f6f7f76e156e059ce520b3af17bf3535ca899301adae20bc4e08b4bcd577b4ce525432d920d04a11270dcd66372abb13a96ca4e1ddd2196bab0dcecf2942157a99f474b7242cbb14b0b5c86aa835094e9599a6e2d6cc0b5c2e7a9274933e3b7dac234f590ace4982f00c8f47a24f9960e617c7ad1e3dbc08402c9d1cd8a4fd15c2deed16c69eedcf161f4bc36061be9d0badcaeb4f180725976c234d1b4b6173afa175fcf5808ebc8ad1e021def7f8035e588a3fadf23c483bccabb351295e00eeff277df887f053679a68fc00d41bc757d0a16b315c0e461ed4cd8e51a1528c39ad92f9b795b974a13290bc16ab3e97319d74639c023439eeff95d4759196f9e5dd61118b4ce22237a4c2e3beb52dc388f868206bd3af4dff2c203e03609596a43254e8d986d247122ab25fb4733d93f99bab6c94e3be47a633fe6dd71b65e9226d59d2a5665b3a97109867f272b3a6f4cc485385345c466c468e8d41dcbe259d2128c364924f7ad52b7611b90119f2889d8756746b171ed93891b20c4e54ba2297f49d192761bfd2b9159519249255b180e51fa291a855de5c3c38da6cf9b1ac78743e6eb30f9b909dcd3a5742d03917823448bea7a19d2dee0870067c671a61a60ff471af8732abb8cc2cb4f41713f7fd1a9cd96428ce92968266785c9c4034f77156e9fbb000fc7a88066991dae4bc3b76a87fe28700a231312a82f9040b487ced5d2033de53cad09767b89eb2624ffdd58fd56fe34234a83e0790fae8f8b9034e4d9897cda6e1f1c3704d74e8a4eb8d52100bc596c3924772ad161c17de91080fe0887047b13d7589c173faa8cf335ebe0272f84b3107b6e9ee648e94aa68cd7978b87ccf46975ad3dedf9134e7276879d2a5acf8ca067c904dcc201da876ea96a65a4d8625d10d026e3da2636d34bd169ee267188ad8e95294d98d8c6abb32b24a130f4bd6317bfcb01637f7612dc045652cedc0e032d48356bbda835fcb94a3110d89abc963c5d072476bc902c9f9142c470e5a20b089c90f73a5055de511aefe059cc2795afe713f7cf7f21b7d0cf4eed64885a38961b9792111ce383cf5df7df62a84aad5f028185a1151782183e700ca553cf223ca42e4404de9d2eb904e8e584248e72c2301e42ce43c35d67ecf3fc2d138da6b987940baea4646c6b94608b05fc41b1675530db5dc3ed09e3bb95fedaf13196f22e5f76f3b2b0b8b4a4715d1ab597e97706e97e0d78d41cb8ba9f6055f6b95446693a02dc3cbe536cd3284869de560957a9642f7e44bfe3630d25cde100d64a37b163ef642ab725013c32ed7669b63059be24b471bf69a22af6c9ab9583885de8a60c402f69ca1bd64234d54e3d9116c9e069e6683f62b78ffd6f9f7ad01d6198eccb41de77a08606053c0eb4a7982084086d4c2c27af158d726a7e6df76704dac9d023522b803f579a1041f94a0e783b8b82aa67e27217e5b888abe5c3ac1e06ad40ee5374a25273ed2d1031477d65d088405cdeb716f11b4a27b8dc62ffba694b0b3a8b48e0f2130b07488d6eb7a08b944d6241324e65419c73ba7676e6b2f23dcf31eb43b1eecc8838dbcdfa9a222d026d54969d67761697d0784f016cb09183c757c3fcf1241dc7e570ab354a3776f8f1e35cd2872b1bfd5c2760c1d0f630324877164e4ee08c1e328c36edd54d300485e841f54b6d199bb806c65d3933669411713b079188d72e487fef97d54fbe6f278a7d1aee4e6f9e117f6124f7eedfaecda558ae7d615a943a0f2d506034af432baf27635d75572c03b6d150d493815ef78f12043eb7dfc9fb1005c1b2f6752992cab869c07696bcb895f7768cbb5b61ea91958a36d051c7ea92e5d932a9e2bd5f27efcd9c9f310ae683623bdc139a73e4bfd395c06f34291fbbbebf1bc3b0e4f68a126dcf3f08883d5e03b19f24dc13cad8be8b3c44d58ed16156fd8c0b20cdc6e49b2893e96f89cb8f832b5762b6041fe35e2c29fea64ccf58b9714eaae64b6015294b866b7a7df79322422785afdb77ca514dbcc1dd3246265dbfa1ac204fbd11104d53c45acf847cf7d9debecc8021ed0fd9a22b5b8c93165130a221b0625637e51c7b0fea6c76f0a15611a9acd6fe45c08f614308de28f7fbeba83e2e7c387323ff1a949bc32dca73d08e8a123c26a5e0ff28358dd44b791a38bbf29ad6feaa0204a315c65c6f8ecccebaf9050ec8f83b69be7abe948a80456a333246ee064a13feced2c4c1d692665c2cd8e76588deef65964e0fbf065dd97a5256cd0c1f432a278e37974e6e80acc8ce0d2db2dfc03af387cd03df1f644444e58bd5e2e6415d147dd804ff4b95cc554f3207a965d70df71d5f738be4f857bc0dc118d85f13d8dec9d30b8823eddae2b3c9aa1784d07ef493877df3a007bf78f05c9c5e14b0aa1165441e9c1e2cd25c19c37d671db21aad6e0cd0583584bf3be523196e09b5b780cd4694392b530533aeb0220b628b6860175dc32bc0269862d566ccc351f4b8b7e8e825100314f7c90bbed8f589d759adf7ba806429320071376e3f10a7494f0f664df675a914fa3d46e9f154b9cb7b2a15d8e2acb88675faca13f8fee8c704e60da541e902e337e0d97fa0e08f2587e55910fcb4d8dfd6d64e2bf5e82f5fe6c97c81f7317c511f61cc6ab957a49bc5c4b6e1d0074938ed96bd0ef5f5c6acb61a25a1856c6a1bf2fb0ee624d23021e047d61a5adb7eed2775d18a56e72ef0b6423934a11daf778b30ee54dcb458d60a619bb2fa038b710b8db12980bd5b2dd6e338d973e19a720a1f8427d3f6c8d950cb22f2709b04e7a1ad950408922b80140f483634278b277d272579f3b111e82294eacd71fa7119b3245dbd631b7640ace98017fd72dfb4288fef964d9f9905556bcd3a52fc9715bad33726308a77428016654f47389b168055ba60c89e51a5e018118b387a0e91be0f1976fbed87d85f1135971d2c9bd06d9620cd2d166c429de56fe7233c6bca1b6bb3729c697a3f1017541918ba6929419f0b411ee7391388259d50b9d355dc46d3435bc3197f0b5e4c046d48369fcbc30b8d927c3f1ff6f8ca26d30689bd92c86a3acbfe6fadc67fdbde3d42ab58298882ec85f0ca4dd478317d9e980d3b55b1c132926b77caba15eefb44087787bce682429d9fb9b97d088fb14ff7cebea00fd5fb56bcfd5aac9c8b4ba5f777c1725fd6531efaf9916c3a9d72b324f14d929478b4040afa2b5258412fcb4bf12eab3b5610b36fe358fb8ae7c9a26266aaac233f1289ff5852043985407876c6941fa1d19ad3e0e83aace6fb0b78d2f3d4c32b1143c4d5fe5609b70c6c48c2f113ab6e77483a80a346a05e08777ae9960a8e0bd6bf9bf49d5427d6a74b6f7c4aa3b7457c71be155287dbe516bc29ab3a5832c9d875d70c7262be0592ff6a2e4702afcb7d8be6b2003cdf4ea3b11eb58ae957391d15404e81f6d242f6301dd0ec07d444c32829fc29e7c291541fdc1e8e4b07a75337c7511c40d5ac81bd959b27969ecf8279d3628a27ea7809e90d3696a084e2af1177caabde82166c35a3cda571ccbd17aa1f8be23f5d4e5bccbee6fb16097fd0297493adb76a26a8293dca6fdd5d9941caeaec8b228c7de7bf36c838a742a1bc3645548c6a50a28c3412f934cc21e906c4f8017afa00af6498d724bbd09a3e1014520e87e0227b4d51e2642d2c7d3996d52dba9069a67ca615983f752bfa3b4ed201377ebdbcceffa28b937b2dc105716fc6556d459d9df8256464c8fa06314c0d9dcf9900fb96682ca018d7c45c74fb3bd43c8c55fb6c41ab5242266f61071e90ec2fcc9d1ddafd186c2de7728ea0f1d0d1529e5215aa3175d4a78ee938e8292c1878db0485ba9f116c1246b9534d402d000f24f1f20340bf642775e5f01368c31dcedbb9d24a7201acbe954a1328515776729dabe4d016682c664e7b22221adf2649dc1a216b519749a33a644d99605c7451c63a078054e4512b0a3e2a5ad7fda48e4ebc50ed8c6422d950a0ccfd6a58c1e31b333545b4c0d5d0e18be4cf9c4ca9fcbf78b024f3fc2ec274b56001c87207f4493f168b5b74a97bf785cbdb6d45a0af537b3e3ba6df207aa129c7671e89df4253426cf8b48ef276ba1b680e585b1c572843c18edb3391e05ce3a31362c245634e80ed23f73b13ae2391448c1b8e61e109cd282a6efe93ad7e722bb76ca243edc8d263c48d40dbd497b300e6eec621cb5e4e31f8f996d8e003eb7e92991820915c04fd35dee9222f98f376b654b4dc9520546804bac3fa5de4b598883237998de9e35daf97e9a1735c491f5c41fe363808d5de4dbab0a3a88ae1c378dc393d1b36237ddbbc7cb9d5df9de4dfcc07cb7ac03fb251079c68c906b73ff40ec83ca726ef71da5214425c3d57b4120155069f74566c982b9ad85772dbaf4e62de67d5f951a673bade222680e930031bdb089540b29165b3b653d3275c73dc235b21f5f621738a23a66aa499c852b7424a5b6f4cde03e1e19ed2a329ebfcfa44bad21cb86fa4d0a9a5ef927222718c909708ee475538c1aed277f249886668d56eaffa16724fb49c356d9d5a510586bb630586f5896754f9e6e6303b274d3b8a5ad2a436d06669b6d5e2b9fb5cccd90d9886e80d4173d0c5a2cf433a0d7cfcac81626993374d122912b95bb5ea445c9af65bb56a3654957de416a92a95808eff48f84ba7f93b8d9c05a94bf90b7edf405b02e9f4abc286e0842dede656f7395899db949d14cf057dce636fa38b6305e4d1bc0d958e57fe44551f6127137ec0499de301dd4d16665d09a62c1480064be33dec00243f90dbc0c73915e1e2c59c45cf498a3b06e3ab0514d0b6a38d5f5dd04b193c674f5c7f32d0915c78388d05ddf8f8f6ba62b89089818c77edfe5def153ce446ae17b6f2e47607b2902145a3f66c980e2d84084cca462e509f219a0db101461d5d3ae2d2deea4c35ffabccc2409b172b6bbd6fcde0d8806d27e81a67654876a7d2c9f4493f9f93071ecd8363c47e0e50932393998883c26b54ca6ea1abf964cad61332232d25b1375e975daf6c100664d2e1b4162db052527ccb24af229afba52a4340016dd8c35fce7e71bf2725adfc575d0059d43dcee141219a5f5a4f62c09aa84936d1bb2e14df9397126db424832704040ef0d70447fc7a54d3a3a913778ea9fde46fdee4a3faab2770377809bb07d9fc06b823fb96c42b0034c9e601026c3bcdee8e71ffb14dc342b4fe0dcb65be7b11ccd2262222f17db481721712c0164caf95bceeab8ca8852d8e9669859ee22cf062ce69e5a45d1a77255d115d26783e3ef930a1a47cd40e674c0350fc08961f7529eee6ff71a272fc586dd7bc65ac81f15d94c3fbb8ede99ac4670cdfba702060513e3c9413533b1cce2ab34ee38386d7108140f6deb6889f49f399ce01dde212c1d9632087cc735a1551f44feee6b37225ddaa5e4566c8ea995c6cf9be6afb0a1e3a987f319f3c6790c20321bfa114e74204218cf8cac9cedc18128f9509d1df95f5aeb918fca7ab442777ea3b2f358b42a332f17247cc094307a73d657551eec36be32452724c76fe161331f951850b4b5ba9c3195e6a16de99c328f08e7cdbdec4cb9886ca29b464495b062603b28172047ac7e1fc2388fd85123ddc6f4609faf2f523d7862420ac68b1707b915b9d038bf6d2cb4bac4bd3cf373393cf99e22c362f6787340bae1bb09ec9050bc60b616f15f44245bc09fb2c15b71f3c21c7114f6cd931b956e2bf551432036c65e37de2eeb7047af961967323b4ef9e7ac6e7ef5ae18c7e54d29c197227a750507ae937accfd63fefbfa6a07c4a1713e5bfe3bca5578a6ec140e7e18b3274c54036f051ce263e95f4ea9d988a4d857130ea663103de7961dfbe0a7812bb8bd924222e757190c7cb18bebd78a65528ff96387f09c60cfa7b9205cb4068000bfb700036990c51ab85ae125cac26e306d2dfb5fa43a5c1f84bd4aa31480d46fac69aa73cb9f507b9b7a70f510ad68265a11538c82841beaacc7be792cb54b2c8bbebc7f07c6ce6cafc8ab8e29c0b3f3e060ff5e00becf3818e4fb6d0ad7b715350d9d9c703acdd9cfd2e25d19dea99fdbe43fda1ccad6c6892b862e1ed0a777685ecc334c82f0d919162943916b04d0b9579a9587c66778b8bce79820554a52076fcd088d66dedff19c42e00572490799581a17598e9c850138cce979d85114b7447bedcc0e9082e6a029817ce7361886486f1c4ab99cd9d21a8b4babeb4750fe4c9262bd089ba74783131e93021254ed30697738eee177247a99620cf0c3797747d17df7b376909b3df17a11db19d62fc8f14b619ce82cb9093de9538679d8c00fc12c39ad4bc4dfa86bc17299eb73bcf14bdc238baabc7cde1f739afc1703ea78bcc65a1889dacabaae52a5cd265d8b06a927871a6d123591149746e17ba66635932a455b79abf24cd5edd703980e39052cce9a1cd854d4d8b00a2a58b4e59e6c725e14dd843065bb97b942edaf6e42dc28b7fb3843c3208d3046018ca2006fcc34f02b14fd1de45c09132e7c4cdd43ce2ea43870505f6ba9c8f3164da1e1d05729c8a534d75d4fa0aa55b50eb2a664480ebe28e0292672f205380c2ec17d2d864add3fb97cce0c7cf1dee837fb43aa871c80f01de5b0e4349a97c13eb47f1a0cbc52742e718c0965cc60e7d43a9a32ac28b9ee83ec0bf9b1e78e13de53caa1c9c0707bbd2abd846eafed35a8bc426e2945a51d131b0c39477d9219924c40ac1d83e596c6e243ec8ec9ec969551b2b4a014b8f7fa2cc26861582c7965c7b92c6b4cf0cd9c57f284ef15fa0654d321c63aad9b5176f7bf72c75292cb48e8145d19b6503b94c8793dab387f07aac62d8c535dba962546d4a843981ab370f3557072c8ad113cd75e59e26f92b9cc5dd86adacbdd666abd3ba69ec95a6d05b7ffe4e7453f9325e1e623195e642c17ee946772d61f3fc62a1efc19a7deadba5e152dfecd96625dcea52bd43b3f6e7b930ef762e3de5e62a459d56d4ff46e023dfa79b8014a7dbd0a9a4e71e0fdbf963852d2c7a6f056ef7e05838cc0cfe28a2a37977f6a8f6345616d5a4890aa11fa61ae07cfd67240a7406024fc030388375abfde3c1e6edbaf70c339796c8e355a97f6f2c281af136df92fa9056414ad827a696b322b28b6572e897c834912470cbdad79b14ee7faa496ca2ac2d5d5d35f9695decc9eb9f25835a42d5fa8a2295b28ab06c00aade33d43744aedc1d4d78b2c0e58e69192d1524a02fce71ea4654358f72da307493cfed7f09fe661870a0c3afdb17c6dacb30214b89521bb14fedc0f5fddf0cc3fcc0453a81a21b44ab75311e0470523d38dd93cfc1fcc5218373f98f0fc022cf87c346008726d339e1658c8a4f71490c9a7d77c9ed5cf28084854189a01ed2f45b0e0bf8ba69c018d8f35ef661c2e70bc2c64a3abe4311cbc54f7cc6e89bfd7e185365b3fccf809273310748a932a9897fa2f2ed5a0cd926023150c212678f1178f4ee1d024892bf74ab1042944c34811f24e0f67f3bffc10085b71298c3eb6e090e8b943107e2631f35432273963609f5fc04238069a5546f9c5496714976c8671e456447e3a30765d16752c599193aa52b681bda9ac1a45b4485b92818645984973a0a9bcbad9393efa8d3cd716f4adb3809070e750cc9d2aa1a1f79845a8f44d2f30fb8d7ae33db4720ff4dc9e9eb7273aa3643ede9861203ba05286a2a2feccdff632db86fefd693dac6151ff78646f6602b330d64a676546847180e7515c27d378e73105fa0a05a7346b0479e0872410e261da6edc74a45c6586ce1dc25e66b84ca8b153d38ecaf43ca793a4fa2df5e8bf7649e631f7b0b445a741ca9683e559cb53d074b3dd0086959c1c8a5a407237cfd8c51bedcfc113df42eebca7aa14ae9ffd2244cdcebedbaef6eb719679c446a38f8dc5a2c917737c05e67dbaeb9e913e423bd0b63866454a167839ba127db0cb03de11e2b27f9f85c4c121ac47ab889792600f0bb8d2b4ae4f4e93c9e97907f94e92efa3cdb583b49ad5037c527644538568166636be56fff2524659747e62075e67e730667f0f7a5af9da407eaf45b6f9e9fcf02490450b571e2bdc7be6bbac1b2455bf4fddc5d660e4664d61b068ae45aed2853fc226b37a553a2a2c1b8142cd424fe5ca6ddf138a4e931f0250154ebf9e82ed4b9e23df97e243050c6ce3d171c9204bc292b9f55c36c8dd1b8c9c890262af7347ff75c8086bce036c9641b84997c05cb769deb1c8472d096d04b74359aabf323eee4b73e75e964f088414d6be03801d9d2eda11bf018c53a80ef08417ff3d8a398fee6f8671331da472972eaa4951c1d59696e74c022a2a65138424fe0d021438413a321486f705e2840d0bb88d994d0943d6585a1c2c191d82561e1b3b6fc3316fcae80c8463db0092af4a678baf3dd6abf99836a2c89f490be9d2f2afbe4023ce0288adaa2a928f1b5dd0d6b19ed1c767ca5b098820c733637aff7389ec22c9f8e325e4a49b27d3113e9ec37bb248c7458896ea2b34d8e3b71494321e14189beb05544cfd2663dac4e3554b35415c4f8b8ae4f3a99f40598475fb58e46fdccfc89f228a7650cbaa4b7d1cb97bee013455f48da5eb0bc8a026373225d5ec0b1bcc6e573e0b5987dec46f2b24603c7de2a21b2820cca4e95cd0ffb40c796bc58144e58132c661d9605f9ee6eb3525e91caabf5840235f6336d74fce81c0f43f0f1e879639ce41343a87a1e107ad1f3c54dcae80f5354ac849d3524e041ac41c293fde29611d1740a5a919640d9c9d2083adf9ae4d3a1d1c24c2d21ec3e6bf612e9f44b5df80f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
