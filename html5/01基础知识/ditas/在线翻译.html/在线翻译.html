<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7c3ffa8536806008f01cb911b7c9eb9d609f9b3a8e12faaae3b90d61168be13ea8d1a789fc580958a3f78840b36900d1a6e25e9c7d46409cc9946b1ecd587bdb326c794a05ac47e53828311251f4a07dacd4856dc59c89948252ff75b1a0f7112c0111ac589a8fa596a0dc1f1e10c6ba2c793c51ec54b8fa130da0f4aeefeefe6549e9cccf1ae7dc6add83d3e08492f78414ffb9de62154db5e5c8c9ade8f8df7d40a5f2d3f574da4b3080664639928264d555ef2bca01d0ce90e0787c3b956d269337f030ceb65808f749a9479a539fa9e88c749b1c34b09f7ca824738e5d06ba2097d0386ca9456e7ba5d89d793e0986530a4953b569b25d9ea3546fc25a2523ebd9374d02ef595a1c06975fd9d782f35ce1c7c1b32a4fd93b7ab02522d0b9cec7fa0df692e651056c10f1cdf6fd31451be437b2f62ca6f4814362d53d86750f631fa0536653bb5e9bf2a3368f93b9eeddd2310fd7ae393f3f6f1ac015592b05bbb848f258691a0fe6d64c5d4ff76197ca81e4f8e280562be13beaba8383e7431e1e917bcb5fcfa7e1a4003bce7dfd583f28243022eca3b6a10caacb6f33dbde78797556fc24aed4f31e2ff138a7e8e1d72655f0390b47a520657c286223f7b9f1a4d887a3b6e483b17e1b20dbc82d38fe45be623729c8f95cc7fcd4fcddbeaa10b638dfe5b2430bd0d8a4919902896cc081fa30f5a77bd1a133a01b8c07fe459e312f76dd5ec7969e153b0028888000955afb8f163863fd096bbf858b4bebc331a86b7480980499018d53ca0518038c140eb762da69ff22463c330b094c5cf894d2e4dca37a9a2bbfb1d1061ecb80046bb6ab9b61b1dccfeb5ba37dd5c8089fe1502c520f46ed48fe9a9d2d0483d1382c0f0b8483cafdcd2b3a2dcd7a5e158383751c6885f05b8eb3abb1b9cdc95db4dce2ceffc87d33037c04270ea421fb175b9fd0c725c6083fa08635613f43a5bd9e0c7b39223b6f6f4079bd25b6815ced77a053b21c18ef966d66d8083b558092d98d23818bae680f7f3cab35e98d77557e2eba9da1e9f317a2c6c1d53e71c94f8c7976bacd986a30ac4ae9f9358af0b30b315975aaa62040ee22a23a365a19f41727f8a1d72119da37bcc12e396dbd84e08fd479771ebf5dd2aab056eff9d9eb10360f4349145e8522156db4dbfe71d5096a511c0df545fad1cca94b5217eeee8d13212392d5235d15ccd3b7d18e49801e40cf6089f7129d33328422d0341619be45c4948a189800a143b82d6e295f147f4da4b9f6aa3d409ebcbb0b3d4ae21b1278dd4075dd221ce57581720c7f35fa40d40acef02b3fb391a960b9903cb6b2c0645b61ce177434426f59edf343e0d3fed8a6257510d9a46fbac62e63fbffe3c93c9200e6cd506f50a114fa02e0e3b7842d750996f45df0af316cc4a6247b12e7de34dc9023f7416992dcb36df50205d9ec3e26dc1e0121985cde5f62e3bbde716be59603c05ad9947128141bb1cb1b9cbc6c9111b61ecf14a75cec3ee3c5a8b92435c8aa6e16f862fa41d6e9508cd767bcea8a741577eb2cdfb867b641ed6b451b0b096d916823f551ff2427e5086e7385898b331bdefa034d9c9e6b29e862e6a2e01396aaa02e22ca7527dc7fb7152e797a4c48d60cf96576fc1b71940f7ade523d9a3fd3fc2d140a6f272efac36c131c027cce429d78d2fedb79fc9d315dd0d15ad7c87eb140c00e1089d1b165dc5b0a6f6d52a9e3a1c958e453c35b6b39600d28430e75cd10b49d7261e939f223912521a286899196ed3a7fcc9b45a538a8b9ee3bb8d8675884182cd68e137a292ddeca5d77a022ac62a92f82703864a998292d3af202e871e9896fe813a773983aa50e04694e7fd87a22b03e4cd857b4ad3c070ba135299a64da9f5cce563697fef370bb7c482b2dca3b8c276104ba5fc34890673a14b29f4021009b954ee3e6e9b18295bf8eb333edd7e634052f72efc6f3f4e704c03de7ac0f4727bc163f4ad32fcd907eb44668f0f393aca06d294c4e0eabf904d9bec53e8ec5681aaf7c0e3f452e9946dfe568aa0afc1a473cdf9806df3ae4e7a49d791f776ad6ea4ecdff7375818696c4cd5c3ebbf18552c9a7bc671652bbd15f9680753474c2a86ca7a20dc10f50feba4b5cc45dc11a5b1b8b751e0ec93ec45041f550ec5047603fc5abc663cef08c411abf930888baea3d1c390945196c4ba04750921face42139f17c180c55025acc559f1bbbf3d38723188e488658bce35617c9d56caa4211066015eadc068fc1336109db484615a128a977e9e54c118a5cb5f614ee28a2fcc7f9796d002bbd846118528cf2b7c05052e3feffee04419e25937efe71921374c9935ef86244c750c95bfa6dc56592092d05f9b8fa089b2558f29fd66fb158c25a5d2317ac09332cbd78ce70def5f009f5dec63777096a11be820d5dc07a5a2183321be86f2656449357c09b69459fb62f53dad16dafef216ad357bbe14a0e91af5becddab100c88d4e9aa68b5b164aa0f665af2d814b3fb915710cf90f5e22f2c6d752e2fc9a02b0e2cef375c59b67944a57e439c8274190dc069350eeb05709e0d0a02dbe5b9936818ba09b2b09c07acaa55cc8bef9102a9157850bce6f69753ce47d1569820e678b400b6f9684f91aa3734dd6a834195bc3f2b4d74b5e89a5383537c1c9d9ef2fd81a6b65cad3b6fdd3cff607c847c50a913e9c0009594fef5a87d71e25507194ec29d2a14625b4a3807f1e9b3b15d6626eafa7cd9216c74d99127e5c180c586a71ef0531d6e9623a19f6ab70e70114bdb86e167c54fb06b99e6ade879370d30a29f79cfb6c44e6eec09bf3728b6d5e1d08e6f924c6e9e5be2ba5eeabf0fbccdf1b0ea52ab13ec125dc8f41db9dd1958ca7b350bc727ebe024fc10198071a13760e4de52d8bb163791b2641831f0c203d037390e52bebfd435cfba5b7abf9b69f0230eb9c82a505b0eeef368305e5bc7e8f2c4bba4f7455da94868dec440985b6c32c109441b4e948f867cde37c1b3ca6222f1476d1d16e5289249cfb30970d8511a73bf265cc30ffe3a716d09d8cc1b9783bf7f81b88ce5e973dbc5e784dfda0e6fe4e36b200714c3cbec030eccc662f0468e7b2f58e66b4c4b66e6131e6cfcb385740819a3ca26802e4ac8faef5bb90f1f41b10aab5b46aac84ad73d3e425c252ad7cccc42b33cd290f1c8590d0ee561f19d57f5f21fa3b49659ec96505e42b9e35c7719c11ca1c01f99a8d8c4db4431601fa853c19f8ba3dc28f6a34c06a57204e823e48ada85eebcda15fec4e0adca44b63215ebb2677f292fac37dcbf2911ec112f94f9e438fd806210128bfd63a51a8cc7d67d051f5f10e8ca9d4bf52b07130c216d3bf770fdda854f11f002311ff199b7ac79c087c34edbba5f1fce1d05ebfaacce292a215848f7397f83c5e15ba516735111bb84902857e6c570be004f5748064248451d0847d3e55cb65761b58b71a944407d596d64486b38e754c2e4ab20861174c12bab02a0e94b7a45093d7c5a628f7b3bfd69c95f6277facfc46cf674dfd52d7893c2fd2679d4a94674be3c6f5be63dc392c10ae1bc514f2ccfcf61f1ae4f8536543741e56175b6e0e3313f97894e1f2c5afb25355fa780e2491b70ca311a7ad1d3a74120dbcd05236f3f8f1ca68083c78b10220a19ddae9576cbfa8e4118c1fa354762fac8c3569f685ecf3c483537d280144bdc5e6e421c8f8b1286edc46766b226ab25cdcc6e26f1a71b706c8325a3badc7ee89ea7533d2e3f11482660e0f632faeb2f81e710cdbd6288762e77f4500f44a566c0bbb64a9e0c45a52d09dfc77eacfc985fef2663e1fc18940663227a517d0ee1980ea01967d0d607fae2d9b4872efae036223165927fbbafe183d9fb5b514cd1cbcab50132e4fab37799698bb506e7d177b365055410b6c46bd899731dac71b711cf2c48c95c0da8d80beee9964ce076a7312a9bebdc40276f0ea54c7d4ff57e1b8ac9569470502a2a5372f4069ea438a6cb7d725cf28a21618dbb0f9812cef1341e3fab5bdc1219cba42e011257b977bbcc6a02d434ce7d0eb579f0fa1f5b416e2fd0d389951b3bd13d048df1762226b3a40b2c6349d18f8404fdb574779ed2dc72088e5870b835e529ffd1c3da8344f0b42e2f967e4c18d346708e55e873b2f16801baefa2b3eb19a0c4de2be39ee66d79da48ffedc900169a76ec7759b5e3296610fe8ef5427c492f4c71a6e480f72fcb5f9a9a6d96b99550996fb92ba5d751f5d69112ab1fb9940a5e95bb89b1fda1abd76ffb1048d16def97e5e63cd5cf4d8cf1bfd5f571f5cea38321068de3bcd7f33b595b07d543e72d9a015d8a98abd3f78f9bf5b34518a57368c30ad034b7bf8d7c6ad73069ec4b6330b17c9e6aeb11b62f3cb0aba5287f71927ad25f4432e0a673ff93f347aad4fb07c0752999f6bf775807cb47fed547f65038b9d5bd73b95f5dc5017a7c71b2d5e977771fb8fcbee3bbeb85944a8b4da2778e207d0e045d19a770f60f6117037924959fb74871fbb86198907bc190220e135772b514b3ad664d9443962990bfd34e19cd3fed3277960449ada057f1af9af773ab2a52c99f280aee4f3324ddb15ea30ff6929dbf62de43d08c3a2422104d464f89ba0ffb57678c7de18e033e7a0e86700e97ed3851fde4bb385d5ec15ba0eccd70340580d4b09216d0c1419ef8274106aef35b72641e716b1054e6a01eb633f6b26f1a40c6d2a680194c0943f8341574e6116798b98a40c17f9f6e6bb0804ec0f3405ed0ebc65079d741e4b6220169bde545aebac570d6dfa28d8bb673d12c92ca02b92443e8a8d7ee0d58d4dc0c6131c928479b89099c69c55a0faf9d54dd90603a1c9aef6e6fbdef4ad5affb95ee1e68ef0ab99d63b054a06710c6e5208eeb5ee66bb4324f58fca56819b8d2babdbb533e704a73ed4c939110b55ecce95fcbaab74d70f2533e1b8989b5816d17caa057d578369d9b2e505140bd2a9159bc72891549a72dc0d4d79809bd8542dfad3a0ad4ed4752ce704b3783dab484668e30892e8403a5e7cda15652ef7f8af938892a6be3fb277633aac2faca602b7d2c5a9f505c0eb7b0eba5e9d2265602d87def048223e087b560175708527a10bfc2d6974bafe8335eb91bd9baf8152256fba95f4d7d2f531fdeb9049874ed9c4c7b3684acf0d129ec2f6d8019613e17cc1ecdbdbc91459795eec1936cc02d3750839d0bb1da951aa60575f717ab8eec1f393ab18045924f376010499f652f5cd6ac0adaf2cb268fce4b0eb64bd3cdeebf38c357b9ebdd9655f60e590dca1a585bc9ad8a94d0de721a0db9a712e86f2cc6dec321b2822535d1c9a4d1185f98640eaf9418a3259ea86b92ed0e931ee96c56c323216785512373b6dca7a7ac2ccb82059452b73d6f3567f2c149ca11a8575960a8260759fdef6098fbd816a87a5e6dd23981c5c1e14956af017095ab71b0b1ad5342fbfbf293e9347e3704a99f75b480fa58189abc815e9e3f13f1e2031b47bfa725a606b2ceb33dd6c31943ad8dbe63bd66ba90deb4657f2df5d920643a703943216c03e51178c35428e630f00837fc4d2882bd316a7631edb53ad886a671b7546a9a65a0c18469e82c19a09a3defd3bd8689ea17ff70c8ea3ea3816730c808e6c6f31e4c1cc637e2ee7be55f7c31f0371b647df04d63611bbbe79d0f47f72cc286d02bf599d402e27f4a335ce0b2dcc09c36c55c833303d253b098195b58ce44491b7b05a9a4ac5a4ffb8f59be17d404a46c5544c0c2646c40e475e0370c0f323990797fbe7bfc7f1ff69fcaa11353ed01932dcfc4fda657293083f3ffa3f34b809f301ac0991db943f07134873aaf4d020bfceca17b00361d44e44a52a31ddfa04d4c59e0b49b12bb52a9d475de37356c7b1ec66da2652cc071c13045ffe38a7174cc502cdd9493c1731cb4a5b9d547b02c18ebdadeeaaf2111c05e38960db84e194bc59de4d8e3e46d3d863c2b4a33e4640547f0ddb677fa75dbca6d85c2571174d6ffac306bb315478c73cc147d5ec35a9e951798fc9eb2f10047599d6ccd9a5c0b0f352fac42718d957086a6f6d442f472e1caf3dfe3d04a3024ceeea943239226f64e2fd85645cd6310f980c210bba8ded62a43038412cec80d749dc0edeecfeabaff646773253bf635cd6dd5406eb87e47dccdae6e4b588a28c22eaa69e133ab1c280173744669553a8aec749228bcc367094357beae387dbe2ca21df9bca830e9d9e1ffd4ea206f539f9b30a26cf39092d1ca27506fe19aebe8a90ebe240e4bed9f815c5f6f2b4de9695ac3c5ec83a57017a21b8ef9881f94f30dcece5456bc680dd442ddb9213ee15e32d06790f81c2a2823dbf6f9406d75911eed4f4619f4cd95cffbb03fe167ff44c1b6d97847851c9ab05611ab1c7555b57a7b25cdfeddf1252fa84978576f802fde48465b340e791dfd2a50ae2ce6cdf3c0ccaf52219b0f7be0ecc1d29e979bdbe7244f3b29cfa386aa0c5c57d7b77cba8231dccf28b37ce00d5b18bdaadbda66e0db8006f9c6f69738b7c4c6a96bbf6f9b1eb13573c520fb8a1b95b363425230a93856b0249d31859f5c94291aab731225c8b9f10567505b6c040bc5653d5b143e2a639e0fdf708dafdf4036be52dfb3830f5951021abe323c493ac4366f075c752a994ac50a861a79d2bec24083ad8901cd9e9658504d44dd9056f19712d7aaa0d85ccc67383df2dfe8771733b7868c3ec16406bbb79196da8c3093b5d5f69eb4528c42a57d110302e1985c31b9643d110db51be92e857df5fa1b70ba90ec44821aa945473c6814ff60110ae7a346d97689580b1fc5274d0b947787cf0316e78fc7ffe93b009389781f59c15ef5cb4f6d1a47e187370ae0ee5aa4215b26931771e8d443cf47a127e41aefba7074315cb229a55a3f76a42db625834c8da1ed0f216da4e1c0617218522aa6f895bf3a88ab89fd1d21e0007503ec8cfce4d3f4875495c3c7d02d606907b7791ae11e55d73221ab013a6003d0b3e122a201e690b953cf8c01a9471b49000d2880c2fd6d15a5866cc32db73a123aa87018a35ae3e75b98886c433ad89e4f0a9525667b7f8d7bfc401ff7da4b5a0cdcf6d2efe438cf15f69d1e03b04a77dba29961d4b9d2527383c93f505be8663d4e9b27832983844ce5224dd647c0cd8f588427ef502c3479c6d85bb49ce72575b384d22087fc3a1e34078d693d4e2d470402bc23fdb21ffaa6e6596229c73332586338276a827a8ede6ab438bcac455f5414714c6a04ab9c55f0384fd2637edd2cd39f02d7e59c31c454b28ebf4c85009347e6582a940032a518f323d0b9431fccfb359d7652d348cb2bda0566040b05be83336adf0bc72bf997b37c7be23db1e527365cc558d0783f8d3eb131188ce4585e10e32d83d9763d2d0163804334ef9236baa2327eef2d6cdf9f509dff7be661424ac347954bf940a4da9ccb7e44b81d0cd1ac80197884081bd46cf5b588bbf94bc640b77123e17a756eda1f05ba67f4a2ee688ccf85e6c2389d4a95ef3cbf352cfaf85811ff16acec0e31e89696ff695a137564f662e577315e47764b0ee5d97e69d004e3295d6c136fae0dda29bc09e7dc355c8ad89b73d60ed24f73cf7f3fc2774398d761c5b9dea3fd68bf62f40ca5eeed8f79ad1ac6406e970e8c8581b7d2c28b71ca395e18df89d544b2404801db6d2d1ce8c757ff05c071aeaddab92b997daea3b5bd31f3aacfa92c2760bfb3cb72f5adbadf914e8dca56adf74024387b0e96c609f20c33066eadb611c32b44e68437835520c79edf961422ab2e4511c7a20f989b18789b57e1ed915f212a6d384a16f1dfab7cc3ea44c2849492f9b0a888c1d69179833e79c1600d0abe4524412e4a0955e02b5a4afed1af472b0bbfdedd9b9e7a6340bceb25b3ba577a701446b1fdc27413f805c4990a3989910d8005f2f673e396dc61aa482b9b2bba961267fe444bb54c784ca9bcf89606e18defa96cc986e61562f0c9f88f4971d59c42363ce787b326dfbcf74b72be9ebbbf6cca1c35d2f771a848a47fa181e8cfbffabd22f605898d689962fc847dd89fda01645f411792af97d2e7a5f58961c49239ef46cd2ddc128771363bbec86025ec2a3cf51ca1eeae5125ffe294fb11637e0272769625a8f750a8d3cb1078ae7a2fe9c2ce6e56295e95d2510f4802b82fa3447cf10a6c3ba0286bc9a1a1cc9e7f0f08f495ea39c234610411aa0cd79cd44975d5cda7b4643ff7df28a317452662a751b07dcb15a665a7564d7192654ed037356ba0ea83fc5933cf8e5176f5ec6377232a9f8e724174196bb33a9280d619e0b838b0cdcff76816454ebc639008bd41ee5e5125175572d63dfff2c1667ce5fd2852ab34d7b916d11549beee9b4a2c5609eb9b18b799f69b5149ea2fdd12707dc88ae4b578c6dc71eee2e05e5dff0be4d5dd332216f24d87ebdace0d1856d7a58e9772860b5be3b5776a357973c331a245c20e474e23b24bf3b6824d2a83328015b9c4953804bb5a21fb8a5714703700cbfd4690f1e875b571ab74508c68cd62aa21381b3ec8c71cca6c38b81c7317862f6e73ed1857ef2e6a9cf533c28fbeab1e0dab642a987cb09ed435cc6bcd95943ec37b31034418e6d35e6326021476fc98a461a781aa3a6b896cd83d09d9351f7901d8138cf73c152429aa22d2d8e5e761ec6bbd0bbf35884667e6f1e36a23af8f8944230a1dde155100f5ff53fa7d49efa2d9dd7c2da926443faa8f4d627abac5070ad836bf47ba7a6e481646b7d122f8f5f76d237cf9996cd02047354b8a215d318522d941e32182d2066ecc0b0872a4486f9301c763af80bb23fc04e5166e0ac4b6c134ab5c2ae8a24a585fa36e0bb909bc80bd5f0d1d49c88a237665cff53c11f71e4fb46cf9615c98f032f002ce4a860f5ce897aa1d01f1f6570fbabc22233980e0f34991cbf584077534e974f9777466e7a3e8791c0d94dac6be0866d2f1f4f086d302f9e81c7d4daf6ccbd5506049eca0e58935ce141f89fb2ab5fa6bbb2e90b163d4af641fc9ee9498adfc15e41d85340bb66959c9494bf2c51b2fa1e4b76f1fccc790ea94ea0496a9561c8e4caed79dedad6a42dbf61a956f1a2e347202b392353e927b92b212477d5d13d8fbc911963d103c6ef70269fce8ce35ec7a6deedb795c29b96f1e66248b191ea9418fdadf9dcd643a14714450485d3e0d672e5ca05bf2fed5ddbe1f5ee02c7907e0882ac8f5548c8c93216b3ebefb0fead31dc4610dea8b2158205b980560394ac525d0c2bca34900d4459a39ad9af64e5463a4fa1162ca16a72f6f2947a7646ef1b888bb4ef9f8ddb6beb65fb28722b80d8fc69fd7a67d869521525df78ff198ae2ab0f409b8e46385d76350d32c4027ae5a429479fe9f2372c06d3c9e6d9559cbfb1b5a09daa74850a2112b5aa5fab12e5f7aee5a5561a78a27b2e9d4e121d9f82dfa096d3f5c23d59bad8c0c65572472f7c741ddbf7ce775bae47fc5fa2e994ed474d5205921cd6edd827866a037cd6a473361eaa52e8ba258b22e1f1ab8251af8187a2367fd34295ddff06675a3224f84a2ecc3a38c590a5460643a2d65f65e47d14dd325669f846ab47012a17a336b1eabec357576835980ca37134c28ba58a6b9052a4113612865b51c43ca24bf91f2aec865cf39a2e06860f912005d0b4a4d99906a68c623ee1fde326acb47a23245f099a05cf80838a45fc8a975f172a666d7fd1a019bffddc1bd21dce76179da2101a4b1c9e676572563c550c952fd38898dccd5a472d3deae7ce78e809c6af78c6b692a65fdf3515c7fcf8deda1d58cc65e6ed9414f83a8c1c09d685bb9ee871640d920f4e19059f459006e14154bdd060726ac8e0be87a122dcb4b6314be3049c6b7787b31e5f372de962cd91f441c1bcad4d6fad63c524e98e9a1ccd115ee95bf9c6323a3a4482b24f8c5b0e7605b9426318372b95d2c57bbfeaf4a9cd3ee348d96b32cee19380adf3b33bfcc7162dc540a72739dd7df8ad51e13e67104ea36f425cab841921459d20558faf0838c95f29caaa23454cf4b5463178e265706b4fb8a94226e7ad7c5f2ade209064686c5f83319641af7f1d9fe5fb9459d0c6bff10cf944d65b06b2307084fc9308cc76c4612b5481af72b477cf1cf3d83b337696fe7f56d781edd9e841608e02e014fc81f85e3369cdea61ca480c19008b10969280c3bd13426192fb60bc1d575b33cd658f8487804776ddd58365890b12bbd235f2558d0c800fbaeee8010e25bbb83555a893cb83f163c5556e5af1e5eb03b6324bca1d06ce0b95f9408ecada5a37d92bfcc458aab4f79c0e1db3ea162e9be48351bdc85740232cc96375a0f59278e4c5b59177f9adc892bf6c05b05a02514315d0b6ff64d2676ddce93b626a6cdcad3a43f0e6307788d859b6e48a8aa8aed2d11a60181a3ff97e1cca1cdee563c35291800c49ca201a1fe12285fa7b032cec2ccb674adc92349ea8d0b666a67fb3cabaae346a2d5272d9d70b1e1126aba643d5e48eae25981338ebd635decc2065ace5e561cf0a176f4c24fa438f8b31dce86faed6a515a62119349c94dc06ea1c040b97a0c8118991883985775a2e86b81a8a39f7cd19e1eb6a529d7dc39b04d1fd3653ca8fab52b317d880d21b816ccbd9e55ce3d1c46ff01c617021445d32015aac95a632f1ebe4548405622239a4f20ffaf8d30cddfe3487eba48c0793e802affb886718aacbaaf1552e572e957058d706e730743c3158242c2e640c7d068b86705dc07d0d2cb91dfd63e5857128ac875e7900d00792ba8cad9edf3c5ad5dfd75a50318f9ceed5a76834deef295caa1f7e86f26208525db1b3a2885545224023b65cc75ecf510457bbe091b8449c1e1e946758dc8897c40636bf08d155bf5aeb52ed0dcfcd7f61e1fab0dc0c08b0dfd0ad1226f0f61e32471dd680180c7fc197bf8123f2df45dc3ed2dd341d88a10620722a4df148ab9a465270b7a1f274eea91e3d045953210611dac1eccfd97336234317e1ab291c9502c8c4c5a245ef7c8de4b48771a3552e2c8b9f22a3538ebfcf08778e17275d98d116344189e5ebbff14af1248fef8b6e9c380b588f08f06a47472158ae6753744e6c3e08469b69d875cdeae07f4efab563cac805e48a08271f1dba6b8f5622b1612278b55bb91ca6f80bded082ffd71947fd676df8ff954bdbcf4e79c443da578166507bb8daf9565a6a39df4c6e3db538044d3b3e1806bf540351f8f99bb2182f4b0b7a79a16679f4d3ee53e5cf04e7cb6c3c7fbee2d00ca1602b5c1738a6f8cb45b9521416253115bd14602c9339d041b4433b2ba26ac14f67f499814f0e892726499d46c3f90c2c3e4c18c3ffddcb5d41e41a991062e51add893ae8be19bf98e4eef20b3ce20adb41f02c4eefd338098da78bf67aa69614aa00dcb9ba084277e940614716928846e8777a8731fff1eea1aa6d18e851be59beaf785b6eba6abec957a35063aff5d084806be76912a9821f2af0d264422b2170384b89827a17d944dacee381e0ecb0e4b2fea104d3d20c8f942a312127b1b919d47a32615daaae7bf159d883bd4ac98d24d69686689a15833c61e2448376a95d63afdce23e58139839e2500f84f74419dbe209d8ec8dcc3c9c7471eaa07541dc34358064674e2247acae07cf5ce7688689c9da5ab3adf7334e06cfaaa8f2e192670017c0df4a564390ef91300e7745e5c283115e3ab7bb698cc7760284dd1065f606f44243dce9094f664242378a6abea73e4a28b6352353e7bf33249a2027b7338e8b7e2b338255ceb262090716a2749361ffb9ebfeac9ca067e825d20da71fe01fa8bfc12b2542f55b404f29bf98b104cbda68ce8e9d301b271c6497e7040247b2ed5a98f3b5314fd240f41dde3becf9c63a49f3979a996bdac05538f530bc7018e337c37d97b9a61afcb263e5e2dcee729cad2d1832529cbd8d25b9fb63d79b1924577ed7dd3a0a03bf77151a0dffde6690f4d0e5db6186bd56a8382a82e19c3589ccc0b2f8e2480eaa1f3f7076067a6ca6a287af2707ca13310a7168168a2a0ef39d5eb77b172cc93b9c1f11814484d575582ef5da25c1e4a49011ed3009554ea2709b3305e6c34b79bb8c26ac8315c4050c8e88a82952f05a63c081c036c0322c1f5799d6b6caa4c638d8e394e17d8ee4dcac0f3c9ea207972614a73c572878badd5399466aa587265c4a5c1dea793b4062755a7808dc8f662046c327e0823d06387395022be88d664d3ed52d4de14f9de3b8f85848adab3b559a4d3a238f46fb54c0cd3b79a95525c2850fffca83cc56f34c5b1544fbd372e76e79c8086d3c11a8c9f113c6bcb66598e69cabc20e01e24984c4625156564ab22644941d8491420edae652a56ed7b60c786f94a6618af9d3f8b7507c28df57be2029e22840fa88630e53394d74911ca7afec4824f416b3f5ae512b3640458c5d8e9566784ff0a8770b09d0d987d5929e33c9943140b342d8dd33275cfc8d173279cfd0b82c84af39d5c4cdac2e9e06d6fca1a42f046ee098fd5528e5d41400d77167063fd409e8d1389956e4e92a8ccd42c907ccee625ec60455e8c4f51938191f3ddfa5245002e487d19d5f1d69148590a3a8f1cf14180ce23ab079d7a802cc002821b0bd82a7f0413eb2ed475155eadbf2881c0b9511b83b74fe20fd5a0ade673d1598b53ba115a0c8093e89c86bdc8c3c4e703c8fafabb1ecb102a06f9573cf669d9f7a12fa8f4bda018b21e819623f5752a9f1776af7013a8e8173c73ae62375b5a315296b216703c8df60c069420d3e74e625db850862000db394d10cea72d08239a2e7a1ffc8f5d01ce6825f51d5e30a453733d774e655a1e5fc4589de8c573f480713104829c63e2c41bf580d1857f5f5077cd141f46d6c14a3b7272ebc78ebb2b83c02ab7a2708d95456d1f1d25c8607bb6aa85ef5aeaefbb5c73310eddbb957489bff2080b6b363bf62efd8fd5ca5b5f16a7eb6be510f6d94b94d727aa85a1cf43d297802203bfad1a76daafc18ee01270a1fd5325de9aaf98315e5814a2f379cadd70d108adb34fac3c82e4ac155fd1c0012b7a0813a6eb99d51daba53706c4d77965ca8dd1d7eabf64dca335d35087c6ae43215713c9a2e380580bc4af73c361b4bb35a1b9b1aa7836f6e1c6aa03c07459859927219a2945294ef03894c2fe343fc7e9aba874af05f337caa9024aed1894b70b4407d98094be74fae2791075dd55357bedb61f928bea9e3f283c594b580fc81c4d88b1b6dd4e0b11e81a8939c9a4debe1354d414b8c2a776cf8d30093142c95d12ac08b46c2593f662efe00c5289db523eff358cc023aaae531e7a0d53a3c3c511bfead454ad9c663c60a6ee05ce38ceec52e3b903923bbfd194008fd02b829a462af7c18c8c7c5b49846a7a68c374d059a7e47e5fb5b1794bf967a9d00a285055c9e1746a41e1ca53900c1a27f68b4d1bd97db8396e16d6632fa8f2194b543bb31de0fad1c6941928222e36a3646f759ff50356e19b5f6595afd7c533df0703c98931b1128723a0907fbf0b19645602300eb16e7a7a425a17c3869ddb74a644b7d56183ac03276095466e55a59b61f4cf3aceb75a00a2bde1d4dcaf485e17e1ec94dabd40e8aa461471cb1ce9e8bbc6522c8801f7101dfafce15c6d17e22c1ec3cb34f969944900a7d713798f367d7b4f586b4589db3fd1b8632b0ccda6648bf852658d5270cce0af0137b6c8557eda520d614645d108b899e20ab6b723217c41b698bd01ef84c2ac2c019276aeb8aa7310b7a0d27515c901df87cd7df89526fcf662aa2c437db3bc15b022e8a3a82592047b4e48852596ba313fec0a29456c75c0cbd7e57f0e8b0bb016fd97565a543ed6fc1f2a79b71a242dff4291df6575b3b7f76ef267788789bb420b81e7c55eda2eba303c934e26e99dbeaff5f9f0ab7309c7f97600aa9276972d25b00cd3adc7c21775c54410a7c6974d224f814d34ff4687fe366aec7083808bdfff8678b67b2f6edb70622dc44f6718c9224c873486715cdd99db4eb396f442187fb356b0783a2ecafafeefcbe48ec4937e904d4f8bfb0b4ecd26553def3295acbc1dbffefbc9984444668ef7319a994c707986f145e4e31bf045c0bc45e5171047556a1e1f8cf40ce7d002b42d33706fd441ef589f3d8d50f2267fb6f2cc4219e0d34070dba299d9db219a32793fa68734945500147d1aa4ff39cb54c33c77f1e1e1ffae2f8f384c9e9dff6ccf0d9c4914534acc62b982a6d8dd33bf5bf488a9e1ad257ee0b2e2d6ca609b25889befe70ebbeb87f0653162a397223646d6a17325679aafaba985352706b20bc55f8fbcdeb8432f6de63b6a31cb40599efecf0f435114f3e520d4e3ba8567671ba3c347fce0abd2206f340ead6d653646ca5a9f2c40d4925cccba1d96c0d4ec78a88038e43ff3aad606c23f8c0caaef8b9913f70650024939b964fee4c69384919d5074fc0a4eff211e001e2b6fc80dd34784487067d6fcdd4d6bb9d302e3276112473b40fe781e62bdb25a7d3c232127d90b04cfaca04634a5958c003d65b2162f2a580bfd7193d34f9236d7ebfff42ae6f09bb2570f8d8144d53d1eee3fff810987f49455475775d94d439c6f2c848fbe17db03a3c62b3259ae976581d2a912ae9c780b0cfa2b9931edac77e25a03d24d31f4769342692d1aada69fbdabd54ee438ee206918a4d2283e27e3a81923e5c838ae185f79dfdaa0de050c55d27a083b8c0d387a171542f3cb1782aca43d932e3a87e6aa124a8cce7b5c28e88ff1a82248163bfb7ffed39c2123841c3b638a6e8c128a03b4769ad946ba5e31d78d9b5b088dec6ee4c71e514a52c2ae505ec1e4f9a0e69ad029a89f7260221d7ea9e9339ba86a703b3482186a255d7771d0f9256de611cae5c1316a973c3a0a6ce2201eda860d060af40e06f7c8850af398a6dafa718deb2db6abf3ce6b2a718e8c3091016b35ccb1ddfc4654deafd5eef6e1cd197a941637cf3f2739c597d86921a1b6073192b884c4e88c619c437c3add4bc35f2041c6daf3d5877824770a3ed0a2ee65c3060c5a4adf9f5e89a6c11861ff35c6c48968df83e872c0b58b09ed3d5dfd3c3ef729c29ee85af24219a08b0aca05244c93e8d8c3f1b22106ffd76367f204e8bdb0d599e6ca3d3c1d449b5c936c5eea88fc21919854ebcb79ad4776f205ecbbc7dc71f89e67e3669386019414046ee9ba7a53ffa551e29e5e0636b9176ab067a4eb78eb0ac0c0fdb3dd526c9680ca200aa524bdca074fd5e99676b611d8c75be48fbb548339c2d57895626984c320facffbf519117399c2122c7987be016a7c5f684b409af23a536d92e9d2e96ab7466360d2bdc43a5458062e3cb27aa889ff542839d675e8417f4a772c42b934d225ec55e630475d4cad29fa3583a7b324b81075def08da068b4d47c03ff1790b1bd96f9dc8384e64c6c4c1e44271541955fa2920300efebb5e309a3d0395a2f5c9f9e771e35ddbac04269d1b071547554c5be99b716800ddaff6bd054ed8b0b90c3eaf29d6ac4d1cc9ba19dfd9b64ec74b5db90237c30adfc1c467d1b9fdc2e7abe3d62c76e4a40e14222579d98bb263e1aaefd4687d6359adfc16aef02236721afc57aa0dd32f29d840c17e5d068902998b86c5cc8908d8a317d2daaf2ced5a84667c42256f6943058331c7241ae965e037e871af7201c32942a1ec2ba8a74e5764a1626b82fc001a6db5c8e66ae024075d1597fe1783160e7c01e3554808efb07f236ead0bfbbcee6371dd3ffc1f95c4247e96ee6255b7c756fb10d9d84ef70a1b8c8c7e6c5573eebfa3a68e21cf61854eeb21f5a0fccd0cc6879e867a2c3912330ff12ad3d94365a2d0692aa0b2d6b8dc4089b1e1ae1ce3ec00dcddd69b899097de58c8ba89771b55c0c445b1ec5281da2403da50246ca1394515c0ddece8667e0859a1aba3f91da76e282a88ca92f244173854f08055f5a78bbdecfa978499e03d4ae69602cab627e42299dbea99518e10016871fd89809c066370a1b3f90349c6852979518cf1be81dbe0f915d393197d0561a8715c327781635e2b4334e5ee610aa0cdc5aecea171ba7c0d50af0042f147663e5c721756567ecc96267a12e712dfe8879cbb8b861646c85a7bc371c0e14aa702f09e5e7354d7f101a9b49824660c3708514b6e850b7351d86d9b4a8c5f1666ac5ce7d35716ca48be084d2df9482bd432830b0705c0bff631c607945e9acf4e77dc17bac29da4dd06d16a6ca79b919670f2a9b4f1026d9d809a15da2b31ea53b0ee60cc90fd0ed2b0d3b78a66dd0188bfb856d62466f5c0f0b2a74ed18eefb71e45aeec82e0e03b1eeca28610351be05582c44ea0edb97d9692e3f512e80fb17f985750d7f55a7b185c9c39e58180f2825aa9dd2709a57903c28dbefeb90b34cb132a5563f5308b0220667c705eacb9f822576e3304261c4b3a3303106995576aeb148a3b8630992dd10c4aff8f4da4139a92c1d82b2b9c43aa33a47c8cd9a091bcbce9faf96dd6f137b6b1c14be4d82e5e480cc0025610d9d8b573e700ba99380eaf5481b905355c13828b9dab4b16f535c0db2c4cf31b1381d8525fcc566d9ed0e48e4363e03b204dd97c2a6fdc2aa8b53c339dfd68d56d9ac3b05dc0b2c886bf24efd24e5acdb2511b6916185eb0c1090fbb45bffbb328e99c34ab9c7341b39dda9f090fda0cd6bea7061a24fe478fea7bcc326e4becfdfb06c22b61feabb3ad2c6dae55d6e0202f9fda69fc46508812371944ab51ff1949fb4a64d5074bdcdd7a625fed0dcbbc7627719300d569ffaefc072190bd4904e79f0d530d2de47147fcfcbbb71e452dd0a7c986b9fe7aabfd41c33d14694cc794f8dd7aab21c281aae5f2ba9be858177a5ea3d2d56b3265fc836c41dc696e38ece288df3771b0f53b7cdf72943a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
