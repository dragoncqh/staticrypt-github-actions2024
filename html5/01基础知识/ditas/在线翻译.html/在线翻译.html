<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0775827dbe40ed0c87ae9ab0cba36cd19a29b32c73c755950491289cc31ffd736d11053739bc5c7c508902a5b1fcd523499eac4f8d741ce32c28d94b67069ba6de6a782605e00d1775f52bfec0ee85d7ff3434bc178488fe3e0d41f8f43cf5cf9a40d72355d80bc502755abd092c090a2bac4faade5ae5d01ffec4b5e524a0c2a1e69a22a59f48c8468293daa7b4cf6395006b99be2a8d1a982b4a1e21af2658f47b2600f559b1a030e2c605ab23f6c314d72aef6dab44fe60f1d8965a483120f1b8249344f430a79218d80792cb4d722ff4d2f7d5a3094ac144854c46942e24763b222831ac3f6a1fbd8bd22d421fd492dde6261fada71cb5b7938a0571f5a40436bdb2d9572d4c402634dcc0626417bcb7bd37c077163fbfa4265517dfaae4346b373374c7987199e53fbb58a110beb3f2b77e0b9070bac5015603a95e6228315233e688da3cad645460d6ebf2cbab76e26274017f13eeac7a79b00b3ee3d6f32a67c2d878cf1bbfc7989436701249f0c2d11607d8d5039e4b996b3d4572b32bd3f86830f92c1a2a31f8334a0cb5a4cfbf2a113876662b3ddfd5470e73e0eb1487480e17ffe55280e6c096eec7540457d61707cccb2d4145b010ae9abf48c5c655534780d2bc0e6e5c7530bb8b2b5920a93b5262ecd47e4b045f0788efd23cec9d86883b8383fda405188725363d60b5dd0e5a91ecf042af5d9e5ab5011077f4bf32777b7e225965d91ce52d162cf3408564fc7728956184393398e324ba6342cb6b2b0c1c72f34223ebfe586889e73846d42af25e5a1f7147db2b32bfaa678c5c059f758e655b776713d49584a41ac593af00bf0461bf62360d11ece86a366289a34d1e237613bcc94329e05d715af1bc450d535a5d234606cf6ff3c32fc4f9c1327ae5cbd1fdff8e768ba08b3a013b02aeea5df695548fb8515652483c3c361c31f8641ec65c377b88de3aebed4fdf970e55857d80dcb5e9eb1c2d48caf21dd5bd5661b7b918f5d4d23aecaa00a3a2b626a3ed7315b98b9d98387c0aeffce3c758f66ae57b46b10c116cb48fbf13ca09382cfc85318e90da773fa2ca1f8f42a07f7e45d8270c2eeca371d3ccdd4ac9c1f0ba3e4f184213d04d4c561fb6b5c2946b2a1bc1560927bba5a6366ea3ed83452a56d2986fa72714b75b726e584768e6594b3b1d86bd6a6a1748807cd65b126188c45bd417d98e4bc1be8ef0e7ff4b997396553e73498a6686b55303e01f653826d38c4119ba9a809d89d2c4210f85f268ca5c8ed4bb8825324f8d5fd61e268e736a5ff089c72f65aac0f8aaafb82315b0943568b7b02cd089a68491bc8bedf6b358186028b4ba19a611ade634fda9411b3a2b36058ebd90d19b15515dd90dfd3e27288f97b9f2d11ee41bf3df8f1919111fdfb3efb88691f0905e6d611c8d312d6e62d3164026e5765fc7ab0d210938d9f8ad764c0d3926bbd006af50b981ea422e10ed5247b8dde53613e83e4bf7f5f66d7cde7f15c4f1344fbea2e84d90ad606548848cfd97c7ff2a9b97cdfaf200b9c03fdbb81ef251a1e3e56db68072c08c3732ff7ec97a1f3f2f8681b1ea1f4d4a63029f4db00c66ea9fdbe5bdb0479adce89b00edfb53b2e131f86c0159aab06e0cb3f3e43feb0a8a91add2dddcf699fd98ab66c85cfb6ad44a35093871a7ba092038f66c595a97d8282dfbddc358be19990f6df95838d1d73166afbf31e95606274891dd2d587c208412e051dde60d1a70cb456141672ba044e96f07b9b550638e10f05a24d77c23e9a97baa07fb86c0ae6efc256b805d2a687512d48c3a4e19cab382b0f9916729239c95c53fe7c3a3752dcd306863d05f9ba14a5e303f65b2fa302a13391fd15c5758d931780865424d1e07077b3ed14130815454116e236a74534239146052d75897745f2004bfea742c23b7d0d2d6036d9e95862d1f6d4a71113536e594ae3d390bf7932aae909bb5e51044186d53aeec54502da2e91cda4a130b1a837581d27ccb1ce1ca67c7723da64ee9c2d8788a2701fc23fe26a2c35a9d944ddd4404e914204973e79606a4ccfcec5d2f28bf9dfc1fb1c07f15ebe05b37a559bcf00211b5f863086e5fd08e56105d9001fc7aec567a2b643e6ff92cdb4f739ab8754e2271b1b1c0d0cdaf3ce689ddedb240c04d33e796c1252ee260d5984042f1c058eb71d93bcc3411d35a57789920da1285d988c7bb5256a5a94124de5b44bfbf934183550ebfa425b2605c1dae50de318ba24478de162c8aecad4a21d61bca189cfd8ee8036d87c5019ad2d6b677ee5873a3ee6c5469087e82a8db1507e80c474f9642ea9e67b79e8737dcdbd9e0a466b7e6c1d9bb276338b3a07175f5c2a67f5bee799b95fdc3c1e60f1c614b6220cec3e9e5d85c2d6aa2d8289953c7535eee99857a6742a20f63c69efd6d87c5f1794559595889be1ec3a6e75842d16f253ab75f916cbbae8492b5675b5c8051c4ea0cec4d488cb9aeedebe8f381b281c209b326f8974c6ac1e95cd98c4b934f494835425b31b14132bcac473f0fa8c2145c52ee6264da30dd3d7f7b2972fdaa6824340d805682de9299aec633018b4409812cab004365c2365f8191b8d20cbb592748538f1f042646bd2ec7321b0087db044d4eba2a76576df8d8481f468889158cd29371bfe6731a55bb274f74b5955248d55859817737abc84b27cace62ca6649039a8dbfc2c0165abb9d397c72e3426d205f9497fc68491ab0407fc67efbea0581f9f26425e7d80bfcde9332a58e3204e65e922f9e071a78af74dea1abfb20e4fb459f4539bac14277f1fdf00c1f5ddae0b4691148bc6ec7f1b2d9577089b27a8127d25b382bd32c578be617e5b677af3c8635de9879b52a3dbadb2ffed6d8cd26323960a9af09bc1861b327cb89940246dd6d81d4e97cefb53af247182ad7013ed7d72cb7046f074b68abbf1d3cc8f5e5cd8afd148912ac2c3ef86c3e4c609f59cbd4e401410c03a5a597c3181b47a2458b0380ebc8e8d8b45dbf9dc3878b9ed40b427e7adf8de2c7a3f338ba2e37671cb6bb6154909de525b31c01d9fb943610c1b2f20942ecd597412f7e20a4a87a238f4ef51638925c7642beb8e6aa42ad2914031208a24e1cd39d8599ecc1aeac0d3622c0e7fb2c74e580ff70640d679d1225088e669d694c6d08e699e3dac67a84673bf4555c6fb2581328abe921cbf856b588dc607ec355b379267fc155a54dddeb47d98cb9348873d0c349d6b3adc6c068c28b31840a7aeb608b1ee70ce9e30e9b862f07e8ebd79697c9445157ab7f25180b4b0cd41ae5289f6d4043cb32d3ccc7aa7d1525f47f67b2787302aab72c9d991584e9245b9b2aef56f7359306d014088c7d58499c0c5c7710c2f3d7f3f3546d94b51dcaf9f99c2e5672a1cfd452da46ed72517a68ef0162f5e75390cc5bb6db90b94e163932cca7fc2dbd2e3c4010604529e69206a97d1a90d8bf0cfb0dfc6fd3a4e01233c8a2d6f10ff631d8675ce486c8673ca0d05c5e4f56dd6b70e4a0a46691dfe9d804b17be6cb541add2053e777ccbeb3bbca213e48c9da0e19b3ba8003c1cf4483ad2f9a0fe73d73c12d138f73665fb442f90da234384981b1a4d136beda9038d3abdad42cdc73f8dd735d1ab026a9f4fb3f24c94261979e42688c25bc0884e0b6ccfa0f4571ce96ed3be792ed553cd61e62b71989d65426fa56aac9407252865f4aaba91488ded5865824e55d3fd440aa958f9a9d883c77d7a54baf6381ec3cf85aeb5bb6ff6b5322884e4714b94c3d30d7470d6b3ba8a26c78adf74979861c3d86668aec95b01f86d624502148d9a0d25a5abe9219ca0d2bcbc27be5b9c8b20843350f71e7bb78ad054b54109849f86f9014539a7f001c7afd7c369c06fa65222bb9f8ec2c16d96e53bb42953302d40433535a0f75742f4e53b61425afe3de51aefac97b90210d335a71bc68bc86100bfe4b3b2ca62410a1d83df4ef04988b46bce5b2ef26e43e03d6e3e4e00d90d7c5bf5054199d949bc373a4f96779647df67d9211d5cda687933dea85b1c200930f8b90be6d862f20b579bfd54f5eec8ebb985ef161e693a83abfad3e2b0fead643d35ca6ba33f02d487e7e1c8bed9fa9be164f21e3976e32d90a517000f215cc5b9ac4bfc58411701aabb3cf4e71a53514da9a7145819c5fb8d2ff60bb8c04719bf4e4bb229648368867729f5460a25103a2fa3c3516ef9d813aba5c885af49d21482812be3bee78c8137e939f7a78425f76c4fd1398e7020ccf6d8cc5d8f206aa613ab49e8257b049e8fd8692ddbe5eca46bb8df7e9bd196b83b82a681fe118c3350ca621f18bd7a6ded25cdcfad4054bb2cfa4447080aca33da4000b64d2e3bf055b12fbece73f9fe7757c8f3bc7f75a0a8affb48916a9a1bffa320dcb1e1bbeb0284523a264fe03c7972600a548f0119512cb968c8563678c9641b382ea49ae8676556631dade265ecc01e7643be7fee482ab3a965a3553a35d9e6414ef463b6b62ad490d5063954e4b3d217ff5a26c0efbda39376cc2e1af49095602b63053136e3046623fbc9dbc8ceea9aa72a029c7c1915f3ed80ab915ec117594eb3ef28033abcefe7dff6f8fbcb34e960ae579cfae559e434b4bac9003f08d9d82fc2f21585756329a0864e998072cb983a1359910e14863a5508046a6662143764155679889e6de666da99ed852409494dcede1e038db5a8630b78515e8d46d26be0a15c65e29a029c61ad51a7dd9d7df70fee15fe99d8d40e198bbfc698e29b829f83b6910f570471ab207be3d70bae510fc1df8ebf1eee968387d2165c09da85c672958d884bd8126acdf18c59d7844f203d758b63f669f315a8aae667231f3886473842a21177e1eec4e28f7b1f3bf45e48f2ad2116e84c0d2bbc8e94aaf91bf51ef63796d4ed950ad2dd2a5819a2442129b3340be0146278a1a438dd07f96feb27fcf3e911d2343fb8b31b378295973f891c86c5745f552d99ed90c1ac561ce3aa2b48e5d2f94256edadb8d6a24bb3dec1b9774d56b4b6deabaf0abbbf320816625873bfca392c43d9663a6186bfb54b458ee7f5438319f516ae6ec40a38ed0e4a8e470a3066340ea695febb0e49bd17c00d6986c604cd02970f8482a84363764f463879745c98b36ee4574bd0285b0f3136c3ece4e7725de8828a3defac72898bc9615b7604dd85dfa25217bc0bdbe5202d93f1e5d281f80959a34160d03e74906233f3c9831906cf30b055ce76b9da489d03fc349a976170c219db91c9cdea38680230334614d3c81846ef1a73f39ffe5c117bf57daf8f5b3ab240c99ff77c7b3349aad6194c7a4bedf6d758becbd94f575fa22f97984238a21e450ed1d1df387f84dfe43d845176fbe6a525e36fa87ab997566227e19562a73de8fbc441b9f23e23430f6835d0442b6a7d05443de277ca4a5a9a561be356ab61aeb1d36e20c0e2370617f52279c063a02d1d1a6c92f16ad566a62034986a0bc48855d19f83888f9d0b94bcba30c345f8dbbe233b41a8547f26787a4c0511ad73ac5c0e4dba4b4ad804dba88a4e703f45ca2480c178f6893025c64890334548e6bf57e5d9f27d3fa47a2d046728d8e274c4e883d4c3109d3e6eb0b3e4cba156db6368827517f0508a154e1995d6550775fd14c2520d05e17cf2638f340d5293d3ccb9722109f37aa64339c2342d6ec09b9a88f5aaba835614bc2a07bc25acc4614497729cf3cf33d3c865f5eaa3c7c60022c2c281c20164b796d6f6257be6bc618f0ace511dd82dc14f315d74fb9f175bb3cd7bc278466948cc03c5e773aa67cc99a45d5621c17c502a58ddf3919252d8c53e8f25a09c1fbdacc616043ca42bca48ff92cca73e45813fef812e924fda4f4f1968bb4c6c1b7d62c66960679df0628deb487bad4fe5b9eeca5dc2a8dc6e80e9413c2166fd4332bf6a7c87d5c315869c3005818535660983ae299ca2f8994d7fd97172d85f62f58ad6fb81ad18cb8c2a86cf3b275f0fd595b03781e1bedbf5fc022eff571a2f3bc4e4adbdd5026c0a66ba569890cb63fdd1ebde31ec53f9feb16a0a03ecb1d98c4a712b87095fc4d31682d4566e64c1fee79b8024c09b12aca89f2ebdaf1404229f1f8577d5acee75752539c1f58840a2882d0179c7d1cc49a5da308892b42243b77a1bb9694323118c3ca9b4f1d9e75f0e189d0544ee6c3e437ea2e43ff4ee402bccf944663655fd2f36b54a5f6d4e6d660df0094205e6d3180c23e621885b94c539616490630212c31cd9f1afd00a92a05577f33c5ba6ad11d07c913688a06af89ec272185bfff5d3d80546924ea849ae168e1f6b99667e7ed39bec11ef8089d486307314875dbd8892d10f2b1ba9e00cf2a3544d319ef6451d81c0b53a1d9ee7afd915208db2337c388163d505cfbcc96ad7857834fad736fe09143c770358e793742be6b9eec76ba556b735bf3b2e18dbdf4770ee71575129370e71cf6942175053e5bb35a11717f50d730b53e2904917a5ed5c518ac1d8519bae9b70a1321b357243b77409e5d6ecb3c07b4bf8996e08b9cfd17e754de105ce6c34b6535bcb6e5f71b32cd25404e290e1926078727f48a69fb1800589e72264be0bf44aa7f0357bd1a2605ef101c4a1113ed3a3e6cf4bac16968aaa2edc9c0e08adfb83a76e6da5d8e0e7e3a5df26a63733421e1cc346bfbe87221ae5fed4621bee66ec052481ed052cf3f98eb14b28921bf27953835b2626a5f7e81c569c0f40b84ce8af23b6af47668ae126f2a31c216936b6603864e5b5425f06f79c276ab6e47b7d25f1ddf7598a82bb776fd7735b78a67c909e53195db8d72cfae96b8c79fe04f08a28f9982034c6691043d90acf04d14071d3ec3e4ba11adc944ac531b26f144d21e77f18c40c3b315779dc806c26eb2a50f8f73a4fe1a56a6f8d9be53c75fdfcbe6bd008f754c60b0ff0116664383e5c387f68872648a592eac1478755040d4cafdb213d19bca0b1f593da34ba045cadbfc079875b21c0163ad22d36ee6768034d5a4d2bdeb47589233eee845e7073c6759b1a396f2865a355390779ed8ef188d8ae8daf3e190a2aac3ca8a5a473b23911f24d7fff291d66b6790dceb562c23a241ec30416001cd31e79010cee308a1dd2eadf4957d40b97b0a0ff6d49f45cdc89e4f5d82784f19b25cefb64d8bdf22e5623ea64bea89d8e57e4f861d8a10883df5b24f69249cbbffc57400c132216499e0da29d40f9fccf8492a28772446f177d5e29494ab32e984024f30648f27b16809998fca78a2cf73e4720ead420105f314b5a4b4ed39580001cb49647b6cab769e4b6961331825f7dbfa6c2cec343f6056e69e1ad21adba87ecb47db2ac8a69dbfd5e05026375952155a5e0aee7511aba9f60a031291cb235db978548539e7f483c7c743ebbb231c167eefb0808db6a79ce67c9f5e20a583f93194932de68cac79ce52b59716c26cf49d6352d94fbacec47dcd8dcb1b5b400862a654c41bc223c263710f7cea90b150a1448aac4708320a6e25f3610f56268c7e42ad3a6dd05a7ce2180858d041fcf6266eccc0bc7858997ffaa376dcd5ecca79cd4f563ea711038069808ab25382effd7063571044d84241a5fac5581ba1850550dbbb37c964fc7bdf85b7a89a056a93d042d1ef5cfc03b0bb135c6de80ffe3a481b85cd0d6c39f605300cef809a4a1485940c9e98d9a724be232738abcca27fe91204d8d70198e43fddba58f0c47497e1580c9881c080f2934f4e6e01a7d836cc62869cc2afd80c852d9123de91c7bef32c7979294dd352cdd7e19390d75efda1278b83c00c14705bb6a9fd956675149dd2838856082cef35418fa4dae769939607ee8b94cb1f9615313f094131de1d40322549f3daae1eeb86f073534ec83e506f8670a8da4b0a6bd45b3c7a58de4cf2ae4aea3ae440f1a33c944a993ea2ffee325ac6f32337fa1e8465435dd3457ee3f069da273678dfa51a6d5e6807d2da6ff4341c8e016aedb3153303264e75bf960a87eb0d59de3ddebb93ecae2a0c859fc87d28338ae8cfb2d7dc687a7c9fe151e618d4826c1cea5ff75784485395f53483213c2a7503b5788235fcc988a2841d4545c0c67957ab6525ce0bd4edc27bd3a0d1a07f2818bfa8c23d85790102cb45b7fdefb406460e1e581bac8b3d92afc1564100f359fe452d39d9dad8f6e6212b2b09cc4c37796788d2a6cc36cc2d610ac71f24fa82b0afb4b6402857b19358f9344ef232f5011a1543eee12e6b6e46e017868ad6bbe5f3db7eeb7f30de457fc174e9106e64b8782985c864bb9ca0bd36c910360ffa3125d3e7c84301de81d5d47377fa974e4fff794a3c14d8ba985cb00d1ae0946c23b50d00be934feb726d2396d40346440b82a289da04005e51a625088eb8feb0ec7bd8a543ee02282e5186c652c28735c3eb5ce8410f625007709736fba9d253fd3345d341d253db6ef2bc7e1b8bb30ec41374df8dac2a5dfa0f044f22c5ef491052a958f7178c6710fbb42c90ff4bc13a42a52532fbf52e71e89f567a23c2a6d61e45af6dd7b5f634665af59a7fa6f09107d95eb1f41adcdec85a87bab6a5f889e4ea70bafe0945ce41ba329c46385adbf803ebc0ba628cc66271f4947b2cb09dc57ac3668e2ea073d7b9da1d36028b92322150032c3322dc43fcfbae07df9c4fcaff40a6dc2fdc19cbcda9368fb1729be8b9900d11281f5e7d3fc451cc0a43e9042ef0fdf0f8b9a4288be2b99de96a49fd797d3a706a83ab50c09b80f3661a7468cda673a4946ae59750fc7dcec3ffbd8d006fb4079ae0cb5e040a12dcb8349161dd01599a3cab99d2ac97579894b38f2c4c4cee33cb1cf9daed3ae7cf9bb486bfc0a85f09e77c9c97c9ce626401b2a8a02fa92eadf463b7b5a6ac454248aa2da808e16651fd927ac8facbb3d048b1380d8792b3521d4832e8989626b9f60b499c57c5dcd49549302f4c0b1b3bed896a60ddba3dd9aaa5a320352e6540f78bc5fee6a5dbb286d07edbe205b5442158be6f5062a1006aebe9b81e604bc6cff0dc82e2170a51365513ce31b88960c29ddb8611749381a6f4198290b2faf944b59d4f09b59b57d322069107dad08672cd1f158d85f2b5c1ad9751bfbac5f06d6d31859df1349642d3df72a98b8f2fe0e6d236bd46a9f4d10077261aaadd0382e310b7f33cf948a8318471d4fd8020170831cccaefedfaf9bf65c2fc6cb62b28ab9da6b7c2cd6e9123a0cc37853eb4ac0d3e7094ba6702fd894a61cd4184e8de667d7ac101928f8a1d8f78c772f399df4be768abb7361fa5f442a80110fe87d72df00d932ddeb53ce93dfc15bb0ad79eec28a63f434d1ea10c17b474fc0015080768278553c1e2e5c520dd56b9163d768698fd6ebc9d594a7fc104656b669217a56495c47a025d5f01e0f7ca4b7614cacbec310a3ecf9dae50a9f78002202d0b0e34f12d1a9ff8332ea14b36139325fbead6cc4a2f0ac9e855385383e77411ce63dbfa0c7e5c04dc5a88618f005cc70f0c6a772284bdb06220c0ae5a8adcc8bbeb45b0ec8cb1fd30943d164c1468d0bbef5fb4661bab0d10c6536336a8ffff3d57f7a6c1063b8e01c94fe74671011fffe28ed70f786bf72185821e88ec46f1bc609313b125b719de36de722c5e17274c5058ae40cf955b8daf3c58169413937788b5e39b50fabeac86d5cc4cc4a4e0af4f94f97883e7f631d76dc595598724e811a8ee6309590b2c15d6d8d7eba0cf1666a2b35148f3449673b35b90320b08a92fb6191e2619ad9c6ccd26a10c16e017eb3e80b702d6dda5133b4b9d16fdc9e595c210c3674eb83d9162314fe195520da3469b9c98caee5b9f6946f719cfc9b2c811df681cb0d3ab18b1c8f33a7d83e1f20832eee4934a3a758e6a73b54b96626eefa0fa3325a538f0192f487a3a82cf7a42707ed19f46c92ffc756a940bbd96d364ece27a424772c48efa93f866563dc5e8881cf82ad4e2978ac4dfae55816cecef62e6c866ded986127baf7e12a542bd7b2740743f4dce2664bdb4a80963aefccfa4701a89322a5a5787c3f41472422a974b8614a9d925c563a16cb8a509c71d4c4786dd17ab6263b1d89c598de1110bdaa3e893d662189d89473c972c7c9a9d5ada3e29af102fa578bac8adfa1a01db4cd9a8e49c359740f555f7f64db0c35f0046c30e27310ef7d50d8ab60806c2ea5c973ae81dee1d86076db211a64f905656c90dcc0ea19c8496a0e2e8582d685921f77104223257c27b33efeb3c98d0b107e3c352431af91a0ea6aa223d0c7d35a2ca8a9a8ab03183d5eaf3332844890a3e413dd928b917ba5e3e43709a7a6d36e6a1db7e8ca0cb410758df6f11f7fc4ec9e8aff84741e0c6ebaa2bf8160ccfe27a16e6bfa1579bce31f58e6d8eb5291b7c65d96c0ca583ad7b2795730df47d09874a915ac9167194268c9811b960ba17cf0022fc53a34e6b817c8e09b2d7fd45dfa5d9eda24874a5f3f22bc63b8f07f12db65c2ea6f03944a4156da4cc0a5ad780b53ac3912191051f7f1319e149c003c3e416453b561b9197e0d25a29813e2aec2617a8a6e7fbc2a2b80c8e00ca11ab17a3e539749aada33c03a3eadfb6cd7f2664368db781c4088a41e0277b052be870e0b7a14d7b3b343bfdc5d9031fa88782d127f9fd7112931a1d183c4782c8206224e0de565b1229ff0104e04b1f04d36a12bd0d9b162deb63b84fc0df7d4f1e239434ec3b6d921f0da7a4e59f230a5114a1fa0c57893127ddac503c3ee65627eb0c6d6afa528cbba1b2449fae07113bccc7cb17d904c647e0e7d29eb3a237f259645c3c1a8e3f5fffb383ae262a5fe3763cdf1784cdee1fff59dacf2da717371d4a0e35042e6b99b276e5fa6f8fb422914aa221ed8d0f3e3476970ac8d3ca78d3aa7078aa96e1f968746f1af36c7a8584ae891e8db87db51c8f5b627fbd7388b5e573f3f24133c961278e4cd1682d51ca9857c9f9b96dd6b49e10ed6e653725d79e6f427815655385dbfe60bb5dca5344edd706b06ec136dc42c69c66af0827bb3ce1b36a27629f63ab693866917eeb085bd3a169f5235fe9e97d7c7f51a7be8f9a36581cb008e8078ba9b843a3612c13d33344745f9c7b670b87a677547fa08012951190cc131b3cecbcef9c995677c970316253c1c65620812c6488cb8378943751e012f08dc47345aaf29cfc6dd9e4709962e9bfdc8283c84c0b7cc9261b40ca4111eac3373e9f742049d01b248be9b16066a7886f00ef65b4e0c7275a111cefa3bb2b9e7a35b4047186f2bfeb57b69ab7e62234345fffbeddb8edfd5a1d5cc9cf1fc9fed71204f0b0701ffbfe6b49b8e2dc1f416e933e20b7587b7aabf5b2e7390b058589844e239f589b645bc57106c15cc9ab7bc480cf689c11a84969afdf1fdbfe4f1bd7bcc714ac2b66215e71976b89b177401242e51b82d713cb05599072c200b38dfeb3b4a4b9f50b30dd8699d951f5fa124f6d102bef3f7f80b4d1b38766987113d535c6a5d3521e8ffca9eb94b29094ded4c4bb78894ece1bd17a6aa673ebb24eb66d3a4c43bf1d4f04c2e1cb449dd445bc2538b3ecff9cea6be603d0a4e800dcebee87204bfe0897bc7f661ebae608aa7b59da2dd2ca4d8996ad24f3b6d8ed5c3a9a5af19ffe542dca4e366a677e0cb3b9d59edb65fbda103529183a94241a84ee34aa5a87eb02dbed3b69a4e2e85d1b497861c7802c75d0b62828722e9a773bbab17e2f735de78a8e5f1069718b7c72fbff5110af532d44e96bbfce4137773fd73d8a171480d3aa3e9ea2a082d716154270f2298a6b8c3e59a021d6ed9699e1805172d05e0f7a1f04d0e698cfc5dcf2e80267a973cdb8a203762c610f94ddbbc2e7f312975d6c95d909d5652be25fb0ce1239acad17d036f154add3b7e8665fba226a3034115d62da3318fbf89722da5d5e9a89073af83d30865c16a2a7d3aa4eab7b8cb71e307855517b63c752f1c6472bd11fc2a41f75781cae90750ee39473d70dacdffa7968ef717ceaf65e07d6518d6490c7420000a6a917984eed590b905307c7162ae7cc99dfa1ea970320ca077ca63950dee6b19e096ab6a8dc71f5c393cdef107ff96f6923d19c1b2102a77419b1c0a474b22bdf5d55d52d74975ee99255114f46f4e499cbdf0cd6376e5f39957d3e9a079183d5053a92b4265a8e61c9c0bbcb5fed6c9ece67d7cecac9f21f1cfbd1e7536c9fd11b4778453672450b09fc9cea554df9215dd229f379195eaf9605744780e604b30bf8546a71b88768197405ad16fdc5407909e1ff4156276cf822288a1e9812a9f48618a06ce47c3abbab8e57772faeca0cc5b00f9c82ce01e81b2de1300fe938aa8b57906e4aa07b12ec8c1951e5dd9b1eae738308a78326fa4820279de461a1639c203c84f3547bd0adf858ac0ef193e5053fee0735543570d36bd6c663006809e6e516665945fbff3b6425319e8805bc5a8997625c61ad994e4daa46551bb9736167726d8e91e47828af7a4a505f3022eb8267e7db6034b472189b86717db758aab4b866178aec760a53b0b484ba1f6af0235ef66688e46da979e23c2fde6940a3d1f072a8ffd792464a7e607a5dfa2e0820edcd220059235e3b4a2a89084f34a49cd64dedf71981bb8588496fa195d91cec6362dc031867b72fb438be1bccb5c310e11e17fba105af3f11334455640f6a93c6d0e1bdb6e4b09088a382ebf8c72d025c4bc3a8fe9098a101ed32befeb3234c5d2263bb1725c6cb6bb2a6cb3a052b8b91d37e19d472708ac051f6b4ae8f97690aa57d00ef30ff443bd6fecde5ac5a6613e5b7c871a5c1d175842cb0ef68fb36ba1b7ce87b411d38303c84867b94bb4b7cc23edf479f9bd7d904d8e504d083e87e2d1b6912086fda965677fef6c8a3595e3d4673a4e7b99892777b2a7ba97e6b97f655e3f65382a3f98485fc231cc59ad62ecf5a03d68617fd81894278dd85cf7f949ea0303fc28bd62a684a6d30011064cc0e543f9aba52b25616973566205c04f5a54159628a05c19d63041a9bc49fdec10d116a5accb83369583b354b4c03a5c75e59c4431897e99e5591e3d960d4637355c5d625502710ea644ca7af330f8cb94f174d4b9a6b365777020cd2a46fd16b16cd47a7502987a06eb77f1b444d70f87a50e10e9cbb0c57ed6fa4dc0531275e2b3653e3d64d9e15beaaefaa27786a9e77e000fa0c1db18d721a72be65b7a860bb14fab67b12f3c4a18302bf1a6c021329feab5b59fb4784e6b1fbceb5883f285caa2547e6fde7f2df458801606d09f60722122277077b4eb92ea9c61f4cb00126328886a3ee90f70b77804183f46d1e0e38b33d70c503a4590acc999360feab17db052d215f85d5d96d4fe6237e7872bcdddef962c088dd912852b3d67f81562f8c2e17a04f36db2f52eedb9b4902bf9a6726b9fdcc41092a991b4e1083ebf314cd0f87adb6d81dd5202bda26992230c2799e404c15f63d93dead68f489e889de64fcf74ec3665ba995151d170cf70f5e3bc5fa3b397c0a0f9f6451b515b0bcbd9ffc24dc9fafd2dfe4cae1ce17f77e45e1fede572697659b88cec6fe16c83e80a09fb32bb699fdfacf1d5badede8431712b3dd3981dec9713110fa20f8205ee4a7c4f5a2c7d9c26e11dff28289bbfd8ff5a39b318ad13521770f249fa2176b19c546af43cf647ef19145d8bf782f631014f5efec59768d2ac6f09e05508f9645a5a07aa87a7441f7cfc2a732e029910095b3b3697205845cbc8c1f4c69479535a2891fe9faba34affe3a46ee997c68d5aa96a56a385763800c68fff41fa219f0c613c8cbf8c43e9f284698f220062d9ce54075898217edc3d7bfa20e8c17f9c46e36842d47318a41b890f7db6d5d05078c28aad94c909320a0ccac117a39a20be4f34bf691fa542f7581406e65c31c2a63febfd807f64361e870cb3f8911f5682727a41cc92b759f1e4161c14917f225d26561044e8e1eefe7e40e1cf3c5340f2ada7e0a187890784200ccb154bde97b538e21665a775cc99154aa0005a79986909a036b507d5c1f0bf7ada5791a266bfbf742357a2083f919a8e75407a728d2b3f6f4b3ad7dccb8024bfd4a962b0fee8c3d4373e6cb8e47dd2ce8f786a5401a41dd41f56023a1208e673b673331b16b799477307332eec099ba0542066bdbe08af23b42cd2331215a3604adb5e8dec88481aadcd56d46ccc6206acbda97c2bddfd3dd7280be635605c6e9d04d3ce49922cf5fe35a3a0f0be5d61079b76e3e5a65beee5394978bc085615d3f7539429390ca75f02d7f6126b65bf5ba147d7f630a5ba96322378d229f7604982576a5f20ed8d594abc230d713e36109534bfdc58decc1162a27104c119e1213291a48a88b20f759d21211304ba1abbf9a67a635f080af585745d0103877b685694b761bcae464e0db225953e9964bd38ab5c20e676357c87a91462275a775687d40a99842e2c47b2262e63cadf6663b472359ed84440b2175dadff6d2ea84c206fd234b730cabc740a740959a385a261fb4b1245a9ef3c5505ffeef89395329a91270a32f5b034237be88b572da262a379fa2531b61ba4a67f090ee00949de436a9099ac36b5bbf29f86a2934f91c6457376bd1564748ce277910b6f2d9cb367e86048f5564975d7e909e3bcf82ce2badf379e2a583f447bbc0982e6eb50ffc836fd67d0f67224e1594039a539a34a5004aa47d3ddf0fb999f1ca8bd5b8779de9ed6c941b1bcb76f98637d2c0d315597fe1e2fdf24a0338bd00f7cc18af28cc26623ef021da4ca89b60eaaa6c0d370383917a327820d97cecb18601ed37b4672f1891603f2b9bd16ba2541599ec4191382ad33322570c15fdce7bab0ace85fb64af92f5d6b0996efb497b2a9bf511091b0b36cadcd27d4f5dd336e3c0a30666484c4f3b3823d15abe7f95fbeea343fea4df1dd357051ee66aa743556ec19762653616110516339602abfe9181b7348a63b65c9b88b838b1db7c40cd0660eb7d79acaa242edb197a161785e80dc55ca26c6ed27eec0d9a46f3e41e0f170d8384b77bf178d4f472f003a76b2352ebd538116ea23870f4d847de94242f2a71103b0fdff5c151c3987c154f491e095af54c9b4059d48f37d7737fe8ad3da0fc3efea2bd72fb292c67f7cc4196aba927f3f6a618d54dbf07e9e7b9efdedb6d5f60e30f748395d8392c2431edb43d67ccf027542827dcdbf204f023e6649c469f644ffeea40529942157133175dcf8f7fbb2296e9beb915719c80a0c8960ab7c5cd8ec4ac4199169d83f8883ea0384a035fdf047f8994c420fd6ac7d17317e44c5e456c12a700429f8bda09e74db11a20d1e3c1bcd505818be5dd2413083c6356c849d38f215344f2d72845ccda3723b8a8544844af1d7526bd4a14f053ff234886d398f1d21f286190a41467bdc3d59d01b846607f1a13ea0f72b9904f6d64423aeff55056a002a2857c8b4a3e1b19875d3833dbc31964caeb7e38e142a95bf362fd77457448f9b30f022404631593d938290712e991017853c9a6411f281f02ca45cef6e11a0052ce5d1667e9d2e1ff9f4c0ac067fe73fc388043cc9f2f3c64852519dfcb1324f59ef9a1374728a5a7d43ec54f2a52c1692409a1198ce32cccee552112c6feb43f93c64dfb12efb8ed760c00281f5dfbafbde3dd38782ee1dfcc2b979286990ec69f9504764a5432292a57182f48b4355cbec28950a598eb5eb6a6bcda6f3e5f18a9290a974efff10f80504991ac55dc9624c84f6fbf00330292cf08a4abaa8d2c02070e21a1162f4e6e6173a9c7aae36e244936c5e2b7bbb4539b60a3b520c09607df4ed872dda9cd0f3b164763f16c40e79561410370a49a373f0678d7e2914623ca2b936ab96f4e54acd91a15f8fd8afba452eaa44a0ab85d52c2023149ea7654c984b2e78c8858b9a8df0429b25c53afffa3e51ccae89849b732ebfe145455b98c0a6949f3403a926f7b5a66a138cdfa6eb7cadcb0a8494699fbf8726579983d3062e5db8b51573ac167110a75c92938ea23a90130a9459dd97d9091a74c5677c505404e44df9a824dcabf7bd000c82d2f783b9445cce5e0463f476b7fe4c49a50f95c56376467d9718d8095b6f62dbb88a77a3ad6aa803f24df6c717c9e0cc6e372f072df76344e0b2b698b8e8163964a33fdbb001cdfff88d23db2dd7472bcc0ab8e2c02e562688ed06f5023a70cc5822cca6915a0073404d4dfc51010883d7b006614587f404db75e1938e15abc35b80c095d8386fcdcfc3e70e97cb983c820da2fc975b3dbfc5271ebc3ecde780a719e27066cf7bc0cfeadbc204f2d5f4927ccba5bb37c7ef8601f0aa3064928ddd5771cfe37dd41ec252401c33326fe3d5f9fadcfd5faefb6a3a34ea3352f48150d26ac34ac6b3f864d53a66cd6576dc264a5314da3c9fd952aefcae7b19eab5d39d533fed76c27e76bd66e2f1162a79556aba4a7c5e9b67eb5f8958e8908fe4522ca7eec9a337f86f2c4aa8af136894cd0eb1ee0953efd131e3d0654ea749bc3e7fa85594eecd46d1fab1f0a61ae6c86fede922b6cb406e20332f973f82966f78ee10e8744c11e188b4e9bb3df09e4036305b3533a6acc2d2d2db277cbdfe01255b39471db2db9e32a00d99f350a976d53e5b215f2bdc03c0c359b72bc26ab0b9218462b584d9cc471ac61db4ae6e8c0ee03d9e9d3108b373934b107d0dd5283e97c74ed11d7e146a65166159a71970bc64d168edbc403865bafce6846ca8612eee369a3472fa7787cd17d531d0bf5497b5271b9afde76403f2bc5fd78f6c2a7b698e0cd74c0da508fe175592a185d30ba06bc3727f31334846790934e9c65894a1df9c4287067cf6abe30bf42d8f7886b1583b1fcf207ad9cae5f57afefc600abc6fdcdab9374cf5c2cb0dded8c96c54fb70a0350e4f0a30a6da1e210f0bcf74739558c422d0ca58bb5cb280e2a9951701abdbe9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
