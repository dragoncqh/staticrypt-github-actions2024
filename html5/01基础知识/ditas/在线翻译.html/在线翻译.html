<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9fe2b65b9cc0ff9d100ddb813553469a8f057da03e1c26e0fa5a51b1a54dfdfed248a9f72a2c7d4dc56049b0cf534e3e797a3277e0915d47c5e75ca8cdf9f13bbb9aed2e309ca75a0185e801cb80f5b4135ec610af9fe6ea2370e0c3b7829d7066672c668339b5765ca90db0da9c7271da0974768cd01e9a7cb5ec6b2dee2a960e02e1cc5769a8e213327677b0f96b79e0855ef4f3688a11e37a3d7897b6bdb64f084a9be71dbeefda1ed29fa8af6916ab46d06c5a7e186c3c0db7c0abdb96994e3a941ea5aeab3c6bd30a4e754b6a3d33a5e5c02a2ae313bb6cb63c47a39e1a20d11827dd6a70fc0c6de14c11c5aa0e7c0b019246ff769cc1a0c1bddd5e4ba17065a37ce2047363a8b9742823bde39ad06f0a7edd730881662451fd00c16670d50cc44223b495ca389f4815ee5f9f452b1ddd68adf6d7b89df727bc6baa670d33fd24f5ad1c57bd70c7a3ffa101e8115e616d1caacfb5faea4888c12f23b5abfe0ff0592a2065e1cc1c4b6c86dad123ab9d7ef963794806544ee03347506ab7ae99b53c35129afa67f0716e26c7e8ff93ab8335ef52e8af8ff3ea0d79a7c40f1ce50fff70d7ee4f2db8143eb9c0115033e7d710d178d193d1f1e4573df6989a0fd19719e29367f79d8f96276b0fd76b3f4c29bdf380d92dc451f35fb27f779827007ea32210d96470882c2bf446e751d26eaab65a7046f620edf30190597022e9880796a24b9eff9744b2f44c9b435a9194c88441fa18f2a3653587826c7759987131938911b5d556caea64b77994f13852a08cf080712254baa11bd04388a70036df039e32148e1980e4354505de7950af2f788188b5c64a16f1ec02bfba2ab1928916e39d3a8e6d101479ea7beda9bbe0954083b0f540106e22cc8f30f84c8f451a7c32bf65089d74eeeab6d9bde3f344e0c688c4042fbd5fa874b70ba1f5f81a68c33f67de6e027daf4c6789bcb6cc2e63d424817ee1163a7c5ceec3a4e48e05668d83ef34e9d41b3052f0043345c6924bcf7260dacc6cfb17fbba03f6c3637ee4eb45ccec45147b2876c19313804ab22bda3884913b3645fd997748b6da346cfca179f71cb1753c9809e6a8d62ed4df52b3e381fe19894bf276917ba2fbf89e458d1d8b7b202f08e5c6757f73ab0b7c61b79e4239860e16aca4686062f2faa88610a48101dcfc0af7da74b9b77b0b2c9739635fc0fce1ff175dcef34f892d081d70562354777430e94868e0028981f76423d3d89470f199e4e63a4220f9edae71ef724fd11cc6f18c1cbacf69afd26dad672edfd90e02ebf3a919337afe7f870de7fb369aa6e925dd2578a57ba6e39cba1412b59bd9d882e2fb47f86b128dd84e820c531b5e676382bdf5d6c23b192e3c0deaf992a833228de131a8bcc840ef27527db78131ec051fdbae5c7a589db7f04bcb4f3212f1b032783b84cafdfea04946abdceca6f9238361f3bf4feb3e7775432582c2255526c7ac096ad47c95d07fcef6e8831607f59a02f88ca3a950b19517e68b88bd170e38759bd999fa855d0fc951504b022e86121b69bf24fce98f6753104a967ee0edb68c7d9edc1df97a80adbd0568d68d91d37979fcdf04f91674387b87b3cacc92d2a63cf57b20e646aa8a38dc441cb57a1f63256fe6b65728e7f17acfe2038cf8f7160191e158e35da389f2fd3f57fd1a117b2f4c0a86a79f41d2b65e96be251fc5b7da5ad4ec8851b1db5f9da52d89ef185110b72aed0c27917b448aa1b0b2cee7d0d3216a10e018311f94b865ba6a653ca4457f0ee7e005e317f3542d9e32b9698382621eb69cfe7bd43d647390e31170f4f725b8ac5220c8cae5762d93a23f8674e20c2ad6f278541574c0894f0c019914567ee0f7c44f4114ecabe9ebf1fd37043be8805b3e88d0ddac2b66bc5de63ffd03f04e28da3648f5085b16f5525449f12cefb4fce67b17b5029b95af597f1366592a555a4ecbe227989fa7bbe134844dbad85b0f0f234361f293f6e26d7213efa4d36e5eb4999c73ae3ddc34d1526be6e9786aff18bc84ed9550e3c0fe2f038bb1019508d8fe2d7c166c78291dce6dd9a932fcd2e61c8ddd65601d93aa28ced2ee417f174abfe0c0b30abfc2e3b2381ee7c35e0a571800cc6d238957460e14916b97c95a5311ede8bc300336d6619a3118e558c3eb2da1999e83f6f68e56c1425346edffcc7010ea610c740707a5e07452c24c88b052653bd7f1d8b7adb9c7ef858780785e6f178bd35759bf4ff237098bdab71560eca06f8b860376813c560e25bf623df6a61c7c310f6b5f50e12e9e71d4ec2d84b30102296dc1ad6999ea583bba861aadb7737fd950e4c2b5ed1286200d62b58f48f13ec0ddd38808ce8b9a6fd270eab35f3ed4e4257db6e989e6fb5bf634f26d6cdc0804c6cdb4f5dfeeb4aeb5c2714e76ef5f3d7b25408f190ead1779de83fa2eb5b0f2169c8cca268deaf0fac32aa58b095cddcd9a60c1742ca150c81c54f97643833cb7a83203dbb202c393492331d8d062e2d27fd79a9f819dd6497a84984aaec8f5d32ac8165c3674eec6b808e0905a1470c52ff3c081e04f6d652bd39bbecd4dfc4973a23866668afd071ee963d4748eb1a62f85df882ff5c3679f220681567aec2ea599c5d25f6bb43537189ac1aa56571d046a1feda583373d7b67a884590b64c358bbd4408b98adf14c3e1a5ce3d950b77a752f8167779134922cce765b9944ea34ab67f5c0249d5d178cef700b6fc3320e4bc7a265deaa63a9014b8e3c2845fb09511f27501baa6ad51ca81ee99b793127cb42b86f45e5fe5aff8db0a36b110c23b901659ad47f07244e2d23bca762e9c9246865266ced0fa9acd8e075863649e2b132f89f320598bb9ce714eae00a42eb035860972f206dce6ee0d36266793d3ca8e5d6a686941f494c707ea6400b6f6f7ebc622662c1ddee7ff66c82dddba14ae31109624d93b8d498f1930455fb31034166c748dc06a9cdfe6b240102e199616d992ad0b28c1a0d0649cac6a697f27cc3ee53751dedb2dbec86b04e251e02084f33a7e689d4c026dec45c3ce0ae0141be84498cdb03daa5bb052e5aa61f4e2c44ce71642e3716c44a528563af9d074f049e8c14fc306cf41ba54e15c1d5396ac9e61a800118751e525b339a3896e3fb4c51d4fee2e96541c099a5494ef29c4a71de0ee0e7074c7d145734463a7a4717177b1fe0db4d4a2af8032840f762a523936468fac51e7a41008d8e6ff7a83c7323cecea233ca4a7bf994e4c02b64516a47c8a07ee7542a4b021c98804b7decf47c499697f81c85011872c68faa1347e246df18a78c0d0460924369cef30b649f31f69a716a1ec95861c90651f6930459cb335f44a7da08ecd6b3f1a696e5a4528125fd5c24e30715df79de55367b754f1c330fee40240d6376811ca9b8353d44feec7080dca5999ce1e11b5860683b5566010d2a4f18838aea1177648c15d165ffc14d97fc326196aa6f27c413eaff49ee03f627ccf2f8732e21ee1bb2c1f8a30146f59e93255472cb9246fd13a03e94a92bcf36063b7485fe8655f7c37360ebac325cc4369161efc858efb645d9e121e564ba6e757b63194204e4dfe8c10416b28cde2c23360b4e8e9b572c9f093431dd2975a9de6ae4a904ef3975c9036b81302879806e82112e38b34cf9c01914acc1ffe1837443b2cfffdf6e6a3fd93afd29782d25b3e94fec9d72a45dc6ff18a4ef8b81c1ebd94414e69f945981216d59c3bbab78bfda315d1d91515e40fad6eaedb454e53cadf2767070fc9834c82d764fa163dd2fd30fff5cfe68d2834007e568cf2e2e6926281431e8aca037d268b3e689f4a2e7808fa1861931ef4443a3fd48eb69aaac8d6a013d20f0381121028a8698b027ab21cfc5c039a6cd5fa6c2913d4980bde6a3b6047c72e2c7515631b6e8861754a02fa9c6c99363abb4b8f332858916333799be810698ed560876d45434c9da08f6c65b5665acaf624f91f72910d802c6601eed27539fed43239032fa52665940f25b0eb2764da58d1eba605c3c6ff5308e40db12f4faa1ddf011b9d67d7bd4c51f4793dc61b9c64c3ca6a15d80396b9207ff006539cdd8d58afc56a225c17857170340dd1b1e909d24e3a303e1bc01bcd0dfa0b6b5c59d6520544887719a131095a6938c4ddf6014c656460e6c3e61e89cd7cae0ea343637f88c7fd335bdd86a106b83687606e1cfd5774ad40e3176fe09ff50780af1d131ae4821f6832968a66e2cc32703de926b2cd9524ffe681ada8f72e8cdf724a35c70dff874e81184f5157b875b2df7470f93f8a8b63fd206f3c5acffbac9ef73123bbf7f575a92e8a6da3f73b62d5bad9d2cdfe0d0f11a9201a4d77d110ae0cfe4c7d705b31e603df210184ab279bc45e9eb0532febcdc65903818aa59ff4a3434c7bc90876aabd749b69500b454fd2793b81cb5d56d47df595eee88a4fe3ac289c649fe3f2907aa8f2f1613bd02b0236a2b055cc03471f885dbff6cfdc2abd27e85e679c3c1dbf7d793863f7cc1fbc340dc9a74aa16394becf13860a7d9e99398c8d5e325004b6f8104a0fd4e94ff0a273838c94541770e2d53ea9cf3578dd3ce823b7850a83f903fc5036d63632e2198bc42d167ffebccb77341ee38d84447dc18a9488d25ee75ddf115466580ab1fbb19f2150d8553f286105c50bbceeb79a9f89b81222d1f4538fbb3d04f9e2e0a6349aa596a8ea387238025ef675462c5c8e3d03f6b16882d0a23c1f1366a76474d9780f4a68836f2d49ee44e3edcc5c0aac17ebea02ad996d4f77ac8615e91a9c6013508bf2533478ac07f40185c479b67caab7903991e45c1f0b154902b7009a9071ef1f0bdba341e238ecd953bcf2c41f2c0de615c67938f9910071e674b716a481ef70cf476f66127c943eb04c983c5f3f4fdb18ece44e44e2b76e57b5f7e044dbc8fff152ac0a4976df8fea8dfa9e1d4925f602bccfe4f12ae22f0ef4c5cb38d08ddea7dc026367e78579d5e84ecffb94a316db04d615844912808810164622c7416ddc59ffb29aef75461ae9a60a351cf9491d519d904cdf77ae32a484c0cf7f763a016f909a1dc497691644598b44acb92a95caef4e56c8de359ede5531e8d63c5692bfe9ad671127ea0688a5e8b79da179b5ea9e62ad2a628379d14497c00d305832246e886fd327a907c2e35590dcddfc0a9f22e02587d62382f6f7bdde45503e40b8675f7058ca435d4424852eb690fc77a68c410561d3d9961989855d253f3ac65b655c8b45a6ec35f15f72af8ee7dd43d5720f1cbdcbb7d0a83344eeffa917a9f06bfb9308dab7352accf96474ebb0ce9ef3b77316f2265174621d96360d4cba441ae65af51942efc45fc6c3ee6672ebd64406d7a04107ba1b399c381fd490bda2976a328c83d44fa595af85d6835e69e9fe53b82de813f4f7a00bfac5032dc10217b6b93c3383a3710653408adaa5f65a9da0bca22abd6616ea9fef6586649f7aff617379960be82f96dd7560ff74373ca9c365e1cd0b746bccf2f462154af11d83347402d2b1d5d8e98ba1aecd389be7d7577580fa034a3fd5baf2cbd3388dfd17193c0649d593ddb08fbeeb97d304b72f2931f9530d69ee9fa28b6b764197e9278cad58ed60bf2f07acd7a645f0568bd8e07ba08440b90d2b2731201214e329b96073a95cc6543caeac7a7f30aad75e57a66cb1b796072de3a87727580ab513ca901ac155b80cbc8873ec1ec7df00d1c4697016513ad205952de20f513218ff3a89de20b00f2ac56168032b97145d1c122b13f5496ed14bab3ef0e8622b85edd9ae21bf3f4ea772a6c3ef5e32f89d4880172d229d814c52ffd13b74efe7f6107f798d0969e2869a52c86aa8d0a816a6fa30348ccee642b981ccba535ec25045c07385d83c9aa2be576f144a8199e11d0bcc7219dd1bb87cff8443f1e773dbd3797904c9a5f3b0edced6ce130c854de3b9c53dd4c6114a6eaf462437233a80dc62bd89dd2f988fdf03ac619992216d9b547ba101fda0a9ad38aa895c25f1195dcc1dbd1f5045bb8b8e05f980f2834ebce15254ca3bae635cd73a33a586920dd9c06e7a030d156e3893b987d9bb7a3645d006a380d3f442c1c1e187bd595b2a9ac73e6e68f11b1f77873c5e835b69399eab7c755cfe0a1b91e7a94aaa60a6cc63e445135a5f71977d3df8f5151fc8ac209c879e6015f732f6f00725190cfee8aeef03700a926f0c8d112429be5c0638e23a444ab13c22a5a11b12974b2277cad267c84719940a41f39ee40e4c2f77075db7edeb34a2f8883e4240317bce618828f3ebf740aaf68ff3d811c8a74d088a60db69fc5e85a11e1a73806a5f1f1606c18d8c1051a6fd9b7fcf3c6c9078f6d222fa29bec10906f4718b443a323612aec96ca06986618c35b4cb54e5118de18fffde8e547a058b43ba758a111da2554c7328a89a3a6d6c33e1756ed350d38c1a268ee8c62cefa56c8756cd850d16ecc91d545613ab830d0473bbb44fe3b7e3cc4abb0832f46aba6f2c62b0a3995b54d39da1b2fcb302741971fe511f82d9d5c0e5ece0d4f33c910895f3a1e24a81dc56b40012ddf96c6d5f1beae43828fdcbbc2333ff2e07e05c08544a1ffa903a32aa2ac877e6dc51a613c5aa9c72fb395e1fac9fba9038d5a4932f5b150b05b41c1ec0cabae804623948ebac7fe72a6952f9ef54fa7ef7dcdd7b458438c826053702cc8d84f529f9593c83432742b30e128c1e270929cbea43aa071131769d0211f0c7f03b57f9f53892d5adff4f6bfced1b0cbabe0a72bbfab38348d4f77381c79771d8f90eb40fbfa2704f2316efd7b90aa49c51e12b9b16f1512437aa2ffb38e28ff677a295908248f2f3314a1b27fedc504c748588c232b373830cc358161a4fc35cc9a7702ec03d7fd3a91ca272ca7fc72cc630173270af75da1c1604f2e83bdbe8e2e4dee0506e863b07ce1ee3221d835237423a0317a545db002a44f2ce3b8db645efe51ff58f43d4580c47533392516167b245970404ea9a724799901e6edd6135b1f211e60f8c4104de2133fdb81f3cb8df0af8bffc6b50709871e3058033e54463d2af8806bf86d303989a1eed98ff944435d7f342f8dcdea6befb5de51eea46e624162f6cf8cad964197bf55f9985c2b0d854be8833306574e8df29629242550c316d7119691b4aedd6848be89a5bec83dc3b51d02543e93bdda067d486582f88068812ef47b2c131cf65f12fb06b626c9cdb5e8b7ca31a9d2264b314af48be531568d546279db960d98a28adb8e053c3081e3c2170744eedcc7152a7434f5a4e883bb1402adedfda22264c372e830d20342f6ba9b137b229a71ad5352b85b1fe5672f03800fd584b6bae60f0488a0476a0f21e8614fe5d3078428ea53a440325b6868508f7f299c853b35fe3f1de982577d4a00a578e88958af0b9982ff9a42927b1e9458813c50c09d7cc5b2231591d56b96114bc3bf56661129ccf54009e86ecc4f64209a1990269c808cdde1b7fb1b72a7908e9471964f28e11da6a33e880c3e0b7d73f2ef584df6d821f11416631334ee6455656d44245b58be084d935b8f678b4f4d7a45ebd9d6c4cd69fe05b6e61f60f5e466e9624d26add9339029e180296796cbb13532ea39e7e866bbded270bea90f45b01f72a63d8cb4718875139fc20525560058e41fc22fd8154b03494680eee0f9dbe0a6c79e7898abdb03cab0f655a779fe48afc1883b9d22aa2dec3e0f088fb68e7cc2817e77dc40670d0dd3178c1703281d6ef7c1937ef7494a84b444b064d827fef483095ac4de21e04f4007078704a1932ef3320c773f4caf97f645948aa335e51c431ae7357bb54302a05ad16c6488deac01164e9e2fc915b5274274e651e0d4ee08d8d0dbe5b88945bc643cfad28ea9616233e480e620d6cd370cca3400ca7ae287346e04873ae009a718d1765cf92d92761bef3d57f439fea532b44b4017c21df598b64012e9fb36f48508104d86d6c83af01aa710b1641567e8e6a22a857ce18546612a84b8fce630f03a497dbd92ae0ce7123ae371c5d1c02107cb5227229fbae943023cfaca24de11002e4c2bc6d9f24a8bd0a514eb44ff9ce792d9ffb953b1be823354e92c654c9fab983c6bb94fbc93a365d95236e2dcee8629bfadae0bace74fe84900ba98c602044ec129b13ba52d085342ba65c973b51b110adad8d0c39afd97e16c3cfb90f736ad540985ce2bfe94b9333ea2f4c0a71283c12bfac188587d69fac5e441b6c91994bf085c4bc6042198fe6cc64e15b61f28ddf2f0cb9979ddbd9ec254dd8e4504877b8f36402d2444e32a90d5506f8c945f4d42397693591a9d36b4c1391b7b02660a1443d5e05e45d5f275146b553063af4c26fdf6232579d84a8461ff3a4195111cf2b9167ce858fae0e24cc82b6b36616b95df9760310199cc4c4c86b31bbd58cbd09cf2caa1d2181e372484a12b8920e43a1c67ff065805d75745f3ec9307a2880415537a6f94996e8eb0b4fdaa04ae6589b750f333b7b1d14b9de333e889a9ded99ef8485b8aee66b35469756ccf88f8ad1ceb2a9f67ac5092c00afd426dd2f673be503390e58aec55f540088109e2a993223370812aa3ce9ca051bb7e0211b2791c20cdf40ddd4a59defd4a37206f02264778c3d368909484824850587e6140efe99f493c31bb79a8a5e88bf31352bc05a8f12f583930ab8d5552194a67180a138b32343ac210e581ba8d94a351e44f10243eece96acf48f0331316abf77cfc1865d28adcb589eb61c94862954439e678edeebd92e86090ebf621c8ec658666e2f70837ee49084e906818d9da6a75966adb639bfd65edf71d1772a7a9ec75ca302f19672cbbb9cf8740246af90ae20776d038226735fc76daa5ed38512ae0e803cfe43e450dc8ce7d7a5f6ff206c0c7979d1663c1d3c6c8bb8ec1e06ffaf49fae7f10c8b6933d0ea7c0869b342f955b1069f7a863782b931bebc0edb75cf3db8068c80099f6848af72df770f54003031f2b48759f00ccc66fced33ea0053c7d4ae5274568948e02099a21caa3b9b418fc618f73bbf36a8b7c96b25c6105230ce7e134927393f6fab416b954a732fbd8d1159b8cab589b3fad5a96d24fe9f94913aa9072cc91c735210fafa933e490f3b1558d842a34ff955f18881422ca92d63b49ed93d883705c06817da527596d0776bc1a43feb35172ef244a17a4f02a46cc715dfc0dbe2961f4dfa411e4c973fd15bc8c0ad34771d8a4a98a28ff02040d0043722f31a753891798207ec7438f87a6702110c847a5430da554c09a3b6bce1c2d18df27da1fb4b0115fffadc6b5d6a87dcbf8857f48fa4706895d2cdf8185afe97cd0acaa3d2f96b82ca738662f052b23a17a2711549781144a59b4f29b4b2e3efaf73c414da2ac1d45ce51399a2436becb0abf10b57f9ca8acf4ad2b34964f48ea8a97c113ee46cfc3ae327091f67f90bded79c82dbd3345aa4d817e5aa43d67b4bb99abd53f165cb1bf08ac2650e7f7fe2eb7e54818d7483a84045a94986d65c3cd572a05296186817a1d4593d3a11d35c0953ab7a263bbcac71fa1a22e2c26f7611986b6ad6f9b2d94bc25622fe30d329d70470fdd48a8f67e756c15b374140bacbe2407dcf61d6c65f82d9e9a8e3e38923b5a2e1f5cc2c243cc91f6d4de53c1b1dd3198e94eeb7e209a976973999e1b51cac618f5879d545705bbfb5a5c75e3729211b8d3172d68c2e39504f08d0a18fa21cad8b7487b9af745770f43129067db4108799305eccdee72524a1d8ebe27b33a06b91edcbc93b21692c99554171a7621b9e1f360c339ff1e23141d360c9616423451872ffc9afbab3c9f8992bfba8b519f7980dd7a3aa200c6de4cf4c959e17111caff98d4638ab33b66c9ba6074feabf89a6ec18c6605192626f471b53732dbf079fb99d19d1e469e40439fd311d490a852d4dade7d86e170fe0ae592d9f7fe65cd87b753cba4b86ededd59031a04617c669148ae8045c81644776f7d2c1f1ba033265ece991b73db4c4f4ae052492956b5f109dba03c0f32d6f8dae4020a72cf57fe10d221efd5fe62d2935b3081a70cd81f74fba07280f6a221019a05ea15c2c1ca96b4a588ccb0cd5f4d015d57034524c339bf5e22976f62f69103b7442237490865a0daf390c62930a3659c8d31fa95bf7970f6bfe97e7cf5820dcc00082fa725be66b505d25f1a1203b681e5739b58e681fb99fa929191c2d48b304abe39efd5e420c3cdd983b8bc5bd19f82f7901638a761cd192d444cb28c132c5081fc7bd74ece24345a01425f9822d870cb4539e481c1cc2430511e7a4ecad0502412e4c9d5037f02ca2a6eb85d15080aee1215636e2bb8baf0159fa65df0640d4291cb08baa8d0d2728178a3ef10ab7d3cde924a554f9990c0d5970da637faaa9c94fe5ea80f943a1ca14ce0d9c60d0ad1324fac276f62ca5da6bc9121d0fbf294fc70240696a420f1b0291e4a13d46d3c02aa2051e2112ca8686c32261c1d700ffd0a3d3811c583930345e77d5929f83f9af28a151e077d2aab83732342e58851c5f9d72876a7c46a369a63ac431451a05bbbdb170c9ba76ecc45a0b2cf7eb5bf61ef44a46d7af463ade1e807714be7939db063c3104878ec38b8ae7eeedd2de1ace492574dfbe1687fc9c27c64dc1b183994d281ad3f66651bba241bb2be29c7ea0ef3f266d257091f90c73b15094251df2590faf11f7686726fcba29f30d99624294b6e357a61c4f6c3b12e27057f18b493e6b319bb3971832b13bfb1d48e4f6cb1d56cebe4a512a65f003a2924296353722b540e8ebcab8cef820044da4c87e1c25116d30cda8315a701574c6406810ae7028e73c3a027a50b103ce93c6c1b2474f8562b9bb4966ae4675276500a38a13bad9a40a0493003c4f2c1861987ed762df30b844d58ebdb01af2c78d693075ea2198fcea270b65972e1121fc5312b0771b68044140f86409e3db20aca429ed07bdf41aff29a9ba82c06f59b1b177fd3488786134125948ebd6df3e1d3093eeafce2a77d2a05c11f2da0413481d98207d4ab96f1448b35e93a507b4048a05c30f32217de43ef634eadd0112955b8c5bebd08086f95a58306d7f144d50cfd9b01c8fd92b1c89b1875de1abdd8f6799425082b68e1dd80405e05a6dab002afa3ced07543b8d78b5426a0d2c3c069d876e9655466487b2abc0e0bc6500e823037827340492e6fbecd7549eec9afa97ff0e64b76c30a776ab401131effa0034057839bd90aae32471e74ce08d2bff96b521f823690513ce1ccbf02ddd5d73a203cb0a4e8229cdb7ca22463b7d92f927dbc03392e3834bd7f0f2528b7a9b93864a08bbb22db4474eedd7d5f75990ab60f1d7b35039960aed438a7f91db52cc03b594adcf1909728ac5afe74838e5ee09b8ff75aa275f47e47b8a2e53abff116f9b976166abf6682370332fd0b355148ce32a923ac9619f301ca89cc573b82e7481125b47823c45e2a46cf489c823f6e842a2b1fe811c29ee6f152a28611c6eebcb92f8d55731b11a0472b4cdfc910d2f80fab7694beca53dd0310a1d0914115a6cf28f49c419aa749060335ccac130ce5037877fb05cc14a7b32cd550bf4478833883a2b27c4f819fa53e70b0c308bc75a6c9ba44dfb1f74a6c860acb893389884b20bd0b64289f64d5e1c995471677e870b1f26163c44ba353e2d59a000dfdfa92db24f3d9611acee6abce24880014ad294cc181064970f8a697989bb36c9c230fad86915d887eeabd66bc376b3bc7609cf04c506d53b7721ad886278d6916c8447c6761765c599395f14e8e46f85413911446269eecd01e69829feeae5b363c05e6de9b5613f2bb09b98cb86066ba3a6d5e331b1a44280838cffc48d5d4b807f49416bc931e3a4429ae324ac83b80f990e6367cefb8a4bf465bc9d251efb81869d8872fe25eb8313d42b786d49d956a15fc58355687a50330df9ddb090e10180262de2592aaae234a84bea2305bc09752763c24a336aa80de4aa6e986a37cd67f7edf4e1ff984267c22bfb63a21ee16958024e09d6cf8287d3be5ade70577ce287ef0355e271911eb2ace81090b11fc464b9f9912441773673d2b6c907355df8401e2bb7b0f7b52beae1419a15ef5a1a67475a44424bd489dd968d83c3b55c289176b9b83dbc5b9f105ea8754b0f27c9675483ac326c85622164e741513819c5874a41819451ea1fd5419b70e61b28fd30d277fd4df17be2e4ee8406ee9318d4628c35376c3a9c54634fadc80c2e16ca75c0419901a1d9a25197d90a329eb6a94428eb3e54013d347dceebc76a767f4e955e69cabc92ed2c0cf1b5103ce17842bf3479814440275414e46697b49308d7387b94f25ae00993f028913fa82264d28521298a80a9fcb6764f6e795896b18e265fac2d61d1a05298a937d3a866f6229bf945acb3a4cba16b83bb4b9ef8258610ec0effb1223d56e727ce894344fde626effe10b3898b28190e8641c8150c2da7e07bfe7f95756a7c5b82dc61b28a089a86afee8ba7addbb50eab54b63706039101784cdf52a640da1b7520c8c529fe72a9fa11479bc1d9827bd13bdfd455182ba15e87c1e78409588b872564099c72325478b520dde224731988808331009083a2dafc20ff7205f980886f116f67da45468c3f60ee1e508dcc27ff4e7f25bb4f3a30f8e3e4550dac26a088e1668732f0e74f2333e7fdba559e5a96a6b9e93ddefa76d84207010f792c08321bac3de61de0e58d41e035dc52272ed3ea77908c195e94e2dd74dc5db4d9edffc119c43e33167635967aa752339b7280c99804d5cfa012525cba838549baff137559db4bccbd3467b0d46e3b342812e53687c72bfd08059a33e83eb7fb5dbca59ae09362e52a2811ce85f40e1868a8b863cff7f6ce8546e03b4758f9eaa48eadb90e234517468d7d2776b0be05787fe8569412b7f1f1da882f37d845776d62441c405c8cc7066178f796aafaf471de178e1ec99c28f89170c88049d2380e966c5758be9882bbaf48fd9e6d4ca19765f43164657ecf07b35c22e206ae544395191d09ad88da24d87c52503f16fddacc23ab2e977ad6459947b40e7cc6d137c44786d9547ec3a5f2829eace7aa2d343302f5d7d68225d480c22a97a066a4e8115becd3ab06e74e91534109f40b5e0633cf39bcfcc7ce583591f73aadf1c901864f8e911e6f8266f914e7db76195e6c99fabbff14f1c7c1dbfd3a050f44e02574e5037c5cd553c0c1101b6deffe590165b3af370600fea41e77074f8c3cd081baf2c2fd69e939751baee7a2679902032219a03331c328ceea15465f7e5326a59b58a2da0eb39e31819531c82cfffe790868dad076fc220064e48a895c2087bd4d05a7c30e2338e451a1fb9b9a33074cf09b637e6fd992c01e4c06e5c389ea85b4ed72e31833266469f43886ad3f9117f6059eecf354a510c9bba0415c4f59b88f12f8cee35f39d2e5c91855ea04f3d2ed7cafa01262972b9d1fb821c5d05ed17addd205bd424fb81a6b48c907ab982267cf488b262a011a4089fbbca4cb9ec59fb7f1153a6ba59628e5f744ed640e3bfa47564738f894655265f1be5e242c4016787fe014c02f45625fe0e4acca68d2e61114f9de7584abcc5ebf82d88946dd8d09592320f98ba38631d246339a9886367bd6b4ac238fa73cbf1f0163cb3277fc40f8368448438ff0e49dede25736d0ab3bc6256efb8a7e846a255e4782db7c85f22d19426d785754c4d903e36d66ad737840ab563a629048606ba00de795b9ca12be41c16244053fe07914a9a8517a330286853f4cec2358491eb87dd04b1bf05a02fecd936f44e111359dfa8dd3854513f6bfc4bd318f724a06b6c2ec3fa4d85a582889a088d7477a6c5d4906b2effc3024fe0637e667704e90a9d4eb9901c66c010401ed7402635557aa0f89b110719d9cbae83302f9ee1f22bf25e073beb58067ab254bb115bf49ba9942cc270d2c872cf4a1a48c3f72d4bc72fe6c2916ad7113425ab69126fff96eaa56231f6245fa53c2e34f8ccb4e0fbd9f39b94dda3086444defed31415fd57973b1f88dd28b430c65761951d241d375b02a190cac0a03a70e5346f874a777a648e2551bcb4fe4e30ec4849942ea1163ebc426c9ec26900d00bc2e1165341e1280e2606a98394704741de8240e7a78ca4b958b37e6f0cc80682f7abaaccf9ed33dd1db1973f38a97ef8e75df82cae242fac7807e90ac169f72d8ed202c63bc2d573a51afb69c4c022e2d29b4fce5c437afbc7dcdcca803bc2226b542c93a7a0178f7687e28ff837699ad68f8d41240f2df4329e3d3113ade3a0ca250cc24c8bf7539fc430c4bf2b154602bc35843345cd95f10b2e6163fb95dac5af81bbf72697c610037c5048d8b361359812d94920d4fedd727933c133593f1dd419919f4dfae06ebb49755a51fb87c78280631bc3aefda711b8b50e0f5b9dc4af6a348e8b0f3bc1e7651379625f0f6e860ff9f23d9653a151e60a2c15a0c8677b0486c812892d1678b07cdbf1fada1b2a93f201204cb647f6533e9ff87a8165943639d3a8573686645c62fc95638c857c556555f4a76abb735570b462a38f659c1f2760831ccb9432e4e6eb3042a3edd5665a709da0a5b9d3c772002761278c89dbdfdbc491546e85cee15724c79f42a5b51b56d03c7f0c9f70e42d70fc3653192aa922404083fac1221c3d008068b1c22f07b38b522b488bf9033fb3212761413bde4cab3dae684e3f8d349a0ea7c34907c9dbedfd3802cb8463d71d12bc6eef1114b929801abd7f202b715e0ecd578eb820837d2dcf20665ca6ea32acf7dd7f5c7ec2b3aa96b8721e6864d2d9be6592794ce7221d9dd347273ee71cd57e05472c037235c795d1bb60d9ecbe36c6ad3dda8edb30b75f4b9ce0688cc4afdaf22483561e0a91dee144cf9a07d862b6b17623a1b2e9ca961ad4ded38b10d24fe0aa9009949d9970b75583a56bcc5e04dd68774cbba6cbfbdec37648165072e64fea4f39c7726400a0902956af982ea0455659bdec675ac6da9578e863cbfe553651ea06216668fc445b359162de4b699f4e38eaf340bf1b91a53b30a9282e72424e4d4d9a29e22e59cdd1a37b096a3675e444982abbddbc757e508d4ba77ced6a088c7a047dbe19a7d4df316522bb9a03f8ff6753acee997b42eadbf4f9ef5dc688a82dc305d0197a3a8c135f82d1e2e2082a238ab29a6c2168f0a54fe0fd76bbdebaf5822f5f8373e0a05c4554645a3aae372475cc63d43cd489e681b4d5e47645b49f4bef62b50f868ab31ffb808ec42041ec42b91b827f93bb087a7157808f4d83800214268d8ee78800ea2c7dc646f9789e5aa9c54c5a39c0260ea5c54736112f9b258a156e6a2c4da05c150ef052850b6d9a556fd247d4ddf6c7ef3a1162c2686649546543dc3673f36db7c77a0808584a661e8ec64d526bfa0be7bd1f056cf9026093b4d4ebbc741d35ac3eae450ed54fc7323afd51ccd7d0eca78fa616d674aa06ad1ab90ae5d3f6375ad8513f94e0ddf7532dbeb70427b43982a1e88fe4216d149a073c3ee0adfe42b372d1a33d0774575d410ada9730cf1fb64b355a1e5b18896870ced58a0aa199cdba7ad2e8a1a77bd3c0ac341dc9a995599839792befd2ebc7a7d39901c64d4916d7b705066ac550735e76dbb080285396c7710421b4a55f2843776969e7142b2eab0dfbb3bcf29a39b6625d87935cd8a4faa1f87973c6e41494016e3e102bc009b36945b4b4005fbb4083a8545fa7fa84f6abfbcd040b863330e225e2ebf03bb8b7ddbb6f1ec3158e6d2b94e826ada166c36bf5fbf5c7e9e9bd70f6566124db4efef8ac105c10a9c414b4824a10de846f7ba4eb6678779b9107ec5acad8367dd313dfb12a7311e865dbf9828b17732f4e719919b9f22af9a0ceb4b68dd7ca5269a91c2f05264e87922d4acec05acd5a38bddd17fa56cdf384792bdac9f70a55d597cfef0731ce21a844f7dcfef399405a327968cbc41df4449e62570269bf4ac929000ac10360bd8d2801fe1a712328784e0ab1bbb53d2fb7c465d4d4fc0ec856ac26379d064c744298fc551e6105d6c2c3a9b0cae2c8956413cc7ed6ea934605e87d1d10f313c205d196875e6fcdf591490b7faafe1618c9ffdfca98f6a95a16ae0436d19ec544713828335061a0056b3c4132f934d2e6af709aab5f51e9b0e486734fdcd5f996bb2dfe9909131629bb3cd08ee7611c5940925a29f3eb66bffbe30ac5722c47b91fff61d34367cda32f1da7611a4373a1bfab860285abc0ba8b40ead41ce50112382d863da6abfa07e8bd797e87a057ff3aa8dbf12ba4740a0cd132a15be0ff88c1cfa3a56d4c1dc62f887015f5cf311ec398e40c9d6865346771cfee9d0f00e50245a721ecedf049beef970ebbe8a6e0f478f7b90a45fb7334e9756aa2089c0f8126eccfbb457b1afeba91c22b737e5348d5ea47974921b9b33ee5b2eb132e8e6ad172c2776a8f0f053f3ed181a61607f4ceafcdd8a2cbec6f4354f1e81d56cb480065903b508c4a4da11568d44de935736e22533981c0339bf3c64fa03fcb0f4297de1ed809373751e2690e656e3791d1e1db97a0fffff7089b8c2917ce416b390d543597ef6b46129220f164b35818fa5a9e4f22465f0ca3fc62a24cfe68c9ac9d517642ff35357146d33e2be0036e0a2cd59d98736246ca93b28d08d66be6cc2fdd62de87301c7d511974a0c059488adddd9abf171be1eb00452385d76f88d937f87433f4b3a00d7f4572aedaf0c32c81cc9cd480c39e20a2a0649e397bf939278f48cc2a4413dab52a1c6fc92674f30476c11209870d4de62587ad37df7cfdafafc655174d0d8f040ea2f4d161605e225345b561dd6aaafd3128f6cfaa9efa4751cd6fe2c0db4d5ebd888417e8e2adf3831f51b4d96b524265c46eaf8ad885930e0630c88866","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
