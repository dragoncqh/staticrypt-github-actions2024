<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8fb6af6d2182fbe71904367d1852f569f40d61094585c95846fc2d0b2f3d98558f6262319dbcbc8712e3b85d6f097e72148a6250a0639ad746b6585ba4059c87f328a2b5a401c0adef679b5a12d88347249dcd857ada5b8fdb5385d4636fc5021d6ee139eee58c928f7e3fb5c8a8e8a90839451e3cb3e5f868e2675c992f0a792fad976a1a2d2e9dc5ba2f66c106dd25c6e39c18d8e9e17c23f2b08c4fac51be8fc67b0e731d8ab901e09d0f70996557ee6e8170fda3a39b202b5af6da4ceff1ddbe3ed767b4cf1ddb27f33fe5f8a771c6648a7f40f33d93e0f3c8df4f33fd46a030cc70df47601398821aaea76d212f77fe58fb42111b11e6ac3de397a0c67d6bc47f278b5b04104b791556ab134ffba2cb79aaa492c2e5c1a5bc1900caf0d98a42fc5217205f1aa73757411f57ad77268b5175021252ab4e74185829a072181af3a16bc1a13bfdcb9613828c7b0f066eeb8537fb2811a27f28274af3e0635ae386a66c40f3c3b6ddc083700740f0d06e635ed50cdb87a5b6d797d0daba74da2860eb2f1a688aaf2cc6689062dcefd1acad8bca56d997b36769968cdba42e87116693293e863115b39d550c5dd8f306b28a9378c5cd92dedc00d94eab82c2beead12855efdb2b5d4c235832aebc7d3487c93999995208f7bb6c772e733fac6ff70453e80c2a63cad99a77d7b5490fb16b089bf84194c5ba9b7e5a4b77226e9c1f03c66adbfeb40c6df4b3245d7067980564722f50adc41cc7ff21c681efaa9192056e6343e52879f245c746831270059ffe1d746287f02239e9d4d4ebf55effb988644695447a08db03936c2bbb31795e1bf550b7ddc7727c37b4a5c6a1fe28e3ca462b8a82fea0bae02b034ff55aeb594c2b12a6ec20411772398a138da68dfd519b45840792ffcc81aa9927258d2250e00a4e33b8fa2304a8c732875887421b24b79f8a63eda508efaa3937490cbc2b08044d042ca1a43e7ba07e509eb38fd3fe7a3e8ac2028b4314a11f1650bf1da125117df2a4c2d7a6d5d17f466226381516a2e49f926d6bd89944b423fe31d4a53ba616c06cf9379f7cf7d295bdba8a3e51817dadb969d04091a267f0cd9ab5a740149596d0a0428db43d26242d6449d79998a2664690a4184bff802ce57a51f9ed21b20b46e8d83ea8d4b66b57ae6ec2f857074e1ef6c5c7d4abecfbfa52a1188033bee17b50d9a50b0292971c755f0c8aff080bbcd5bc215f0a2dae07dfc43da391e4913d08f0e3ee29493f5e0513bd9a638798c96da6b92183d094b4c9a4a6da8d5005adc3e99ccdd0f05df6af82d7d31a895f615e896bff7f45480376362cf5511b00b4feecd9328573ad327fa9591b2bcde3323a3e05d39b01e44a84150cdc41521c24b8f8f469a4725d0fdf981bc5738d586331336685f03ae4ba8184f6047b15b04ddffb3e417afc7e64d477f7abd9dff5d55f04f3a74af8ae7cce4445322a335f59ed5315d018117c2b5f3f0e6cbeb2cac37b8338603d5bd8e968a7fd8b90f083055a73a07f4f841243e9c6d76662d73542465d7c8ea61698459094c050b6d32b339532772683fda262c648fa795a0b43dde25141158190b328cbd2b903043a705194c5b947859ae2439cb6aaff3501681faba2bfa73b3926af1e54b9feb6dff94b5b23b48cc271eb60013a236088173672345bda951eb095b599368b609ebab197e9fcf6fd88ecd62f5f027bfa9d5503912feedc3382e9e1269d0015c659db48b645ecb318966e940ebebf5d0cbd6f1c7dabc477cb80fab0193cf19b593b4b74fa93b84d89f106f144da29285eab624b32c6183da70733fb0454a248ad651be2a41f18ae649c056fa05a0c5fa28582ef26791052dbf6654c99c752e3a2738b7ff3ec245ed1bbdd650f23d237e6575a67205759d6098192b3bf7ec92b8e587fed6f72a3904bd31bfad32fef90b1bcdf70180cc86d579b140a5736e80c496fd64c9f4b5aab9bc7331498417961b8a7ca1f853a528dfad17ddedc9f98465d24a14b3b8d7601abdaa28409d5d9ff85c8561cae85dbc41e51f9bfd8e8150ec2dc2716bd7dd0ea56ee4008d64463e43464df46e7fb09b26f04b90cb0367075a145c33ae22a787acf5aabb7a34c765b68d01e71ab89217adbd8d63e00c510f6296d7c6d1d2a46801500dbaf4c8131c526e151f0380237d6554f818d6019c10954b77ebc6c4ed5ee70b09e4e2d94218b6e65e090e4bc45ebe2450f5b2a88c913bea48a6a4bb3d320758e1a3c5310d0f57c8c6c3fdbf01f37ed4d609cac39d83bbe06b3a0180f04477e942b49c6f3750de92b781ba06ee0c173bb3ce9cf6928c75e0e2ed43b7c8054ba38aa61bc158cc47e621751aed22900c54dabbe8080155699d0b275b1527b8aad20677fbc966d3223f3eb63eaeb809c3a0ab82d7e98306b89977bbd216dda55f1d88cc1346bffa8e0a8d8aaff58b20ae0cba4a714434cac63ae05a916b28b714efecbc152617e223d1fc865600d50462b08e000d24b4292f25dd3eeb7a8f4aebf0efb9eaecf5b63dbcc8eb80eb2258dcefb2447deba597f98552d605f9e711805d789f1453c3291b285858ea8922520e18851846b0477b5529c905de0796b3e1c250b0b3da5445e3bfa78a432c5ffb225ff836016587a1af7285661e4408e51c6c94dc2048c751f380a9f0cfa9fda3bb6136e6ef68730505c71770d52072d9bbe82c46a41cbd3a831b91809f13caee7e9f946b27793fbd2fa14c19ec7ab7355a694024f41f877265d17dfc911d3966984674ebc062047dbdd114476b4812537354a8a40cb96601d1f01ceeea9dc108d5e639e55a2f6ea6e34439a054c089c97cd2a35313155544aa850e4b4d70bc977428c8868d5922eb8a8236abc4fb311319d280e82fa4084730726a8f062033b53792d4295941632274ea62da4d2e1032d8c669ce06c691cc143309cef96d3aabce3c6505348ea6eb4237f12c0451cf8aaea5fa5134471327e45c3748e22f82847d425375d4ff628594e7197b19c846a63a3226b3862468e7c267e354ca6d8d186c99b98e9e2b0590d36109d2495226f5f3c9bd0a37a429462185d296fe4c71dddb13c929e8c5405482771f44b0980eed52cf214b87eac1473ceb06b750bb25112c3de3a42496588472d8aeca02dd100a53aaa7cef1a41cf77874da24615015cd98e55751c2688218e6d05e7885aac92fc3eb1aecd32bdf2fd39d6f57f34a7c1c1f5f26e36060c6ea9eb8e2523b1d249bb78ada6f07e5795c9d0a3244281d1ae6306347eec295127bba4e02adaebed4cbc8188dde43fe4d904403032ac977a2a4f387518f815064f2d1b8cc3ac426a5ee3dbec3e6704fcb25bb551d7fcaaeaa302a74a5d39c4a8011d6060af98a043d4f0a09e5a20386901f7902202f757a33a52122fe3b9a5e83f32b2738f8cce728f3435fcb40759279f7f4dc295b59e8cfacdd4f92e95971ee896259fd1a6da8191c30272d7a01ffda7eeba9d4dd1fa9de98cfa695952d6809f413016cd03037d84cd28528c8296db0bc5633c8d72af62497ee33ace8ca8904659af1a40eebaa4669c62e56be8da63110240ef3f4d5fa502e7d2891eddf5bdb018f43d139dd0f29886e8a9923939603d0f7694b3fb4a55374bfb618477d0975dfde4da11506a6fa9a4f44dfeaa788846a20d0926f409543784b48b672634e14de70d2e5c6b97b58c9aa7daa48fc977e36885e04504a45ef79532f921d8e84bc4168b5d72d184a2143a140f479df32954a8abd16dcd15f332b5284107dd317ad725cf2f32fe6c5f2bfe83172b9934e9fd09203303f8ae842b17ddc13dbe59a1b7cf0b8c5115c14b571c6a2c64ce265bf8b48353bbddbdca35f83218ca41cec10981de5bdbd4fb7e0b9d41e63dce1842cce40ecc1f9a5c9f33dd82208da16616fdb2109c7e1364800573cb2e71bda2b085c181c0dbcf6365d83907a9409fab888679d266f30bb7934e4feaed6d17a6f3d4e2a28ac68220a756399753777d08eb19567f47de8b630f854ddf45466aad623c05cbe01c74f7b95a5d99705eee22f85525d90fb3b2237ec2fedd31347b3c258c9f8011a10cf901b5fd934d48db90ba5a884b4c97f4bdfcc1ce1412b964eb07c584cede2021b2be38cd92b370c3b480731ac1e4d728239f894194bb8cd159a7bbeb27d7f356ef14a4777e099eb0bdf16cba2caff505680887de4c5dfbd5bbbfcf95abee8381bdafc33ecf44cd89ea4d8ec7f02790e873863da1c2c8a136bb33939a20fd728aab871998e7eb2730f764f0dc4201cdff280440b82667356a972f40a3d49e6a7b2166a449ac1208c5faed348d72c49817d2ae1329db7022753a5328f51eeb9ef91d7706778f8aaf7115aaa66ad3afb0736a2732637e4cd968e5a981e197c563fde25499f8029f41a04efc222d41054f38362399ffb37527f15e98cf4fb95f4c14eeeddebcb50afef297e71536927ab3f90dfa6779388d9f0758af1d84f4c82256ae3d83bd454f9c14f8097286247feec09d119b07e621a4c502cf9196f86a2e8889352ab06c3f5f35d6f3a0dba47ba74668fb819ebc342618896f2671932468101c5a65af88e0d2c15efa1d43b9eee2ee114490de737ef7e47d135c6ef489a9703a03d3306b7c65213398b06f5eb49467c2797b969b8430344731ad557a45eb0c983e998c714cadd82dff89d2876cf51fc04aaf55ad99fbe364615e7e4256362c56bc526991d2a687908491a3d580b64d717b788b3b467b0495588dc06176c170d8b19192d1496b2940a005e90ca7381b387b9cea171da9ac8c8917f17e4d90bf090219083d47787493e051f51245568a82ab9a96b5b574169ce7bec0dead0879cea848f8b744e2ce821ea02c5321c2aed48a3f071e478edaba14a31ede7f8e5b0d2fef25e71e436c3de330bd3182d83be0718813cb72311d5bc294b6acf6a0d97abd7f01a88cea7db1ccbded2fd268d712959aa95dafcdf8cb7b2d92bf8d14a937455eecff68ab7a1c1542bd747e30df6f5842845ecb14011a93d81db2e27760139c3af49c91514d4b69bbeb37953a1e2ea3d901f34f4c6476a1271e2ce4a80441072f2ddae70f8cc705cf3ac2eedcc4c9acc8204f06302d40f7c3accc85c84bb3a92d7e4d82dc9c1a857e17def04093a4f92161c71bfce7d7e595a2abd0e87b11c8322029a5d768e3aa5087a27581bc649cb00295d2a613136a3c5bb59b404bb5b10cab1b1c9e2511a68e1596a19745da270a7613137a4282ce9411c00b9130732b14e1be3d5755262adf5f611d8eb4d03ecfa1739d3e18f3f700606320750840ca1ba50192510b5e724acf102f5b8ecb760ea13594667c453d5ffcd3896e9503e6ac032029946d98d06bc50a968279ba68041401479d44d2ab08e7d07e0b1c94fcef6ef04115ec54c19a9d700d8fe3618c671897866e6b66f90ad8de532c94c540366785c3e5d5b9ecf42cf25b8454b8f35732c8160889ac8e6cc477603283c7363fced9b17bf9281a502d078824845a10be7f36b0109b574043aef8512a9573a213a113970ab79f8ceb811266fdc83464625e0bc7b830a7268ccb3aef84701333a8c86f1f3e0e71c830610bd60ca3b9a98342abc610088c15fae99be59acf9cd4fa89080e68cdb8fd3a5ef62a747d7af84cf3e9be02fc272c430adab2c80369381cda5c0c2a83ef3032679fa1fcd5522d689e1ff05163f1cdcad1bfb05a25f3f0c25092ff64ab7efc1b7602474120b9aebd1dee5adba4af48809232e85c1c38ec1bbe6aebfd7b7862a90ff90fb3022a5ac197583d305344e81134566c872e3e5f4fd84557127c721e63dd5073d9c8ccaac12845c319d1195d7b17ec692c7318a8b4e2c729cbddd736f3eeec3bf1857368a942ce871f86bcdef322e9791a4d66df7fee6e21439111c34b800bcf49b9df5298ecec61769faca13a73d0f10f944e7ffbfba8d69368f7c8faa5fff99b32a54d2fb04fd2ade09025eae19a8b00a67976469a55cc31e87f462c80cc42881d9ada65efd4a8591ae3ac30b3fba62769028116e4cbbb948311b4d0b24839f216b18f6689af7672d948118ebeb36582972583ce614dce7cd4fa794c0664ae6e330324721e49afae146a76400222819d65f2df842641f5375b7f08dcc3b05e2040527388ac8da7602a1172c9d14806674b3f46dc6d775ed662f87faee35cbc27c9929911e797076c3aa426e8a73580dab545911a104d0c4d557085a21b4763d737665c842cdfa44706358391eb487b9b4e82a20c79fc5b16a9360026a4c0dac925958b9ec5fa2bc6eacd7ef3b6285a42f61ef30f7fd8e12feeac16e892b6b939ea8f0fe3d01b89b38dedbe4cf385be980a48323678ee95f0713566f374d68fb3a6123bdcd5f4bc646e38a25dea8c8905834375380e531bf7deaf8ee10b5d21ee7f9612c492a6016b822adc319f521ffbccaf301b157b2cd447671fb3dfff842a70f5071a41a403ac93e84d69a600c6c85e65f5c3b17ae7f64c4d91b0be488783d8665b6caa8ab5d0ebd81bd955f72c935a40fb82acce27d7c83fc9bb23114026e7d32344bf27abdec89f3825cf77947a29b3b6f198352c39a2e7d3ed2db9e8c073f0f16e80e5ca032374f8df7a6e9ac6bf8777951e9bf9bda3304972fd0095c57d81e221060daf1adc3478fe944a3c122a07d36361a2cf7df2cbbd64a28eb2468f91fa0a78e39c7a6d357bf1ecf983e70fec30cbecb3ebfea588afeaf750358a7498f99487ad959018b7b8e0ddf043d6daa01eca667acc41b82e0966fbb8ff1c4b459ab0785a72ff62ab26759425f30a7ac4d1cf4cbb122bde7659d2a9fef98e173fd2531dd37e156d4736292a1fd2146f43ba4b1e73756110d62d2d07c0c16146c833acdb431d14101dd022197ab5695f45effe3819c1b56f8aca016cc3192edf922915ab28e5acf1a737c87704c8d5e10fcb6edfb116e0dde128b570f59efd29e42924125774d618c985428d47f8b30955d92f34a480e143e8789106b49fe30c1beec8ee91ef923989f59d6aeb21432fdf20a5482511c5f9c845cc1f3120b5d338532e901bb3cc682e914beadbdc0947d0429ef4e538ce1cf87c628f98998265b0e1255701ba064d5703722e9f4c325234210917c52407f21e3bd571a50f875c1c59976d8799dd24f7713dcca8d0a42f6f300d06ffd72568804a625b4e13799b78000f223cc744b1c83814eafcb24fc42875b4441fba5cecde60713c5a4eb29c28fa71c475dceeeb4f7be62169d22c4e242d47583e8f63d922400489c6cd71b6a1944097543b6543d3444b75bffafa9fb157d3f788594ee3b91830a72d7bf6236d76bbdd59349d97b517814f8aab7759e48e3d18accb5c71529abe98ec72c274730ca24263e34f2b7ecccd067496f4b2d25032b91b3eae7bd3f3e3fb5adfefe4b9c26b41b47152ef8fbc5216ba53f633563671bd6f2b5fb4e089e38afd3287cdd7a988a880f039d67b4eac714c1d1c759e24cd70580b218e60b83fdd61cc19ca080e2985ebfd581d00daabdce1f5bf70a6a14169fed42d12b85adacb47c18dfbd87a962492781ca9d95b4cd2392d112c7a439012e81ab42b01a5bb2c1b5c5482f48c4be07a48f0f8b82db9f345afb47fd65cd724e07b976d7107f19d4be7c2aa630cf0089cb7332cea43e5d838da54bf0a8d4ae7f22e6a817d2f82cb7b11184b06bf202b6463df22e131006e01149921e353a5d7ba7d7026533d0a4b0c925b09cab528f8bab5eb1e744eb8f0976c177cf6c1d1c77fa7332934beea3d231856e3515ddb662d9a0cdec2e330c699894e12892f7e2e565f2b43ffe005deac3e9de04e16c7c933ef18b3d5eaab9c5996d961818095128805a3bab97be1c96c29aa035fe9836c7c4ced6e90512c6afcfc31a367a4bfecadcb9344ca5562f4d5106855742deef313b6190da8e39ec199f6f9b3922f0814efe136732e5b03f8fcc32a593d61e29bf8a95fd68f5d805819dd9c4d7e9df7c2bb90b02f7d306a1d4cbaaff8dfdbaaa195f0b85ec0f4fc0efc3c1e358943657e2c2c3048fb2756d4695c3df3730d6cb1ee70a60d52c68dfe56335817635d3a78f2ea4a0e527762b08293ac5293e728c6c536f48064824bfab31b02e6c94d9fdaf920087f32d64ff46e026a1b18c8b872ae883bccec6b3dba67688c0030e54566129dda2b0578e05131303d9369950caaba87d264dbab8bb08f9d1c69cdd1e405d1ee136650a87e38e5ae872248193161e6a266fdbb5814b1b5802de74210b0d35ccdece03e7c41169812f94e3743a5d5cce70455b5b749c947cf303893857583d18ba69c84b4ba9d530a6f84fd0812d473ff9a1c42c937b867c3bb58cf5993679f9865682c38fab8447864f4a4686c1a191f83e5c9c3a4cb70c77bb50a3009b98257747ccedf8135ece895caf172f8887fe24a0ef9bdbc78ef97fc70660cf3f11ecd97a4afd294a20634244bfd0e71b7e4aec0c3b78812de7b44a3747cd6b559004aa34cbae203be4f084bc6ea0824805289f1fd989b39af5dc56217c9102fc5c145b13b19572032b9ffbce923c90abebb888c6f802e7fe65031b67816b702428a4dc9efec93c1709f9242b8c00b629c12d406b312bb34f2b12b0f022cf024c50d476acee7deede429b919993abc852f3c16cd9329d3cc1a49aa69f0a5e6960e0dfae56d6e028d4ec9177478d2463f263b16e4d8f67991362f7007a4f068f1348675667e38b0958cae6b3b3bb5e8423e0b7cddd4c70ac1a8df9315c92b6343f9dc4daef8a3c04bbaf6175a5d779af30098504b22c0857f10985cc22f8f7dc68b1cfa19913aeb929e85d500c4f42521e3bc4efac14880f8bc7078dde08c3a91e8d529fb962168106dead522a0306c1fac18a2be38fd522a0be18bd29c66e983f8aa4568bc3301044d213e4846fa8a1266851f415da10707d0418a4346ca482374efd8d27a5da3ba90b6d2a26ccc992d59c9cfd9f1c4b04115c8abfb5aeb0f84877bcde1cf208e386204e07cfed9c1177183df63cefae7bf144c692af0462035eb1a86de41cace6d0cbe0eab073e6e5bdb087a5bbcf85df2ba2b586e9f5f601b680522fb1496ba0e2dd7d50601ee33727caa994352761d7c0f4240793460f31ce1d4086e208a304434318c1668b574006b398cd162d73e044420d766d6f3d3be505771a4c27b1a0498a2022bfeba019728946bf0e9079366fadcd42a47fadd081ff692fa661db20d976b00f4808d87fc6372cd3fd0146639693ac2de6bdf95e12565de8f6f565f6809c204e15b79a04bd5166e5e14a058c09c8b4f0fe4e5baa2e8739f2a89bc9969f624424a5107733815155c1cbc305b22367c410b00fa1124aac0468fd93a1369c5e984b13108d0738389d09f40828c2827a2cb13fefaa4c85ab08850b1c38d7e928b83ba176c823a76c6e79f6061a48cc15f7657a0977af68984039c33964a8127234eab3e50830048c0f066065e0433d9f8e6e765d2c1ee6e11e8afaff022067ab00f9851472c6617105376cfa7f697549ec143536414bf43ec1060d521d6e667fd0b1ef3e65a995ac444ee895a287cb011b7a7832dba8f2c84104ce60b389cbaca46050f59dde84e3b131543d71892bde21635649a8a471aa21e7456fdd007bd3e33fb79bf601bcf3bb6066050dc93851a8d8e97f2da7eeab67c749ee2ed349fc58c6bb21c243babc48085fcd1b33a628bc1322cc1d047430a2c6f260ab503923dd1e5ec07b826c43afbd2f2b0c5a9b9b56cad1a4c61d570b75337f578c5f77456b0dcd1a05dace4a7c0f0ea9e6cfdb576ebf8f8413148921e284a49b5539f49d911f6ea04aef0cf5856900aa7867ad860f70d15379cda25dc2f21234055f27eb0d5d7b15bb80b1d0eeb7fe275b9b92e8f1a831364db2b6154848c76cbd589aba0e61c721fd8307455b8fbac5062fa3520fdb6b0af3ec43c5c67960f6f6322b39481b070dcfafb43f6bfd6883caeba485a99c2f1a4783428a5071be2f69ffa1b3b642a3a28158b0031febdddea6d5767f5f27bec8b1619a1828862f45a31ac42543ce4ba39dc0e656240007c15f8bfd9f05418593b8bdf3dec2ed86688fe1b1edc16bd95f3606ac89d7c8b2f05d88272eb4acf5979df735ecbc00f356f51075932d026b8e9d5c747018a11e80a3831da2ebf255e08bce5cbe4fb626a20ffd8531f56b4323a5bdbb49df96d1ae95233ecff9d234125b4218e8b16f0c7ea70b67b7597c0c17b0646681baea8cb745ba4f26a0ea351ac492d3bf1ae9b97cdfdfe5c50dea04592968b9afd61a969fd607a56896d09cbaaf578ff277de8f36048670bc8ce52e37673d226c0b19d90361fa2ed7cee7da26c6bc141b8b97bbff109ea4865aa09b086bb5e29c8e026a0081769220fbab09b58db53c7cdf6d99c4f0873aeed18514738a9f13c972470fa91d804851b9ccc47523661a8311f04fc5660fdfaf6cc7fd8bee7ae6d39cfd59768c0eb374c6ac862ece8f43eae27b59262f2b5bb06865fc3dcf26344c38f4f6bc927ac015068520ca13c844e95fdb475e6545f2582c39eba4692607e59aaf602a839caa0c5e7932bb3af34c0fa15eba09836ee18fe1a3e7efb3eddf7fa90457a49382cc8ee5ae33684a5b73635131b6357c69481dedf8a8fe2535105b8727d08a83d8e77bdf7856619782adf3045fa63eeb15bdd6b985257ca8b96f8871377a93fbfec22dfa4550c3c7835d72583890c81187f20ab1a8f4be12751c30acfd53d1d67ed28358476128fd4d86710b61125946e76cd70b52eec131a8f1823e96d0abe8fb0e8d94a9f4aec0b2fb8d52df3b9fc76e1177f4160cb645bca519f27dc07db250ee285aec2778397013fd9a3327748152d951bd710a44a65af986449db5345ee844fc78be42faa5e7bd33b582aa6047d7415c6a468ed3962d01329f096bde09137d40d3db448cf42120cd2f82b8bfe54abb678f4a73b55cd7874a44f5748a880ffdd4b6041b73e1dac0a9813fb8ac5e7c1c8e5f0979af1090dc95fc17c6c55f36909d1cfd089db54412bb69c8841455dc6f9a5d336c0ae5ba188c7e665fc1a0bf5fafcaf78b707648616c69ce42f9641ec769b876fdff72779aa861226ec518e109d302145da54485a6123df4e57241b2d2041140e332d18bbd3ac1f7ef4a94079d59d1d2ead753642177b02042be0a045c43dc7ade552959b0f346a79dc466788cfab8eae94a759c030cef95c0d3ea31f9530a976f6eba5f9025a3d5ecb6442d53cf60f43625bcc702abeda6983e6ecb176656b32e829b2e7aaf3497b3e086e87ca22dc69a91c31a088ab11e2d9ea3ece59a6e2d9074c814223b12e392dea14927162f4079b047bdaf7e5e02bfe0dc1885c6b25169c5785106c592ef904f28fe629e14e75c10965d0ebe00d3823c28bf0d77932be5abd2b04b0969801bf2bbaa8172a38d2fbccc5c8830d7865e340232001a0214833bde0559a61e1530c77700c86a5ea6403481b2d541bd6ba29a5ed6049063dc6408853952d0aff57f40374a9430696fd38914d2093bfa328656434fd020bfb53985e659ba4414e35d66d6668bae7df31fa0f69b862a888a89df5245385c4102ed89976383dec7af3a303b5ae5c3be90ccb36ae1079217d7122ae9a8d6ed29ae015111e47545c9d5387ac507d4868378022b6cdd610e8e12750af6edae8bbe730c343e9f8fab14fa7ac57c22056516505a14cc084d8038cbdccb6b67da92a5fd13ba7846bea85a5aa4714c10d6832f7b940c5585942e46f34931f0dbbdf07cf602e314a4b31cc6a3298ee40f7c48083795926c22f94af8f859a3199d05030847606ae1512f477c1a3b9b6668213b9d864284a937b930afab5d404d9c681f1cbb0757ca572fb5d86f8dfbc58063371086d638a24a4abb551ff6aeb348597026eb5407f78c05cdc21c4b1a03fa221417ae032aadb77dc3d68a027f8a6a45013332b3efc52615c0463e51ef6f76b8872f2f6216f025b5edd55f5fc43d3f7c92cb1abd4b8cef556e42fd74cac7ea11b0dc5f85bb4b2d55fb0d6bf2131c4c52396f0ecf35f83752efa9309054f1195419e22e0e191d179a006d9d90f3aaafc153a7532f495e017daf5c3a4abba841b3e7ee89c7b5943a36f568cd7700c912e5cf5199ffb8fba780372189f13ee0259a7a96b9261e9bd24b6fb1432da42b599609ce6df4230a9f1c015ec7d5eec90a9fa567f58432c3a259a21e186990197812d609473c511c7a9d07ff8a8d9daf9db9bcb95fab054625bd413ccf6e840f2fc979815043e3b06ad33697ab99c92418e6d2b56e8163c8a95a5096c27ec2ae124cd1657472146338c9d936ead1b59e48adf511ca221cf273d882cf52079fc2572cc269d578bd08ace98c4d9cba5a241051c78c90539ee856e1c65ef23e25bf476ad76357a9f5d18d90e4bac1047f573ded8bfe3b1e468cbdfcf706ea7d00c01e7f95737c6f9e0f7406d55b8022196936a21bfbe9d3a1078564de627d7378555796dd24b119a31e9afed2c4e5e5fd302479fc6f32081dc05ac614e26638480d10472358294096244ea974cfd539c0b3dc477487833161d26110f6529ef6ba5e8c93b8d47bf2180b4a9acfbefb90502db4527bf92cd792a89cfe271ac4e2a4535f80bb0fb4f5e3f2aeb64b02dee5ea98e9e38b8e60ed52e963859e17caf89f785dc30678fa6b6cd6bf201b5ebee7e19827f34477236c0145770f2c49302257094133abea3c7faf84294086a6388c56c365d18920b8fadbb7625ea326a757fb4fbe000154e890d6c9d3f7a86d9d9f4943d9f9e7d545cfad065c85d696f49ff07069fae18da9d459005cacd3eaaea7a17c9e7285e1ece70e4b26b3117bb0c3a9229bdaa1b091ccd861263136a3d65bd89235e834869efb7550a59c5d2096d3cb01d344b5358b91e72e90dfd397b4c074994d026abf58246b8eb82f88ad0238561aa69dac16c880f231ddf1af6af219cec46b8a1f67435944882a4f69abc53e08bec2356040821452c165fb2b5c7a63894c0fd4d2f9dc245d00aa94ebc35d5a06458cf5688a93d7e370e652ed33778ee17bc4cf7c312e04e9d03d4c8be0c963e75bb580f4777300fb595c2c37041a80f2622ba15711035d903700e5c5413ab2d89654d9c7d3d702253529400846724df2ddc569d0295064a02f3b6c0bc24eee9ae3ad12305d6b78ddc4934cec38ef1d7936541934aed3dd76a432e8cfbc623231dcc60ed85265c7fc0fc24aa601d76dc92d194af7b54e34776fde99b88a1f925c79be44d4ba6d6b46dd2bcbe95859343525a1f9ff93e6ca4995c5687c473dc996828ef999c7a4841dc3e04a9645a137875251d3548ddae1418a88bffcef1ab96dcdba782a775742792276fe1693106029b666d658e0a02ab19cf93a9b1b4eb333f3366b467ef3d69e010b986e92640e6306b544155ccdc67d45c9ff125fd7e8dfe71472fb2ad1637c3597254d61551625e550748513772c047b9cc936cf1dec0ddc7b54b84b116b3cef6864e0d88f058b2492a36a7d1844aabe7eed6d5f575431a4529a3a6ec79b3e3dfc220a2fc97144a7609c7700dc84723b9c047c437ad8da63cf8088317bbe779b77b5556ec786eac2047d09cc8d08e20241866ed99853d6a6cbdef7485e4eb763635cd1d9a721513a7451517c03353abd0fe7f999968a5e72634c1aa008e2fb238dfaffa164d5361faaff2e27c8a188e3129f5548c8d0e9ce65b70eb8241bbaf995dbad3438824ad6317d8224a051efe59c07e0da5a3e2446e412c04622a5d5cb4e72349e45216e2006e3070ee9f5b55e3c10299dc1911a6364b97ea9ef58f309984fc718413c94c261a832650d5bf6dba64c50f27cc3fb97be7860c2643bfe2790db6e12551d5315b8c3acc92b0fc8050c57d129d4c111a9cb6323c934d42aadb025f9b4620757a3e01498daf61d697c5d0949bf248b513543d4950be8a75c02585c06d2756258c8d5219c109c95533d52b09425057730b048ae8f7c806e19a3e673e0c8d430286840a37d7dd49ce746a6511873bff65617aa464e4a5ee99296bc2eeb80d7868f4bbca2919f4dbc3677fa9139d3eae07de893956ae6e8ab9a1d5ef78d8f243acd81f5a28f1ecc42359d2c616686a26bb3950af3155404108766eb340a2096965d55b1e03203e160b6e1368fe160edcbd8ce66a8c415baf98527e9f35407015623972404120675625dfbe81701cec923e87ebf1d151d680cd8f3268f862101867031d658bc3011272fca40949c07fbab58571a2e0a8e674855ce54d0dc4ddd53fd87d01297d14911fd0a92e2ad519db9a55843f97c2674180fdc9a7aa8bdfddcaa81c24e000e9365bb11da5359f10434e8b0b9495eb8e5625872c87d76d49865f1a7ee24471a65650b6cf5f30d8aa8d24696489133271614f8eb11274bd6c5af68313fd6941e1121cf6e0c384a9bfcfebbd15eb4ea2df1b46bec85f6e0789a8d3392e6d407e3f900d929beb1bf1b50314e364374854f7a085d45a849048047f4807e65f421265e4dbb24ba07f4353c5d8b79738ac2468b0e69f0ea2b33ca5268a0fbff51bb3b909458eb4fe0ee0e11ac5830363ec6174b9992e33be291a863c8f5b1948bc8ce4491d4c9915247a1a81811a0e159f159b5edb183f89ac3143c21df5408a599cd4227359b57a6e54daf5d685eaaacd1ec770d88848e56e5afa91807b4e9c2a654bad62179be0c42c1ffb4bec9dc5ff42745366847501c973cc5d51fb69fb3ae332e0334ddf71ca7a14529a62f4fa3220647692b70bbb739fc5f4b2a11577520a1ac1c32b91e4d6cc07433096479105bf2065697b1c6211ddd0c107987c9ef130b0a2080fdd6e448046fa5115fefdf3945737c85845ebe1734cd2f416a2278187b038236c16aa6e53413f735c7caf827199285153dcb46cfb90e0ebbd112a9c1ab507f7597e72e3172fe2fb64f5bca09c5f83d0adac057c3e06707d7857f95da03c05ed00f49ee2f835bff2f9fbb9bf6a25d407d8895311a0675aa4524ffde8dc7bb53303ef501e6bdfba2dd6e524e4ea6d069493f9d93feed071df1abfd41357059cfd7bf171d30b88fa3ecc8acbc8074dadf93bd0e957f9949362cbc9d17bd2f804359ce64e5faa69e1c70c2b6037046b02855995afe134884919b1694a29868f7ec408b07a2b57f0bd54c18b93116c33b1d17277a9939389580596a9131f527cfee3b8226cfcbb52e113b7357b7065c0d64346b75267430d10d220cd97fe9be88901ddd60248638d5b45943cbeee4fd7b14ba34110d7682d539498cdadb10b38ce982a7c43edb734c4cfb72b54177fe851c9b68c75f2a9450adbfaf22b75f0bc3f12b008a546d3c64899a5b8b0a41de67c882d71d4380181ef67d03c41c9c3f05a20f486311aa86f6e80f3b46c6525ba70ccf74f9f950e0c6a464d6b4798ef25586d52c18e272c4850a3eb5a04129a383e6ae9e7db1544bffe4d8120f3ca6a70baf605f1a241a1f2d31288a718273b3c78782a864404ab616df224911465b7c0d240b738db718ea38325d8141099c233440a7a23ecd3ebc2ca8c932d049e1dce632f6e4bea20312701c93b261cd29b24f33ff888b8fe22ad3fa46be00b0aa6c42d92b740f4f6ca8ef8e2269da492828c8f2265be390d17f893af94da28609bdc437c8378674b23bc95f533e14285a3d6882614144def22c283d0186146a562150f9ece9d1a7c27df9fa9bdc2ab6c194ae91776347e000c5481d8b478001752a0354addfce6abcb67659066e97d6b0f33aca531d3262d99705dc44464938d7438e5a4551c77e913b39ee909dee234566816cb73d4639f48286b417d34a87656aba1c2399871ff305502d58eabde8712f789506d8ce5173fa58a33eba7c722819cf839b6b7bfd58a99267862c6c976fc41a54b87411e3ef6d6feb133cfa80b4e78e3f2299aab5c90936bc38dc8966d556b632dc80ba746527591d3f3b5d357f219c09184e68c95fcdb84bca8c6f1a4a536d9ba08e5b1bceb9e7a7e0db486a3d527eec7253c5c39c9004fde0e039d5e15dc5310aa12344de2fe2cd10cebd5274f9a0caf1537369f307cb0ea171808a2847047c5733376ff2a3d993d3fff7a02e25f6c83c5f413115399523bae896af1cccbbe019d93f5a19535aa58d37b13827d55189d4c764df60dc921f3afa24e2841aa7c6f277359b8ecb6e2ba9a963404b469c208678c3a7607cef403f90b4e0975d7e804f48abef1eb3e979729436638a7e1887fe711e6e3bc1b6d98d0cf07f96bad7d9ab5308b641774d043f4dbc51190ae8dabf21a002a03b1f56c78a82aa1c94c8979d888e2b892b936aa8447e63e4b9faba8aacfb8ae4a2df34bf319212b7b5f2bbc186ac5b8e14ee2865699a61426eb5a41f1b1ba72ca6ceabb241ec346c165d6f679d2fffcf7900a4cf976bed474ca8b53e41030c9ae4be93d51c1c146edbc1232d6e283d47adc76ef9417d3b3f2bd1c22f2f9b23ccb29a7523a361ef28a07bf3eacf5e6819919793ecf842f6eb8ee66078aafb09de0a0da196b20f657d57106a5a3992418be5f6ab0867fdb253e50f39087b399fb05b38ac86ddff29fe13063d2985b8ca44c577e4abf48dfeba030d87db2f643bc055854afb4df2e0e6f566a999e8732504edac0eab4990b21c0d5a431359bca8a31e06ac0a9468896528fa787707a1dea7074cb79017147845670d8f13e255a0f01252a686fad18d695f631ff966b2c7b7d70719aaf5f6ed9eb24d1c87443fd7ea89bc7026a4900e20c8e96307fa17a216b19d970924d409c9c52258c01a97db7f4114f14cfa0e3ffaea1dcf5e6d96f0104416ebd0777f5b12eab19f165294f651dae75c444ce9ee109be8b713fc96470dc0b75ccf6fb4615ecff56fdcde0681bb2778ccca9bd6761b3f6052afe934e932d9dce516221d1d7eaa84d9285e31c6853163787222d09901e6a7f15b56d38e14326f2ff10a181434c25af560682de12b4da7b14c78b4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
