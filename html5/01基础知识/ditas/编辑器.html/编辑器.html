<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39c6088dfd4049bb7be2e8ab4b740e7937fe126108b296049faef5f8c720f46244ccf1c487c4da13089334542b417038951b800cc7639ca148c95648cd7197e8604f7984c22543586d04d887759d550437915be26111d7220477d1b4636a590b4cad73c0a285b34e21e7907d582e89d6da600c1a049a85f17274f9fea06bebeba1a0b8acd650123833de9386bc58e91486df9889ef28623b291cbc44dea5be6f0139682f77f9627c0abadb630f8108f71580f8da6239c2b69d21b4d9e6ac9ab3b8b6ea8cd4037a6c342beccd8e10eb1e55640e779d4548dfd5d25a4cdd3a936e6eaea084eb4c6fa8343383fe20f35ecddb8806fa92c7bd94247f32a5ab08a63e9416edcfc52fecf7ade0b0ee333eefacfccf53e554814baa5e939221c6296e50d14094181187602b91c21ac13e1e5b8fbb147b8dba7724f44b67995af1f3cbf024257094dcff98027194e463d01be98e801ad4619369b2614448965060fc33678086ff52310d1aff6771e5c0a3d41b15897e49281c5f5bd577ee535601f706c05c64985606c9d5f8f0ddc111dacbd5b17394c4dcf1892604e2050b4abe5985c9b6d014cb319ac92efcee65883479e739b536e2bcfd3b70c5cdf3e844d1bece8cc9ef6dbf65452d66b618e2778fac39122db5d027c124c86570fb44263c7c2170baa9d0d1e18c1ce795013188e1cf832e441b5cd5e1890863bddf74a5e18b1f7c6e4858362339bdf8380ba4d02a8bc2eaaf826b060e1085b8109d78f51638bfae97e193d9dcefb4f1074a1f0e7f1ce4a0482a4bc7e2db864ced4461d3cde55475f74bffc7e7a609d603b3f38e3e4ada2126e9d5c4d22dd94c9df3e693f08f8d68fa5aead01548670ba4f95880279a18c486d9440f459cc29563454546d7c9068150d69217c72aac2e8d7e816eaf64fd207d66a650d7f4f05c858eb8f803a2ed5cb6757535b7bd33bd03520e59ac84a28e8da387eda97c915f5ebc11b71f2a5fd0cc90c751694564c41dc87d7d10e6231a1c5bdf6f5913cb40d4dea21a24854b04860925d2bb53a82c70a2245da7db1a570fc8e8bfa44d86fc3d6a76a465b495005c148f909e529ad360aeedd9d5b3cd1df057055fa1baad3319ccc8ca18ddcf8bc8ad3a87474af4119fc632b6cfa63ecadae7a397724f575215f240545e67f421f37a4d80922fd12d009e143471e855c66ff448ed021e2fed1431025cde00d1c2a5fe2637a849cbefa2834e914b347cc70a29155152e38d81145d3a7dc2fea07bd55b339ef5a0e4b4c30b1dfa64026451df05fa0296a40b208283d684b77074f72ef850dd36de66fc6d9c78af60531e82da5c329f65404c2b7bf9a91e0c10db7d6af9e4b9fbafc3e8aa71c4a9e91aef69f5f62068b64b6a79600207963faf55b9e1c99de02f59775ddad128eef0c4bb30082a99edfd5f00741a87565469151e18d132c8c76f96b9213d0325c59080be44a9a9fb4b5b82e7c0bb6cd2e3a2d9a197164b50872de8f6f0c2937d272ebd2326a4257265b8fec20f5079754ad75db79381205941da17625339cfdb5ce1efdaadad3b0c772adcd3483ef1d7039761522ae9a1aef7a013073ebbbd47bb5092b5a77dcbffb8651ff463c30c540c3a22c2026bc8cd436da3f44e8cf89d2ce6457a321e4bc46e35e604c9be9c2408d8114b61c8625891bdd99dd578eb5939afab5e99a508261f964ecb00052932123f0e70c285c2d660fe0e51d4195cd25324ea5a8d6411d2f1b588206d3c62c7d5593d2776a52bdaa720d38a4d57bcfbfabec0c10d3d51b703196ee25d608c0208bb38e8aaada6617e6a1b394e24ea118fcbd015142d51c7a05954ba0b36bb9712755c7e0ae302514f12883422d6f6d0e09df533f30717bdbe13abfbc57492cf7ddde014642b69cbc4843764081ed71bdb91edb9b76d2b90d6d574bc912bca1afabae09daf07231328cec5e80d1eb60bb2dd809871fa19785972cf3c3df269176103ece7ade3b96829880a0f985b8479c7c9d952620c2ba9cca3ce5665a3d89343c1c5da2e1b50728bfcb9d02e9c9562e14a007c050378f3a0bd72bd5f660b0ae00ac4f0a72c687fea09450d37f5a7adfc077a9e4b5c1a109847c6ad15bf2ca065152a6ecb66f424bd741ec34f15a73d01053139b2a94828ebb9ad1d2ff55e0836c7408606f7036304d335811c98488185530c9c5cc6238b66571a0e8b62a0ee8297e32ad75a567318d729ea34da83d05ddd97b7d799088b5bae8ffb663ae16b769282a411d2d8b4434879f6d129dc4f59a57f23832123210b9431a2f633599a159ce85300537195b48095dcdec52f91b42212c0b414c0c600e485bd997b51fde2d604c7055a8029b9f36eddbdd12ab074498c053b9ce8371130e01fa678d6829fb578eea8fd916eca410d2ae746190f5ae4756be81d038e6a5cbc8e75e7872eda4247dd75d82613007c4462ff544fc99ebd3748009a112bbc6d26d30304763345c03394b2877df0499973dcd1671effc8052b866ccc1b1c544ac46bd699ec692f843bf3543ef6af51f42c960f21f4a9adc55ed716e82e6682d7712c37eb07aaea2769358a0099771276752eb6a282ca8a41d95ce1d02f314ed11cea7fb96b4eef0d4a2f67fdcea1487325d18a0352fb5e94eb664fc0f8608e22e18c34a4c65b69746ffc6c2e6cfb52e40d1a8dee5732d2c8ea8d8e2d11b37c7c291c342928d770a8fe9d8330dc5ba839c702244a90878473a76bd5d9086cc1d1f2553608541c6d73b97f4dab88457c7cfd0bcf02805501d9bd4edd8bcf903f8a95df4fa630dbd80bc18cc918c5b3f9164153862e77c7dc87bbe38fd7065759b13b3cbfbde3acd854517ad4fd81d44681d724d41aee9ae8181a6f91492a57a0979f636aa848df04528114adee1e70b81f716e2b8c7b428c5f2e138d7d2a92bada16f1add990a61ca177dbd2935a80ad43893c586c7f5add41766d6368bfc5fae523a9959928bc830159c908d5d9fd2c566163a173364a78fcc4d46716d4616719eda802c28f8a9377cce209453cd7001986da9a748166297f1bbb08d6b5f7905a78532094f13c2ff8e6617a459b2d362759c2adb01f40a9aa5c4632fe606ba14b787afc4533429eef3ba8a992f753ac65e1bc3c11121f37965972d59b77105095f0243c223e9f25079935714b62b29aafafa07a7970c79f32bbcbd767c41a241df36f40f46736a3c2ba3ef4c29c7f2e2d6a33e35573f5b09b3bcdb5f1dd0b49d2a27d54823163d2af0ee060ebc43fb76c8a371c68c9e39a211c25bb2be8a88811b62c617d4cb74e779803ecc7ad0ea469ea77c0fa855df30cdd8e6728e64ffbca8d2386ac26785f3652569a205af61507defa1d5aa9d3bdca775bfacd1649b1be57a85494333912fb93696e9a663c13ab023d802d71e8c763e214d75ea4840f7dbc0202a5d0ee10aed6aa9b4ea4daf08b268013bca939504beac88be5d49d136c3409fd36c23a9aff1b88ff933a0c8534097e937b7c8151082d66db6590d257e0f32b7110a5eb391e22c9db2e6abbeb4c6a0119e98ae76dc4a9a4be9d782c7a412e0853ccfff38b9343506ca41eba49b751132d4b5f435f20fb98d508ce6d923b44c85af782414b1c32cbafb96a8f8f7bca0256a35340cf56f398c05f343daee499b45401a110d3e441fa62932a2b6a81d2729bf68554489cddaaffeb3c5597cc32190ddcc7c340a33d7445c8f051bebeaf1f88a937e502e373d87471801ebf5e8c976940f7dcec70d81ac38157702422e518abbbb3b5bafa94bacb554f0250152aa9b8729bf46b79443933436471af2415933e9105dc399dc5d513bbc7f7b6bb4439e65b883ca1a34b85b320b222bcecdb286e16ff94c6d5a785b88bc972f98c3b8982e21ec96c9c4224516d5af383c3361bfb12df3eb0875044e5416336b007aa4c9c2d77659600960a9fde706f88761e200ae549997f9237361d999c24f03348ac060dcb2e1ae3b4257875789a88c27715f0e6bbf5fbec8a8c3366cea2cec6db6dc27f0834a652a1f94531304b7c71f9cd680fa7d80511ec25dd7b3b75fb5be6ea0b1eac0e15c30355cad15b518e82e4302b96a17197f943890eb968df217c7519e6c289090cd51acbb5169096c012cd5618f7afe0de88b9343120e4ed6fa42231e2d43b7e7b29705df4e5309ec05a1fdfc5b00bcdca47e1e1fdafd8a1aa0d9478aab6bda192cd7e9307238c6ee6fd11cef10de21fd8038a38c37a20f1a068016df280cd356162cadcf91271d84a678341dd08357f50fc048c3be88587fe14ad5e8f0276dba2b0b636f17579c386ecee10b69007b0760cb9e126d5ea8a5e9c581a1f5c009c077a04788a9cee40cbd5d9f962c5a4839bb0d815d85da87df5e4328ff2c79c2dd1e527ee35632d8d47de669d4ea765c3cb61a376ed7376073c6a3c8265deef8cfabbfd80c8a11a6e792d6a9d15f75b45550a922e94f12cc4b916e097fbe18c6beb705a96531f759629a0dbbd1e48b765e837cefd02bbb03fe44d78f6e45e1707865c9dbfa99d68af8d48ccb018efc2e6a054e7544cbeeee17c8aca2f746ffc7fb75d16d7d3b0d0a524646545d070cc373b3dc794652793e81ebb119d731cca561b204ee29b1658917f98cf066496d9ef626bc80756fa0898e74e69e10cde849549957dc6cb4f85590a4e1e8945a249a6d6bd5576be31ef8f9d0cb67fe196cfedc2839fed5e024fcc3a839381de486596e118a9b48fce9a16315d720e9ec9e23bc2af15ce50521748b4086cee6521907d15eb4a4577af9b300a8d54ae44c29618923c3d53137c23d6bbea7478d8385104b3f54a7a1e3d7ed9a501c60af8021cfe96a87f962387dcd8bddd4b912a54189ff4d00d8e70ba1a34cd8169c504df3a8490e680d9048aa931e1cd87c3ba3124e6665bdd99cc82cff18afce2f0e4fb0bc0ceccff615182995b396c57e3473e538877916624c7faa31767739af4c331123cee65f590ea52440349c1ed5db02e9dc99071e4beeade6d5af647c315f3bb631f1fd2ba037bcb1b4a8e22e562a8ea4cd2c8ad813e901fbdf2397c611bdb82c66624d3e9a9fabb22d535dacfc9efd0790f77b33fe3e6df2d5a209b4b2977ff6f240ec3122262f8495a8088854de3c8aeb15c7618e4d0bcc271bf613a766736e0c2c44358e57fd7f82d4e9e7f6cedb16435b8d612131fa01c67b03ccbf9b1711172b30be601ef0586e324ab468953fc908c8b0063908798b55da352b940fe40ba432b7a3d8365b2028362026a5d44c5db45581d15912163f6f7a4bda23f65b614e18e6722364ac8e5e636075608a9b7d18393f8e1a6d1d20d563074927d68cc9fa0e527034d81bf9eca14c3fd661db0740cb3dfef0fd0cdf7fb85ae770ea74293b64e17a79f8983b27ed7f58f41a676a6689ef680dcf087a8ba12502c9135298205584030803c293bb942dc65257d0d0c252eec83e3a0e21617dfca8488d66bf995d863320c76354cc9dd1931aeff46b7df74efa25b5d2e971a15644470cd6c2e4a9881ea73a54b051669877f9f46d71c53d2c98e964774a5e53dfda85fe813481ffb48c0b68313e57e6b73a669d202dce72fa2377c07945d610de6f628991af40bde369c09c51d8230e4bb76a6b1ea63ef5ca9383c0137f847524b9f414a8f0a84fb3274f332ff97b5d8925b28d70097697843721f950621e2adc3ced64ab9da43a5f632c84f890605d7377a7a96af529f7d8e10ba0f812473a421fa8b071308e8718a4c13c4cde5b42ef589964d5a09f6b7a229b968452201357c1b8d65f21ce2ff178bf2435ab4cb03e793be4c4f9797ffb82b9c23675267850827dc315ef650010208f4e88c76c74e52999b141c9fb7bf6bee14f520103d2d856b47a30176e9bbba92a1f4b88c1bda07c31f0ae5b3841ee7d8e67175dac27e0ab20eb5ddca698df02e5a8313bee49304c09d24d277336807ddcacabe569425d8d2f7c00bfa06591cdc44e9592b080f73674284d0114b801138cc7b8451b4146734fefb22341c2106b33e0553582dce0ee84b640106900175ae8c84e9502737feb2d30df6fd2d41a5e75330a2a636b817bf580faf501505aba047fd01a6f13464e953847278b451a7a1455b64e59fea914d09aa31461f23a75264771d0ffe73d4e991780fbe5c4d9e0bc1738b830f0ca345a20f3a229328de3d5350baa969f68bcbab90bed31e716ccf09214340e783cd5d97a6c69b739507fd71a47c62447e6f034679b8827e22b28697b62ba5ef52cc2de4580b351582f4499a82d7bad50eca21e54cade11049016e6b3782746baf1595b98c810a452e2d173b22505472ef77dcf5787b24d56e4ff42870ef1c5559db98f623eba047cb247338c951ec69f778fc0636866214fa313af1ddeacf88abd80bc09ef217ff87deeafd6667c165bc3af2cb9be0e61a2fa87d7e4f78232830b62100512aa06e41392faead753c637f8434e515ab3bc735585a47592b9d8f3c5198b98ec9f316da278d5a32effe57a169cb908f4d4b40aba30bb8eeea0a7823834cc46eeb88d727f1e996a59d8058a2be228fd47bbf85c3d4bd7df412b802664770d285a39fdd0b24c8d911cdbc8d53000ebe55f24a38f69115e22acfb54d316e7d8552ad8f348fe1a97a2aa818840c8827e1732292d364ec8ab4a1496de8fd30307b9d4d113349e6088bffd359aa6d307a8cbe9eed6f0e76fdb46916a9de12448b4a84d01a5e6c636d7e2c1f89ce1122e93a54271fb348dd899c554a29d5bc569cdd640402e71e26a67d6baade2c60786bcc0213b0964ac61bcebaa8ad4e4dd339b6cf3380c59a1876278325eef166011ca73b65c4a97eefb16139473ed84bb07a57a0c34a76aaa1b6fece6c9cf11a70eb35cdbfd8fd1cb59dd6bda4d173358ef46412f27437020ede2e9bb42c8307fcc8f3b14e20d3fa44fbf04467bc24f12e049ae2f7a8329d4e8593e45ab168adf9b32a32de428263a32f0c712397431598d756e86b964700086861042d4166139133a03f47ed9f0a917b6a9617d9621f7c9c713142e873d76fb9ed466d24874a61f08942a48ad7bc88f54bb95bf86eea3a5343c4fc48b9a0a42b94b47b1d85e5a9523568618d22c6db64d8922d3a1deaa2c2b2f0c2aea8fb8fb55e5564b4a4eef1e856e178daee72b8ecd82649169a2a7ec8d41a080bbb69979cb010c5cc0f1d593cf4cc076cf6bf3c1d15c334ff2b0eac38c4fc43005f8b363f57c8f560fdae405bd32df1e04002023c171610626bb007784695411e5bf2468363af2285052bdb47ce3bf93fceeee47b91a1cf8db397ae9e3a8b45ddd2cb70d48824e58e54ae03a9d61065cd2c020a18271e304e1a67582cf7c554f99011cd0ba225b5bd7eb2e2ba83088cbd988a6e27ec73830c6c031756deb5b07a6197c0b498086748245257a687ca7cf2826505c4b121b6bd7b014a98d5a28617d2bfae21f47d8ee11dddf818bc15dd2bd57f40d7b5276ee2b3221bef0fea9a11b20c38111facec9c2dbde681dd2c9126889493df9bb0a49648fa1ba81ddb707f31b16b97d72f0087f8a101763386f6c3cf73156d4e401128863a0139cedac77b945c0d82a8f3f4b1e458b4a20b758fd9aba4b708bce93b74866c42bf9bae91e90a887e3a1704dc0717091139bdf08697f0c43f962305e46630cf17ea1c0a3135229403b55adaab4926c84f6b11ff63e1f5feb11ae71f52beee0400b292a5d1d2114f54dbcc9c9f1ec5baabcbe9ce946f03a7ee2fc8deca6144792599787d74159d251c5022cc74842696913aec9087fdc7f6c1290010a64058854f9899c0d69b5e744279f242afdcceac4ec526a95069704800c2be53d4bd5eb4ab12ef17bacdd8c1a3a1e5b3081a7bc94762f13f7d477805a750ac2c0eed1aaf10cd18599be89139d3854dd6f8c09eaf4e1b4119984a8bf6114c4c1ae7f8b89ec4b1c6c273e74bf996b198ae1454a74b305a7206cd5829c18d58d13eb320ae0c04cee20a6293a9298df5b0665fd994c693bdc6354b567f856cd1dcef983fd19e8eddf15d98e5fcf5de247cb7f1b942d2578f0c87059652f465222f8d914f82c66e40d961f65a74a9673325d4c8f620634e5368a19da95f5b5307e39dbe6deb4f9087cf661113b6c81ccbaa75c49015449a9276522ec8b37a9350d0bf04b60bda83dab2fc49bd98edcc8644643c55bd70bcec86b650b4602051e18372e6092010a975dff07a4f221e635fd2a339d54d93bb987bb2f0541413985eb8d9448ffd4b029110b5ce32511d3a1b849f972e8a8abeabcde8745e30bf01db045625657c9ccc5f425e3e550536ee30759b87256e4c91624e1032c42cfff127fbeed4e5609bc7d63957fd34ca3bac23252b8ba60506bcce464463e1c487ccd31a3b9346501df23c9ba754ce8aa3e046a83e569aa509fe0b01689c8a3f519085bd179c573c5a4c6a7dfbc183dc0e3966027c2161632c61ebf29872b5d728903dbf2bd74aee8b0b71ebb4dc6ba8ddd9baffd3d32114a52cb7b29257bd0379430aec75db01a52ad795c67abacc907c3e0b38a0274efb23407a97dae90dee4169f2cdd8987fd88ec84a664b0825a57b4f05cbbb71d260ad8b3c0de24f37eb8e88b2bd8848d94d910a853865914e67e2d7a3ae13f3ba534f60b77e0e90ac0cbe04b114599ba64889d44f0042e27229497869b84f901ef23ce4e0e3a62c28a7f7a6cd58d4c152070504712a6460ac1e6e463ccd367e1281674df373657de61bd323f5968f76ee2f38f7daf4111779920ff626b48d0daabc756ecaa366314911bfa86630e97ef9e1dc7d20bf16ad976f9326d514b0b380436f1c29dc9e7bfb2a4cd3bbdcf41f3958a7fa0db7d399b42334707dd94658adead7966548ba9911f5330f2f94a38769f7fa6746590de851e5f3a3f89e4c9e8f5d923a05f32951529cae6e75dd2360526a44b609a63fe7f75ddb1373dcd5f54a9deb1b623e67a44f1b0a27dbbd17051c653f6b0b707d714ed7a635ffc9d933c9504e9ce99b965e32180b78f7e7cecad3d0c0edb27d8c200421cb7893edc10626dc725e69b1472bce41a585b921839bb0bb1407415025d5b2affabec1cfc7608d9e4379250aae53ecf388e7ea13f2ceb44efbdc3fd7f2df205d4b12f9551fcda547643a2035cb5a419d9aede264c9da39e00e79f07d25d65c7b3b713eeeb104b54e7b8b2f2b2669754435aec3dbb49ae6633631d5311106e36a72e1c8b18e2645288397f7ae4c4af7e0f6a6b8c764dccd983f85b5091da989a555fa4cb3f3c2f2dff5927fb2e02dd856dc779198c2b1bea1a2c3a88c6bbd5fc6f5df4bead4f8bc8e9fcfcd755bc00d341118adfded062a3e45717bb8af5936748e822df78afd6f7a555489ce9c76c45b739dff0cb3812e4f3714e2e36ab15b7921f0e62c79cc470eb89a82f6ea685088db0fcbcb5b7cc76e6fab57065cd061365e1d69ebaf41d72a86326a0f9dc2e777451bc02d6b20270fe7340a5a1d4a3df9a13124104e9685152dd29c403ec404844c7f2a2f01892937fa5b7997f2358f92d30ce953ae159273098f7ff54c24881032e8d41f2d5a74cd9177afae31daa40783c811f418d7e366641ee775985c114c58f11d62cc1deccf75423f485c1f0885f9c94acd923ee0c2312066753a2575de8875935f5a4a95300f84e1645f2cc90fbebc54c224324f7713a7fef1daab99071d0178709c9559f181e9bb841db605aa7706ab6e434a910ddc7dbadfe28042cf0a45dc6a98185143b0678fef7b12faf98f64cae1010186551753025fa2fa3edcb3d4b755ff22b9b61e0845d6e25824c7324cd0fc9e9704e3ee26dee840f5892ac79abaa80e735f0d3b43320ae7272923e5264eb2088ae9be2837b7dc4badbb23002fd4e28ba7643bcd4c13f9c4fdb5d017aa392af09c9895716f6a7853fc47cf3e9b6efd81075c7caf2ab35ff7d25e0e5357d0f93b72871b8cc8f73f6991bd472beeb736b89991b78909b52f121691ae25c3f946b192b3fae15eee983a34fa587d5e8d544a1d28d23f98a5962e93a3d6da25e879f47d361156da964be272881e3993cab0e5defa9103874c21def6d9bd3cd36ba2e0522c353cb679c267d2415790b9f4e85946cc77922777cd2bcdcf0e0a659905f1d7eb201d5bd74eba61013c65385bc45c00591661b7012351ee32f58694ec6f617ec3132daa3cb7614cd3977ef49a6f2a92984d4746297508368e4c3fac6534aaecf1c29ed196da6228bc986581d12b98936e2fbc2528510928c59a4504e7d19d3a3fa27dbfebc31a4958ed6646dd0a155facad260db8cdb06991b4690159edc1ff384eed72fe175e862250a5c8b77324f207443cf0c4df7b038eaf611e311a676b16c6c3f0f2186c0cf4f8553c518604e279ec849856f85bcaeee7a5c78d3f12da1f4241aa633eef328deb593c97349d50357cf16ae622596920defa6ab717722b8a31779129e7d095b5b920123d82dcd85cbac4dde5282ab5285dd6687e6ab4230a5ec9ab0a2e32843fdb047f58f7bc9a68607bf32a0e3152bd07d9e37bf1d0341d11d46328c67b9ccb4965e567c8ba828b205eb6a08f4b690ddb09ae2e9b7211e898e429b5a4060f0bb9614d03fa2a56c6fb7b00d9d398d6b08cd98f6766247fae50ba62ea214d41f5b2091ec3c7c7912189a36e77e55f2f7528506bc36b5966d10d3d8f3bda56e5b5fd920223fea3db72d00fd7fc9daf2b977a581c6a7756720a2d74bcf5522cf902465a2c507233890bb6da959c11cb64e2f524931efdb2394f20c4560d0ed4c39e12f2fc98aa91e080db085db1304e1af9a86fd9487747d0d768d8d23167b6acf9409d49eccf95aee4e9a6fe4d007ab9728f9140031897e6944e766658510df5291bdc7d92f17d1674248d71b74afd1f61cd2cf502ab02e7fc89957d227e75d24ecd4b189e8e1fbb514ea9ac21a78366824cc8a36253cca5515f4bd4d9bd4c7abfb83ef8830d0ff83e9ba6a1a5ea941494120dfa2b500e2b3ab95e0d984216888f2dd69c3b20a60dd2cd15fcbf3f9c07dac7dd2175171c3928e35c3843fb9e089fc07ba08ea65185ae5de11a6fda5cdd156a54b4a6ca2d8987ef7e8f1c927300a544af10472127cd7c8e6da26c75579a0d6430bc932063377b3cacd2f448cf44cd26346d3c623abe2a4bdd2ffd7997338f25c8c0982fbea09f44792e98f74b1a208f20052aedc1b4d982b28315cfe0a578623e2f979400a74a4f0efd9a51cdc3f7797458900ff23f657836223ce5260c0d689ad13f85bed4a9718b08100af2252649a666de9bbebb141482d2b3708a0f7acb05a8610f5d8c42286b0394b50a88ec148d5a3bf6bd163c93b51bad3d57fe886506ad2fa9c5b2a215e7dd4e71783269b1ca75bf1f33704d061d2ecc07ea4ca606d1fd3fb42866fb3ebe9bf3a7b9c772d830cd4230c2410a0182d1b522804f114eca35bd8344a810163704446e13378097c237390616fc20a7b156f03688086455262d75ce10145ce2e952d308fd54b53e926ec2341cde094406de1833d2714ddc73accf8fc8bb62a00e3977746efeafe081edd22a4d8602f7728ea6d0eabfe004b3588bcd3ae5359cae47ca4e44d1f7563a018b163e06f9329e2045e0da048e4e94e2eae63f68d2d14eca015c21453e4d17d641522214436805510377f5677c642b1f30c2ee99e63b4279e9a5dfd989a6d52495a1122f8b737785d8eac0d672041b824dd78d2848232f7a1aed598fbd2ed9edd43dc4d60ff9f96898a2a8e38cba459d17074291e646800fcb295d1c237684f891fdd7c1f0ad219ca760101b66fd1803a7290c728cd2ada316bcc02af584134cef214ac855cad545ecde9b9a3156c94b40c031e4ead55b38a0befebd878aa227174eb04877134d6d1a555bf19c3437eb05bfa40c949c84c0d8682e63f9d195f1526810326fadb88283add4116f9e40143ac2cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
