<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8e39f06836489b3ff27905761963322366fdb3eedafd58c70648182e282cd989b91145592c6ce8ba08433bc4d3b3bf029f0e7fa61b07600197925e0f92358f5519411050c1e17271de55683a0d0c6e80e19a1947116bbd9bd76110f8cfa60f9431c853c553fa6a3006100d1dc9c4826d8a5852b219d0fc48ddece86117dc69cbd23f02839cce473550122f00de3035b6df3eec410d799519a8c2ff45b165c3df6ea7edfec5e211ee0806faddc18d4e246e39fee0ac09759d12b350c4012e6bb933c4c6351d1c1ca8fca327a6588f5ae3f5c85e982bb555906719cd98957a886e170f6fe62d4619652c6199ff9b4bfd694e0d02ccd6dce51ccc0a652c0a84e8ef7eb25a4bfead05e0c24acaa8b7821d7487ee88b47a97a3c3ceedba9ae1bcba7b5b1d9621a5f5bc792bf1cc31e722c61db604b782488944870f501bdc0665d7375ce22ea795d39dd063ecc53ab3e6d3d2d645e812f969037415dde890330fd934c7bb47ef9c69e4a1d4aa6b5ee0fc64382cc94d2c3d7238e1f512b39c114b519214a71d49f2e4d2363ec2f3c4c43c40cc6730033e461bb7054f1fe101f55f89607d49e5607058713ada4ec650956e58305d1b3248dfb35132fa39b6a2e08c564ae0a3862f7dae97f8a55f819c12f34abb781b2ea3dda2b2638fa25715dd3127ec6820b1669d7f53617e8c392a4443cfe31ac619cc77d1c3f9c63e2c973702dc7c69241d036656277544d204538904c29dffadd2e0d740b3e7a84b10c63f5d6208a2b3d60b6a07faa121699b16265897fce7893c4edc2df31db3fe9f16b7b5ed2a32eaa9b5f48cec7ad5807a675c4552b58cf5aae6846e7cd9f56d0a1050841eaad245f5107269ad6a7685a9317a4b0f8fd2692be4e14a173c2fae96d010f2ef7f885b354b02366c7e8a39c7991ff7402b81c6e10e6b4a61d8a30dc2cebcfa8876c9d560fbf5ee113c453b8d710f26ea69ea4681679c7e80b3190ae3400dd2ae13349d6ab70bcc00013cf2f618f6c1414ba97d2d46689ca9d87f251c7fe841fa434489f39b3397b73544b3fa897ad03cd751d248a14da18cadfbf486001b37803fcf451b121d6f5465ddd0e2f9443666cc4723c3f3c25c6050ccb3c333d0daeeb6e4f61ad23ee3f7d9890f47322b51b2800d4bd986769a7272e85deccf16d956d6dd4f5d197de0abc4c0faad994ed9f028bc853b322ceef984003f5a1fb30dbc0bb66b07b29b40cab60af6d7082cf6bdee520dd58c4ec3bac6576403260278910b53daa150399f7c27d95cba645d0485e4a012329a167a2e07fcf8407c29fb67cbf635595661dee0283fa72061a10fcc6489101b6839898a500eb7225d32284c7d7ee10eda161fd58dc9029f293613f819e606eebe9f20731014b6e6ce0b202379a5d558c0c17154c437d9fc650e77a25ae81c04ce465a661ab2238cbd56178ec08c6123d06c6ba3a792b4eb2f7edaab34845213f10fcbe7c09e35075093fc5577a73363ba321cec15726712dac5c2c4ccb517581967e477a931fad72e6d6dd28ad0e77ac447e63d9f2aa206fd51c46ce5125834cfd0e0a3b4beb0fa6753a21f52e4ef2833849706b143a48fab56e59fb6163e2e1c49bb99f73955d8ec17f6ab3034b8b8694345954064fb8c28cb7eb2d163e113053cc25b4863bea6b8f342661996c7742735afcd190ef654ac49f6a1c3a4ab3eaa83219adc6b82c64c6c94d4393b58649d07a0b22c8e8f609d4e465ce42850a20b1e3ef4e0a98ab776dffa4a334cb863a50ccbeb6c7fb636f9cb91beaa18ebcad5da427ccb59342681fd61804ad18bad39099a901cd3b64ec3b5315edcf606eb41db618be581aa6314db18098fc2b3b86d62f2ddaa3f5c1ef24d0603f90cc96d45177e2707e77dbea9aefa07811f47406074bbf21e4c007a66ac84d12596e0e4aae53275c9ea72ff4c9c05799a338408042452702a7ec3bbd67646e1f6f66f2e493ddaf0ac9218dde6de1c0d16299a46577f2157dd6588c658176b0b53926027d994c5468aa9932b727fd864ea9043455b11d4501ed3b84d7c2aa88a880fce57657a28a28a9326c16ec9fbeb73363f9bc144dd6d98a9edd932041357e4a7b9aec41d9fcb1f21bb2580ec6015129fda4cc78b05556f94a9e2edc103b3dfd7894485707c32fb9402e1f4e038403c0f92737260e352ca3ac14896d904e8ccf5c078cc34600ae4cbf1e299035c34fd3bd2c33e49e867462bdcca7293983cdc24d0b7ef8382fc7d5915b2906d777df7084c1fd14c3b4c38037d5d830a0d52eefb18e01c2eedf14c493ea8cc2a8343265a5d22b92baaec53a879602ea399de3a411c66d68270985becd7e6318da8a87b86f4404e654cc3494b37c839b6daf5282d7713be719edaa576003ace0c228114aa7c86025b39f8b56ae51cd4cf5bbeb9014aefc63b7f99660751b21c490594fa8a7879819d9dbda008085bfec939c20de8428c32156288ae50cc51384edfc56f1dbece43a3ef97d9df102f28d93eb811755cd96af8003d77e95765a3fafbb2f9fb0435c84368133bdd75c671bab910de5889184355186e04687b7a04e482318b9d695bf04483ce5527ccdc2dc6885124e450539c020a0d4d02bde43098de25639b8724634aafc36eef78a5337a29e8efba5c8562dbe41822cdc4f9221230da78ab23b05b14649365a92ca2b155b9c72d95856a7426506d79ffd21b0740367ebd9e37a70521dda7ac9e2d6585b1af3e50258a037bb6ea6b7c5b451806ae68944e6c780b6a4ddf9bde8c7187917320777dcbba36c2bb81b8037e7341a1e89531fe7c6bed982519d1694d1e0ab5b3f79c5a094e1ed6b8d8a2ecf1601625b4c033eb5491a2a2a44f02a7251ca8ae11c7b320302b3db45888d9bc087e1e207798cb46740793e21bc448122cb139dff829c7105f4fb435f90aa29a70f0d39f4caf19ce1ab2861056d3154834e2865a17d669a2462927f3e40ca87e61164764ce660396f2aec4a2dfe56d01104ffa770553dc7e2653430219486ab9bd6b3452b468051d34e1026460174a4ffba2420a60a4dea6a076e85694d0cea33cb2b23dfa8c531edabca4db0c2f1f935e946d358a971339d4ce523e0105f22719aa6ec28c951056bb6c0b402a0f84893607cbb0dc1040a6f3c9140bfb831a21dfff9be21d3e391337424f1ea96d9c69dab824a3bf57dd215aa38289b96110e46fa1c4f879a95010b92924313fce3b57a1fc3df92abfd215785bdd959de44895b35f2282011f1ff0d5e3d50a8372c1109c47bb382f812bebf6e719791a08ac8dd1cb71794b5793fc1feb86461a35ed89e177fa016d48719818c8986d9d98187fd6d0bb2d02f45fea941735b62599b12b13fa246be2aa994d7f0b589dc42de279700e578a5962a33441b24303a19918c5e04bb38153c2d5d00435639747a9a80d82f3ca4bca5ea183b92ef2e56b09802e9170ac673bd00b014c82cd7fd1e8cb18354c7697770300113800b716c2c794fb55bb687c1629e5200079f866e611f44ffcc7922014c3b5cbdfdcc124e99879f1889ee90884695e012f770ba79864fa58db749f612a23ae19d22b9025ae4e34b9fe1ed53154ff7b830cc5813a5a1894089b6f784591afc8a967e4b65024db90364e2feaa610c0a4f1def77e09c64b573807658e0af2585d4b0867d9b6e984081e311ccbe522375af076a7932df70c5b967edd0eb61bc59273e6a0eedecac3c02bbb0bc1a01d9e89067ecb28f14075270a65d08262199201e6f2ec788b66fa6f24ff2b5d0b4d60454bc3a7bdce08f762af3334046723368036389d90e35d04ac5b4d91c4de1a16d6f18821873075a576b7528abc03c505159c156595bfd8a7d2e52368ec2d11d0cae6ccd1493eed6c4f72242afeb374341ec5cdb2a7ff4eeb8c0c405d03ea16c21f7640d2888741df62aa952caa3dc31523a9072cf0839b8d62cffb793ef45bccbd68e94b830b10ddeb60206675a2df81a0289945ef95647640106465f7d96e514a0b2fa5d85183d515de695dd7430b0b04f6a7076e79acb7bf3422ea03e7cd854f86c3cd0b158a03a760582df4ba22025df760e08f3eef277a2dfcd1294baa1a17dae76abae693ed2364e3aa97c0424e07b291d75eeedab454264d79eaad6b790aaa4627d76fd2c54b0102461757cd71ef7b8ee72be09405cbaa7aaff97b50d626e34fe03707552a392c75f2cf97062b01c32c2452b82a71b083786571bda5322717a01a4b958e4c9d1d02a1b388c112cafa742349fe3c4fca22bb99cd6c81c67cf7de3b3ed3e9ded3682c10a6ea1a6007e65df1c414d4e371229abcf34e4f372ac15b03929d600a7022303422b1734ba4b1b0d01048b1bbc1d3e4a27e3efea792364077173a7acfee5b0d93f7ff56cee12140eba52dee8812ddcd7c832855450658a1bb7eed4c77ca5e7fe323de515a6d24d3309c1613119e80041de989e88d16af16244933b0cd0fa448ee639ec41b324c46ee96b8c99ac0841b2d59cfda5ba8d0cb7cce5b725408db5029d39a76c301e0184280f5460d2dee8e041ca8aaa450e822bffb2c4b238ccbcab3748692bd98f613749b4ea0ff0cae9c247e85950a719cb916cf7598dd5d1477d483ba980698039e3309b93a8baabec01ceb9949ed5c9f8674358dcbc2836b0b482d5fcdff7a615e76307f7030c5aefad78e0a622657485656928c7d2ae5b84fb1822573b3299355b67b66b0af760adcd5a8bff97e0ee98bac2a47f0975a0742e2261090049518c156a0c61c9495ef4e6eb86fd2bf77555a896f161e7b8779d8ad394d78927b6282bd65b8ebb9f02c75c43d34570b38ba8cd24af3f19baf9356d3e41d439795d9d74f8a259250c4fb61ca26d47decc452cf0996a01f1b7672dab418d2920f9cade57bf6bf58bed4f66948a6b038b98425ad15185ffedaf8fd7119000d471937fc0c1e59a1f532bbafb78f8917649e35f8731de2571c0710584452d737c0fce7c2a60698697405c6ae54ae849b8f129c8d537bf21b087c317033cf8e76f5c8557dffe79920d553cdcac5a2817dc5889a4d9e05233e5d2c8e5b56cdee19485b2f30dc1eee2d723aa81a5bf5543ce600e239b08346dcc5acc20e8d1c1a3d4c900c6c83cc3cf32f44ad1ae4eed62d67eab585ee5f7a348f70ad9505547d913eaa22b172e1b15c282a87a4e33da1cabe25a31f22784bb1d701229b3b56e685f46e1ebeed5b7bba1c59f8827c188ba5306ff22572f4d433944d60bc1f7f7cf4ebd72f3c7d514ae198ddb8a4e7267a4e49e51bf6261980e51cd3e2dbc0f67dfb3f6ba641025798014544c18354c37569eab16d90d6f66584cee57773117a3771d467dfa8fab5cf3dd4f2f5633f238b991068f8f209df97ba0675ccf5631feed54a21cafb08a8d6d79205dc49e44eac6debe27044560383aab18281f1a21dadcb8058d9ee2251be6d0bf7fc02aba0efa7791b805d18186c0303aaed6f6f51b2deda8a46ab45ecbb7d8a2cffe1115cccaa7e075ee6aeba2931ce75bb0ac0bc1c10706862a0719ee2459d440be4806bdffa8f0fdc3e673e99fb335d3216a081ea59a6d0bb02db37c0e5bd38e3445911ec4c76230cc5758bf4ff780c46ec9ec44dd146b7f2eeb0d68bf245cf415e2101ce2a02e97c1d04410fedb83cc9349950bad005376bbeb914f3c5874fa62112f8507f00e962a3be1f054878ec2df5bf6e54cf7c9bcd2589746f2992bdae87043a69088747fc4c28ab6606d45696fa1f882c703a2d1f6a6f1c8ff1e084dd618c8f7b8411dbde2d108409fe320bd8a214500594c60f8cbe318b7d115ca81c8bb00311fdc03ffd582981be1e7b963f3190b9a67b67d346788c0fa8c74249bdf0014499fedc429f55c08130678e6d5d123a23dcf5e716306c2e63f3fd6da1608eb5330061682c9cba9a99a45fff9fea9c85b99a0ed7800dc2b05617c0163c41ae45356ce5fd2f34faeeaf6de82394c787fb6ddf0610496abdc1e22c5dc3f8959a1d0b2f3f7495dacee7979334e450a9e6eb73c7a87f7e6d36389941c84ac985e6fe973f2e7ba4aaf9a23fa556c056bb5c867f8acf52c535b279de073d8e4f8f3f3581536953ff5e2abbbe1c062aa56670ae79b88613e819e50739e8ea2eeaa4baf2d40e3544146cee3d3d849f6297cd5176d697a1e2f61a71793ffc3b9749fed1c66511ae302f1a8d54a70ce03d285165801f736d4a3a4c58865cd9324f500f5f96aaba4cc8f26a2a8d4eff259a1ce778b54ba40ceb47420a988b3d804c5bc58be909294b06fa3d8cd8e7e66704e1646f839f478610577cf56006e93443dc39c7fbfc82d4371b38d20a224cb15ffc38e8dd3967e0c7b98a649c3e1977d1b4859f3a0d137e1bee23e9329d37c80a76111eea82002cbf36bb62ea65eb178854a8b3d1097de0eee197d88770327745626dd6d6f8b5c09474d9f6261db428d87897e8b59ad090523ba8819223be4f50c8aca9b153f06de9d25896e1d22732034864506d30141c597e8c42603236dd5915c519adfb90f99e8eb6ad28adf8f728b4255c8beeb55dc2b2f3fa6beef23729d0a5b0c1f4559307e2f728e13bc88f9d2dba44fc5c7f9e00a9c13e18bac96d075fd1569752b0115737414e3a9cfb4b690db5c06754897aaf54e7b9dbf32113fc2e9a3cee56cb0646a8f5eea407908962a84ca089e70999bbc2d10ff0d5e48143138fe0134a2504ab9364f72c63de00044a9ccd3dbf1f84fdf79dbd017301d8bd3f1723819f3a4d59cd70646dfa8f0ec05c184b5f073dbb1def69cae56b968009bce375862d10a280ba0fba93f8248ae3eadb92c076409a6c03bee9186520a01d02d4ca16b2bfe51ac5ad496aacdcf258cb861dff1ceffd8c36466a20b039930148a8d81165f7b85138a25fb3dbe3171dbca66f5a651bac579aa73cb1ab58f2377776fe84b3ed80cd8d1d6d42a30eb91e8a5fc147f61e7a9074dbe379c9f5199cab17fdead7f9d437eac4b093ebe4f50150239c1d9ef8957208af56c581fce01522d3cfb7c56b8a34c94966f4ba481d7d96bcaa9b7b884d85878253fbf145aa1cfc310c97f259cc7e35427c823a82ae48525c46dd4f87f31e914045679c09b55697cbecd1585ef512aa40fa8c973000adf387329e57437e67fcd0cfd7c53f7d49c37d3da9a9a3e9aa235c369bba0887a382e95cf8e56138ddfd7167f16cf43b6bfdfac877cc6e94e76afe8e77f85af4f48eb9f42c0b63c3fb83295ab5ee6a23146bd95d0a491c2a5ad90086d73a61d05c2fb709142332ff31eee561b81ba0b5fc50e15fa219dd7c9408343a0392b1a036b0cb11110586678802d54305ae155c0a7d6b1e90bca05ed36652f68870d98fcc6369ac2367644e2875bf280d3ad3a74295b104094539e2d266e7af57722c829655ab196365ddc9cd6530c2786a1e406ab6a9bcc7f129735dbaf5c47294bd00b318d463583e7777907182d465b7c672b1ac768add4adee09eaed2224877e54716ad17555a190c207e3033401f99d561dd664cd2c931c87176e9f5b44ca5c5f0bfc105ae45b507adfbf7fdd204c0f2be7ca9eecc17a17654df6f24db32850b1a2f77d0d9de0aa0482ae0456908ac32033b03148e997c394fa319adcb581d445e648c723b7b591c4b52184a8a1e495388f0f37ec4e540786395062ee9f865616d208f5fa9a47f6dd86f89e7b71fbe976baeac23ccd3a470cf19d9f8dd0f329a7382a7a9db0ccb7629865ea68b5285b64a2e9240656ab4d17904f42d051a05a57f76494ee43b867ca6bf91446644e1fc8fb7ad1db03f733fce2c168e6acdd4b00d878edd57a9bf9c012ef6b6ed138df515969f948e807d6b846fb53030d128b1a7eca6ef2b9f5e55ec99d3e93cc539749d83832c5725589a74f4141c130d4ddb71fe06450385d79c5a3079edb0814abde7c9e54bf2172d632bb2e41dd1de22534c265685170740bc1ee7e9d5c081c28291f7e9d313de4ad92c20bfba6ee0e4a02944ad7bb1958085c297a93c4c80f5d54a69f8c56a374cc9ecf025e595890e45113daa429c47a4a67673418f4361206672e438bcbdbd73c2e6d12e7e03cd6ea4d17f0ed778890bb2e76c1325371054902f93ef269cbd334dc771d2c23941c5f9ccf9287415e5c66874f6bfb056fa04c7dc43d01a4a6429ce95f1afa1b79c933760ee7df371a6ee13172efd584b8747147531a861d2fb259cc5e0149153848e159421739ac3539a08c5c8fb929875a6e04c516bdfe956d6e6e738b7d5d9b5d03e63cc4afa91aab49ad9f1c5dd5727e68362785f9f15a10b86367b6a29452563f6680608f58fb00858de81446d2cbfe50de6fbeed1d0a5103368b02f0b297ac2c810cd7839f35611d4af5de4702363a9051800355a439e808972b126b12d1ed2499f7d23e97e9ebef67d6602fb759b2bf0a0816e5b054f0f95392d462ca4150b835049c9a711b2cfbdb50c82f3310163ef6e922f4dfa6affb2f2d495346c807bd88ca2c3ca6569bf1074b93811d0c2bea8af81012971013f7e59be728599938a8398f262bdaec5e1963683f1026ad3fc6ac8120e4785afd7208a750bc378baef9919e948707d281f09a8e4ef1d8b31bc6b161af69c32bef2daf2d400d3ffda4f1e489a2ee8893862dff5322d0a6cbcc561da43cfd944e94efb60c4359b2b387261b7153fd47ad043d925962442a8962fc5d5b1e11b8b9a4319e35442a09efcc1cdf2a4f0ff1da553b6b5420ca08fb5260419ca766e215a73408270daf8906ea34a41b6bb4821af0d4dd8703f4e76bb605a1a9eafdf3ccfeb597d69b06b33e233bc4e4986a19e98997af9dac9f44228158f86e7d9702ed56bec97b9f2f622554445a30396af5027cbf3650460fd7aa197d47f2c330d7a9b76d150f4e8577903e7ee0452053651b3c5a9b48c0727ff155dfb12a33220ab29ac5a01b7039b072f1b28aa7a9a0c1b383d6c27a49a7caa816d7c244e8f0efa3e50e17a4634327b94178dab64db407bab219b8f3ffc2b14950709791a4ece0ebf3fb2bfee1f83281bf2f1ff0a0028cb486669029380529592b54f1cf1fb395a223aa027d188802c4c44e41369d8383011e2242966cea506b3e0124f0b5332afdc5f27921cc0ce99d77e95891bf2da7456f7e5c255ef3029cebfd9ee34be8a5e73f89c732fea7be420fe23dc737a787575dae55b9dc9e82eda1dd49f44f6fc1647a38f55f2add9af447b6c04f414475052acbfb66a5dc7461d4b373845263ba761b20fb17e59bc7a24aa32caa675a06332bdac12377e9f03c1b0c43879d29a83e15ca0ec04ad9d96414975e15da7eaecda1cb277e4bc747d0fefaf186fd70bd2b2580b1b54eb9fc921e06ebf27941ba1f5e01958939c0704c3dc4dd6e2c9a8fdeebcad0a5b00c27b16b1a97a5d35140aa32e065716af98736b738d2619d4c33d7dcc483b8d3e93e05d67fd45aec287805f2c74b92b40ae2c1c95bd2408f9e4e511f9c35117fb8529716d74771ac30e797424b59d462a862d9ee6ed3875a2da528c91f762434e2e086cec60e1648ece882049aa176f86e94410338ff831641d146aba7b14f7cb1908c9b145920177de1fcdd813bcdf9f7830e631b7d875bc7851f55811f8635ae1a8dfbdc86fc7d680a87394dfd39136602da1e944d13f757d2701d066d04165fe535e4f822262766ea85fb6f2e5d018e72e44c55400addbdedd8506f9d33078c280795bba3bc9e72b113a00298bbf4c517d83866a86f7e9d5dfe9240ea27f253ec9a9b6468f41ae077ee29aa37c4ed7baf2fc44ae2a6d38d46aa450d825fb83f05aa25feb951d6830ea2cc811f64677aaa66721a241408bffda49dd23dcfb0913d6b73878e9acd77d0a292b56d4897a297c1761dad3698dc9331bda87078d6541019e3e043dd32e9afe055db67db2091a1246b2c7dbc238aa4d6493a5cd11f6a6d0f401a218465a1691883fb70feecee84004a8f10f9d432ee49472bf14a831e8753d093d1ed8ff1d72f9bf2166c14073355a98c38037da54dae6566e6c700532d997e775c546ce29858ce8ee36a28adfa7f22937359369a392024db070cbda18b3cb3a619295bd2f464a4c057bef9c7b5c17f3b3ba2caff6468fbac62999f6c5f09755e9f13823157720ac8797ed496c74367877a6834e1e7dc442eae14f68dda1a2044db68718a1c0b6e73eddf9404060d3b75f4e498579d91f30ade4038034c6e2a32ee11198d6c3c932d78f4e67bf684d0ff4f28cbcfd7b2b4a66cf9316403e6a421500a9be92321f7ccd12a3e8fe08f4897da82f07a51504266e8257c95477e4e6a39f9698dffd277f1a1abc7b3b6250c35896740537353ecb3d429bb448fcd24f086250c663f5a0a1f4ea9ee151954634118bf06a82f6d2e0943dcc91968076555fdbc0a4379bc4ac8b1731ca218a98856e45647853540368de7438eafd3d6294e2728c99d67adfe85ec970cb26e7b875ceaeae4d7dd7aec72778884b42fa988e00effdd3b4f6ede1b014764366277ed4b013223a894d570898a4646788824b1dc9b3dfd404835fe9fc753a735644d6fa2c995472c70417b2f009dff0d55c172e2cf40aea760058153ffffc0beeef40c3b5947adb6c3e2fc5965d7421f6c29bfa74c88fbbf08468989b57e3372b86d98143e9b50ec0d054d74cb5f39b964548ed99307bd82b59a58bfc9ba7510fd49250d68f3e7635b0ee296a1d9822fe80ac45a5ee1cc7b6378d13efb829c1b7ab331839db5a6705c5412b2742d2f9ac95f850e3a5bd83c720183df5154048237be479ce499f3b6a805aea028911f7900fac667325a064edab3b67db2a58a5af551c4f6d137e5d881246c5c570234993e8c507fa66b5169e0533a79f7d193508b9bb34473147560945eafe43d6c1e1bd1fe941ed585f5e6ead612b6a02816041dca1903c38dd48132de8687b3adfc8e008dc013d65118f996d1519f293308076f07c6ae839f6b9b3ee483b4a95c45b8ccc5ef7cdcc2d31a103e51723794ef70f7511aedcf1cc12c907af27f01ef5e2e303b8e27cdce699718ac7b3a5e784e018ecd0d5e8c0cccab1249a0793f1e33b22c16052b326abe6c42dec62e6105297a916c417448cb367a884ce96320135dd5e541684b7b34d565da9305596a75c77d8f8b9f207a676e354771b425ba78ce8076ac6e45aca1f9d86bcc28934435629b0f75864689977834986520b2abd86178836fb8f335a5dd5b7067a70b97b0b234fbd5151c3a3fc54251155316152e05ac5d6e50a950e11f0e6670ff6ff55e7009365fc82cd462627c74eba4a8bee02b8ded8281135e960326d1ce5b012708a4e7e4703b208883218a3f7f7444566cadcbf52cd5f32388c49f8c40cb4fcfa7a5f9f842b0b8d4d45b548bd7e80915f67642c73c155f34bd193779dd536f04166c37479403e22597a8b30a0571614b21a2f3f9321a336b060e577875f796a0e7176be961c5039860fee5011561834d5fb037197b53d83d46ce15bf673c8f5cdde83b0fe91e0ffdde27ce9fe220985ce5eea703ad45b273f4e1f0a4e760cc92e42d12faef8aa41e8fb34ec1812c8e2aa5ba574b78ffc072e7cdff0cbe1f1f43aa33750bb7d63cefb3e720540fe13a8b5223afdeb17d71dd1578cba539521df8a8f02e2423d027a30f7356f21563e3a32d2fdbfef8d34129eb10b3413810ef79212ef69df20b6867214fc704b3803cc6ce77a56a6e9be493d498674c68d17805d2a2018853a2ef292e2324b81040dc8d61374b36b4dfcf0669fb9ee00e218eefd40a447ff9b60dc5429b93c877709801bfb62c74409c7555b8f507e1e00ae68273c30fe5cc62e68143df8b7f91a1cdcd0c198aa178a6117124576b6df17841e276b25b848b8e43f43182e1faa6b5f24cb8535636860285f3208c9cab105ab737f967e5b351b64c854beeb25bfd30997ef98ef33df2eae47c2491c6bde36c8125401fe6b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
