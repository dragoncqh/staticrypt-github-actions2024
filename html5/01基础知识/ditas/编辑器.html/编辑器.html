<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84e56f3d38446322f5d73072150c6e589da1477f2610d197b641cebaecf79ead2490753aa4053130229c151243022dbbb5baa1f8006bb17577bf075a58904b5adcd9f59a643cf8195aec132d2835777144c54204adfba9062fd9f60a2a56858e4ceb9173f512da89b835ced0a06159ad26351fbee7d2a2a6973f9086d4baae264a53ff898b4ee74d6325b0f615fb658ac1e9ffd2123890d46377bb13859a851edae91f15cf04a5249921a12925b5bdd08044138658e1046999d04af85612dac0b2a7e8b275722a8a4957db966244a166858f3d33b4908dcb28a18516bd5c58945d374374bab2a8deb71518c0f10b9c0ce160043927091ed5e37c208d71f5b77a59fb64791300ae66abad3a9865f116dad6db911c79b56c6fde65e6a69e8d3cf6a206b0a1e6aed76c6b8a96e7a742602727991dbcd0946204a15283ea34d05f3428a4a1d19a3ccacf2f3dc6a33fe4da12800280195913608753afa60a047985648e2807cf7dba82cc41d80795654bbbd344d8e7448f2a514d877e06fa7bef7b39475f45413e3bee16ff95edec84989d0f5ed010161475f8d4907194a44d87592307fa98e85f96e3d9672ed85de63434377c5d999eb3a1b760da899256df1258f64926b74e549d3fcc783938f0a2e2d71bc2ac44ebf0a28d88cf98ed4ade62531ff415638f99dce17a2f0cb0a2de1aa78b38f0b92b4149553c65e7dc8969e8f8769e253e1859a0b0b9a4d8a64bd286bddb4935b23924f80cb9ef4782b4eb4d9006d2efc07c8ed0fbd1a90be0fd4989b0766721f9de2c9ea1efbe7d02f06813fc9891dccdb3b0fc3fd62da2906f1cb5a8e1f43d5874dbf0c99f7b092cd1162ad7730efdfd67ab29dbc571b915544c20f7d0024a29f11d041a4f887608f1793ec6aacaccc22281b746482e9a15e533f30c413e00d3292f15e65d12dda1f67a8f386feb43b6db3e4d3a43b034221c175a40cbc1c8ebf7477f740495dc5c912d5386cdd4e927e187bd3a93fce6e44c3ed377c29538160501a0a2443dae25fddfcf833528b873919883b873404dd5c89a08791580f598a0a2bb24b10846e094963cbab16b4e3671b09604e092bf1aba60f7172d276cdada8f722117cec8f602806e12f07661901aa68a45f78b1ad081f8473e182a5ba96f49a168f041ad40354715125d2a93ea65e88fc395222e677271dc3a1fdef16666f57b66f9583cf856c36b075f5f5ebd8b21924a7c9a207a2146072618a96ab3e8b7bc3a2d2ed7624b2bd2911cd836f84548685fcabfd369617170293e882ea6aaab0977a70ff88e8c75579e3a7100894732a500540a9c5643929c96f4e1a06083eb2445abd793151cb7f9e21def303e92d47e328d06d541b28960ba2783f03bb35f42bd11030eee96e6d2508a74efb44555bf05f913da56ddd78afa1899af8e8f754d4d835636ffb40203f9301b5c8a75d268dbacc9aba2aebc7cb7e2bb9629ed91e464a0fb147d1b26165328038dcae88f41691b3a57f5b5592ce8a8f4c90d24c7d5d7fdb8377982dbd25840de1d62b54716bd903681337000c680f681c7c9f9936f3a90ad799dba8401dded829fbedf5c7593f90de84b052edbde74a7e11800c68ed7d7b8bde82d7adde07604356e1e407deef2965b7ff9b577ff1b169ec8d91b5ef1c9a2b98229858783e422c5d568078ea739fca8da4f85b41cece6118f39d6c09ead649d19df5ddb86aa419a46848e4f97cd75ec5df48ddec7710b6252f08a87fc7212285e9568759b30a528af807711717b9cdf5acbee4ca63c8510a27a98a9b24d8780766cff1b54cae5a56b7a54100b579c4cb0622239ee5cb7a28ac7b88e99e5fec5d99e2d6e333f7ac027c67a3bb98b98c82ae4ee854db92808f509fa71c8aec4028d4b3d9ffefc59ae9187999c099e814c34d2c546638c1189127c4a01804b38e537a8be0618821e6d57ac2cc45732fc7350a0f0551e604441eff9760bac5f68b1c473de0d48d28c590a775ae0039f42fef72107a30e7399cea8feb0a3ab822798664886acb23b0f3ae73d35330f7d2af7f93989ed9ef052718b64d07673f69cc2e5b4a025b90200302d7dd0b2df723fd4e6a10eed1d8943bb0812cf079ac21ad9e68f3e25f0f481015e16e3334662c26f887fea24c4b2f58f4647bcc99a56527ee8cbc6a080d2307a3a7d53b2db5d12ce819693a95722844b238632f119013236b107e549179758a58b199bb1635cc9dd229088901395ae27ad5bb94879b444e8983a06dc5a38fede5dd70104532669a7ad0b95cf4e22f5349480238b93e9e5f51068f370034c23a59b234221f2c0d89981d83f28b372f899768c40f69ad9e3b604d7e285890dcb5ea2b331709b3322aa46d00d4811e6b69009b19dd5ca0616723e375652b78b0603d5b1bcef3551b8c7ab1cee63e0d3e1523fcc184eaa95963385cda096a0791a7ebf95e7bf5d51951bfd68a05468171289dde19b1fae677a73bf650e31110708c7ebee3648fd3ff33d63416838b22f962fabf3bd234771b24525ac0e18c6d6ea17210bba770c6072bdc0c6b8082ba3646346a470f323d72ec053bcdd4e69699597e870718b5273c5ed5b325a1b6477a734e23e400e4cb4f5dacff9a533b1de9d926e5dca4c73d0c36d552c6509ca5bb194dd8b061e76a411e10f1740f19b77aea9a02a6d0cdc7a31a16e72654cddd11ce9c166e5676a7defe3022d6868f93faeb6e2b408cc899178cf04e3ac438d53a450c88e47eeb497a5f4f5e9757cddd2d275bea98159895c7cd640eb9e2cca3bad5db1956403cf32b7f11a92c86cd1835ac5c2ff9409d73c822342208baa38c6bd89f0c73e29b589e5cb51f94d8fda71343cca73e8eafbeace32a2b4a038a6155a080357426508d0981b7d8d7594dd9ee2c4a23a0de83ba44980aed74b44b9698bc8c2b83580c93e5fca3b85e8b61fd990a2a7cd60463d786699e9fa941a1e29057a409f88616e237fcf8d50155aa5f399afceb188d8cd0ebadcd45245780892ee3f2ecbdfd2a03868f70996eff2ceb2746ed076b3e067db5e7e63de18f76233a3e6b2da7fc20d1cc500eb546e4026333e67a6f262181c165394fc09a8d265a33d1e7bd1435faec5c0d62a4113728c73680d7f1355406185701b607149d876aeac3ea0ba89b632a2315ca54776e083e9ba432098a65890376db3a75394c30872fc54de84982a390185b2f0d3891468b50ebe074a6fc5d9a8337ca827ce2e7441b80000f6b2f44d0def48a509bdaef2ee9c17d7f206d4403daf71465d3d9355e8f48614a90180bfa94609f1d1fd7aae99ec02b1b8c0db75df9c1aba8ca3456d32ac21dd968771a23961cf02bde3fae62ed01e96177262466c24309104709f826bb8bf1b5ec9cff97e2975bbdde64ff8f4cfbb112e1e2967719d04468d6f67b5f7b32749a1eb6233a0cf4c2942b4c306426ba6ae3e39498bc558e9e7a50f10ef2295495cc3f9f8d922897e2110d4dc81955ae61f3827527c3151fa38b538695a9b362435bd44634630daae25c0310640f6cb5552f24cade70cb9ac012df6624e940f41945de5b40f5a057c57b2a6e0debc482366b55be587c0b238a1dff67f1f0dd6301d2a1a64599f4b9545c773e1bc802956411d11a2322c7846cc6c93f262e6fb12cc35d7a94527cf0b62353cd42be1d40e9b6256998ae6b7aa6808c5498b3518b510a95842060b2414b652ef80ea437e82c2d08fc18ee27405b4c54051d0a62a8d082a6176e6c823a424b0df527661f4d12a40c91d39d032d803aa5d1b2f69bab05bf295e4402a8fcd632a9200506775c7a3a29a86d38ee80e9955a88ca5c2fc76122ca55e8810ab1955058f622be42997b3053a81e45baa4d795c5c27997edea526d6d1c1a8199728b27d70b3c457c12a6bddd6592f82197f900ac4cc02892d3176749b0c25566a8e1c31ff3701bf2a10ffed72481c29ef1c27ea73263232827ca2a558d158be8827ae37a7d60ff05bfb366a39f5139caf2cc3df5e8c0a2800efbb6b182d7e8923b06b1f2821af52d3c95a3856a520213298dcf7710b8670193cf6ce7ac9fa971d0039093bc968933c99f69ce28f8ce2e1a5155e24eb8cbec3ef611224c2524e661ee9159b07cbea3548138def5bb9e0650295cc1043859becd6d7ac8c583c4cfc7bbada56f069687cddcad5f8106ae9b264ca76dcfe6cb851d1c18b231885c89c154ba8f624d5d945e544b93f205e28dff1245a65abdc450846afadd1e2d2f9adb9fa43ab0963d9b4ec434f0ec7578edbf47a4b0067765a8cab3d8e30535c3bea5cd0d6bee69a706d4141b32dbdd201d368dd21c3a3622f0f3b1e5e5cb905c569b5283b549acebc62a4ded90bb98cca34f7bc1a491cefa680871840ef529cfbd70820eff376351fa8e36e260cd7bcfe855f81c4f9f545e9328f0408e8b68f024ebfd46ea9d4cd4a179263aa3425c33173bc86251dd031d03565f668db414491b7aac9a11bb8495335f2e28d45587fb43dc5bc4726c0278490873923983220411d94e129b5ac47701c800fb18db18e534ba8941f9fe2b762018151a05b70b55b48bc271e70f73c72b037771cbc8bdd22ea5584f87da77976669f6b71a4993ce611cbeca0ae6f0ece5d4a566d2b86842a21730f331d0ac4c08e73e53d68ae179920b3078eab22e24f521550810325ce841128675f78fe24fef2468980df98fae2b4c02d25ceb08357c8e6c29088e785833788697e22fb253ac3632e8cdd0f80a208653114d66a142d200d975836c1e4fd899c48e66a921cc5dd68374a2a1320911cd8c07d559f99c6e07a487a5804d1eab115373333d640bcc9b7068aaa2ecfd4ce2b1ea6c9ce3ceb3982de54e9b14a08000671501d93456dc4ce5be6b47eb1c6a61d0f3e8943799d0e6e718c9bee369d0b0670b01f39da95e05e0e92c8ee64c6d99a003fe0d75af24fd041ef9e055e5f7f7dc04e4bd1ddfbfddab72fa7fa91366982093cd516239ea3a383a4a1dd08022e8293c0a9ee0370c5d5efff38a1d64b193e948f3336359ce2f538990b17d247c4cd8a0fcec9ca1e48d507824189372bec43400a05603edfe7ecc14d8f35391abce8512896fdadc86c4aedeaf63d95c07b671ec30ff25860616648aff86f7dfdcbffcaa78a3380b3d406092c4f4d36a4545d47e83f558f6c1631bb80a3608d819f3da18016532e87643b68bacaa4f4584d293fe58db87b7e859a9096d260e3bbce6f0eb8fe50cbf0825101d56d3b2e296c1cfa55e3462aa509d5748599a86a070d4f6e18459f3ee00c73988a6ad34419943312d02ccca377918acf2c033efd449b7d44ae153ed7282d99bce0c4e3cea7b89b284c2c25a6dce643e02efd17450e6a80b0d3331bea37a23931d3ff0f2e38f50e75e0e122d0fc2a93034e6f63e9f8c7f89c960cb25cb1aed6f2699d5994c4d270b87a60067f33b0a975b2521b50a9a0f7b0e1a67f42b11137224c41402ae143e528d9b6f868fbcff1c60a1b5a04ca49e01edac57245b354e6bf709ec08f66d18de6fe6877cb2f8289eb90d89c4f9237ee97a47c2eb4f0f5bae218688e78cc3c209c0726e07de78694f5a182c333c9f969a119b52c6f3eeff390f0ea7dd54eb73c5807f9678cdf11a51d14f03673bdaa10b2ec0c3c084bd67d7e655e588bead098e51ec3b2be4d8c806429284887b6ad044bb2061a67f71b72d4eef4d8230f19dc6139af4496164334591254bf383c680ad4901cc3ae3ce6a7265c73efaf2b2c01349b17f7d60a06b6df991cd715e69b135f29bed3f90ff5b7b1b583313df1a96c8a3ac70f8a159be0eab1ea53aea4468ae4d492c60e29a61f37c7425a400c4f38c9959ff5f47d5149519332bac22735b83bf90d1f31a0bec3228fc2075512bdc4dbe8fd1c0e85ad7e96fe5dcceb78ee8dbe7a5ef00cf7194e992580f3ccd5814a7842fdccc672279b0102e5287ed487419efbb1b95fdec34baf778368fca96d7accc6c0807c67afeee37f92d05677035cec2b21ff86591cb1e51d094553c4bd100dfaebbea5be9dbc104af52125bde4b3f211fe9520c6dd4b60949953f768ee8c6e7ab4ab213262f10bf5926822eed8704f8db0892a8696e0c49c1925ed99844bd2764e5570db3c1c8b97fd3e6e9868343f57feed1f6cf700944511d5bf63263dba7386cde72ef7ebd47216e2e961b1c50933e229a3767da0676eb39f5a8206f238050aca1d31bf26a08af3d620a4596209c5abbe174af9a6fdceef00df91c1cd490b21a5efe119e77a0fe168136058fd3acb068133c21a35f94fb4e4f691e5ef5e96ab187c100c77b0082b14c35906d59a99960e372654dff16d85836c965493adf618a1b8cb953c6772165d6965404aab0f785a3add86c30249a561c01c6e7641e756b2dc29b0d9c6edf782157785e4e2109d40e414a7097374af88dbdd5ebd374c75d3ee71d0c51f4f2c2cc9349a0d8b7e6a52468c196bbb6f28689ef8321850fc1acdbf1061b37e9fdcbe018a7eef47dd1d134c83f5e0d53b9fa34fd3894cd15e81491e5ed79e95519cd6eb14426906a11fccf70276782fea81b83d8c6cda2a4cffb4fab41113da7d28c3d1d8cab97d7e352a542a14557521fc6c3100e8fe5f32f9e9e4ecad385f4fa6bba7028b71b888ebe60387b98fb546d02f852061c2843b4f1deec7528de1fccfd38775619d33fcc9c10983867ff9a7095e9d34a71ac8497f02fe7326c6e4ffdc37aa8652f06d95dd751ecfdf77ba36b94a43bbd3e93429de81c62df176c1015f426317be3e00261a06c7c1d9ab4fe224d6ae624a17df2d5a63a3eeff15092f7d4fc644cff89ac9bf2414d031d2fe5350cab1e803cba7c56b402cfe7aa7bcca958d907d4b70596c205bd49978cb5ff7f4208fd70a9f6579aec30e23dae585f79eb4b2cadddf4be00a8a61506c2c66f5ab7c03429deadedf5727071b819189c6170c1c957c531c6b2f649761a607f83eb120df2306deff515a3897f4c41e758914096fdc5d6cb7be305cf8c90a4d1865cd815f4960712209858fa4513ec90eac9114e8eba364a9f632993d0ff5809902c759a2cc3f11c389feda975e3300d950285fb7deba696cefd00e082fde2a213d57755156c4f6a82f1e2181605a3ced1a6a119bf10bfd45dc5b187dfc07ef9fe1852703477254299821946e963857375a0e0c6355faf46b0ef3b15e52d2526b7ec69f477b0358f7e2332aa813e6ae9477216349952299f4a86f82216ad7639e2972c84320247ee5b28a31a7cbaa37d0ac1f2d492c22bad8a5e7fb045148b3be83f4ebdb4c049c4ab3a63c791024964dc701c15d3f132119e25c50e427ca768f7f2dde1435bcf948ca39802956e28a007f63d1813088a65eff4878e09130ccdb3cb623814ec9a5406350f74d3cb21b36fd675e0afb8a21c9c4da32a59cced067611172459573998dc86c62a6d1ce52e069b3ce0dff63ef2c2edf5012205955a5df292593e957ebc94b2bc944c1bf31b57c763076aec7a77e2fad5081c0de9eb77e45a4b60c429ae22e91c6f83c8920335b6b187e6ca2672f3ad09b2810a61241fc4df86e6e50d2e43472e3b4b3a3d8811d768bf1f3de6672f9207dca4a3f3961b611f00e65e378834e6504863f679b11b2cbfed4038a84e64717c62fdd6e128ed91b2b2a2b9d16053cb5e19a62ea16361fb2f5c75fd3c25ac4a2af588fb2d0ab9fd44c95f722397a3ef1f92c23ae17ff9c57ce494864af9cda73dd88a94e4d596c932c30aca1013d2b7a3cd3d1ba7ec6dee8819394e374300435863a8090933bba555156ae793df26ce082f9192b9ca713484fc031e4fcb2367333d08e4627ebb287a173aeafcbbb5a8ec8ad726c7844de49d3c81d2d4a89748997548f40808f3c6aa3cefcde0a7cf8d469e531c81b6e6a82f254bd539ec39571c9cea1ca3d766ac37e73e96db3120546fddaf9aa975827ced21671fa3cfefbc20cd8b795a289ea0e4c75d3a09e2cfa1d32a25bec533c3071d8cab41a8af90d5b681bb0e5c80882d0c1d694c5e8dd9c7188055d04d01866b7b0c36433184865962540f0a391d07c621adeee1a6ff8f1aaa3e3e4c634454451fb87f7a86df1de5e192181e197a5bcf55ccbcff5b288517cb95eeb4f2485e9bc9d831cb9ccdc95b5d8dd6727f94e6b73353a996d816bd840bc916264e611cbb97331bfd1ee0b835a1970c57da92a3cac060961c21ad54d537629630a8d1ec7f76b683585c51396b20358b15a72d2c23729d11a7dd06cb9ce791ad33e20f151b058ade1f0a67a931b2426791352b81ae4ef6ef14e7b59bf1481fc06740f1e1a53afddde65262ecc18856b2e31c2b8698b970a9a73847ee6077942bb5b755cba9e39b03e4e2e4b6a1d3974a8eedc523e694ceacfcb0b0c735ded55fe006d65893ec1bda5d566dd1665e3fb6bc9e0c1bc03d120618a0ca06bc8a4beb0d610f77abefcc8bac2aab9b6835db838959a6543464b835dedb3dc7b75e7fe82bcaf2ac7d2fad8a2180e8ce8f8018315313fe4dc1c125cf18b8ec6b4991e75a790580dfbefa54d3c3b359fdd751aa2f8dcc5c620476941251361179ad73d2293f44cdbf1442e660357363bee58d471a401426fa62925f29e48c06fa92f9e81c14dca3204c467b9482cf9bcdf97faef218a6c7424aa7bf6213729c8e2735c0cbad7151691e406b84109246db529fc8f757d07eca62c216df24b2d74f19c05ea44fc047059a30f026692e29f0388611094f63f0d064688dbda7b42655be0d930a9cf7b6482b2507f9339c59aa6d376dcdc0af3f71452073ddfa11ea9306d7d626d763e7e423e445254daadd403f10e417353bcd40964ba8a970125f149b4343c4ca8da134368d289218534dec1fa6152dfc039c06e90cb101aa127dfaa275461064094321ced4980a62ccb92ffabe44ae4c41d00fe8dae6b080304b8950d5e460945cc226630f20e7edc9c40f0b3c35b022bca3582fc212731eb843ee85a99e9fc2d84474a434ce0ce09bef8425dfe8da782f0032f9f5be7a485a7c9452819bb129575a120b21084d4a30091a634d1b2f607d7acd7fa2b31ad0a2d072e0a105b1c02001575efb05f29093a8d7ff7233cdc207dbccf36d6407cf6fd74e869e9c1e9e642e9d8eb666a98d62ca463c7ef3961b43081d8df73c199c882f6365c1528b63ff9773db7e2271f5d70f5c75b48686869fe58401f1689adb83400ad79db276bdb03d0fc4e69f35cc9a56609531b614fa63aa356eecb52d5f1368adb46ffe04a562802e2aa9a33e584418e973013ce7acf947c463278ca03541e5f75b507a2cadf2a05a971cfda14a8590dfb4b8105a8674f62074ea3a5264d51554948e59dbc3808afb92a619a84a4e033b4bc012f7812e96972e71bc8b8db1fef815eabe9162794760d5035e5d27070d2d62d78d6b683011d9ab7abde0756a52a859ee7ed15dac04a38c10b431d4bcf288a06bafa39efd488ed66330eb58460b556d5891fbf7bda61bfd971b19a76de51348155aec86ce2149e4f3d5e9aef8ebff16a2af87f19cfc784c5160432f6348d2eb5e1c75f85ecfa10bcd4f36810b20b76ff749c34e24b332de3410efd64a0473f066944c081a71b05035d49fb0e8276050470c4dae3c2706a6806c2805f96f66fb4e6d6114e5a262ef02bc36adb0037e2a2cafecf1ac6aeadac8d1e333e9ead6b31fd386295a7948bacf890b4d1a8f2bda2b442bb8a5ccbac69e61a69a93d84eccb8178632b7ad1225306ff9d06f8874f7f6dd8dea4ae09faf1d0a4dc0df71ad270d3e0efb9996df65074e00ac01ecebb4af1fedfb906b57bb5a7606e0ede3f00315450942bafcded307a36a8ab19277f42d6ac68149249d46586851378cdb00114ac98ba4f60890af40d044898c9d46ac18dfd90185f4b10e9174aa2864ba5c9cb26942931b1cb999bbf06e327c6a606fb3ee1bebfeb44d7b7cb72bda43c2e3dac0e9fd79dd25e2449a96554ef6e5f362156ae6a5747fefc549631ea0e49dd33352f54ea3f16c5a4065940f2e90fe07f77643bb8d829de0900bb310a4f8342f270c31fbace0bcda225af7a3a3fe59e4725fbafad5c4623d3067aabbd2fe6cc0cf76af111eff5a5f1ec87c92a185fa70d14c89b3544761a02bbe7907035b4153d82b37a3462714dede12505c635bd2208876390700bd4796573f8b96c7f11b0469c4dcb42681874ae1d6c21d57a1f8e0780dd683f45e06f3dd049215348fbb83a052ac19db06ce45897fc8f28dc2bd225b139df78f70fb768da5fa6d3e1c25b0ab99b9aa242f14d9eae7fac7a48f27ceeeedeb5ab2c740c695372f9583c114b4d206d83d0db204e3440c1600496ab7936e8ec98b31761e100fa75e208ef5c7d6c1be58356138db68ba0e855843b1e5c1258c6ed49442a076c7d1857c481035d114cd1db3e2c419a971a8141ae3dc25f81435aef3bdf1acce45608924055e408b857914904bc567c336cadfbd4d550fa7f3656cdccac3fc86a135431377f49cf6a33b791a73c93df5ad73531e1e8737c0332160b4ac6a0cc84434715854265971f2e936164aafacfd7e0ba4ed819a658dce8f72b22e1995e5e47c5d6810df1e28a01f16b8affa67a38981d88b8e024426adf27659ca0c9d8075aaf3ee83ed940c131820822e3144c8405e5cc6ce41e78c478b96246cc512e59dbb445b4fb5bcb57348ea512c5824fc476dbee6bb0adb4100c24bea1847fd94341a34d5f80aacdb89103fba05079850fd393e4cd6f70ed3799afff3db7db006d7d19bfa8db3a8668c9ee1729b6151332013e171a3454008548bcb1f9caf7d33aebce3b9ef86fe8aba09fb7600a3315a8c28c646d8c55fa7b1057315f56e3ebcd9ad733a7fe57f69e8b010306e7e0ceab4639c3ec2ad9b233a81961dd0aa345907f194e45396955ccbd3cadba33198659e2eb4d99b435f34ac7dfdfbf6ea93c880c968be876fd2c3aa69eb7ba9f39c45579c90fceee941d005daee05f1596c3bf4a2f35092bbda9aa3890c2866820d2354728ca3bd38d6d21af793a0486f71fe74338ecf5dc1b9dd60d1695b96397cc042b04c76a3dcf4f1b1812e7a26054b16e57e5d16218d1567caec4da92e1c9b63c37802bfebed661f5a5829fefffcead2fb00094612450ceaa957ae7af4e8657fb2ebd5e88c8387bbe1d886859baae6850f22c340c431ce513e25b47d9688666a3ceb8cef9e611f298fea854308928db15936758ba4e1108766cad1186afbd8733b42eae630e92a57950c6ba3bc65203b6f830fb8b46c4c79bf9a9342e722d06276d20ffe89572cc9f83d2cfc0fda1b61720354bc04640cb9263bf9ea075070145184ea9d77d2472acbe2a2c096008df0dfa6fc4c649861368c64bf6e2060fb5baa82b1d4dae4ee0ef17690c8200e44e6366c4cecad37265dace8dcfced350a540d7d6d291a903e8163e9970f25837ebce0cee40b94244b1488319ba978029c2cdde5c42707625dc8b235f5829223d2fb6c8f15b61263c467c4b847081a9f41e43038569a27575724dd2c2a7805f8d887b6aae1ba572ce749e71d71ad62e09da7bc248363b4556f7048c704e58d172f8d5c252f63413b0ecdcba8b5f7f93f04cbf4358874c40c6c8163d510634e7d52d4fb98b9a550993107bb4579b63799cd26f40df46820d5e8daf60e3b34e8871bde4fac6f35dd99b201ee4b9c7df94e8151b1fb50e38001bac903dec1fe7213bc25bfd9f8fe63aea62107545530997a5b0c35c3146971d0d10144bfe95bb7685c0e7dcfafdfb4ddb826cbf0542948518c5689481a9b45059f812bdb2ca200142d3e34c1c749ac2ad439f8f33bb488583edb8f1d4266c8e29402e2e5aedc7b1d47c4950bab394edaa3e6113987485aff3e4d5d7783449059360789ec41bb747985e0c18a6d97f44895ac897c4ed67d0f55da9faaf6138a67c8b322b6f7ab6388897b8258d65f380980ec326cb03fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
