<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eef8919de734ca9a8faffceeae7ba4d96602e990c06cb95a54b924f8c292aa6caf3144a55e58744d024fd335f7f6d439d710b905ece7612944c788a935cf6a8eb1548442f970b664d4ac71a02c4794f60b9a8f2d485d5d1cd0855364efe298c1704a2cb4233767999d4f995142dc6dcd1cb8a30966f20ee43db842899303f3d3cbed3058c8062139a642624b0265de95c87bafb4aff0d38cdd8bce2c3766241b6577a658d7681932130419b00b2732708c3b21873020634eb64bb140ee25153f4e415fc59af6319b359b34d1e9601410590bc5b64ec8bbbe6b9e84aa479e54edd9b84560046e02493c5717e0ba75706397fff4fb020bef81e4f700614418e25c4c232ff94dbaa263114a8be26e9daf65dc66294ef6cadeaa895456f21ba2990398cc4ee390f92582d60869f73753d76dc4deea7c0cc2d6cf594bb118a36a7aa30f3bfa073e1a475db00f60032c20b2b2a53b4859ff5314cb051b63d17222794357a5ef73ae0f0b743ff7e1fcf0728646ab6dc541b3849c0957068a71ce548247ba02a417186f21b1a61be2b156bd170e422ab63a5035a1e3994b4cd035c0103e09b6e039d9c5a1b8898298554aea1f10ed0bb2aa94422acb754ed08c98050a72cc2c0bed6faeb17f4bba5d2c426ad6076d483c5dbdccf16934f7404e0a005efa1974b733917deceaa1e93f3b11c4c6e7eb349e68d7b6fcc540ed8276b2186e64fc929f0ff116449292d32450e5a7110cbba39312b6ce2678c544f73835fb20599b5a26634ff0fbce216ef92bde6fcda9514d1fee25d499cdea2c72b7e4a93ddc97859fce6f3f194b1c4b306c0d0fb93110de1c1200dbfb85892e8ea2e016d4aa3319f89e9330ec22b6a62d1ce96338f55ccb18713302001bc66430bbd1eb14d02216ac5bc3d3d9d569a1b4fb8ff7f0c0dcac2eef141a36aba3474a0ccb69d659b0d95b5a5b02431caa1fe822a6605720a4bf074f31c130d3e21e4aba6719f83fcaeba7cacad4a4c882f39884fbd23347aa25fc0e6a499f2b729a0c96ab5875990fc15a839b2a0531337d1907e369bdc2b3f0883cf2aefbf689a0d4ff6d9a602ceca0578a2db811aac22210e881112ed31ee5cab35bcc821d7d616dd23741ec8b8f1c5a313da6d5b336a729018eb61c3ad00183991c25ae19432537fdd986889710e2a39a7039ee9203b41f657c9fe1eb55a64f3c1e9819a78774350e3a38fd89627d5c9d41d4cb44647a9e73719ccdd79349f9f046e5f310762e0349e143a709748fa856a92a087e61ea0982c08edac6339c6ebc9a97e5b7eedd921d6321f9e5dad7ef84e03fd1789d12df61d8fea49a0a583a92a9b4d9db65815a064c39de971f515c8cdb2ea3ea41ec7befc3ae70043a16dfb070fd60ec9de56fc786180ba1786164576fca3af510bcd4be3503e8315d89003d3f5da9b7ec91b55ddfad4dd7d658b744c4cf2aee7b03ad2d5f6d584cda4cf14a55d13d7f8023bc283b6ca43948f6c95f6a30513932d34027c9791a43f6f3930b09d369dff14069e2981d07dec45421f04e65542c5364889a677c21562adead61d102ef4cb097dee9eda2b5121c992d27d522c92e3c7379dfe716f6e76e277d371610aaaa53d92c73bc80c13b60756507435c1ecfca0a66d15d26f2cf6e5f264cb453de2e31d7e552c5ee011bdda4b6432123f132f7ddb348f5c03181c7b4502753be8d0c8162fe68a09073f988bfdb67bd426de7b11d3cc1efc3c4193326955b6d2f0d71fb0e846f3d68a668910e426c5d574c49d0f290cdf27b134fb6904278aec8c85969fc2d0f6bab09813965726e68dc2bf8f6d789096cdeabf74f63b2c702c3429dca39661a8ebf5695eae3e6f78508a0bb1f89b8f8fc513736f08e673d38101201f514e4cecebcb0bd3b977b60813c3d34d905654fe9c43fa8df3e959de07ff123d3c8f7b488f45d6e3b8a8807b7347004aafcf9a3ef95bd32d71d29a80a4c66aceea47a2cd504f889df2d9088075b77c6b7d3f6e4e91787da41d8d4d6c63abeda4397c0d130daa7358643662482941ee87970c7a93273ade6c76d5b4a0606b988cc9049355426cee462585db8b57afb5a3a18b92b9e79ddfa5447668ad29c9d6413a0fa6bde8e6b078595d186ad775a7c7a96df022c0ad3748aa53e6e99e9afbb8681dfec3f3f2d0d8076c9b4dd389857be443373ba72f0fc8af73add92e0814b4aeb2035ac8f37af86f8d44d2f44e1e36ec986d1ec469b8e863b8c1c59e2322ce2cda7b29855c69a6dedcd8e3dee813c4a97471549da038e44c68daadbc6d57ade4a18a764a83e51c59cc230971c370e9b8c262fa73c411bdedadb1c2b3176822e261f9f535fa39e864b2c54c35b63593e629b4eefd4002b52f0f416effe9f95452dfc9d6ea8f2fccb272b8b4e3a9c0e658b6bad15b537c9f491dd7f864f0d0cda5b41c3e8746f4ab03cb7782d1e7defa5c982eb5a4692cb9e727dee3ccc3b35a50321d9c64beba5bcb7b336b203027748ad226247ec92564500e08c90bbb3b6a1d0a61ac55a0db869df653953fcc9bf76e5f5309467caa50aaf822a14f1a3e4e71dc37397c35d85b289ceb0c48a94bdf84d52100a22fde21e589124c80ffcaa83890d95d4d80aac7484990ac37bac369e48af52bcf43b2b4b7f8a06a5043aa31be4128ccf4cfb2ba527967e764014f24885c1cbe3099b74786621f87b18a2d8a768b1d616b002341b6387267e2ff11a8161b5ff7155ac3ddc10994a9846f055cb3cf97ab62631fc02e6e6e8f8198e6b3dc7df561ee1a1c8921e00fd289146eb5f4a9a41cda93ad4c666ead5ed815854aaafc872714890257b136e6370e63e596fd4c21b77f5445370612040b0945d5701c8e2bb24a906a855da4be320df38bdb06db746fe12e73dc0a3453915b79d8a1483671780bde49535491fba202e29f20e3dc1c3de44553fa6aa04d37789ff1f53121b512c06c1625167e4cb2c4211abb60281c95a6671942f10a1a237cc6549f3b83cb6081e02cee3f4873a9ccc66eb1f5274b31def28d7f38b9efaede6be9d777d4ce130aa128a615d2acc60b6919aac69db20497ce0b0f59880a480b766e3adf9825256e4d1a13b232d5aebe89bc33395ad998de2174f48397071f717677faa867b36efe89e29300d5b8e10017855d3d022581251b32d3dad9dedf7fdb23160e61998597582c1863c3872115bb5093ae5257d4be90e76c1a7f4df947c677ff2e9184639f3636cc3c8fb4c958b91ba237b80f441006fe18ee321ed2496222077470fb1505e91aede2d50f49679d8001052c18adbc63b998de04cce14fe1bc23264e52200bf7ad59bb807a45c5cc4e983f07f9249f53fcb469361351735fd07dbde75ab52bfc9b4b2cf3d7bd2fe9f761af3565f83139dbaa5885f8b628e1b96848ff9c7d5ca6ad9fb8374cdcce4493ac4aa46ef400eedc6639a09b755e7fe875e1187916836bcf186ca073f8a03f64fc2f68126ea63903d748121cef534d9c016070d3ecd5daf2d2c30334e0a0226708cc1faa5c5fdefbd07c64a34ac2abd0ed6b7883b410b48db525213bd9602c078acf8f99e46074fe941b91a964cc9194c74c3519435f046d8d4c82b17d5513ea67b924999a5ced9d8547b80ffb40b37805830e38ba164ecd360b883355e4f6bf5f27995be71fe5cc9aa17bdb5029094944ee458b8a106659117edf900c880486455e7bb0599b407b173d9f2ce17eaa1dd7a581500eb6af17d8d3d5d0031e44935be44550be3390627e2cdedb47f508be00cf51a67e9b1be816eb974019c2a69fa4e09fc8e883b42f198704ede3d93a93307e914e5b947a447a3e7763ea364f7245c6f2455365fcf4daccb579c6aea891bc2925598329f2d8b06ae2ca44bff4826e90bf20d646ff99ba93eb20fbf0ee17d1bd0f65be988354c097481757e27e7a65ea868cc2aecfd309be295e11d7f223ae59d33e609970acf0cafd03d6b87c0fb30a711acb4e1a4ea9f8ec8918c9e6ddc3cabd2fabc57c6a7d5a2c62e3a843d2cb2290c62747c51a539ce36745bf96b35825f1d5cc9b7707697ba4396697fa4bebce5e44ee35e98188d38ac80e8cd042d5f04dfa50256973aad34f310df2369f79f3252a35016dc5c52f0c6e779234aebf2274ee7a5f31a1d6935016001d070055d351233c92ea7131208fbb8f2a23ef9e79e4ee4f19c3e6e49cca89bb66315705e911476f6c5ceb201a9fa22a1c16865b3896ab21dc831b43398f2f96558efd3ad4dd162712ec96fb8bfad7b6f8c8a645904c2f98dd4121939b5c6d5f4fe1317e6b4648cf17f44ac6257c0fe5756c780a791e23e5c9b8b3e1f7e6ca4f7d05c54a22f9f7b4d06f8125385df59c6d854249448ab40166e200feabe3f0e150f2a940f03bd16b1ff979321d769ed8d8733972bbdf43fa2fe9d7b4966a5eb0c45c57bcc4004f000d3b8eb4fb1ba5ee5fdbb554b53c29a64c3bfd3de7dc7af940aab7a9ae7b4fc1587b76b19bcbd44469a1bcc7f3e0efb3d67bd21cddee49d7a9019bb4c0d8b952de789eedc3dce2cf1235f901b4d527d16ddcaae82d30a1e3e4814b90561f6a2f607e33c7cfcaf5c12c639c4f1ca278cbc7c2b13ac9a7af5f1d4327ef9b903bd4b1ccbc96355406730eda4ad95417ef8a706934178cae4e7d886a9c4742b019b9eef89bd107925e9dc6ba05ef9c30ffb33a938256b6130db852437c713166522e151c62a8fa7636d8a009dbcc83cbdcc230d996da4871caf46b3146eb8d2019715307fb9e22024333f4a6af7c406cc5d38f6e506675cc754a0cd7681ee2269a20e5afdf103812b568e82025d2d9159e2fbf730c0cc5b8563199b29a02a419a66cd3e5f336bd2a787cf77d4e76de34283d2eb713b89867487ebd2a318c25a57382325a40efbc4040b517bb91b9635e5bdb8716f2f51ac5f02aea6ad74937c8fd2ccfa25564e4fb5442a89a52295263cd4ab8c4ad45dced80455aa31a19ab64f5797d9678a84cd51bbba2f4e090d51852445d5255394982a23a686695982ecdf925f97ac755d7b5268d3576387eb311efd2bd62b738d0f5eb09f57cf964f687447f485fb12bd6391ee4d045505804404c67fbc3537e5c273a5038ef691126b250173ba1a4b94997a78c807b3c62cdfa78bdaab39dfb8980d83e503cbb1ee40a36ef0ca8aaa5f64608f9b963fef050f31a1d390c23ad9bbf8817e13e3cf72fb481ce3412adb3f8d1fd769ff8ab52ab1f0f12859ac0a8ed2ec091dee744e9e2601d2db2a0627327e24dccbca9e573cd43c701f12713cc8dc0ef228968faf000664997c614b9706bf4370a18af828e1002a8ab005efcae77be0bbd5bd5941edd032b3ad3a098824cbd1e9408a2cc43b900a1d7e5af0cbcf9ab4f65674a7b75a226952e0bd7a6756a48f8aeaf553bda1071c61c203e5abe228c1f249acd29684e503e39285e0846b952a25d5a31e1fd41cfd944c69c3e79dd645f811a59fac628bc84103862306f4f7358ebe665c468a20807436f32487e2d43ea4433e3653b0e1931442b1d398e7f958068bd11037045b3287e540f67f84738396b931edefafdd0cf3dc5c52303dcc95b1f7e6eff2edfa23522962f896a157a701c7b1d2251ef6b88870df3d983159b16e53dedc3c065b75899c46cbfba79b0c912a509c4d1c1e1be0ad7276be2e5034289186adc67af0d7056107eb94f74502ec7bb3f7faf43cf36f1f8035c78dcdf52977b5fb3fa2e51e1a9fc690dc484a474a9248c0ee86c624c059f1e95b488191280d537b34a961861ffaeffb31616de678447680130533eb344a4d7c566fd21804bcb95da9377498b7e67073efeeb4b2fb24be6eee828eb9ecc20345a970464688bfc92da5bdf7ba85ff7a977c0a814b8a9edc35ba75fe8206ba6cae58fb95e8333e8960af156350619af54b73bb029bdd360ea664028f50c045c08eb237afb3d495966a9166a579b396da8735598e2ee1f526fa95a0f01400f4e2db8818a8fe737ac9e61799a17853925ed571ddd954db8d56c278ef4f4bf1eef7bf260480ed46c8f316705e9253556cd26d13fda8770fb19d38087032f9aad541d882b036a28cfbb79ff395e5970f8a4d2b12a2a74eed5ffc26c63ad6b65c9b426866abaa979e5c708a3898d42f963a91939e69e692b527e64cc588b140cd2b282ef95fe2f02a2f3cc636011fe959e8492fe8549e8c0ab09784c805c08e03daee3d8c88bc51c8931d1c48eff25ddc61464c10095e97742e2eff9fc4d3f5311622ae6729e46905689ce0b28bc8d4e39c9283c0667366caed75fc32ce3d457b59c2d03b09a2015ef1af8877c84008029aa7781935025fddf31a9a2d0adb680857247d580a41945777148fba4d6e044dc6245b0daf171a2687a30d111f7d81c513f785c67f7c82deb75a1226cde5c5dc9e819945d7bfb2e5bd35b2e4e74d5e2a8056b0ed6c4aae9aeb90cbbee9d6154d8607bba3d2d51ee39f5d15d7e38449b47205768bb2af4a36a017acfd1f1b9a9a2e6a785d96f537a73b6c672db779f79ff889f0c5079f6149699c6aca353e8a79639811ea4be1ae6079a90f46b3df9cdcd9a404b23cac04646bef628296821c29bff6671f32280ab1496feb100123eeeea2deccc54564497428008a0d49555eb95e7c5b888adf3212b5f09f66b168075fdee25b41d54976a5170a0bab408fc85a2e57e1e5c17792d1cd348ca98f7c6c1ebe95c18f4f2339da4074bd82b0f187ddd50937c718f0a41d9b94066b667b92cdb30f2374b0cce63a16ecbbd13381198e6b0254715109109f4fb869227f13b480ee1311bacf70dd516b9a19bc5352624df3c6a457c325c386d820a24753116a08512eff481358d5e87ba7f4c1cfb821c07c6f081299345c1ade1738d228ac1d324ac924c02aeeb6c210f0244b585e0187d2930d91bfbab6920fad39c274d68693f3cc0ac4ece564fce2175bef2c52cc2d0e7e67c3fbfcf34e1ee004c15e449dae70743b9d1d454d81a84d727765b055876b8cd594b4befb5c63c533dcc96164912112c1ed69719ecc3e0f0ee226f38799b37e3867a8bf2feb4b28d9e513fd43dedbc513903d17637b684ae4f0ac0f57f072e5b2ee16e37deda4af3c8b08e2ad22aeb021c0bfc411482d60a945564e1cf0f74e7bcf88d2ff59ec95fbe56f5b6f74f44f870d7ffc5c08e00fc76c67d6c53a85577c0e698ab67f31148b3bd76eb9569e355f818b4027ffe2a58ba3c1d3031a672ccb39f6e28aed41ca880366235ca827a5fa58fbe01ff3a8f7e01ae45afd6e04ea7e27fc72567fdcc0db2813073e46dcbde8475254929aaa70081b3e9dfbb5b27cfb51ac763829c9bc1552feaeb4ea6c65a9f92b58b515a2d77ae6433b4144b34ce905fbf8db2d3793884563e7aecf7522dda9979cab53c3ac0094f0e5cec333c3ed845da75160f094dbc3819f3cd8c9090ecc777b062efa18a6bab5b2f5a3219e93592a803539bd4fb75ef24ba9d0818ec67acfcf9a6c0a714fa73b638c121450fd479abc3a4c8c40bc50e88ede789034492380914490bff1709041f21b9a99c5d8c63fc33caa45059e65f4162c5dfc4dcc37cf32be48513abe527b04301592745733524d3659398ca9cfba3fabbd4caf6ac522bbe4d0077d26caf8df9070a0593dd1cb30671bae5ae17ae9055246e304bca7da5322eeb4952990050e3a0b31fd3790008bbec594035b623c06ff42024ce035541863bad0cb14eb3022defde5157f3cd843e7e753eeb7c90f239df1633421787fea19d8e0afd2e0a58d4ef25b788b4201cff16b921467de8d4dce7c6c5c6206de2d63c8bfdc1949edd08c711b3cea09d31d7e8be85d500bd7c25649d02d610750ad7f2722ddfbea825b4b8259174becc00297beec822fb345330930c2871a7abe0cda321a70eb6ea7551ecfb33f75f0ba7bd9d0ab36c0976519820f9c563d1f94ffb105d10ea397d0b33dc8f5cf3bd0f0e4e11daab19d64b31c24b74a87881affc75b17e5aad06f51bc8844bc3b7aa2325a3b0e5a3cc1622e36cabaaaeac3f536afe4126b3b70ab257a432060809a3a6e1173525a06929c21e90fdfd6139e97395264542b320e033aea32c94e2ec2e37ef5fce6e9896ada1ab92c3b35bff4307d47068567a00d32ccf305d32d8122dc47e997515908463e84b600618cd216e0a81dcb71228068e81c62883bebef40d735ff077beddd8e91572d71377b482681675b2e87365b21b382c639211dcfd1df8f4c57fed7bed42db73f75d0c11e723a29f43382fbbc8469efec471f9c5e19ab14325664d8c92c362a8c6796104d6911471d317b4a5a3aae748c8a2f06102351dbc58ac0b678d13fb7b6f142c0f3d4459c92f281ed17fddfe9626b724d3b17d06ee3d89fce3e18071f7413b36fae0a7959c2ba99e15619fc79ae8628d3e2588866b876c5e2367f2beb34550fddad68f6d244c2b179854b4499605d0ffeae83e9cd9351764cdc0ea53fa3e8ab7ff5acfe1e4439190319226103395020b174b38306f4c52d36c73bae6d4e91e0468230f0c4aabb8dd55187793ce57e670d4cbdadae2afa8536a46c0a000385720ff955a612716a76d43b1a0cc45bb01702286eebd7898aead911aaf1b5628570c0295fb0c679bc201b890315dcdccfb98b85502b2c27277b70d37927c8b7c9d8990f8189ee9ec616c3a90a5f3a95b5a1698523a8da352977eb06a67cc0d7194bc4dab6ba61f16cd51e6e94514ee5a016b6e5ad0b20092a04f4e21130a03a0429ba5a1c03b34c0689e71c91044ca476d3b91173fef69cfce5a41266ebc19bd269bd71eee61fcac9437cce37436dfba4cdce225b65245e774fd8d56202a2994da0c201ab02953d5ae5392f7ac768b800ee902e00e588323aa10e5eeb85b00cdb6b25c04379c4f236afa2b263b998c979fa64929c95509cdc96ff9d6e5531710d4ea0e838044cf260c3aabe4815ce037293087b00339e6aaf04912cc3cfa575b64cbb00634a4b8e4c4544e62cc7e49ddde452ec1bb8bbce7852a33c810f750a26fb89e3a1a6b64aeb497ed8ba95df3a8537184495ad82229a9889486217360206dd117c1805606bc648693bb6972362f58a368c388a51cbe8473118b84661f8bffb274f49644738bf079532af81f8b785ba934bccd46529e64a99229fa57cbd86fe1ca531c25e5c7bdfec147f50f1d4a912a1b4c46d557baea03294cc06e1d32c917dd9e943181965536a2ba6a308613e329e2b9411232bc7269f37d97ee09c24425a1d2a79f51d20f05f4a170d1c09539caaae142ff89fbd8235c668ce034d060dc50f8dfba79859e89ef91eb1b97f3197900556b72367668e1459d9614a7a54bf60834fc9fc79e0ad880d55a45c0b7b9af065fbee68b335c28e2e8f573e9221d4412d6c2a647c1997fe7679aa0d40042d29d215dc4e526bc79a85ce8c0b3b279cbd1260fb7b7f6aab6fdfa6b29b316e3f2dee86375a8bab074b19532c1e0e87e1e9ab61c0939e75c99c0fb296b9a9a7eaf33b3275f800f53aca0108a669114dcc664335d2b9826846424dd22518583950e945c5bcbf8cf463055250ce96597d9d8d02e2ec789d0a0e953c680714d9b0e3d22f0e9e59e23e3aedda4b21e7ab48320a3ecca67958cd66e45288d33ab77135424e63a1ac8dc89486373e898d6107905041950bfaea01dbf27f72b0bc1ffb6f0cc600a11d32178c55fd48826a646e344d76a9c0eb3ae69abadacd29d17d5ca7e4651a6125d2fced67464df93050075c4627d0820914277d7ba2ca279742725bcd99195a71f81be7aedf2c4bfe3f3b3dc5e5558d4e09d48c0dd29f28e0707034a105480b0050a0d38eb40e8e1a57e33ff4bbada6d85d8b37dc0abeef484423c9041b98a182822de45aff648293c9c75fc700a93c8efe17fbbd35d99d45e8c447a78ee8d03f769c68b678cb1118836f9027d4d983862d0851169bb775486382a10e58c0d02d9cf4f8b888284e1dfa7d705aff10b268e790c63193354b162e8afee88cef4f69b948e675e9af99b5635d22104946a63157fd99835685f97c7299765ec39ee6b2622f3afe857f4140666630d70217b1d68168cc56b83aff3339bf75339b17116b46b8daa513eae1a242b78f5f35989fce0506efe0d6b503b5e9fb1cbfea5f03d6f1ddde804d8c316b53b0151061442d01020fed2c8c14fcaf44f782864cb5eaa177dc2f0f2edc2bfd208b238c988567dcb2c70505aecd1ee1e13ac1731c4cd9aedb4ae8c8aec026106169bb0b1787bc5a3d7c7d9f7ecccbbd8f16c4b310004c5d504b14e8d8124198ee98067ab426598eead8fccad791b457344a10d30e0ed831ca1c4f6d4698a8a0840afc9cbd381e468118f4c67e25a99cd72ecbdaa5e83326c8820aae7fc5a8c9f6269c8f8edf2f2178fd66fd36421e38f4959c32bbdaf03f95a861b80d726fc16954ba50dfa15da1d9cb872ee2b0788c97c6f3d11c2a0c7306de8172091e413b797ba36e5544e77a565e804f692b948d14bb17912ea83e898ec8264c2a27f53917674547ce93c904ce7448020990790ef47e927d95a34fac08d3de44911c3a33c746c1355cc5299ddda098ed54d6e5be3e377123b25f478464a4c0be423acc98b7b1ca2e08cb03989e7097aceefbb4f90311a3d50c51c5d62fcab694c60b5c355dd84ea4358833891a0ab8053ddee889e339660d4753a367b1f384a4321b5b4b47bafb957ed48ca6bc210951bb245d0c35223132140acfa074755510aa24c76bd30ded063b7b8879907287bae66b397c35619b0f72eebd9162673a66692c87f158831bcab94ec3d4aaa1c87564d4ed7ea1c3bef3c537d66d5a295c57468a385e4849f8ad1aac5c6f19c41e81a9a1415012e2bf0101ace54ca6ff7730e5391ee74354006be5c6e9c5548b7d582b716db5645c88f7b2b67a5651bfc10449b46d10ee0a04356b7dab60b525cfaaea463ecc58bf9d34fead03476511b8816653838df4ac182cb746ee3ede2a82fea6e229383303f7e956e181e5f2019e5d3913b5997f4d13f325b73cb3e9afc458f2b53917635f0ca188790d6ade0bf996f7fe17ffb8d850e6d48d9575cff1deb0ef673967e4323c07b1f1abe0ca593ba22137406373cc2b703c88dfdde5db2e8c18aa420468caa25f746503e5f720b438316a51b17c02965eee03702e4bdf282d586b18220a5b045ea0deec18a40b57ed37073a81ddd716d57949f8dd86106ee8a4264cf39d4fddce8ef7cfdd18d2f9bbdc002e70055b8a06d74f39dfc1782d88b8bfe31c6dc5dd73deb7a0388b84b38ec71fd09b11612887abb37b2e67578b14b3b43dbeb8db952d9e2ce639893887f8f4fd8a7445817731db91e0025ce2140f84213cbe8edf19aa0588df5020e606a243c1686fdc27fa466982566319169955631f7736a8a0bfe1433ff715dad17ab729a85586b077dedcfbab0f1ed10f9a28de0858135822a90871f02bbf9256cd15de4467944412bd197a748d7438c4600a2431413044a8839da961f335c4f652420782251d1278d2d49db551e9eabdedbdbe9b9830d0a7ecc3039f6d6954d59608de07dd7e7ffbda7b7ca7fcb8a979fb9fedc537e76711c9de806ab72a5a9901481440535dd0c55913deb67567bddb2baf1b4e5257cd3b2edd37b3cdf1fdff56134da6cd331794992a7a9ed31683d8c4a2c0d5da471a5456c594e1a130ef6b4e35d4161467a83c5b605bfd910c3b0bc2d10e1329f760509142df7d14d0863930da6c9cb18e23d765c1792a813b10277f37a89068d36bf82d6923b80d86948cf661fede9557261a31b8f0cddfc01a8160dedb01bd0309660d98b3eaefc5009bfcf74f7a6b69284fabd7c00025f5293f427dc3da365da7a4fec573c58d08663023339aef3eb42a66f9ac88bd445681c332e980835eae3d6a1e60ba6eaa4c26b3e728b3cd19c169145b0572f473322acc40626a0ca4d310e941eeec61cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
