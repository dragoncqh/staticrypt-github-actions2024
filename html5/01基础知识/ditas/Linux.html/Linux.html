<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f72635ae8c8dc58bd49d05894d319fc3c815d95669362df1346e66ddb3666274c6a42022c704dd72aab098de7b678611a3d987e91591444c080fbd8574d60b83f84b3158c4fe9f3dd718eed399bee0e367b6180f56da6926c17625b2ae642334e620236de1dcefbaff0f2e966833c6de71ecb26273a907b45cdb6251eb47f39812b42fe80e6d2d4e65f55d3fecb5c26c0f338394c21bab6c947165277b34e691479ea4df1d793392b0288476fc5b63c1b0e725820af1c26f9dbe2117b4def74988f6d958efd1b5d158c8aeb4d9d2edfd0d772956466abd84b8eb816a802fda4325059c82e825ef794c39530ebc42f4a7e08705b5957c53b098ae4572ca11d84e5f046066458b005fcf9032466d41f25a5e189b65eb1344136866626fa4aab71a0083ddc984830204aef7049c1ae7fa5d4feeb4c1c7b2d388a1e4979ac8d898f3d7f9b44472555131430bc200248c41b6551326aaedfa9a2dff064ad4e2b8a7fb233b7f628c8799a5a3b78656f169caaed16b4cfe9671ca4ec2bf4589b8532ac1d4d7d966561b55af10d0c385360e49161c574decdf34ef004db7683c17963847f03ebc2c23c83d798a27d0261273d7e4d023a663e14a277f14895d7fa40a96a7b5ffb18e45f3b8e9c0dba91db603b92ef4fee1b1d9e7fb9a466115a81e2ac1de6bc6aea76c65e28c9cefb347bac20575a490bda4edcaf905686ed1d32da96f9465d260289daaaa0338894026729928ecd3c0e39aba3442211028293f3b11df19ec785fa9c30dbcb5c0887f94a0c6ebb08e968b930262f45b547953fe1d693e5a0918fc480e2e39c6dbb95c61691d4f69d3b389205266eb2d1c771e72f4fafd7607ba9a6dfbc7ea8b3eb7daf3031f16decf194dd360ca6d012caf6083ab593f0d4bfe5d0ce685b3bcc1f15e3ad76a61c1c8926134643e542cceb1cebcffe4ef27a0daebd2430980e851dc43d20198905cab16099bc41090d6e50e4d292aec86b358c2ebcedfbfe2edb4f7dbe33f1b1794eca08d4c0e7469e63bd5421a5fe1f152b3fe364e49657ce2538d7ebb57af248e3c8f09fbb6029b931114de72695f4e97804bee024a80930ca2ce1f69261f20cf77a3eccd1b128950fa41d17592565e5620cbed8f594ba7562336078a06ef182be516a179efe3ee59afe66576f242ca40fdf654ef181d7340a743d1b9ad6f2c7c6e2e37d07a9ba45beff58d024f52341d1ac1808a252c15c023f66e4133150c1f3649124644becb34f180dc85288e125284ba572eb61ae803dfe7cd64e2fa7efdfe5761aae093510fbfb37c763f3e7082ff9067b460f42ff74e61e8be20b36a48c3245afac8a0c91677779b5c63da66d9e1e949a5ccef7e1a68258e19495fe59471d3f80aad8bbf4b216f04f72f4431ff020576d0960d5d64b684f40dd2d91a6cdcbce0e1c4b810d4bccf1d8b2f36c329c6e057077afe36e96a74532b0df5e7295afbabbea184660910946cd5f7a9f6a48cbc443e0e56c49bd10cc8a7e9c83dc146c5f1401d488e14607d2d8e30eca3dd20ae61fbdd14f3b0efd2246dd20f6ad6b0bda7a9ca9b59dc0606689425298563d27af6f7c8b3fdf57205c6ff782a9e4129cfed7f3f78f24aaa81ee024e6b02532c1619c634f4c087f4c1cd390fee239f6d52d0bc5174b2ee7d88b2b6d957de105d8c013604dba9400089f48ba2d1ddab031036891f21d23207146dd32bd81488b7c9eaccd9a82a24e2a86b101dcc268fb8aa88f39a455f6c779488bf7e26b7cda140b76690007b30eb16d2ceff662d8e938f44882e83ece06881ac7b8fe222c635effe861e4710365b4744373496e43206b3c592caff3f3b79fffe527d495dd1a81bb8f4113554ece71edb7ac31a61b36f878ce821c2246188693791a34983fc7ee2df7f69f6973e19293270b4624e930392c7ae7cab4c0162162401ac6885a111cb198c859ba7b61a8959f98e92842cff93cfd53c38cf956aff5bede7cb08c0cd68beee7f8d691d0902ad14bd6c8c35a9ad4556dcb0a4c9f380755cd6336a7844a40084fa912345a3d815c44c3298394d5d7a3d15995046374bbdf645b4be94339ddac39eeb1301bd8d3de9267a3faee65d108c0ac71a3b7ab25e384b9c785e0da83a850e23740a50d75b87b048d3cd5a37bb6d40d1d83a11acc6de144d2e49db1177c1f55008620d1ed031359207edf4b9ef5bd9e24a3bd45c545bf24dc422e2ce326cde06245e6f5d88b9a3bf81f40d8af393cec5e0e9e9aa26dc5a4a00dbf3ec7a041f6c0fcbc8b30414207cd35120cca46bdb02cf43dffe963d04f86da147d78f00ee3a623d671984ecd388f3a10e7b80bfc0b1f0ab68683926d8ee5225ee543359054452b97540ba3b65a27a2397fec49c29feee70d7c614224bbde896365aa1953a7d4553b4aafa384ce065c71c841e8c1d0baa37ec881792db9c7ad7b60bb2aa16fb6b05a7474c08be56c4cf53e485f06d27bc117fb66ff988c610b3c320d43aecb6654e78ba797cec07e6d9f3188484eb62967025d4052f8ccf45cdcfb08a78d32ddbcceecef2147630b1caf64f079793809d7a38a9455f1bae7ee1789af36e4045ef7705a011575c1165566008e1bef558a9834bf1f9288516bc07d8656df9d5cbd37f8654caa9ff23cda82997184cb91c2783f6d32888f18e13363d590413af4505dbede7bf292b9f2ab3da0ded91e0a44135d825fe7efadc7363cec4c8821b55de8f6d7f78076a8756c3880c8de4701b4ea85f33cf9ad5d154ebce9e2303b222edf07f5c5b7373888e25cade47cde86c831456664a523f8194975f3ca8c3a40553b41815e82fc5817136cf66148bd55c3bba5f711f5bb9914ad10fcbb9148333488c95bada002b94b9b34efd160220a6fe94c5dde2526b20cfe5353e0e20bebbddac8f6de8788a97161959818b296cb950749c252fc68c264b43744254cad4b8ab57062ea421f3094b41b3f78296f8a1eb036dfdfb5567ce48c89375d7f75f44a988bb93c125973b4aab191178ce22eda207ceee68fe5625bbbab080444ef460082eabc75062fa2bf59c71ade2b5b946b653a67a14de888e2d57afe9c00738ebc35f3ab9c2245f5da148e83160a5b80df8306afe301509b79095a5cd7ecefc599f9a4448fa2d709b65620f8709ab3bab5842a82052420fb893fd98d7bf1ac951c50172b220960f7673d110be5fab2f6861b73a831664a4cd0f4e81cafd9a06000674159b68a5434e6aab9e2ada3cc1b878dbbf701d1a857db5ff5872c74dfe638149e2818f8fe89baf1cabd5382b50d2d6bf09debec23891ea0c6269e3515bf1ca0f514a1c5ea376a998c32cf6fb9f2ac76211d49ce70430d9800816235b4945735acadbd03c7b43aa1790b87910265a64fa10fd26a12c99af0d3cf06d285c146e404e7ee8a40142b499d8e709b1b2e60b2fb1f6aba923c6148fb48c397094a200d2f1377633e70672ff475bd8a338a9ca47c6015c2831993680308e0067bce8ef722246437b1a1d5e014a225ff5ee11ace8eff092187fe533019ec121701918b9702d355ec2473ad65dc14e203ebe69193fc9a80133fb9eef59d943cd3715efc58030d6ad991123253ec8bf1c51b366726418f08f43d5f14db52ec6e0058f7b10c22f8b81726e93a87f2ec95d6224a66ff584d9b2305a76477312dc3d77ec44b72fe461f833b84e7888eb4397b31cd48953acc4e7c86436359828d23bd6d84d7fdde3233cd048dd194c95ed52820ca264791eaaa47aa719caf2b3a180916ab4f3cf503460497a8fdcc6c1edc51bfee9de18f59b6518749b62f044fcbc53cbbc4ba611754248f0cef3ba027d03467c05ff27756bb190a395d68cfae8d2c1614a3a8c0dc7c653c853fd414ce546f2faabff8dbbfaf92c130e107f38b804758dac0f88f05d547386e61ac0a1794763593c2c147d9c2d55469ff343a569c242a9cc3f3a6729a835531480fafc54ee4674f13c48eda0abb25c445c2918f117f515fed823dc741945c6b8d7b6f9b8caec8ac21649a115d4c57d5acf7de57ad5ee46c07e65e7bee5822af267c194595133ce00d9e42e23e47166881ef246c1dba9205a04fe2c9793ae684a6dd1d0a00a6e3cbb2e4313a8f3b6a13344467399a1bea217a4763542841c85985428e40ac86ed7edae58024abba81544f448e2ab3842e16e7eab666e699906dd7adbff189b1a5b2e3acd04442c6f188c722d5c97b408607d708424a4926ce8d3426ca119c27ad56c5bd8c08deece94e381717d10c7dd711d77c7113b238e1b71e6419f8424c2d62ed3ef07f25c1e8a4327327cd6052d908d6dadb787ed82943c394d44e85d7679f962a4041b2023ebd92ffe55c218cf6e00d8f0987d2736eebb7f9e05d3ab71df6c6284e48d6d22c90e9779d4aa13cbc9f466cb36d7f02d119fdf6b46a6ee1abf74d69679f8c1de7488d7b01de2abb43f440902fe3e78a64a7876aa7596e3f13dca6aea2413060cebebe42d22dbafc8262cad3a162c206e1e3c1bd1b6ea781bddb11b7a2dcb75f7838fb62293771c7e7ef82234132b4af059d44bdbb620f5f6f042be5897e5c87987cb85966d4fb4719ca86a2e25a80b357911cd2aade568717f1ef9027e9105afdb2e4ef3e22ae514a1bf9d5ce4d0ace3aac92114c2faa220f339467f107821b2fedf5056efd53d5cd909f776f6f8661673a689b2249499482190be057d293401629a98dd3c71066bdb53281fc24426aeabd44669df798c19794f406583a1e1a2f8520d3f287dea4ed8acde7036e867a3d048870bb0d79ee777f870c4af8b5dbb843b3b3ab95d3a6c339e1ee3a4be6542eb79b48b94c0de8e5a0dfd15e1b8a7d8219bd57080c098f0954d4162bfe14c9625e62e5a549530f32c5be76e7c374c12dc5e782056505ac892a77bc8e0e2d4df37183caecf9a3fc11691a191ab1af84530b2677262a0a1d8df5d08146b8750ee4e940275ec877f78e52d5bbd57915841217ede4d9ab2124b56614920448affc47fe29584e7d4e6d1b451b2a3d07cf2cc85af7631721295acb7092307473e44f6ad36b7117bc6e03c3b482c21858cc6ddbf64cc86a016e8c460e9d107fab9dc3f0334db4eb850613688f4b25eb4aa37b6d70807df5ea6b9f130aa30af581ef9834cf4ff0557edadcc47d9568be9315f34ec0e23ff65f8ac5e0c7e077f22a583d52dd4a0e7f1e935f1de97e7f283419a212828be34315223dfecc8b8b82365a840b2d674733eecb69d3d22cb87ca5bb47cb0092106ea0b72775b4ec0d20b5e14f80935c8c69bfe0f948c25e4c9b40b5a23084b9312b516f7bc51c19f07e6f75a9c4e55b4d290ec6be741139fd8244b76ea46b63feca695d09de9c97e6fdca6fb1589cac7011898c8c90ca7a83e1b1a13af24abdc7d6ef7552c361a2184a533d1bd36654f37e17e76c0b2d30dc6d9798ab82a2af8f3e6bfb5dd0ab4a5f19b5f08a6d4c169ce09cfbfa84fd8aa744e7471486d36533027f87cebd53837d0bddff85525049d18ac75ef178ed4ccf6376737117a23f64683de7449f2f80daab5c6b62bb2f2a6cc03908bfa4a732c2756f5d4e5f3e4832480d7088732469e8628cae794d9d8e510df4d4f81cfd0744622c5c819ce0a7b35d8eb037ad9b6cd6bdea9e7c1e057ef28ae3dd93b65dcabd31da2b030ba0cf655c22d49549320514a92ca84cf170a7eb1b3ba746d2fcc9735aa1f999b79eaf80d984e71b93ac21f976f2b50f19bb0da0279d88a9699d5d57e7946e91f8c78d1a23d410c26af24448acf74196aaee9d5068ec79cae7c65afefe9ed276c00726dc592cc54ab962c617fe366875d315f5fa5bdffeee3f1a13664295fcf21442c7d9c88d3958d6aea2534543d28dbcc96273581972a27ab05a20941f8e8953dfd4854b42bd29858dda13085578bfbddd64091adb5a1dea77858f309cb2e7d0a3fc856803a447c277fcfba1349d2626cdd7491d01442a380296593ecf93773100b6a024b03b4d8c6969b3be242f9e13771d792916e649cc516f73f2b36eb2203ccaa79ad7d48e37602dee122a3f8df8e2b2314437bcf24d4fde56566e8bf433994938c7c1e82fc3f5d65ce89773bbd5987af3115bf40d1533f5e00ad0f7a0f95ffe6cda4809b2c66fbb8ddf683c6e17e4b125a94365c370f0adc66166b654e0e592655084e13f56575ddaee922daea0fb7ba01f29f634a07ac239d1fa899dff97d8a38fe7ea55a0fe47c4aa665bc0dcbba3f9047b44c7050ebb91043cf35950b73e3fea4eca166781f1b690ec9636149839c98445655c74b214b5608f03b2a09ce1c1abb22fb410004b1fd624ba8412070a836c77af17eff778b06378804fac19ff415830f5f19382d030d8d2cc3a133e77bb35f40c57126ee21e2c8bef5d7323254cb1d1d01b7fdab782569163c2b0a59acf2a225393b4da7c44d39f4de95a53986db67a0f3f373b6adf7d4e8fbd6ddc0f3fb6c6eab7f97c9a8d0ad81ff9dc70131c68ec8a3ec3ca9e1e4b0fc1d4d7d03abda4a442d08198dd8f5a9d1f07de1c105c291ad97c9098f91b8396d52935848f4a30322d85ec9cf6983372382ff5086a099289e691e15a30b2bd990d7bc31f3d9d8a13fd35d3f623d1de8aac9a25f5aaa24d2a76230a26bd8fafcbda43290553f6ebd41454d273481d8062d5378e9630fcc84d785474d7c1e5d8e686053ef70ce49e935e298ee12af76a9e5f084bd4e97de8f74b156820a45dd4637a73a8ad945626fc0dbbf8fd8ae51f4e4fd17eeee5a495bd017fbf797ff3b102f7e0a3914d4fa1d2b97945ae292fb4731a000552665b1f122502dcdb53ccc057773e617cfdb51c91f97276662f131f02b3e8780ce751b981c0665833eda56183667f45574f247e2bab3a1ce8b101df6003c79cf775bfef686913dba243bf8c92299e941615c70e16af2945157372040b9c246d5199c45800886717a5aa3a04c2fd70d19482064bd83656db9bab2980c31753954b61d47a5b6326324ead7e92ff0c57a8a315e0e78c55a72dce7cf23a551f00d60a8a3dffa28c46943c40be904c120a2329a62b71ddede69444411e71f002cbc428e6821b78039f58a43a857e236fe46383865b5a519c8ee89ae33eed6cc578501cabfdba1867af67e7f9823c7f0caf0f0d293e08c6a8394d22735c1a4fdcc4300adda8bf16fb6cf06813391bd7ff7d11470afeae0dc7d3e224730bbd5d0b0e79ea18a9e720d2c22f560950ac41b014c5a068bfe647e2be7fccb56b430aeab42ece7f4ffe05bbfd0c838f394f0d58b2619a63924c37d6e882d18b38f50cd5efcea051f726e32bbb7e1ab23499da8a6a55adf8365e2784f8278992f9fc0537211c8511095c8be8ab1e280d217f187de983a03aabbb82a7c1eff4c4d8140765072bdabfd18ab859cf3555189bf44cb5db6fdf6b240a7d719f0fa90f0399081b038971db51cc971a95342172d4d281d9c4f2078149efa52faae9e07dc2af6218911cd0d0de2e804f5eea05a481022bb341663ecd3b165e84d35701880dd1aa9bb25a4ce4054d08cd035cc3988e93b72ca88fbddf288fccabf7b7053a7ddc7e7ccba7a9aeb4dcdd4b34a799ae7982d2541fc652a426342c4fc424be82c682c87cdcfb3bab663951b672e11c3f0db276832c010e876ca8d445132fd5b57383dc3261e7201d8203ac7b0de78d0b0cc1db0ec5953bfbf93aba303682c67c10e205738aa0e937384f5371b0b2d141e22d6b331e8e19cfdbb743d6bba40004b9eb8bcb21a11d6dfba00e91a1ba9ed1a427aa4a3b5fa7477dde04c1265670bc78f956e769afe86cda69a40d5a8527f9da8da8c1554c73e0e312ea91b5fb61102ce3775a6fde6691c87d49222b3ecfea252ab29a8f4bf143d144a32fcb313a0d48bd334f9ee35005a8411b337300c450e37a25ebfdbb4fb00df5b61fe413fff74e848c4b0e838b9264b4aa94b04beaca85e5cb638c3491fc9b27cb1827585321d2f8572c6a645444735a1d991a682b04a42e09ebfc78ab7c717c5fbe5ccdb66b42261f0efd67d2e1fa7270634b3a278de10b151fffadb1dae6b0f82722c68188e3daa2bbfe2c99fc06e9ca719dcbed55479089b8c65db5249d65dd9ba561fcdc9e2f45d9a78856535e4a93db3792be934adfd98ffc4ba1d81372c0896597ce51a45de6358941b2c17c5767d35694c938f1764219b1aaebefcea41c8c3acc66482c26df79e06ef678e8c14a56fc36135338ff8058efb66958be7c03bf3ff77f36e388b43c7101c8670914873c7a086520a0cac155a5cd34699959e3443d3303ab0342a0e14e9507b63c206cf07a06a40b24a99d6bb04c05e4f7e7ac57e117e8724f0a25820be1f16ba868b4e19792a3335ddccdf47d9f1582eedfd36b241017733f616552dc6d7fa00a0f7a8edea9a435eb5d4fb22079951ae8201e98eb94d0d8dd2991d5f631092cebe28f6a23202cbb947f05b4891e22811902423d7a5b9b62ffe2bc3ec2bb6901bfe628456583a38281feaa25c647519ac22a0e4c05c08f72706df49b4423b2c032be17dad16141b585a26f68f769fd867e01adf47cd01965d5a6f6fb194374e3fe4193ea65ea1ab44a2f9a722e2eb895f8a3926cd140e3ec6cefadd3ab062c540ef05d5d2077f5af0e3869420e28f0d518dbd5d7a36dd657b066b2a992d888648c047beb97915cf6b26b94fcff349dc6f6dadd643e0d2316f0e0f79e0e571900bf4aea26b66fac101ebdb41c99c78281be3313040e90f8d7d93a164780388c727b43a56b030219af1c944ad3f4cd0b2a58ca200a5ae3629f010d588c3d18779d765875d259de5e6b47ae6312b719851b3977e1229d9922ec7a621a0272d40c6583bd77681b37d2b97ee49f1da7bcd1261a6f4d41803229c8f6d2690d016198ba8fe0c9a50ce9f576fffc965166c93b934b17e2b44b0055fa2ddebe5bc32587eae48db9f21737efed1b94779bc8bd7a6888245c0bf66729789fa309c2e42b007b53db80c9119efd9f98b958f40eb515b740a1a825713c1a022bd5bcca4dbebf1c3c6c9f65983b8a9eb415dce67ec203138ac3154d475ec1c3e074c339b9d79557db266638686a35a75fcf6403133a1f4a453e345259aaa6b025f9ca8120a3a8cf4562006f0ff58a01c259678bca275974da1b35178a2ed64a20b99e60d11ec102eb7a62b7c11f2f72d935b11abee6162cd85b5f14a7e1cac244f03d3e0b62881a85916b23e2e47a74609c2f1bc3fd0695206827d1393dac101bb2ff70b8a2ec858fdbba1afa8a13dcae3bea7d661a16923bf5c5b59dab58e88865634b63bb3089c154d0a9ea101d53360376b3c228e7de9949434be787bb8b7c8d87d4607c81d8d252a22ea268e2e26e5ca7d2c5e9856bc1c7a1f10b6aa66c5e5c09365b12f2a71370dfd71fc38fab70da1797aaa53b044aed13a9ffbf8ce15b0f951913d55e221aa7c4b3f4f939976887b9066a8eb460e505b3895a9707958d42fb62a93c4d88cc8ad8818db356e5e24fc5bfd900a65e2815f562bb70b8751eb4bce77dd231b752c257b00abc523c3e8ade3a78fa2a472e3c0116e4d6aaef3ab15464dd80c9ccfaabce2a961adf9492a6518a0271239b0a1f9817b8d59130f52007cba4ee7f3f4b1afc296d481196a216c549fe6fa3fc04f632ec37df0d8eebbf70c938964f95368033b3f6755eba11893761b9dce46001167dc40f7432e12fed2be53f77fbc69b90723335f58310d503bca997830ff4c80bd27758424971ddc6ad4d4801823566b29d9d2443de7c7b8924ecf9fb09b86b9f69d67b360c6464d57f68d85bd013bc68d2a179853b94f322c268dd34f0fed078d1504a80682c4416bd35dca26df94d243059833074dfc8af3f12808c4037080ffe0c8d31725dd0712f66e4fbcb2b970b1044034889510ee4419f3fa1d2f42b5d40a0138ac011453efeb4afd60faeae23bc900f47038fc3077a1638cb4bc7515d169dc22b413fed468e4c16a5f8a104ecabe44e83e2353a9b6d85956c98999071767d944fdf1bb42caf07cd0a41818898f7a635ec9ffbc1df982c7366b3823dd44eea2aa9a6cc1da4c6ae16419fc57e98197a96cceabe435b026d70189e50c2115f3b9dd66614c36599f8c7c2ae4c4751228163b03d7f0a5c9680b19a6be131c791b56fb97cf7ee7d4439c078e8990af5e56176d3cbc0588839eb71e6842f55ef5bd87f5d4a6e8a9263663bdc74c603a166d722177ea95d7a5efc2d3736b43dcbaa028303f9a71aab6776416db7432a950067efae17c2466c67a6d675cf0d3a5070e4f95abec297dafe0b515227b4af023ecabf20968ab282670a21d82e972bf24e90fc9276f6f4b26c232e42f198b8f8b3c323da7e172fa301232090e382ad919371cc01317e03bbfab15665a31ef83b8540ea13d9e5e0bfa581cd0ff6b236d0c446125887be4ed02b10d05b5387978433814cd33b6eac501d3b0b9b94b167cf67c76628e70d19842d6b1c92b7ddb21e47d1cb19c7a412b6b3e6c28b109ca61aa04423558aac327a6ad505b5c9d0c95026a68c8c4f7687557d059440c2024743b0bc8cc531711732b647443589471fe1e976e4641d2795816056643a530357e61bd92ebff523e3aa08cd5b2827c0e801b213d599c31320bf1dcd66d1604689dde87b54f02abe77c762e92377dda8a88cf330b48c98d8fe4a2fe659c3255d8c17668b40a06f12208b4ef9859ccc89c34b599b120f94d3e220ac3c4053a91144df2cb85792f610bacaadb5f853eb7bf8e1d17db25c3489a3a3d5131262ab0cc37a0a22baef181f4ec84c930de513381358c86025225aae554d204bd9e2ce2deb10d91ced72c5883e1d012887a6748d3be58bae80d1a603368c07cba37b52337b4028f391e4316dc1c1e39c8d76473faf28396e06a0584a16a44bcd95752ce826e652a8592e70207893471f54fbd4109c0fdda8d87dbfc478ec990537425b33f678a34c4b94c457dfafbb9b1825ee3ade9a39e749b82dadd79e10b64ba2d6ef0dc25303dce0c1f949199e00dc3c3ce3bbe41848b47f1026aaa2baaad8f323f527cf85b3bff09696b6f3cf77479f50431759423dd7403eeaa99d89c51c99ab990af8153e07578301c0bd200658271e997190647a7e9cb6aee9432f98285d4e745fdadbac678fb4460a5af2692f08ef36d0c6cbf059aba9728b275b8adcbd7a5da687012c9a1def234089f685812a9d4ad7b37a52c22c0823bcb0e67ca2fb80912b49372a42c6d2b2c7d395ebdc61e47bfb5e09e3e8f8edb6a8225cdd7bf773dea162ebeb7c54e7ea2e70ad50d09f51c8325773d21d2877d30e971e7a3bd39bf2c7f9c8f2cfe45c52309f1cce688a42a893482d16c160d8aae77e000c9d772f16187b70591bb8f81a4b0b8c0d2ba27ae4fff95c046b08900f0ee3048b446f54a4117bb04ebcd52f0b8b6afe85b314190f27beca97ede2591840d54745513a2cf3f1abca9f98c4d50942f7c5efe20bbd84f050ded7419ee8f2f0d2719493ee3ece9b0cb84d92a961b267c2eb90e39e1a62dc1f5807fffde3ed4d7d4777b536a3286912630564c958f1712a1baf8380f7e4fc22c105cbc564dd7d5b522dc727267b97dc97f2832c0f69c2bca60b1849f7dc40a5916f47383fe5dfb35a5b6867ac63da0a1d76838aaeac3de76913c06099a43542e9d6edaa29d6d3bd66556f1d2612ff99dcc1fd189620cbf56ff390ea80ec9ed848c237e2ad020b2c9b45d1385a21ae5e7a5a73dc4f79e9c5d9cc1d4ccec46b5590d1ce5e229b181525e5e3db876fd5680f8494ea9f8af11719de135f407f6a720c5c98e5fa6ae8ee0d53606362dc854f5db839df64a9e3a1b98a6c9aa9aba816e8cdec02ada2b03af3538561f0f704bf0c579ecf8ba6be0a7216f9a06582046c686c464940d150d04aa52d4292096773028c8c07e62e1915bed7afdf3412e292eb591f6b1c5fa61b836c0a0b110a27b4468462415f3883a87aedb94d038795a3ac3042909f5cfa66268e40950b8b243ea9f4b9c65ca06a0426aef84f210b907dc654af90588e7d49f7ea80f25630fe388bf04de362f90e9922fb9a75cf7e044e6d1f4ea45602f32b71735c948821ec88e8ec74a88f25b173bd066703c3e632c978b24aa779ea72f8c6442d2652843d7ec8d0f9e31eb8b658db53d89d012c1dda5b6df3f0bbd3eae2c56388d7289ea0198e7ace1a1394ff3de1e02d4649b2600347a6fe1a36c7cd983f147ed11cd5bf331c21811d7721b82372f06d0558119762a4e2eddc1b726d21e55ef9a4a0e753d612bd216fb19974e5baaa77663911e81e86fc4015fe16f2b5c40152fda8f60b0f875baf9ba87fb3b5da6db753a7b471b2622b1665a0943563466058b28f53b9c1fce857a980740ef9b762332d42674cd36eb42f576ad8eaf354cab491c7e233102736351b6240556e372c1182d20e04272af6269548976bffedd5f79987f558c290a66a34cc8dac9a2fdd112417796d6a7446959ee04fec3f7daac1e694b6d3c9e54def4080520c4b875a626fd13b7363b15b696ce4d4e9c3066717a9e0de72813bac73f399bed10724f970dc3e16c46fedc4cf8cc2987e4f7db813c21e65436cbbcb850d821b6a630c42bbe69db92b4c409aee98b679f0cb72502255c77bcc8ffc2e57e8cd9f0d41c7faf4c3c35927c4b9964d5d6112023dc882e4056fa499d85e83f2b9b2c1ff85d1ea3fbbc4eeed62b1475d4a8bcc1619c731c30d5bcb65025daf63f018576b40962efd3ddb7b7e200116ed300b0c293fcd4ddec7fcd0683f07673b60c8b9b020f71b8a270310dcba8fc19fe2970a9bc75b624b6b50cbd0bd9ef0a640eccd231e876428acb607be9ed56230ff2bf669863c7b68d3ee1fe739322156bb5dda5788285dca6cf2e0124d6cabf09c38d4ef083ca3891e7b7a93a25f6312b8c224cc5b67c96306b3d5a4ae61796e61c20068382754dddf6411c3e92298a37425955a60d4c1fd1813aabd609c4c67566a16baadecfb529ecc93efa3af34a20d86bcc7770eb3abd3776f6ea7478fe1bf8b80b18de56e55eda6f9df536b32c9cd923438241979a61341bb1bf3f52a01e10da409d97722dee5c76871642dec3763447e59147d13c82406003dac84b40231b520d28443808097a5fd9702099f0139cb00b466cb7eb2c19e2817692e1a8556cd939e317cf27df4517624d242e1aaaf2c31340c05cde1de9301e10da5789229de7c5a804b5b0ad7184126e0b7ff4fd4337ec3a1a7d0fb89edffd85c74f903f755ce2b2439a870a8a30d3d3426b0a9618fe1aa38493208279e9db3f47b4d18fefc5ca73e24cbc2127778d69449acaa9bf9f338ee28a6eb459f78d8c2d7fce9e028e15edb412613eac032c203a42f52b4f5665e508aaf76019bc1e37fb34f67bb237a4fd623adcd5e1136650eb62b8a13525224f2bc60c6e06003a6b9daaba2a5269eaba940f4191c382bdb8b740d4ab122e9340e1f54969d689ef4cd2cbd8e8f784c7bfab5259876a9ba515891683912e77e75ad914aae368ca465de26beef0f4c8d2ff899435082b56ee01d7cc530446bbfee405a149f88c4b6439a4816263f959129ff0818dc4698d6aa244e7ab7fa10b7d9d87cf83f4996cb6878262710dbde5b0bf2e252a500402324ecd958536398027415976a28ce2f30b7d26bc4c7a62780ccdb399ff31e54f798097116fd81fcc7b7944e36ddc58d30cf512b0edeac0cdd8dd080cb5a45ea2011be10a062bf510a48729f6cbf392ede54cca8dfbc6836b87aa9d206eba08fb09b834c062cb6b73617365b4c1d80b1a1a1038b0eeff706174a6aa58048b067551e564e12a3e278e8132b240b8152dacbdc386e324aaf39eae3fbccd6d105d4353bc635d641a60f89a823b0a71e1c0b35bc33e22fda4d2708a7a6e7654d0501078df4221982533f0f2c458a9482fa6392cbb27761008e5a522b324cc5b908f71beb1d0c25f753194cf6a0ee8f6dd8d92e39e99e710b5c08ef6cdef15303f6e49521016b06c86c95785f31d0d85a19ae5829993154731297fe699d6c48ebf58dfeb8aeae6067ce0e4a5fa6c6f90d8c7fdc7dd1b32a8812c3271917cc21700ec6f092982f3fa5ea300efa5efdd82f8755b0459f520d29083bfc763e37bed0d3377e4e1642f59b816bfe14a21addc2fd45c600c69757cde7ce37f802a062daa09fa0288ee19450a5745510c8d741ce001601a46a0a58353bddfb88731ad1f4bf2732ec9a5df156db39d2417ca2c47d845ddfa6e0daf87d0d792a41838f88667fa4bd7396ef8a4b70ddbc181c54c888ab2699a9b2662df6e2beec2c43aff456518f0bdc9964a30801de21df4e2324a61c0651f3faa5d30f496f14f8b8fb6d07d8163f0e94b34e25ff501937970d82dfedb428627e1afb36ef3c6b84f4150da3ed7d5f48df8aacf7f19a650b56d241b40371a4fc6fe8bf88779bcc7a71f89b04ad21f8352f02a9757c51a813d11d74255216609ddd98fa5182f73b1e77e6129a5ec4664181484ab28ae2c19e73d5343a547efb600092f60aba4cd0295d3f85647496036113b0e079a1d3b0b4dc9356106b8474154a2582419ea215bc48181bb5a535f7d127cb5121c03410c769b3cff67375c2f441f90cf7138564a7581e969ad9bd464345b8fff8d7da2d751cbb363557ebd5ee499bbb5554e96ee326d8dad85906be17a5162e5864d2270a4e9fe5e37fa9830c37fd2f4412e60b4bf62332110e84b47216c0bea5a3da590867bbae305d47d0eabfa31e5c0638afa4c98607a280879e7bdb2088bce30555fe1a3396baef3dd226028e13af9752d542dd1caef805ddd653c928937a06e5818ba013308ff9467fe2cbfb29ce591b8dda4d5751567982f47edf6eb528aa2a3f7ace1e3429309d7f7fab27892d4e0f751e4a7678d7749ec2376baed376e63be9ece1498c0459f765bee0f7b04e615b7c426090f85031c58aee3e1e04526a4ea3ff44b435a3ad7177f5f015e2fe91dc9c559dc55498c831eaced7b26d7d4910225d38b400e3b278940b7ce1271d7af613cf560e20d538c9c3a728e5bcbd67f3ab517c85054ee3b8ca42c0dcfb60c59637a2901dddb3c0855adbd830f42be0b7352409a54380bd77350ceaab61fdba11e7d1e78a6d74c89ef9eb6cda8b7a3cafe59209c18987de44e27346c35ec8322df02c74eb88558b94229ae95abdbd6e41e26378dbb1dac7e6e706c76e52ad7a354e551334a889fa4aa88073c6f5f4b7509ad22d28f413a7e40c8584186f98d3a8d23fb7cb0b7b22ff7bda545e6475b0f0dee95259e04f1691a26342a862b566854ff049ec4426999fa758c91ad4a56c5768d855e7bbffc0e5a22c1dea35c1012b063ce5bbed6ce7b537559a8cdf5ee6577dcdc35d9cbe47a38850c6e6cf98e5d1cbcba8b8405f866ec36601d600c6cb3efa554d42013cb865d8c997f26401b380f2e48573c08a9339362739e54a1aa0026a9850609190f31b5771a9db9985013009cbd79f056a2765f7ed422ba781dd1685db850f600bfac490a75f89e0943995eadcf54ef276b18eb8d80bc92ff701e1fa9a2951782e9e373774d154a876310a291f043b2ecfaa24b937cd49d96349bef0cb3ecc775bccc68537cb1528a4eb9a31ecc3c2934bd05f1476605f9f003cc9a90e75ccf9f3df3c4a322e472326e76e790e470d505d55d0f9fd49d08ccec53abf6791aad708c59bfaffb1f31a9678f081930d488ec0094481c8d2781378bcfdc26ccd88ea0de90d70c2b46030460675fb1a4c5ef6d2e55c8b3db800b9643f8bfb9f5da8b44c74fe78ad6fda1a2d934042a18aab9f88a2aaeeb5b7a10d929a17cac291298bda732c125bb265a2e6c6807875c58e6363b69c56298beeb0c788e986dc5cc77080b621d604b12bde7c65759dee2c8cb76c6bab1fedcbf681967eeb523d704d3eef4c27df252b1ea5ad6c426c68e7b8a483a0ffed40f8fd4c6ac238091ee4efecd9edd407510b34720c686bb11554e2f383f3a36d4afb5e5fedf07b76da782002cee745d2438bc1b35bf8f80ccd15b2cb1d834d17ef252cad798829bf21c003f212eaeb45594b7816171c37b9f75aeff0a81b175e0b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
