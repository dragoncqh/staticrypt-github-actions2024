<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"082192c3c8533a9a3a47fb03d8cba91284030abb16052779096de091cd7de5b9fd663b578aa9c5571f5f0273526b2ab857825857d7cb92c81944f180e1eb8506722fe91f24b7816b4f52f12c29c3193f935d87fbef6deefc0209ace396c2799d10116099ee1e55165b50f6676238ab48fb01c41f5bb38d2685364f3709e87405366e185671bdcb0e876e7c967d313535dc6fa15bd91cf03497eb76850fc00e1268f2ac77ead9a866ad5921cf4dd5f3e25b02bf5e4e5c6824c7cdaf68507da1f9a1a5b58019394adf31e128cf7372ec7830214fa5d50bca81fa84c7ad0caac838e4bce7a20d53b0fd16cc3985d0e49cb3fc4a7b3c9e9728fc44c5a88f79ae72718e96c75525c23c9f3650d26991f49304ad642576168cec99b0a4587ff9a032bdf110f2ce7470562d46925716a26f118b5b2a57095abc5f9d40cb1a261347faa94bbfc1814069d8b86566b0441a09b2338f9d3df0d988fa6c83aefda86b54ac30cf6ee19c150e738781c0fd277f678074dd6c34b1ebcc5bd229b8f5f166e2c9f95bc92481bdbc7a6555e7d02c2d46c630a33afd1135b118830d2f053ce06f5041aa4bbc389d43db4103616c7bcf73611f4d6971a98551e82047b4eb08748dca6eaeb46febda9401bce4c39d1ea2de2b0f475cab756871bb1c0e3c8b2ce179ddfa4ae3c22f99cef3af816fcd084c4bf876b018b24e93f2298fe06aedcdb75fb07cfbae576df16f8dcf83ab99d6b643e04df9e3e8c415a9913d744112451cafecf0a5e366ec045482fe4858cde802e497d4ea2f60ea980b1f10ca64e925c4c6046bcd0eef8e9ab8a0f8366a8d4fe443546037d95d8432e2d1c22d746f37afdaa7bbf91a6b602b390dd30733f1843c3b9df343858c69f76475b713746c6eb09a35ba057f4f240fc6bc218e262d68a15c596547ee9801678bd7d56929fa1425352f2ffa643d8e58b28df5f9cd7e0e110976a856c151cdae23c774104c14573b126b20f7e7b63af47f7a7b5289b47412c015d0ca8892d4627c361a1da14e131401b54f6c7277c7fa7a3849e40e5645aecbd746931ed2507792b9f78884180eedb2be1ac16db8b03d81f541b4b77713a55d7e2df1709551a7eb36f1f02895d03bb23a9ef2b10a4c87cc9e9baef3bd63ed2f0949dfb45006b83c0795ad52746ecefe6103abc3911e999b41b9cd5b77c23da52764aa1dd9e9aabe0f4432e9bdf49e4e3daeb3428022be10ac98e98c774052b396380d05f81c67b4237afcfb83af1f3312f48f1fbf68757f2dbd7bc0779c791b392991b8044066a6b607ae64fd1ef0b35d5fb4ff0c2132a324e3d98ab7c612630e18e23efcf04968f26627c4fb1cc28ca5cdd6bfa989d0932875ff5113c812c49e44890c8e5db493c200c089c17676d30c648d576f046dbb9b3482f44a0ed233fef86a5e857feb8e40133c8fe770186af10ad3b49748e8b8a4717cb9de0a0b0ed77eba91fd5051ba1031fd4d5a53e23ebdc7a606b26d5d8d13681a15bf38fd0e122d7a1e0615842e34ba3c44004080b1688f383aa111f8b06c76f938d64ddc5194306ca89af242970fe673b01f35209e57b48b610f64fa6babf7228bcbb7bde92053f56685fa7e4a0478e9f97f1de3569fa32af3ae1251bf085f9b5d32ccb2f432bb0ba58994b993ca520e50db6433e322b295f469eb4608a25f1a5a87fea526ae3a9cf8aa6cfed39cad614158181301f7ba856311d2a256d118df5204c5a86fe5e9bc1bf4b4575b970f4d1cc8f96d4e765c62b6bfdfbcfb5d74c0e0dfd84cf747b03e2789b992a7e7533cdc6048bfe97eda92e06af3a7aeee6771ad6f7d8e971f1b038fa2216f712aa1265fe4bbc4073ec725fd3bd1c66cdda55dbfe3c4020ed6b53ffb0bfd74d2f0a161f6d09ec2006af3abdd8dc691fe5e6e16030e178b697e33873f81b8cc0d0829ddcd75e599e719c739d5c635486168f4ce912eba9aaa8f0e780b19b1b9b31510c0fb3ba605496de68e4cbf682bc74b3545ff976c3f41a527f7ccb93d75d4c55e1da14246b7387d3876b6cd79e0d84690710185f5fef54ab888ee7c5065f568693348ab30f3ee48843f7ee756acf098489aac3684cb1dad5ed40096bbd6dafe9de3dc5b4f08e0f8685b61c72f1008442e95210e0a497d392af81069a351491d779b160b1ddb2969f4b11a5d66d298689997e8ce3277b2aedbba770bf78603a126d971584a7511b3ad7277b81525c21c77a89597ad35acd2670931a8c778703540c519ffc319608221b843e0b948c2d4a72543cb5dab3e6bcce995de95f298a23625c998900042522770654ed082a4b800bead3b95cacfab0c39e361a587d93d6ffb5983ced8b62ff2c3568439324d6b38aae65e93db46cd81aa74a2336f42ccedc807de75dc2ca1380ba3887dc512536b09cb540dfada6137a9a4b4e88b68f049fe8de04b8b0dfc6bc284c1a033b15a993a26e75c8dfdf2db548eb95d3cadfff411fcb77adaaaecce41d744e4a7f67d799b1d0edd023689127a3a668cf16a2862facea60bbe420d7784b2150bbce3c343d50520dcf45894fe102a80c3e2fccb90ace4b28752a4bd281dfde3c50977e9258c95158b3b3d36ab2b40535f3c853ceaa4414e23707f4b073eca24604b96b5a7e229ba2c14023be2353bc6a66c81a9f458263429a35d4d4d0f0446b62f39a677395946b53e642ba1f1a9541a27387011027df19faf6ea2ae9d2e890015c072b31b86aead26e7ed099b73278403c7e945556c5c45a913f70908aa7baa2be7f4199dd4b9f8b1fd5b3def48d909a377b7acb7e65b87cf882a41c79eb895a7ef6a277dcd7d777fa9bcacc7915e7a3ad051e5b21360bc1155d2cfe6bdd92baa64a70ed04a4bc17ef46362b59f92e25f6d9fa63373e6b704f5f0e14bd8fbfe56f93d1a5189935ee3d389d632d8daa4bc69e9b4795c123416ed459d03cdfaab52a38bccd981f19bb2cb768b8f3c2317d1fed94349d4c7b8ea4783fb7ab0c02a7b89ee936b8c0dea0557195b22ce4729277473ed745af1030c1e4b90d5e639a2b6fdb31520c2892441f25e4954bee29ac2cc6e702fcc648b8484d2cf6e8d79d2f67759e48c79499a17051c72160b2949248858f4a050f01c36f88f0f7b354f4522bd0575eab11009c72de947d3a9738a56a6e8b16800e42759dfc7bd0993e14ef3807bb22fb5f925073deb41867bf47747674d54f4aa96b185e256df5b4f32ce45a4a1ec65c536b3d1651afe214156da3061a8875aadbb081c1e9183bc073a0ac180192b6f3510dcd089dd2f0c024de03748932353315f4407462b2856222a61fb507ec5018c59be2aa8915c59a8dfaecb55b5df99504a3f9b17029bfcd80479610640d00d824c33da40820aee007ee11ec21279f9f4d1a70a933c238cbe626dc5ae0f5293c7c1c445e57a519d8ab7e5edca86ca56356aaf5d88622ac43f185c24fb9c84de60fdbd8d54df09bd1ede05f1a436e6d3d078c73dc341c95baf4b824b55ba293f23524d2758440c238add53027379b3ccb1b8b973e22ab73675a462c28599790d6f0c7255c94ca8f584eb197327396c36e71461b9aa759aa9516d66acf696f6921b635fba4d9a06f38b1ab55e737108bb2fbbb049142f470cafe2625a25472182fe1895e411b38f89ec34fdf018d60bd9d6841bbdaa827483bd781cc8b7b92853cb3be0a0d07775927a2933454b55917e767ad8574890125371cde6aca2471cb2f932d96c6cf1c325b7312104af6fcebc7d2a7a660cce29b8549a6cc2d28630997e46b60c8da8a423971248b6cf1e3189313fce7be21dfe30829dae5540c52f03f9f3f2bf34180d1e4c2247de502fb8c4f1b329d461837c90a1f5e4c17b166a24849a36bad306493a511d17dd7f2f9d5857f947cdee7bb701c424a36bc22910bf540f3530c9bd3d97900e91ccecbd27be83924ab51c06e8cdd00551960e486158fdb9b227bfd29ccb95bc4214e16ab60e2610b85db75dd9962da1e32f4ef8ffd687af0d34544020210d96f6fc7564d54fc5b2ae55419a2418cd458a02a1caf0112a2140a7025037e38232307e8b746f367e8d6c20500b317617879be4ca2e72f23fe8cb2275e534b1209f440c8227bf3f5b9b1fd82eb1905d0c8a89947cde32e3c06e855a35987bc8afe37b143aa8ac42593460e437af6e4546464037ae8b384646663c1c2e34d16838e21e9527caefadfdb172fe01c30f783089c4893dd4373f583a2413ee342220546616414e4e4316fa83f1c47f7201e3dc81330304b261d68cd339c561c30a3648945bd960ab335ca59ee91c4b8bd9a01be736d77e0943beb09a15a143b9eae7da224508a223f8495c777de070b7088b2f67284b202136880c671c0685a7a30b4d535bf4e772de15a643a5949741f5350e0b0b3ded9c5b8cce7d376ec22c41d9051482bc42fe46e64eb622abab5d8fdfe7bebb1e3d598e9794f58a905a0a8a8abec27cdd7da5dbf86b9760717f197562474ee06698069338e51bb71c0cc70bdb82215a82158bc60ed1cf41e75a5a7389fa48ad3aa0a7b9a2800d859e628dfefc3340340221ff2c2f1a8b9d5944da5f40f6fa2e70edb292c632cf53772902cb5237729071cc89e2c3b9c6ddd25ecfc3cfc0c2903761fdb84f1ee601fffc2da084d7e09c78a0deec15c3b4a909b109a5f08c9723516ac699b99cd70d23058f5d7b2a57a9026e1c58d40da98ac9f7fc4fbf549ed28ca3d73399fcfede4b0035346cc7704bc0b26240e7d372c1020294d5df20330923a730177ecb99fa05dd3ee6723733e2019f5ccf616622fad7109f51c48c76b7b510a80ebdc36f0611138b425ce4c6a78ca1009645d5eb962de8d6497913452cdb8721fc509579136bc35d2269038a8419177d85a48cbacaa6178a5f786bc70d357dd7a5b802d24c227bd7fa602d7ef5c0dd481c430320f14b3377e562fb5eede7b7a53c8550781a423ff90e8e419100a1ba15bc06208a917fdb36092c6ea7730d600502e44581285a1882f98f59cf0c1f3d74b7d2b335ccf7cdded094901acf83d9292cc0874812e8e321db35a5167793e46ccee6510816f559d34da9c371a29b6aaf9fe4ceec2866c499e97fd3f7e53aeb6d5f83eb5a60fe09d8ed8c3884d137901a7d80f22fccd090beb081792087c6331039e49e09bfdd0262bb5ca042c2076d95720109f2d2687afcf217f4b3d06a3a9d0564338dcd117d7fc3d57899edf7d9b9fdb5a617dbba04ad411ad34050f981de7b37a17cef631f0380cca91aee05823af9d2061f86cc78bdc4d7452896a126b1183157d79adc03efc0434921616ee6e6145de0cdb5ea41c9958a1f0d38782ac53140eaa0f6c09e4455183b133231850158da0b4f1c8f905b40d6337dde6ccb28a7abffe70ba34025da757bb8900462ce78782a78a5f63cd403f9cab93ef74af33f51d01a9928375cb172187e2c5c09061d2eb624ea8211d886aff4fd79c1900584aba67b36eeb9dd2ad4ec9af4acf48260c94b3cfb30a5ff3cd502c7db5527a1d88badfc909e19bf17d7614788f1cd9792bfc6bbcbdf9573d6ba1cbab39d826930a06d9ec4c6622f5a7c39b987bd0a4d119490182161ede316ab6c91b183a93fe49155f632b44dbf5b194f155db7f9783841874a5f81a1f70f253dadad8675b05099876a859af60a9d22ebb16c9a7f8ad48f8d681497ab1c27a06a5a0664f015f0ccf562503b3d060f9e76be76e697ad51156f055dad8f349705e4efffb4a5d1d688132b4bdc51ca83525a1162c5cf32dacdf15d4ef67106bfc0ed6deb5610482bd5841ef4df93e05f61d89ea912975692f93b542ca28faf61d0ad4d85fa932d74d8532139e800141c52ce7ac3256b02fb12cb73411ba4d4262d7704699e6070acc8f9909b5f98438ae32be82b9d934d333bb6d30c2feff0f2c7a516ffd4361709cb68ddbd1a9656619ccd721c23456a915a9563d606245a1b70a8fb965a9fb9a3d20d7a4676c8988f3a5386b8be6b5a64a643a1e9b60863319d62628b5b011034b7fd87adea71a19573cca953bfde3122e92255e93930f311317d677f61b524f1fb516c340090e98665dfada46ebbe0151e349217aa46d5a557371373a836b33ff87e2dfbcca7c536c73d6954397c35fa2e443ec0ccb90e03b955748abb8ee5ecab8e762b8800a78ae6b79d1f493d55ad6140b0163e07fdbc728f2db6b671b7c78473f350dafca9ef99ad7812603d143f14f8bfee01e5a6e52c4198e7335ee3d2fd3aa61881247edc3f8a6612b27353e8978f710576e2ee6229eb1c6a88920633b3cadc8e59aeda4fe35b224b6a122625219b0244c45b566834995e20300124fdb04b6637062a25124bc1a191c264f3c1c5956855dd117c4b0b8843cbb7ae7690fdd348f3994f8948311ba4e5610b95bb06680521cd6d5f50d4f5b01f045372007801e8d55a05cb1bf9d9d6c550e853032639dfa5052e3296edb1b72ce6ee8efcae8142bb406c83be02f955d231f61c273721bbad9e456f6862091e989468f37fd7c80f576b5adee9c406e78d8cc4319eccc6ffc68e471a701662d69a8353db22ea51a4ee67ab0cd2c449a2d6a6c38f61183cf487db917f4e197a313681ffe64f303583f5c020345456cd362356e48000072ba5084cdf7a9e8d7b2ccd5211436fac1099ad3693485098faa987d5b2290ee01061abcee32a221541a606ec63f0d9ea3e5f74f68ec8694a92478bc52b268c36572deb012d3c078ec1d78665eac59209db67272803199e5052c454e17466dfc24e6da32c4ff2eb1c87754d3b95d076551321777ae56202d69d56942c6d5a61f2f478c4dc4395793cfd3a54c1b7a2442587cfff302185b9bd5e2027afeb6d3a7222c764694f1f6285bd0773e417496b4d723862b650eac5999f1263f979db73f67d169a3f62204eb8140288cb05376b3951e8e8f80b20f10a003e9851cc2eec330847be073e454c03b393737357c18b56f06920938300ce829b369c34627a4bfe03b813d9480024432513753b4723a8039741a8fb29164229de55ea88b4440830ac9f10abd173d8f2b16f36875188f9dac1c5d73f25b71065b99fcbbb80ae00822440e826181e3ba567d5fbd70be0940c88b1868868092d5546c802af1681ebe17fa4433bed12ea7f74ece58a2724748ef392c0a08ce3d91cacfdab80dc518e41e352163fd96a5ac76f1f56d807e00ebf1154fec3d77902391feb639f21d127d792a947f02273c272ea087e83c2d28ae52e23c5cf8a72b44410680f0a1c41cf2edff5ba0ba7955b06fb64652121e6bf7756334d02d0127fa705b88348ce76b6ea78540224aa917de702090d9156f2b123622e9b2680611d899f25a843916dd46aad441a1feb7b93bc6398230cfbdf76a1bd434533643e0e35d65c317e2fb9c06a67837a75ff19a1251c408c6286f7155d30ae30d3520e245f26d60f33a8ff05866a0644872bb6c1911e985b7679ee8363f67d69aeb2af26e7d9917278b4d768c22f8b2979477a41b531c4b253b14c05bfc1b10059a488b1d69d2cf4a4817f56685b61ca8059e95276c93cc5192c1e4786a5f0df35a069565ca86757078837dd3b021c00ba87a9a2e6884326ac8dbf8a36e173897cc5a254057b7a7f8c46b086baba7e51f050c6a1b8e1783e31b52a71ea8af0093b1563d350f2cdbe116bc47b42b46737af306f27d72e0b8b7d466c2e345809a9d8833fe9522ae272a7f3905eed7df04e8bf6d42a9eed02b1e0ed7ca1cb56b4a84536b0ed696c42f4a825a9929330023ca674540d1b21af8cd061472e95dfa5b413043903edfa5b5419c8fba46f88918fd2338490d34f3b66ddb40fea620319bba57aeb58efd157fbfc3b4b3461c0c658569f914d860888f3061d68783c7617b336c8226aa785bcc6c2cc7f280cf7e93e3adc9d307921310847e28f010ab5629ab98fc60841f7f8ed2221aa1bb454f08e47ae01ce427c7dda4e7a6b2777712f04068ea74d6a870e03008b9c73bcfba34ea54860f0212a49324e0d1e0183a522e4178c176994d76c7dfe7dca9aee5208a21db418f75ae7a1a0f30a071d3ff64a15b923d4394a21e0cd0d9f4397dff7ce5b715dd9ef723b4cfbd377efbd4f1d8b833c9d5cbb8f77f6826dcbe17ea7c3a0fea4d69b0fde81ddb50a616b8c95b0a6bf0183ec7a4e6a460d126b7ce677f5162368ecf030a5b2daf7338c3f83858f127fd8d7796188f8172da410c265750a7f23fc9a0bdf5a0be0ad762f73bca73e183c7ba7fc569a36a81f5d221c482c1939f8a731f0863277425b14d40b19eeccfab442d43a3b776050e3464a208c78998f5da341199621e1091de6c3c4f0fa2834caef4a609bc7d08c089457fe7813c3a55c91f1f8ea4b1f849bab120e51b5b373193d2c899c72c4cb6075fe84b714019572dc80d73ae4a6bbfcefe3c136a2046691f7be21684d32adc3bbfd88606b29e637ba6562e134399a96f1f77c7c46d0ae3068f993f3717022028c6393e60d64e373b4c8063e948315767fe99c56cf2ddd450e096df2dc5af3f7ddce943897661e1f2b151bcd83b5b83b59d82a246363be5d16f41e22b3c16e5fe003ac263d3aa49ff0782f6e257688e5d77849b2f53d1a4a097f3ffc946fb39847e9c6e32c80a6782fbf1f5b7c48288eb8d5601cbbef261faad64c21bd610172260c8018961e33a0088df2f07f8641cc7bc46b16a0db4177d94bfdf4d8a83d2d7fd5b36e6b334a4062a50db57b3a56e3fb55603ec4456b4081f7bba0be98f2f7d0bfeb4ce0459bc5fde15fc26a6fb6df010cfaae7da7c56a0f542e666c4d4070feddf7c3a431df270aa7a35235867d8353f3c1613a9ed404aebaf95dffb7270fbe8aa235d4c8c31ca6c7eab24795bf2077ef0a48b3042206fa81b2640fa6daba793080c0326ec58cf1630c04c7d1f08fc34d41232c7cda63b483c2994d0500c50e089ee3d1799632465197a8ea0a82455bd962d2daa920dfff0f4a3384d35b9786acffaee91c119460b3746dc736aa7d38147ec36b6eee85585c21dbb975c3dad0db40a272e9cfe775d46da5e1356a54e51bdf9204a0efd2eadf9cc36f4b2ae3062703bef7b1135c627e5d8ae7beb26266a881642910178746b664b27ec2d43c0b63acbed04fe945d1b5c3a16e8b9ff58a46b1cd3720b164d6f22f0948b903b9244e1df1ba4d3df39475dd9cc70bd6f7805aaa4666497a9926f321f19e568942485f8ef56fefa4d02eb1a47b975de05d4c0ea127b34ca3f1afe727e90ea049125698885deab142c5228bf54a620fc1fed6e106a000fd6c221e95d3109a912b821b6c9a98539f4c0c67ed05c0093f368f140131617fbf3ab0425eeaf67571aa84642e7df4598c9eecccd02d18603264625488edcfdbf57b1ba68e7ec4165572bf11bc33aad85656782866610578ce28b36b6ed16d87743992c7ac74b6f30294f094b0f175c58fac8f300074c15e2d498a821abb7d53549a3befa7a76e8beda4b8fb06d8103fff151fdecbabef86de0a8c3fcf5a17d3befdb9db2e661cb29e6a67594c4a94270f7aa6157229988212557c52586ef6cfbdbedb0b78139d5f5e8cb6697c928eaa10f86b2a0fe9cd57066061338328efd0f742a774c82dade2257b43f4a46f034f70f5c01efa401b78197a2734793ce04b8c8f342e58a84799b2d261355087592fa07953c683a4071185c2409b8301f4ae98d085ab25174a81d740188e41d4e3fe347d343ac5863c5c8e63434847696c269e4c18ca27924bf2d1e7b29074e31f15f7fcf9ff061cbd06f26742848c2c08b0fc67acb390b6a1b58499e0f1e66f2e432cdeba93b222c876b7f44ab899c699aa9501d9abb1aee96da7d2c084d31cb43f556a26fe27c39c82ad06468c14684ed4174fcbf39a59109561b892fbb7b147482243aa22cdcca9083e04acaeddd9d77d68480057757d79605bb5c6b7a97834be026fb8dcd26a793ab6b33356f6c71ea8fb6f30c0886b48eedc5bc32476367775c7df9efd1fd99afb2f5a26108085f0848ba295f360ae867142c62b536702034731b963d3895101a893c04aeb272359752441d1cfd5f132989c30cbcbeac04727532c34ca36e4d2cc26f9431b8dde45a82942f22e8f69f0d90384393bdbc06a8b7f1d1e30fd281ede62b3052d570b07ebb7d5653e1cbd0a776747d4676427d781024d92d4d988e1d67999f2112bb76954b0eb09120805cc4c00b403bbce98e1f8e3a702b099b9f4fa8c6a635e70a0fa5dd5a04ce39ad5b45c47ac4318fa247356ba1110530edf143262194469eb52b7e4215971dcba92cad59d42dd773e867fa0f466ec63af59329aa0b6a4951e5f76e1329b4e84ca3a161014b6959e8880f46d31f2c342c0cb3f8afeba221d2ced91b4583243467620d38ae335e7118a5bacc875894262603a8e5699c311069e2486a7a5b3f5369172645be601d8818b4a3f0a575a9ccf307c353f45ef77ead408fd831156098c8809ffcef84b17bcf63a06616526a797691260961064fd465c6a4e79eebd460301f8b451695af37c1ae057b1c36d56732fd8627fd65eaacff72803c953b4782fed572b71da093f55b946ee19fb97676b7123f2340f4c2fd8e545b5de3072e7384d90168307f6c0e0e148ced062d33b5623fbcaf50b066318d5670b0707d650cf63ed1e34a7fb6e4b7cd05e7e0fe34611756fc2457dbf0804e46da66cf0a47e21ad44f993a5817ef3c006bbee1946e9284087b858fc4fe2111bc9daed935d5ea419dd4ad39ac22d7c6051bdd1bac7b0bae97d3e9942a042315c51cf4e6da8d190eb82c134f2efa3ce21bdd5c4ffa291c1c17ba99b0ad606fec30c1bc3adac00412439412f10b75a29913a18a5cde259a9139c80e92039565dabb718d7785edd54892455c7a0a3121c2a015dc66de19f802f4a916d54092135c9f71c4d9eb78ea0f86fd967e8981a4e24254fd8e85636c1c77aefb1d1234f9a49b5d9cf58ae0c58daabe6c77c606ea74b56d6967e05ec74476c941b21866fb92cd98296bc840787df8da16b98abc93b9cd9c269941918a29a9d6d3a4b3b38e8584404d37bf2289324b4d801806aa47ae2b7bcff67554357237d8cb5a533bde5b045c44fc69d3fb407139d01e3001ef6ce9fda078832f8db93bb07c7f195ea887ea9f4a08d35fd0ce55a95bdcc2e7ee5160da912d367a930fc0870b1dbc315bb49e490986ae1818a9ee633df38f8af4eeb08337a834a35d2335a6d811ae57afe75b29693c4bab70d3d443e64477406aaf5b2756f4cedbf5eb8ce83b76adc90c19280b7c361733d02571f541c8edd15b351941ec5a99287f0a1a004075055acb29dcde7f370066308a954c4c9364c79b89e53ab3323ab47c2b6e9b06957db25b51652f0f7ff85a83c50053ac3c96b6efc3b2a760cf6f60d94f182523f150bee81f08d933dc5d84afd31e416f479479faa9eaa96d82ace5d8b43605d3536123737fef53aba757830374989e355b98f8ded8ae58e44b203b8c6e3744571c328ac11d93728fd8fc136c9b6fedea85b60e593ac5d9e8f15876c2793fc14550bb3abe864fbe5ecc0a2f38f1e42d05d751160d219259451551f48df1b7137d8f9ec639e6f30e6e5d6c90f161e14146f7b5ed04adaa8d248d8484eaa48a25d850ea8297431b778a68db1dfc289dca53f8bb82da41c60f1e719712632d390aebb16e2d2415f439c7b4269e6a40ae1c0752950c81f652994c89ac767df0813a1f08c384d804bdaf12e5c0bef6623e82b272d892809f67c1b69c94c31d021ec9c8c6122a661783a6441aaa66d773c7fa021ada393f3ef0d42fcbe9933ac268de3127a3cc5ad5fd749cfaf6a1ac41d7d6f50a7bd712e477ab7beb1bd37472c6b06bada389bf691af8e4d1dcabe75f349811997a46e99cbaf8d50650a842ce4c33243cb5675a799101e415eeb2ac174fbe0adc8654df89c8fc9dc5b5efcea35ec6e3ea3ae6839b52535e1e8b78e24d4b86bacbf3611c4e4ec1e823a17fe886a2c9a9725d2ec7ca6dfd087e4964e0a6edbc584deae87671bf26529c75d170120429feecba26c9c6a7b6ab57b964336beba6fa23b129e05a6676fe9cdaf4a15a7e217b2d54410222f04ca03e6a4086940c415696993c1baf1a5ddf0e276ca37fc63395fdb3ae82cccc4133c2a7c699a30e7cba1fd441f7bb48712336a68c3faca90e4c82bcb2010ce3db7af0fc08a37faa97311aab9846755215a2414a360c837f30e122e0e09ddde6706b9187ac1dc84acc390c9e12b2d4d83a006667de3f4b7c5a520f3e505bba25a84c6cf8d308c33e0c203f754c6a3485611800af7c15495785405d46e39cc51f0e4c86cae2341a66455ffca0f2656518eff9db71e3b495b3c5d9858a52fc0d88eaadfb1c9a32e55fbce6d70c8dd00ea87d215d31d8da59985445c85773e890c6bc535b8b4daa75b2b2a60331901e37b9b619a81711f6c9de2f1e9a038dd6fb724637b149773c50a912562626602db64109799a396327f2861f94bb6544607b2e4c81eb935b0229da38cc5d2bc751dc3db64003dd06c8d433e478ab2cde54f87eef15324dab523db9857cc37e4a8fefb62a55b9e4f1482cc32f2c059aa61aa1d8d46069a0c06b971219e347569cd6e70d1e5e1bdfa47b1b16770d32b78234f354b050e30160b2d07d98682a85fac1cd97ad881c2c6f0badad9ab4821d4a4e924243c86365e6da0702dd8ad62ea3387e3934ebcebb764295a816bc199f1e67b96671510fcca46eea38b6e315ed967d0bf5e66e102fae96c8c5bd69dae33e260565eacd951e36456463140cb4b4fd2af3303b0dec5ec9450a32ca5aac9d33be29128a796f5cbd45132fe726f1a70dd017c424dd6fef216fe4f86527a26cd141a1d5bd4292b991be7658d9645d99c36416334e4517abefb1381be806e5087151238640a1a596f32513acf0ae909a91fe34800281f8605881ea08511af90195c39b2b7d9650e917d08468249c291a7a6bb04ae651b77eb38ba834c2e18ded49831c75b8d588a942b29455f1f7a4ded2058f3db7e2d6cbe1da7a173a9efc5b44cd5e7d6085555777ee1096b1e63520d1b988d1933e46ec264d646da751b561866ca8ae8bb1e9fc8a22f9be7eecef65ba18890d4c68d6dab7a06b32354c9524d72eb088b0589a6b162e8e0e892da765034bef59b3a826ded14a27282485ba0befae83502b6b50a28b422d976d969006d1910c2da7f41ba9652d62c138e52a6a66ecaa652345e46230ab17bb5d46720fe6f8dcc124fe280bd4f3b54dea39a379c1d25f806570365bee3f2a6ed5f6cb1d49ee16489af57e037f533ab22f61e5e6205b82421ab5d7d5656ad6b329fb79cb77770995c226c7f0af8f18ca040c0fac41b0bbba69ab1f6b24afa18efa2419a83b0bbf33ec8d352cc5c3e521a4455ceddfa76abaf26af45058d8e7708431655f5f3615d3642512f09b15985d69aa1d4a96e649c0343eaa5d764140212d4e4dce7698b043c8c5d7691b9a36ad8d497351d4b1b6fc77d5077c7dcbeea38d8f6e1cefb961f05a63735e578a02a571f90a61f4110b56506baa059d81a610a6ef470c8a93b9d2e44729ba34660954fab97047e27896a5526cef4d6a6d2a4c996a0dbbb5148de100f5440511607f74412f2e727cf90a51c303f77448c63bca665efee9d084b7ccbb4a61c764287e7fce436ae5597b3641e30b317a6a2e7eae5c69f2ba92f5657369288315bc7b9cdcb94995fa37c7467e4151e2f230caa4f374b0e9f7141220c61f32e45f8115f8c1570e6c931fcba51db26eead70eca5fdaf507c0e17f4927c11095f0aaf43430f6fd55f7074740dc46e160ee8fa506d8295c56c2fe93077d02378c86c2b324e03657c7e2c84aeb60a9cb114f7d0e58eb6ab3cc29133f6fd9e7d7964158834b1580fbcfecdf0abb0d495e9987119fbec5ea8d15ab33700ae4ac33ea2b064a5192549e7ba4499343128586157369588e1e98898adb6455501a8d927a0a4e231da6e5d9543618ea738fe801b425f65de643707d8a7384a042b7b5abc2e90332d530e8fac76eed5d5b99549fa6b538bda6abd527262a942ff9f80d4cfef9f9beac885173be1f70362d4a2269ecfd1a12659f7365ff6a82ba8c94efdbd7b337891196ffd1190d932220b695739c9f1ac49102be8e20b2d064fbbf34900e1778d922bdceceea219dd235f06079500a7b81a39014905486d04a6634813348dba9b956297b292423c5be28557094feb452c9cd21853477ef907f0ad74482c4873451c01c6391527d8d8e308d218b7470e5c44ce73d086cb222b0ac4523c1b89847fdab10b726cf4975f975efe6252978de50a785b462b615bfdeb5e91c32a9152b5a1dbc86521f01d132224ecd89eae0fa98b3d7f6e598b2da51c4b0eb79badfbe1c05e3feb0540d73a6974ad4de6f57393f2226c3235430fe1fd52ca6bfc00e642a2fc8e75725bef84111c09c2ff0c2c4f9b8a253ed0dfef3ac4907a4ea6aa9509c8155e8d5d020ac6235daaf7b2977d5d83fc2d03992d9b6e4b8c8406531ce068d3e8fe0b2ed8148fedef550b60620a5ff341146ce56b28b9aa8eca3ae8d46171432da927abdfbe01375c527655965ac7d3a501bf9837a2f57a21286e1df4c07def0334d3fdc966aba7228005f65d92105ebc72806c8dd4d2ddde08cf311c6327fd931e02f225ec98be0922b8ae3008719c59a65af8a363212cb212199f85441dd8c24194960e36abee366489e1073d22a742bf2d8fbccc5befaa244b4d049ae96d981c0581112bc9cc5b2245824f85074b1eaf5a4a6be606ba74f064b280875082490e3a87b9129254ffb5b60ae77e05afb6978aa48ce29ea402030d947420186f7b2627a7e7c5cb839c42bfc29a52d87d7bb830bbe47fba5666dc89239c6018eb1984ce4d6753341360838a4608965a7fd98b57b679193e70c1d9132e8bf70c3b51ea8265f1b49c715ee29dba8c93311a09369844aaeb3710dcbae8a144a160fccfd99db1f2a8718af120d903bc6bdd712a11cd04077e056ea65ade94eb24f6fd476962a087a3a69ebe56d9daca1ef7123744a0840c178070f72739998638f04b52a8c687d91a5edc9fd6a8b04f6c1761fef5c62bd4f7acc0da88d144701a6b7cec7f7830efa47c28c894dd5838a4bb5ede9eeae54bab005e8349720aab1bbd23b10962f6554ee44cc45d4f7d5b4044bd7214a6a728bb3f458898b00282cb25568a6956415a6b7fa5737198ae1a8838faac474dcf435a87b075913de01cf03dc3d761b6a3af4e0afe3deb47586a10e8262c105f2fa9e080f655378fa09be073d061eac5d8953aa4fc24e32ecb64d08f1ee642bb06ea5273c5b6174f82882e73da4d3119e38c72c145b94fc3db7bac89e6e7fd76d017253408c071566825f862d82193a22f5cac3cbbe77860123d74941c44487edff25cea38bc588facd8bd29fe6c8ab49dd6cbe91f3ced3b2c508827cb8146b87893cc3cfdc37e725130a8f68e27d1f346bd950c37fd3f6eca2615d74033dd876fa645c5d841d459412e6f645c82e98ce4010724cb5fc8bde39f1d16387d5c8e2bbe8c3930ba2dc1b79114d273bcb1af9d64be13e54e00ffe08a1a6d1c3677fa5758709a9405aeb0d183cca57ec6f61bd7083dba6cdf657a536d29b2aae6b8ef21c01fec46111910d1e485ecbdd6fe35d5bd31085921f3ba90e1e9cc8cadef66df053b4b09d1e8bf1a22b8d83519011c6734555cd2cbfc0fd2a81fa881783b626b75836e53b0fcb2b362336878a100c438b429f8f5d993ae14d15071d6187216ae0a3d1b769766b63f7ee64877087e08bf49351fb532a704ba7a199f57e7bcb4379a566a356070b28c3a42c6f4ed20e8f2629fb28b25141777947fb3a30ed30ddc7070d5a59df14aa414c5c2ba9a52ea06a0258a0a650c8c4aaf70ac52eba28eaf62b9d9254a37e4d7c3298953658bc4cdd467a005c7e1c914bcb1cef0f50e72334e2b21ff9237c61b63f314ed4a30164b35fdb90a4fa9f84df75ccd9a5935bdc5f834ec25e07a28612720d38f017f62c167bf31529b31fd0eff0315eb6938e26464fc124ab33a4ae7d0fe4f0ff49abbf9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
