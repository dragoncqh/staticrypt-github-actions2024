<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71c19157f5049491f5e2aad81ce019f5446f90180af20994179a0281b3bc55b28b4a5926e47c518b14032a26977cb656ee3bf3998af390c56a16ce5497cd6d5960e5925b78d4226d06b4f03e3db025f22abd1ed4343fdbc192439d5a05bb086a28c8730b8f6ebe06763d2b10308d9cdd9db5ada107899f9043023133117a480456db109ce1c4847ec1e23f90a087eac7f3a250b45f0224be911854cd37c697406929f9b11a1fa7a15617d595ab22e6d15e43a7dea291ce77b121b3575e02c207d436ae3a0ba0ffe65894db1233213665fde4d9de84ec0ea79e4f90837b3981d30355d87e29e5981543a64010428e1188ad35f2e5646086ecc206de281ed14864beecb2fb88e04ecf83205d01f2ab9836532d3b642cca004dfb169aae9ef7b83363fafeea1dcbe524900e054f4c3ee63c4b5097f2368ab79b84d3af8ecb30aa18b1dd8409388037ae1b52dc3eca6013ecbefb005d41b2544850906edf80cf5678dfba6b60bb8d3937ad861aa0252f7882b30e06ed50765d23042536068459987417a5d37fc87b08465fb02f2e737d3b6348d38102576a53ba28e7f52df561d5522f69edcf1f00b0d4dc58e9cfea765903064ce4aea3e690957300b7972629e74fd6aa18be18b8cd2681abe264f92e49d7abc6791500a69d79625bff61b1fb6b1b892ccb14839497eb18d42b1a4a6d84a64c995eb780a94fb786b934058d0edb16531df9cc553b907a29a8ab1e2dcc974ab61c368f45abca398aade6e4cb97664d7e0c0ef21a2042452b7e5d5c244d01334ac5bd30e08d91a8847def16370c194e0221ed56dc22ea24cde962906ca3b85ef02339c0fbf49d48460359602a89e692ecb5a14a8b666a9fe00d63382797065454fe2eae1d1c9b9c92b16575f873d57bc1b5a59a87f4aa746ba5b69df7b5da1d06c74cfd5f290f0d238b34f694d725e2f72dda182ed127c9f4ce4f52f92eb8690c0f6fe69d3624557ad551c4642b96cb48aa6ef1dcda682db60d940b3e807d7921697a4e65775e8f9ddcb02b6ea53a6154a0ca1f17f9e77f2d62e888c6a74d6a3657db5176de554d2e3fd819b1598f77ebbdbbed09ae5340b5cce3e2115b14a0b6df696d7022e1a734528f4e80504e9d2257175ca3b0905acb9db4f93d59976d745c726981ec6d3eb26e684a2ba51586f75bfccea458cfc06969bcb33ccb5f72775565375599b7722c450c057be18bcebaa953014bbe49339c0d6634cb8e2bb33e337986a8c5ac39021031cb733829b1605508db3ddade4a5aa21674744b029c0a387e579b24f6b792a64262014bf3e10e976d00278e998ce4559a5d0731909bad15d7f97051a5dd03b923f4a4b01967ce94582641878f8e8d333b0b51624b60d5744d6931df68c8be99735a61287c3e694951887f9754230df8dce1d91e0945cd21b647b0fe394a00f03530b6bffa10750292bdb1e93bcdee672899068cef5918853710a9d2dacc8d553d99f79263a14bccf8a4fda237f9df7f9a84934914ce16ac96b89a339232cb2d21aed660b82d2bed1d4811dbe84e23476bda20e519ecc52dc0b144295924be8a1830fbe4f02482c4852ed46e410a7635e5fbdb33338a3bd461a1fa3ee4f93ea106d3da21893245d43bf5b36a7f5fb4be6214a18efb9916db7fa28ef63b863eb44b096c52b7c13a99a7aa5ae503c6e53974fd8640c2f559a9ce7c6e5b947cea1fd187c51966fceea8a5a7426c5b9840a31b1b4916d34730492c5b2a8edcd921c0f932fd6282d18ecd112c01b7ccf41b597187d2f8c611ee4ddb16c6ad9be8a2890d76681881643d9e8ab3192d9c6601c6067b9817c7b6ec18f593350f25df9156953e9d505051ac88374cf43bceaa4482bff2c23b90c7cbecf35fd7f8f1ac24e574b72d3d8b1cf384287282e77369eb5c582f6f42afd097d78f762d2434c68d4364bf3c0bb19895b5f701fe2915a2438a8349289256442b1eb9f2d418e7af397f7db0da16c296096d52753c4da0eee16b4a230fb8a9e42c366d23237de45c5b598573f4b9f83b87c50a9271fdfa7371fff1a6a32c35e0b7614cf5518142b81f1e4c1f0d58a16d1ac314f4eec15a86f25a4aa2142ae611e72841d420576dec97c206eb2aea99208913365eeb93a0eb76d7b1234a4ab81fdb1b1f45f8d99e8609ed4319cb0eed2f32fcc9c0c433648000892a4c88cfdd1530a682ad0126090184c83e549b16b8f9a952f839a511bcfb9ba44306e7bf38fd25aa1c3b49094769c7c41a1aed6b93dca208aed7c07f940fa20f3ff47bcaf515dd9ead8ad3667a4eec002e453236fea4113ade053d57e7691d49c14b74753044f324896242b6a531124d8e51ffae2b2cadf76aa780e0a2cda4afb68fae48b40c5fdc5fe106d1beaec32526bce5f02ab3842f5b6ce0c60190932b9176f48f13accef44469c88abf17c8af2f75ab0683b309b5e958e01dea9ea5a64d13d7bb5b0f393ba8ca45c51627a0514cb01aa71de43fe9b9086b568639d44a0a3d484714f21cc808d4319e06f610ce9a4443a5f416f108d00f3fe7c2651629b00e908b9db8286fe09eafa618e0c3e19db75af7f6df4dd0106ee8eb0036b0683258128d22577d2cd281d49dae75b95d01387d778aa029ef3ed7adac86372f716c3bea2a0577a6615b98bdd7ea60e49433bf1f5db42e187cd3b46214c91918c766f7ec51c618b728007e94e3e57918e04732b92f8f893ccbad7e703a008e72e21b3519dada9ce81e843823dba0804e2f1d1e8002ecb1916c0c60b234136500f771bdad08df64c502c34746c83d45c2950330b3647fb119c3559f7f12b0f7f62026e55f70fba034c99778a0d50346da08fbcdca418893d5d55fcf55aae76c5c080bb0ae16f27c34a70c008ab015ff9b06ab63dd3c5c4962cbf84e379c96c8ab1ecc88c7aafc1bc00948061b7cb83c0bd1f4796923f4351694aba425f6e0699328a2a14d78b0358b7e37613f359ae8a9010b0f78bfd437006bca6f8c8e1efa28e5abfc36cf963f483a37f80206a7537df1674794cf56d9aca810767b617abd29c1202f1259173498fad8fd3bcd3dffa29783bf638bc6f44acb9b84d5420b16c452da1cdbf496fa8cda8e2a25518510491021521486ae1ea7644bfb23cc5690cda92b217879f50d20d96a7ab4ccdfc1a68deaeb663b6a20bb46fb1f0b11b414a200b33c25606179ba5f2c937fb79b36aa37f7ae3b28129e79e513ce43ab2c9556f516662e16e6cc6ca6fdeea3c07b132ad62e9a1ce054276ad69c2fa6529570677dd4d8c018488f02ce91cb130f456746ff58d09737c6366b1714d49c2439bca9e309a67889644f02ea0e8f31f67ba0bd8e79ac8910c26b0c19d5bf8f27b917fad9e648c5171b71d505c9d5200582cb2dd30f99ef90ab74f9a2ca76f7bc40c3d9dfe341151ad8ebfd08389313b4248f25092df072a5c5946d1ebceaf34372580d80526f6e6235cf8413b7051d6409c33a87057db0fea3417a8ab68d90fca503870b928a5704b113c312e2d4f72cd37fe58f138405695a4fe71e046902c773234d20f053dc73d63c9c93e300ac7299ef519ed1fc1cdeacab5aa035816c7c3fdcbb4d554d6020f33b4afc41106093def1210308a1db44605e70bfd22956aedd1bfc26657dc98daea496bfc06b38faeeaf6728704682ee727916d0881da086af53db80ee5790988b468473c5bbce860e842288b70e74dc2d17c22ac84d83793437d183f45f4f6a45728855e08f8e0f7c21807a9faf80710e140eb3c4350cf30eb30de7659bd9ae09fe257afdd4ba40bd1bf77322429d135f48f87a0728987c6a7e839bd54469b396b825430ef34d0e4df75ee02609ef6fdb2b7049556ea5a0624e99601a2e42f9bc2eaa517d605da390360695c88a48f11c5ce93a4ad23f6993f85e582585f5373458c3beaca18fe547ab99db81c255579e72fdbc4b29a7c2a18ac1682cb52282057e63eae2906400050517a1ebe5e89293e5806b2b3130d3f998b4ecb8a10e6196f5e3b7b9205cb826bcb4ba210d032765e8b51423ad180954149d36cbd85ba33e45498d62152591c2f93bfc8ce552ac1eb4747cb81e20fd2ec0f96c2c8e36820fe427512e8f6977fc1b2b1c22bd2a6906de90d7ecd0f4a5f45dbc270cbd50d10762c5088b8cb5f4e7e444e81f7b405b95f2aa25fe06dc1e6dab03514e2c16c657eb60f58723dda240fd3414ae72cccc8b1d48f86313d9a282e2fd8d7e15fd9ef02ce61a5f8c1f88e624408ac555e70a92ff68ea45edc465b697a347a1f800eae0f2b034efbd21d3e6df8bb0c58f8dea6133653e5dc47731bc8d246962d9720b98ba51b7e6a7b66940796cf2e92216ff0bd312f898c4879c1e5cb8b77dd7cda5b78e40ad3c1bb5be844c16e563cb9b6dff56949265fc2f0d40250218c793261cc8febf5f01d4d9302b9df4770566c79c7356995e65e82e2ba2dfcbe167a235d0f27b3e338b72a12f9e9127b2a534af2dc38e15ea2661c1d307479ab3d6137789dc64b905a310eccad5ebc8248ee4033f31a95cf2a964d24c73d56f1f6a85dad6895abc23edea64efc0bc31c75c5c344b0a42317123789872dbb45f610662b3562bc50c5117a7b7029350ae55d17ad03d738440626804dbed513a5a7d5cf7c15c5e471d6c1312a0bcea21d2e501dbe4b8f79ac509b5a507db5a1674d1c3f093aa5c1d2af3762cb25031224637ecb0880584c67679014595bf7b0a0719a07545f288269cf80c4a161f8c4054e5c6bad71b5031a4aa349263811d9e25334a57495abc0967a2009d6bd9cbbb998401e0017855d324a15cc5cf03869c2bff3fe446bbd2d820eb66869ab7972b2005f5651fa5fb1f4cfeae988fca83b904a7dccd56fbadb5c4396512b86c124e15f04ef0a00dd4c20e6b177fda298d4252d4677f652d34270e63f578267e6ef140ad2927bda7c9ea0a65bd5ea0f844c71ecf4dc88f0bd1517078cb9c357f27747b1e7aa429202ca6b36885b79a81e4041324ae6b6fca04db8646ac42d9c568b17d38732dd8bfab68c6d40c560134c13e23eae9061c882f818612af69501f70e93bcdd2b22130cd5190c69329c756232d8be2f374d50834aea8115230c311c76ea782867fd6673ae4fa0c634adaa36062096a5cb3e48099907f456806c70be38624f24f8c6d9226195c7ad569b4e2d2ca4a8f742a7b71a7f595035fbb4c678edcd3d30e349e3c269a5a2472139a78e792d3d1f23eeab13800a75e21a5b6b4a89e6fbad4f3a583623e01db91f5017f0bbb901c7a177aadffb6309c47473e21016d49a09281a77505c861adadcf2488005779fca7fb39cd2bbb68c88c600b6083accfd3e4a0f12e1d0d1149fc3ce79b0bfc989d13d89454a5a163975cdfe478de7a5fe75ada8bc13e89370be08aab2154b5ba4c432959a545802928b53427e652688b93c2fa24b1e6eb34ebd317ce3c4abce9012d6fc4f36593759b67247baa4a1d57109ff4d36808bc04fabb80151ac3a3e9319d270068c01d7adb6dd570460a05d3b7430bf56ac039d7cc129074ee8ddb50356e7e7e2385ebcfc78d42c4a2ce08862453b7feedbf96ad305ca3987b9c670f4ca588ef7fc1a3b86e7669c9616e76d63de6aae1282195a06b0e01cacaf0fb6dd23c091d2308682831a4c10e90084359f5a0362e703667bf4e450ee0bcd3765f1b78137d229ddc41b8e3168c37546a958239eb12981607140295c3edd162e2a5d28db71e186c4a37781ab6d9fa0f1d945c75ed512ce42b2fa878f8060fd21ce2e22bfd76589a9af26cad21841b2fc8f5d61e132bc4cbf5644696476908086c738b55a14973eab06aebabf4d393cc133262f06661049023f968e51f7d16d8be7ec1dd22f104d596451a7e16982814559cb04ae9a585393a56f50f11c86ec21d665d17bdacd6f228011085040abaf5005093e413b4d8fd55a6b1e5e8b05af460ed86aa6ffe94d9aa18770871db5074b849f202fc6f6a732516f93779a02e3bb3ce3d582734f5940cd20348b0f2a3e35b5ccca7fb00a5cbd3099e290ef727397b2b97154201acba7967bbbe38be2c65a05a1261c30929c521c9e0d56519a03eab37c9e0b9a66487c412accf59c6f7a720ea187d901079c81a4a02a707fba882d783423f8da4229618498233a2393e0a3b918ed9273d9e7b0b0c15516ee39b7bf0a22253eb7c3501ab36a05bd32d5f488e95eae59e2268af203b320ab8bf5f0792aee49e1459cf12f7f43eb4fa65124f1bbcbdc877cb4c26daf2239af75d980fa90b9c2c88634377c577a291a18cef07283c6d91538e88620cdea451fc0495baecf57b1c22e786da6a39c7f29f5597366398a29cd5c8193d48c7119b1d6e5b0638ff6f0e8aef32aaae521a99e98d48a91003b2a4e2ec6e3fc7dbc5b418152c56c80d4de695be01c14712a669434854dec9f41bfc6ff30bdef10895229c8fe9c186f33b0e14bc5277c85a8ec670c06799338814e772678a55427f40ccf2d21eec56236b9811bb5138fdc16441ab7ec0c54a2a104658acc4b984a6041f8ecb7e9ca108e6e0ed92c623439487d00c94fb388c13c6d4fed423866df02388dd5f44415a065f594ff671bc9cba62189ab06204274675207c8f31ba8e1b62d38b969f858cd4f7def66b71e4fdbba36074475a6f0500def025b8d43d9149532c10d497e47f5719c4e0141a02c4f5bcec4e8d43e37829d56eae1f840313bb66ba5cb8a3fff5dee042313fef6f886fe16cd749e18507278a02c98a81196f159d21e9356f261fd21d9ed99a379940df199946bb88afcc689602cb05a430f30da41e971d65b311748df77bde7e88c7bd75ba91f4030b258d6b20088e45dfb569f41a39aef10545f11ac6ae830e5118fa9d9758f13ba98097e05af33dbde9a8b6c21dc332760dca9abdba5e3893242778412e0879600a92a37ca5b8dcd03a01c2d833ffc15833cb2ff1fa25faf1955da37a1462acc28c7eb7b9735081db4a42b5d347e20b4931021ec81ee6f6473645c13d5db2db692b2c22e4f6ec71f349bc754de6087ee6f517bc18b12de0d8ee265ec7bff66d383f29ef09c0e972eecdc1d0e3ffb10200994cfa366631a04a33513e3fba1b67f0ab525a0af279ed907f124bdc9df0d095001ea0bde8036a96f98b5c4803a5a0ec0dcb716456b0f14a0f17c1389efbe343a1e7e017f6ca331ecb50c0d0744de0cf8044c237f08de299e8d5f7b289f14ec9e54a8a0e88d81101db82018f9457310e567481ad30c4379f6b589a6d28b18a76bdfd8467e52641234c86c99e33129df6e464883f88e995c04d8d9f06926496ebd085a0c37d8707c75bb58c26eb8a6dc0c6280ee45f5a812ade7cb9745b5ebc63bfb9f30aeedf06804d0f662951039123b2c9f92f0e85fc6f5e7874377d52f42870546a961f8986ec65ec3a56b320e6a2dc6ae5c998750a2bc81838c3efbaef0b86180af6c62aa3de748ba1175832a15eb73a63d2ae20b28888c08dfc441ff1d6417d61673473a793db9eca578365d94d47425fef015481a62e1bc66054afde1b2ee98be4ae92c3b8796696d0ef8bed4467ee2f80af7a9ceedd445f8f739fd7f2f2febdc788791fd3096c62fd77d2d8936920a86e83d5a238bb4e2be03d64fd587bd70f04ce653a53995d46c37f5e86488856bd46c64a4d3779ab42dee556991f28571eb1bb5757b4cf1a4d02da1e91a6bce8cb8836c5f00d0a2660bd1955a64643d4767b0f10970625b5853b1e846602e779d6b67a3aa513ad384349ba827b47724ea5c0c36d0f8b91b5939afbceafe9f545bcbb34297b0794e46cbd56410ca1617207aab16ecb897caf38d18d6a7a3140868a2cea9d49d43049119231fa05405713e911f3de40cce3d096621f3718d28288a60af4642baac32ccf785bf1ee5394d78c73e58f390f7b4a34ef80824c38acd19c962294b6184f1b4173bf495c18ef4dc2ee40d156e71d13652faeabf8c7cff2b66aea0cecfed6e203f152242d92f559641fc5e2477ddd36e7d19b09edb754850e65e2d1b6febd6af0da77d6fbc9e16eb8affe1077b04dd883a90b691041ee6365ae97ed591768ce7eaae6e2178572c4793ad6ce988916a54644757c6fc98ef118cb2225f348cf4d8c3726a38317f8bf34667e38a42627440356f0e9f0ff914db4e819ada832c2121f0f7c806e51571bfc61a5ebb3d1b8bf0c914c781d0478f98aa59f67110b836059494c3b4f3a4ba493238ed322eb38a12841c8562ad52ebb6d35e378b7e233eaa2055a961f89974186bd753ede33ff9a44a4c8c27b74b3f82bf5bd01b180c3be24c90cbbf2fae6ddd6f6bc4fea16b950b46860cef34251ab6e95a466542cdc3039772227f64610cf879aa35b12898de8e7b35d2c845bdd027b3c0708b2c0bf43d22d0fc09cd53882325c31d444e8286ae76e33fd2880db15b40ed234bcbeaf850650437cddfe7eaea6a740144e3562feba1b3d452ffb5a184bb7d79c18f60f7d2d84b3f955d6dfe0d0ae6f1dc8ac3d5a4631797c12a359fa9412b45546f553a3fb17414abbcb5e133d4bc720f66c87ed8f858e9ac1ec8f8ee478abaf89cd1f56ba9fa4f64ef9e7774f0d645c8ead75fbc616d476504d8445f1f35458cf86b9ed97f1da6dadd484223d68e24268658c24486d68196badee654405299680631f1d45ebcb775f58306d054a11d37740013974895c71f5b0fa2ccec85e33805f78c7340c1757e846ea30dd62b1c6d29735749f150eb279da3d2d7cb0a4de8dc74aa892dcf4b45cfb05155f7cdca95cdbe6830c22fdb6b5cc4dbf2900e575743137458f7b26a2657f572fa6ccc5e532d3800b443b5c666ff2a0c4b198555c0b1241f4fa6f9dd201c9e27b621209af7eb53cbe194f6c6b9a4e246d2d28b7861084888e402d06a26f38f3f261a3af4f0bea1b83cde1751d60126d00d280eb608581a8d608cf3045cf123f78a186dc98e6404064274c3d25be0f4c4cf4b12642d376e8df230940fbc713cd7a7cd6d7de8b9997926b9304c84acc2b9d7a32a0b5760edf40851b992c2150a610da5c64ddfd9ae55425c4d8d51fd7a0dc01e4884f6369f3f75a672de06ccd2f0056ac86495ec2c56b549f8ec84d61f8f486bc92104b170179cb960abf33a343a300fb066648cfc0233981735b31b52a5bff2760bc80c46b66f1d556e3d1da2a78d6c627fb93dfa1b76b2708449e6466d27e57e8867e56d2d03740392a6cffef9ced756c7c604316bf435e430b51f72fe1b1d80f7bcd1f07a101834f985ace902d2bf6bbfb21581394e5c82aa82c8926b4ac51577616893102ae420968edcc77140ba2ca9264fefc518bf7e3abd5d2f67fce9f9e6829f3a17c86d16f7b4a572f005b3892b8c0699413094762ea5ed5eecc81cc7d3fbadb983e481e58171b35ef99078e8233d2032a336488acc004eb0790d11c992fbba9101f5b84328e98abca8a007e1d80a35d73a9ae73236df67994e2e949b9c24fc3ed621b6799194e1156fd65f8ea9e26300f2db9df5023978d47a8a99223a9701f9bfde5a375ce65d6d1206bd95e926313468d47436f698d2f1c57e70d73c82195870767fc19f46fadf06fb16bac68f2d9343ea3fb8151093698f6425aeaa07a1ee678cc7e531144b62f216905ceaad0ad54c351c5dc51a3a65bf5ed7f6d7fc647e3ecfece0a0755d5da5da3d07f8f8742b0e27ab1b600268ffb25713a8a23f92fad93f955e49dc8ed3917c872cc456df9b8632cfb633e470604780130de0e90b53ee3f77303d024cadc0d1cf7bc400c0324fe0b586c3d936c48d77e43cfdc21d641ac27fd68b725866413bd7a21d94da686ecfa4d4ec73400796b07373874d75b98880f95d5cfda65cc00d2c253b9d0800e9dece38d484006a236daad3a1f81b346a3483a5c0fd7aa84e05e1aacf61f24e94d51aed7a8b4b3353185f0485fab4ce1225300c9f044dd04c23b5046fba486723802b3086d7b25ed8bae4775c650278180d2c7db53ab3b7d46a2e28198951b8130db9ac7e135e9a66809df47ffc5ee6f3241e6ce14639b2e42cb7b96014be1b99fd7f412c697fbf7af4ed4eaa548fbccf9fa4bce68dd6069a872ee5c43f04d65be2baef6fd62b6bc8a43860ac9fe6cfd7d23a08849c1de22cac4529c09e1d50f7701a0e7a1d59743cd269a1aa940b5bf2490726b36c45465c42a38ff2eef6b6e87d56cdf42408fe291378b34c2617dcce52e2292b288aadd85422306beeb400f5d6ffb24ce8be719d3b2aa60cab58a7dd6bcffaf7ad53af04e4b46c93bfde396b70c64104babdcc46b669352dfa6dd392e8d6284eebf5713d51b4892e5c5a75fe2a8e245a1a8defb6224c2e104dba1d9fad5759a69e360532c05115f10c7d3dca33b88bf952409841a94b37ffcf248493b1eb632a408b845aa953a56a0c60c955c4a43b311a4738c798561167bcdc493e1f003c9ca016b913c5ce049127cd955243312aa67534e0c2b90102b91f208c43891e430c274b11df62de63ddb3b947c76ed97e7ad5a9b69a673ff6ab904c16dbbe212c892ba34c2d7807a190d722c65c3e802befa2e1c50ea6329f47e003026a6832b5950850992f84e3bdb72f16a12b316ac78ad6ce39bfc50181064f997d7209e9b00bc274769b45e7d94794a8be1c0bed2ab0792d9a5ffc08af34d3031ac0b8c657d7789f9ad419eb6fb2194971c092f578f6745b04983f6c4fdde235aca780d8422fbb26295bbfeebed13c1ac3c5367ccc411724cb0cc6f25686f8f66e8932c54dc945adceb819b778cb84187d58ae472e2be720c66b4aa1c88216a4f5bda6a9611d1574fc00e4979e55120985c72fc6ec5af7ba8949f10ded5bbf3612dffd69132980a5690dbe7c500ab0fe1ea94f261a64c2f1aec241ae2db33ab4e973114091be486fec33719767158c542759887808b69bd4da27b216d22bce1971bdaee258838279f5008c8a72b47ff0cbbe81acf60fbc9a0101bf0eaa85773535046f11fe022fee37f9a180768b59b8903d1e2792ff7fc90b438814becdfb53314aa0dce2062eef9345b103f7005216ca221a11917650c88b7ada904da2344c6e086aed97c859a7f86fbdf9232f9f434afe0b6a55df492a257981588d197b750228c3b857ccc018d314d63258caa587bcc7f6d2d041dfd71101f61c4f83b212aaca379697676403e647f048e629a1f1164baba78149d499c54725efdb2e38d0163f90b11e0ee740b5e9a23eab1c4b98fdcc03de82bab0fd5175b4c4f33842d28a0c090d9c044a72dad0f3dfa46035cd677ee9f0dae34f81e86e7effe637951fa50dfe91a276f73f228d63b1b0c2e5aec7bbfba40634814eda30c56723211537f98e92f67571c6331a3868a61961070af35c91f3640065024b324283ffed95f142f68ac751cae71bc8377e47e443e137edb91ca06d7e1bf3e65f5ae7655bd69606b906da4404149c00a9d32987cca9269785d840fcfaa696bb59a2f9268193b2970970334882be066df868384e50499fc7ad780332d3adb003a266927cbb4ded2a6bb57572762dca16ba2603c363684698e355846a94353689387671b0a0b47037c81a880342368d3eb2fe0057d8357cfff915fd5f30d7a794c5394cb00aad207a1827b05b1e29f9714c1a00625c5550890bd8eb81e70d7016c31b15905c19efad4a28580e1e9542cefc4c0bb4f7a701bc33496f6cfcf9050f10e9df2aa8bda89c6ff8181c5c097f4e816a88f1abaac70f17e76f98b03807ac9e1db2ffc6556a3eb408daa22f1c8ccae7ae87e561269e32d370bccf1329bf637611bd53200321e9ca120c261d3a91864a73effaddfdbe58f8326018349523c592861c64dc967546f9042301b26b54b90ade3d751097f9226e2bb54c499a13525290c02e5a0be030be2e61d544905abafccd3fad47bb5fdbe418e30af301d3ce513c74e1c119120ee9a309e270d4b99f6173e2dfe8b2564e3fea61948540b01aef5d94712197c339c3152b1c151515d6358552562ffa6096557bf3b108cb52fc79a6edc3ab5a318c2b0f37a0ecebed7844780f53b710a6db7b65ec5f32ec522035d02d891a0630bcedc161314619e8009f8c26add7c0358ec548805336d424b2943e8e363eb242199880de02f85f06450e304400a049dccd87ba91b5019cdeaf1be6cd4095e8d615795d34d0bbaa5080b4c7a2368b3206888a99fe378bf36e6e4d620b2dbf9a1652e1f284324e49d7586c89ba6af5cf6fbcae01cda43bfa82fac40385a871f4c0c6ecdb890db7b762191e18f94efe2e75ea938258fcd35110ca993c4025cac876cddc51e2a59e000549bbeb9b2cb40fb6ee38df082e83797e7cab7a50145f4453a39047730a21afecb5f0042f586e6eefd03edd604552ff5273104ff976b4764c3df4cf59b0bc2641439f5b5552579b3297566cf901821d626da287fd53d3643a29977c1aae2241a59ec3ce164b7d8c354d0afea08f2595dbab60b7ba433d1877a908a56058634737b3da2730da53f3c5309a4986c707cf70a53298460330952fd460bf53746807abec5e72235ec6705ca01425fdc3208f9a07dd234cdec6f2730e10ce401c446e3d924525da9e1fa8d7db61e18adf1520394b557d872664603af49f7085a2f9e0acbd22dd89132173a46824f76ce36757d8df6eb18a1b186da6b0f8b6bc458e702bb6485cda282c90ec0874c93a19600a4bec90242c3e54071d09b266ddcdeed6d614bb6d29924f75690c01b9317453bd27647929d5543ebeb29aee93cff68d3e6dfc010984cc1153ed2cbd1a76868c89007364d9e9068cfddb083e22b505707e7052c430ce67629f7d76613549bb91dcf2dc599566429618666ed0fe334001515dfb400dd7bca1b8e807ea9a8cd0777de3413a345e470e036831172f8802e169140b11f3f2fdeee70b2e5037ae0aded6b5efc8719801883aa32901f8f566ba871f469262f7e2aab642722e63d984cdb3be2d98d6584064272342ed8c06127b26bc201dc910b24bfce93de3746903779753be6d33b965cf0ddc44b31cb8181eab1f4b1324758a139efcf437ed09e86c8cee81021aa3f00e45e253ce8f5b49cde4f5c973a94ccd2ec1c0b1116e826fb83ca8817270d6ca29792fe1520ee6593fde6fb403b4ef7c52f17d545fdfe9f366bc36ec23453557a8487cfcfdb98d991539c9a57515a77282041438003954ab2e9a9bba924e56697eaa50bf543c8ce9c5a8a748199abe63ee4188fdbf8b998684f1968e74be18b988e5730cabe0a8732755f5edfa0c4954cd2825ecd7246539d2da2c6fd43fb4758722bb33c416144bb9e59ab8d679c8a96992dbe8021941f1af5e787e0f9be94dd8342c7001418b066985e7c839b0d8952d82ad903e77e11378f61d3918e5b798ce554e6ee4f441e87bb777b4e5560dd01762a24974e0d7d9a1a5c861c2d9b2025064a85f438b6997b8e451d844324e1e2e579932545181d8038f76c693e4b87ae8b15df715fa01e67ff9b688da3796379f452629d0a16d3060511ccf4a442a02d7018d1af23c8753f42f2f9f0491f0fd0217725ba0b850410a9633a5cd31878cd5f602d2ae68aab418ddc2acce74f30f46e2c991799c4c972b36c89c4913254e0f0315947d724b8fa35a749e611a9af84afeae3b212803be758526a47f69f336f9bec98d86b38c7eb12e7571121a2ba875798994e0adeca1acb2f6221ab3c4e191c185ae71efa3b100c62067dda81c9d9e789c61a79689144ade8bdadf46e0d617af7ab67cb965d2415d5fe85739a17bc8d457a9999b91474709b505892bf6b32bd933bd06875f60d641de9b7469a2c6e6f9bf823de9fff23529a140a2193f831396ea69739b4cf6aecf7c78f3bf3d2db7534dab37032b52f6a55d3c6a5e9ce9f63c8e658f828a061acf4f384b595ed9aaa8d5cf664b72efd011e89a521d16fc567ed938cbc41e76f4f0144fbf74bb5cb6cdad1750c622b5e2be270ab06c353bd5d5173755b42a752c783c0008c18d2a7736a9fd203a8770ae39c9e005d8894c87227957deeb35fab78c257130784b782eaa7f5b9dd71a0ebc82303c4dd420220dcdf0dea32142e1ecdec2646b7e97dedf0d031c4110cf583f5f833a24b349d2b298ac5d5525c87a80685bf3baa82b89a327f21e55870c47077d47eb09c9f4374eb5d9afcdd1eac51550b1af0b83a86d3c12502a85cc1cf8c0fd816fae3fa28a341ff0039ec450bed2a1637194b817eab926d5a5c65574ffab48f84f4d541f7f5a61782e051db1b599161f4b2b66ccb0fd6055a8e65b4facd48c26104dc9bef3e432a022c559bc2ffe37c3737f1ea1b2007ac4c60f004807dbd6c307b31cfeac063ef57b12dadf4d931eaa4ed1e0e030202f6c6b3203166e339d8cb7c69002d4636decaa3aafd69e0b200885f21bc1123e2c5b65e49bd7d2595ae123aa61e9bc0c4305009a670d26c6d96de9a7e412eeb5bc75787ea36745f2279df2cf13c209a42259977605b5cb6f6c8ce98825ad8d1a0e69e26d6948549536384fe054edfb17e57524ff9348e69d51ee5a6a512541d4bbb846911e5d728e3b5b58f76904ba3156df03aa8414d1dac5dfeb21ddf71d4c4ada35ac8a09fbec1436596e2cd6d9a19a28cf9506fcd3b3d61d24a15c5f25f869ab8e5b43a0aa9dae1a8fbf106b351f77ee53a0a624e3379d9608fc87909e05908c07d3a162790b0861df4d168d89009da801998cad6e876329bfefa24417b5c8d1093729085be4b6a4b3649101e01fed5bbabc38936537e6e4902f93e8e9be942d070770cd36213cb496c7215b4a885fcd94b4897e4d4469b8a49a96eb4bb6d795381fd815be04886520b3554b07070faec121797cb7e6e02b16887c6fc08ced0baf6618a24e5358af7906a55c4028dc52d808771580e74127c1951d7d1806fa1efbec644ac121cfbfc7086d4f093dfc4d7d4f6591b17c089c641343aa208d8649fc107bbd1d5cdc1c74889f2882685fefee4235656773a09bfe72894d8ed8d39c2d915ab2adc1745d8d98abea9ef0535e5e3e3f8b365a560b7a5b506dce5ea47a1a66312ac488bd4ffa470d9be0c6d54432eaed3f740bf93aa7b261063d9c9cbed6d4ecc9d84e23557b95a292419cf6231f5ea7b3dcdb4f34b67c13128eca5723d3f3106e8405d4706fad9af4661d804f59eb1073258bd2760ef21d2e2370a2ded2366d7158dd190ea18938010a97a5f53ec915e0e484fe988af0e2463d4237086212622f51142028a8f601032575b4a343de6d868bf48da3ee91fd48c7f3f4fd30ed3b3c43e36bdec3d829fba15220af28fc9e61e37ea65867d77db6ea9b04e123641f6431d3108e35e8a36752fcc04ab607ce67f8af30b74866f0d8617b5e7fcdfe8d721a11163a4f83e45b11da2f46a5dcb601410ae73c675b26fbf6e01e2038e4627191183427b9174af4701148afb5adf38652782a7106a449bebf0a0fab332010ceb8ba60b808bdb224b5afc7d1bb5bdd9d01b3065f96ba46d13a7688326f3eea7e7290d4d9950275c55212ec0955e214ed77d3924e3fe2c89fa8d97e4a0a02b386ccf947dc79a8c9b0fcbb89b99524a5f1bd2174925abee3a92d9d7987cf223759532ba1d1a9a78ad67b9d6afc29f59417d556daa43e43fee3a587369fb11cf2dcfe34d261033d724bc6832f9a29060a5295b42752d61f7aa27059371aa06dd3261740ee475d0b555e67df0e8dd3a87b4f4b5562f6f6700d1891c7926422023ff828fe5c87d538c891b522e17ecd5ab672c7627a8fe2e65086f88d2495adc5939f145a476eaf653a388e7c204aeadcd9293203bd69f6b3ca886ee4a5d30d92bb95be265c0175306023599ac13c81b86972ee3634b543a412a9984af72871b0af78f3f06f3d32cfd8d9df014184039fcae677b9d8a112be3868b67fa072ea99f094cdcfefaa0fbeb9ab2fd63dcf42af709d124ad4d345a490a93ef5b25075c5379fa89949c5a2b51d8edda5ba3fb5d9eb0185d705ad50b7d365522413d55b018fe3543ee1192cfc8df9093c871a0e9ab9d956a1707735ca738a89382ddd0df3ab36238ceb48321d59f694f23233efa0c74b12cb24b95c750935dfbf049bdb3dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
