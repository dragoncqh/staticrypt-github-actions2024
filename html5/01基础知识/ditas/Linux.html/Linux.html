<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"101276c87644aa4d84bcdb2e932ff17f63e58fbe69e17ab9323e67c719a950cfde9ef7fa63757698038ae9f8e047601da2096c2c5b119e7e063b390f02a61d8f12771aabddbe281ea950d898a597322e60003c91e119b839064255956dcb4bf2f57a4875c211b20ab8d4b690c878242fd58bb7c105c28ccda8bbbf3b2202bcf3f64f4dbf184547780093ae0f04b5098ef6fa65369821a1a2ecf7a21b4592c0d0b1e08047275afc560ac50a6485e444a4a8d3f73ed1f34a907a410464fc701e86c8b1d9b5bde71a0156ae76d63d2233e0b6da03455d763b3dd940708b70e38dbb59c231b7ebf0da67dee71f2c8445e14dfb43dfb1fa434b83acb208eee5f06b292b0b96a57119435106bf9d6fe488af2dd9ef6115e7efcde7dffd287589d6fadefffdd38d9d59ba093b81939ac88aadf733607fe519d04e91a1cbb793377117c7799e367f4b6aa9bf1ab218cdbc25ec23fdec5168edd9b1cab42487ada667fddb10140d5d0ffa0e999fd12b0af2c9e7e32fda0572cf28a5360ca7c9d4e9846d14a9f5595fb218c1f2cfd83c10364c87c81de02f20c5c3409af395da21136db8aed85ef6fc4d334dff39bf4260bc45cd887e8cf5e440b491f0c12319f33bbd9526a65ac4f160d9a17a8798b0117334cd16c44ebd12f9737880a3f53a71ed96fc3972ccb33e1e41f519173b8b158d36b28b60ca9c0a38a0d8e95325b804f219512fe815d91071250de27098e9006ce8f7a6b0f4e53cd10d0c11ebf97296a9b0d296ee205f05a09cbaba6facd06a2e7e185e8dd55104703fa5fc02f202d4dfd2fd70da308378fb34e815d06bcf83cd542dc9967e2dc1acfd791929a7271b3f287170f7e6d48f78199d2d6803ea902ee9700bac4b6f035838b2c0eef0f8260bc3417892f450f08e6e669bdf42dfde9783abd8a76c9e13b9b276f39555ddba589c9ffbcf977a46f641d1529455ee3f958cb14b884dbbb3368b6727c9eb8690e734a8ec02cd4cf15f8a8f00a9cb7974b4e9c171a1ec794469086930f10fbb9246ecb89a4a7a14e5bd7a5899d981b78d5855ff6101d8ad20eb18ede0dbbdd762ca5a8927e306f6d6f735ce3d2fdf01bc930aa7a6bde240d8f80f041b9ab790068df95401c43c76932c450179bbbe264b65157ce166e42c7b135104a550498cf8a1302ae9ace84893884c2190c2b57398b751f90493f5e5874b171b5b726ad4079e6462fffa1bdb4b761b3125c9003d90b1382c46ae49a5b658ddc6435b2c65fc691f071c60bbb891b3f04aac747e4ed68e6df31b69fdb931b7fcbceac36b8a76bfa9c5aad16a993ba80042eab7679fe8e65b9aeaca7c1e0ed530c4829c5bdf4f4377accbe9a3c79c93410f105309dee87d5db9f7f7ad19ebe80193afaa47c2650170f9cbdc0300ad7aced79a5e4610aa44fe7cda2b2d5ead6227496a003b4d27ab6b1ad818b97b44b8a0711faf1f132f2b17d8c118737e486e79835120da7785ce797efb2a2a1522287a218328d3d57e2a25c67fcb3b83bca70c08604c346087931e5df73f0c770efdb53c47fe8489ae0666620c4f2a27400f6bea1bf3ad4b92b3d14ccedfb23dc8306c05445af006ba3f27b06ec0b980889fe7f7ab752dfee2bb91af19028aadc38587597c442bee67a770123c3e510fb99297bac1d9b57cba0ae584073b2b33112ca1b0a8f1404067e7790f267cb06f5d59175e4b7511735c77e6fa62cf79e09659d85d81edc3165e25e0af52ccfbc1e8b7522ca6ebe13bc804e3567cc21b3fda4fbbca0a863d411ae7ec267809b0ae60834e0b8b0cc41920c72b410f4f3791fb23b1f6739d69e11ed4e0d96d2b69337536bf00fad74f53d38b9e8bee69f8aee1f8b7b5ea779163c8d490d3be9c194c82a4c129f2fedc932edefce85bcae00434e693600257814425e7823b26c88f93b59efea5f67d1667bbb437e661f012d88efbeb930a5008f294c4f86340c4610513fbf290de0ca1c38ec1c0aa8f6fc0b7e254a0af8b14e61a99f87566c01de8fea0611c5570dec97076c88d4a931a769f0883eb626fc1a93c9cf815228599cad9971f76a454dd691393cf027f0f67bb288713ea4917b949d05370397e9b5497310d837b21cd7405b273f5e624c11ec83359e7b889b341f8c9617244d375231bc6e95e0984198477f82da3bc865435a914cec9ea0745313ae978f65f9a9394c7aa066a85377a06a30df9eaacfbd34bba769db380b0d868afdeb7d2150937ace3f6ab92da6045eb4bdb1a8fae7125fb1e2c707b1f276eb6ca1b7f3a4ffd758c0a6a047a97d32cc213daf73eeb48192caabdaac0d14a192868768c049d42fbdbebf8f2f76395252d6759f0fae2ae206c3641dbfc6d74a96d5116d5e511e000665d9aab35028006c9048fd3926f0d2231064b65fa458037ad12c5a269ba5103a9af70d5f7712162a7e1e5a9810f1bfea621dc575f44ac0b48831679b8cbfbb738881c8a478b4949c503d0f40e441936febde5cfc5cba05472e3cfd79aa3aecfae797c96a9743b45bf6fbad252c8450c6b4825a9eef4e5215a13880363098d3bd63acb34ac3940ebf5a1a33df6911b5f1ce4c37c7ae9a609a9aa7feb627cf894ec8ee18f2eb7a398c5798520fee7e0222206b4673eb3b1407f71c247a0ac615da532f8c61b9c6f079c9fc0c18f4870db38bc46c4859ca6d180106c3fad7ad72a0ef8910c2eb0842ffd1d572ace9c5726057261d79f328ba0b4a8bea0d4f81b1154cc3f8bb91ca831cd4daf16c79c3a73f8cf897a6b3eeb9356db22d1a16de495de3059b3680d7a53c5380310cab0bb77469cf913d7314dcd390f14d3621e45e6380fbdd68b061801c4758e1cca5a66f0ec25a8803fbb27ac937743c256f036295f6f2ebfc36ba3f5991355469052208344ec278ca754bc2861e2e91865f34b623b872fbb62114d6c8853dbcc45a4cbfea287bd69799cd01a11c2b8b6fe68dfe2b92a19bde997af7b10f0c22298748cf6e27bef21d61e6201c1e19fe551487dca27145854000ecef0872657347cc67df918897bdbad5e1a6f4a85c903bab08b175c68c72fb25964cdf45c8224e84c8aff6405299157b8b12550e4dbcd4d0309a57cfa8ce879e81bc717c174bf2fd1b8ea822e8878f707579d6f1cfcb1312dbd563428dda1fa807abce1f66a122e7ffc9d5cce5b4f18012db31c434c055d48eac93f53f5db9311615fdbfa0087d51767f5c18d2ca59d8862da02bce7e29836d9f9763fa788f25b6513e0e239fb22d975fb8e1f91f6b8cfebdf8b6d3bcdda56df9503c3151d6f1b354497a8b5baafe22a2bcb95eeaee7b2f2a4618e17a1c1998ce384070d249c9fc90fae751138c70db6194f7a6571f69d06611fc8793920ebe3946f392e5835f26422486464659c3c305855c4aac9aa8c15e8fdb691fe5c2cd26ceeac6eb7f665aa01306ced6598dfaa75a16284796e1323c9171adde74bad0ea256566f41dd612a6bd3f11f85f6597138f3a61e4545c3190dd57f288be7fedb5cc3beac989dff36116479e20b4472c648997f8a53404c2d39440110770f959624f1e77c58e32b1a466ade2381aa01670e0323a8abc248b7ccc58ede53a634e22fcc88db1d769000479bd20d0acb5c7d136eec22b0c3f78a9d61dbd0f484239994171e6b7442e22550c4cf9a7738bbe80085758574a762b0b93ff7ec29182590943d20a2f2de34e5f22d2b5c5b531a65ad2dcb31c97ee1587241e7194f167e5e6f13f4d2f7fab53b167b9ecb74c836047046c59394b92fad78742e5d41ef30b03fd53df4ef0fba14db1104e025de821bc5af79358c328ecb6c20156626d5ead86afb3b6a09b19b6db3fdab3bd228fe0e28202f27f26b707970b83c63b23842361680dd0019ec8978d00a73a9dbd33f437b1d2555dce7d9046a8b485225ff7fafbd0b294ec1f03505e7adc5bbf83b742d2290be4269492921ffadba2bdac820280525ba7c33cde95b612d02ad17b6d880eee4949febeb61df8824e316635779a3fc368f7f0ba45208c88dd60b6bc811aae04ea35c694124b5c2d13db905ddb8506ac5d97023da12df8f00a956d824946b05b07d5b12162895ecc111c86876eaf5ed43d400cf69399f228271a4e4513b4414cc62de8774ae14733e0c77475e3817fc97b72d60ebe0847b8b6d585648b2f71d08bb45ed9d2733ae76a74287414f68822ae8fac9ecbd828afa8818e49c67a7c602223f982beffd5d347d8167cfde298b21a156d7d055d73da065a8fca4ac615189b650432972c7fde56d9b08ba70ac296f8e34b8f73ab38f98556fd118626064aaf165915ff7d56c49b0201759715c00111234555ebc0bc923b83cf259712ffd3caa4b91794aa20740511357995958f214e8f175b57415473db4bd6acccf3c6f45953d95f845ef7b50e4b9232a87813d7187d3c3b09b1085a6adce3a40f91d61396433d09c599dc7f3945238f6c531aa6f18342b84e1f379459351160da7b9d276292f4036e84dcdfe27ce4f3df400ef55e2cac473880c008fa6f729d8262d29e053c33ff22f2ee5a7d3e0f1659a4ad7dfa07eb146e0db0b5305f76b9fc993e9b459bae4a93cf11d5a31cfa96517545f01dcd7cb1be51614ec4a806db783d80cbb2b2e472b489428fd782afe37e36a50976f1b15c0e37c0a363fc85e087018b624738a04a47954eb2a3dc9cb0174bdc59914e6413b61634ed39c48766232ae2b6d0d6393d6d274d8a12c93ebd80871ceecfbd8907e5b91ac95d03a0519faa32167587e17effe8706234c6fa7c4910c1df1af131bd88d1cb9a8f99d8ea6b91c353ed8b5129a133bb7f128814fc48cb86d6f5daef848c16057524c9615e4b5a479edd6be9aa6e0491d0ba5479373d6e369fed3d7d9f88090374831dcf8e76bb558326fa34ea71494ee13051a63526546f7e1671c9c255c70227ea9aa9856980a45ad847e650b592aef7f20cce5df41aea0be70f849b73cc33dcaafc166b74a02f6cc506927dd44b1b47a34711d7e717260ff2689aa10bc83686b2730ba720d418dfcea5ffbe877a978e16eabc77851e67ab8d696d981efe045632e8cb1cc2f246b5bd46db8889ed8f8d85ce0fd60493360ec3abf45e5f9ccb04a3b1b78036e6ce04f79003537b7c5d14cd90335ea8207744ea81272d5fb5b1ff7340477b305edc548c34d783bb7afb057f930b79ce94d9dbf2aa6406ceae93b1b71831fd1fe5c69a5108217c941ea7d6fcac8ed81a9edda5b42c63fde7ab36841fcf4ee0c58e4bf0fce24506382c05999e32b1878fe26e580ac2780cfb589d6c1f6fe2590a04760012636cbd91128e0f790d863d0235e122f8b29bd5c330f799fa4f5900c2260ce8f6b1f975a90ef293c4d63fac7f544bced5d993ae54554feab8ee6e9a56842c2239bb20b17013a39ac5476c5bac86c2a1ea1263905931abf0a49292553009792c8007edcdf0c4bfc86a09b885e7e89771fcdd0bc85446cd88d68c9dcbad248751f6cc3f18dd49c7906f07826cd81d449d1bed9983f2387440df898304f41225fe8a0bfda6d8e11f9edeb6ef0c36009642e37abc1c08aba7b42b9e18cdd271ecb6a7e49f83827eed257f41538d51ddef2107ef00ccb7caac219dc28593e144a27fa98260157cdc284d9454bfd81cfaab087742467a59a089d46a98951faebaf01a83262d62c474fa7e5132e29dbf358ce59a8006bc9ff4d10bf5d2abf70e477fc85675642cca8da6e5ed572d0ee61c6034347591f7c8ee4d3c0b30254efbc3f9953c6971ba78b4c650665d6892b85ea03cccc7b6ddaceb65be754ae70f05734b945967b8a9c499688d1ed7f942fb991f4cc678942b72f59e79eb592393465efd8574a7395dc8517a6ba8bec35af1f639affe63fd09b492c1c188fae24326de8c03e1678c054c0beff3b5528a1bda30c57a028bd9025e6857d1a45f0880b0e1fd73bd2674c0afcd1778e18a35f1b59b51887ed14f90e42a710d277d0caae245e2227944f9c6c89e8ad070969edf6b6e53fa31f4ce965de874cfc24b917304ac01a8db5076893616438499b4140846625c9b239df45f5a94c107fa8a939c92660e78a8d33f7b4f83e0d6c933640c5c57dfa25179b4a423af035bdcc1ab3f608b2cd1e07188297a889eed45fe10e44764223634349a1620644f15ea48db1ae4de3797a9b42a89e238a3e7e4968cbcdf9eacde658955d28d8b3d9af2ce6f0554b93e820c11bc7fc25544a6f9d29a2d1a09991b6dd88225c621edc5b87f3cb7d0b60f46a38969b784954f86fc6914ce725eac832ee6ca96dd84f3d17e124c72a955629bdea6aaa2382d8e4c5e552a115712d2672a71e3755e15bebe481cab94df5bc5352a28a6ccd9d72e29830100b67b4b57a7fa4189c5270e616c9728bacdc494af2fa2770e669d98f4513c04adf4ba76fdf31f2989bc27d10f659372317136ef3ad83ff497fa631ff1ce1b0eb2e3ede23fbafa9961ed3f87f6e9e292aaa1dbd09edc6be6f1ada0f65eeecbe11d3d12dd1c4c444c39cc95208f125e738128c43cf4719236bf930ef24ae8a83f74a0944de3c9db785a2b5aabacd42113a338b453173394fc89d4a1f1a78e2415028a0341f58a2d6389388b076323dafc6faffecddfc75d9620f3bdee475679f0aaaa93aa7acb30b09c4acd7706ea0995aeac9953206c9d2d28c96436fc9639a7e49490f46db2ce2f9b87a714ab000ad11540b8aab961bc2d62687720124e1139645b346d40e07692c4580d0265de28a7576fac99f3e6175042dcb3f2850384fce6498a13291ea6b9bf28b7050d80d6a983849b43c689c63a4fe9864b7e9345a7074f2d4d3a9ef35ce9251400345ecb458541d2e432dc4d40d3533a579df3c855ef356329898143947c682ecf0e7934f003282b6fe843972e28d65182785827d0b4e03c4fd271d2578779329d710a116235c229d26c9575a40e38401f1d4e9fda041167bd74bdd159b77d4902c13e2cdae8700ffa295704e88e8d7d355bb82b12cfeb415b46460512783cac451a7fb8c3d338de65afcde329a9f8e2103f6254237fc4257feef9ad082991c9bac8ae0cf3c65cc975e0054997977de11676cde4d43a1005a4908c2e1a306d9b91134e8da729cec11e695542493b26d729d2d0740a2c7ea7ff848e8d61646fb2d65c1e2404e53fb5aaa8fd0782902f9f14126c36e4cb956f65a8c8503b0c362772fc6ce480c1426a4792f38e4a509fc9177c3dd917e65d15935ad8c08aa69f71f77e85b75717643db51b9bd16b69ad83df893d50bf5e7e94905b9a7ae5e8313903dfa531b69503edaf6f930c1263c8867f59dde9058fde41b6eadfb21c2f9961dbfae8463765d98f26df402bbdaaac6932f34c77b9666adbd6e79fa1de245c042cdcdd02f36b1bc23dc3c1d25fd2e68f3378e633d82e4b1d14f2e30acb3d31a8286f43a3e1bd83581327f18e2d014e22ad0eda2a73ee912d5329ebbb94ec34862be93b92869f33e7eb78448e4f67b534ddb0f7b4231e02c7b4b5becb73b22f724b35de61b4d1c8cbe6ab47ef3228be159b041889a11cc84a1604f03d90424725af7cb4fb006f31eb462acb62cd53e0f64166713be2426786ea14c8d83be12b65e67922902befdbbbf1027d4fcd7498793aa5b6e761fd7daeff6a3142a238938ca7f3cff74992aa4069ee647fcd3e89616255d6d245c0fc8b6916edc17bc92b4c09c2dc531e7fc9995f140e1772380a5e86c50e5097cdd51b746a60234c184780e4376b95fd8b3fb52e81a8c4b5c250e038981c9f1e8eb9ae00c009a82c52056a7424bc5d9045b78cb4cad4a98bc6df7b44d9da5f7eb63605731305ca97b1a64a00f40017c4fd1ba252e08855ce71d744d529ef44ac3966b54e5e70cf0177d460b158f8160a03a351e185d4757f6c538c0bb5437fa477bcc7a84a7d95691c7234dca1d2586e2ef6eeefcb84a6c7b1185ab35482cdc51fcc123e13de2bc980faf89cb25e54c9969a4e41c3e38a54cb0086a1bdc05de0a6c030a67781ad9afab7dd210b2c04ae405d975cc784b846f53fbe7549d420d75d8711dd237c3af0b92e624bfe256116364a48b38330d73897a3d4df81c3b00310a59e091b3cdbb28533476bfa0f423bdf58cb53a53ce5659a0c167193c6db1971606a282d96e86e890cf16b87045bfe1e41938215d4c5f98610bfc67dccfcc048ffb6e1df6228b44fcb6dcddbff2ae2a5467fcd3e5528bd253df5b2b3a6ca4265b99185d33059517950cb69ac3548cf99442fdad4f4d1fcdd92592ca1866405b8089772df97b3ad991c2aa634abc6551fd960e97cea04ea2e38f2fba69c9b7d54fb502b839e7c0e5276b80af162432c72c4a1adf0148637e878707ac4e03d2c8b365b319052ad87c06d5c73fe1ae3b5f6504ec9821ff3acc42f8ef2eae948e7221fd23277834f6284736035c23fdb6ffee06050e858592696d75ad561a502bbd5f9d82869e468daf5a7bf72f72d3e6e0a681e077d9064f4836f1a38faf7bf55d29f7ed730a955a861ae5b11e948d262de5be33878e8a5985aad4aa524141d0d6fc2bc7b7218d63797aa1162de3431c6b7f91f89f00e7af3ab63be1fd2bc21f9fb0c7db3f6a273a166e61839c12a7a1b62f4892f7c3ee7ca467f69ba0ebdb66c44fd2d3dc246caed4f25d3fb1975324a33996bfc3019f09153f1c81f78b2bd1d2fe18a37aadf57c3edb5a1bac757ab78e8fdb65f0fa85816bfa44d4ca41dc09602250723e985f23a5fc5262b4c490b638bcadd8798965742a42cb1041005d24ecf4ff653d58432941300465f391ef1e32ce90f0e3787fef0a77dec3b3765234eb96d1f58e6b23893ec87a0dab6604bbba226ed5e2ff8fef544984044d8735c477b360234e2cc7c087b70178adb06719e3c79cb0e5a8573709d000157aa7784d138e3634b246c8b347710017c06478b60d019d58f38a14d6528f4763fa1478533021f6c5d822c43be16b864fcc12b9b51c9121fcf791d7e59a8de56742d0dd904dd3c66d925617244c409f1520f16d72b669800ac7270287d4edca921ae56c032207e1c9d88ce15f094e256ff590883c310d886ecf960fdc4fe72ae0dc2c4e5bb84ab0a2dd89bf58b1d731c446b6e5d5978fca19d1d4dfe2a582ba8a3370035308487a039b4f1f2e1165dabc54ec814e7f6a86003f336296de65b19628e755a6c404679e6b818f369b0914a08ece264eb3985dbcde2f10c646c191e1a0046671c9d5d6aa6acdfac2c3d2ca67e9f8e623ff4849ccb249d9bcfae7b687d9c6af7fa9738b240e4606a9fc82ef93afdbed227d01e1ed95591857324e176eb689491b5bd1d1d0bd313fd0e3435a76f50ce406ed532c4600d08375fc0abc14b316e425b42a7101166b02be22497fc9edda2f4d673aef84d2fa278c9f0dda29c6b44cc23604d762bea9eb7127566a4b58b4461e11ad85ae6e2cd12f9a6cb0c94981f1b925905c93e0e25ae021953b8541131315b4b0e8013c99c9be150a885b14a0f070c6479fe66896ac169595158cec13c1ee46d1596df5b6b9d3377f7954a7e52f5ae15b2074814fd9585d86aa4927da6e416c8b59d56ed34a23e45487ecf1d46637b56e6da440c1f61c3e9244ac2a6d3436cc6a1b4a77a92cf5af22f5af0801a8351915de12ec811b30d7f9bc8c9762fb2b3c4ee8cd9b920bb221cb49e8dcbed8b090faec3a9d3d552491e0c67af07f89a8454343a97da530851ebd69a21397cc3d41cfa030f5f94e681edc22b0ee3a7974647e18b0f99a23e34bf10147da4c6c2e24e0993e60942b662dd39f3fbc45306425508299d54db8b094e437de70ecac4c38f66da127665a86b606a1e7de5ef640608f90bc2537c54548346c806f4e98927851265cd655ff3e2843ea922620aa19f6ccb5d5cac37b261f5e84a83e131ca7becf7eab3e3d2235588898a2629625827197bcd871de6ff5ce6d067a2a91e28839f5ad579096895a6aed824c0ddfceeda504f517fc5d75acf856c3691272426571c8399583e34c9b400cb943f6107d2106546eafeabc5ccbe7f4be6b879444dd00a498e92892c9adb83045bf72ccb034780fb499c5fc13d109d0ec01f1555169bfe0709fb0dba7639e78215f242a9a9cf76ed9e1e2cc55da145391aecac260dbf2dc8c28b38f0e06889ed99635de5b0e772e14408da1efdda37c39457a318a697c2d45e9be661f1eb9a2d82eac97a7f70f90a906fdbf64ba8511dd1f892cfaee583b4fec7832247d901214194ddca6e2efbfbee1a2aae9af31ea2928ad28c22f12564e85dfacaa3b9f33e05cee1bad7945933fc79887cbcde16db7bb1d0bd950119dac37025f1655016dd53157d677057a0e4a31ba588b35ebe6ae1cbdb5cee4c3c228e639c189793d8b1b967aa8323b6cd838559bfcab92c1dd9ce5e5e08fcf868c2ed019b01d5967779d98cbb21369d65c2b51626d1b0e067603105ae96eb324141dd32fe6e0a87b1d7be27227b138fb815818e885c30c03904bae649c5db3c9820c7bdf91a8cba7e7cddfbd1f30c45b85629551d7ac073d5e578ea5a4c9c432aeefe34702fa840376838df99ef86b136f7553eba2f525bfdec8666cf0bcea3f07e27304f9ae821f008022336b0c4a4893e9c2eef8a181fe9a7a73f7f0c95c68d36059eef11a1e96c40cf67a940ebf72ff3547e528e58dec64050f352cfb26df2da6cd30fbdc2ac7007635ec68cbd18e7af6c3baea6a6835caf40e726237fca75b9f117265f5a3fc1deb8f1fd555dc3733092e58df362754b57eae7df830d7afdfbae6a368effca60a8c910d8c51238a15b73ff778fdc45c6dbb10e5dd636603213b03dcae2cdeb29e42483de4d343999d4dd87e16b95bf0e38ff03feff7b9745458ffd82d91857bdd11573ecd10cbb54eb50f2b4e05374e9e20923599d4cd389a56ed4b6bc5d2e0868ed46ac72c6392190a00b6e8a025f4621a7df3392e19ae93f730fd95c16b08f0812ab5cdf74d8b4b87243bf8968d795212973252117e39f244e9af85be0ac77008770493387cb5e169d2418afce0ed4a0d685b4656387e0caf4c59d3a054e4bf7946a4971bba6e76f57fbfb0d563222721312a89ba1ee950498d297816aee5c15302bc206af507df5498817e0e1c7255de4c98673c560d6324e3244349c4da9863b1c4c7671ad4c7aa90853baa37be75b9025b58371e49f2d6197bc71f64a32509df40905e87adcf1edf12d59178d6c1a7baf93e6e620c17442670ff65aa337f510325c2d18bc295fe0336d7a71689f88852ddf9013d5984c001ba8630a94805f275def9b2d8791a821262feb4e510e156b64bee0774e555f4bf5116b06f3aff7f206856f7701c3eef35c5be767d9152eccf2b50a7792afe93602eec1d459965d629747162dcc9c7520fad134b11262e621a2c4b0fcb9ed8da3ffe7160bc7a59520f5154e4687af3fdfc0615ad707432639e9f0833907c2301e42026f368f8928ec07db0c665eef33bee2b544535ee6cbe2b315a07ba498a2804c9e9dd8883abbc80fa5f35c4af87cd2a7686acd06bd5383295f449b091d9c83a9f12fb9ac0256ab85fe14316fe15752613ba333addaccbb43e346c58c74184e3e1eef99155d1aba37583c3192969aeec0a0c3ef1701ab52ef3bc62907ed57ef6e639861872ecb511828ffe766073108991ccb73a7e4e491b5ee0fb89233089f59282fa8343b7a7cf5f9e5bdafdec6208483a1bca57749e8b1ad244bcf8fc8308790fbec96eec4bb1294791c8a8b2c7dfc922abedc52c241aec8201828710868fe23f7ad2a3eb5b314da15a6017ecc157889238000256a2f9a099b885ea103d097ef921bb9a6f46cbe732d86c35843fcd4b217c915691aded2aeff4d84a3bedd04c9240368b6d635fd71039476b90235045e95caca21fef83dcfcc640770d7c9f7411f79c4aa6494877399a016d6b7e8eaa654f915c3ed6d1a6f38583edc3f833010d408a0301c2fbc527527139392963bc5794f3d3b2ecd08c4a83ca45892e0cbf83f313d000258eae872c7dc1a077554873100c2e0f6b9a87fe12ed5c849a493906e33a1ba4e0025811a53b17f16602ea11441fc6500daf665cc90630aa4d310c9a71fed321b5ba989242e8564d2b6fc703d2eff6c42e6f5c203e7613273a7a69d912325d2dbb49dbd476cf455a17a34a840143306cbec1a22d2ccb38159a2a78a9ac0915ac2cc295a13bdeb593cd3844f47edde9edfab1bbc4e39fce6cf466a0cff43315fb20f7f601527726b14fa164c1823193764fcc0fc92e1cc4d0895d83501f23d4a32a54dc7723d3747dad6d73764f171408d656f2576ac29e84beb15d46af02508acf121aadbd937c14e14530226ad73eb8eb699d5b8eeb9a0ad69f6412dc3d56cd0871712670302bc49b4558a8e25da08a7cd4084a7a9b89b3fc3adcc50473a6fcc71dcce35efe5e48d52dceba5b6a53c0350d03a378e0231a92d5a273c050d62f084fef9ae782fb0b9b90f33cd7f8e2987dc50c024172fdadec9bdb370f40aaf9bd1beb51feb951e9ead503e3dc8909b54ee01300976ebce969e09853083efa6a8621bc279a824a1fbb4f955ac2ab20e433d20e544dd88da4b32cd137f483e2d1d0ad13a5d83828110d9b6afa67cda8c1bea967fbbb5b6d579eeeff49fbbd665aab2400de55f5caf74380c22df3b9cabd3f02a85f22b11db7e2a9778e4355ea146573071c62d3d6b302df7a1ca139977db7f725553f1f49f6d862f95c55e0a82b485eb07a49888ea934b485f9cd7b5571e5b831c8f88a9881b46faca0f13d67a63e68605802ee423487bf4450fa6a8fc92e0482972bd05a745faa0599cd96711a0101249ed13b09c0b81758e52d0633c76dabb170d2d997efc51143e59d239bc18c4b8a081163ca4e51fe43d4d668699a1483dd9c9778a4869b3e4c827016e0b51c6347a29e27f20b6795eb2feeaf05181245c0c63e80bbaa99d98cfbc3113c8b4ac162bc4a5c7abb1040c32470297d98690a5eb893b33b38a6e6c00da75d742734fd0c158c0e02777dfadd2875a61402499bef195912aabfc2871a7a1e0411122ad8932c3249ea59d255989c0ea3b4661d3b6a19930445b667159077b6dafad09e9a6158107f3e674e17c592c91e379d62c00e764bb75c2d07b8eb41c29363a7d20b403cff10e5641317de6ca487608bf3522e23ba9b5dbf84dae7d7363c22b13c9416fa3694778bf8b3bfdb4a1997c36c416b687a4c60a0f305a2f943b7cd290160256ebbb57e457faf9ed7abaa6ae8fcc98d6c9d86a2afd402080ea8764612ee9aee172bb8e1b082041d815f330aae0176408888b1b449d2affbb5527a0324f30c78e61416af04d12cf90b1360f76a7948a9729ee63f5828172c9fd4c7a08c0226289c4456fa5b02ab48beec9a07dfaceb40f19dfc33f473d217f1b03083a04ee06b0741770674c363ebd27e267d85a00df511587b5e0c822f3ac22e0415079dd492e041558bd172c780acaf077a515d1f5455b39a13e505581c76360dc9c3a3093a4a02d01a77d845294b0b99bd93461c3c32cdbf4ff36125c967b4ee0848864f428d4a6aa7e51b37a80726aa05a14102c60ec9750e39dd9e5e39fdb97d2bbbabcf2818668589bd64a86d30661bdcd42ea9891127191e8c9e2173c517ad475fa49bffa5aa81ee5f37f091e17528b481f0e98eb5584f51239eb6f5d308753e28e374fc9c8b8820ca7de46b15bdabc58cd2ae18b0e6813b79291f06788f18599714d2eb654ee71fdd3997f8da95d917bfe84309b4c3920379080f4479009de14a054bf10bb93ce4ab3f2b5528bba1d763c6ef0c7a4572cec63245ff1e35a7d2180fef52444316c266db5b5d6f7fbc4188006761202a03b7661d05799848f58047cd71c3e07679417f9eb6d5c3ef6e0fd174a08654a0122cda156c3194a310ef59bf7be5eecafa1aaf310f6454b374001d66768ab3d42ba2d85e364affb43ad4d6394c26bbe42d7360ff2544bdbdf68b5645199a327740cc9b137e4c1a99f0ed96c61c024aa3b825a5ce6c07ac9c3fc6edf990d586ef7851170f47c9a165210b47f391d0b5b429aa1b005ac11f12df9dd3b1ad8761d209c6b318f66ea8378df367e2b7a17fe71f6e402ff6731e945e387dea45374a035cffb21e0ff0c4ac8005ea665faf9ec9be942f0ad0b40636a9551b7d8f49adcdccd6399372b6b60cf22493444e7e63f3f22be31c5eb017e5d684e06c4868a3d3d73e246f1dd4d8091a7bcbb937bd0798bd0a7f93562840168d2f132f01db1251866a4411d2e4ac6c76dfef01bbc3d076f11ab02d7b140809c489eb2642fd1055cf1e6fe16131cc39964e6abe8bab93c02619586f22e62cb5710ade5905e51a5db9ed3ac7ccad5b14ca9f068a79eaedd406b38b6fc8ce1647128c49b3c75ff9ff480f86300966ebb31fb944ecd98f1de40bf44e7892aeb00d584d6bf9ad72439c71cae24ab984c8464af6b45b01f3ff413615006b6e14e5f6893023136398449aca7eb211390f6e0bd0508f34685b2ef2d1aa687dede6f48e320ae0a33d1fcf99b7d40ddddcb3c69b68e6f03cf8c64df0234bee2445fa5485ae496dfc8f3bf99b45933ac16e148582d0f71ae466989f16c9ae12656c98eef252705027952852b8048c5a8aae74da7fb42f7945249d78cbdd1e9ea5701d68171d307c90a0f1d8cd227928f1805a4fabc63258b7b8936807e64261a5416cb6300b945fb64a8e57af10cfcdca82d8253260402fbf32b6c722c90980d4c86cbe99d9fb085ea5b44a008c121589e22d6b163af47364ff45a92f1a564fef1f734ccd65a87479dcb8ae2de891136c3a193e0b89163f98471ab6ca71826bd8d1b48a6c4ca3db9d088114753adff41e23dba9f29689e4d6a113060065230b9db7040ecbd2417071ef0c125dfbbf868a231161b4ee368531a5352cae55b50d953f3581737974c43dac70440f77d29c2a5fb240f734b933bb9f729cf5ae6fb4cf5b2dada5486223bbf96b81d93cb49aed39527eeb2387e27d049ed9dd416a8dfbbc25771aec178610663200537e1441b701db0fed5acb14db745a02afcaf5a7b89a5b1a83addf06e7943f98642bfd902d396c0ee88d18698e12513d0e9425474821022ecdc548386b33b505d66f9e68e30219aafacca51a94dd7a8c8266132ff09420c4c64db264e5fa3e3f859326cb38bd6cb76cac89654c432b54e7edce23b378fbdcbac83594359c8418ae48787d69f8ca041f0d1386dcf551e3dbb54227dd6e4839e5b1e72784585c3e4ac7f816d0f549cad265fa51ab4f6ef477d1fb3621dbe3fb9868d70ac810aa2f38f1eed3022084f657e94d543518b4844bfba8b3e1f8e71188292bf8be803ccaadac29b1e632d01efaaa91d40591d2556f11b2475a6fe158b41796863aa2ec78e1b46e6f154b84fda4fbffbd3b2aefef3c49c1481ddc5bbc3c8722f5abd69da54cebc5731051fa4c326d4519a8070810d79dc46d130270ac39995ec542994b897c9b164b19c652453ccae4dbf6929da53ec66f0bc1860bb6320c4dc2368507b30dc11afb77de884f5ceb71125ee3361b0147f819411d20be3fe2078ab3313e9c8584cdf69355d44c39237cd8a9099ea2de5034ec3c2d938b212217886af4b81394b99b0150de1b75bb9480fdeda43da89728a54113de363f12fd1fad4a5b6a1024b9d52d31c39c5ddc3f45eacab941df114b8d8f7fac6a5dc2921430a57a0b6d1b74899d44d052ff1774b352213fd33a529b3f46511b49442f815c0203683b9a3f01c8c7dcaab306c699a1202c04d9f0b1111ce2aa0fcf7988056133c3f91d45a9b0f742f36640a0db858e76ce11923a567da71c86f4c93a1fc915f074998252522a0c871c509dba084fe6f126a9ad2b39495d7fea6971ade81e770fc8b0332d67824de7c4329c134cb35b415e09cd156e3be2760eef0cdfa824b0f8bd7b73689a1d1672edeedc9fd4fd3814e3481ed1e5e09ca739b3c3247aa26a9893aa7bf0a441df1e9686e2816376b2e0a4c62824f97bd4b42b84f98eee4acbb9e084eaac91ace7fdca62c5417e6f870f2cbb93618bb2a4bae76cfe8a3397f1e1479f9a0557937d5c0cbaa4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
