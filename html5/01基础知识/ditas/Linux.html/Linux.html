<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e34736ca2571ccb26e3699536950566751fd679d29681733d42644c0f27fd8b21bc53cd062edced29aef2fe7a5143aa4110296c75090ed99b8d22380a2e7849c2b8e3b835385ee40a10d82d0def4b331092ba743ebb9126ae63df8ade4bbd36ff313604671e51fe2eead3094ccfb1d2bd86f0fa623c515070dc66b576a597e2d021d1281130a43656a8f2005cb31f519d643d070ee8f55cfbc1a4228fcbb8d663350e9bb7c26aa26246903141560d5a02b083f2a154bb120333b6866490bc580bdc98804538393f5fb81339fee2c185489f6cd48f7a416e6903e0f034a8e50a524e4ce22f888066a6d887d8d64094c293a4e1a03ade79c90b1abc820a16ad2ff2a0866379f8737d6e94c5f748cb3a95840adf4771d29de5bfdf87a68dc0de39c68b2861ed1d8233eabb5bf13249033d467bcc3ded581d24d8421c0935713f22480ce0166b3bf383ce8f90d91ba332b4ccc93dde127a1a419ddeb0b8d5815608b0c9460a25d9853683f4fa05d1395712bb3d4d124161c8701d5eaa332c8f25e3956324dd94697ad2dc9b5e4600816a192d731b004a3e1037d9ec4e280c395893d28361e88f20fb854edc53387b28501cf564781402a841cec290331b8e7d4701e9962553350191b783646153a3ccd210fd97eed9183ea8b769e0d5fe5566d1700322039136abb9168d5bd8463925f11fded458058079bfbb4e1278b6b916a7e9b8807dae10e765d7ebd475a0d3bb74455ea98fa2f3791e79263937b8b29c90846dc5b2174355eff5a8a64fbccccd1739ea2f36a8a0d5d1d22c47b2a274472a5d2fc836558c15b1256257fbc210c3ec90a07e8b7ce14674042beaa9f8c40fc6a3072f958e0dda0668f2a7b711298d93262dfe3df510d6e3a75f0983dbc4e5d33446c6927b86ade9e917a8d02fa099fa76862ec276fb32f133ee5978af225432a4eded53e7b8f56f0df266bb96125dbcbd4153072cc4e9879b35e5aff73cf83f29cfd9db7f38fc59e88246fbe0ca462c3c52842a4fdf47b85b6cf6c12c139a5108643b995d2d790a1d81d5a380ba519c8bf4ccce2474cedd0d7117270c34b36bba535681d810be75da015c92e2440913d6b4cd8ee08033c0f308f2d4718b88057648a863d4f5b7e51e39f47643241825a96ab0a2b46a21dc22b0d04cff549e18c9e06594e71730cdcdc7164299e319d000d4f35c2c04992fda104f19a7f9010241a30c65a335c0d11a0c673803dcd7bae40b1a771a3512936399aee14e5305fca5c031c4809eb16cef0996f12b0da404c315ad858797abf72d066cb31d49845bf3ac84fe8d77961998cf84dabc6dbc9e8d35322a359719414f32ab37c8e6940584fd86e106d92230f97c3acffad740974bc2bfa39249fb65d9def9621eedee5ed887e69d31e4ec34ed01f248af6d94251e11db0f43af0cf6fc44bdc2a2ef37182dc2d8c7ad43d38a771505e241a45a82453dd8524d84d302d861cc8aabfe20befc17c4f4f0201e28ef45f721b3e8204fa7ba44590def0fad7b45fd3e04d5d3d322750119a740647bdc9e6837d5c4fb20f8336220aeba6307dd3da6be3f44322ec4ae3ee01d8e506a36e88b3326a913ebcfbb37866054bb9356a4791435cf76a3076344d54f0af36f90826ea9ddacb623a246de98fe817e16aa7bad2ced5555222fa5867934185a5f547a0fcc115df42d3e11e1a927786dd1320068e3e28601b7f90b5f411bfdb2826c8ecf4f450c0ea734cb95d4b0f031457877cd1382960dd71ece855f7075a6de41b2da855bcf463c5a80a5ba00360fbd4f7ddf3c9fe1bb4d3ce21c1c311b9623acbf07b662ae225b91c3eff27ad42420e436734efced26308581b66d79a8ca901b360470ee926ba5dc32858edcdd4ff7fd3eb509f18603ade8e84bc77cd4ba4710897414eda06bb7c61c3b49d92d7ea5c62c867e0b3983b9f6cb9bd8bd41ec916d735fd76528202b5a15d80c6ca41c7060c451e454d47e8d81e9213b8be188f7f38f1ab9884c84847ee9180fbef4ae1a9e35e256140ac90c6311d8b9d3f658eefb6de9e979c9ad156e02cba18edf9be316b7349ceb13baf526d6f3f8cda99e8d620b7c6c770de51c30197762d7e7dbc4039abdddeb268c8aad84e1435b19b14aa6dfe3dcbd2de470ba3d591b8f31ea5e399ec79abe27e4f34e5cfb644fdc703b255cc0b7da647dab94bbfd6ee6fe852262de30303aa6373d6628e4f6d971e80231c293045b298610aa048617f471eace3aaf3c7b9a9d8f49031b0908cd5d93d0af885ac720db1d4ec6928d689956f621f4a2d5d221fe7adb92f1484c3c0fa4967a0dc83c6bdfb06782c8b17da978c121482ee1d4b5fc2154329a57c4468632fb2efed98bd47e5c1602fbd782727191c5e223e2b47404b5f14be4676dd7150029109cb78291d184e3cc37792f46ca471d6ddccc9b439638de4dd795d0e0d77a292f45ab46ead61826f83a9df607bc7d9c68d1264ea6ac7359dff2a187e3b602e97954a3e813346182ef0882d7b63bcdbe60b236fe50513633d02b385c3fdf5a7958dd916ac228b4d6000da86ee08fb668b2be5f145aee1359ee79f1356d68c4a784efc8423a971d705c1d45f6e86a2d387ab081c4e5c844d2f42644ebd95cb7d256a3628174d71e343bfaf54dbbfee1cab2dbf67b82acc07bd613c6e7ff5f71b738e6d39c90de4737084ddf106bb261c99f1c5046886e531f0546f78155b06bdd1564ff0c2f378c0814307a50e689914c66027b6aed6f6c77af58f3ee23912876ca050dd2966f5bac342723e3518b36e6f5d4587fc075f24cb4d7a71b701b8bf5acefeb295cb5f78eb95786fd4e480ade8c2f1d503d83858efc342afba89223a973af400a2264ec22fa43442f102f88247fdb07851d359d2b069dca5f7236a2e3b7e516b2e977b827d2950fda76288df44a33ce38ea1253d42726277661dffb7cd4bbb42c2631aca3f5b8e533222ea4a30759cabbffb663ff13121f9b0b6d257be5a012d2f64e6d590d8e0d2a5e5901e7439912c4fa4b94d2565e6ba25494ad2eee5709834bd02acc038ebcfd9a7f82143fd15f2738822b0933a893c4d380ff6d64e77acefe0a4bf76392e62df1b4b2f19f410f385b1ea6464c9323eb04077c56f752e45004618a28ae2b4b5bcbbdb13a4f5af61fa6db1f4b21499c7f8f784d15d35f293faa6f9500588f9a676b305f5e45dd7da3c3fe284c732a90b7c203cb0ba9a0440770024674e1e13bdbcafc38bc6066dc9ef5da3f3ebc2b5c0825fbba55d166bf2a0b147a0432dc745cc962761e70a7170844194e41fa88d17e8a436fbee749e50941b29a9a413013a323e3105fddf3a9083dcc96abec7f43647419159b60190835cd1767a760a5128117e1789a77772d979d083101390799f663956d74a2f208ad40d1c1ff65897a4db5e012f58c50d06322687b86e6bd9f5e2b1964e3c0c01bedeb1e2e86781447c770456419b480dce31395ec65b566aa899e8f72fa42a0c8f93d9e573b8a62932b74f6cb3150e2ac8d8f40e2263e3a34b1047c3120ab010a585fecf82273b5929d6ce1a8ba4c0df353a3193eb80497599a1791e15ced0a2fa318cf37f7d0bb93bd29f959bb7bd03fdc3d6edd1f0ee2c09826a6b2b0b59167458857fc1f005098095c852de2a26a5122b11950afc1f026129fb971be7108fb18b755d9f825e5789b1349fb17de040e49cdb42cbf6cc6dea5d85a107b746c22e56f307c42a25309ffb2e4d7af5a39f71f8395b98e1de30ba6efc4294b21b43501e6a9874cbea66b9bdaece381b7c0693cf1f0b46a98ba583da8b01047084ebf1e44ccf064ccd29bf47694be8aaedeb1c6e18ecaa94dd61d90ab18d1284a4e782e7668af2a016f5e740f0645b2807c93360bb7a8b3ef460c5c1f09c2f02ae1a374563b828852670e0120790b98f25342bbaedff13232b58fa60e977a17c5c54b69d1996a01f02093825c2cfc6849e05706b97f63cb6285b2da7bdd12a11754f723a65efe24939d609796aa1f09bdb1ae7040f2d232e17fb575e72a776ddfad6820003e0dabfb5dbf08f0f8369cf7de394f23f3d862c69dba5ed5dbc924dbe433bff68022e1ef2c91034ebe84a533f9823680c21778bfa1521de701443015539ab9241c8b7df2ad74cbbd6e68d9cb50e6e22e8e63e48d8ac5bf097b14b36fc06777ffc920fb74f3376c2650d701967d94753389af69849bb957b0d440ea317433ec8f902f467b3a985af780a1de66b3592a78ff5b4720d11475439548623d8e00a768cb09eaa4c58f5e251e0abf003d4f9bb80fee41f0e0aa6d5e82b2fb77360f88d33f88b69d364efc61c2788578edde7973b0b0d2a538fcc45e8508aabbf8af9b5c70673097a3d2f82571cc0327e0328a795e624c211b98bb380b843ba6f0390e52c3a772eb596fcb8a61342235b4b3efeef15e72fd4406a51ba972714d0c6d23ad6945139b040e023d080cb4615917939e63f2a8fbc4f9a7544aa63db1eaf1ec10347144653fc55ae0432522e6187a2bedeaa9d2becc0c7bc9daad64fa623ba9502f557c79bbca45cb082f4944446db6a71cfedadb7bf7399dfc381686d362e08ca2f62d0a2090d417339fe9fce4c7e428e903dc09220ba6991fadb62d1485e626803f62a08e8755c545936c275d530f20bfd9bf1e16df2e09db396491a7444fcde2f67b890472d1e08fdcd17553f2b9308e0062e090af4e0e8768834dc4e3fbc94f2195aa5ff55c09557c73c03faf9cab48af44899acba39f620933adab0c042fd06f40de03d2e40407f5172bc56cdc6de1384ec4e02d3849dd6be1ced99dc1f842df7ccb9710e8bf9eb20de37d482db7b6527b27c711f2dadcd0daf95f691f793d727a38dc7a99e2620720f8508d9c8cf3d1de7d7fd2a2fc3e05234da0e7387c09352e5cefba62b7c0ef87d5eddc3e0a176505d14f650e329c9c30e870c8bbd1cd4685611ff8fcbc45784625e951c174570b664137eb4518515769829faf928ae1af37ecda20daca26f49defba9e611df817550a30a1129fdb1157cdc092792614c3b4c2d94a9bf7b5666e09db142f02c17016dc5c7caa28d9529612b30507907166bc9a2b57bcd22d7e8b78a63020597baf3a5d0b62f844a8f9bf41c2036a6fd0e387bf3e516bd1e2be3fad0546513a1b0b6b56806be238ca5d7d2134296b6d0330598375ca392b4df4cfb87920ec28c20a9c6459b1f84aa2380116a838e03b46deb1eb7fda1257e20cc817a147e88357ed7dccedcfffd423cb7d9eb8b1ed3bfae5633f748cdf16f0466407ae394ccdb2168b784f2ec65deec3a9abb98af900f7fc0040604451cdf7f0b2a50605bffbd1671e09b69629f8090933236a6827cb64a55d928aa0d59b2547b88729892c056b431328fcf1e10082096e0e4af356d5f83e7c749f2a78b1bed8770203f6b89aba834a020956c52ee196e436dc50171b0966c1a55cd9cfc1442cb4c0c38dd09893482a37712aafb1d7b9d14de4820cde9cbb72f46165bdb2d1589a9ebb3a1792fef353c4e620ec52af7b10911127dcd1f61f6c7074017884ddc2b44b538974c5b72943f8c4f3fe67dce96b21ba7d587137f638dc6210e75d8e0295ab999b05728dc70190afccdb896094ba754b9976178cc846184aebbc0e8e491c37fc921dc7dcb90f35264c7f3f350411b940a8d981ed4abba572c38b2a7bf5ded637081049b426024c3178de3ad30bb70df1882c8ffdc4fb83afd6698d9c1fcf69f9e1595baec4c5b1adee0d4709d04827f456443df8da60694a324dcf04ff7d18d1a4f0a6c84f3436b41fd1e040fd0be2e84443fa6229c7579ded855f9e9807c37eb38967c4a3e13a995e3a69cd7b4abeef2cbe2d1812e8d826dc559f53e7ca4d7759db945ffba296f830271a174e07c7ba5199e1bcb7cf7f93cf42bd8db74b9e3d58b544162bac4bf7589f4af70282cb0573d964debdcb07cb198f8243ebd713d9bee21b2201b213b74054b40882782ac9174069c10007d9a050a52e71a7a3bf9ae205f7b82156b5891d6ef66b177fb8fcdc479771f934f9afa4e815c3133d35d906e813c5043d38a161cc3b7426fa7760ce244ff1730ad70db89e4756ad40a0ade7d140284e555fb2dd6815fe184c0f108e8665e3f3f0b0ffad20d6d34572346061378174847d591904745f1b32513390034d2a82fd87622ed7a06878c40af3fe5c8d435f44ceb88878f18629b3523a5fb2ac9c912262fa4fc39394304a7ebb4db221a6900d172cdb5e858eba0eaa0f8a7bfc142bef575427847fd3d1b91495a30044122b53518efc794497020392c2d0918441dfdef9f3adf515f733b94b7e8581f79afff69cd77386e79c731bd07e73bb0a7f1bdb2fca7be7a8630aa0854425a212fd0efc320f98b3356ed0b25f9f35dcf0508b3069ea057a74fdcdae053a933087829f01a5f20921e437ea95aa9ae7fd1b4c30edc95946ac7f3e2c38280546ad2545ef1ff8c9d913d3d7996d32be036dd006df02be410bccf709df1035fdc80929830c81c9cbc121fa711f871e54a4edad1abac4786de65733b4b9963ee13c14b883c47cf71c1b81c1d63ccd5fe2cafe1f8537e955c73f0175baa660b4672cfc2a9b9bb7097e45abc22e3207edb82d268fda96c52e0180b4a931cb527370bf6b02089011830bb3aaf5a0dea726f7e590a5468fd5b537b37f2c4c75dbe2d49262c8eab9abe05de8838cb4e6ff573c4fc5fa8bc05303542613ce3662e849109cc005e9535e4db55a662063f588fb269cfa675ad592123ad9bd7f7d9896f8ec67f939ac4fa8e3b10bb1bea6e931a05d26d28d82dfb59065f3be153815b9657fd98aa013557edb553e803a2981fb043ef6c532654a4dbf21f91eda5cd92c805f84260e4e6bc75aacde47930318a9949db6aff4edb6e5f6553cd4c7df9ed9bf2673b903fca232565920051b95043cbd51f041882ce5481ddaff39f3da5d23bd10c16468c2898efd03563fb48f6f8d8cea6cb8fb729922ee59d618c77a8203f8cf60fcd4ff59c1bc00e7d7cd86d84091d697bf7a8cab54186655709e7201bdda22cb08a2737d6bccd6a1e2e3325becf8e3057611e2fda6f0de6dd78b88823e54ad16f7377f3302c7bdbddfe5f61186fddcd7aeef4b699f5364b642be28d55399e32b67c179b6c80753e23b6188f1d5ad76962a2c59d22f5ff109744d3120700beba303540bd677fcd516a7e3500281fcc403f9794e9f7cf23e90b65aaa761c324cde22ff2028ab5cdfab625058ba902c176c81bc3b1cf3efc3f53ca0e01884cd423bd12a8ca53d7dfff2124f97ae6f8ba612e6d729ed5071bfdef75cdb8453a95deb168e762d4952ac877eccbff0bf38ab744dec54f4282873e4e2287699b7c2977c187404abe92c27891bd0c44e67f0242662b22ca64985b22106ce5753b1f74a40068f93fa4fb1286207b58419353bdc9e07d4917f7e266c7eb6f90d70e5277c66510a72ae64497d3aa13c5304aa30070e3d3a6417d94987d184e053781f1619c55bc38033f40580fd2326c52076542d38949ee0e841ec5f59e844810fd5cdb8476321e6f5680511175ea4b2683da0e6fbe4d943c763952d09e1787caf68ffc891ddf87e7d20cc66531a6793b4ab848511a086ff9da440be78a6ffdf747c7e0dd0c5bd1d7bdd35e4921f64ff8bf42c18e836595b6d79597bc2dd8c63d7f7578baa43bf9a0e51c7a24378d588259c5b1efd97b85322dc85b00e78ca4ca945a1d7ca99ba9f0aeda91ff322fc77b0eab569711edc06ec153e46edc2c5ec6bbb7f829c68be3427ddeeae5baca81589d261b843d5a5b44e556ca97548da16be593b333699bce024d3ecdce552e31374a39af0e34d4d848461f851f7b9e551dac5caf82a6df65c53c0d95351e99368d1549bb0abe2abf9628f8d8265bf9f8b21a5607dfafd9818bcb1c723bf894a06dc74aade93ea04412740c560dd6eb91a13591f93a5581460dd32ee8c9c410137175b84b43de626b007a7f7650d350adc59f22e1dec7831b36da4d77cf488dbcdcecbf6319fcdb6ba1ffb9c948b40d3d806d4c1df79922eee2b22cea6f9cc841841bdcd2fda3461c377a50fb931c9a34cb3b052c789491ee356733e9dd716f993ab69d0a7221941770ffe1727d28c3e05fcf90273d47f4da609f74747cda6bda11c2380025a417750c98018a30dbe74240036ef93e7e927dcd324d3206978c8b8892394916c396f83f50095c9b18fc048f46c86f1d7e349b0c96f0d03083dfb260cf8bda535b13aefc7a04aacd4cbf2e36ffaa8594d92590f3e4a5d54eee40254d7cbf192b1a146effe37b41b6704a8128b5e90d6c3144bf4b451e8a21c0967e9d4fc76f7273a3f6af981503727a664ae07b6ce0e5bfbf912325e403eb8312ef172211046615dc1bb773a04e152b605fe53ffb91bed5487330cf8f490be859cc49aaa3cd77b7ce66bb3e0354abe83c402385a18d661b0ef4a8ddb8ffc81762258c4da3944fedae05bb8638c7e78f714d81c12d3c4f36497eddb9a9a47862b6fda37a231b91873cc79420c7de323e84ec66a749ac37a93180b435211563d761faca81285515b15a2bec9506d06c07bcc4ef6ee0b3b38413982a129e2048737f4fd47549b94f3fb1358af6dc8e07c918c9e525eecf7c38f2563b3a0007e6295165e4f4fb68b0b37fe5fe202b4cd820999650c7b62f84aeec63be63bc0c2280b676a9031ae58ebc30116f7d9128d3490cca6b78053f513c8f39048091dec42c9f7decb24b39d14d306e8b6ef7181cabf8e68e701d91d104df2a4579bf85ce3db0b6981eece26a2b5b645936b5ecde265c93dd866cce73e647c2467c8531c60704e6947acbc6d001c6a502d6f9a773ce32d8766dc888b2131a75c1036bf118d6da6ee13974c0b449c648d228b9b751233c36baf72534a3058217c907e45224a1f3b24e0c54962730018325cc7acf2f3de1c6a21004125f54effbd73bf76875c1c8c57f1f9f2d4b4e4e0481edc1050bff01c85ae97ab5e719d135393c6ab09e58ec096a88d104390020181efc6f14e475a1fe5e81df2a1650c227e45bebb8259969457aff16214f8baeed32081ad5b972469e04e7dd3676c01b0d78f279380817d22be638a2e92ba3b64d59fae6773bb14090a91966dd686842f78ba7720f92004481225c768baf9cb378d96dc21cb316b4cdb84e0ea6b36898c41af561e8bbdebfd65c3dc2c4c45f0c82fcd6affc6a2660b06f1a09e4d4bede43dc7b9c5426791c8adf7f9c4025ab47008b3e140c75ea00dc850fb8f96cb6e85fddec5e53f396af7d9a7e700e5ee2666ac52bff4792c82228e484ab1b96cd7ec711229097c9dcba19491115f236dbd8cc90d16d4b17031a198202a5db59c64c7ec2deaead13d52662517e585df8e514db0cbab119509e32f1fb44b83113fee096fc866c747ace3f6c3b2b58bd4036fe48df0f4f48f0e7b5b697f1fb85d8b7620b31fb71c51c6e3090852acddfc0d47db9ce4368d3d4afd6aa3c8d215b82579a801be509c9d938dd0a99c61a8657e3a3570574dae22163febe546098b4f5c3fc87abdc79bf846c4790f6cd7c55e6e4c5181a0bb0202d707f399209f143ec70a1ec1fa1f50de50dc4bd5c1ee19b358e7966677e3f41653df74b9de7179a970b9528b6c0cdd67005c1e404bb40fc2a64e2e1a782d6c4cf46d72c5c8405bf0b817e5354dbb702269a3cea08da1b85a598949ee48709d5a84a811a31e9ccce8004a7ddceaa4673ba46b464e85b0a30863bc78e2e25106dc329a21bb9286e7bb2363e8bbd72c942b15589f616a1e2c1084a6a6f6d5600908c0fb30320e6990cefc0e5d4a6151f69b8490c8f2ff6a747918c3bd6a5319894d502fc4cd9d61cede9e7ad00e1a62caa10851d44a1cbe7a60d64bd899d312b24536bf6143ed72aa9e52b81843903a7680601dfd7e8527ff8eca08a82be47e8043b5383e4732e0804ace214ba2d6289faa1fa52355bf82398b7d230a6fbc2a056e3894b122ecd83c0e027fc6890aa14b493147680036d7ae28d170f726154491e5701a64679ff85d52454a8a8fd77535a1c37fe32c8ce2b945a9e73a1e507a84550ec95767fb2a6dba76d35d7aa1a6b3fefbc402de22350c600af6dde27af725e2154525a52ce6b1ad0656895180068ac6f6d3102c993066bedb3cb1499981fa974d8b442a2463bad1d28279de4815004d5a064e02c49dca61ed51db25debcb5ec59a851abef16c101f6ac4062ef18a11d5f347466200043887818be0d436b46cccd4fe522b0209d61be0468e9599ca1ac2dc76c84f7b3592601310a6205f27a5d3c5a38dacd2445b82c3b6df830b48e0775b148b6dcd1ad8c1b45633b6a3e06f95913a8cde83a0efdf0cee0d530268c4cb7c4bf61030c15524e1d6f6bffd28cbc7c00260b189b8212a223525d9017c81b8d9c812e78762251a667204201ec778bc6ee91d2cafdd8dc83b8d1a797bb4f3e7816f58e93d2d5fe8db1b02070a0320d0593b94a5780de7c53aa5a67d52413212e6953d947d6c1161f0692bec8b231b835c99988e737963eea47caf17bd8e3c06b3a8d00d7872c687ac9647dd040a7a022678ac44c55ac468268e5ac2ecd3e1cebabedfff4e72d4b9d6161a49d2d61e437b2a478b9e25f1abde10be0d260e70c8b5bb333ea88b81a99fd312bb1489a4ba85462c2e1c2049e5b31a72970936db1c23fe21881839deb2fedaf6417137e394a8ffc06911b410e5ba7e2e36b2b5a014ccf9724792873af39afa9ee900ab8ed9f73a52b1d6d6169beda9f06a30233c6e52107029e91c14bd0f8dc07b303ca01bb2719deedeafbc5ace496a518da35369ea179ffe01b300fecc3700e1edfe145360d0cdfecd6f963993b16374b81ea94103dc31d959854e5998583ee6ab150aacc6002c8350a03f9d49d22a261f995600b1474fec09c524d3cca6abfa819fb6f59ef43d0df9f4f7ad6544b1183f592fcf9ec19429958b18794dbf6029071d768e9e65f88141cc9488af00a48d1e78094c198f8ad4c4f6614082f394003f1a81a1c22a717ba2fdf3217d736ff79743996a19892bdfb77e94a38f3c631110efdf23ce1fecc00fe3e7f923d45b42a308964c07c89280a372dacc118de980a27c28afb0daf923e8629ad844bed9a33332a811f7ac6c75080a91cac6f5835328cf6660a4b612b20ce2dda8ea98429194ccb1ab1269b1f2e38f117256be012a77238c057b665e709362bee7ab80271dd833ec1aa91c9c0748b6f834dd640186f2c6b554a78cd4f273f4c2a7c533fb2f48a7f27270c25654ed94162017286c71f4c67143f2d3376294ad6377320f09f645976f70348047f317977c6fbde4bf79cdac1a5987b809cff72ff82aae290dc4fc379b6da2947cfebc9da1d97222d0a4713ab57af98e00789a00dae3f0452c660cd720b5ccff95e49cf775567fc6434e14f1f73413ca9795db92faf38d5e775b380010a171576256bc28340921546b6bd9e8413e376d02c014d55053e1a1038cebf7debfa205c8462917db1fa978b86b893129093e618a3170c51e2ae2bb0775c467a5a3849bc65e0ad59d7f6fc2dcb093776cccd80c59047c0b77bc57d86fd27858ea8a354f2b930b4b4fa8aebdb4ce7058589f23cbc26ecbab1f89656c083ec974c60038aff860583c27f8ac8e1911fce2cd10e18eb35172234c91a0c7733725164b6035966d7978f99e6ae7f11835b22bccf26bac84fce7f5466fad9922cbe6edd26912f993b8c15b173efa770aa4cc07fd44d28409eeaa3637dbebed7c05a74a83c244eb270f2e97c8001a534ea76da7d91a70e038f8ef877b8309061d9d46c63c20560d8d2f2d59eb40fca2e828ceb6d5c3c6c5f3fb5a0c004865649c3485c0a010471b8f180a3bd72f2ce2497dc944062b3a0032072049ae6882e0e07ed87cc0a08e721cca452db74bac7a4dbc055591e16c66026ef8e7fb221cd9b5094a96cf33eb8008016f0e4aebb087ae22e6330b7b4e42a09a85763fe6fc6262bf25ba1880659a7434c5a7933242e84c21fde806ca4894c1712ad139a996c83d351886c1e9e450fdefa56e8a3c501c157d46426037bab54bab24b7ccabe0f17d646fa5e3482d3a80177c2a90f87ba552c84de907e6def79e6da4b7e5061aa174327418a42eea8a8269b4e512fe7beb03dc7bbd23105f0a9b93719c14d3381023389fec03e83bd949569f6779b8daf80a2cdd29d1cb73653e4d7068483ce26577c3e1464314c3443984cbbf8a4c4186b4845365b04a63b9ad341c9041f7ef797c8254f2eea3e655e5ed66417568ed8528dc65c491e9f5a61374652023643af4a9c22f67c0969d80ec7fe11916eb967be941cbb5f90ac54cfab29ae64cfa676990c2b483724060d957ccc5f5830007b70e3f79ad5630d447a98388f765c2af090cd5c751ced33dcfe83d13cfafef2f72aa10979c307481d59fdb944c0f2196f4e3145c2b58b4e4ad2574e41c3141d9f5686eaf6a4526340f931e8b2564926654ee76e7fde57e38658b4ec1a30b2617fb9aafe6b0ff47fd7cdc6caca262de606e49aab7055fc2a5a0e040136af8fbc018c88cae353deb142c6e27586ee8f9bf4de7152b60131f16dd961fa1a5a1cd0724bdb48ed79879cae519fabfc1d85401d97888daed19b9b5e8fe113e6bd79251b9f927637583c7bb0425859d87262153612a9c2dfd3da322ae57da4a7880fc5a91f123636605e225925fce7383166196065a021c11ee98878ea3f2304e2a15c90be710a307cd530da391e2edcce30bf40082b42dd3ba270769a451a238fb6a74217bc3b7e187053cfc00ec10d226894020faceb350a01d2d5dd5740003d65e0ab1f711ba90c72e61395836e7293bbfcd1dcac03d70a4824ea1939e6e2ec2a05ad69d537913f9651febd9c56e6b6d3f5656afa37dd9de3f95612b259e985a9a6a5f461c654d5d5c5bb35597cb6630fd84c12bf967d274989dc81e91438a934ad250da7b775712f3db7e4b609594ccc7c4f984148e6f9a66c9456962887d4b23d99c9cc817ea27898946af1c768e288f222bb899a0c0ce401aabade2be3661c3cee13f48d0d1ca61d9a1bf8d793ef7a0d93f96b6d08d502b785c2e7811db2a46f4c2d60b7510ee60cf6823a2692520a864e705092f3fd08d6f10ade0a22e87e52a76c2e698616b4674f2b86e4436d361ba052cee120404bb450fff8a3df69543d12adf0874313995065782181169752946d0d99c8248def559739cfee916ad5d197a507a849ba1726d98909666dd5cbd125732f36906380cb3cde1f335cc4d086a4b98edd7c6a31ce09b10a567c6c4dd4f57bd4209a51778551a6cd2792c667c4982bfdb59bd5b02f1e554685d0ad0c0234853a6d8c502d1619e9731832fccc139582029d455706bbd7100314b25b4e926ae3025ef964184df6874ef371e39437d214ec462a0559006e383177ea0775f57421a72bd0f3d5f561ebeb9b49d4f8a3efda321755f08852ce09e06487ee675579ae93dd9d91d18bc5d3673beacefe300ab6e8f482a6b18f8e1a8b2e854b3667a58a37ebdd641601551078fa857e90a1f6f4c7321a4846b25a7382e5ab2e98581117df168f691f42c6540b9fe7b48ef9c7fddadf4450d289acc4085d1dc7fd2205e3bebfb2f91b88455dc913a61e74a1028c56900a040e03f552bf6e825bf69b93b9a861bdcdb38b7670322bed6ef8361b30fb05bdfe5b3ac7afc6cb1f1f315cd99acf1908831c28e5e00fb2da05eee95625d38ad36139f13f41532befc1d53ce4fac7442d06fc48ef696e0ebb005090cf7e12f05ca272f39699fcb3e80b73c4d0f01684690901a81275bb6392c78356506d184dfe5d3d53e6cdfeef62c64b50831ad194831ed46352df7890498e7a4e25bca8385c9c0a9b43eb596f7a84f214397850cf1a4cd878f0f6700cf7e1920e3de24ea36318674793feb2b6a622eeab88c90d5b7ef6ca44c04a5e2e803fb1512eb94f21b33ad09751e80000cadfe31819dcc7dadd25a199698e42709b2407df64f499efe03951296402b64a8b20e2f539036066c0360a2a78be37506ed71591c7b789bd25da863f07b291ee59b11e539488c446452cf25162d7b2ac7967398aa67c28ea0be6ab7a1d0036b838347f8fc61054187563e5ebc772574eac83e569ab3ae730b154ba6f2e4b8821f7b2f9c307203c563a8c41258a56847e28b3987f5555bb15d2989cb063fef9c17e2b39b731d6e3268dd564728dcca162c3710323482b11f8686d35b3ff3a7a986d890e7bad7e9deb9e0714c5096f80422883c3262708d6b524dbe35c1cf9c309a9399fc6105cdcb9100fca9a801afcb470119ac67a61a62324d6e6e551a5ce568592d7067860c77ef2defa50f6773aad6e3b7fb17dea4b3cfccf152e7a498292e88bb0cbc22aaab583f3f24383986bcfd7f4e1d3b8fbe61b22b15dd6e8de718cb759029e0301b5afe59836a360d6acbfcbdfd517ccb6d95a778b51925ac7a49c8bb1caf3a99d07efc9f2e014bda2172d95c9694933575bf043805e9961eafdff9a8bb8f4a21db140d68fcb67e4cc9d1f83319dcacdf42fb093f44995aa9ff705c0d78e71dfd2a48f3c6f55f754e8e9051e6f91e55cc3d7f50b766494f65508dcb9597d7e8cf9435927be8ad95cf33dd6a84ba3b24282d1168a1e416a52e670818543eed5ac1c7c7e105e8939d2000d505c418fd703bbb535d0c1f443cf793d78b5e35cc0465930d75ada4d66c08e0e1f77d488cf3ff4544c0f5a16e7f72bacd68a343ab8a5c3c53964fc99fa134a5597da15f0cdf500cfa965b632978fba28dfcc61763ba2d8a251259e2462be7d91385e38f66e79713487e54ca3ff4bb9f10fde2eb0ce8a1a58ecb1c16e71cbda18244e6a17c54cc0a35eaeba1b3ba07babce2c128175020541ce1bfd89df7513c5ce3ec6ad560b697df7e5bb9aee6becdfd3e7b863c0197689711817032a15550b38379dad242142db193d8ff9ee89840d6bef021046775dd6c3bde7cea40daac79c13194428c4a49b6ca1a4b658d165aea3a8cab8a51242ab1dc31270c3958c52e5c26d272ee8f87a599c50c8a87e8f6272b719a33177c6891fbb6494951eb2076d15077e3f3a73cbd074efc218e71e926a6972ad2f37348e00ebf34a809f868df534564785a8cf360b45347d7e7d4432275fb44cf3d78a5c7d171b8f4f1e72ed73bf6fc6aa537657a12aa9c4d2962f523326e0e43a9612df1fd9b9df387eec4abe8ec34a7d777f74b1141363523491f88b4b5eb6da816cd48a8bec7c2ecef52dc94e54fe500098e6ee97c977d647c6d8f49b724397fbae5ad08561b696ab82bbd0257e758dc2f468247e424b60a7ded170e9e35abb6c40c16042e6e3a033a92fe2abdd0cb07aee2ef23989c4f637fc2dad651903470b9a9791ba9500d5e73705e045c50a04c2dbf618d2b604c204db7f93a0f078e234ca60b0e6064bbc935eb3d5efaa900cb66d7f8a7fc00181077f587a7dddd1825fef298641e218bb3c3e7adb97a2f3b1baa568232e009e781032960f0431d3167f1fc193e8a4070a3af4e1b33a56a536ac2231a85644377fd056ac1758f14d23b4694ef0f39689519ae3e30e38fd6bd76efa7478a62b270bf5264f30694b49217aea199029d7c82cf9da3ad9bedcfea652f099f1f838ae5e971edcdba7b13d61470d3348df2372779cde6859deafdcbb429712947ae6da926423cfbc122e270f76e321dc54e6d8c0faae3ce6a9f1dc09eb6b6dfbf51cbc6ba988bb2ad75b085676512f0c93d0bfbda0790897f3e8cb3d128939577af3546b1c39a853839dc9b2f610fb282d555bd3ea56df64b751f9915e705a64428e5d4d6da4d662a0dfa44c40cfe926e7c218453800afc34c2e76836b4bc5ba4ecdc8630c1c4547d04869cdfd6bec4f16c04d4ccf729c4b63d418ac0844dbfaf22edf29eaae9f53956ae18ef3f2efbc751e1c1313bb7d4884886a8e040881349d8b4fe16336eee33a18868d2484c552e59c752c82de8375f8f12fff6b1552cf3cf6c1894dcdbf3f0492e46a79e72136e1992a14ad503ebe542a4158fac0030c3e09e68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
