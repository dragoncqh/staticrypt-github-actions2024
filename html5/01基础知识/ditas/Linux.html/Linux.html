<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff6a462a0c784082194a55133c5fc1c0b58fff39951ef9dd895a9919e64a3f3051534b4858a3c4d997153a640acde375279e923826ba5f3dd1360011eab19fcbf376537c52eeb5f06d300c7a31ad32cae4b0867bb92a41ebe675249315693b213d8974605b35dd4d1cfb12a8a2b7ec64e50aeb545e86d80fed743c25cba4b91e9f8d6538d0323586eebda00bcd4efb2e67785918b91840421c5f081780aed339823d2982a7f40b530d028cd3edd9012a0241904400d00d8b696f9d768a82d077a866041fc47334a24a24f4d9c56e9ff2c148310240d18a9add8e15dedc0a08619c7e7beb73b9f2956b52d1903c5c7d0d1f974b3892f8902040e6a8edf3ebe92e13d81791d188391c2547ef9d40e4cd4cf9b13819d8a84b984e5e44e73218bd55df2d7d6bbbbaa8d68e8cca225f98e9aec4fb3c9f50f31ea572cd601fa2b68ac38e4605d785743173111cbb6bbf8343dcebd989c01fac46f543d6c61e7acf11e2fccb92babd5ed94e9c01501ef85e620057ba6513eb8fae8c55715f4b268b20732fa4a571258ff1cc16b911f73d2b6e12683fb25957d17a13c77e507e57879536a69e0d37a946f04ec1ef2a775ec4cf50b675d24cce9bab044092959bfe95bb03566ecd5ad2ece161aa3b32f64132d4ef0519eed688b64945fdeb76ed2df8dcf423be62320950742a94f3cdc3fcd2de020fedad8691b6257e92808215c9812abbb23d9c310b790da0fc693ece16907f5189c4d6e65ea04a08db2477ca2b206e037e65ef0551b8647c03cad046f41e67935eecc9b0c98605cb9aae1a8e6af3a663232f12ef1cc256c59480dd2e1949bea6273a0f646fe8afb6cd39fd6123e5739725d6211e6c4982ee2ebb30929f1676b10969cd6b9611c0f86bbec5c6a5b3b6cf857e289e6b4facf75752ae34698d664d6559e793f74a1189020a169fddf13c6a5cda1a689716702e4bbb27ecd3b82ed7b69dbdb1be07abad6896b89a47b5e6943533e7064d58b1714e6852b316650b7feeb1048bef12f93c29f74e24c3921230aba05a694d3a4fa996a09db58fef7d3d166d7d041870fd919fd25e6e9578bd7f0548c67a8f51d340af816c109758e8958a31573fcc69233aae55e19190c36d4fdc0f708be8e0ecf56e42d8c5606cee966aa2ee8f37ac51c742c745d6d149b31b750a0ddb26bf865111abde5948a1d3502a8efdadcb7c3f4a8a0ab018d1f81f9fbbb3daacb019aa2ac2f78e37d0b8b2f6223c38fcbaf3f71ace1e61b35287346bc6cbedef035e72d05062c0a48fda4b66273799e10c2a81bf7b8e64a68face949ceb5005b7ecdbeced7a94bb7d14a70e532d438a1fb90488e9a9461722c4e435dc519041e3fc9a5ae21ed95eb093866e792fc06f5653af20c4ae46c1a7cb3a87752d7acc7fcafe167c9abe70834ed97bfe11e8c349a407d1df09b23355a39180102658dff7c07968b7ae0f76029d33fc783e4417d4e42063d0eebf9e42420f1ccbb01bd55e1c586e3f21f86653ed941e7df56430b22ce555e6f325ea8f8b13abfba07e9303c5a226221d8f528ac6b5fe0995404e2bc6c064f44acb45968949de1550abf83c41de5db33fe661571312a16851fa0f5516a7a36356c6793f3db57d0c6799c6b99a0e36ee3f7c8996bca9346a77ed7d39b328ecf244f2ebe399e2b41b70cd8a7d93cdbf2d4fdfd54e12e1c16254ac6ca2a572e100820ca920f63dc3e6a29c24ab8ab4466b4dc15ea03102ecb8bad8c07c5fcac53c06c0f84f1aa72aa25c41aa6ff179958d2e11c34e56a7b78b46ee425a3cc4da056f6c3a93325b389510c026aa56774d9b8981c0c5f9f263ad15643408dcc52d1829cf898bf1dfc23a492abf043994748848b3c762a77728064a348ca50eb2f334b4e3b46f6f315a58b77e7986182689700a48ff104a90940d3a3293fee9ab49e128349931798ed6617c0e9c9b6f369160de26691be622a7fee57443789d33521ba3558830ff797cde7bb89af0bb0a6d26bd63877a80f8a7ab5fa2df9e207deda57f8a7daa32084734d2539edd6e1289eef0e2ee7d73770b618164cc6d05abb93a66f075a9ada7b0abd3d18f93de8e2761962f0100c1d9e625b80bce55a6e6e447b49bf74026dac1d3e5a4fac25a8ec7b362fdef4106db2756b38272dec49c28ce7ce83a4e26fb41d4877287ee036e007ebb4a9026b341552ab0ffcbdf65a2ff4152f47b127e115119c5e8f9477a199c7eb86ce02cef2eacbeebeece6f41fae70347a46130a38d913e30689faeaf911641b43cbf860e7f890bd9e8eff9c506306b186ec6c8d2b1848d986d310cedd2f42feb6d523de64e7c86c01b1895dbedad0392a94d36350267799cbf2b2b824d251b9739fa830b5edc7726652b697ae7bc35d0fb611328e663c0d3a077dafd5c4e294cce3276fa301b829f13491452a7425139bc2d9a3c081c53a5c27a4c50747065f30a5861f6f6952fa7f59c3bc4a8c24d2ae739a25ae197a1fd716b39e5d14d7b5c729540fd387bbc646a72f7f2c751bdea62f073b7c563f57e98b331068d0f7fb461aa7296663449e0176b821f1c434fabec3b056a2e911cbb066621008f1189e2048c1e9b6f85b55505ffefe37094d1a923f01e687f574248e722b164efff65a3705fbcfca2c113acccaf9ffa23092789fa1822df7bc09dd4ace8aeee1e972822fbb5b3a1c91807b5cda3febdc7a9864512b8169793393af529f1d7eb254312d7d8c3d39504565b9de957207481747eb5012963b2cad02f812a730a21667699d12fa78dd807db234ed47448bf898810a0e4ffd1eae2130fe902a878f7727e1a10a02a9774137f37451a048847f3be067493959d592fa73c237b00f33d9a8d1d40d4a5202dbd95a8e330aaf3b17a0d567231ea2dae6f6496c4015a78e696a9e90e0b82604ccba0124d25935a7700eff0e6a4272a3890a998a88bff66e8988f89875bf3cc28e13f867b4c2af3e8f6c6bc8b5fc16923aa379dc5c084784e2ddef870344736ac21b50cd3d666a3dc70667e27f71e341e89cc5a6b1c2df33df13b086b83df171e854a16ec5d3e24e907f755e6cb0519d004778c6eebfe2b6d0ff5cdfbca05b980024dea503938af615a87fd8f1ba87097bb38ef1dd5fba84d83201cbe346bdfc9ab6c4da1750675f89b938584153c36e4fcdc5768fafb8d2e7a547d6de25f0a13753b2e75273898b9ea332636e944eb09674973cde79cd3705bb473932dd875bbaf38897341be4e2ba9f2143cd2644a9b282573aa36aefe7d6d032ed99d722d5d0ba07b1820dacbe02fd124c783c95f55cd2521c247bec2f93854a2f318925f63ed427b09b8a0e67f3f5584cdbf26dfe138279158ec0aa3464808b90bcfe0284f65adc92378732f0940df1447a9f43ea65378a66efd7fd78a7eb891699f21ab5233526b214ddffd9172dde7b3fdce270097977c436bab3936c6ed8067ccd1f6a4a26b2329bf66f9b8b6c7ce5cdac334cea35ef14fc408e5bb93c5ae8e39f1ff503cce3cf2a33590f751a518e0e6d21869046af35b575d2102130a773fa6d12e6b169c70fc83fe8d943ada49b28608e96914de364d729178a5f89042f17ae22559120b3b9cbeb82d3595076717509a83ed0b8fe0df68d37101aab2bc91c18d21e58b29cde9a85d46596746a9b494e3ae772a07886d3c3b3817dd2d4acae2d7c0140cab56f98f685250a1f9c44988db5c856250940dca0ca99d4d679947957abc19c82af991c974e2b6a41f67475af3f21ea54c62eae1683aa2fde3985a96c7f8e1b166fc67efbc5450ce80432007e9c10a5f9cc6e0803335573f3e95840fd99d73e9f5863f2a1279a51b317a4d94a5cad78ffdce0560aae63709643936165b1999ba16f3f0cfed6b15f49001f28cc077b94b693cfcb37c426ce9ee0886adff4704f8399d23d6c17d688f3c8078949c346a9afcb28eb23d9dd70aa274d09d154e0fd0e26e3ed26c25e13fe994499aeed36966778ff7303bab7081360ca223031f584908aea8fafe0f8592f7fe329589f07a2caaea0ba19d677f0a00b1eb134a8b9ae7a932d926908f6bc103e2df25113b902d980ae43377d9fa8ea55d93197d68357a091fecbb770d0c60ddd4975b5e196e464a44a9e2e161f33ace8d4dd8ad11b8ac4d9938433f16929fb44b0096595c37db44ef8e0895f5c51ba6046318b82fd8d0ba1d3c5c7cb65c8317e08068a9a56aa3f4a52ed8f4ac0f7e5aedb9851f7d094c2bcc1b91bf0e3ecf45e7c98d4f4b0c128f5be2c6bc07ad5252dd87013cb4a81d20ef399e5ec20321ef3f80409e2573304002df88d243a717c1955c3ce373df3d0b438b1c35e174070799e4fcb7d51e6bda8f2c8cd8ebb9f708c068b15f7663fb2a8810b3320c242a26595b83fd5e82b4e173c4b0706749dc39304c44433726b4fc74d3101e18736797c623833846b612f74b7038b3ae5b5507d8daeafd2771820e1bbf23973690c1e7917c710f62aa4290cc159ce9092a3e3c2906e576940e602c90d5110fb27d4bfe742be950a1c0d70e6ce0ca5f584182b7042a98d40b5caf5d7d08678a3423610aba4eb405e56cdeada72328ffce7728564cda0b06a814627de18ad0b809d1ce00ae8278c0ded18eb8c7baf2d169560ad6cb1bd3d4c3ca03c1141a115184c0d0cabc2283e05dc0fcd8792dd5aab5ec92c5dcb1467fa7fe874471c23ada33a3223898e149f3d6ada3ff3d3be5ae6d922c8dc5bc5c304e147394d048dd484f5e17f5541e7000b07fa7a0e8ba0d7f593be225355866c05f3f7a0b7b027cbacfabd57fa5873b2139c6e1d0c267eac77133c07434ee881b5d9c67e999dfd9c669ca16d1315979c9fe00921148ba06f591430c3a096ac26671b2b8fe30d22a5f46bbeb0a4c12d4d6542b8d91d0c32c971c2706767e480fa88cb3761f798058c3bbd8f5afb165544928b0ea994e69c15034ce6cf1cd7348e6e48b48e9c30a116e0b57c0ddd63f06aa63e4111c75f570660ce936db0b1d87d9bce611f8189ab6aba6d6a0eee6b321c7e1a5c358197fc942172098d1d1bd4374b6dfeeb97760a726153d7338b1c7e7fd9c0c07441907c75ab504373d5989aa32196064f642ba1b8c467ccd2748939694f6edc07b3509afeba4edd66bfe505a9aca3df71393bed9f8a461a4197508e12e3b4f6ea4337a7c93687165d9542a225db845d6962eeceeb6bd1a50d3f42a5c5756d49044a9e3f176721145fdeca8dedec8de1649da9a48630e8a5e996611627b3ae5d5a4f045d381e7fcd6d3e9bb14a3dd65fc94168ed5b4e0f44119eae6cff2d07b7b049d5bbc828369f93d7194752c04d36352c0590e4a57508f3fdacaf634ddcb0499309f39c616efdbb6d58299d190418942692500512b3f433d243764c98af4403d47dc332aa4fc486db1815e4ede8c3e802475fd203c88d7a3b81a43e33ddc656af078184feb76dab00f4a0a5d9a8caac2ad221cadebe555d88afffb5f24cfb94b5d2e5e377fe6ef44f38730d5cb2bb9a6b1ceeb37e60f4f25c8056ed7b27b0520752bdaee749f842b8bfa8c8c8d9191784b9cffcc987f95fce3b867e4e4af3b76591f5f5aad2aa92a66489fa3aa64e7e96b4ee58dd2c2f24e6c1e84bbb4439f0472516b5792b6ab9b7e9ca56f9b00dc15f22b348612ad1194f5607f4156636d7675f839bf239ba7c9e6d985953a25c037fbf83a045803245beff97da5098c2d93841becf66d9eb02b38a07c9e76e365b497152041e9e99a1f0df3c150ea644e8ad450f3852d44e16e87a501ee6b9532904e463f8844c500b9832679ce2ba5122917bed2a84d84c7748418cdd11381f495523d1c757b67366c19be34e8fc16210a385eb12fde4edc77a2db5902abd95d3f42960c6a8e839295d55a82e88c38160dcb1a3a7bfe22fcd00fa9d9a07e89f9978366b356933bc04ae76736da18127f3f32ecfcea6c3edd776c58d56aab65834f628e468e0c67a67d1eec14ca50a4fab30f69b07e7eb7b9f82a11346f9b4aabe1f87317e8c9180223f3a49865c058638bc4039c1efb39b1006a5a7810d321110f87632aaa6b9fef7022d96bea91643ba6320472ace3db7cf66c57627073a01059184f44fe10b6bc0eb41dfae8fb0e1e9ddb86333d4fd80b2634b4bfd8dd1bb60717d7e7e629755c5123afb74dee8b1f02e477363a09db5ec917a6510215b1f9e146e0f654731ea3a9951a32a2c53c1164e2ce84480f83428360c07b8e99ac41b7d8a0ce56e0c7d0479f1536f77e206fd929bb0134f335a87887b0b788ca54e18b3c522700f87d5d051ad8d656945ed22d0d4278a49fd10c9df5c5ae1e8e65e7d2b70bbd3a3b684ddfe4f22d81562c4cb336f4392f5f3362e97bba5af0efdf0984b01c64c5f45447b2613a9872728c913a2723c9dec7cfaebd28b66d39674ff124f1253b62736eaadc130ba3861926e407f33fc7ecc6163c2aee817efe5ccc87daf2cbcf75f21af32c4d4c30ca61bba37d81f482f7614c0bc1dc0a4b93782f4044652a2fa1f7e520ce93c7fc421965fa21b7f899bd01cb2af6acae8063f57cbdf24b8e8dbad066052dc182091a7dc0ee59563905bc539d164cf348afb7ad1ded5a5741a59f1829a1dfb6b58ba1045ebb26a78bd20c7667c963a54675805bbd329ce86ee2033a0b5b2398e0c491ba450d37cbb539a4104af382efb0c890f8592b267fb750ace2ce51cc3b564aea2527fab4bf1e38358cd4138d5274a1c92f8b0bfe316e69dea8522c090f183fc979814994818fae8b749fe8eb22e8dabcde743b84098f07c7587d5617081f54306a7a4cc70d684c1313c5388c90c3bb33172384b8849bbedead367819e59b979ea57591e942737d961d634aa2489fc33f563ed673b9953c2e01a63f14cc04c119ac6580535eed7761cd5abc7d21761124d00ef25bb22499247f2f64711277390d751cbecf3fbfd4f751ba0d92cd02a20dbe5e3c1bdcb616f61b60bf0599393ed74050a9d084c657a81a203cb7e79a9226d72cbd44b468cdae0cc365404fc8952fa3eb805707acfdf11e43cc3fa6e0999cbef9de90f5d196da990fe7a5f3381291fbff06d9a43a9035869907df3c39f663a034c7c8f5936cf0c3d2a8a53ecc6fe5466b60b8a26bdc57513919dc3cbd0601c7a22b9c7f05c64ac83f5a510e68315061cecf6c1598b2e6f9fd76615584420258648a411e08687565ea4ef05ee24c565c79db39fcbc33c49f08968266d7f2ead3e8fac76a89727af8f257a0b78a94c84653a7d85da2b19928d8a6c19c85200d76f3c6bb98aa50ead4250f214e403812792908f98c720fab879678819b6c2b6f7f7bc48e17b768b79987a4dd22ad8b38c5b0f9b02257d6d7f0ff438ddd4ee3d0cf4a83b5ba793df40a661133ff630977915e279424e52dfe826b59f93d358c4ee614dd0c678f9bf5e2c4fd3a9163e455bfadcd5f2790400e4249973638a2fa22144e6fc1054f18235399636f91d4dd5f099cb70efb1d7d78643dbfa438822a5543a67544fb02342080e149be447f406c5fcfae6beeff54ec52227a9c2c4a20a376dab48b05f63fa1a57bb2c74b73a538b072f09752b6aa1c821d5822fff28b37ca764198eb45cf43f66035d5dfa2e21c58d35a37b8cc95b22fdfc34bb3bd66fe56e3a0592e8401f1974a91e99532e1c6a6f6958fafd775f2afb3c301a6f48a15c2a01647abb63a7e49b5b608daaba52f44a1d4f970f75ad7c7eacd6d8a69203a0aaccb89be4277f3a0b39f290cd86fa3ecde26c5ac7068a7d1c9765b05581ce5c32c59e798877f070dccfed665690d7ad8fe287b4ae846ac8a797108d08a6e27544584cd510a6f9a9c4fa50414eec650d869f6e5c3e33c10983adfffb6925b5f136aae244398e91b2563d0f489c7629b162a5d3dac95a1d354552482be85dc93bdd5cd1a229959f2c9708571b7744faeba9f05d28263eb127c66fe3bb7fb04e15221a94ded047f9c522c9c601ecd9b2de354ceecb2a4826ee2823dc7d37c97b0ef530dc8402ec2dd1edcf7e6d0e02d13a75b1b757366bc550503fac722dd98fa249e534173dbf068ff4130adb14843667c3c33c8e58a3aee86319996f5ea9975ca04498aa91fe655f3a3a68ec8a33b5a2d7a21bf73193dc683583c957e5e49aeb83f35fa219042bb971a0dc8dc092743b8f5d420093c71428e71577efdbb3c9bf0614d22292cd5434b463632185d46ad1c772b1f86a116657d9adae7ec5458b17a1fce59f3f3b9666dae438efe7908a6a030cd6849ba1adeca74b8bc6f7c7b1d1a1b00e9a64bc716d75950381b81c37bf8f129f941e96ffc8d45e2a8d5ace927ec67222c952a0840e9b34ecdf8de26fc0eb651438d6607c62e1e69569d4320ac7ba04c01cafb99e89e7f0a094db799879f5165cfd2cc1d589ebb1f0b212f2890b3b0a0d30b3085c81b807d9a2e2f55485a2d74b1c0fb00949453fa7d3ddb51803bae084bcf9d278e0e5c6ce1418ce00f1919c045314ae9ab6d5289ccd55f866823932be166ec8e10cc3a9d74f2ad14f254fbd307291c399a4c1f279952d7bd35eaf605c2a593c0f6f6c9f6f317e2c6f387fb81d7513edb7b8328001651f2bd0b6a68fe356c6e568514d8d34e6f9cb420b5ecb9dc2cb43833ec8528aeb894c43f17f2b5a86e7a19f329ea9e4f5166460564414bb72ddd376e49e661700e4b9d4cf704b358ca6b1899ff4e2a8c9f1193690fc47beb34faa8e222df0b6b024321d8115374a6a0cb91f6c6cd741865cb8cb4fb8e31dcc7d545a23eea20769fb51795de197effc2dc0a34f9264c9eca80058fc86e0d19518c829fc2e10cc5f9c46f279ed5e31eefbcfd5c68ed9159e93a8edeb766ae8b0cc5c0ef355d46d89361c3c6a902fbe97285eec384cf6d1fa7630d90826535f39e4cf2e15741d42f4d4ecb8d070ff51c625ef429eb3fa8b7bcf4d5e78b9a55d192c46d37916602d4b305a0020c79fefda3eb26295a52895bf32cd23b802f0d82db05f7628bdebf997cc66a4736a06adfe1f5429b331a17a42c682ac86cbb7b6819464f89f38ae3104d791b97a4a941b9a8906ab1493273cfead8d93060a81fa0bcc487055351416218efe1e644b261b4edf6ec53ffc89490ae488d36af79d1b676201592c5cb5a0ec0fa1ebaf04aa76aafe7469fc43fc583ab23fc77be19afbeab71a76c50e486402fbab26a80b38d76d0dc18708478823f90660ccde0e3eeab5619c03a19f4961a47eba15343733a0609538f01a4462c36711058ebe657edaa866fde6e97c3c73b09e4900df93ee85500f57f158273bc63527717cf3be7536451684299b7a91aef05c61a92c525096f3e74b8032cc7ffc5cbd5b9abf55e87e1def63b1bb88ea590761921d53e9f56f913bfe8e32e702e80bcdb58f5e186c78d3db136d46430cbe84cf2557a58977a30a3f44dec76d4c781f21f6a178fb27a5e2d60527b65a96f2e70ab48d522a9af44ae0785cf98fb4f9b0c7d076360f246d60269ab01867b3c33907cca99e113aab45cf1af848610109640bf6f307e5452ef6cbff0ad8f2e9b0bc71fa1fa4dc271c6882ff3f177b15aaab8f5b7c9f976cfd034bc6b818cce05ce08305b6324813a3520cd0ad58edd49658ea928005e2579415b04315efd07df461bb5634ed151d7f59fea8e93b33749c0a3b5020ee5dff1df86a251ce93f4253102f6b42eefe20ca7f1d121d6d832396621861835041dad1ece17613b344131d2e7e11e16af1ce290f1f484d4e8b4bfaf98d2411a869865a6b199774361c27b2efe235d9deb11879043beaf37b9bdd93cd27aef4fde9b97f394e0a4fa5be1eca1d625a5a4ba371cc9c15e8cf351da9d9845be0deaa2e5d305c6bacffe8fcb8f39f83e0fe9abb995fa91515b5debab694cf7d4a2413965f0c3d1466c47c581242dcefb037c2782218590d48452149c9369c1362269553803f315c8991e9a3835db8a6b6946139108d85ef425da321c5e3370c102e9c33994ab43def4f54a21eb28c258fa11ac52d5f69167dce9f8ec13defe2748b03421cadf4abda62cf0ac298099cf61a6e55cb048bfbef13dfd8cf5b8bb78696542ff736b54dbb47733696afa09899293cbfb365fc7a75a18bc674da7e87b85716d80ea9dc40cbf61f781bc8b7d61bcfaaeb5dc8d321a07dd8357e1831486dae9a32fc60a1d340d0ffa6e4b816396ebbd31341f195442bd5f8763f0404316d105089de7f863872f0bb719a11b592a055e9483f20c9260d66b0e695da6e4cde7406919dac0de0770170770ff9c26a34b38b790fdffacf8e7cb020597abc97de30761882edc342fbbc31ed667100ba5cc6d82edd7ef98ef97fb9f101b1db04fe00fec3eaa5ec55b1837095b2311dda8643ece16bf59ad90e873a8a8403222fe7b645f385a8a83f02afa0ef99e2b3eb491aa86f981d65d2e5181e375ceba36c86dd39c59a432e09dc7ccdfd13ce2c27649e537e2a669fcdf175c8e8d008c688fc6a42096d63bd8854f1d291fb05844826dbb5964115e1a13d4e3263f4e1cd873cc4b25cdb2adab93cc8edeed308dced214ee321e3991b46de912e372f1d36c6af0e3a3a0fb687d44203e842843c67c072e89011e4b6ede88a4eb850877110d4e45116757bd73c6f2be2582ce4c99e74e1fcf00203ea2c95b9adc6973bca64d5968741ac6e5f0037458eee50c838659a2a00c5fb520d2e131db3e433b4bb98f6c889d1a77b1c3ba57ff0be56103b678dc9a7f175e4c9ea9fdbc3013f92c8ce6b66f2df29f8b31920c22078c19fccdcebea9d04880669d601f6aeb903f7d2b67f542ce7c707701e8ee1b01bf02b49e844979fb8a2e0d365dd348451c669bcdbc80b2624b88f5453593cf473225629dfd9ed8edb9125330b3a986dec60ceae27c4df5314cf7d4541f68631dc512c4ce3aeae89289dbe723a0acf86dc5aad43f84ff1071c07f9700df36051c40f4610a644699c01a1af9f07f46d9f02e91ac8ca59f10850e9aaf4fc6062a32b742bf6c7acbe5e09f85b9719add950b87f5574fa1c176f9fb0b01bd2be60e4a6885f635911d4c1a072523951af26c152d1495b84d264c3eb0bfba4207a057039b311686004f43014d76045dc4c177f83209f669ae4b131990560be9421974bd9b669e18bfef4645a2986b3cc7ce9be3ae614ff54632dff708a39d614fdd81725610a8a6c9499038ad014bedfe7544f39482c4233893278c0af8f2d9621481eb880165052411e0ed6ca79a5de21f0a5ce802723fa6cd4891089c929274bcd562930480b3af2cfdbf87266572fc8b9eb012a78229996b11d7c0c11c43188f8dfdc0e9cda064807d3abf42a1d1d6e3a9cda8be6828f48655823e70052435f73e7657fcdfe57e6301bb465673cdcc188277f0658ec02d3a2867ef0d44d13c6e80633524f77a12b256382d11ead83852901b64ba00e5c61bdd70fe815481ee5a251afa60377947e066987f5b2de4c26f25a8e1f62c2a76f462432fb4bde50d08ba9ba7c42facf639efd4536545c46468300f249f5c74b663a32db233a6fea460231e38650240c5bda74bbc182e6510853dfa80e8a79b131ea70d4c28ee68fcb8e4997bbcfdfe0a8a1e140cd6ee7b678ec098117f5bade0cb94ae642814e184ffb562b6a491550eecd1676173c3af4eb0079b05c2c4714e05414586a5bd9c0ce84b9b4274192552573867299e5ed8e63a0415231857ea8f3e223fe59bc48e23a7fd7e6a9f87ea4dfe8e3302e2f6ac26468c33727adc049f647845ba40cd14f455626f40c2aa79bb6379cc9fa474079d14684c382a63dc94577f4e83b8fc80edc57e2dcb89038b62c979d1aee8e3f1948e65adc05a2131adcb0a0b993ece3b28b7df2c926ba493fb9f61b55802fe75f80fea7046e2a037ac6290d0805c934128382c932e102c0966c1e6c2c09d314471f16a6c7dbc28f2e4076d34b401e897c010ecf35c6b5e58d4446f04e3ba3a20346441463f006205ed35697145c420ba47f1f7c2e7e0fbfbde7df497fda582d62a363155ef55abbe3e3517b0475dcf9471406c7010cc67c55216794907fd94728b06acc900c8ad6154df08589da4d8ff33207a3b03c420ba06c2ec7734f7eb4fd4412e5c6914486c26b00166f8ed8229055f0b9d7f693476eb8ca48edfa5f34823098101f5b901930e83f7513c9cd2cef2ec69fae2a95c2fee891eefa8cdd83ab144f2673d012b2d395d73057d7a1fec04a1f85f286f02cbe1df3829dfa6194ed791a55e0ad9ca9f979ecc6270e7c75502bd66733cd75d00e7d7d91ad917a102595d54668fedd29ac5f483fc10cc32046432e906abec03e36e6c2db5b7219a68dce85c6f1164a60acff8751b276c282c4dcd4b7deaedba1a2f09dadbf24777e3cc2d513da8c2565f38288ff68e1043ac8cf524723b2d82d46a9c595575d3633ffc9f2e676ab54613b76f06d30edd6d678967585f8e1091fea934a31f0382bdb3141591f291e8512e9765f6a6700514da247f88337a170a84696c16ebdca2742ea04400766a513f580e36fc3fb10dfd041637889cb8199a8ab713c0ca9cc8a7faabc86c7b505a884cff8c322ee3104282d7bc0feb1760ae5a72d3e225acaae7d32257f9070943df3cc14cf322f37cab465ca7871add4d0cbf242e2fba5fdf93ad705c01ceaee7faacbeccae90cbabb5d660ebfe1dbadd7e2f99232eb4bfa605f8baabbe3c156c7754b6f6ae11a70eb62a11609facd3adb800d70d9bf8211c781fe65fdd65f09bdaee74c41deae4c18b3519ee00a23a21312fa515c75eb01cc457d8de501a1f69c5b395e69aaea322011bc70682a1fb404bc4fc32ca31fd1d55c1b85bea94adb78a58ae4b7192c8d8578aaa86371412d2b522e235e3223e072cd55304a3c9c089bac7dc960e0d455abbb744d921ed181e2c1f88a9a50e9f4ea51f8fa8b802642b1170e6a68200fd63121b0babe89ce9c7583c7ccd32d3be87dce7ce6cb9c024611ea906e3d0ff679de734c7f298037a2b2a71e45e5ac2219801965545c13281f174147f38c43b9001f31cae4fe8007411d717092510f57df69597cf70050c11b72d23553bdea3341f5db3807b7419e918a30f4bf89cabbe16d6c9894451438cb2b033c380b3210d3ead2079c6423dbff90709ffe6706b78f1fa308e7ec033481d6aea17f65fa1f1ea2db7711c43fcf9c1962d211b1b764b4f0e7fb0dbf22f6a89ca08eae8986160aae2f54992209df93949c171ed40dd8a3cf596729532416801c61c141833f9dbeb7c6ad4a7446d6ecf9959bd1ee90930f8b9f054beaa4f612810abbe860b82a22398c79533b25025189d33e20158338651c49b50a04adda47395fe75a596278dc328518598b9eb50ba01c256d982dd3ae474754c97cb28a1c6d2b1fcd97f0cf02d86eb5267ea8bc508bc48bbf7e5a8cc3f8508ba553c612a9da2f31be949bcc4a0b7f57fdbbb73c11806702af178ec727350a0fb1685a411d029a7e9b8d74d19ce5a6bf64c141a4c2584bc90dca5e0776c6c8ed097675669df03dbecd59194e4d12634e218b7997c588e35b05d8d1b8c286fbeb099ea4fb909952edb106264cfd8766ece0f9e8d93aab409630917d5b89bbf745db2fb6d5e6ad379b93b96cd3de15562d21f8d97024169c21ccad1ba6fbc55fc48e70580ddf6892dff09fdea3622e4674d005b8e3f053cdcfc35a205ebd696b38f28d614f3617f72a6ebb9f0f928c4c116747bdd472a75f9d8c154e7a326eba818fc24f19420d5e0ee0c09ac0fd8f7c1654af1552c79208703953d3be2667def9518dfe18fce1e44589c7a6e41285f56d64e381a4d8559453d491c1ec69a46b1c02f4a79098a64e49445b6603124da50bc26b6e4a5b7af7708180f538e0b12030cf3d2d45f911ca408037f9a914201c1c7c1355252f307b0cc3077f474ec4b44ca5e00d46f889ef833ff891aac39cf2318cdcd26aa3f7ce9649677d207b631f1cd6e28a446cc3139290aaf843edbf659a3f12eb689931b38f697560eeb11d8aafc075a262054041928e2b40e2a0cb07cea9c21e71d231ada594a0dce12b2da1319df5bf9429ea8da09e8c9ff1c82a3583d2690d6b034c9a6680317c696f0380466ca7b78fed46771e9905d7180f815f42dfdca100af7003f5df8706c2b2f79bde3d441cacda7f072f34ebf0047db381aa6342afc80ceef95e791d7e34da289a619603989ce3dddc9ad043817b2f2a7e6d3e55f54543f4f828a4d4ac30cc8b9e617902f0b62579bad92cb0683ad80aaf55feb8373df2398e648991815834f03f65e672c9f1e5c8a9d6a3a433643662df0c2b6a0de11b12eb40d5ae1d2e5a6a78f1f5d2648807f644ce8f91af6b773e1863136bf0a3565214326e1a1a16c53f00aedc3d33dbe99d2051ca1352fce49651d04160fba2e155922ed7f66e38f54982bdbcae2c39df4ab2285418ff38f0038ec1d925db51495b7ae368dd30ae1be84a5fb2ef247831b5a14887a5b4f0942e1128860bbb9179fef9d909abfc56724ded90c52811582e2d8bcf9989bc6bb8c486622dfd718dd14f1dbe909868e554fa0e4c1d12e53b6f49bdb0ec24567270d44a4b3eb500428ce5ffa183a7f76ec1b938ad81fa6b3b6dac485c0c56e546c9ab4fecf4b383f34ed3a3d70626a34a09e50ff829fdffdad95d1f63f4d527b12a88912057578c15df7e5e5ed1809e87ec3f3939fb13f6b533636b3a43d66eaed3f7f307e2c067b5e7f1d3efd66470934fc1ef9b453d2b36e3fd4ca17eacc06b97e67bbfbed7295820b55d6b588a672faeb523f8dc65e6068878405740ce96286c9d12f6b390f9729e9549e2f702f21405366a1a5b8f1fbac81d9a96fb0281fdb68a75179e8a31fac42117aaafa5d38b6b37ef0a940ebf45afed6178c4e72711576c7793552ad90a72ce01cc43524a91742a048a83a41e929eb44870bd7a77f761fbeb2174026641178a187b2592bf7a61b752856fb8dd1a385196394dec83c353488e872f8aacd44bb2a6f150ec2cc3cbe102a372f488af168c5bc9a732c7e9323844399927709d73e3e90ce72061e20aa35156f35a7145f5c0667a544bd92089b0021f56ea326d936c6ddfdbca5acf9355bbb8f39149c7b0036e0a0c45fae84617e13ee79227657e6439139c95870824d26742e2ada59a9e6663b3d9110ea692bc00bdfe9f94b1213561beda245215f11d450e565f457dd6a3ee958149ed4299b8143382d3099fe0cfd69ad91928450a46cc190eef2a8de1f6a3c9c387285525e41bbc12c36659964220a4a0fce739508ae17c8136b0ef11b4e1a6eefbbc0f6d43911c7b4395437a975252b339d602597981f0aeebf1720d90b1eea5b821161a1e4773c34865fab530460513ec7424d07d044de0d7ffb9bcb1c5af8e6b6c9cb23b098b345e91247a37efa1ac27495c51c4159cf0beb02f22bb7168207cefef45f4e973a22dae338f6865760aa7f61c92a9825afd47f191f314c5eebc622364074a03632aae67b5b2797abbe6f91c527c68c8952ab7352109f7b36feb0a1f9cfd920e915580697f73e26cd6394c2cef59c9a8b6eeaac52431cfe0db2e311ba57a5f2323dfa77c87294396438bce2d6a41c39d316040c557ec3d27cc5f2a147d6d9f483f60241e645a369f48ad13c539a83e33b7b3b09a8dd916b1f3e3ed0cc66564bbf4756843cfbda826ab1f6dcb910c8dc1bb3dc8b44e3ef786af9d7f6e44684855958fc7ad7512e927c71fb5ff64f421a92fd5219aec9c628ad10eb88368927ab695d07ee5501778b11050d1f19c886c13e0469377da285c17b6c99708cdd35dac19abeca7010e08b464b55dc396b36e805be1906907fe5d9264a26b769016a3b4cb61fffcfe15050167be9c83e221b1ae6638a910a0e2cfca33055955528f7e3c63d5d30fb47feff75eaab80308ce0096130c0fbe03d55ce8caa52f2f6dbb5af68f6ca281ad40e4012bcdf5ac55dcff2ad349ac118dd798158b9a353fc11641b5dc794e3e3510747cf89ea22e4557524e9513a7ea4a35bd37da707d58bd58954776c767810f1adeaab5d81911b2b59186e68e8421de86fb63bd537932f11106a8d8160e29ae2654be2f1256ba5c2697cd7a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
