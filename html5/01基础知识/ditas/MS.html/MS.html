<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"304664036634c59c6eab0e5b4ac242f6545390ab8653261b86274fa799689319c5f1c523b03fd3eb2af97e9fd596f0919c5cd0f2a6ff39c229e3110d55a4456310b4f33f307485140a3e73577bb4195c35d55e991372e201c5fbc4429b09527984058bff6d34e2a2e3bb514669aa5cafb3e759d92f2c0020e3b502a093a754b9bb0fcdede68b2db3aa86c18c6625a545d22d27f6c74c135b5fe7e694e7d4612df326a1210e3546d837dfbced02c180bd1934e9f99a2cb7e487720cfea2d0a6c204e7c7e1bb8746bc6f15a4a7fbd9724fa7ce46629d885db4ccb253ee7d9072c32e501574bbaa6cc68bd7775c2b044378cf7e2b1f915f5384181cd849bdbdca70f051470c147669b5f072a2992ede3b06f64a6b0cb275af3adfb82ce8ba5ade930bff78f566fbf681c66480546a8af942726b0e7067092bc46fd1a8d1be3e0f91114052b4a4057df115784b678f010e1cd2de0fdc64f0c3d5b67ee29c5bdeabd534c47bac97648f1de75151df7dbcb84416657fe411503cb21b27e199097f30d5519ac06fa684f6a9631b62af9c6e49a44f493a8dc51e2b1fd8c75e7a5d99e8c2321e4f6b4c0a9b73a7f27d3369707d13a0d85c70b512cf2fc224b7ab4c173cda3049a70078cba84fdaea0413dcd9b9653fd3cb0016d351a43ef289bf93fe069d1eee54a353ce4537ca7f1afbc78eee49a0e0b3e42e06bb671c6adf9730b83f27955da1613272c5f6e85f871fa3208fa352eb7b7712049b7d4a9378156fcf0669acd1d4305f366d4f811f3c070fc48a633f5e4269083c33115c604f0e99da64d9be246ad49bf3ea56154cf444f0fbf5026f5429d88e89914310e1dc279c50b894cfdd396c8fb93da0e96300200f687927c88392dd67bfeb3831ee1650eaffbfd68dd0b549578347af6971175dd72f939e00e79137d96583bc0f025738aa6fde26a9d2992d54f8148307b39a00ac25c2ad70a5b2fe62e24f9b2a42533b8427cb9d5bd65330b4d9bbee129256d0a92c456a099436902e463914e8f84e48eef9cbea51ff115a58f3686d0f8336572fecb23f65c9e76c3b5263630d9b4b4de0c30d1b02bd52f96d18abf18cfcce34a11832dcd192cbc36f8e50cb7b32138c0f41b8174187c8446d6fc1686bdfd8be83d3df030d573b871e94dd92c7c9e12baf7da3cc40f7b37b43d7f7b73b2d2e5237045b11ccf0e6bb00585f52b001593d974b0e69071e8b87ac1df36d3755663c320e2dba11c45c788be6916d361f28b73e7b45afd9709640dd8d3546f2caaa77a78ba78294488c5519d67dfbc61e9eebe648eca1e94734a323130e4f1582571099eaa3b410b520cd9b7ba7984d2f83187fcefb08f5e2c6e5e8b54685ab44eef169e5eaaf872ebcb34ce72719218f8794016fea3b25ddbfe5d82218740d7f294c1774d9bb52265d2f70513f3c7896f0cb6ec64415425a892788b69ed6e1f1422672396aef2b4d8eafd11bd459034ee1f6fccad8f722512ceb139ebad144c4bfa689f7a857c55d4b60453010535670970ad56bfcee9f495f1ea5ad3c564cf75b667e2f7fcc6ef35463b77721dcaa9ce7f6d699817ab676c18bb8ba605fb64bc148eaa9f7605fb2ad9a30cd21af3b28df10f98e99186c6a4af9e5619fd6cfe6160dc7bc4a1478cdf2c27f8cee281b99140fdb3a4e10ea8349aa9710be71b309281c339ae10099e6b64f87fb4a377abc98d500a9e659c999cf268a6d285bc16e3e3ad3e18b03e8068fa04b0bd21e67d68b91b790a44e98ae6039c94f0edcb51d6cd28d15ca4cd7a0f16f3478f53486472abb30d538ed8a164555bac6ad0ad82a158122e8ccd18daf0ff6c1ddc5c68d742fa7ba555be69b8962f53718a07b5a13b8c42480d8e69939a2d389cbf21ecc6835306fe048a5e0c6f706ca321cfda181a4928213253383d3f0dd954edf0ff8044ba6c8333a9289a0e8d9ce1a531aef5f874f50091f2f7ee75f77f2f6f381688f22bce5ff469507cf34e037163f3b94856e4b3f327373b24d2e12843d8314743b1f95d622a163d61e3b1dcad6c4d3709335bb63eaabd5d280c86fad675182b3a35460a89231d815449d660428248dac422d5c94117ae67dabb04564230ecd8bf3ac56cd3c0ab1e6645ca0ffdbff809001ba01f5c0d6bd487141c6b9ae793f4854df04458085ab33983594b11f08b00d963a16f4093c724df339844ef19ed6fab6ea84dcb3fdc45de8437167914db4aa1883284e7322ea71b725a4f61aad753727a16b72ea4fb2001027a74ff21b91b4ab7c3aac657baa73ab6b0d47777bde09f50d5650ab6e7be49963d22f200af3b1ff74b758971cf419805aca3e2047a704ea91e81061593ec5ff6d26ab4d00be5f15c5815e839339959388a893594139a8fe155c163487cd4d48d0bcf7f905c0b76fef51a136d178c44b2dc3b8d6c0b825ccbffe70be88433cdd763b6c921c23cdc9676ddb6d3a72708178420e0f013505d6211f1ecb605bbaf0e18a944a86d423aeea3cbbb21424e83c23b11e199999a6a4e8602fd62874b8a007ac7508359fd4b557ffd47eede7820b249ec641c27be2e0cbd0cee7fe550b4bcfb79a35dd45f6abc013db18362b9385a08e030fc4c42de205e6d3ec83de6fb884254c43e5775149c470b8d6af6407647763dcc8e0a62557faa2e0e5eb3c9071a1ae0bc2965b844d89d9c32cf72682d4efdfdef84f0a8b1a5b22dc11e8f7799d06a5d2fe193ceef993afc2c846049d22aa5c5d488a39bd77d63bb714ddd47fe37059ebbc7fd4714d22bd0f4b7d9dd1ee18961d90158853c4c60e6cccb960fb7e897b41c99dda756b50b17470ccccad98f34cd764483d23b61ae72bd2d9c24fb622ee6452d01875d2fe34dafd5145a2b48e8168c9a0f3e892451d4136640d93dedb535e5f0740ab10fa9017903a88c42dd24d7df264cce018fd92024380130bca918b68351118c151b7ecd74ff058f4642655ad39a798187cde803c796ca346c4063f7599bd76f0e607a4d038acad595b4242ecef68bcc3030d74c10df5d536cb6173eea31d4bdd716fc89759a5e3f7f4a812e5886969463bd8e842a30754daff282d94a7834d87a58b6a0b247c508e984a4f72cac1f7e1d9261effa96d4650a139bc282f174699877fb24d776cc318ccdee0918ae51b28ad22ab4fd9b86647c4a1f5ab230eaa1764bef200057c2b68ed1c096fad41bb252f442267289fa68b08b40180392d80a33febc8231cd9f5d2d68fdc3881ad2510d5f4dd97f25a45d36e03855db479585c5fbb910cee3489645e3af7228718ed952f057d3cd29168dda0af57f7049f164445b2cd6effd2a562239d32e605d2d44294d8aaff0e131a7d08c41ae2c6f222abd1d02107eab54baf277c3790362b0b3ed70bf64d118cb66d37bd0990dd1e5ea830ae8dc7e12bfae9b958c2c54214f7dbd0165b1f9303e521057a8121d2b2e09ab5df28804187e2446efbc8f57d93be288cc8dfac3a4130aec08030a69dc1376864d2029edad476f974198c99b2aa45415d01fad43d7e4dbda8d719e58a07602f035bcda4cd839b0c88a78a20663cfcaceda870a9d2a734dea488b1ce77ea0a5367da519390198dcea01f0bf8b776ebf49e24a14f170017cfa67e505a4b30db298d94942b2c14dac30f016fc10e8d712cf2afc14955d643f08d549b2dbfaebea3e2b75d0aaf416d3e3b72b599d64da69096aa72a211f9e15f4542062f2855238b8c48e37a69dbdb7672903c9f82191b37ada6f8cc930121d5227f40830107940c8cdf542cef3eb455bbbe20b6a9049781754ed3b9c93218e8ea644b62308d4632e7713100932a220fb09bb9ccfd16143cb14f9d7b657dce93939ecf4f5f0a515f57613eb9111e2e356816c8caa1008536f6648741ab0a6b83dbf4de6c7fd072a8fe77945938de8a6479db604353ebcbf530840beacb731610a160f1a3fdeb780dcc74ee1b4725218c0bc4c8bacb41dd8865602fa36523472978f657a3b2b3aad7a5868fa940cabad63cbf326e48d12c55284187def5db93951ddf4938fbe09c1bfa166b30e5ee0b72de5f885ce8b4ccbc965f1c5b6873a99bc13f1a94334afbfcc6f0f2f4b71655d3ad55461627fb39060c8cd2c175a991da787cb2cf685a66b9db3197562eeb85efea30ea9aedda6328e262e7427cb346ab06f61e94932e4731720c6f5414228f1d1fe25f5788579a1bebd77971fd314f1bf187a8c8e779c6a373312147f0c0c5a80130ff400c408cf1a7ff337db4d9abf6cdd7993643b27f5ee7b17a5c28e13423039bb9d82218048d318dcd2ee257680bbc9b9b574a7017f046777054d59c4129fb4464efdd330ebee6e9e9ade9e7c08813039d73abebf82187154de373c06572564959a974aa4b431b7a2849b8b5024915a09ac5509de2e20eb779afb826b95d1ddd0d0f19e2f679fce91117136117a7de8442e8bc3f204da53f250af2ce2fa7793f10387826bc3febce7cfdf75e6e9a8adec8cbf1e1c3b5026b30c8d022c74ee3fdd428a7eafd4f793ee38e8289277b125ff8187ebd015ed9007ed760cc8f7bbd3c0bb41b202634c53e768805d40e8d046b20257778acc63ce9e571bc332e372fa06a5c17d0ddbd03a8d497c7c25881151bb3e26ffffb4220bae1fdd1bf79a96bd6f0a3b861fa6c83b205f773d3014b274c45d6364c96d79b8ce76e23098a0cf0ba5d6719a8d6f77627cc26d4bbc62c149446b82d24174543b98c796eff3a58c4c926f3e70fa572336ce81172fc0391fb90c031c29279dd717b62b1c8579e4bb4f8bce5bcadbda3b8f004d306c5bd8b2e6b417c29d72e1ad4255d5bc3229603f450c1a96dac3a484a8a81d3dddc5d06de7c8c949a8dd44132410e1c07db5003c6ad14d25adf079fd1d28233cc40e316ac545dbb2e933aad211314f0fbfc60ed26ca52e511bf7a679110f8a760877df49f7100e432e3a5c66939ae8adf9212098f4a4a429bebb5c58b98e2ffd545e0f8b5c1b2426d10c81d4c9da644d1e4b84f22a92832845334c60348963f6e4bbf50b77c5a446366b843c83dbef123e163fa43b146790b34dd85800643fc919331af98738f358d4e4c6e0387c8bebe7c46cd58cdad2f5211f08bd071352bed9c8d8c5146c1c6484ba7913923be35a23dcbe844657fafcc0c53a85058d0019298c47f1a81f93c5786de1284baa94238b93f8242a91eaf0c5efe30c075fb0acc8adc23b686ff07edc14e9b94cf082ad1227b1c9a2c63f100060396a11521844e66070db01f4a442ea062bf0d14f51c9496ddbde7a58f9502dd735dae646959a81f42eee07c76377d53e888475319132283d72d4568991103d7d501f8526fc79eeb4110dcb318434562a6d2c557287bd4a7a5211b4ad9ee0acae4c42d609b9f3d79cf4cd7240e78dfb166cf1e8b7d8ad9aaca382687d83e124b64beb116c3a613f91d98fc95d523c7630a1f818b83d5745ef06b4ea320c836f5fbc173878ce3f19878971eb3b1700ddac08d2781ce9b253196b760ee165eaed51f31469f64a097456e139c9fc5a5ce5794298cb171354bdaa8994a366eadbfdcfafd202a72b6ede0b4e3e64941707b67600f5b1360680fa050940d4e1cd9228dee92156e3a1f2914463feab853f9b1e975d04a3bf74e26c7b84ede6b0620ed562837a6564c776101c8ca031e10d3afc83c6564d2ea44607bee7866a051300e3bb3beea9835e2b6d76fcf8e939fbb4b393c73868fa8d1440e514566375408a8461c83f1f823d2bb153c052193e0b917fbc766fac33c790f219d623b9efaf5f0f623a6e41ac56984eb4ef4ac4ba165bc5a12f68e195a56b1ec80b6e1577cc252d6c18c1f19890bae7abb326ee94fa27f93294af5e7c8ae182b544c66762bd7c3ea1df9d307a46c3afc0eed9b64cebfba35e9627ed2c2629d3a51141b26aaab21ca66b3b94caf964d4da0e1d5d00d3dd7594ba15cece23d3fa775cfd393b681e9a2f7bcd4d91ad82d9bd4b5c492b08505798adcc6a9639befeeeb37cc3e2d2004a28ef024c4d8d32d50c09edb5cba25eb07d055f89590dd093ea18f7b38113b394a9f221ef9cc14106495f5d382a09c9a67014f903f030f5a614e919b5c70f1fdad73218144074b16e270020fc4b80a42ec32f53da74e6c228f6f128ec43c2c2e2f72dd080afb85a21502d47ee8b9c614222d5eb783a6db44f5954e7572d2d3e5c2b901193f7707e0d4877903ec7cababcb9f7b9c0b62bd55c37aa0199ba14d85dad2d4226fa14eb8f015ce2f0ec9f6dfa8091009a61b390d558f9541264a1d3796210876832d14b90106efc2c5c5aef80824ec4350b3f13cc5f02a467b1fe04fa8822ae6878c11b37fa2f9cd938bdda800785cff19fc834827fa59ac53cf1eefe6ea87d74bb6be991ae97776b287c4558b3ed2218a6254717e5a89432811d5fd71f63d789166139d5d53c7a9d2ab11ec56f1e286eb1cff2053d8fc00ce33347808ed5e7e30a25822207b108c9a858341c0911f93a23914f5bc2898f76da10fadade3feb54b6b0d37d5b9f03d3175ba190ddd07bbedde7e0b906491d1940f906b6d3385a84059f659807a2c6a040d8869b3dd4073bb623699c1016c94432047161ec2b998d23c0dadc9b2a2154e09fd78ea262a770f1146295a4603dfcc42a8c0b48572fa9dc35098c6463994a356e4a6dd64832451f637ac58a47ab214eaef23492fb824bc8509137239a171122156da77dabe98bbc6b53286ec2ca741f8fd5432afb75188e046f4809a02819447ae53936a68414601c909300a3a76ae4e19a1fa19178c1a19f29d1d005dbb6321246decf05f9cf8730aef3b0fb6660e887afd8878b5c5d6f28439d35c10e85be9117f6389c87907e419d6539b50c1521ea55972938188ce05f3ae2007de785296f05ff211af8b72f961ac17bbb602d8393ddfb9073f8628a4ae9eeac13cdbd023d64f3ba1715e60a5f21f57f82ad33690ce1a16609be088d0be9c8931b6418e1012e510e8383eade93a6d9cd29f2e02a2a09d7307da08af8537071a0085d2af8d7c032c0af21d81152407487e14acbf5b07b204c9792af1c0bc49cdd4224e74d34761e7da866e871eeeedc099e198458d346e1aa90269e6dac85ddbfc17906cf11658e95d4248ef48ae569a9593138b054f4662b65e784b0ad0ff74f17ccb58d0393ecf9169c3d4a87b08230b793fd5379db5a9d57441770ae2bbc49859e57a436dfec0b2cdf702ec4bf8411863f9f77bfe296dac509590f30aeb26ba737ad01d914ae07c24065da522809f05540846ea5a07ce99f2b4307a1f9cc81944cb8399697893968073dde842cb6f71b2fa575fef8fa1b831297442bfba36e24b5e0c12363d74ffa72db73e1b75955df7afbb9f4fa1cf06f40b1d058e8ba0cc32a27170a9dd671331fbe82f43102827f871f456cfcd518fd6acb558ecbbc338ebbee1d7da1202c5f796678ba7045e6fbe7dc7468c25687c659dae1838f9e40fe26a8101eda4c0e0eab10de03bbfb99631ae02b57e6101aa11889485f8a7526c02528b41ec650951b2bcd3d85ee6037731f2dcd1c26fd33a7ae68f526df3e7e4bdc38f94347784b6a225e9e5865ca918993a87ea83c32704c318369765d74f99c9c8b2457afe5586431a632a77755b9f8fbbdd46edc9a0a22e9abeede13ba0314fdb5ad162aee887c9563a6e967215abfcefa6e68e73bb37a4a926b08f8d22904221b551408af2eee217fc2ad06ecec5bb80fd289761092c73b5019c763942db4931918525d4c7798d94c01f1e57a79823b65f9a9ee26f1cd672854a08f8bc901a66659b47f6c980ff3eac8511e3cfaac879d97226447e4c549ece7f4458ee9e366a8e7e358b958920dacd6814ea8bf990731d57fc7830b45fbff1c447f9ac561ffc8a9a869160465d8311a2008a588a1bf7bbc33203ed3f613e047c9792b81ac516a7c026de1e24a37771d1f85964cf8dcb713ea798f5579673db485127ebc8a186cc04602eb9fa1c6830065dcbec1a6ab4d512ed63aa185a009e4af7691a30b4b3f9cf6e7dfe8030b05ed870e31b74825d37005896592e90727357910fb6d32b7d74818fb327de6b3e1ef0c63bac1b0bb3aea26dd9880d6c50ab5bfc4dc91e46fabe18839ec250e52730cef39f04f36fdcf90d4ce3536918456855696864e721564b772f8995446e22cfdc7bcc16542f781c96b6884c27d64649c8e688e0ddead25c1206560f6a49efe1b01b90400eb2a282276a6d62113499b670ac175c406a44ecbd2b94e7215c9cfb165f15bfa4826e9bc99909b0d96379d88500db87aaac1e151565ae0c8ca693e2e943401035ac396748707f21bab337709ac9d18b4d8bbc7ff94345f2b5dc4c1574c9bbd8f4e08a5b6a2ef35fe9ddf61a15ceaead2ee3521f530c91225cbe672e51e704304fa4bfdf7d258de90f62a4d53d00099f66100603a8712e3adc2a6d815212b9bd08e73c5b30fd1ff9a20df067a39b98d17408ccc268562f7a5f3fe7fbe7a427049c272bdff693b1d5f523d0ba5bb6b8b601ae4f707c3a679c7488404214b4eb2d005d4367b84f9fcfdab0f8bc469e11e4ce90bf710631100f0792b60471c341ca4641b98b12d6e2a676fdc31faa9747e89aeeab39045198c4f03f867a19c37efbeb96da295122d36fce501cd5360b4edd1fca04dd3e84bc9d90e389122bb5102f98f863e7a56e272557abeaacd4603be19dbc93774476ee26034e6b87166f964f690b5826d162f2d1ab9c00a06840be0b8bf3e355ab2c93a478e13d0a508efd2be8ee5cd44cea719dd884ab8c6c8ba4fdee23c860f2e95e98eba59ee96c3ffde03105f76d23f1f69fb47a13f60507665e0ae9a51e238d1496961bccbad42eeff2210103e773d9df8b809f9936d1be89525f618d77fc09049a9148d3fea3c5bfd8e152066ab827beac405b4c6d3e6cb1333dd1eeddb3f654967124cca06d679ee9380d6f468d21a3aaab57a11341bdf7e2cdca87ebe8c637e37ad98d45e5f054230bfe3e45f4ddc94b12b6bb9701ac7016544b3ab8625486ba2c8e82988a3348c2b26cad0414046e94319b2a63f2f5d792c07eea63df7caed6ff92f1bcff9a5ecd62fe9bc21df49e7e3980585c988b9b6ef674afa476349aaf8f61e9169c55c48516e5f41328e1b23c7ec4c0c129a561c3aeae6890a0f1c103b1570fc81cb0df37e7b6bed3720aa764448d6212da01871f24a673605d2679ceccc84f673beee275503123a6314b3ebc22d22d2254229df54fd7f7293c28aaec6e7232f14aa2deb8b2b549ee3577e953739bd6f8fbd0c4d636137b45028d3aa07275a6bd5a49ff785db40e130f3dcff9ae0fc9f59d3b616cc98c5d898cfac01086b6c8bbcf97f616e314d1b8f454a2379e965e72362fc2fd9e6d97bde8cf1dc397efad3cd9a46a6a75b3f4f7ea879e04804495a210514343404b9a2e2d8b2014e7f1bd49dcf755696adec33ed3dbba82a1d38449aca8a92ee6f940106c73476f0c92dd2f8178414abc4b36236c072eb03fc767694477ecc2e2c17cb8a6ffa2a7f728b0f586e736effdff7cecb879126f5b2b461cc8161a746b9418ef33a85f5326465f3cc2641a513d8a62ad67127680251e0b3e5ab8d0cb7729bfae89962588911ca24cc53b8e5978c136fb2059e41d04b81e56b47f2e0c84f67d1ef9589174e6c710a02a3def1338e54c9f5ad91ebd0ba08470761a5ebecdc43c770a9acfdc882b82ef34657356f786ff4386004372ddd5d7fad480da12abe884fbbc93432e96895f1b6deaa3f0030cbe542390b88d6b7b4a7bc9cd11aaf63b2e37dab4932332579e092631c6bb29e8552306d7a26f1f091202b8b4bc9d5e20bf03b2d4dc108d188aedbe9a658c5996e986c909b5b7df7ffb6f45788a426357d714648ba6421ccf73a55d6a3f21983e965e5be45b7e86b46887f8c013822652ea66bd3e28106003cb644d3090a8982d7e3f487e5387bc3652c16e186a767de5328a10ec4650e13941532bee213f381c07b554339979e8c1bf69536832341e4dbb9dff5e53d86137231e3b541e305649d6de9516befe1256b4560f9e0938366e197cedccb2ebdfdfc63db1a133ea7ae5a2fe767fa8750c33a0eb8ec41fdb6ba88803f3ce87ec58ea67b082ea2fcd5f31a4890edaf067c2aee96ba6d1da81d3ffb0acea49dbc8773b7fe885fad0b1dcc3db6496ce5c527c9159e0cec4505f75a0005dca6cbe793b52c33485cdbe1ebca10cb9cf949c583d5f9e80f99c356ea3cd46cef979dc9081b640cf2de2af3c214b57aa09f39eef2e7813456f1ef738b99a5006432d845a6a353620b2a97a11be1debfa0be66ffc9c94df498ef63e4577436a962509bd3641a4f8d1b76c18e3aec0c4afb6e12025abf8c9f8d75fc7459c8c84f18625a98f7fec247db3a18438361da673464f564a724a73770b6a5da1513bff59a82b355ef8b946f8d056093257071df3868afb494d8d5c8455c9a10c40e1d3ae1479385186526c9e1842f9b42ccbfbec9307dcb49f7038cd7ed540bf43374bb3e924ce1c76613c94b95f3bfdc5e2bb5d36854b4f14868e89d6e35e61d63f2b5926cd60986c1aff60f658f7b2c1a772b45a0a5aae7defbb1b5ce6505eb49b6a350453a3c7ee3ab9956c07fe5183","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
