<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f82972a015d71d80e21f098a8b07139043eb13d6d48257e9c0b064b399730b75967fcb0c009a062fa888121857c29402d9e2780a33289c545a612af27d05164dbfa0f001f2ce68aacfb556ee73a9a2767c862a61630c006a9171da77ca4d0b245c48555c8fb922dcdbb39cb41955cdfcf4cebbb080e066fccfe9ba5be2675f3ace3a912bdfa2117e467c37363837de165ad0991fb0108cbe33b0f9c9432d7769c9ee341daf0f6c8319edfb88699de7bc8367d841c1a74ca46b60a995429912df719e45f593eeedf10e0c1908b1e76bdb871e96b95fbce15ebce993a99f8b212f54930ba6887597be51bf0ba255b685bc3738db64f72ced312fd52cf1d3644ddeb6c94a18218a06bdbeb12acaa7f30f3d1d9d8b1009e9ad348be3a8a64ae07f28b0b2b7bef9c2caf02aa5e3d4ad90dd81b9ad4f28ae5d5b1ea1287b1beb40dd4bd2c80ed951b17c2c03a34eba9bac971f66b5c1609cc14d5cbc06604d33a074deea01d20262c400252c23c707e5dc13879215f4487530fca1a42d81058edfc80e8dfba339aea1cbc1dbdb7aec1835c9b2479cca69f2deb0d68638f45e2dcd426bf41ce8cde3afee60835f85d5896b10106595b82c17ca6f7e944b890095d2141e414b7b297f4363ac96789a03f64c1a6cdc389110948d828208d6240b1ebad01e989e0c51c6662168a41f36d7147edc6b3b09b0877f7f9d15541b7dcd9c3702e4f507e13bfa7a1f6c0e3f8ae530fdff721025ccdd0699f5677d61e59505c6b8fe840c172358fab344a6111bb74ead80b706f59b3e5cfae3f47b64c03a2420e45099d19eaab3a45393f7a8fccf2d5996ed77d1c51f6a336c47ea9ee416ea4394a66aec3004cffc92c845ba3d6a526f185a32782a93d4dadfbb2866f8208c1e6d1bf566017768b7abcf381a89ed5b6e52a822e0444f72b89ce0a1beb150281368c3807eae2cd30fc011519ff935a24fe9fe29c1e4a42d6631036cb8a0bac8dd19c322560dcc9597d34792e6730df207164e77cce79a435c63eac507370283c963b1831ed14fb08c98a717ba6b05f0cfd6378cfd844dc8d696527ef5df1399aec3c0850823578dde62306c1344163bf424a4b91962f4ff30e30dc1bb9eece9852317548bfff33c29612cc13d98230d2bba55396e5cbcde32b24f1388de65a6080ce751de46629b3e3a9acce26a8f50d62ffe3fc89021d8b9ab0b76f2c5dbbe40af617c21782c0febc29aab2862b31089531321d740a84487cb93912ca5053137ba247bf7c9cc8ee530972875a9fdf9038bb17fa5edcc967970b92e86a585da92f04dd0340f52cbeeeeda59279ed6139786e07760d36f1b68d413cd1bc1863d1c613efd320e65bd557cc51e8d72b9f73b664f0cbddf54cc949b84bebbaaad1851c208dd2f32604bf2ffea5150bafdd1bc7e64332245189da01cdd7f6ec027fb78ee8867d278871e714cd7aed48d852d885b5acf358107296925691c166a29606df4d8ab9e6bdfc9651c2e7149ea54ed11f8038497554b58d594bc5929aa1aadae9596c90d2598e1c8229c2d2efc7793c3a48d58558eb9dd53da398358a4995a33dba1d3345b831297dcc7be8420843f9c639c4c57acadb31f27519de59797234f62034c88e0a4cb7f036e9fef6e408621dcdaf1c7ebb3ad36048287e756cfb57f574a8368908488d3d4499e21156561a4c7f45ce534c098777305a9e140b68f7d7aa35933c790262b0116d317eae52e2b6413abab9567c957daae764f98795f570aa62e9a8340d7111570b9bee087c6dc33b90a3005b011bf8deacb66b06443096fafb6094993129ad611cd812b84bb17bb07cc15678eeae345f63f681fc4afe6e403482e3784512ecf322648fa4d928995d1882e883c72a68d135b415516b130d8a3929c5ea3d6a933f89eeeb8789880c70d1880da2a8e3f92d0fa3956e83f3520c16ecdba6f0a0e7c1fc8c7534d6243435c3548749c86c3857622611566f6e57b9e1f4208937ae2f938c8557184a9894fe76fa160cd6fcc84a004311872b326c9370de1c92bc8cb602f803eb7af334037aee93a0fbfc159944bd61ab39fc1f9beda4a963e8222c5b171a464c17c07906944b7efeb669655ee32bee336d8b65a22a8e9450a6aeb199ca43570fa96ffa4ed68098f92d98575782da16cd50807a1de210123aca986102bbca43eb2582dfadacc4d4e8cb8811b008a83a0b4ce724b7bff90f4e4c621fc172631fe366b1bd7bf28a41c0a200fef37d575a3e549681ee2338442078316ccf0e5946247d11ccd5aa3232365d8ad927f1e53bb5d5286c72786930ee22ec9a5c2d22e7970fb3a6cd8716f4e03b8c622eb615c2258aa77770a2507c892ee9225782fc88d00951158ace3b7a1a27fe4b2fd6f55c969fd05368e1f85987d9c1668fc3acbb7df0086ae49a656e68aaa37c09b0d9e29a50ad7ee802aa0e6a7c92d83b2e6f476f5d06b3daa3d2202b4650aef0d7c71c51bcc3438daaa5b02d96a80b5ee5e62b52a54b821831cdaa945c70dae5b655f85df76609c67c7edbb4c77e76b403c2b0a6a5b97247b6d1eed145983e27dfe534325baefde589a385a839db69fb089b4799449b599d2a8e1e13b8dccefc5c2f2efd0adae15971bce3efb64f996a9c165beac6cb7902ed2f66ee1002762bb0ed7b592287737fa889f5a3508baf8a2c0c5fc6e3cdf731c03d83e128867f629bcbdf89b4a07021a7b5f3620a87af7477bf3e16fe22a61f2721b17a532195f0aa4a457859005452df102133f8b06a740ae328345f7c3747a798def457289fb6070e2edbb24d2764fe95a0d6ce203d6629bbaf6b96852fbde2b700d11b91b501497a7e74eb0cca8128a052f49a89a39c050d820302bad99ce4f47d30690b17841e2378636cab859a20c699a7caa6061a042eadd19f8df85d25e2d94e37372bee8f003365dea95f8ea8341826c163befeb20d50d1270690837696d3434a036a2bc37c024e44e46bdbcfc41ec5350033325baf90b1354777f4513f2b683dbc6f4fc7a4156e278cb5cde467a3c818089a385b50684b8d63d403a1b73f355568375ef035a025b0db13a1bf59c2119c469960012e228e22803a193e61479c5b91c9e9a26f383d380f3443fe3568843c1278b21dcae004eb09458ae6b879891b84ebbc39b8c691a2d227b5d26a213ac8103ece848fd574722cb3c2a885cda83a11afc49636f45262314387f36be7b9955dd08fc9fd1a2b83c75b6f7e7b047cf687c7205157a5dde773d4adcf3f3b1e02f81181c47229ddd7c840f9836533a01095d195bcb7c657fb1db634a96eca17b5b25b3d87e81e1c24d7e8c1daf4e013c8496f1701a0907b9d248146d2ef90ae6a7a496a461f06173f2e109613e45387bc06b2d56cd562ff8eacf303485221c3e22b11fd841aca447fd629cd1372d49fb27a52228fb114cbc9ee8641b522df0cf8a3861be4bcc80a1dfeb1a35a292b9750861ea9eb516a4895f979604f873935e0e87dc391ced1dd86d7b818f66c345fa9c137683148b10017f7584c395f57f412adcbf0376e27455385c9f345820116afdc4f5f60ad7ef9dbec2776696019b95ba0a3d72af3d183159c0f5d6d1e4498b230d0b7056df2fd25791c5a459afaed7931d06d98c1e23dba3b7cf07ee790d6660fa122c239b3f3f3e7c132454a027f51533885b4277157c892786bdfa7a08a1b43ff8ae5ce99bddc24fb650d599d8d177f8178894bdf7c87982578c746f2ab9edbd09c85e1b9ef181d565513def05bc3624d806a776ca9a091861e7dd06276f68de19fd2560d92d572259bd51cd5dfe2a7b62f6472b97f54ab983b8efc06edee0ee255e4c4a6acdf16dc57b251bda49ce188423d5003942a2046fda8f9a5e65392fd8b23215819e8e8fe1b0c5aac7795dafc5d2fe06de82230cf892862891e4025cf30689a714a360011c5684c1018b6063d5f084096cc8bd4bc774cb2b8273cf8417394509ca817efa3ff87a1a66294a6b653fd44d1b6ef86abe2b706b6a431d0db4c8f076a6273c8c40b1a410a98c610427360256bdc0ca38736ce218e5ba13390d7d8cfe33243e494bc10ed6cd5936b01109878d9456c83c649e12eca16f8b775db42de76eb4b5203385d879eae77452b643fd5d3ce6131b87f765d0e1029afa27b8654ce5c2a6637cd48f6d30d5e7b7784f79256a8ea9c005d3034786f80bac8ca01bc72c2052b4e9a115004afed1c10af36efc54136cf5299461c30a29de51819711a273150daebd616e63b29dcbac3d5818994e1235ac64d44a3dc890314c6257ac4af9bf4f37c51b0f4f93e45b3a2c92a81039c348b4525b350cf9be72cca9934b7c3911dd594432147ce3424af9d954eb5d36eab52e6164d52f7e2f241d92877d82e8c7a72d334cb9c9e35516a9fd487510f0c550ea944b7850aaff0e858cb268018a3cafa7ff640ee19d07505effdc84efc74834cb86677dc730c8c5c61c5e2a014a620c8881c181c0ba5348da475a7e384401936da890d3ec9634d60106da5397e19570df654c6125aa72f5f6f0981ccf053d18c3c78646b2cf9940936dd4d2b3a40bc0acef9c510b87d81b88cdca5fe3fac4ff31f7f6a62e86b91f462cceb04f49a72942b90e15d3a48411fa90bddf2f3a3db82c50387afb096d6b32150412754cc8418f61e735894269c5c63bbbe86d9dc760b64fcd8c6d9bc71c8e9ae0165bca35ebe37dddc53b55910a1efcd522e110dc4b3fec1b624752c19b0e33c3bddfb696783fbdbf9a3938a3ea540dc9f98f6022a172331935fa59968c59ee94e2ce9a4aa6fd5a384e81695c83ab2e61adba28b0e5c2f53fb09fd1b16249f3693b909d75b725bd74bae252455f283e9662b1039b0af10f11dd5c76e57311c7225235683e0b717948f4512d6d38ff7b47dd3ea5b159275e250b43bfbe3364e7b327bf810d5228abb96ebd4692ef8def23a51d26a1d7175568af5dc568aae9c1ee328c29a21d542845c39479101f95a3c372f4a04ff3a43fc7b48ae568cfec021cdb6f8656a7bbfa8cb70c7850a1aca5418c674599fba1d420246fcae6a8376d2667574a34742aa07c76db315009f82f33bee30cb2c525cce3bd3005856a6c31a732e02fc5d045ca7b7d23bf1bab40647a479f697c96dde89abb5197740a26c29b36f89ec36ecfb0e157807dea555a7472e70b72721f9d5e85a5807e7c8447785bd15edf8c10b369c6c3dd01c466c785b267e4320fff266bafbf478f9d995194fe1ca26f81f5dd3985368b1ba146d20526934eaa51f51cce2b6ad71ccfe499a64edfccde28ea55df80356c2404b7654d871b93c56fffd4d8f9710d1da88e7691304c59496096dd0e72dd5de1d9345deb72fcfc9a8fe23a76bbce9a6766eee24f8652768c2d46bc2f4905af00b2a653b0860a62fa12b33a647492adfbbd58f8968bfa1b6138501d3a84ebc4206fdd74c182b0891a868580025335399f8b4c6dcd48c3c5690fe599d3213e926afae7c88061ca21d64ea3dd4183367171eb02315e8d77a1aff2842c09020c67ad0da5b95531c57d14aa239bc1d3a68fc77bfb8d154c39454e7c5845765fa7d37f23abb6affdab8ca1ae5f6402acc7b90fe1c394ae266d8a8d2679f83581fba54de64fce11cba8b0182ce683ace4e2f2b2deff2ff9c5b02ba3672b8f7dbb5cec1a5481443851388cb86b355fa42f68732b4908a81242950893940bca019be52363843535cafca18f1ac23d5eec760b9db4566341acb68c053c0f2082b483435f569255332e5c9949470f201a3a0417d6b942ba27addb31c46013de2c551193ea8c90d47af17559c438cc41c4342e17f2d53794ae1d3572df47fd21a117f90e578cf4b19e611896a47a184b61d71ac509d9a435219655b4a8257b7e97bf00667115f969e714ad821f3e7ca935b9332c81065327be845cd0126cd971ecf56b817aea8374465e3de86532d7348cdc3d1416466f714deee3a2323d2596634372a4feb40763a126b3ac58dd09773e07399cbe447a5e329b12ec726c76650fe175bc9aa76852a5f9378758e4f31419d788e081db065a09cc00ac927cde38c5f0049d1d53a94c6f0b6b4a04dde869719bf91c425e90a52d26e4a5773284ace30a96a9646fc9e533a31501525624a6bb8d33795d489666941df7680697370ca9a05bd91d5088a36fd2287b7c7c279de03c4c2d3558e2f01df44a4c3ee7b6294a437c118977aa46bd96d2db65e4e7d099c81d8a93c39563bc5dec052249b3845970a72b51caca8ebf1fea5357232357189d8fe90ec6736c5a887c96b185709275ee2b782c7066a7e3e430bf3c83704469a8e3feb9c565aad0e8d4e3dd0f1403307ed460e322c9b034920e56ab911a02eeb93714088b0f973c799b27642e235e216eeff52e0606835e88be5f49d93048f9dda2b51eec23379ea00387dc5dac05ce4712326c9c958a9c4ccdc5dd16b3bb2f70ca3fcaa664855ab3d29620d59f2704857f4d50b4328dceff20658d6b19fab547c9bda062446c1cbd133206fb9ab8627620181cbdd875ef0d83abcf08d2e1823b67b09f43cc167670dc0de02fd4913a4135b0ca74d70e52077e6f0d21496bb70e8438b74ebeee63a760bead46b2542f41bb0b3b5ed4bda508e4467d45cf5bc73ffb24a3e213ea706bf14d6daaae5df1cc05f77a79a3708574486ede57728d35ad4064c5594c6ce25cb0ea7abf7ac4b9549d118beca2ea369a6524962225ac840e0e226b636bbc14b3eb89af32bbc0dfbf5b48761645916a10dfd8da1a6c16d4706fc702295dec182bc2a685591ead553689f539516495da72f8b4b9fe537474d108ed8263192978df36acd0d7f2a0b329135ccb2b575de1114b6654efb2fe6794ab43c5d5f60306ea0a7e348c753440a2b52ffe4af8b56867ea1b8b4785470f2f84348c2570333375283027be579715c146a63bc70bfa4e465ba4203ebbc27b7eee36ce6365e547d5496d74109c4b08c1aed877ff195efc6c981b196fd84c9222856fc57b2e48c4f46fb45edcd711f51f59c7312b0695414bd8d1f9f3c25f0372aaf860c9f329c1f8541c1eac5d462e1195cf287a302748449601e12aa93d934b19edf8df18e98299f6dd3cb679e8fd6bcfb7384734082fdffc2722169039b9bd1723c46dcaaad3e24e4461eb8bef5f5291cbf8bdfb1085af6935174f9213e39bb2e26c50bbcec76e0cb5f3c055b05b3a915f34c49bd5167192164d79f1f2168b8b2b5872b68cbe01e349b03e7ca7e8dfd2bdf2fe17db747b32994117ad152953be0b807c3441dfbce517adac0c2c0311d99dbe520fd5d136a0b244edc9d34e51138ef89f2e48fd86bee08acf44da45b5388beee99b24bd71cd3a5ffbedd56a0521d5e867efe6a46541a9e61a8bf3547c44c03d2491b51344b66a10f5359937c563446ac1b55993318f961431444b0edf8947413e15143fd316ce0f945029b357e5c36185ddd80b8445b62633044949f42169381cd2120d957d536becdd773e56fe07ede87126ed80052850ca46acf1d8e1b7b8e16cabccf85df95db6dfa80ae2679e2f5b55d25c5f5432ce3f8839483c674d93fabc36caf2b0fa972400078f9b6478d0eea3e56ba5730a980a1ace212e64bb3dd5642edb16088db383aabb3d93237ee8dd449c650d2d2f0615bd234b048aca2a805ffa05b666382117baf6d065fc477916d8317dae9b175db94ab7ff2f63d9068883d1ac4226628bee46f4bdfda46fcd8547fc6efbd2c006f377b663507ccd7e5aecf3a7638b4cc83a6898f329904ee6ea76413bef5cc3e53d45f5123df31e422cc923295ae07f2df068a9e07caf731635c061a6f2ad6ae4ac876ffc837762f134f8e1e2aca8724943dce0e509a6eeb4cb73ae13c1570d9dd3cf44c68f65d510e9790af888677f817b521e76781f082753e0c1ad7cc3a081639319879737897549120fd0314232ab6e2d65e32d386d8fce68d433600480603a12b76d9e072e9cb5c3237b2fe217e38d42776392f9cfc37ec1db9f91d5201760dbb786e38fa4ee9158e1aef3afd623b134c088cb915cc7c783770bb48feeee6fcbb8a7b91fcddf94e8b7de8900f33398c99aa8928383ec453ecc4d55840d229adc10b8a75625137925decda4f74bf537af623134ba1de522e4554c160ff1a2047c7f3fdcce88fea96bbad40e416924e3231f5eda39776ac4c8bd81654117040e4586d99b86c7999784f735cb3db3afed20eb2ac5eadaa303b0ade4273a5014d1d605c6e1cbc9ceea1930605e762b91cf3bff64cb8a49e28eff5cee2b2d61532f09f6e258101e7c9ca693b3343109839e768359122ffc2c6290757365271cff9253ae5364c60c2bb31da52b94beb8d7b2c075292d987d7c26791ebed99a37263ca18d3ae2fa6bb879c0831da6345ec96d0f43d04fdf978f3941e816578914b35956c0dad5fcf13a9d689eeb4c73d64f4cb82166c02014a56216fd077bc0737d9ff5eb7c58fde787b8ea53af223474cf768f56e85a4061663657371f45e106b80a100e0eb50604b352210941f87c4af1bfcbaccb51f60715ba19334fa56bc8439f664c065407c5885ea5f4c138e3423b01308032c0aa2aaa0e10605e747f91f39ec248f19644473368ac297bc5ca4517876bc4a4c886c9df1b4a1a18d8b1feedfacc665727a413f04387fbd3d15c52b73e38e381d181c7476c0c81520a77fd356fb448e346918382db2c29cc9209babe070a62dfabdbc8b3309896432b3ce59b174a679b739232aeaba5e37ebcecd91ed3887e3d1692c2d340eece8e4d149c7807e63679a469bf5e2a8aa46e85854766b044dd0c33cc457ca2fbf59d199c1cacfa9ef9306082f291aa7cf204fc6ed151968a0422c2deb93270d1bb0a7805d8dbbf62455b1d0e4ae598be3b28fc3ba52959821602e5aa3273391f24fd8ee566dddaa74bfd3cbd52cf14584188c16b1d4cca0408abbf576a80e08dfc8601f179a9c858aa10324c859e1c0c9896523decd70254b4084f6e4382966767c463bbe4c565bf1d0d23d756e9a8bd3788f4165c413668efe8a1aba0a466ac0f79940bbd6709ad4efea82dffeec65ebf6afcfaef7b2a45a9758ea1192beb41f511c6086e9ab543c734b92aec5d7120049e4d7c47e913d7837669ff376671f50bbd2e2b3ea4c411fd4cca3f7bbb0c0525832563db3bc0e09a31e1029ac5dd97de1f06d4fe657bd626e8fa1e5896b6dff3c3a2055e52d56656605d8bf4fc8b908e4f38bfe45d420be304e24a81f5ff8ceab17bfe87f1775d1d3b316cc0b9a7af0ad36006cd123128d9ca3f26476208e542fee2489cac37304e7fbc790d7f86fe2fb14904c8b7ebaff128f487cccad8f7a9b7332dca8cb57628b9b7e000999009a873b9c0cfc8635314fe4a54bb965ede0473ccee66de8334f062fe4d7dd33f23baba353e16aed12990224cb77c5329a7673590241d627692faca248581475dcad7777fffe01a47434f4c565faf4b964bc42c991b5db9ccf1e2a004bfa5612eec5643e03f00ebbc1304c11044ec649bfbf29a8245deeec4d014b028d359e289a02e784785535a97df65e272128d7dab390ee210a3e81b0f0e2e7ada0e7055835f1c01452bfc53e6d45e4b01c1892f9bc3ff356c5f126528eb31979927eb5eae81035d809370d5ac96b4d624d0fffb91f643e4840511b801e5b431a06b7b00177ea50c791bcbbea430e34eb12fbd92ca6ce452e63a5ff5fbfc8caf2721146b20bfaff1b87f80829d6c26c157ff7c8b518de462427e0f2b2395b9d82fb62f877ec4c18bc7d5471d334207fcaa28145e9a5dc821443a2cc85d4a657981828793be57008cba6f40ae7a7003f02b36de7e0a89b1c3b1cc6ad70abebff9619d2befc6879655870371bf891c66d585e9aa408bccf01f664f476ddfad7af64d767b856ef1e832cf2d4c8373bd82f2017afa2d5dc724a6c5cbdd7dc2b0842e03382665491b1de87627d2e46fa0b97c0d0fbe24b4d4f5ed2a62163a34283052da7869bee5aaaa540e304936683bc764005243aca6ffcf037e98a391aa929c31d90836764f4f97b5977fd584e758875d1393f057202e805c7ddce9b339d5a4e6ed6ad8504785981c97a9fddea74671ef1fa17d1197b6dfbaa5b30cdbbca20c61861240a54188b9b06b5eb2d75c29e408223b719c25851e2fef4b6346a951f41feadbeb142b4f1b468a6deefb5d9c136c89be8714b50acb8a69740f95fb53dbf99457c511040abb3a6c8a7edb509137fac0d1cba8af71c9bbd4cad631c2468ed2b2b7ee7b22dbe54abeae983f4d6001e3765d06e69a0df4567df49b0b8078ad076d98a9b6a1e339d614a39b7b734284c2688d0ab600a7a26961df0bab8ab98b28151e6a8b21979441016f7dce5f6f3a696e602076bef55eca4d69f6331275b147e492452ed9bcef3ec9c8a968cb3cbe0a9ffb1d91201b302cf785e7ad4819b6a1cfc7ccfcb7186f666d790bb26a3700dc42cd9267a20767a46e0fa0f349a68112f58d9fc868c4e5db0545a03909928485d3c6993fd9055fa6871003aa34651eaae0f314b84978328ed258200a74249315fdd4bedde8ceb9169ad8b59e9a451af1e9640c2368903bedf59de16e5159574df10d573ae2af0113897c04a0394e352125bd51","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
