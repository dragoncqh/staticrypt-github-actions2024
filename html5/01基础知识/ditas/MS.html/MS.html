<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b12fdfc1ab5feb01358b54453c834863cf89cbb23b5899a7d9d4dc96cdeb6487c698c7e8e793d5e5db44d3cdddb01cbfff88d5669dfad3e75ec00254d460126e7d59ae5c1a221a0682397e605aa0666a4c9e7c8f64f00b6409bc605b99fbd9ac0c548075de56bf80fa7afd7f465270d645bd6c84ca5a581150ef80a90404518803b8f1cb351fd37d901baa7b7ac931d4ac5dd92c6c2918a224991bb7fe55dff663a8298d99b40c579b7f529b7d0e69c0e093b9aec7dde7ff7ab2db434a03c218a204a8710605f4f0c18844b28dd212fe544f09bbe0de172f9430992740230f540fd862d723264489fc9cd8672511c565130ced195e23c316ff175594a35199f49976a45e22ed3c587063354deea3172611ed128b157278bec3ae9e3c0fde7c7bd09938d3faef5fdc90461daa21f55f6465c1f5da03f553d5f907a0e918849b9c8d45aef114a1f3927a4e75973396cbea645268a8363d823a2808a635fd7e28112ef1bdffc3dee9b5457c53c99d1efb0a10d0405d934495b525de2621563857808f4da6172df2e8f880eb50d2fbf733ef61623ad6c4d0b6d0b9b63dd623bd1854d729a6ad7d07b9a4febfaa7a55e0e4b598a43c54c460f2125c33fecf328bec0161002a7be74ab36f9f147064abc9d55de86d0e7aba2a78e016a257e8a45969b497701303b755b5dcfacfbe9330c76cabe24ba858339d780b456085e31158f7695aaaff4c93834c7e6b6f494ede871bce4070abf9f5d07035af19d8adef1b2cbb9e77ed232b22005a0b56534e5edebb62eae3b9bae652921d64e5bdae6296eae0269eb72b29a3ae32cf93da5f16e2677b2b28708f6abd2b01822fbfd4ddaf1455873232c8bf79f3f517dee221861eb776621e52f2fd66eb28754d6347b000cc9088672978ef773c148bc128cfa13a72e1547873775a22d9782ec0dc9a7014ba95be7aa410e859b7dfb5751a0253b11ae36201646b085974096fed7589934a36472aa9ba34b136b2fffdcd35142083e9c8c986cac0e565e3636908c79d5642b0dcd8cafc0836c9e1d3e4a686d3fa0ce655bf569f84b52ecfc3cae8dccdf3c974f82ec0c6f21fd3024b5c63e67fd8ec1828e7ee9dcd2275509c20e0b8be91428c84167b85e6a8bf61ed8d77bc51d70f383e9d10d03042eb5807ce7fade0bc69a8cb706211f377402d43c3b2bcc7133ebad917f1a67f21b6582ff00c1a3f249150eb460bc31f69814c4a78949b8004613aa4a40c66e8836b1f36aa0e2b91377a8575b742acc8e31a0af5fc221880a18b9c6617b88400e48b9b33a868a5e34139031e13bb58c66016d134df542a73ee4e0a17bcb32a700c254fddde89ec2b0de438f05c856a312a2a89233db55c6441d0dbe1f44980bebb9c5db01a284665e6f987a8e5eef9c90440d440fecaf5877e70cd9fd3b14bc8df26573412d4931c71eba6bbf17187f8ad7211671db73ff1b44bb3546024afabfe7dd02f05c4397ee8b820936e9e3f753ad5e0a54ca115ccef085cebfe4b940d347d6b0ca6b3d0bae9562279ae91033f5ccf627aa117e5695ab805b48fc51cde2c8250fff83e1e114b895f207de971691dddc270ba03c3975c1c173ec2b00ef4f3c6f2fae909e4e84ff7c7cf3f941703f6a41071f67e7487250acce0978ba237c0eef8bd10d14ee24429fb865e03e1f68081e9980af2d63c05c0afaeadb2186ad25e350f88c50fcb0f0e7a0358bc34e3c7a9181ce282a75679f4499f6c91fb79e3d235adabea672ceaa1fdd2ce7d2bd9390f5f53f2f509f08f32579dc5f6bd983fe01ab14d27175353184f11d5fd735e85f8d46655fee1dbdf9cb59613c3b049ea4e46251d3e360aa695c7a0ad5d44755101cb53a18a2a57cb8c86728248ab19b9c5f0887b368bfed2eebaff3e179f62b3442202afc03e4f0e84a62969636090675a5bd1e9707cc32f0247abb135db0cc7e6771b9021a8db2e9d8610ee6cd122ee2ca6b6d6ea82ac23f7a49f8d3f79526bd61bfb1991a0167932f916d652178d66257e0c2518e3fa21b058c4e21a222b177e9895f2543661a58e4ec629818f550ca3cea3a521b2f1d6e55ef24cec91e5c04f85130bd7461b5138605aa1b9854ec0441745730a012322aaf7d1a067b18993440fb032b3818c994cb08fad3723dc328598fb20d169dde08922efa888f9b75f9ff4ce9f8369d98a2694427a17dad0069ac4101dd330b5892c5d1e42fd445095c19cfa4fa13ab5ac1ed096e9bf79c24e2e3f55964fd14e31c2007663b9f38d43d60b463cef78ce475bf5d18d0ba1bc8bf55c310a7a114780d84f3049fe925cd04aca39e1c6b93c56d6b8f1f3ec3d091134a5c32dcf0e7a09d5da69734a58e38bd09158ad3c479cf5e1569fff8b0a3d3109224300a8cf106b2cbdf1fa896799ac847cf92f6d838ffc1be34ad7ac56e27d3a338b44da5933c097399657e798e1e9ff3f5f534611e97d02ecd63e579a426035d49be1133b2ff812356ea9266676152d5f174954d785f9f34755d43182fa3a0da087ac013f0d8fabd5c74ca2bf7b95694bfb411daca8aa152a53fb9cc6a5076b6ec577b7db97ce695d56a889e975e884322d044121c2fac656be409b28802c3b331c2968d9ebaec25d8c8e635cb76b4fc310b1ccf7d4ac68f15aa3c0f2bbcfcadc28f5ddc39fe0b27e2d045b4de374e6be9398df7640f689e3ad0d9e55784008e576dcc6125f2131a77377d84ed6ce6de1a4d924109bed30f272e8e785a72faab8214dbd07318b0f0f4e58d047825dbf8c878dafc2f49e90dcee34e64920ac039b4272f98805f381eb175fc2aa2df326890c6a0ad566c9e675b3e3e6fbd89d28b779ca122ed8b1228c352703d2c4074b57aae0da3ea423a1b903c548e929a736a3cae66daf87f123542a53e17bfc106d32a7794c7349a733afa361e2df1a291ae4ec08d44473c023a8f08171adf0f7e0f06db6fd85b7e7c0399b8c6a1c52e58866d067cdd4c72a00e77cc919b7c6ef2a3673ca664fde9633f8c8b88d40533e69541e7362159525557d35a55cce34289a3fda347383d7613010701511b01254b98008b62b124fbf92055ff7de5e2df4632a0d264433d702e25d2cf14d5183f468ca40427ae109cb56ff95c9132dd337a7a7a02a23282756714dbd014542cef79eefddb5608f89d533aa6c6004d450d3ea3ef13cb3cf073cbab95b077c4f885db71e9a87dc465d32d54da34512c31cd57763082a7bc21dd4997a8b03b2f002da49f78f62e1bd180f7c0e11256054c9e35302e5f06c8d9bdf8bec462140d39f2cb5b3010c8a730857b36a6bcda8c97a5e3f1a2a8490de61e52927e2c951b44d329d6aeaf53de9c90ec3f22f9763436fa3271a6aaf5be5574bc700236846465468ac66e715ed0f99c21d2faaa1473068e5b349476ba579af675a0b71af06b90c3a9c420c12a50fcf262016c687f1f0af8e6ef0461b9ecd281c6537c22f9f9996e51fe5b609fe85101e6aac459612566343f779c107c1127189dd4c11ab69cda62f1af86865643b295d8960253c67c59b916eba8ec6b2c1029f2b41cb110d01778bd67cf4ba1b2c3ee42d781278b9f88b5cf79005bfdf5c203fd90ae8db04306d4c83db7d3409925e592118ff20ff6151fa548f3808b8a0875e6b1abff219633186c7ce3551d4be1c0642083cbbf78ca43eb0322817e9fc4ce320e866df5f84e51466a85b55cf33bafb82d0c1e1dc585ba53bfdf603a880a8b3fadb73c16e395dc3d9ed85956f70f9e2468c51d6ab9e589c48c3030f24e5e7416db21a3e7ce5870e43e278516fec7a2c2f3d58cbf232027373a4f8a266b67b3bc174c6b6419261224f7676350b69bd39fb3ae0a77ce7b6ad636ff3af1a9f2b6e0c81d8f7bbb875dd679636ace4cc50225caf50b157db4ab3f138c2f5c202bc18cf707f9f6738618aba2965d70b39c3fb3205ebc20e2ba3d1041608384b2725a1f4162286e2fdc7638f6114e64795f589ca9c78e6bb00c69cf74f5587daf2982310b802ebf6d479c6a6329c20bde8f4bab4237a1f0fd469d7d914da545c77fd7bfec929519a199c08ab5125454ed1d8dd15159533083b3fe0cb7b9c874466ed79002f59afc0d9c89da01bedf00c511cebe4f4d86e85c1d73f04c23c751e0d7a729465926e5085c3d781837b2cc25390d559e2ff62d4423350d7aaa487a89a1db9e4bea1348e607e3f50e09c19f33bbd8d5fd7ffb7e4b712fef28e762b8980e4e40cef40046d0804bc3c15e6dcc4689ae3582b924721c6926327c0021a8ddcd3f89ac27165396b235fc78e9044300a867230df8992a8c4cacbeaefb770e02f96206a0240932ac0d37ebdbeb1dc89ab068526fc450add42f89f574e9188ea07b923b948059a008f30d82b6e069ac841ea89f345c760a04eae1ca9756086f692d27c4767d42df7ccf91b2a3f27b245909902e5560eb76cde9f0d0213b480186d8e75a8777a25ba42e2ec0b67b0aeebb1fbb170847f1bc2aef2f630a43b19e6d16bd1f8524198274d824b362f959c9912322094b87a75a87cec2ba800d554540ba57e085b4ddef9bbb43402a268f1b182c73155a78ca21b20acd24ac530e40465a83b48b0629e98121b33ea25891a7fad71f7e56dbcd6fbf6cea8cde03d4f5d077fbd2b8907812ef4c5526652a2ea90e2c474cd8098c81fb6026aa736d5d0dfa9d090663028991a771537bb0ee840804781bec0a4cc53a2d99c52247feb05957c3ec681fbd3df34625805870ef928ac69d771dde37e1bb955e60dba2f9f8e56f6dc7a33384d866bbfedf165311355645a8dd112a7821e9ba7c91df7aaa1f18473bb8aa0b1b977c67c6758cc1395c5ff604565405fdc855e0c0bc443f0a833c715f12cea60d7441a9c6692cb42ed5ca948ce89f32fe3a599dbff5ccedbddcefb84b2450fc8e01f7e549238238452b1249c70951fa6c3b06573088ee797447bb07407bc8d57c951cd64208b4b24a728a83faf95829828a67fef49adf0f6082ab2b8f9000f94aa8378ca8f14f0e26e7b6db85b2e3990a876f706cabd7db62703d60c498943ed1c40b3468c954352f582b6675e04ed3c6bf91987bdcad017349fd5359f3d7435c127067521285051ea035511eac5133b81757edc3702ba16bdefb40fce26b92a2d28b556c414b653e872e15e025c7f79698f2d4d73cfd379f849c5a57ad70a276195e62cea19331e9a6a4680ae34dc7065236c2d875425c05a5bf0942044ec2b9108dc2c75d67cbcc1ba8f66f91dd83ac576e1d114c7ed048aa9cfb17d394411aae2184c0953fbe68c93da12362394b5d841ffe7de2a86371f0dcb76a94f2ff397fa19185c095fc1dd43bc1eb9f15913777f11bba0ba71b8b5f223508b40555157905178793e946abf3a3ba8641da60ddb9ef2dc05c4b50b3be0cad50af3671e7741c18c9b551abdd22c6778a52ebed46ac8db616b6d1d1648e068b4850243f4cd61b20fd664e674c115b7a0e701cd51e8483c08427f078b903cc0d9e1fa3ebe3d1c278121c9061510d015b6628da680e81b2296bde6999636b795cb045916e7058d55bbff02f5ab4791dba6576cee50bb58483ba7f37bb052caa52d9f101c01de1f7c783e4c88338bfea7dd7920bac2f9ad6f58fb03c13e8c647f911b3ed32aa8b0304b2d17bbaf81c7f7ea3540ecdbf3805593e734a35e63357894a897d9eb914796cad8eb6352f0f3e4233a0a13f2b0b6e11588dfdae85ba48310ed28351bd573a254f37e73ded66df0bb6689e176bbe6ebf1616876506bc8b558d6901920790009344e4c7fcd3a1adf164556677d41eab379c18419390388349adf2f0fa55d43a1fe1aa933f84b1789c069b3c599c669f0732a3c35267fe22bb1bacb63f2f12a9e027517fda5db857eef555aca47d0113b40873253741f64530a7706c03153bf6f252c1c67af5ab0c001fe2e6b83dda015c0bf565282b5a9ef8989d76bdff1bb49b70f928a8836564fdd65353382f89d85ffbfdf06db293582e1be0ae61ab8dd7958343faa0a07fab14533fb66daf7b1a5bb922966b94c98358e2b10f4be4fc2d274cdd573e12e964bb5a739a18a577591932494b2b550ccf95f691ffbaf89bb62abec8af8c214e9308d489fc1cbdd7cb1d8b9e80cefcaf11ce68a71f8d0fe70ec56008b8476fa1c245dd446bd20648eae2f6dc928ec32c6d10c88e9bb62c306a0de2d39e5d1d4c9d823e7fac89236c26f4df6d3278ae522f7c4d6af32bbd716e81cdfdc0cf3b9c1a7c1e20a44ead5a98c9e942059fd2afd41d5902049717f9a9be55f75c0cb725191056a9f9640faeecb08962b3f0cd24995395228ec9838d8791eb9eb89f8d4bde5a4953435175576e7080e164c8614b4c362ba155664307f3e5e65f8d16db1166b4c6becb6f2e598ca62e054e8d74b1ebf61583963aa467e17a6477ac117707802a69f4ee7bbae9aba6a160571ae5cddcd93732d50445e68e374b465803c0106576861521ea37d70cb94def4ca71606d966488944fe4a92ff247b6d1d5ca80f15f691357a5864b8f8c29bc811103dc2c52a905677f7fc272b8c2def72c4c746c02d1c309ae1cdb6b553c9807428de29fdd9b7c9b381f10ccbc2e9c3d666c5b621407c924ac2f04b9ce9c2f2b7320ff32e04a2d80438c0264adcd3c28f292e1e06be6092fb8d1d04eb448eec563393c369e189c6a5f4d340258105a4eaf1a2808e954cf8dc24857260454663b12d1779f119439fbb8205909332f2ec8f6647607a06be61ec3e91c8bab105d0f9b9f71ec808b5b9429c70f4e9b96698dda8c5cb5a7498b6693dbb17e128075439f7a9754def2eb4d70447ef8f7ae302bee81112c90fb888318752aeda453df727f80c8555bcf5a401d4f4e88f8f2f8407f74ba0fdffcabafcad7729e56b1cd04d8435e70f60a09027e2ee5a7e7fe10dbfe84c3c6a654fb06e1d5cc9cf804f751b9bbddeb74fd3597bf98bd80de7afb74ac6d732e5e4316ee09f5dfd3c9f28ef475dc1689635ccbe318ba70f6a8b9eaea9fc0f37ac4b36119f969d9146ec0532b15c2510632c54bd44b14bbd7ebe021f0bdc07dde4df31e3685bf144142264294b26fdce2924675be5c70b9cd3861af0457154007571457c55cafcd235c0735ebd00cdbd2890da48d7fa2b20fee69f3d127cc6bcb8e9ee6e562f77c16ce9b227b3c3776b22762fe187c1c083a1f568f9eb6b8a48c16e7234ac1e851bcaea6e88788225e774c50ee2f3e038b483dee890bc7bfd9164175d0bb2ed71b2ad34643395385d204ea38d70c4f16087221522c28ae21195168241c32302f34dae951eef671d81ecdf84706f3f840ac41aab836212d35e67b57f328e4fd3d5bd2aff36817c4a6aa07684c5f63879f549d2a5537e1e78de160b5c0fe5795c8756185b3222c6b56fb1c14aadf8b4fb53be569a4c5823d2593687c4837f0de40d8a3c997c8bbe153413052a3a9e8468794809c0ad89779458713c979ed30734fa5bb23f3644d986bc784040dcc0ef3295e2b4acba57e7568d0ce1a7e245f695a280966d23113a3f19a5086216ec69aae1de0db9984eaa5e59f46bc11fb46ee125fbce1f90276954e13bd7cd8ffed0f7110af602c79e93b77343901298a8a043532629b6ea878644db15d619a0dc0df5e26d3b592f19c62650f73ab90f08c3af20404450238980534de7b73922399dea91e712f4cc4347ed4ca14418efc8a91512e7030f87803c60d23ce53b7a8b98f125d8513658b32ead21b772f7fa79d650ebbadff38aee4d85406d9d21f4c0726e21b5c1d0d7c062ad1fac91233af3dbc292d476f68847bf2c6ae5c50e7c0cc67b0e3f0c7856a453322cc262f6f36f407e43097a56c5ca57a6b8bf454914e60ac01c1a649246256a18acd08055fa9e334e7d477c764134bb57316a9e736a6dc1ef031fe04fe960b598864c35fba115a48a54c452bd17641a55114fa836d80db961fc4e47b4e5e28b3c2cd2959cc27c9b66498445bbe09bdd0fb192372a0bc66077f2f9cf4666b49c7a8e99ef9c3d5a7ece09a7c1f05a169b50e9e9c547f73b931588724669e6e74925bf318ce315074a2cde0c01f91047b525031f25704730efcc4d8130d3b42957393cb31c184316553e9051e9a6fc704a2467a6672e2111f2a8b8f846a8d0779618b3e6562f4ca2b0689e12f8280fcd99a88ab0775d171cbe5f11321bae97846f332289ca9aef6bf86dfe76e53506ed6c94857a3997d8c261d1aca9439a1a41e3ddab9ee19ea399d1bcf8ee359e4e8577f37459a4de7880601c47af3096aec0d5f5ebb09f2b202184fb4ebf356e40b0bb3e441b75e390eea4f9fb088b158ff6fada83caec5d8c61c1670abedae7fa5d58d5c387809e44b287f5d1702620da727b2e0489e38b2ed4786e6be310630cca96501b2e99b4eaacda0487f49675353e24b5f13586d06c12b6c778266daeee808f20ce3ad56d97fec8ca83858688713d4a8151df9541f3b1b265dfe5f9f517a51c44332a1825839533a099a1e29f4abb542eff7538088ea14669ee0b020d60ef417b37685390682c00a20daeeaf35cd7a07cb4791645f7cfa46a9577505d28f8b0d276be2044172f73b1504db070050012a829ab99afa882ef3c3885bb628b08e7bf359a7628ccdd8df8135acca0288e22de15ed21e387608f03b7f223336ef34527fe6a255f48c352bfe6d9e82b45ccc4fb0dbc7a38385f70492a1b23efa50ed5083df7dd47bbc4f6f3f3d996fba858b0855d3012198e2474c34a5f84867b7f472afa788104b00b7bdcd7fc48c7049b3fe209dfbea92f364443ff55ec50019d65fdb65a875cedd1c1d5340c55c0395a4940f5714f5222fa280d6cae564797cf6ac3054823b31470229e9765464936c36b72e5db2a124941539de364064d6ca26be5e1e3d2cf97cd8e0b5913122ba1347a173c5350df4dd9bebf64229da73e51ec52112ffd979ed3d834121f8235b5719e0ff6ab0719e27dbd9701a12a3187e8684a3eb87d3911c0272a52ca8de86446f998723e9f98930927d637335636dfc89aae149bf3fa245ad736b287c572284b30971e53fc377e78813136605f715ea2dc47ffbf13cdf05f988f9615ebf35bb812f15e6fbe41922bb58cd44ea0f90fb4d56dd5d3258272518ad4cbbc27a38323b9e24a938cf3c06c9a42ba5e34798a41a606a4a59263f0660f3b2472c4f5d4fa29c6de8cd31b484d36d99e20af560c5427fc51a43ce98df4bef2bdd714483f9a55561158ff6cf844d6d5a7204b8780c6b4f31ac9cf2101efc14323d11b43c4d50e8761dba65ea2c6d5439be6deb2432a3d01fdde2f5a289e82f49a75c615470b3b918d6b1800d5fb0070587ec3d48787ec33cafe8215fd3874e74e683897a5b462413d80859c6b0c9fc6247a4fbf859488b5c4bbbae60a533aa7af9e0a3652bda80b269ccdbeb17e7712fb5bd74cb881ffd9e5c7d748b6bb13195a93d4882c4c922c43f90a6a39149d0068c0ce785fe358418904343d54f3570bb7de292130a10e575441f5d75b62df198918b5a5a8013f40c578671d109691b14e6544291acf17278536620879392183e27f0cadf62f41ec93bf600600ee7ade16950a9cc20b6f2570f4fe3856334b0c038574352212069642f266268b13e1654dec01c9d20bbff3555cc3a8b8f4907bea0d1f292f9b4359a650399fbd0f0b9ea45cda1b2e102497484944bddaf34baecf4901e86ac38bfd421dd553de7dc929249aed1f280a119653c6bb8c536adfcae93c8e07877e89c19ae73606dcf8c274265b7acf162400018a2336a6c76e5e45bc884fe125501dbdfc6bad3b3dfd7d9988a2816cab0e8f6f02f9e97daccadfc996c896b681ff126c07b72f480b85500f1e90b750e0127576a9808ac503ab192da89978cbfd1ed85c0c1c2d84328b5b9074f722c9aeb06eb56049cfd1190ea667949165d5b53dbed0051b6c7b25c545ee7b048d9832673a739f1947260fa79241e21515ebf82e9b49b55e3a976c67fbe6b05c7b977e9c87e7d87e946bb232656893495e459d0fca6558d47d6d47d3a13976393e2887d8e9d0f3b7dd53ae870ce2da13a07aeaf4fc532db51b78e588a2edad425583d2868c7fe3147d0ce15fa9e28f5c121c464fb100d0fc683059137bd2f62ad2c9faadeb3c6a34631e0c442238deb85a31c03bde022f72768c8606715f3b3fc8af630d6b147121471ff9b9b0f4dbdb0e61dfa4f98342c1210572cbcecdb3e876229bc948d2aad3e23030cfc9b87c5437ff6bd5d8eaaf8264776e3a3a32e285eb28bc56fa7cce5a26ad9bbfbfc3a1a3c509e9c680097624e988b940839a407e64a539daf4a3fb8f2a872f7d54e689cd30ed9054cb11783e84dddaeed61bd98182be69941aa8cc9933021e2bfbc2c71a341b38ea4321d42f7a4805b07f6a7a63d5f497a59d15193f8b58f676de0ca63df0878203fd469fcba618fea199fb0179b45abfad72167c9f73379ab0f8eccc095167f08ac9f35296833bdec67dc688bbc459c32803ab3ee922394c07bf548be881d8a4c161265f86038d319b5e2fef2f1fd1203328baba22e3e24b96937fdc9a71631f0ad568f0cc48ac2ce3d78565ddb393b3a41270eda83a58aa19b1924b416f1ee594ce5eb48312c97b5cbf68104","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
