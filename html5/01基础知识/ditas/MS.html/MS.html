<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c5ecfba111f8d0c9d10fc2434fdcc22e3954f93115992886f83fee3666b0797508487ecfa24ebb7f8df35fae61a235f3d06e1733742b3631de9de2dd6658e23febdc69d680b5e019b8e295d2cef70b7b8f7c7f6dc9b12a17f448a101271cb9483926061debd0a53c1ffa28bb311fa25c9651b62c52a89e67cb99e581c596b2e4daab07982a8ff663129cc204e8ab9a645e212b869e9f2e95922d1baa654806a629d91b37fbe0d3c21f3b3a049074f5fc5ca8c2b0d30c16dc5a686cb92320b9cb29be33bf6167fa852319e583f9cdf734c323f92bedfcf4e7ef1ec0716cb39e987cf57c92c3f19347baaeb02d5388a370480f81a30fef9848dbcf60c2ba5a58bfccdee2a0ff91de747344775c9715a2a87d4d65fddde068d1696b0da10c63d66dc4949b9298a02c1ebecd11e261e3e7801bbf617e31c6de1be244f9e59dc735a9071159580ef14b7684e4d279261431a6ab676344c49ba0b5e39a77bfd2d1430bd640eb7782bded92084be4c504fb48e01599f7b04e2b9a604ce3c18d79caaffb2e8ce0e1be38663b41a1c4fc637a3ec53052cb0bbaf2e2f23f579ee854abdcf18a02ae8e413460fb4880ef29521f72b536cfae20bc212766a91b5415ddd684c75b35b89c84dcd2e6f43d8927823cac9a3401daa59c2bbd009d131a155032eee3235e4891154286f98f3c1754c6a3c81a3226a9c96d3c444e064485d63a480245fb7122063756d00d2b6f28e7b4c8cba825a01d240c5bdd137602ec6737a7af5abff74dc876ff1a9505ef692336402d3e1b56e4893ad7d20a4540061084fe2e1340eb0205aa7e3f5baf7df00c936a711640d00e9e37be68b24c8a5f14d333579dc2d3c3bb6d14928571f2e4b6ef03abda5fdf0c3075cdf11dca3e966f7f5666b65288185ae3d68499ddc956a95850f27fdf034d7fa9703ec3aea0dd03ffc3ae8bf5c402ecd364df37b5300461e74124cd1c7c8b42c27d4431595229864fefa2c3987e656d749421add9ef38102c747d80aec6f1be32e9a1058d23a9c7a90ee33221451ce9a0f315f404c17f34321c1230766ca747492b780441f10c90a2c9170349bd0d39d09e3fc371585a4168e5f662c9ef951ff110fea2962843a31223a43e1020a427db0644efdcaf524ec3b1ad62fbfa4193edf12c339598f4ba96a7f889284d71f56d6e1dbdfa1d0754943f9cc5ca6ac7fadcc0950d446ad2578fcd756e508249ff9be8e1d715b4732def38a37efd50e1277db7734635399d6b584212c41a6b98e8ac0c820d8556308d5750c5f66747c356c5153dd0ca4c943783e56505412472917ca5b81225671cbf52f597368e4cee60cb39a2f97e0408b5437264e38017b70464c5d4da459a2a092f7c939ba3a2914779237527a295c77d2bcc2b1d7d2cb8c3675427a0c224b4741c7aa978749e61ebd31a36cb12e54597b59b012396f4eac621d136337b92061938f9fc741e088eb5e76fff3869ea392cb8906b1b8690a7c9682ca428fdca7bb849e968e8c24f5b30031b2b99ccb7dfd372ca946aa48256bcd410daf37b885047cb1e09d1ba6d1e27ef299439a7bc363daa148f3405e4661929d4ae6afba2710a7eefa04f6d198f86a5330368ff5ac6addb3dbb000239bef47d5ff070d8a2c6b6314cacadf915cecd3ab68141c6d52583d58617e1bfee1cd369c7e73ae408f6ebc24693cb16d86085a1f8a68ca917e329d5cdeacb2c6aca57c9eaae7e4de20f8cf2045ead7646a10794e0162540117bce0289e62a2b72de307fbdbdb44c8620d375c77d18cdfcba4b2bab7c4f1e46cb86a9d687839cf3fecdbf76e9cf23551b5205f19ea1719ae432b90ba7e374574c8968b6a19b6ba1acfa342fc0cde9c443eb3c9ad9d56e265b4a8aeced574b9c20acdc54520af6f17b028cb31db205aa8b2ceab1a07c0cdab453b5bf03d760d55dda783b33fc52c9f3062b8803d37827e121959a85118ee6ac5b21cfee1958e98591751dc4480f980e6681f69be09b6adfe1699a10a15fb4c9b00e73b3dee3e155e6faed6cb643954a69640a0bcfb23ef446448705440c169f86b7ac95793f142f644ac13cf786e898f73f5335fbcc91262db15ced21cc993821e71d0329c86bd98e1353dd2b2ba529db926fadd9430521248de6c82c9b46a767ea571d755858b60524049fcecf94a8ac60dcf328585aaaf403e610c9c6d5e97481b4609fd630eab31edec844c3cf5484fef13ef52e31bf3024c3671ffb496ea54c9a95e11359dcf49348e63214df9700f58fa1c39e7a01f6946af07e05d73f07dbebda31347dc2dd79556031c2f74002203e5cbd6958dadba2e871d409a5dca49480b0bb288c5acae99083ec6d1dc96ec12422a566433d24862d72f4b1b727b7a5e0e461f1ef2206229d8770dc86ccd07f3b866bb75b2a98fa8103a4e77ea1958caa2e552343ecb7bcc578643393d4d80a2a45d6cf3f1a09fbe31e8285e39c3dc2c7bd8f8aad179557538b6382f943ceb62b01104cebe6a359489c6803c1e360eb10873b611c861dfb011cf601b85963ba6f3bd53ad84ce9491d781d56caa6f678cf1150c5b10451edb64fbfd6a59822438f9f7b56685fc866548849499baa35f1d60888085f3df4af6cffea7edc2042821d7a5c876ac34a53b48b1d7fa992f18852461a040968ad3f335770505aa761d7cf5833c4ef1b87bae37c7fc73cdbd37145dbf267e5c9c1d2547cd8640104c1b0a1ac92cc69e9887c659d29c348eda434b03a30e709f0a67913752eb806a6690f01799da3670b518f9fb9b913b0a96296c8c41e49b3107f6e3bc1732a95247f7a6b2fd9ed40a1d17942fed53f7183f5d6fd774d5689e993fcb5b1d877f498d2c51e6fc9f6deb33ceef64978baf56bbce0e5a22f0b10c0f57e82f638f13b07789b9cee522dc308f6680e2b27fc0220af10b250650254d4c7185353943d95880b402c588e490e9b6ef19fdcf3fb5b2f6fe11f207908de92d70f8bec97f2d286cbec14bc8919c3f0a3bcc6c70ae627858995b11c3bbecdbdb60febfb5280e0839faa32ee9ee8673202d7bbda7c407480bbb95d32ef553f317886bc48423163f964a75f83545e29a3886c267dd9df169b9ffbde93ecaf93e6fb3315b9a57cebd2d4bd0c9ce2947cc83932f2550125736761f9e7dbd778b5bf673bdb7634dcfcb605d513fe7e95e598d74a7170329da19835621d571473ad3726598602b0bfc403d0e4b4c27d144eefcca029ef47cc8023f90c4249d637e6db96b2fb0b4311dbcbccd81865aa4f70ed63c90c0cc15ff6c9e3970a4b4bc3cf006eadb2b73ac56f9c4014922b6bbd2808147dd7878eb2221de3cc6e7c76b8a277cda1635ade8e90242a0fb22826ee38caaf7ee9df6467303baa2e9d9962fbc46dae6e766fb8820378d9f09332821b34b6b4af3f9a4af9b784a3786bf3c3ef82198204acfcef4878d7d445d32a82490c28a4d9e7bdbdbf5690bab17adfe28c38daf17d002d968c431a653467a0cec7dad6294307131e9ee52ab3756464df2d5c8127a88c1207ab591ef9a1867b821e7bc719083f73957f10a989417a564c1d448084d0a27a7033be6a50c548c8796d3fbdfdef2c231c8bab0ecdaa3eaa7086ff8ebc03bb6990e58fc69dbb4fb6a8332726ff9bc263deef4930280f46649d948406066ce7042cde9638706021c77f7bf43f11e18b6e3aadb177a0ce848b5034abf9b68bf3a76f15f1bc31310c85a7e1a6941f2c9826f4fc4d4db2f211fa14c39282cef61dabda1a813ce0b01e4e84bc6386ed4756b0b52ece9c8bce610dc3ab7ecf414057b74aefdbb5c48f0c59b23090951b5826d06e52a66a9fe6f6e56fce5c9b9beef446d7becff6223811a138851eae8d00e23ab4e9ffd9b1176d9a44af8a9333bd4aa05c67694732fa219479cea04a0b989231521c5954f093b2abd35824a99a08aa9655fa174fbf47bb1c5c2213f07b5125d85daaf2d3fcd01d8bfed1e3f7a7d3ad30e21d225c0ce92a4b7ce2bf1486107ecc0ef221cfc5f192d3c279b201d9878be0c135613a230d1c53ef6c0c30ab25f97da68f14016d41e88aff505cc3ce3177e687a888c9049174a2973e3613d8bbec446b5ff34c6c4e64af5076b1272ec1a4d848b5fdf34645a95dc7bdcb6eae69960453cf155c30a12c7c72e1c35cc14fc55123a69cba27848430cd4fbff99daa4c9058b1c561fd6c2fc08edbde9c890858ee482fcdf9cc0d22e61ddd0a12a59897596e88e4876f05c8319ec67ac240082f09230b6b250343f09e08d2650cd24f3c43d8ef9782e190b1742107e5971b27bb676fa9622ba3bf6adb35224109c44dbf6eb177ddbccfbc8b56fc248f0dd271c1953484a81ca9c070f87c95726c9dd4f6b5bd4b1a6c71b2b40b071589ec390db4853b0704cb21bfc0af0f23d45963a2e09a7c4be458a6abf86ec160f729816e50a57b376ed7b21d1c297785f0163c6379e47291e27f44fa9d1e5c7af86f60375bce2aac8fc59fd68c7ff12e8f29b0811a5fa2ab20ed3e36a35081e7d4252266845d8f19ce7d915602994945e50e87dd27523bdcff0d892d715f4abdb8a50ef7babc0f63d9d33f6590f5d8323fa22721207ff32dcbc067282b063620406afe1b126753eaf63f675ad3044e8ee8f534d53592f6556e8b45c747263755893c4acb42206c86f77eb1dbf6cee64b0d41b2aeeb5b0390f253e4ad4b96a236ba5623b2e68c602daec84d1b362f20ed6abab22f28c2244a502344ecfd1d26e8db18c43ebee43e9230427fd2ba88abaef8bc6dfe24e38765f7979cc42575c54af49303ac1bddb8e6d730cb56b2bc97fc19350b04d20dfd9491c9403fddf83dd1f68391867999a14ed521521a66008ba17f6bb7521b8975ba0754662ca8540a7fc8b5be126042003b9d250f6f02e98cd626860bd614c03830769922b35f4b2723fd7b7c503c7b2578d52fe836993ed5f838819d13d796a5a3fe5109b8e2cad003017af72dba2909b53a68c249e1593d29f65a5ae044586e025d6b716d2db0955387467347ef687a38e9ba51d96c4e36d64b4040760992eaf9054c007c5e60d0b626d64104d5083d58b5b1b509a305a0152e55bc2417267bf6812960d4d858e0dc06f525c2859823c2710dcea82c12acdfe5b726aa247242523085976f68ee0de2627db42618e9c4606da320c9ce5904acb6fa6cf048664860aad958088232f334e59bfa9384343525e3220ba02261db4beb860fe311b41cfa8c40bacf4980c06fc53e1ff4b9e40a2689aa982eec2fb477a8c276521b3ec2567fc4903634c57bbe2d144b2e19b085d4e4765a14d924326400e5bad9291db07a507f90c7e2c31a217fcd68e3cdefa4d69f76f3bc30ca5d2a381b47055cc50de1044b78048204ac1d6068d50499b15815383a8b3e5f235b74b344f913eb68f75ab53f28e47fab0d68a923b6293f552287369ae7902ea2f4607bbf6f64eed845846b16c0391f9ab6f2b1f3ba3059286f3e759f9c7beab9c994e646773c7d964df91965ad7c6c1bdaa0700e526d6770c38dd5ac76b8265220ccd855c892ed6160a906a341df296459bd719d65459094d345e1f5d5dd5eddbc7977575d3a4fad6721ccc7be6688103052c155c6387d7f42469f649999f39dc20a3b8758a856e8551c6986c1bb7dbedada891d6c8baf03ca11538beb83cde171139e77cb03b8c1b62a039debbc830bc76989796862ced96f08d022db366bd6faf98e23e399cd0d6afecf1f71baa46e3d331e916e61dcf12f3377d4d49fc20a169724a703066098abe3f7b0776c81438daf44b4cacc4542d7df9db647d8c7eab3309609205e850d1beaea9366edbf2652ac49cbb1e8544f546571d9b3c690ce3d1b2f9523fa220296975580374908bf26bc8bae447df9890f928ea4b24127bfcc4b09a41c08bb426f3507d13b4305d96ea4264ccc29ca668e14686f475a632dc432daf08baa3a489ed7c1af4220d4ff5e75c9bc4692c76888819175f4e44fb3a3b650cd161d7e4c10d676d5c3a3aff971d07ff708374422b67580e6a42ad457fdaf5d360e562f8a768e98545ba3338d43a065417b968feff858b84d5171e0ae1f390965b137f1f72b5cb710bf8dedb5c3ee5814692ffbcd524b17b0f3f903491e7616e9a924d499b783502b405e7c0c9b28104355ef214139beefb30d0202586025c3496ffba5b8ac2e9d7d10a66990666ea89f1f9debc173975bfd2611e794be23229489058c4941368b959655ff74c8da0c553e34d9c8a0eac310b37c114d19226a256e44b5bb1fef7b05026f64f4a07451aa49a4f2a4a730aa8e92bd2560a93b0f5d3a207eb46392000717822a271a9ad609b35c75092c65cc6ecd22f01840837cf5793e876657f391c1459f40c209cc01c47bbf2484ffbeed3e469c2f99e11033ca25d32eff84813b61369a176af3f096e9e832bd3907ca6a9e297f1fd0b83e23da859a4869fb16ebe7485d016924b36d728920889d603286fe16e279d6ac841eb3fab55f6a7e0336e03057e33f182e296052a423249524dbd4533e24fe9ffe1f9f7b1e9bf2d8ebd8607ae3153b23c0a627caf57e85e2b3f5859319208afe4c129718fd8bbf5b8a5aede6ebb84f5f574f99f249f8e74082b0a400931e282318c9bde891952d0024d197630cc79a3f5e728d5b3eb93562e5cdc1766e1d38386897c2ac28aa04ca64bbc3703de8ffc8ef572394baa88691ce94ed1a49216289d9854de2a9eeac3d52f5178a85e1389dba4eb8b9d121d16d4d138e37698fb4ea95c72db64fa22b5787d361d5e6f663b11aa5cfd1af84990dce39db67edf25ecc27bb96cb24c193c6b05b80456b34c23bafde6eb5534460659fe574960a6f4f4ebbfa4636067df7982948f7842c88b34e7a97bef46261717c0b49818820df11deb8dbf7330bb45989f0f41ebd5a2c19d79363c911bf64b7a275a0fb359f2979856d4ddfcabd2032d913e5ba608bf5f74b8e8c827ccd155daf7b0dcf57d90ddfd3340acf3ec2b725ac89aaf64244871d4efb37fcf3b1a74ad858ffa1722be2ea6a079af503b3897bb5c152833f39d0193fb81ff7af869e7910c57110555b4cdf9117e2511b74bb454f24c1fa5730e294888f039bd57812cee44ccb78dda95541390f0df23ec63eca868511a559a04ff3ee21f64edc0eba393cfdffa6263afb3251f4d73bc5c21f676dcd813a45e4757356bf0ca27b760022e2c869939c4fc287a2cb7e0bfc99adbf0c1666863dee7cec0fea49318f39228eb99ec0cc63df8b080e650e50068be841111f88e881235db8a80df55dd827d3dec85b75f753a646b46c2ff80c2e791fa4fb9d6d128578755134164751bad4e8b76a37125e9184f5d612a73c32df1c57fedb671c11b2bed48e4f325e8f5dea987b33fa8df8b19ea52f929913a1d2efdd42c1f66e795e962db701c9b204f8c73918ab872afd253ab5bf735ea1b11d426f7bd4393530beaeb5cac98e8b722538a8206bda75593734f77d953164c9106100a6a2712a4945b8dd1266a5d66a0688e7c59cfb9fb93334294a866b7dfc20807d5ed6437f308c59a94b2ddb2edf4161fa34afb71eda372e18cf55dc4c46dd6b87dab8525cabc4120ffe7cb7d2c38876eaf2a438e7faf6f0377b8da63f157f387d3c9b07802aa351ac547d7c6da48da53e5734a9b278243a98ed7c95b769d73cac1920df75d33cb593094088fbf192d221512ae5a2f8d733af122c2027ca83a3111d5fc615c78d6e25c6adb2b0a83c0782aab6030ae3c39dfa96fcacb31a17fde8fab8b905ac146db727ebed244f327ea7b9554a1113c19b77bd5af63c89d3cf3c777f67e174d54b7acd7a2f7cb27e42eac023e6164ab4012579db267193516cc0d8afe82bd9c30c9a32be856bc96f7da66f9b469189dc38a8b1b1cf4265a824ac8f668bbdf0cf072b569feb734c8537adc75fc59e89ea87fd424a4fee9aa03bf7027ac01112b3201a53d0e91098c9787fb042d9287f681df8c7573be8a1d107561f9d5694b2230f6f1adc41251ec9cc0e7acee513ff4b3c0edb8093377f52f3da6395bc15a8dc9a8503fbacbef97dacc4636bce53299ff310d629cacfe77488652375f272db2dd898c97b6ee00758dbcd9ac82bb2e2223e0b2d6a401e6b5d79abe91442961ce60c599f10a0a467585605febe287bda29f541b90fc4400f81a24effecdcc0472368010daddd01f7d92387b016561c3ab7be2b64977207cd5ff5a2e491a65d4ebdb6823acb205e48cc6346714ce1c77467849aa9b8f7275f22719610e48ccfd4aedbb8e340ec975f315197cc0a200803b6cc8305882cf9d63aaf04cedb7d8e632950deb49a3b4d9ac7f09cf486932726b64837fce9db2b9034c4bd43244d15374176706ce70c0698a6d8627c644863c2a3f392a5b524ccf5497964b4b47df03f12e6d90391fbb65488fcabe2cdda116f8b51571484cfae19696413fb2937097a2419c6ffddee71a91a89b81584670f15fc5d9ced6c545bd223efd6927d77c029a7c7044e50081fd99fdd24fdcd144e1f3ef6606b390eab3cd683ede47fa2fbd3c427ce6ab708019c56cb91dbdfb7f7db1df8f03d1a3512c4a23e2b2b8330c519198c80b3ec17344652ce50c058fde4fe96bf8c945fcb700be4c9622bdf8666ae5cd04b6f63f33e4a211c4b8b55bfe4e72687e542729b06a6da9d0e39caa1d2bf677528928fb2f48934290f456738086c510a1bdb9f0d293420a6b19c8874bba625de33523186f05c157e0421927b9577a310a9e46083746f11fa46924cae86ba43c143443c91b11a094e06e7e735749bffc59922a6be1a4b0c84fb00409c58d52c77c89164f269579bb49bb102115eb7a80b85c24ec090157b09e0eb2881581d8deba67eda80511ef6b5945620f56c4ea3600fbf2b12611480106f65cb1324cf22361e678c0d2b0deccdb24602f9cacb89961210203a351009d0215eb8812d46ed4f83070c4c7ee48447758c366a7fe28c61be26663ecf4bf1d2de0ffc982cf18ed71037e01d0bf5ac8f0b33b8164ce06157c9a2ea2dc3e14d058616768d8ddbd88bb3b4413d13e82d3592630bb81d3c41a736a1ffde04d7313d96dbbbe0b3d3acfb633804dfeb4ba30904570564cad4e45452c4ae77857d55beb7c6752c1e53ed5d05a6b2ca2c3c0886d8cf91de350236f263a3525c73b775219ecfbb8cd0a8906518e9742d5ef6eae10d1d7a22fdcceb56d8656922ca932a58a3f73b85e19914da460f653dd71016bbd6bb8dcfa5ae3bbfbbdcbf51e749ca283f46d2bec7006c4a760722e1df4b232257ff38b3d0f412f817a661539b25889752ef7dedb05a251af9756b8f149425249accec1688c32663a2d6ccb27d42f99561b6a92e2b466621df2db52948e589e450d079d48e04acdca8a40401604f4f75cc89f49cc03feb063fe73c57b186dafe04e20fb9423fd507163320c0ab70d0f7569a43c8c7161941e3073f98f25b751b52cc5c33db188e58084780e849fe51ee1042ed93aed67e9e6c6b07655ff71bc2824675429dd06420fbf69dd2cc0bc98d87de094338962b6c332b28031b4888f61dacc40b9a9fc49831922bfc452c9084c7eb3ce1cb20c194de3e03f14b3d075b6fdb809ddfd899d086a390b64deb6913ea0164b79a7d2add516cb25b70e310c431b3bffe75b4b8cf2ba70cdf840b2e50711ec17d66a43c234930f9f8b172a01ca871e8ccb6908ad250b3cdcf475c824ac6cc4fb88cd1e4ffffe089e6bdf494729e2f9cdb508834cea54791e32d520745725b7c538bc9e5fecd52c002c6df21dd77dd0905efc82bf3b0d9b31b29ced48ea31dea13eebbc926367e3938c37043ee0f951d950df20433cad0ea82c9895abe54f7e89c098db6ca474553549858ab0fa7da9f9b1a756dc1da2ef9b24727f5bfb5731238471e4807701464b8c7ebcda6c5127eff8997dbb2353caa89106e6b854aca1d22329409cd1bb723fdeef5cd7b7812bfd0ebe78884c2b78b7c19a641bc084630d17d50242e7f1c3104a037a6e5c25aeebf13ed1044b2e5add66560ac0f9f9c40fa401b2ad555c329d979ad041618a1a3086a563bc80dfeacf3746e1c285fecdce0cf6f1d91ab195480c81523d5d71a38573944c4e3760021337c44c7f75a6755be6964fb243ba5ddaacc6e40b76ad22a38cf81e3a3b291be8b809797b1dcc7d47085818a0836bcac567170c0c49d30d47af0cb7840fb640814d3d6630129c06fc0a7474b375cdfe186286fc08c699a9b1766203221e802acf7969a1443a39bd81a1407c0fd409413a0ccad9ce52fc7b74eba3dac24eeade819cbf6f461627e7900b080498122ffd3421c4ffd444a0a517a2dbe58250fd0193a9a7fe20b54248a0230bb5da387c944bca5c1d6da0161641e9c0780fe15b2bbea0987e35736ff4121710a870651a98d6e490edc6638e8085ff23732e4ab0c104e58249694f4aba44606120c0ae8da91a43fc064de49305882a0062c6abdfd290262700bb889ab96b1842280213d54dfabca64f1688524bacb8cdacb3900dc436deb39f1b6c859eed77145669312761ca648da3f8c2a5dcb6a2ce0eb07ac9b28cf411fb1946841c3e7483880fb8491b5f1f9000dd91ac924e0f7e656618d8c911a2cc43b112f586","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
