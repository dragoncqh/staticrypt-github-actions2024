<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fadda024627bd70bffce31b6e1dbbcc1cba444b4f83b0258142fcc429b789591bdc1b611860e88e8806407a6e57f9c1dc94a5c67945dfb4b9b8aab2f3258937a55a7a7d57900b4523cae6e97dd7ddbb75a6fb7147d1b1d8138e5dc6e1fd8597bf141eb27cca7fa576c0e1e0ae510f28df9e6aef66116860df05039d1843541fa52ed7bd88aa12bc49ba5acc48522fd7ddeb0f652fd419d8404049b452e43c6a795805efe23f77ec2b88618e0c4e822676edc26cc54a548aedded40f773098b0cfba2a2a0f84670f8a4f03f7c7abc8fd04da8722fd6e1e9ad79b93b05e278fbbfe4e52726356f12d281d5dfc1e21cf1ebbbad131974047bf2947e89502e6642117a0579a4cfa0bc38976a583e1cabd1a63a0b0b6b64114dd48a254b5653efc3227309e6346b906ef9c7ed4163d8617fa27c9ea259730c6428cb0a20d016e23fa998e7761e2e0e029369695754d5cab9ca5804cada9a46040ce8afb50a18332dd002dae5b82b8a4d1721394789a534db6e1533d048bcdde1fe8120dc6b94752a8a2488b8bfc91b02011f3d5df2ac4f61e341212d4345a47d3e96c851ddf8f01fc8722f1132a5ca3d9a7a0373443046f5cd70be9a2a890a02740f93ce3f4ba780ef16fb7a32d810932d191cff648260542ae613333e79e3dfab6458f83487180b1b1d0504ecbcc42b4635874e937c940d2d19b0e3396df53835d129de77480d58d858a1978893299571805ce491e9d3b2b2f61634820be288b55dcf786e4f3fa47234319f973886a2bb573ccecb98943e9c37e92fa9efe783d47eeca4eec97c86f4141eff90a8a5c25d12e4b4dd96b0b688d58eb930f3d1705b55617e57219f1db5805e6ff7500043a46e5442c7d6bb0280a95bc2c5a8b67a0721c4ca064bc9ebe5cd5be75402f517b77453ea3091aef34fb86a71b903fecda02af8870e9cd4e5dec6a5f38fddff72f1901bdba6e62a7984c743e53c2c100fee20cd4cc9c464aee050761f0fa1c6170b91ac8eea31b897f6b273b7386665af8dd50338bfb73ae4e8f5f3b2f6bdfcc0462c2cecf5c08f7b09844672aa6f125e67318721a2f3628b030a9b16cf81b1900aa2e02fd3846499be0b56348de1b94f6f5168dbc3d3efd9a5533277786798216145555edd1f00b1ca8804741196ec65b45a80d539eb8b15b35c76d9cecc071a3a2d9839b960292f3d9b67c3fdcace7ff07a0d029564f6198f7595474fa038ba98747f287e8ce089485d2399ce21ad7340291b0045d36d0cea2e0f4e4b2d6a72710e3e21a973ae7e8495ffed70cfe6c0b71ac3e3df19238090e2f34af2afb98c65730fa02a1049a7724be49f223fe38d0732ed23b0f35aa3e6b49f98639b53cb4dc10b031b26b79ba497c4a40f5c584f787202408d0fd84752c0b41ae954502e4f5396559804384b7c753e0ae951635d228ecf891afe18b64c4570e02c4c07050db4cc2e398cc070b95a4c2611d6ed9101184952b4d06e4fc07e36a4deef44678149e4d15339b6c337224b573dd36fd3c417d4b1314ab34696a7e8d136a5f866822e5d77c924ccc5ecf7ab199e77247311dcb42b96f071a8b638091013ddd54a02cc7e1ca33f5d4ac96e72f54aeada5b8db0f6de1d44684b3bdf1aa95b979ce713da50a28ad2797c00c555bcde63e342819e786a2c4060cbacb18761bc2a01546fec99f0098d9ef3a589e7f3708436ed25e258b2d31a248128367ac5c923bfdcb3129f94a32b71514e783029d4d6e30cb1ba41c1a365329ccad6f1966638dde4aa6b932902421fc853b9ec647a6858c670a1bac18383fa6f7554cc97bd09ba1aefc9842253698428ee527064322a3179d31a367ff96868a359011481adba53dc3221b50658411958c65de14675c7c08a483ee4f47ac5f911964c1992a08fa4660ce94a1cc9347555696be7d35a519bcd0e7c0531f41bebd424536d89537c926dddaecfd3ed0955ce6654b72eab84068b4340a1640f15bb4532a4ae08dc597872b16bb69f47c9c5710e13f354532f3b480f288d86990158473b0b09766ea0720d23e3cefd31065d394e02a931781ea44bf9878eb573d4768ec77a5786b177dc4515488323caf93418f925a02cb92e7de4503387ecf720c674f12a8d391b470721110026736ca1d67f2d16f0003f8cd2572057aabd218647c9d93611060351657e6d8cc9d94a0ef7847b2b30594d43275580e5dd669fc7e6de729d4ec802523662386d550d276a19160cf24ae198651718da1bdc083b407cf249fbb1af7f7d8d933ae61d450f661cc0679a9c7b80ddf2c373e30dde1e1a72c456d7ed198e79e04aad4f25b6ac90f5d22a4ed8f9c33da27b62b92a2a44d52f763b631ad168481d7d66460005acaa2198956ea381a935e51c11d83e188a277325f2ac07827739c227b52cc2ab05acd86230724780267518da8b1861902f338f08b28b14d5a9217763fab1809f3d3977b4de81057fce1daaadd7fc74e2db0cc62b9315850151c816bacfd4e3afc69ad0c61c709fabedbd20fe97f9c43b4c7842764de2cab3828bf353bc14d777e5f5d0319f8b0db74ac383e79751b807736bf2c681de7b51c2ee8b1662f8a3bdbbaad018988ed794458427456ace819b22d007601a26c2eee336943e79f7795e69c0c200055e884793a85251e982a903fdd50a53a4d6f9ac1a9a173bf9703dcf1b6689d715babb66f36712ce465439b480f72921029006fd4635d8c18e32eeeed839ea1bbb5ffde26cbf81780a89b191119c9795788def6fb59ed9df67087e7aeb2d0159b9cf72115299e9737d7db47d6d10ad17045bdd8fdd620d1e4fab8a0dbcb912c8012a49d690efecbdc834c6c65a61a85f4a6c2048eb9ee52b8b68a48377efaa26e473aea84c9b1e049b5fca4fb2d6f898c321ee76c565e1704c6e25bda02385690a020e63928f0f198247f9f7b6b9899c3bf94cce3db1aa092aa42b7dba320dacc6de8985fa2f3370b882c7e610e7a3f4d2eb5fd73bfc0edfa1695b7052c6f7d78f5aaa32adf26adb1876fa39543cd3a792ee8df1fdd2254e3a113d2313df7eb77dd8ab906a355bbaaf149eed3fa8bb1aef516adfc23d42cf2a9492e0126722baa71205cea9522fd3de2941d058dbce5953d6f0805ef90581b9183b3098c24665fe45fe7925f568c3d963e3c4983586226b1dce02693cec70e5b76f82fcb25df621c4c8702cc5be23218f7b884a55d2533344d0ebd437de4eff42a24442d4d1d2f7233da771dc4c72333d2163f4750c8dd22ce2ae1ddf7d6372c57ac739e933c763cbb731c9946e55ee79fecda0adc8af16a5a6d619aaba73826ceaaa0f3b23af85499b0655d2711f16592b62723328a6499d9506176fa224295d74a0107e85941c17dcac08106ddfa43f97169db8ca1e2b5dfc836c0d443c157fb9bfa71a2430f71ef53d6516d7bee654a78dfe7c2df5b726f211a4b05c738a5ccdc65041d8d482ba3fede1a221f47574437afae324466485dc3479ca0ec1223914a8a7111369ac97ef8dbb17e6ba37c5229861cab20750db6efeaf25347139e34129f1632c408bf00282d628ed2030209201a370ab26b6da421f8a3f769550ad5bc8dc8a42df5f251ccec7ac8939c53612dfe9d11762a26b23c7005587f2da996f47f1d29aac90d1f07d8503bef8403b1f9f4f5d40a412cdfe548eeb0455b87e53fc36204cfac798982ba0f109722287403a5bcc4a91ff57b05f8af48818e5ea3c2353b1e58d83da6e0f3ac97fa253551cf6f5b71af00584f2946e92af090d7b7f7a016ddcc763239680897c9ae0da1575b8391b557451cae56857a98ea87ca3232dbdf13b27e0fbdfc7f539191b90a83d13ca1d055d4bf929e44e9b7256ba759921ae847f3ec2b56807b2701509caf63c182b7e1a6ed9c601227c44fe1fe5e25e0912e4b01e016c1dcb713e787b9a40de6a4eb90403e303148afbb7406081268abddbc3448a106cf97057cfb21c0f4e464fd23942b850e75a90263edb5c4421507847be94120e4e6b9fc3429e1cd15ccbb6bbd3cdd7ad603fd15f46d2894c3eba818312bec8788e055ee2b7cc8affbb7437d7001c2c44a8f973208c7d7d34afc046daaaffa8fa04e66e43741da7e969d06977782dd5239fed32a0d514e6d2b5613f8866e0d32f50911042788cbf9bb3965b9210f4aebfe5d1a79c5c1066d7abf41fab2778dca5062c983b4771cc9e6bb3654a70e2b568a49011ab3938e08782c5316b7e8d77347f68daa93ed6657da56aa2841e55517e9f6be22423d258e9a9c3ac602d974da6c9b4242046e5f59679c99452da2a0725a79b0c0d846263c37725ceee51b967ac8ae20a59f4952b6d3954ae9d1c3415051d2cbf14984fedb97237286d7311362b51378905a6baeb5fadee699020efd946721c94d9ff923cf525afe425edd995b4027ff38728021efbd5e7ca6c68cf69e85c5012c1d444a2aeef0cc6644efda42c2fe2bf6d680517841c24900957ebbb23077811106f628d01f89b5a1fd4320972a6ce6ebd320c136f46944809f9f7ca188d979aa353d9264136749052a264ec8ed7fa2d43de9185d0cba0c300b4b28428005bf07a651013b00019e4dea21a90052b107909511093414b58c97b8f7259b75d4cfec208accf479debd3a3b13f528b977e0ebf9d18bcdc807a4101955514d72e80b8f54b61d9da23c4f581489107c37485c4fc8fe04366370d8b3e77f76550bcce2bdd3c982760f8400203adbd6168adef6f88ffb0e0fa966c51b3f7d38d50ab4ea725fb40c3e5c9090f3c5762906c40e358c9d6914a95ad730a08252c7465258bea17bde0a25a52e24fa7d3768871bd109c1dc2b1284100872acea831fa451946355d4bc8ac5ad0f0528f9a58190457a8f6d2eeddedae1ed32e85cbc90338228cb8504784a5be235e19250475345101e04e4cc774e50a7196dabb763b4977f57662b3eef023036e7bb101dc399e7054fe9d5a88451eb329a1ced9398b75fea08b1466dd489ea02908d360982a6aca913f5324cb1a0e214ed0c3e42465f21f86fd4632b0051014093a832b589322afe4f733a11d172c62c44b22dc1dbbd0cd14847e6c261a94751ea8859937bdaf68215d9ed731c2f299e6e8b264c361dba0cf0b384f742487a953dcabf41ec9005f8fbb871309cf5d8d5bc5fa70dd3399c41602c90e6fb15bd4d6eabdf732bd89d3b90a2eea9a536f249bf62ec5a72c4d0f33c2e7d7476b677ee42a57fcb955203aff44bdfbad474499e8e2bfbe286e8f92491d335096d1410dd8fd8b68eab1860e806302b692fe34312634d15991a617eccbe5c14ac230e775ce860c996c2338b2bd36e880630a797b4e905449e59c5ac99bcddd721aa9fd81cb2d962454ef82e804f05a7cfad12f081139b24b8f44ee15cb89f591f99167bd29e355be4d90f2cd89d5c9e4828a6a7de7e9235cc902f019acfa93b49f437680a07e0ddfc9e06fab80be5a87b5ca479f670785d4b4e75e7651ddf5b18f54c66cd0dd994600cba75adfaac134b5d0427bde9376748e9f9b29ef310136aa63e97014db0985dfc06500ded7034709d7881dc4c25cc6f309c8109af7f2487d01408bbbe45739c34439c5013759f435818d59097d38ae0928f9c2fc191545590e32787847699acf9154077a1d0ef1764378fa48f9aeb39b74616ac8f14cd083ba8bbb5ca587a1b2902861524555448aea82466b047570a3415d7475a9c9f08f563e83970b400cb026bea16a1f917d3fe94153664ace18b847aa994718f3d17da984a8e1d89300cafd80b05b197ecbcc2ce05bab273358e3f3b01b46b0bfde382243c5d5bc65dd836d8e1a285319d6448324fd455e42dbe0bfe7234fc11b20bacee49a0094009080cdb4c88beddbc4a8f3c523236b95acdf82128438f03fe474a59127de28483dc47898870dc3395d5946b791ce42e39dd810e00f026d3d1dc19582aecfb57bc9c1f4ef9ee1442021a9f7d82476892ba5481046563571339b9d119d61e2857dcc443b4968bc7c4e347d76acf6e0dbf6e65e3f437468ed444bdef1df4a45bca6b560ab538f5be2779a3ebfb8b69b0cb0ca7b4f11ffe1413a78b5a5a7c9d30796c44b004bcec7a05eb1bec925080c5ea15a0808799daa28c62b7c1192f2ea5d51055c2acc0e78aeb2278035b608fd5d0bbaf4820c9c4b92cb7e50df01a3547588c34b37277a474d0b429da0a2c242c7d2a89cd1cb5119b499b7d99513bdf5969a5786c3314808b16781187d11971edfe75c4dbde4463a43c9fb86444b271d1b483d70542b1a77b382625c15b37aca7ed7e5ab44e54fa0c51e412b23892f3851583ac014d3a62da3671536ff2849f0c7d04d58f2e42a3fb46bfdc44573f03e31f86896f59251032b3d6d81b7fd817b0cd3c237555c21064a05501cc642e34832668a20507f61ed0de57d7dd303d207993797f75c0fdea6da989f4b1df89559d0b40be3dbd205ddef16cef4bf633be955e718f4730c1bb5b4ab956695618356fb7873d1754095c98e898ef9b9647667482a0e5e00c5fd621c656403a1b6a9928a1aac2b036b3dba4f64a32039039179cd8b24faa7dd83f9b10b09f52757e1aa1a6dd9940e987a5c099ad7139d41c696f62fbeaac3557ebfcdec34757dceef78e127cb0c688f6c63186fb32bdbbd68a51f596a71049a426ae421e9548d613a7627afb4882cf0485095e8bd2a9c5a3127b4dc4de324d78d88ef3b64cf6db2784f00a293e184a6b8a129fc0179a834f78da83c335a9cb44dcd96c1f02385cc83b04b1adcaf08c410eed5eb1b71ba69baacd48e9a4b4c6c1659b11417cfe97e62ba1ce99fe3d11ccc304d4efd82387ea2fc3714d9af7d280d57d96d79e4c1f76867758d0203f6537c40ef4ab6b42f9a74a22518295c5bacecf2055db22998c340ff878e3e95bec160710b8412a2a22560b97371ebb91b66f68b2f512c5b9e900ede05078ac887579f6d6f5096c080fd8bb65136bfe9ff8528ce4889cbb2c70009bdb954680f13b8ef6a8c2099d6d0be3d2a0702eb61f988688cc0e45d10def9a47e419ac4fc324dc2fa5adc3809b48cc853e2c901a076cc6afba3d63a355acd11fcf069e206e2acd8a2d0ca810fb2e135b1282608958d3c1b7e112a6c319e30ffeec7cbf3333ab6f1155f4247bb51fd152ba4874ec9b4783b77b9563d03e08359c5078eb9033b2fd2d80c526405e241edafe216f0571c48ff90fa085414e6bc9f7330bb56b4d431d4557cc2a89fe2d9d33c6dd74925db69aa439a1892f19d69a10617a7e6c80e011521b3e4fb562a25e1d5ece8f797bcdd0e938d9d780fd1a54adcce67dae83e47fbd6e28d5e94129262350868bd88f2b0c3928c1aa842928e17d6595166d0e27d21c51763efbbf05c9b0214e3046f453905d3839c5dcb845f0b7aeed990c0705e3503452f17a4802b0444789e39a4ee2c9340147b4beb32f6a344c0210060d8b0f875cdc99a16f365d0ff633147250002eecc1f1a1e9725081b51f55077c2ec0a6214dfb050121470973aea3668fcb4ec4e65d56b2556e641b1735be05df941cacbaa85dedd2105833b2c087d3e413621613d47d73d716a32775409a6a0f9396553d7eb5ac8108b69805ba2ba7ba0104f011179a9ece1d80f608c23623e2f48246e93176cf4cbb580d3910acb3fdb9c510c8929cc0dc39ec822b593243d7c78e4344e1dbb7e733f886673a20f01f58874af99302dc285d48af4d548e0690c9eda71a42b44f4fa72385e6aed8c5ca6fd9ac5c137d09714b35aa59b423d7cffb593b090acbfd84c3680eca7fd132c4bcd6dfb8342b2abf55c12be248288ca1a1370464d4f0c7e53874d47f48fd34817dfa01660d3ed0e44cb7a5dc728a1184f49c91017feea587cb6c3c1c52c70edabb8a5a2f37a3740b89763df0ceaefffc13f1ac574b354d3c25cbf208b1edfae0dad9d98feccb1607101fd252cb5fb2860fdfc8a3c45e48b2ead1964d1cd1e621fa3fd5d3bdd6be6153bdf10aae7197b880590083235d9cb881846a909bf1e56c397b2f07832e2205f291a65d6e04fd23336b6bbcbb98e7edf4155f253617a0c2f1d52e4c058de464ae35ba800b120ba1ee234576296003afe1bc5d702016a1e692ebc7b5f41f1fd4778602708218bdfff765e926151d7432a14b9e678cbd4b9d5c7ed8ae5ff29181ee5ed9e94c3094bd6bc7f8382c2dff40a0fe4c85e708c84b01142ce2823aa962cb68c0252f2bf15cdd32e6477332ec8ee711d0e957421435d0fb6cf724b1a4faf56af671254ae62b814575b5d23122c0202f311637cd3fb9ef267862cc124fce0dd2351e6dd1ab48628f3af5f393bf55fbbde48169f3e647a8ebada8a2f9080e715b31b3bb3f3f179dab8fdd323ef820f6914ac1912d68754111772f2fc791be41d1a78c966fb34eb02b0fb9405a0c67faa0237feb6082f0be149c7d394f91369cb0fb7ed53dc1a1094d24289aa6019ac5313b4b7000b24a46d257d0f26ebac48b9d214f6ad77ee25768005772c20fe3211cc4484afab34906c1b0d3de187b9478e929ef0f6789321b7b0fa5aa359542c5bb574cc50523f9bc1b657f2f3cad119558f7b20d2bfa929197267bd92a0ae3d14981ef0ac1989a7cd5dfdc74d3069343ecefea83fab3c277385e5ec77dc0db19a57ca15b0fd53b310f5edce0d194a2b7a066bffd174d74ab180edbd471be0ba052d7e7a21dc1e46265ebeef1620df179efc07bfc5cb13390883ee3955b90742ff8a5041c194a4ee759f75142c29e13f242f7ce103b115925d2009a90ab294354e3181da21953a03d68ad0012337e28f9645cfe54ff19d1a9ed9e74cdd4bd6193e00194f91f650eb495747f8f30c1499545b45e809336c1e1bdc8886f15183c766c5974522069f03f2427813ec6d46ee799967f8db9ebd0d48d2992d6cfd17cd655e1b2a65a61826134a765f74773664c55243fa3e691ab446327f33827098072553a036220745349acc83f9803dc2ba2c6b22c2c26c86263108a817e123e4c9e6e67ad0b921540c27440398790f6dfb405d0a6ea4f7f58c92aae8892c24ef0c144764d9a0eb4c57f5a0907abddf96b8e7c3a42ad07685cc151f1d661444f209f7e548e7a6b4fbd15f5e6efb36c5d3dcb87ae1b7661b22383508de07c2ec2d756522192d5c39020488db5c4f73eb4244ef44b77e0ccc50c60331047ec78fed64df3cb5530facb27e7509229e758c5b53c978e2bad38a9ac3da79f55bfed0ac826c449fbc6ed423d7829db5a9482fb9f7ca52594ebbdcfaffe89912e94a370e984531314e39242bf90601951e6e49d163384abbbdaf0690b2a7a3addd1eb7451a65f0e13540a41603770d79c6dc23a48c01dd9e5c8102cc4605c33339d9333f0432e877c4671e317f42c5203659e6fa0425dcb24205c2109af0aa8ad2c90d5b817c32eab95475a6a25666d3583c0eb6f20a9d1e53d2d8e2f458b2fce77edb7a624558f59fcc84f9b82385641b6bba8968110435b086d9336e2fe02e3b303c9f9da484c32996c6c537696fd6f6f87f088f64a5b22b9f5b2ff5c40c957ca1113021f4618bca827e76b549cf175c0f55f696354ceaab0555940b05865b70ffa99ff8ca9765ffc7c1872c7b47c7a68fdf380a2a81a14efc358056131f07d87d409bd7a1d88d9425fda40ef7406d15c3c815bad646a1a424e8587d41d3a4a2ba528293db8d13f02b4b5ec6f7d1515cbe937876519fdf51da13804c89bc5157cd4d2c129bbd6756fd6244f4e865942bfc6ce9f8250d93a73bdb2e11eb0539f822b976821ad0c521c32bfcd988eb7079acbc881783581566a63926dd07dfcd36e5e539d574e360ab023215a35e4c36869cdfc67ae9f4aed86f92cacdd491816efa19bb28062867e0bc1563b7aa4d51466a9be1f8bbbc6240f7dd0497c71b4e89b4d85dd7c3e1b868b3cf5d9db058c6081087a96981ac8811ed0cb18de77cc14456b2a71074aefedebe8c99baba980632d4a259cea7480db0bb346ad207e011ad4fc3db9ae5cb9764fbb1efde7114cac32a8625351741da61c6fb5ac53105a08f1fbc331bd89ce6dbabb303e95871f89c0d9637c9cbaaca13eefe48d5e3bf81deef27d9cbbd037e010f7ca1481e0fa335467f27d61888bbd1139474f8400451ee994443facb9fed4069a925a6127bbc76ca60ab684038992dca3f7e47dd394058c2a95245a71dc15a333cd45e1dbb45d53c59c484b110e5b428b646d1bce9a1917a3cdec3000ca970ad22520de2255e898e99a29d51bb141a6245f883dbe6f1a6e0c5aa366fd375ccd5fc9c075d4a143422cdcbd42edf9e1ecec96aeb962dd92d57faaf2027c6b84f8cca889daf33d7700bdead31ee8742c96a5f659dada36292a1823258ac11874065450b9ceaf95ef7182d8a2434be24aa14eee29addc3749b5e439e99b4746cc258761ad8b66931d31a05b98b20a4b0fabdcf8cca85b8c7a38648d2f4462141d48bf783fabe8e120f3fdf2157937bf48a8afad419e0a5104b6b0d0e097e760d9913933c290b04139b32a73963f297189342bb30787364d799e5ba2caeb956dbb719a7bb985576481049f70681059923054b5bae69ad325618258775bfac74fb8bd1152277df23ef28619c58bf1ccc742209e8748a0526dfb7be455dab12d75a737341891919eb48fd2a488be7e743e3a82971574a615423e563df4adcfb9304545f5706e06799797a1ac5b62ac53f3db3fe55a9c6e3c4abf93023bdeaaa898c23def52e2990a8cb1faad70386b9432b5e33006c399588205b22883c8d71c487a1523c4a7c5e0740845d7f864bfc7a66c73193f62629e1fa4fb2d729cf427c3eeede973100bb8c9fa753fb5b2753553d793748573b27acaec9ce92ccfbf08110019dc72788119a814739d4635ec77bf305365d09a44913f88f544aee0606344feb184086b9ec3a8c03fbb1b147894d8b74b0b9c5b77d857b679d1e5058f3a97f86972e74901771462a992b4e6005d53905647f6d81f29e193f4b5f3f3241a7837c87eed33cdb9d58a25587c8ae2cfed82b4c2455e437f2311611ec798e0d62d6ca67dc8c76d63ab538100633afe6cf38c251ad4997fcb0a8eea88a0ff8bbf158aa531270a45efe7808adba3944cfb4e5da99f3074f68e5aa1cb3ac0e9413e913617eaca86221f0ade6561cd99994b131074a4b03ad8b989171d50c4312fd0bd67e2d4ecef5c23ea498f062b726146e342b86069d786d346678269f2e1d0283d4df1f51c394e873fdf132e3676eca5a474faa2b516f08dce4a0f721c4d3d6252b5cc920f4389456a7d9f52fb1eb56fe5ae83d65e036b06644abcb13c1d3503771aa3114cc17917d7a4efd5460c08c922fb003bc737146cbea5e14103989e646a295ee45e38070de6ede48a8f5c0303135dffde4e4d38476025db25f1cbe3657f4d5363a6ce096961923095a9dcb822eedc2706d50c29965c547e4eb3ba63740de74c3f55c32849474038b99bda09c6bff4670d6d80c44507477f209ce5d330ac37bc30c1f123467aa5087de4021da30e42f1df333184fd90d34bc2b5335226bda2a17a89317b64f4b0b9344f70f74c79f9379537c2a6ff597ffedb7c8c650ceaccc44d214c05ea5be39a440bf6671df83d66c1575800bc704b86c4e9d323a389f7bb4d8e915a63b71151770e68f2e3347a1895123b0c97c4a867752e6a632c8c7aefd5129067ea7bdf87d24f846eb45a10b063e0df030c23f645f43aca02f0ad4bb5f4258951b1b83204cf7f2676d46ca29008c0d3c45750e3b591cf41bddba1fddd895b4754630d81c1d7cb4f8ec7d21ca438c82b146694c86747571f769168a3d9bab34c56679d11180fdaf4fa59d2b8c80d88ba68524d2bceecc62d6c4bbca8437f4aae7aa7ef9624fa1aefa2024f0e0dcc4d8f16608d7b172935c592a24162eb36298781224d26125d463c7d0dbfd49d7e2d7cf8f6b78e64b7eca30e50de72ecc76a9d139b8671d56cba52f0d462d2ce6b5f607bf099d37318f95dc3d741a22ea5c9c96cb0b26fbf616259258af498dfaf19815ef6d03f12516c5471b71bf983894838f5c88ca676f0d92876f4cf9c7f9e23120cc3cf5afa90de982c35f02c69938dd575cc09946a0c19e85cf308299a1038852cf2275abb2087b7c0232b87e7aba15ae20f1903b8c9be7ecd2b11b5b0bdd0a02ce4995343191debab0be473b7bf60a3dfaa41dd0bf0a24a28eb1ac09bdc2cb1081f3bc8903bb523aaf7023f98d90fda55d98cf4a3477d9b962660bb13796532b1d0f8fbc91832e2b3461a4f41ee01dd924faf7aeeb60b0e19d1bc4dff5470ec3b22ebe66bb4219c5b9cc380d2267805f45947aa8c1eb4f993889874e9c74905d6cbf7ee2466d52fe04eb7232260945ed12093d7ce9a69c8bec1b9e92cc9f88ae0966de2692e6a1d34d99a29cb6e941ad5efb3926db7e77178916f0f2905c1703f4ac79af0814d256f1329f8f34253d1d5c7c2ecdc96dbd725b7e7e31e64243a64843a3b4aee23d38e0a47c4c468ac9fa0980f8f9909c172195c5f54cea1ebc2c4daa7c95481db61edd4900ed5d458ab4396669bb0dd991aef59800d50d0ceeeafcb4510589e286c32c58238cc199575dda9103d3b18db886c479d64c6077612440a7b87967caa62f2022b5412f9b6cf26f5fb8d6894dbfe5245251ae36a8552b1102b31cda94b9c26ce2d4c55bb24291c1287a5d2469ec370bb31df3906bcdeec97140c640b8955502a35adda8f12f0b2434ece1754163a610d056dbcfbd2f2623ae1cbb4ff1fff2bf3c24540df4a3433f287e0ed1cffd6ca75479e8ee1df06d4d4561e48312f2c477de1bd0ff6b75c7ce11f4ec45870a48ff4602bde83f1c4bc2293158d4c08c43c7e332e60c878dc6ec9f7460df5167706bb4f4fdbbe2997851926e1117d9af6fe02181ff0ae7883793bb6ac1307c4f0575ca097408fb0a18a007f97e7a089f3f91487932b2887973a56cda0a1aef26bd0be6c4cbd13e0c8783125157793bb0a03b4e8aae06f1b69136bbc42848824286a829fbce838cb177fe0af1e905d20788f2816d337375f07e8c843f9aa2a95d94966c5a3f410b75e38ec01b2801de0c874930ae56084c5d8fd86006af9ebea255f3e96e9d78530c0d40ba94c78c5be1e9230b0e8cc69f10664e22b10194663a166cb0371d11bf1a228c3cc3b258a0f40299f69b692e9ccf4516cbd92412adf23b261fbd65aaca9dfa5d87077c22dc7450fd1681e5874c75c5f77d27ba89f5343fe39be4daab083011f902002cf42056cc964e7afe6e915b294a48d487fb9a0923d4ee5e86dcbe1bc5dc0a8140d6ad953e0a6f0ba1f45565750715d1e4d04e13fc51aa29c8bd9cdd1f975fca56da4bcade875062c9b708d26b2808decaa122d7b08b7aa20776dfd4453b2a756884eef51d449b197fa3f45b27cb29ab61e9aae424f663e6dc88f9e0e58902264ea20817e72f8c0a2d203474a3b6be3e386347b617e98678ebae55dceaff3ba695524e768e1bea87317e696d84a4990e4d34cdb1f00932ecc8526f46f19b40bb22d5fdc0b211b38f6498fde62af3d6b0ce07110ec8244c71db15e00d507d6108b5c032d28b33db5f6e34faa65797122b8db7cc93c114868f62b854c6e7b9015012dbc95401a242252f677630602e54bdcf69752fdf5e51c4a689302a860ccecc5ced3f55ae1f2a1e9699e7e42df004d2a159ec7704008853673f2bc17b8e824391473fe140843fbc245396bc972fb1ce70b495825a54660added545c7fa22ec1d6abfe912a3536080785fa25258c5f11a7ed702e5eb6f263e66986c0d950e92dcb30dcf7585720cf5da64f6cbcc559b4270321184b50fb69b366941854082d9f17b288f1f23e104bc3584136d6321008a3c216cea7d00f9a48d29c7ffc10069065a7783b284d604552eef4e2fe53157bcaf601750d198a4b98bf1151e6df3efde34be72821216f783fc095bf5a0b9e0172fc045cdd7c0ed69dd65570392ca2d8194b772ebac397157027f8d89189a0945cb2878bb27b73116f0e27a4011dbbde17139de6614fc43459f8c63a9bfc617ac659fb6480de405502e4890bfe96e2756694e3240aceebffa081515b03643aeddb61c03447bf67bf9923aee683017750ca6092221ebeed490655f0c14bff2cffd525917c7044f60bae703bb96baf3f22f1d3ae211fd2e3bd35b2369954163d4e3fc37db3b237fc74e8d9cb5076cbb70c542643cdd4c872c69062077188f41fa6417ce07afd249d31a00f683e8dbcd15027fdc40eec454e5bd536488676d74a3c59b9f852e89c0769bb635827437d266f1f1e7c6a03a5b53d019891e44499957df49c344f957490406b3cadd632ff09b98db8c02adcd0bfae9c5320d6078337cbde9920b8eb51d8e1ca1993b59606f15b320a309e41842ec5a9bc726df42ecf41a49980e98d8327c344d7eec04f38699137810e1d6246b6b8bdf4d49a7330df838e42dc56b54baafa27c4053acdcc31384efadbf479d33ec8195f6cc7b1a28a853c846be7361cf268e2ffb7bfd96674638e8bc32587709b3e42afa010186d19dd0c4c85fcbc71c45994187b9a958c5997e49120f48f005c0ebc083682048978bdedba6f04442533ee84d799d6e2811fe3f96aa1aef6c1e2e7a088d465f9949e8908e4e271d110a687af9a377e85163f4b1e569d005718c75be1aab6e9d454b2f9f56233e8b8d4a1c46e2ca75f9871f4f1547f4a13da71613b80f7a45cefa9c6753650941e23cb1c82429fb0d9b0e2cfecaaf2e9517b827f1f2b63c9d238cc728ba830d6d794fc0385fcb86f935620f10f7773ca2b58da7331542fecb5162d5a89bbd5455d4ee76cc273844cccc5a0184e6e59bffdd4cefd468de18d3f2990d92075e72332175b93d16b693fc7f1ed3bf6ba057360ba01213d82059f3e8a42b8e9a1db0845066627a3de0090098032a5f973fce46080f9772de1ee3cb73b39bccf058bcd768f2f6a07d0468ec56ba79caf2dd1631c3499099cf102ef3b3a4a93b86392ff3d7b2dab191aea261da1117e23a53f14caaa8eb609069f01928f1dc5bdd0231b088557643a9c258ce98c4456bffc884af0a40615dc753cbcacc4fe6ed62e360becc761064af763d851bdd6ab86d48a718c2eb86637d77177db5ac689c8840d410b01e40c197411bdffa648a7c8ad574558f4f5fff62670e79e0ea14b61914670d28540f358bdd8ec42bff42f462817b34f0ddfa2aa74e667bc337492e7cfd2bf23cb7830a29a90920c09aed5339e2248491c8ecc5cc005ea63fa261b2a68178aba378dbf6cb105b882084f98f28dd4ce4d343f47ccffa3dcabb61132d05700322ae0f001ac80c3865ee9a273cb1446ea6d22ccbf549a1f9cdc5518ab03141ae6ce4b90e0be41caad53f4a1b76483fec1ee8f7abebd960eea4baafbf101463c4f720ee70d12784aecf9b2412068aed2d22984b7276e2fdb0a4a268f68f2ec442b4fccaadf10b2ded6548dae424b608cb6ee4dfc85016eddfb49c13eef923e36a3a53ce44e5c7fbe3c69b481f28805bf8caa9183e98c110de1b5d9a0df6f9e6f586e68e8f3a95d8a2edd45f1cdb7a726c33c62176fe83cc01da0eabeab0f82c38f76a1cde4fce053af40f50689d7426541a34ad11db592dde57ed3946b29c3e2c7267f5bbc94206257d1e0fb22f7dbf58dc4fca5c1d7010d4d4b12989b6b232cbd9bdae14a4af971fa8e010eb4c6276bb8b515748b5edef9fe6a90aef6491824ae3913d24782c5afd953dd7741c6bd1f7f849ef526d23c5e46ff5b671d7e5d9c11ecdd1b88c50397a09a7477bd9c9a7901d8afa5760a2782b3941b0a92c14fa21dbd9d8d71231bb3c8fab93f4c2a2e69ae76bd58d58c36534df12024cac48f22dacdba4392b5bdd7d886cacb3474295438173faeaac6f63b5e08a234a2ef041810ea047593517c2b84105093b0c3d5e9217c9378d85bbfed3f8169f8b2035fc69a88e366f36648f5710d1fa6954330feb963d6989a2c9b292e39b26525f74dac33f1c94b35db862e06e4a57fd8632a2458819d13a557038db07e8527b6b05460ed16b2e75ac7353fa14b92ffbdcd1bc9b6955d2a82b2b41fb3d7836dc0343103e7b41f96063e5e0a996e1aad824da2a00fc251305b441384aa6f6e1998f093ef4ad5f2acba91addf055d17a19726e3a628e3ec2b33da6ec671755ce583ed5c246768863e1393938dae610cf82fbccb32fec49117089f20fe19e8c74756468eeefe1dca86828c220557ce666d1887adbe2007e79550ba14f3bd1fad9afbf2dbe4a55c595d62835a904d8a276629312df0da7d269008dc14d22688e7d1a7be902ee105d86b5f281e4976a752dde870b6051f115075f4488d69deb778b05562c8304dbbce32f8e0ed6330e2f0c777d1a9f70a110789ec7c2862efd447f2251cdf0bf6726b744c3aa8cdace28315888f5ee847baba16a1ecd20e37f17060fd33b0e55d52eb89f3c1c12793a611eb27fcb385cace3550dfc38aa9b048054dec2b7924eb463d66d861792cdcac2053add6c2a33246ee9c8b76613b3ce8cb9e23c41773a011e78e27f7a4fa6038bc74166da7d0252137a790f80b85c1ae437b7b9a2f1e8d57280812b1cc80da3b011c83a2b0e6814561ac3cb9e8112fff1e06001c0fc3a5d3355717c176b65effdbb2e81f18b276f906e44567dc8c027aea42cbb524a787c519702d7f85cd01508777708d456131d56714e83b96f45ac3f5deabdaf3e140c79f20e8cd095cf870b48c476a7aed70afdaf95233817f06cd6fe64a727f2be4a3c3fa98c1739b09eb9b9a33070005e8946b87eae82c61cd9cba5c066229628181f4fe6578aa4cf4caff3c233979ce0f67457ecd149b7bdba4672d703c4534aa0313e558d0be117c19ee8d5f3b0a0673dc3eaa6ef7da569e6741bf18a4c5c2211e5a52aec60436b6666c434b8043efdcc48f74bb7751101e21b4b458b28c95eda112cda22a9acd02894dfcd6e71f6945707adf35c1f56e042167e2d676330b93b79aa389315c4b2c55d80e6a7d0d7bf7769a07e2e9ac18223e60ad19d52f3489c0d07fcdf5c462221688be5a57b19bdbf8408a78e61eedbef0b1a7559605903e4d1f7561edbd6c7b9eab408aa38a413c2c321a670898969f7dcf3e4ff6db129f5952d00941374f719233125ab8f94a35c86968b4223a49bd826f52001b0372a36bafbc82593d36532c6cad3561b56f1d901af58002e388c51173757ce96c83433411d254cf4b2be676a52d482ba17255ebe10aa784a6fc6d5c9b6595772b7413a2b7d647a0b932b458db16f15bab1afb96487c4d32276e7f5ac178c978843a9d978f01f0f0bac151d3e82e6cb45735d7a319d807b619e6b4db92ad79a3afb35e9461251637e3b8a2365cdc340f9e9cc39fd0fe379457e5e7eeb5e7011bba08a1df2304e12a98785c70f8a33a36b5a65c03ac6b794b80671eff71ced91cfbe5856a65f33eb97bb3d89f60f49bc05f90a3954d51a34120fa9eb22674f27e2e388c408dda7de39c733394d8c6374c1910c0d9c111db3b3705bf9997dd4b281a01c9cb527cf2905725d163d0749991de0b90830b5dfa5630591dd47e4d89f546ca6a5aa2bc8f0c5ab1cf82025c72a68c55a16312a8df4f86c00a35ea8aed4dd02e7d2238a91a78a52e0da42a8a210536eb69fcf08cbc421bdca00a47f07aa21b913f9fa7bc289fe53983b038c345eb668bdd313e61bbf0ffc1a794a3dfde61c24c7f96a0fe0b5733b338c2fb03db13908da6fd0f32f8e324173fd3c6d74fbbc204e9b78a17c0f96676b05917f3e79236f17ee9abf1530fe9094cec7f58c96716107844841482aba9203a940b26471e1d71580915a0bfa26b46ae2a12ab5925d1fbc9a8ee4140a4c1c8c21b0fcfff1ef8b87952eeba102658184f1552e0cbd7b1fcff79c8f22902e4c143b58e0856c6add1402b36820fc06fb1dc8faecbc7099d8d4d158cb2f232aca1fcc5e608592a795f578674073068bb1a5f72c1a666e5d1ab2064caa9b3c2fdb8a3053c0388058543fe59fefd9aa59f54603b1119e4a980ffe7fa40d78078bf9c48e2e0871cee691bc79285e6ed8417ed1f914f4e6625f3556797364104ad797f39a7bfaad4338a726ae2e2755b525020513ac781a92ff9f8dc9af4cf23ecb01972a813eb0d6fb5e4a807c2f2007cb747b792089f69e785304ce77b4b6b08889b4739a84f466b54f66f0a690678710c7298ee9aa5e2b4596816b0d9bfdf95101c521c88df628bc84e14b16dba770d519802c28212a9adc162d15b5f0d16aa1a70e4cba007fbf28577ba8009f0015ad6da21160ad9c4cfde8d909899b24283d10ba0dc75d3dbafdd561d2f314be517240e92e085b9ea5ce3ec6eee2b2ad0e8e8cad11178f8c72e3a0fb5b2e6aa18feb9e08ef70c778d094a2021d6fc89a7a247406d45ccfd123b757e9ce5739618bb9ed317a28b6ad09e725d43ad110d42478903900f8ed3cca6e485de05706a7177314a28c9670b8f77156eaf6f6837cf84141bcd9f6184149ce9330d277bfad89e733a93ada888437e498914deee42caa4ba0228f51e959a9ca385a9c8e9ff6dfb1d882336a12c781826a69ac255edeb154d732608650945b8a781faae92a5fc053f62b691219f397f2b47fdbdf65ceea9ee6dd0aa167eadc90bcc102b8f4a8d7dd6b1920dd69068d9e4167b24eb9f045c454eb30b1570ae709cf0b55942c406f078c784410b3c9d88b268f7763fe55ca123f3c9a97fed3edf550767d72429b74f18ef1d33fc7dbacc21d43c229f9a13775793ee3fa9b347440cfbf270ea4cf5a8901bcf0e8cc39d913969dea96d641c225831525ba0271338d4b54f285e77904e2852785994dff20ffbd3a0e17a7c43153600cf1d2a87f9135e8fd524599c04dbb012fb41a40376a11f7537b3ab2b69377c91d3757f39e6e574e706a7a4db779d123a231fb3d6ebc9ee51e48c3532d7b35890c1605e8002bf36225425d53608055f9caf961677bab8c96280af8bfabb3cfa954f4898fed71b56a19f54c8f946614ea4c51be86e566cbd79fb4d18aedeadf1563266977c02c5560fa9f5b85c171e8006a8515fbc90648e94555e6b10970ed82705ccf55d3e68ce02b4305da4d67b3adca45e59d4c65573594cc676a6c6bb2852935ead6f41cdea3c3d85c52a7deafa4734d7868ff57c542a0cf92cabe604895599a0ecba8618c5535b89cc35195fc94b33a09a9e531c96e8129b5855b2eb165f36b4a210aeb597a02c5660bb1794798d4cbf283c5afdb6badbe44be4fca9500f58e9d165365c778aab430f452c1f25efb2b15e2966ab8a86c237ce18a7b8a9876cf74281895b943b26a800de1d7498ac174d33f94469a83e47e3a861de68aa2d3a61eb1e496a246042cd8109c6e1a69b6214cf88078cb00572472eaf69020e3292a38393d83d34a56af869bca0ce5e1a40f7e45c83cdd00b35f5c4e49968d6bc06e71cadee0c4676cb8e11e3809466bf09aa95e8d77fc594592afc0cd86314817f9ba0354e80f32b2abc720772f1c7d200be75ee341fa965340d0486f163052cffcb8e1bc3f1191767d9647f5cb20abcc6b4ce71fcc9ad470629c557137542d4f7b2b8b6ea63cc922a191d2f75d1653aad3947e9bc6c62c79a4c1df377293c8cbf3183d0e7ad1cdb1ae6093e83dce19db5ba8f44defe0e05c9097db287503c6ed4b2a31d423b232cd03f8a3c71622458a58035eda6186d0b9f4c0ee67380b4e9cdd13962cab2bae299eb9b7a280f8e332ae0dbdf1756a6126d2feb98347e76556f383456997f14e743b6e15672008c6123a7683f5cf59e2f65dd66e5cf583519625479051bf306e0ac6f7d5ce02dde943fdf71f5d30b56f6506b6b60e2c6a46bbccfef1d981427bb3b72763cd56a1d316f782c6d2fe06912d450bb2e67a334b6a04a4d81ad1a1859d37058b3d56b4574ccd981ab0e4a7bdfca3a5e1617a99555587bf17830cbc6d9d036347369c753b8db5b85f5da097368b7a5ac6d3cece00eb004c1c083ac7e27f040bb53948d99afbeae8e4638601e97049cdb07a7c3ba2c4cd02e55af2357b4fa76dfeddbba0cd49610d3f09e5744010ed40b30ad4fe761d864de88ff4cdc48e59c01bc5c226b8acdd61c4e223a4759ad191276a27d33969853b75fee7c75772ec7ebd12d9c6f90030b5e9d73681df72d7ca4f3f8c34b59942b115f6a3421a5589a1f22a416dbb9364ede7f5646ba06d18a44d9273ad2a33e56c6445d1d1930217f49afee23a1af434a1cc63ff77aa24abf0bb57313d38853264ab31ff3a36b2f9f6593de2ebcb1691f547689a7c38137f49e54aa7aece88e406a513ecc207bd71283a888afea2a7bcf4234ad62b0cb7785a10e5499cdd562276600b468fc9e9fa3b7b6ae48aaa0b8269d8994159a0e944f17b37499efa8ac042256980ff21ed0de45e4ecc5e1beb19d955c0438b34d986f8152cb00b312072c21c87bbbd559f654216d0481aa1478e9f8caa2b428805f31bc03f926c4ab9c58af7839b85d991b5a744a2e9562c359d7ae501bdeb05b54485e23256bbf66e4ae6f636e54ca8e3b9dbe0963ed70a828dee8980d0d1c1f40da0457ce06c6368ccb11b9f62b95e266510489a6ab2734d115d4ed2714a8d00c738c334e52cd9fcfee8d5fad52367304869130fea1334f0a90c9e2cb8579ef133593948881ad263c1914cea139332422915390c6a99dc1c0e04bbb64545c056e7a79f4b0b28c568889f58f584f73568f57256793916dc8a10eb0213c0a9bc727f8d77f3a037341edad87097e7c380b3b1b9613f333f10698fc7fde4da80200d04ec413c6ea1e7d649afde81180ec441fe2a2d162014bbc66d715117e6b95df55a4075657d2e2faefa4c6aee74e1ac1c38ae32346ebee5eff7360ccba38a8d144690bb064abf1d08c85d7e3eb183ba896d59d678b6632fd9a4feb6c82fe2d6600a2c25a77dadecf729c61b63e7544d9683e335a5159a73036540650627d56ee730f8dd99ab8df15f85b910359ca6e1cf325cad5e83c51e10b2a722ece9fbe48c1678689f162779b3a46511181cc6e896f9f63e13d35e029e981906ab9a410aa3d4e30c543e1a9ea9ce9ca31b95a96c7875dacae3cf8a36c374d3986d801a031d1ad93a01bd5c38daf134207a3c12b8d0493f5c2c9ddaf393b87750c0418cab70ef12decfb7c2de09a09fd926056f871ccc2bb66cd11d54877c704d2b572409f619d29e599ac565069e467284e630450c2c32ce9222a32b76edbce346e0478bf6f407c2024d54abe8db1d63074c15522462cead7a530da578a87ffeee75e1c3eb6f1856c7a3d9144241705dee72fd3ec7dbc9ff0750565e0d8f5e82d4961fcc84413635945c6517df9d98c832e8603e690faccb8da8194424635ebc8733014dc659ed447873523b23e1f38d2ca9dd7b238c9647c3eab44fe40b83232bb94e8d5515dbb87f6b6700451e5aee234a9d2baa7d672ab2aa33aecf5bdbc1d2010c31a08e6db7a1979049fe21a23b40cfc68a090bc160d6e502b87145b548f99f9d19c38b04225edacd2de0e63297fa9e7657d843504f82b951d2742db6e4d3e290df62e8cc65cd0ac6a699cfc76c70fcdb3dc019377cf675bc5d85204c6940f88ba2e682bc2c675a2da682b89932876cdfcd95c137846fdb8a343b11e5f299aeec8856a359a56585ab4ab600b55208f417d78a938574ba2f8f1295a35b61013adfd399921e3430e42e0f12aeb97702b2b2cb75546fb2357ca8f55738a6437c27ff9f3a1852cc966351f51e004cb6d69b89829974302826ef9fdb587cc97089ffd72f6345abf62c2b625b1481637b2068b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
