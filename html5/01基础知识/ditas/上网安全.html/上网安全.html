<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a85db595e1402813149be556e46440e2466b6bf5ba630bfbc21e82ac54219413991846f246454e83db0fd0cb2a55fde69b1f2ce0d09565f0c9c6a038c0d5ae978bd4b55564f060711653ba802fe0312ea408b353a5ce8f431792b6fe0fee8163949684c0a54233385097eb25b3a100610204d201a6d0284dd2c309d58401623d0236e21af68377ffa50fcf232ba58f47a4192deb494abde8a421b356108a446e2f79bd1febf321523dbaea01983b4bbf29f52d5e641ef621a5c75d2d981d71c89d40dec8ab77cb68d1809f962da9ab5e1d63770d7cda0ad17c1271281f3e3f761fd7472038790c67728086c978e88f38c881af2a509d0a6e304f16bc79eb6a891a82180ae583e09f654154d35cef525382f26f9e139c2d4fc00342559c6a64cafa1e4ae5b436587eb06aec1161d65355f6b81c4fd361c5bdf63341d2c1b52c87ec024f47f9d260ae2ba16202614985bdb68013afc9a4d217e77e1e0fe6fd9a6a86ee39a2a96484eb89c1c9695f12d6e0afd663bb668a305785eae91b5bbbe407df52570a76369892d382419d8fb8a090b82c223e417b74f765d7adf7258eb022ce16e8560e9b9124ce875d378fdd5d0dfe2f41d6e9f514e737b32f24ad47ff3979f10d3ee690e49db5d56d292a2d81dce3f40b3123bf40a546c14c2e298ac32c1ebcc6d4611010afdc77cae275cb9f7d2a401fa711ee3dda398b2b9de35f30a118aef430e23cdfb0c3aba09c489e05e31a6f1905eeeef5f65cd38403b54c556979c8666709585e151b4b423c7235b2138803299549372bc5c08db5a2c8a0e4805d2779857cb7de7f837394f8cde3e5df9eccd56463ba39342473e4aa7f8397e75b51ea2e02290496ab808e1ef9037baaaf779b6274c8f1ebde225c91bacad2ecb0389b505ef5f50fa6fd1a94b5e19174393e38f536ae7a678a09c910f3d8675299e676d48803c5aea7682f09b2ab74794bfbd373fc3df5a51f5559aa82c1777cbdd745f075c596e5ca86c4a256dcfefc9c30f608954fdb67a29b65ea267b1d7b70a4bce017aab0c2e87045e17adfbc701f6bdb45c8231f5e516141349163109bfc88ad3e2904ab20b77005ee1b4ed9948a43a156595e3192a97463cf1827e3206a97d0fb68239c4b1dd5b2062ff2c42df11e579bafc34a5503af65df049a5b7914c3fe6023aba8605a68540e9527a9aa47f9d135f05824414ccbb7287b76b757e51ae05478437501940391272854161e89988d11f7157c439551b17902e75bd7fd8023aaafc2f24dca8fba870a660b65ccf180060991b4abeafe8add000ae1d88e70de11a50a39902e64d404ff8da3729571d6f5908d7900294c03994e782bac0d865d4375c00a4d2f5c7451e081f6d174555eb7f9ee7a6e54d5f4316b1208b45b0efeae55417727b9f216e29122a9159448bf47cee2c534c87f3905ab0bf38ae3867f88941f9c6750a783068937de334360c529565573c7babd81881a667f04bbd90194dbb2f357c6b389b4ccef6a7309ce1c6a01c167392271e08f848d2bdaab1f9fbac28dd74fee5494d4e55c2889b0cb44846a750052a2bfc7935b8ce8efe4d0cf4e89b8304958497a0b1f1e08f326201101786a03de9ec290b05d3984cbe2ca4e545a3ffabc1b1f7f7d36cfdfd396db0ccc0ac228519d86449893b750cff6a02b97360208484ab8f1f26483790b17ec3f409f7aeba57507e0e6874cab0fdb189259f15586531ed4506f3fc3d58d00f00999cea3aa346152743dd87c498ce3bada1b8ef4fbbcec35adff5764e25bcce02cf814a2027c6f8b510fc75aa18637f18d14dde2e201e22809ebfc239f457e6363cce478dd608a4323bb84e3e9ba61335dbe7a27c2a02f9f8776f34cc77c03df12645580bfb728643687b60809dbec2a9eeb0b2c2ddfd34170baa0b3f7f6deb052f71f8a90e902f60e3b52fff4793b7ef79f04e0a602f72fbda2e9af9f56ea621140cff57bfdf26c3488794584fe092fc3b9c73ff90d953c0b63f8ad7c018e27b190e33cb4cda48efaaaed553b81cf9091acd5feaed20713dd616c0ccc01673577bc0dd31dba41b1dd2d1ff14e044fb2e900c38a94f6e508bacec26f84e5c5051138d6133206c8c669e28177978d92f7e7a4682bd7a854640f0b7c20c8ce328c4aba1d611f65a64e92e9b178d13de7bce2a22f56998d630ba7b547b20a5088e0815755293e3d1ea476f2f50751792ee1288d525ba054bd1375bef97a2b467d526c0627da8963de31773503f819355a5d89e1c45343c40c62c88b6ebeaa70d676f8542d27895b7954ffeca8929741ad066cfb8b878364fbf8027fc79b458535830b61b8d33f52db65ce66402883d540d67c9ed14de8a90ceb1fc2b5f74e89000431da140ddc5503da6f63a34737a60451ed5828b690af739e40fc97e628127ab49faa7ec2475292788c30bf5cac180c1c8163faa348c7b0cde0d56d85c04fd34b595f89e3a83c21ea90f257ec3dff379eb0ef73d5df7596388aff4ae5bcd3bc6c3d3d84498b594320597560f64a984746a2c075bcb57913c5e2ca1d90d2d51ae640dbc362b85fb977a2031296843f2aac1860c78e1203bc9da7c0e87ad9b27dd240434d68b7a7fff5da825ec8576cb90d7563700cfa2d9a1d39e5deaeb99a14cf629de761c5c4fc16e93d7d1811854ad3f2e7289ad4678b5189cd73149b72d24d1acb2ebfd9fc5614bafcba26f9e0c88597a5e8e16efeda874ae4af3220bc346e8c30131803c1c82b79a345dd1a6c4bc529a7a5b8635253089c37e384c22aa12885b12848e5049b13023e9c6fedd38483662d7a24b009f309188d04bd0c44fa512374640a891fca4639a22d308b123da2d6409e0c77567219c97256663b4ee90305d4b98d3c6aade472e8ec6a7b2598425562ba4c7ac823afaebc77517b2a02cc335060b3dbd9a5a2a44ad6a953259e1538d5e7d96da60ba3a389f2d899685d9aebaca9e83b48cb61c419442462289a31d6a3dff0e9fe0bb5996f4ce43a2b2816ee2c3d75ff478100ff5f24f1814ef9e33a0ce051fce58157455f660b5ff37086c0269aa7dd1191bd99f8db224b5e4b16f8bd3b0a636a966b524b0a36460e7aecae97eddf7a0317abb5ea555793266756f00ec339b732a8412ad931337470014fc0ab04a8ece933464826f995c12fe4fdb7cdb4a6f3756ad1e811979c5e4243597babe62fc1438f96e958ae3062e1d3a9b90f25ad8b07ae9ce37df2b83daf7558325389346643df0c72f17594aaf530c006d36f7ea1fbe09f2e06e144daa57d282649bdd3239e22d389eced8bf82f02d8dd0b7aec233966a4a6fdf43846078a2d89c3abab20b8f1787f39cff04c491807bea6ef5084573294b1aaee4ce0f26e6da6d9b0a14deb0f6c86f256eb5a353196cd81d281ad7444d285267db485428d71dc6615cb0112bbb3e3d28851ac31008757c6f79b1d4510ab0a7520cccde812aba8579e0dd27da1d0b844c1d7865ac8a61546c6de2e93493f401849f9f3e3b44a5b56e245d7423e171445c12c4ff24d501ff0e2d80c3a3952519f8a50018aa69e53d95a2334354b23c64e631788455491853803bf2a3df79b7419682b3e23897c23f1c1525202ff35838bd0103ef18f35b2f2904f690b6c3a0b9d570b7914b226e43933f3e5c962d5d0d8460abbc840fb54b38d2645d7d6b47c9965db94737e36a3a0d049c736a4d8f0ae59d38d01abcf7a7879b109bbbf16ef4e1da52099fec3fc21eb618108db04a7801c018f4555b166bc8140af172ccf9798b63289936848d0507069d58c30d891b567413204d067f614b831442047919915a6cdc2bbac09a0981bcdc2628230c8bf800c24a665dc5195ae8d6b8e3f359c899ecf8d4faf4baefd0cf4446f49ad042c9b226c589f50c319724846470e2c334dbd218fd1925b56f44f539994079fa27ae8963e8ca9e1b59f6ec26fa15793d5edc11b57bc350b1e82efc0c343547010026c2069d6998ae68fd5fd78556242d97e6dc4396ebb5eeec2f9d064ddf6dc96c1152ca9e39fc5dbcb20e23276b0e3b24fecd0f384653c8fbbd93f3a87675a978d06054f9ef82320e9108d5b23c191a38209a43dcbd6d5fe6ccec8ff09ce95a4b9ffbb1b5a67d6e39b54f998edee68b894216b9190335d475e0e94dda259591c4c1748e321290ba291ee4da74ac1338659a3a3ce0c4d127d41088aa98ede15bc6c3f4a8c9aaf6124893c8d504774c6bb96617a37d8fe2f3e8f4a58f70ba4852fddef00592ab6a18c8a89ce3475822af1cd84328306e6cb57726d623d43b4970e9aedaf61dbad3c281cc6a6d0f18fa0ae0ad907fc8513764999cea1435648f109f0c6cc81804a2f94e4e7247a9d20844f0ac8653d49f840422128dd0aeb8011baa02e5e35321c664ac7f58242f9b7365fb032a1f8fed1da86f88a81f84d054a8425b89d4e61a0b8df92c58524722a4898f4d4017cb8d8c0c9b31888ce076281bd531995f4995bc373282a970d697e59e15557ebbe3e996302114ddb9f3a1fead6ec0ed1ea223e34720209f806ebf6799813904c0545d4acfd0c47f388c12dc7c080bc43da6e6fbb704b183263cd7e9a1183815653e4c3da27733f0e143b747d8e749bd80dcac755dc66d1bcf7d4fbc23b1ea37bcb98c2ff1ff59ebdbe064b9ded551fe9f5a300b364af0016716231f45eee65d828efc7a4b8c1bd38c533a8470e6d16a285498675e0638dc981beb1de3178979ab4a3c1bda280e0b587f4ee96743a87c2e5deacacb9cc0fd2db6a1d6a00dce05db0e27a9f1ea881be811e652874d151a9e869444bce50cc9259c8113a8b418e821838843cee274556187bfcb16167b565d9c4a2a54101d868f838e673f84bddd9f11d0211741064cc11ef2e39677d5db8f9b3a9eaf05a2a8c4f7901d9734cb54a9fd2e51cda82cb84482f12d5d571904ccf1d691235985befbee2d95ace1935972ca4f00fdb6cb9388507d35699f739f3b07709a007d51e7317b2c661ea9d8d3588d17c3979b6bf4b50ffa11f6f5ce529b1f07bfd2e2fbeb8ce5107ed8eb8e60de2f595f3aa0dbc638193dfbfd2afabc506e0c171ff16b973c86d8dd94bbeb94647d07edebe0d4405431827e110a6be045ffee69c627d3fa9330e225291563bd5a475e47f2e3321df876cde343f9770274aa649cd044936639bad4aed4ecf100cab8b186d7659b0f42bae580c77ec788798b04a927fbb76d4e0974365ed7d11b990f4ee295892ad5a816d160085815e1fc799256edf00091c40d348dbed7899dde02ebb3e1f450784ac5410cc56180ac05391c04db2ee39d561fa1a2fd0098151c0932cad070551314676062d59ff591e453a57d94dd3a0e4ccbd3efbf4ea5dc3e01d75d77308a196d3b919e167e15e9a82d02f9d3d7691c24deac1919460ec815d39c11a5edca62a4d0a2a7cdf359a20792bafa0918af32e4b2077d78a21132833f0989e30a8d346857defcf3d5fe6b685dda2822dd435f012e60196ba8080e80bf60c2820c59bf476a388692030733a3d753ed99cd437baa3da6c39729158bee34be34647fff516539edfe7e4a0b88963b2708105685d36efbb28120a224123bd2178d9f6843174e1bb820b5997ccd0e2059c1af8bcb5018c2e28d79d23ea9b9464199ebc4c34576f5163cd40df7906785057130c11ee14fbeb7028e15edd23b46b234b707405b03082a227ca3038e0b460cc5abbdf5c012ba2dfc90d429346c7d77a006719491413a4e05d64096e5b4b636dec246a33cf0a8c94ac2035285c30e3cb57e8552c0885fec4cb6863400662e774c544757c8c12371f7fa5ea3ae5f7cc0d3334b3013d4c64534f58e7605ea61ff7c8127977ed2b25a787aeb241ad7a1cf1322d7775c337198af50a6b2bdf9a09f748f81b7dcea886e03f86d1751c971816044571052a49051ab380ebbbc9525ea1b548008a3553440a9fe9450306573d09ba2721b61cc35e1816d7cfe2338d0fb40eab448db1d20c803d96319025dfe945f045a9ea546945b79ac584585c74206a2a27c3c159880e1c9dfefa2aca11d0e524355142df28fc358135ca5fc22f31eccf5e1ebb0acd42499b84954bb7820e595a2f83d9f9fde880a8bf7da679b027fe70bf1bbe6875325afe63e5a3fd8c8efc45383d15e5baffa458d375aa170fbf6513380e2f156ca8da5bf8d369017aa3e075215e330de494ea97dc276f8f92218ce79e8857646e6696be0c0ab4f76c8d52766c7963f455ed41d099c5ecd8e1a6b8818241c7ffea37fe4383a54bf1ddcecf946693614a90e6cf79ed6311d9edb229a48f93b067cbc76c93912878153a841d31a7361c2902750a4e63c2b9389683372d7928f1cb6b178543dea360f40a0493346dac24c004e9d2dd0e04bc0ded9f769e3646db1b826a23ae0c3f720f1e05015137da0a0ab66c6d99838bbaf05b571444c520cbb1039e8bd91d743812d784a846ea4f9645e5e228699f8abc6f64a8fc8b3eb20b0fa42cb1e55607596942021cf85c541ceb0dc4d5fc4bb0e1b5785071029d1e61ff0b7fafb29190cfbcbd677e03bce8cf74be51ffa838ee53af3424c6e83912966f25d607f8f5a4775a1e423f2cf3b6d745e5407258f5e561c35ee1ddd3e47b7004b596cf65f3bc89fece7f52ad79092e14980ef8cce32ee81e7edac2643161951efa1cedff9adf4838b7c9c304e002b4eee49901c5d761405bc01ed0ab18abf3456c5787800602e7a4ca93f36e3d85bd4ec7dba887fcbb62f947d4cd7e4a6d635d9e3b74c006daff2ea4df56cee11fac5d756bc952380cd1a6305bb8737ed7e2145392ec44fd1dabbcbdd2574f26133223f931390f6dcb1e4a77b10ced08af0e65132cdcd56785c1e03e5fa3a8864c1e8dc2162a2137caf23250ba80edd73bc9b9c45da5c922da45ac25259abd7def465d218a179d51651c306cd52af07a1914c8213ada9d49471ea4fbbd8664b314e546c4b2908f9609ce71d8f9603e850044a71516ab17e60da7b59938fd08657945be06c749dcfb146700445e1c4be5a1c36310927987dfd6f9d001bfc1fb0173c61a89e6e7e854d5ed460c0a98443c2bc46a8c33ee800fb14c1eca7e93dbda3dfc17ea215a3474f20d4fe983f926cc57a083c17e024d53b6d6b30f357b824a8ab0f262dc144b37025aeac2ed6849d82ce1287f0ae3c95c376dcca754521cbb325e7a67661ab885081b8838b5ae3610ea14df17262ea62d4ffcdc075e0537a43b6e00dd566e629ef217c9316aacc75f54b9e7e0550c923855dd7a838cc8a4fa89a39ed97f1058d3a0ec1898b8ac0ca7f71b6e95e66e864a13287dcb8c1cbc76f31bc64f31529032c2579153f8f08022b5dbccc551fd703e1c979f5082e50d88b8297e682c9f76cea77a0b0adaa3c1cc7e246ec0b0013a24f55ba6bf093d4de84e7678410e5926ac3fa9e1663e44ec44b511090afe9825d18879fae46a23a53f1ec546819ba0cd7847fc969185c4868638de4a8cdac806241d627f2f8f5a1042aecdfbe40829eb5ee2c038ac73d24e8ea177fd9e2e7e376eab4c885ed30d2f9115835c53bcf37e5be165f5faa891cb167f2e1848d3af70d979a008710be067a6b63fcd15dbb52d6e71b6d615985ae2fcdf9d410d0bb45c8130d316bae18d4f9a90c6581d2531bfbc9c3b7fb831a5136ceadb145da2e0f35cbed5ffaa5663b33ef6311da4e4314316bff9942b4504a510c5cb54aa6fb6657b3a4981dad68d0d0d13466e8225449c81f7f1bbe562b7b04787aaa1870cd12180a0ce688dc0e54fbb82976df5b79ae9f788279db5707bd7536b2d2ca7e5b7fea2ef5904b97eaa82371302f36b2bf2d258b08dda676300622e4a0ba4925bf2a079ed8f516dfde7533d0fe2f03e9d0c6be6fd384075c5c58e626aa011c562d8c045a72dad5ee9119be33ce2d315b2a12a5c45fd2d92bb8fa3d9b140f2e737210d6101af52c18d5c0a3e3e6c9b0be37433a8642a25ef957aa0b7eaccda0a2e293cc33bf67bcdca177532cf61bbecec141ecc1c10ea0fd100d62856b7f2f53b90a512f3fffe728e58a068af24f01cae2e0f668209c8946c2ca5b7e358d5de7ba393e2a9089e834a54b5ddd6c17c46a25bc9fdc48a5543cd8354ff831c866a05a7c01fefa27ac145b6715adfeb70db5c9258bc1e6873d17d74df8d334c8274c4ba1e25874394603575ae60c40e9fcbbc5a101c1380e453a9b85dba548cf5272d546cfaee347e3c959ab650311a3f45398a0b72e9a68345f2fb5f71ebba3dcaae89abff96cdfebff4246a1ed8e4657bd9c10a78105a30f288fc73f48377fc3bc3c8282cb1d497a59f1488c9e72a7cd6ef784ab9a67468ebcc616c7d38b5a83bba492d451b13f7ec28c75ea9ea6bd596e951d424b4931b8575d366ea3b93b19085787c2fddac52256dc7fbe1b8159a48ca62ec6ea938c03f60523e723a34f2281dd291508cb9946f373fead604f906fd7d20a9fac958dcd1415092599c34b8f8e6cbd68e11674be65c0c8141c8d558290aa7f832d4d7eb84675081f5f99de3cff5416ac8dc29e8c39ced547effcf5ed413d3c2802e52649908d3eccc29b96d2d809c2605fdd3246857be06077974906a75892e8df3f1c1fdd9ff84fed08e79c21d3ed912296fce3b9e744e9d49401e73a6bab785f28a677e3817c179b3a5d768a0db679214bb4a1eb870a2add25986cbb5549ca661c7aeebe01fa79dfca13cc2553ca5e6c593883d72e6e5ad6e8f93f416aa52552a3499df82b8e4e8a10bdf90d55dbe5ea919aaa20f448d9af8ba20084f6a683ffbdbb0daa07e3edfe7947f2966234e0567c843eb097c0163ff6667c6aaba00dcf020546fe20084052d9e45896eba131f9a153de427ae1faff0e7422eea7b6ba070ee4aab7af0aa8a9155628dd58623f5cc7701577a23aa7e979b059a10e2e446153985784410be4ed86292e28fa967e40ce41b47323eab4548c1b051341b33ae3c07f6ead501597eb5ba699e364c5156be827be16dac5e910628155de5f342e62950273f19cda06551fdb797536ae744b7df9e2f8f893d2b1e45fb074f17d9cd66ca1251f849261a39155d7746fa420876bdc84d13c2304893d539351d8072b56514badc0d8ffb14609f6bc7dd8b475b0b7425a08ea4e0566a6bc8395aa7ec47d66d6b555c1e6c189e33e0745a17fa2b32db5ca355daa94c5102fb3e4ceda928c6d883b89ca467fd85426b89d7b9ab75b51e4fae5e303f2acd5c8d2a8356eb9c11aa7b6724905e811c4431e0b4ca7bf922b0a35d3db0671d88cc8b0bcaffafb4706759a91c823197511baeeb76596411a18cb64c0b5d0184206fa2ac55dbe3899a078636224af9dd04853dae0a703b5a651127ed9b208c3e802f027a518c807dc156f402aad41faff0f08f9dc8af19bbb3a3c502656ab3c979307ec27f03b94cae02d2819a01210d557869ee39d990bcb7386779ef0a8c777914df51a4e504d58e8da256d73782aaacc2fcab5abc0287ceeed797bc776874160ed880092809b4fe6b0fb5c4dcdd314f0a71409ffdcaaf8a20f27293ab959130ca38da2de63f6e330552d82b133cc37d521208b9c79d231933b482413175f6a40f55a17f133240fef363fad6703d49d6f9358aa30cb9bdefb0ad471b1eb41e461c0824a023dd998efb3fa6b7459776efd9d13d07ee55b61d3219dcdb03332ddbe9ae55b67ec060a14674ecea0cf71a44b7828ba3ae018fae7615938fb28b0e96348c5f8fb6d4a7f536b00267421e91f33377d6fbe48af5e675f648b797eb889e61fe88fee762d147b91a879c62b6d3de024c642de4fd4451c808614562de67319319be4a65f53c3999295b5d0c8512dafb630adf75001a9e4c48d377e1a6329a77939cfd6364f058b595155b3b82752919e0e9e585d85d3f7a9228f7ac766e433cb245268b6d387756e2358908cf20c7ac771c5890b0fac360cd823c506343b21da9f9e92b24e6956ed2458d0b3cf3fc1913983afc5ffb9ca43829fd07b2c023201b2b5fee295ca90372f6f9a832003f55051474860eb389ca21dc33955732c44804af2f92ee34a24d93389c93bda52a2edea9537c93dc86447b1ebf8accc48c678152c7f3a9995a2f7f8ca1869386852aa241e98639abccc38847aa92bdea72e58da58d9b37248a9df177a9b12741add6c5344d2f300ba050410d156b7b6a64ba4197f8955fb2df648dd6a08e8afb3d7e9fbb4dd5cc50fdb461f91bab8c89602295981b9ba6da8f0057fed7ed5b81441d991b67bd5924c3f5ac08c062281903a98d472214c02104b5cfe6e451cc7db1fccca9ae0285bc49b81af3d25735cf19dbf775dc1e02a5cf8a6b69c4edde085612c9cbcd667b9af0d3f961eecfffe1ce9dde8a13e6187dfb6dae86970e0b227ca1a4863ba5fe538f483aa346b48d70d77229cd94a5f9e5f6351829a6dfb5fd235765549a0726a91273412fa90e99f34f07d4f9f6a53594194da9867c5325dbb7e3118f0dfa866c89fd94ecf242255c235720d1d151c9e82b1e24b25e550381dd55ba075c03c43aed5234222cce61a54577112514b3f5dc35fad2df012194dab14768e76b242a990e86c43a4ad73a085a2e8da5ec286daf6f212b5c50f6081a41d4fdee7dd9d5c9c9985d9e459d762054d19f5a9dbfc70b70b0f1d7b8cf5a0e5a87d1a9d83b3a4136b76a08fc08cbc4427c003c6e45ee1159a0edca50f40515460758bf4dbdd1921a3cbdb3069dc4312b65a2cfd46cec21c65ade84eb7d29a9e5e0c7a61911a94116c4b42e3bb09e9975414b4e8a2774a2c9bb8002d70b84f985ed540526011f1ca1b7ae4eb24f49efb3b9930f708788559b78622b23f6351acb6890fdfa919b7eee031f9d1ef3e7de3311bf2375fa1f6c8645b6ad9c5f9889aa8ee47ffa51c39fe7edb8fba7c4c8e686d5a9e63b95e2abe789bf0f2e234c66a5ed332a31e12ea9c6a670a207de56b0182f41543884a17216c797882f8a0afac0c85becfda38509e29a813eed0dc19972af66f8a7f5c6cd93a081cc94a0fb6b4dd1e0d0d9034b90aac8b89ddc9240d5baf1d63d69b5d49d4a8e887b4da4a966a808a8a9ecd9eebe9045f12c676148d90ab3b09a0a355de9c80478d3908c793c35b4574941986c5833d56bd2d304090b857fcad2c8ac7b295ffdec7eb8b6873bb47e1e57e8cea22d0e83effb53778df8fed08a40903c363ffd6f1c9a830251bf7e7e28cb2cdb495b83b4b88c2a82f240847394249cf041b06f92317b993e63ebf4682d1459fd22dd9ae79c0b33a5367d30fb4bab51dec30d6b321943a7edbac333603402fcf3d254554a5757146a2f3c63d731d107793fa0ec818f3ac6b076892c6a57456fdc2fbfe6e0cb693d5424b61a24691f40c2fd786d75b0c9a3f8063c5ae4fecddce34a8cffddb043a98725ddadfc1b813e56362a01652622319de2eb3c2164eb6b64b7a4e04338fc30286031231327e50385407dabc5140de0be84a2d07736395dffed4cc8401da74b10c547c4a2a00dd8abc6bfeef7a605f4d21d7513a97e7dae21bac369938204b2df1834f78b1686cd7b75ed48791d425a1fc1bc3b2f751a42b42173846d8c58b18386c99291592532922b889f6c37c097b12a92b5a29276a50fc57a4d67a1cfc5fac0464c0624b61cff01de59a6b07e35b44ee51da4ff206e48df021cba84fab7319e67bb259f31f752413bd4d52224dc7121ead4cb82857c2671750341e2ee29bed2420e9f1b1f50cfc3e7810697974d89ac88d6a726062a060a1ccdd443f4eae9488c29a052bb91ae5c4f296343d06d3f6874b0c6b5a8cd3f01665a90e2a7e96096f7e0d1ee472382f5bdc20e66b4de98ea8d7ffbcdcf23cf943f1330bf9079e507880fdd5394a7bd66d2fbb3b9ac7f2f58f2caf108f1fd373c6d98270ff26b4454f4ec7eb30fe196d6b4b8fd43a1e8acca377b3efb93de6644047d599a062f4c8f071c9649b0f3373c92bcbe6724484346bbe8ba66bee3c85b6fc27ba78e26e67fa2d018915a871ca555207fc4cc74f41d577288d32271a92c21ebb412ec72b97f6609ae93d4230a5e7ea2dc31ccd68d0486a4529311f27a33f0d9ab4d4740523609ce63b93da6c16dc3ae74c36a9bb07cf5e86aaa9823930c8ca65b7efc0fce6b6d40bc4b1cdb943b25434ea56c9f57ab3cf0a7fde885c27333b7fb9fbc8fd596e8dccc80fe19f62bef47b91f0a54c45135e953284c0947a05ec33598fc4b29169c8acf453d51fb3b77da69833a318295db12159c9dd00ab87f6d281000bf5bb360e271d4fe038e6394214521f3c5538a0910285776f7c8ab54879d3618084f4ea8103ff171cf17c723e94f32e12e7114312773ee5013691ba456c5c1da63aae13edb97b65e4a255d4de428cfe09bc3fec1c9d1f9be38b9e656db22095ff3a02fb07fa2d0cbea533fa0a5cdfbf9870b0368b3205a5e3bcab23dc01e8641367c5aa3e15d4dc9cdbee6e49ef49e5f6a367ff2d6fee61af4b01d68aab6a03cea43b345d43228f2d4dab047863a7bab5e5944342861212a8152eb4b098a618c499a121c00425eb778327f0f4c97b16572d8f85730bfe5ed52953cc9b17a9dc0e5a73e481a6885d3ef9015374c9c0d5ce267091d6045703218a19ca62d2b456ccbeb35a9f33dbca792de67b141b57c001320832da4821db197e77ad3f15456be9f8f2ddd74b4ebeebae6e5d121c30f6f5d52459cec18e88a455610c5fb1910df4c5241d12d7928eaeda13b9904ad05ad307dee21f1cdeeea5cf07805566512c53721cb91ffd51caa5288b67bcaee3413b1b5a426b9e8a0f907badbbf116d33adda05c103484a3059a903132af87e0bd2d6df44188da9ce397342388d338a6b616d9a4165f6c49c2c4278b7a8d5b47d1e1a975bb1fab7719fa45eab9f4e06381370c987e7cca9c3f6b63ea1c79d3801c1d942248a3b9cab48eaec18a78faec0fb1bd054b629399345ff391c437f10e203253f9a6128bcf2de07454522524c8b7565dbf4ac1030a82d638a8813215dfc20049c4528fbf5a2230dc5bd42d545b28ddda85a9500ad368691f953430496d7cd5134c5d7ab2539b7949038229c9af1214ff3d5b6cd2ccfb9c8cdfa90735938987ac60b287c89a78a067ee8c4be2ff7eafb8a98c6230c2ec12f65f432a613267d06a1543d5ac218cadc031bd5902d4c8d356916f7ddbc68819801dd5e8e7563d57947c2c6ed88cb0874f531853caa525c016d385323b5f6b8663b454a81e3d9846c0a7f819ef58662e6db365cf3d125ae5dc39189588ee7f756effd9819342da9254dd7154811ef19b654c1d5ec8becf0c92fcf82efd2f62448a0f5187d6d431c05f15e2bd4a8e06205bf912a83391eecabd97124f43467adec5e5fd2a1a69f4c3821095ba7f5de1ead411b29427750c92f67bebf0328bd0289a55c6f2c85561c17d62e0fdc0356fcdb4edfaa9f5d1b0b77d0dfb947e90c60e816b225be823dc2e6f5a4c60b88595118314650271349a055ce3984c6c37ef4a49c47781cbc3579525443221db2e9e52e66191b8d9a1868d9894d16a9f9415fe64ac6aea0dd0fa4901df6fe9da0f08add3e62d0cb5189acf6ac1dd8122b04e25cbedd73c3a9d753bd6bed579b420c47dac49119fd3577312bb08e8fb81307fafe1c8eb1e87e94878638df5045889e41197a7a1f6711103722a9b5923fd0770089b2d182bcae1cfc915679e9eb2074c13859f78e5f06c8bceef6d31ce34f274e67ef90d487743158e11033341f59267e656d82904980dddaade882b2c4df97233f9df9b004fbbd0a8224dea00e6427a91adb22d5c1a067371e477e398ec2b31eb6a998e4aa70b896f812e3b7a02ca5d067452937e247ea4edc22d57d7ce4497bd5ef2f76a90d301e452f9c8d56815650a2285e3b358d8e2e2f502c3228e61823708388778108490622a371ced0c5e0f9b723cfbfe7dc508fdbf9b4a17d87b97cebac9f4f816e4f747e5bf930d0e21fc2b1c4706c549ec3d68cd1a4e8da1ac2290e44ba6e8cb577c6af8c32dd974e3150b93c633ed777aaf754a5b2084a91ac257c144a742f5b066073d09f499a2cd8ae0a225566832d292f94e28c3284953c6a963a2f3e4bb79cd5d42a5a18ca33b64e033b39f659c604eb3cd88106291c61a920b127807637f35bbac34c63c4d9504b4bcf1e1c314cf072d478405cf1b867e80ac7012c6f423405cb84c8b31ef3922dcd604b6ae3b99a596565dea8edf7a7e2e09c37c80027b4646149364ac7382bdcc512808e2cbdb7cb1c4570a5b24d63b3ee58f314127c1e9a904cd0308c1d1d728db3a653464b3fc20f2a648c1830c13648d054ef415db0813be57b3dbb57e5b930bb438877e8cc3c17271de3803b7856bdc4573126fc6f97c1fea4e24c9cfb41743dbea3f95d2462eeb3fdee9cf026653285b50ae986e9b3f18d27aa442885897aec116b4e7ef858975dc18236b918edf4d5552451778597a08563cbb6c7babd382833eca2e2ee217ff84060d8ec494a2d0644c84e75c47717d3dfc92e612cc8520d9146d32897741f496fd644dc75e0ba5b2de9a512edead47616f8e2bb193efa5a5907d04f145b085add4dcc91e3fd2f75db9c2a309a966501e865d37db72e7083d61a335a4e8d8037d04afb7f88490d38493aa3fbc6668c4e3c8c0c448adf5f00428f63db5354b44c63bbe26197aff8aa2c1aaea49c6d782c96b311b2c96db6895592bc7ff9c22731b21f5f44a839194e3dbb5d648c794dd84cbfb678a6d862fc280cc895fb34d45bec04a07bd404e2b0f0d7a7ddcca6e14202a7d6f20b8deec60ec4ac3f79eb2a57b93c88937d7b1383b59229fcd2ca313107339fb2dba3f0829de9ede00438756253a7dcd2ee869ffda724988dc4f0448641b8c972eb235d11608a0f5409f68ce02f87a5fd1ffe614057b42f50348d3211c7a913187230c652ee6a2caa38ac3ad245e39b3097a77ae8a936a72033d2cdd080a1d063110e39af16b3f15920e796819ccbe661c44ced651cdcdbf4329f86dabfc5d41a907bb7cfb706df4e51a626958fe6d63d4eebd92fc7e1484261bcdc251fec5c7502910810ec6d3ba9f7875d91dd2c885e88459633737b7e9817ab164be0b49e906b7cb45841417070ac9fd54b929221859c1606637f12a217dba4d65d8dee6dcfe1996215d37bfc4f000d7797af602cd7a41e3a5788dec900285ad0da72d14ace9634b6f0abb7c7dc596f64bfc914a1a31964e966caea9143acc6495a05cb65604706011a46c890525b23d6a799e5a5d9a1b39005e43439f280b66ec232b8ff5197cc0b1117dc58f9f44eb5ee79d01b73bc3e0ee6fe29d46d8ee24579c1bbdca3d9919c12dd877eaf1d9d5b6a9025a302a5e03e91ce19eaeaaa0942547727e05a1709cb0195a534cd4a4311334fa625da82a88b52b2ca180af21cb43ea972c40132d22a1196bf0cf86b865de2d0cd1b5df19f3d94e95ecb5d849cae5b3c942623372caa4e52522289a89f54bff4e3068e538bdeaf41aadf4db224b35a446b9a484b0a5f8d34652cafd90d84d41d2ec7f0718d2e7bb1fe10da6c236882ae654ce7f61ef35ad1b429c048010117e5637d9236972db4c0c242791d6ec7448e6c619dffa9060a1f8319c57d5e81ed103118a3db9722349367e6079b22b8256c7318c79b0408221ae059b291a621671178d40176d53e493ca4597d01226dfb13cf298cbfff0e72fe430f6f0511396c5e876b9135ffb65dda0307d346e1869017498c68843a63e6c086283379dc7aaf75880bb1e35a5b4501c312a5811c0688e83301a2e13517a67c940f673a026c812d0201d6b070d636039d4fbac50f0ee08de1a3f82994004bc2729a94d09848717adb105db237bcd37575ea624b898e0accc09b8b2df24652f8cf6f6bac0fc9bec291afd4a3cdd5e07830ae7cd813de857bfa3e3da693caff90d140f69c8d79f09caacd97dae1e623d1db3730084fb7d5e5af655c89593eb4f32cf0f0a45302ecf8f122e09aabbe6c4b1462787a5c6887e97289150c56ef78c1419dda7e4a6918f7b977cfe3ccae6700034f7317d7651ff532af4a1a466d3cbb4e6d2d491c4a73925dc403ada775be85322067646ef54f739869cee5483637d79bda9cbe04bb292ecf71794ae74f2b5dae3bf4b1f9162266a1e387de22cddb87306b4e10ea21f4f32e06786743d7a34d69ff9dccd6943915cfe4d98983242ab6ff1e02b9c76786a9b798a48f5e1b9289b6215b10e0b4a2d089873de87986a397a098de4ca88a9dadcab3e2488ebf5d66f995fb6057eaf720660adb373acd87a103b3baf836798d4f94e2247d0872e6de53bf88af0919caf7e977c3e00ecfde26721bb273edcb4af2c7ab819643e1e9c498a464aa3f1264fcbf2bb05b272fad109ca50b461d460125d7728634b0665fbda347106578560d1f6f13e96200636870f85a3bd104963efd1e955d0666428c798b18326cf79bed4f31d6eb5e99c53c1e79bb5f5e0b0f3243b1e06d62c4ba8f43d1022fd902001abaeab23a86b66092c493112f4a99bacb6123bcc462667600101316874742702d32a94f8b899d2a7a16c724103cfc2fd66499263a30fc7577810f1e61381ec638def7cacb8307f897fb5507f76dfa58d8c0d1cf6e9cf2da06b42cbc6e25b698eb2e297878617669a8a47512247a3d10341b347a651465868d228ef9b031d6320f5e31bc904c2f807dfeca37cec8ba7fb0d62e29a6d5219d7caa65de7c80abfec7782924478d5931e8b9beadbd8a0b770100086a4b9b32019e61275eb31f0256a5fc3e96f629fbf6b4cfa15ce941c8ae09028ef8d5e5899b2eb58e892620f4d98f79c29e4a429a2d9fa3aed557308d2b9bf9612e08d28c1f88e88e11b3eaad0644da744c53fba2de2ae254b2796b1a07a710d34fed4c1155375034f86634ea877836b07daaa7aa8396a4bcd330647bdbf3a7d1aabcfea7c7389bbdee576dcbe1ded71217e6e5632957405844119361b4eb2356d9c1d04e220c0444460004386957cbddd6faf65ad0a9b3ea34508ed3b8d13ac21f761508d48a0fde52b0278f917f6a2e38e51569010e194b0e0b5e9162f7acffd3aefe68c1356a56e12e9f8e0d346200cf4a649a50aff6c0ad2ae2fd50576b4a5237993083f8e50d6b84bac910899349a3c9b284f93f1f2e64dd704028557af55aed40650593293e71dbd3a1ffdb461867499809d155fb208c1e96e6c3a26fec9833172314ca1cab9937567e2c337cfd67222d0f85f34db6dc2b42b4c4de5fae107af44e529eed2ae439b2d49b6a5e10107a0b4fa622c886b293ab2ed5e4249147a29e5f72470a0665c274f99f95a01e3f26eb4a908dbde9829ea124b84c6aab760c8588cd58105469d7b8660124e9b18fe77c1e68686947fa87dae7b2554333a1de5cfca3da5894bacd5e6e3d89e06eb6e9803e490bb505aa2f0d435748d3adb9baf8a0fc4cf0ccf6ac163a4af3d0d63c7e688bc5dc7e90686006b9e0c9ba3f4f882c606e310aaf5711ee4c6558234c48a092c75e0c0d694ead9252cd3251e88933e65218141d77a09387edfd499ef105bb1a2628a90f537ffe8eaf479447f4399182c89687b51c941e7b541a86b5618fcc9853de2bdcc4de23497e84d3e09ae4a176913210cf137ef57c2538a5966eab1536ce5ea9716b2f3d09bad27d7d56102e4599d059b4c64e0607ff6a645ea82493cbe8a4469df55d82014e27798a91a1e400c7f00bf9ef301172d6ab736eecf25fd6bfc6a852b785b92422c131a21bb0b46e97037595141f020255326592ac6a897391e56b1ddf2bbdbdf89a5b3a45ea5588965df35a081bfde869f4428047d8545814390fd70176dc4a5b4c6a91b1ea365a9984090804434a5b7d7cca94f4724f2adf4a73d1d62b6530a86228abe257ce8ba207ff4a38e49270e7b9fa376a8f1ccb0876f5aa4cd23812ceb1e245c385583456e0a0fd5409a84ce7f8fe00e7784c08c428ae0fdfc4c9f239c1ba0a82aa410ebb07f2ac970cd28036b6a482268aa03acf8d15409269b45653d6cde7b2a88354988160db3ea3b671c6883e8f40e4d89bd8a1767e2588bd80d13b7b5e161c4933edc53ac4369ab9935f47a64f524236021e59ed13429ccefb1133ac04c2c41ccdf18f2e212f4ddada183d5c303caa26c27cebc3fd352ded1315844afd83982d7854ce31bd4b83b073ad17eeb188d200370e52195a768829fe0aa52db3973027a6fadeb5e9dbbf52fb6e2118e33414029cd2e7489305b6fe9e2aca35d79e43819433cd1bf8a851f5fde73b0d4db6a38e398e140195d75611d0157474f02ae575f39b664b3013195045887e5f7df6302ff9c310456362d3d30b8d1cbee5b3783ec58cdf26f9d9b8a9021bd827d9786f8879a2001ba1e7676018b29d3033a07917bcfb873a008843d1a1cac64bf74ff786c270419d410134271c93740967fdfb376086c81f563fa39319eae5869fb59bb8892fc228c6343b9fead1d92b732ac2a89e5a7f4afa6584d434cf97a7b91f3e296be648f5c91dccb6971f8984789a5a2ed262e5f741b1afaef1f53f27c211df3816263af439487ab9db08ba208154a0f849c4b7b896caa94db36430b51e8c58ab05774fb13e29711824f4ecf0e7eaf190edaa28e39fba1ee5d9fc5014ee89475e6235c1f98e65add82a50db939359d89aa6ba159cc6d758e072152b19e7a4b297006a446570ad96e94c48d1a4e16fb90925d601548a0ff43e6a7668f9ab36e33db9e00f79cbf8fb2f2741d000ff6eef9624f2944576855ab5b2ed32271c0130ff1c703e8b6ac2970d6e3e6265b0a3e44f53230208a074dc37637290127298018774ac33b74d23bc2748c3bb68c0a8cafe8ef934c598a8b357b5317e35bb4bf0c0d2cfdc1884ca756b1ebaca17de695cdcf4298303f4dca87a73d3c376a2f37404ad4e6ae9fe32e56ae07ea94906e4bafdb411bd6bc690336bd1e31eef50a187562565108fb637015c5c19b6cab3521380e80771a2d057d6a4817cc3dcf49e56d6c52838a2924ec4b56b80ca7f79441ef4505c21c078bd1e2da07b51cb92396cbe9610f6e7472b86e961e472c31b4cf571250a5480cdc1017aff90105de8e6252f37f3a6dd79f27e694fd7cdaf4236d39f59b6cfe5d886d85e8424a2233a26d2023a0939092f748e2083eb60932694f9da5275cb7254c9da10755f77a858ca240e2de72c91d657cb35451e4040be4d50efc82038bc27321e319a896d7af17c2564496321905613449dc4506d70f3c1693e21774242d2c7bb74f24c78706e64f1a9977bb2e6857a5d670f7d34a893bd228155e36b1fac235b546af8cff9b90539a24b8b973450599aec186d734c8a6aa79884405364dea3227241ad321db852cd38565a8c944f246d57c445853504d035d5cdd4a0b40c6160673459fd950d64adb41b5e9ff4ff05212cb75d1383c0fcaee8ee10bcefede2a6a3cfa1a0259467b5b21ab23af740e1ea8e0000171d137e519cf25cfbaefa1c72300cfb2007a45e77d737b70b79b0edd319d94ca88c664aba9d897df43aeb5ebf3625b834defe755c2a5a68f402789bfe929c8a7e9182a74725f5e9e9387eb5657b99fc8b1ace20d4e4af1a6f86120f1ef9a64185478a8a68a20fcbd9e8721f76d5795a567cc2632815c015da276c54a936374c7b8ea7d3a0088b811d5aeeeeaaf597f29e5b6c9ecfc28fe5f8c14805a19376ff583446f190f7afc2a351c88f78bf626fb34054da724b1699a3be9517d1128659ef1a74b200841146921f5028d00b5222fc73589579307f6ba3672499232d55f4bde9514fb2444854ff37e623d86077c95cfee00489d43f70fee584b8d7ef0e792fcc693c1dbcc222cc92d60de46de39ff1bf78695da4695f01eb802a62235af215dd27441a04ec6b6f3cb5668b605e8db412bc78c951a91095940c946467b529bd086059904a4a1e8411eab4e501c0605c591d7fe7c1fd7bc199541f59861eed1f820a509f1cd7278cc340620da9f5cf9765fa512680123cec562afebe4dce88349ad76deeb922b4cd9e9c5068d3c1efefe650f2868c8bc3570c7e9ea19aae3bcdf03f269c7a49426d692aae9f2800e2302682f1f36927237b74a99794ef59635c2b6a36c68a11c83df224fde29a1fff3fbe924555b2a13401b99dc2df4ec76cf09a9f28a09809f7b2645ac96d6ce5850adfd59d66f058a51fec80b343df600de9049ebf55a1207c1a664e5425e3ab6f5d32be8ba55ea896dfeaa74972b3b4792bcd1a9d4d0d71540726b69860486266a8c7f22d8f700194cc8b1b1d286d7cd48e73cd783c881d7fd2dba35f5ee985777a1a6d142b7faba23d7a41d8e242ca2b15b18cd01c3a16513c5b196220bc64c55fb906780c5ffba6fa2d72faaf09825fb7d63d41759db1cc61312eaf9d5610a4595486ba1d74a17f6962dd6682805060260d11449234b35f9d4785a5cab1a6382eb4c612b04d233fec6506a0388cadd8480b6ae6622d4552dd34989f2799d5fe440d5043a9e5907775023c6147be5a4b741914b7cb25d3dd904cf51019964f3dd2c29f07e01f2f18e1384a93e919cfd543501357fa932c37f7b6f98ca0e84471efcf2623ab14220e77ddce6081e16e9fef45ce25ab339eba958a9e9a819f17b03026b15e4fd085c1019b7ada2a6576187c65a36878d817b0e4c3c755a8ffd498793cefffba5149d8b42193a1bc41b89273dba565674fafd98e4e3858800319e27c8035670c1a1f6b37dd2b8b5a36ce90e285b584b430390d68f89febae382969c4e79ce695388faefbde9e89a7f59ddc2a857d4a9f7bcb94d3e71ad07be67dbcc8f97d9c093ecc422e7455fd155b599176c77c739a4b107bdfb64c7ec5570b7a119d4e17bfe4ba5f17bf051c099f25834bee21ded32862f87e719a4d3faef2a147260a0feaf578ec24d959aab75d56ca94aafb457c53db5acea2ad2f9bbd7dfdf04e5677627ea1a78dd4ce94608cafa9ba1368e70f4d9046fea45b163843fa937f6f951e024ebf778ce73bb55c96d39a15b4e12a3e6274b0dbbac253a6c6dfcd88c1c1dab36a9edd51382b0ba7b4d998cca7eab2a3b06d034607d511e151644232fc3061077736db9d79e5187a2b55caa58139050f062b27e8fe3d9d58c78ec672b65615d0a73821c4f26136b9d0dc0e247059f58db77e2720ca3d3761c68bd6c549cd33e4c46f827470c60860db1e9b1a88e68034b777b8b9efc2fbd8dca6052320e2126943c8b5103dd2a404b33cdf2261bf8849030168218ed5a3e6453dd58fbad4fef5cbd9ea36303512b9409eabdadd26dc1fa856aa8f334506ad0a12563ec8215d8c245dbf2afa6db2c1f6ba12c7270f8d5825c7a6406831ee2a4e34188cbd55925e812c67f44e3fdb651701e456be494680b98097eb1bc3ff8207222fad5adbcaa99a771212678c8f86a8d314a919d922f0588e90f009b59c764c7d615f8aa9312c1201af1ce80f7ee9108058971352878e78e9b1aebd0993f37e77cfdb65921bd4fdfce208c3dd0190ea119acfaaf32fef50ada5b1e87852ae194f641b7ad4d2f15d0887bad469c963f1539917ec9316a7c053fa197985d6a85a0363643c120d4243ebf77f13a2a2e1aa63f4159b33eda5292224b789f5ca2ead7781327a75897699a625f3226ffc7ff2d014b17696e115d7b23d1b8eeccbaf9f95f169df0fa4bc1beecb723d0320827253436e948618b1c35cbaa18d5d45cff3f2eb7a208d3cfe802dc4653067e8df3c28912444fce6b79e93005e78572be52035431150a4f7c06ab59ee5aaeabba4c883deeca56ab4079d15cd2bd05d15db761589afc0f23a6bf3756314e5887965f2428d99","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
