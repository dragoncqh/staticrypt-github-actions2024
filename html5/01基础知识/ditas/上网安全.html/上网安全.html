<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0292bc709ccf7293bcec4c460c14c87747080b20f377ed5d4d80f803779f445de3c4cb04b1744e0c48ab8bcf051c737c3be1bdf54e8b56cf32b1209f25ed81f50faa9643b6dce55d5973ef5824fc1167ea6f0729b8f95cdf6ebbb8ccd2be325c194261f495bf247e07f99c998ba93a520cc7e44a5d1f0c59b62238f78b4aeab303f3a6a95db46abe882845510022c7ce262f4bda13014225d2f4062c5142aec2cd7ba03c98f1600f400aa33c7a63d110c48351136d5f8a5e4d498ad45db2cc0dfa8583f9f6797828bfa7f46fe6f2a7671cf76ae28aac99eb09903da879342c088c4add830d2782707b00cc5fdc0b0557df26d5108f4293a0c518f4de73f515408ec571f5201a5361673c9ae2ae411d3cda24525b7a177fc2cb8a18ca9f4ea69ed32de3d36367469c466ed404bc6496e9d95433f897670855a26db20eb653da0e2302a4888da79d9e0383ec121091a3d6ed4e79fa3b04ebaf10ca1de787041e9752569ec571b0f7d3d71ab6693202e91add68d9baf7bcd6b66a9fe7d717f181a8833f84f12ee1f9e0ad793a6aea6bf3ad4f81d4850ed49d3de9388aac46578a31d19e7d360f6327144db541ce561df58eff211ad2c0bb7ec7f467424b8feaf870ce174714a5084ab261f846d0c4c18f454a7733adf0533da67271f4cbe2657f671c87eba01981d4aa8012ccd23f26da45581d06f3b6a5608c33d068a82edf69d4040cafa9cdefbd0b9eea84ed213dedaae2435d560a7373a6ee4d293c5e94bc8573ba056a470e32a06b054bfe7037d054ad3a81a5a14dffc1b6048fbba5856554785ba99f13a734837c35524a59b63dda225c9650aaeac366b4127b8079060d7e3f1081423cf0b64dc7cdc76e9f445ae2d4cb3408a779f7bfa74ccf1cfecb7889729ad30fa61ac2f6c8a718924985ebe68602cc8e40217e197caa337458d04ec87739ad1be9cfb2c3daf64d3acdd787a43f35e9c16e872816fd37f8814a4fc9825f0531900763c48121cc6e0e7d5009f06ade8c71608fe72284be263b415747891b85fdfa504df792db77bfb64b29b2dd9f42ce39b8c5632ee0a760092557f04c18d3b4d4f4ea678f1c1f796afc0a7103837a9267569784d88a25d38267ec1130f4a7cd07f1cb58a1b029a9a147732f6122af225775978c590cd7024b026fa04688af3edec2b6ebd8a34b1cf18d0c310c5c1e6cf8f603f2830a39b334e486767403cc840a1a6e130ebb7286e4f22a5cb006e7a8bf98fd987eed49364c70d760634709d0d2d36ddfa3c54f25c3cb4a5d4bc9304aba272b8afd4353a425d5d0dd69f6816bcde74f531447355f62fbd66bda6036a5560d0109d785fea39fe56734d2f9d12be2b4daab2688ccd74cd57172a6ba6dcc8d2110a1fd7657f3400fe9d44ce3938d0fabfeca6edc783acf1103d6ab968be1984a213b3e5670313366d0ecfbc100722f9cb278341930f2b302f55786ad5c261e52f646bb124c67b9ad9bfc6713abe29166ae83c003a5a2bb2d72bfc6c558b7c410f9450eeca0c23ba303362962907e7d7ad49e3f8a05e42f25eb7c0d2be26d52795d9f5bf3e897b2dbaaa89d8a9a957d9d5afa53210369a8bb0db94b110ef0da563a34b9808f4dccb4a944ecb1bfb9f997b5e7a39e4244c80a00efcfea63ce0f122a055e9a521ef44fa1cda01288cf634180f8bd58300c566d2ee9ae5e77736278cd136dbcdb5e79d88eb3a6113d759358d2e1e613a3abbb00bde38c5d6d0ee6184493798811134d59b5a275cb58710d019761b44a4ed1e28964d39862367b64fc4fb3a96898c47c7e0a8140b0290f5b783438fb9eba3d3780e15eaa479bfc1b38f83d5a54edc88dfa4358ab9d116941d7dcee8f8d555b309b61c0f3320ae8c10831abca179dcfc0c1caf8986e2f72e01a4af13469259f502d941527f0d517581a612a70a8855facecc7598d08c14828fa1a29d457d25d16f9d27493d9187e25baf5f82904fc523016c0815d2685c8df34848ac67b60a119173af1cc4d04d90dcd2a48e4b9b5faa4c209830c7f4dd18209d14c837fef390e52b8c6bc8a37c7289826f7efcea291ed34e9377e73a62dc8693ca59c80cb4cbb87c566333474a950dedaacab053b4238e5b576a78f05e29eeae3eb0f221730ff495f3ef8f94c4df2eded6145fdba326d4330bc6d737d246d9c3e62e5b410a3be2ca7991bcbaaf7ba75c844566e312783921e92422dd9917b25d3ef97b122c30f76804a2809e8711aecac65149d64e8cdc8591981e8409e80f0f15377f684b4069d0781ca70ca615193a8cb488f04dc3dcc7e755303de733d99eebe589bdbc61a59351e9f0567cba1fbe89ab412bfa3d245cde72f53b288ebd6c3f24533708d4a6cb16050cfb96af578ef1b9915317e07e7f39f8ff8d2d184adeda5f5b2f3b050348fa0914cf38944450e11640b14f6629620f5ce9174dbb18295858e7393b3098f793489515398b09dcc1aa8bc57235b839eb18b6272864ad0cff346a38a0b2546be377397ce61ccac2dcb06b2795f8c2d7db5c52b794328b9e1bcc43b33bd371a34d6074aa512bfe70c29535cdb3006b78a098d1a47d4cef604426e7fb110d82517b95cb526905287264c859dab0e5e8f1bb3846bb50a804832d50087e69e311f798f270cb2a177d876169d994520839475661d53273f01a65a4d880aea5c5e59fd4f3bcead783905cf2f0b79f85a52a07422f47587a6b504c0fb342051b516dd03efcefd8ed0899002eaab32736fba11bdc9aa62280849a69b19ea33768ec6c8cbfdf4742820e23f4a5540bad9e0acc95542b490a03fcb9052a08a2bccc548e8c088697daf5ba9704849c3e8fbe0379f8b7214c051f5f90b100fc9bb999af9c622ecd25389ef8b1867f70d4375ffa00ab03134f8f5c091656ce1194080187d1936fd6882a58266501749f4b1ebd49f2b6eab9aa0c7c3899f03e9d9acabc8b325f5f1d3bc70fe674af8df1e0839477fea626d1ea1fdad322b616d14bbfa865b0e3006c2c7432a0ed404349d3d965b3327a88f84ae794365f0fc6f6fb499f55276fa5423289602cd0d581f666648d89713cc523ac325df63bf4f478ac9ce7bbd803dda2f04cf614ff002f8600837ce38da37e28c66bc770318ab36b48c0ba6816bde88a041e262e881e73e6153bf17fbcf6030b16aa103cc73710315687a18f3e531632635aed53049cd9a4dcdfe019065793b548bb38c33c83569218c364aceb08387d4e319d0fa78c9c4e40d395d1f57ad78e692f321c81f2e4f88e7f096ca65d75a8b9e2cd97a0fa84a69517daa40a91f2ea3e671fa4b180fbafb89d47dd219cdf3f7edc0a4580467fdcd8c181236d5be1e2d42d19aafdc1487175338cb3b5257e999c2641a481f029dbfe71d8e144f23b9684307f8667cb9a2dd3e38d9ffa4fcfbb4259acbe90e7312db0782a6ee0395f09b86cb57b31e47a7dd739fc348b125b6cf0b9d0daf6546adc02d4fa300e45e5c125ec42c422a1f73452aaeae61abd67cce95d1789f6856a089e8f58b881e9c0d47a9e43668cdd9815d11426034149796e4cb5d40da7a09c4379ebd559aee7a0c80d801569c4fd1d288a81e8e01a5d3f0b08835eef735e7f75a422a36abcb601514f042a8e183d5f3bcd5bc32424d0b2a9ce2655db050a8f575a0a3f0e0fa91a9f900ffe002fed9f4c390c86bb98e14bd5a100aa625d12b0ad0b4736d115009ecfd580c7b3a5d3352bf3415d309cfd1a998b3f912058b1f2df075163bcf56d5a382ab3206fb0cef40e3f8ed2dff48297fc6ee0f4ee0772840ce3018c8df152904851baab1922c744049a312773ea6b7c847c8c4a7b52c0d2d58fd01818f5d0676ca72b961c411c9adbd5b6d625f7259fbb64e6c6ea7e20038f171f1a3aaa652bb9fe7735299ccb327db2023f603143be63ad197f71d3a34228f4d1421048c8336ea90713a45235553bce56a14f12c12e443cc6b1864ce3d4757f8eaeaadae6203da0c1ead266377bd57201c6ff177b0692cd5f1c94a63cedf2c237898ae2798c69cc4c346d52f7e8dd23f9a5d292645c16fc0e3fec7314d1253ee5e2115b0d523a5addd4726245dabba63c1f36c298dc04cf8fbbf1e82d5eb625948c20191e2bdcacd42877eaa4148e1de622cce4d4875625762cd87bfac2b7139e0bfb275d3f5d6d3c4df36cb2ce547076cca91718922b603d063e0e525a07873272e22dbe7c2fa93a4cbfc569f0a7909131bf2c424c363a8cab8c88ccf5dab2d7a775cd2d39b56abb4558909ec852bcefdbcce989c063575b40b9be68c1aefe3b885258141786fe54cd797b52709db9103e0590b279e84b54361197de44047809a8028a9236b7ddfad20bb40aacd98d5c87cf6bcc1e5115f1fc8d6584e295bc880fc15d769e8afb95abbfd77cf23f7a4c5595596e1d3576d121cf6b2da786a08aa7104c5e0ac87efadc220bdc5f643f0b7317b4eff4803bbf6a21d9d0ba76885c88a06279ddf29c24e1ecd5ae68f44241a655875aaac68b01a6228bbdab9790c3a8a54e2c121a04aaa410171e6c6e3fd82b3219f9e5cc8320d9a6c70dee95bae49380290b7ed3bfb1ee439d9cd24423d6f79a5b4e28564816d5becdcab56043bdd2b79e5b5e8eb654591e0e4b625d0b44527080dff245a0a5c00b611a678db9c76251c6fbaffdcc69991555ebe1511df29340e2ac7ee4f1b0b1e1d0d28be8ea2b275b7d669212b45b7b97eea3f484d0cd83513a4d659a2f311ca087ccfdf190c8690886792a1cc1d480fc9d9399655527a99043bf2629b1f0a6a10c22c7d19755abf3fc70d7f1f01cc85de13a94152f280594a83f8c11a047a2eabbdf61099a19e6fafa288b5213b6a939ac7c35d03c0963ed82ae4ea1fe8520d9a246f4c0777b5a1d3273d12c9e995d7598888ed925556401ecea34c67c41c8a7fe81e5ef6478d98862aa68517d3a9ab26b96ea883061d36a3e6e4c3df9f30ed6824a4cf5b10247864dbbf954c73c239eb6086d7ad51ab9c0918663a98226f01a5dad19237fffe525ec7589aa29af8fa47be3be0118335f0c7aa3d1fc31103eb1500695fd131b840f163701b6b787aa2b7d51bcbd060f27e0e7efa940aa561c30ec8926b58b828749cbb533b30e7884d6955f1f2b6491af29b8b3d354b3f28d73f00371be2e80a19e616724ae6d8b5a6aa3a01232b40b1f331fa7e41e5ff1f46563c605be141b084e37db7bbc78537497480e022c6361bdc0ea35053452125430542fdb88d7726b4c695e80202d3333220390cf9be8210242eea60750f4a98cdc6e737553a4eab8c1ed7d95a624a4db537f0cd4c728121f88b144ac216f019b0c7429b1df9750db9963261254b1c3b38905d28f80e114fe7eb550f97ae66c7c742d3c231408f488acd91ee7cf43e01970b198a872233ba867195242c894e39ef5c92e89fbacea6d05eb5598e1278f79d084144aa105b1ea74d254f9ff9846c2b5a334877c09444fc87c289aafaad58966bdb3382d7e8c3c0f95031110ac169a38a96aa6deb848288215c6f5ba6777092c4cb207cfcc0561e29d47999972b50fb1596161a28799581dbd0364ff4ebd5fa4b8b6231ec06d9ccf236b37f2f37957c518f062f95460965da6e013ddf82709da585fcc701a03b82b366321f0a22e1d554da6c37d37c184380f2a454f5a1f67271dd16f98b56c58aab72f54ac250161cdf6a3356a53ce55b41ad1edfed65007dc75bd941fa779db3dd7992b69a2a1053f5636371835e69a883b8eb708538ca09389a3fe20ef814d24a86f62e87c720e2664be783991e28fd81e97535143ca8a3bce8b41f443303a260801b02a7399069a252c8c6da6694ff267636f159eb1729af0e606509eb2cf9664de2edcfb0f148080965c1ab1ace4fce70ccd14c22a1168892475b71ebc07128d81abebc9dc0844025b942db437820eb732e1d64bcfce873dba459bfe907997682c821d78a2af52997598422f5c6f1a9d8d8d41fc39367d1d2c49dfa4329a3549235c211c2be2d38bd3de148ec6ec0021fc018335a8a1432acf69e73ac0c43db6e9bbe9c5019057ae7faac0532a727633015d64aa3039aeb6b5ceafbade69ad410f82c713b77bc14a716a65f34348e0d1ba1d595021499a3e86698bd79f25bfefedeba2ef09c9e648a58801582caa36b4707c8488d4fe5ee582173ff1cb2ea70e2b4456b3ca6c79fd83b88ab62b183166c80643c1a412f14fa3e0363202e76354b911e7da381a5e2c64cb6ece36a3186181e8feb776666458a19324895f425674ada1cc601c8b628ba8df4b0bed77c8a7742844e154565ffb29328cf5a6be26286575fa38c0df81de0904dfcf2ee783e2b99a70004b09c3eee435540c8a03bfc0618f3bfe6dcbe943bc27be76b8cdd36b8d91743ad2d81ffd2779c2ec4e507601cfbcd16b9f8278f1167d75b9b608ab58e6eb520003733143ac408cfd6bb72d593d71e8eadf87a98e4acb95e02fd1f0685759f7ac3902c30740e30eb68343509cf89e4d98132e897b3593ae1820449c9688d702e1543f3ae6a3f4beafbd217f9c97fb9e6007439acd7545953319ed12213e19af00029ac7ba810dc6ca38838655a0aff815e439603ebb008b424c7c6fd98b3293c627d573bee91923c44faaa10c372ef48174b295f0a1477ba6cd91a8ffb54048e9ab76c2f099f1f50b56c1dfcafc89b08b2b21aca1ab52663b031635571a3e5b7368256fb5977e1cb96699020d0d17710af5f694ef13f2888d856a031571f0ec2030930ca22b9b8b521a67428352fdb3560e4de9efc8deed6f004d07e3fe501ee6c97a8f6f8ba261a598882539a0a4f80bc658df38d984c494a3cca8b862f595017b2eae171f29eed80a7d0d99effad83bed2776bcddb8aeb5ba07e74eaedf98e867d8334f94cf2ed398aace1d5f3d26c48e3129be38cf3d209892f95e4a34b6aad556ac262ee6819af55b2b7acc08b116a306e2a217cc09d67ce56ded4ac4da01ad42b4cf7727320747dc28a91dbc30d824fec13370705344946ad4cc299a51c6f59b42eeb1ad05788b6d5eede0f1b7fa8c8a5ddbc9b03b29e39c9fbfbf6663ca389fcce54fccf1a8c2c8ff69e776a9c9fe8251268f75bfeae8a2e161b1b1fcb122ccaf0cb0806d5074ad6c2e15f7453dd439b6527c92a8e417055aea07d7b2636adcbf8d78d0b7906edf8347c5f382752f2575e7eff05f5e63e57a464eae062611ecfe69753d350facd47893d4216ea44311c1c3beaf1370a0f00451e6b35c74adb9c0ace0c29f578168e3c9b2fb66b1c3a8f57ec0589db24b402b69894fec9c067bef28da204eab7bcea0d52f37a0a7d1601a10cbdb0db5dabd2ab181fd9d86354ef11e470b8782fa1e5f562e627dc9e7ba51614f115a6feb18933f60c19860c9e7a5ad2e24f497c756bfe34f9275b859b63a25358ec4d2c97c7a50f51872a2d49da5587682a111e5f0dd61d16176efd65fedab3e2f720347eb19b395b20fe8b39588c1fec5e2174464edf925b64e985d3d5085f74df2209dec8cdfe2e0cdf35aed3ab482040efe388a2423844fb97a0170df8782496d3d6a0ff59c5d9bd70cff029647d5ff09366ccd60b7279158c250e09e33dcb31f3bf0b7d52f75311403b328ff529c5a2341da801e01c39dc667bb2f4245281fe4be1e46075c21d5fcceb90931e43a5df1e6a44fcdb2efad1b3b88f1ad11c6c3de4a98faf86dadfefc98b9e201fd4326b602c1fdefec0051dc832e8628b9970d73935104a38e19ab0ab835d3760e8143589b1ce2367fabe7a5041f26b01d633e3df4ca69177c9670c118ba31e09654774a7ddd38577e2af80bded45bc00426c37578267a1c5b969c1e2d95fadda88b0b3debf0539572c4d071e1d38f5062f3a734296cc99ba828407a55b32b43c62466b047861b809b3a13c983c3dd0196a6725333fc7c03a6da793f0f9500afe461dfa15e46fe40218b2641b4e3bcf7c60c74274eca38f6fd96e62986b31ada5cede469745ca6546207de0e1ccdc9a09d285a66afae9e3df74a8952981f7f4254403838b64c6afb11dd88b474a12df07c28774b14e4e71d89b6abcf17196139189ee431b29eec8eb06028c7d8d38eb9093987157c8569ab43819a5b923145fc4500ccf0d2d5a6e1bd8e998deabba3d3d0cf60cb666313d539cc09e208b0ad4f66c4d71704f65f375ac5ccbe9eb407a67ac13215d2dcdd7bee086d1868fcf5c2785105989f1a4e70f0857b483bd71234e7862f0b781a193770e58f786d2ae756f78c26285c4cb5e23fe78ffa6f185117cb0570b3fe6a2291fa0b8062c5b9b074de0e542ba78710fed58f649aad9195b1a1083de865bd67213c24f42ef6d85d56fc08834ce50c4e42ea789aaf25a26629b6ecf383a8b116a6f1fa64b5b7737f75aa4a3ec9c6e04b07083cec1d35244d249221ebe4168d08f91a86605c8476967e526dde917970eecfaca371fb35aebf7f7eada9ad51acd035a0815a248663b25628bb60dc84596291eacda9b95b0c847c832368e271f406c98e3a5114a5a9129b169d009d824004611af1a358eb9ac891bc1551905d7a88daaaffa3ab8074d6d99ebfee00059eccbe7c3139c310de3dbf74594e095ecec9384c6b28413f4bdb9d51bf93f659013c9e49a5a24db2d0199f742db87bd7131779035e776c83e1e1252c2386b87aea40cfbcd438ab9e786c67c2254e480f56689fc390175da43d9097570209a818e13de0d806f7b9dd0f296c0db9f6c909d084d5e1ef6b5c0727575544c592336873961b26d2678377a031025dddf4d2c7118f6c9d1863a63872cdf973adf5c12443fee2acbdf75eb83e52bedc3d868386e260ecbf91326a9c98854597e68cb8f952b31d5864fda9d413059bc37d4d7c8aa544575f0befd5f7fa602b34f30a1265593ac43cf154338412eb87725b521f4a3734591e9c1bf2484b98983e00fa2d4ef9c2bc87614e134fb78cc7fec7405ad1fc01f913913f9b52ecd31129b90c4dbbcb0d659667a49c468093a526a61b3d6261c672b84d2c9452e3c906fba9c198d45155286c3e62ea39e09c90bf78fe193281df5e9ffdc30cac65b7b04019c8b440348c57ab1a43038bf2ecc69a34ffd143588408761d71f56bc89ff157d0d2e7be5cd989d66210f7afb8fdb72a2f00e4a72ba1efad7fcb72c33022cdd38f38284591cf0574d1245ee7c680efa0ebe6568ed1024bd5c91d36cb4d7b01b66182a09296f97b91830cc2c5dae8ec408df17c04ed746aa550ee54a120b15b8df48a6801885b1b92e8fc14c697c297189c4edb14a5310057d6969959afa81fd65a031e79d754d007e32a39cf83c30d16965e1a775f0ca5a36ba28c5e34ab5aca81ef243beb0d290bb2af2632fcefb97b9c6d39c3322573dff0e05d8af34dbf8d3c8f75e0a1aeed6ff5e32ad1feefda2b967346c03b99cb83876eb1de5b512cde4592df176c2078482e81f52fb8e373004f9737258ef88233f0d3397545fbe3b49bb0ff26083b0dd267ec55508509c714ae07076ae8ace364b27cd018ffc145d6ad3c9aacb54cfec98c6df9375a571d7591a6b6d0bd29fd7fdebc7a8932937db5a0f78ba5379d3eca4182a810411af02ef55c592c19eb0b177cda052473607fe3d7b7bc0d397d956f59444f34eda0af46dc2409c148d45f699e0a5bdb19fed28892c8059d1eddb23000a63e32fd7560fb6a76ddbb7f0f153821bb1edf91a36fb6aef78db3ca1ab1ff6064114c379a8ac9280d4f931ce59801bc5a1cdecbbb7f6a51d9bf85a1c81182cae1f39b6723b4b7e4e31d548422911839a6277909df81ab629b871089820d378f29bcc3579b0389bdde1a27f05819dc84220ce5c13f26e8e8fa726b2d489283d590f74304f9c786d2b0239791ccbdefa1cfd22e0494556a497e2b0fc9869086e291dca83a87450312bc0063663d6ac355c950b7ecc32c953b278425595d0b9298e72b7b5097cde6e4f0af8cfa209998de89f26552106f0cf58361f9d58bfa714c09ee393e1d2c812a710d6536dde575990066609c8789a79b85b42c19d273957ffc342a5246c60ff264332a76d11ff0fae6883787d9b1654f3acdfd9141a998720a77e3aa8490c0c67afb80d3f004844d8431d345bffa2ffeea437443ad3d71d5deb144c4b37fe6f4eb101940c23473a99ea98382d9c765f8426d76c5fc7becc0c117cf469b5c489a580c56a2bbeb31d2f5b23c57272089f806f403ebf14eae33aa83ae6da8664c0b88f1021aaa2029f2827255bc40a115ef59281ad9aeb10e0bd1f809e8bf22b41687a21cf9b867571cef8b9e772053b7f1b4b1bf6dac514ee9497c69afc09416c344b354a887501ecd3756ad775b2bbeea7dfb108c45f2c186e005a07def9e33f3694b0e5ea5a4a0352136428a45337f36f1a63bc99afef8ac35ccd8587b9dc4f81ab09dddffe3d3fb89a6879f2c019335e806dd12f03965780bc871d458dbdaec3e24caa584155db3bb961d40f21d62f5fabe7b47ed48b9626647a1f02c4d1a9f514b22adbab9e346b6c2e0456ada2337f07e9c749c7e40c2617b548b37a0197d86dcaa090c5d2c303113824b570236feebabee536c55bbfd712eaf89241a3a3035b020ad8b55fed62fe427130812a7f092ca31f7cc7483fece0a92c6db54425c4497fd316824a41ff28bd99718ab93136261b6425ac4040f94d5813204a0d8cad38a1270c59c5088e880dfd4de7962b1e9847d7386b84ddffbe885b25e5c7fa21da27c64749ae9fa24edc9797a8117a0e5e858539a15d1de25c2031774c05a7d411d93c0d1ce71c52ad4365a42ea201e681c787e8e70ef733cd571e78f09055fa9e8d77fcc5f853ec78c60bf94a92b56b9c53199efb35f71465dde3ef455259e221bdf33983e53f6dd50dbd15ffd813d5f9fbe5d5efd603021fd11f7db344f96d1a23251097d176b20465aeb2acddf3951d309b954f05306695ac5b7da489198a9b4c06677083daa2178ae858a2a1ea0bc51742cb0030605cfe774a37dff3fe3743ddd2e525c55941489cb3d0a4ea613a51eb5078ae0044cd8bfbe7962da932cd6708bda00b6bd9fa2d71445f4a9767c1b796dbde22cb87b625c04974c83dc8c3bf1552eaea1e0a736be9129f34e0471ac63b9529d83dac099018245f8d11c8479d44fe72011113f749eba8931cf3a90aeb330243699b62a2873c9e331c0b8640b605191aaca9fec493caed44f9a59f62c24f875f5c79802bef6d0551822e89fc3fc91d3c1706305b081abbbc8dca646c6db4855d0416a0a37ada2180a52fd740b0a5f20bce773058872d9c57903cd108d6e7a7cf195c9fc6fa58a0fd9f78dff0d8d1f496ad279e050fc4aa1ebed376cae96d1af9a01af6b5b56c4f09a59685e977080307884fe2bf6b266b6ce5c3b02ce6d87de37b38e14186ce4cd990b9772df578a656e2705e768226d45d189af21e0aedbc040b712829fb1f6c387149140ce7ab232110424c510ca4910f160e77966992dfb23fd619bc9695e8ab990992c332451a8e9e7c1d86c8c5814a6012108c04725225a84a74593e2f659f9390bbe8014236ebacd8f48627de40d306823885e75099428a66ba84061e3f00e74736b4082dcf2b310b49ca03cb5334aa1b3424ba50d154630f7a2a1272e93560991b4864ef5edbcf3d91591ef784e762bf9029141c554a151c1057fcf59aab79a43c0cd3e65c930e42187d8d724916701c8a3e5d8f96016f8593b3ce1425c39e15b306dcf21df0bb907654764605ee7acaa8103e906899abe2b891c6d0dcca5685517f3cb00307d9946fffaf6f59cd6c068331a913a7ca677fa34959b6548d743120a08156487f9d4b74a58ef33d9b65a76bd9f94aa5a10f7282d77c94108aaddad7802bd18a86e11aadc5d294a613bcd5c55c33813e58f7df30917ddfb8b4f53f873b535242b768fc11a0b56741809a052b88db9a49de57911a9094d8e92022f84f312beaf229f662eb6f24c3b52a1712f42c3d1c07cf01d2218848e04069d031e1fc429927f475025021b3711d437823b43d0b2bf5280ecb7d430b16cccb39fbbc914d2f95df2339dd039e9ba2d5da07090d642c0f1f4917597f67a293803af7c9225bddac80376da21a7fa8efcc05043de96a560f3accc75011085e9e30990ada76cb62cefdebd5d6b3ad461f31bebccf761fa6f48ce185b8973bce005e3e2d9f5f7b4a148c17c73003479997d9bda4e2fbf77384869fcdda12a44a7325a6334d4b6ba02eae68dde1deda73ef81e1777e7eb3f2d80c236cbda0122e30c5b844453f45788d05babea368f75e21881d853d1504ef8546e764ebdd99e6653078089008d7d70512da7f085081cbae29468c8860db9bca2601600a77b124286e02b1d84462b00ee6dcdc93f8bacedf6d6b413f2fbcc78e3fb85fcfcd961fff410967514c6fde76d7c33a4ccaf19f8d7c81fb8eb3d08ef8761a574d05c5975183f80137a60d83bac6681036b9a91adcbc30d343c5346472ce464ef60651e81be04bb3ba925b611b002f99c573e4b09a000d0a237539aa57568db4fd2872c574082203246a60553ed08f5da916837958a2c1d4916c25c58a5b3acf0d70ed853321d40a4b51bde5c3ed74c247c28bb29bbac3b5e3660dd413c3f7b10b856c05a209b45096974aac007b72c62e3279d38a56bc801d5c4edf5d08e7d61110768cb161d7f3fc9cd6d44eefed46a694280c5edb895f6b69ad75c29c5467f6758d4b62fd8dbc5d9ddb19ec801a7aa811f56eb5461acf254f63c2000872c6b037d8698fbbd6083b00159055ae42f6bf740376df75d1f6b2df4a2f2099d1629f94c3eca2d81a4286db02a2ef051ee8408d38bfb5a32a638804645d0b3de03d2e5436c60233bb358d7ebfae15c4497dd63077800984febedc8d685e5892a4f19bb61d60bbc86472d3b3db5a0117c22051960624031755b257acac1bf234c58ead4b5121bd3a12f481824d10cdecb8b1dd6bd3cd79512e945a432157cd3c48fa4d8ec7ea02963aa8c1d677be75a046d2216fb4d1c91565b2beb494d83c3fe41f47e44099f3dc1541a6dd59c73668aeb5ad3736c13157708261964218ab28ddb546d134af0115d7f4962360f83688b17006f915436cfbdba6f744bbfba8edc02c3fdda33a28b33fb8bf0fdff3bf7a1064bdd04e4f3440763ceed24e9c0a71506bb49f9b1133d35cdea85f3ce256891ec321a0a1467ccd378dcf65c86898bd6f748bfa2c0c35b536c13052421e8979fe856b24d1f164bea972302266d63b882bd83a668f26425094114af751528679ccd515b5d26b3e9bbafa801a8bb468ceddecd62af3d44931ebc654d51a97c3dad27cdbe41462d436009fbd79194637519cc523f48783905b7c8353f70104f44958950e041438b5ab522f4366dd966553eeea9cb3917e189dd631c7e3bd332df774d60252ca35375f178bbfb2c3edecd75840a3f7cfd4187e4b2d684cd9cd6a5dcced57fcda4d9229ac2596374c49ae289f17374156d9e9a5ca2845a4e487dc0c97bfd46fbb12fc7572766dfc215475637e0b037ae184fd4b4f060a6a42673539eb7326df78a5d1120a98a3bbbc155488e8ddf8d6eac84e1c8988bd09531ead97e333a26a219faef71f0c17aa8631d7338d614bf1af448a31c40d32b62cd74228f463cc788649256b7daa2342a87feb7df73f2d4dca5b743b8dbde85fe83f6957111dbb01b5b4ae36d56a328a31017945d34b0fb2399b39322ca2693d5b0a456351fc013c4dfdc17cab3d6d279b18cf60f0e9ac13cc124c96dd8193d96a97823076117c8b0a83b8a6ce42f7caf298a55867624f6055cd66bb1af3cda4b51beef336029c70cca359012193149026372e6b870f86be0e9bda752df69faa25bc08acf3bbcfdce47b44b6d4a06b48102a0eb7ff5f5607893ebd770c2a75fda1bc0bc69f27e49495b5c1cb5473360cb13b752ba83dbf368b917e0f6de219379ccf5030c600b028741d394807bb609673a239fd19c6bfed3ad5a072aa402c4038fc455132e5e89f337836b3a0f57f2419d833fa38e52f50a8b18a61841ac66e72b0fa8566e901fbf36e90410c21ebfee8c8af0be357a30d4f514de3f28b63e43dc07ac5a7f3a637040ded8326dbb5df32deec5a9d924d72f0643fec05b82f38d579b6e5945dac841defa881518b07a7df44f6c2134b685196f175512cbc97d5e31768c48ded6c1ef91d5f72f55a37bc8274654ea8bf7c9d42117c881bdb80829daedd684cc166bf4b74bbfe181d0e686f87271154e6e60bb831177f0f9178a298055d8a978cae46f306d54a68a100d016c73b97e1e0699e8e514d971b47bd1a2299262dcbcf97de58f73c347ca6e576fd1da72c9c9fa8b5baf5c835cfe56213632f766ba5bcc09c99147d70d39d6890ebee1493c45321df0fe7fc055386a3aff63f6e16bb4f685ec209ade1bde25796e0811097dbf0053a84a259c51e0a610b9a6a1358a0a98aeff9773f8a8c7295f4bb1d059bb7cf74fbaf01dcc12109fb4c46ff9084bee201683d4eebaedc1505c032d403f13fe8819aa826848116e62779496968bc9101eafff3f70b1ec8962db32b8c17edfc10933f30c156412cab9962b7782e709910a62f51a29b457182c9a47879efaf63c8e56b089096bf349c06d2135a3d7a04b6bc6af83975b8b77151c5d6cabee12d763441b9b49ad36b146b4304aea39b661a88029494d2d20a3e3cf1903c411839278eb5a67508bcee6628c1c22b3a00b1728f5fe165fe3cac81a7d5a9354d164b426e3b3a2e71c6a24e308c348a3c21799f182caa739613895ebc88faba0e670910d1842fff07dc6fc42a6b6b7891dbdf960c68e0e819fcac02df77009637178e10f6c1c8d145fb5979351a8b9a0be1c37bb9786bb923ce24b94b95ad4a42e60618605f84cd7ec37d1069040dda9c5248bf824ddcd9f9ca7cdc33215645ae69746dc3645967bfc3e7cb15b017551ee654296e877b511f6d0500147c03feb0f0fd10a5bb2282b7ba61e1d5d8182350a72734161c9497433b916e1e90b3e39447a2de9245752cb0406124d1d760dcfc04ebd3885a0cb21e8700b0828a6ad86c8f2e7bb4c5e0fa00a36f86e2ae675097e5ac5b824a6e0101ee74464b8f1f66474c03ce8cddbaf58c38a14f0b5ed047138143085e5cd5de89a6550abf93afe6241b08bc5a663b474f9b08aa68573fa8be88b562dd2b0786f17f879036e06c91db1f84fa0a044445ae89cbe189b1e3e6926babacaab39d8787e16a205e0aa581307f63ca4825454caa0b03e224a0b6b6d946637de65ae194d1a1c2758def33d8cbf0ed4dc8162647f2f0722fda09887045746a4ef333c82a9029609bf7005ae0c5ba7a8da1e3589977b93da1aedcbcdf275a9541685cddc902340c0c475cf227cddff296fad6d6697fcb57952433fc8980095247fb1b02517bef0dd20edd31e1d0bd588a08892f9dc5d4f1f25baa5248f66357557efb3f2c355fc907834e6244404772f465ba7ec9cedb56f4fa7c608d298e083bccb063bc6a041db038b5e1cc58bfbb75a16be418817060119c3266d3ad974702cec4754affa71f32ab3209726c2966b03ea18efed5262cfc2f8e0d0b837a2471da690ab368eb393e4dd7e40698dd188eb993423808729b013260ebbca7d980ac689722e314adbc74357281f848eea928768cb8dc54df436549a13d163a34b3167ad21ee4034692919fd23484eb4e200e8e2e0e823c20c98a2eb07e73b118a9699715b4a5d1bfa54972bdb759454aa7231644613e8f85291d31330c0c9dcef9743aad2cb18ad46f260116785875c468b46ad4edfe982219220fc9f65d20a0a690a8a27a9620c492a448c59f806843cae14840ec1f5d66889ef3e70f257dadeb13e83b7b3b74a29ec3182c6c65cc77b455c9ac57d75bc5bc7f5984cc4d925be552def53362f03a8ee9d70ea5a3eb3916cf1bc824982fef07f5d7169f202aa02ba97b57d8ff04ab0d325a909c7da07762ed530721918fb28faad11118e2703091ca23d231e44b7324ad73ba584a8ccdb8687b238126c7028975dd8ffad39e8a0c34c60264e276ad6f8ed5654885404aac66bf89f71cb8097ff91c79da762d1aa2203c3cfaeb2127dffc70ebe5dcb93c68ed5d5a9d25bc12974279d77961564803ab346f5a500721ceb1dd44d99229832c57e45a31a57171bc8e6c0c9ec3ef68579751a521387ef642c8fd2c5088ea21902916e8a43334ab40c953118cdcda3717bd69480e83387d861b591dc65f7af33eaca254c296b5fc84b2ab954e32250a8583597bd2e85a28c869627e0fcde999ba1f950db140f768f11669d34871fcef4c77b31cead334c57db2dcda3e37420f7c1687b2432fb3cec8a11e3286d00ce18ce6b339447f4f1a9151f06c9a4d4b15d9b7bfec3695fa545c42bbb381121a64798d00523d5f513d74bf8cc2887d231e2985e53952c44f8400b9077486335a0e6c76ecbb4bc9e2bbd5990185f377736c730621d01ac35884be1c3e5eed2ee70dfee4fd82be6ab4ba963dd54e75db49e52d7899826db23a70b7265bf961ef6c5ba35b895a3e4f0f3c564373ab33c93884c37baa12056e36fc2d08e82a05a3e7e6be631ca264c53ba0af93558c15a99b7979e2e1d80d5b71deb757689c0e652e33ab2d51178b188a7f0910592e12f37bfce120db9faa3a3d9219ad6a2259397ba0c4323f26b0891f609b3d77cb88afdbc16425e1ca21698acc071f28e11c3b26f218bcfdcb4dc529e5f3e198f3b0a8eda48b8a8de5670049f063a6789f126c2d9de45d1806d1e498bf8b0382e37744455fca0131a6ae8fa3eee1b2ff8d1908e098bd5610306d8c8133e867de286cd20ab5efd9b6d277be1f1c22b0ae5e522dea456a3db81f8bd959a73905696f0b788d8a32de3e20d423e2a79626aea0561df7ddfcdfe8a5a991939fe9e8ae9e5283a70cacb9cd6023c3da2ac4ad60449853eb7c655973362123ab012ca2557d225098c5206181eff3e071b9790b46879e6aa16210f8f0c76d96bd170b20f4180de1fd8a27cebbadbcee66f6bc8d16ce96be7305a559a61fb055764be7f0742f258323aeff18bdc9251c6df856f75b648835f0494b1cea4001e0ca0b8f9ea5052d51771ee000d70434c742f68a732a88a702a7e4d52f27156f92f1c2b8f072113ac6e4317e8b9cd9b183a2444ec418c3260c24f864f0ebfdbe30a94e2ef5f87a3fb061d6f8a1935ed43e10330abd91e1312df7e1bb5259e5c6c7b08b3fad8b8b8ee2d2bd3c847d2ce34de77caf0104680dd1f70d71995634734b5fe9f3295e9e28f689d71a2b8fa2abe405ae9bda89a57a229f363bef47000de0c1525557c6313efd698c140c4dd877beec43d6a878afc8d09eaa8f91294bc8cedf4d068f500d1af04d4709b32865dd51e0793419b4c07a901e33b6b058f812ac0d2ab1bc912a4ea1e9c223288c3b6785dc600bf4acb59c8399ef566f0d864a8b65cc05f7eea7446e5566a6d2f0912bc8575195f8ace4bc8654126e5c8bb6176e26b84417bd1f8d812b5c688f88d38b7e3b9ac09f60e7cc414b9fc29bb96f973f1f6404a6b01af7dfedb506e3509dc3ed0c5ef1c5769df786809d6b8c732a8ea7c7015f55d02788024bc9c5397a8d84548f863d3b29acc8139c395e88e44c703dc397af8b3df1d703f068bd50bc1f1390444a707a4de0ef7273d1d44684a4f074ef8edb7389cee732b2783fe1f209634d06c3390825441e2cc94c94738929c98f288f76066b87b3ffaf8fa3b12daf23420096626372822792592fb832da4caeb0fecb4aee73dd5815f67e04bf0408c6012731127035b0cd42a058bed96ac37a8a2078dcdbd51636313caba33da9f9fb30a702562c0a2899b44c33cbc59b491d5d7ced99dbd326446b6baad2aa03da99a991e47f0395ded91a0b46d363f4847eca361efae5a471bbe6645982e6795270694eeaf933a68426a388fcd44a6d54966552a58e6d1e77a1d794a55030ad464339068830478a334099f224e133d17cf9feba53ff542bc0404c27dc1d07b3f391b28c91a8aa72987c1044474c8096154e94aa8192c23bdb0f418ad1cb877247f6a1c6bd481c5ebecde53dd26ca796f971893c39a56b0277af12cbe60758f334385eab39b52e36c0fd5489b66952d2735a041d66e00c45480ede9ef2528d8707ec3180e7cb6904fff10168f4258303eae89474267919c00d8becf0c02f1316f2c2127051c876fd6b61c7d8caf72b5f99c486515476924820a71ec04e2f7afd20f518f4029dd7408d07275a1e13a591ed9a85ed7c79efc891ee182f7536ef4ff7cf82414b50faf977b5a3d1f40781092ff2b3d2fe85339eab1850e49515487e756deb1f19f202b06b08f0becd0dcb6308761e217b73f66441a6daf73993e339d6242316fb2fa35754ad457d8df2224d03fe58a25ca3b7953857b65d9612fa60185e30b0b86e1e256fed383f3b0bb9c5e1902d265c380acbbc277cb09bc6d7212a60ccd5c2510c5d0c91ab49fb63a11bed91af971518ddd6a6698e79aad20ec3e43d5340c3ebc24b492262a1188e7dc0d8ca8bf510c644be9fb3c08dd4878eac8385908555cb524aa8b5b11bc26b5af9d2904e16126d45c7b10174dbd8a50a8e330d27f9f843836d3300db68ae3a825cd7faa3602d52140c22783b1d11d9accd451f38388b4110f73626a30543577f89c8b0da09923b58888f316b0f725c9d7b906fd00957e6360de469fec815393f0ed5486839fc34aee581afe511c627e1b179d479defb887b78207ce89b3b721667de100bbf1889d493c2bbe8198f77ab54a3c7b5306a690c8f832822434e42080242c21cb8dd19ee37ac4cac101f55df20ce952ceba5948dee93921770581d0075eb78e78363416940e77c88385df4c3f079adf86c023e4b85e58ca3dea73c61c25328ec70bb227ce0087a6a608510dd649a2d890d4282eec7d17acc1a9dbbd2bb249bd451e8d8c5ba516dd2313c0df55e5d2f925ee7b6c97e1f12c47e3f3080790467690d2977549c41f455ab0aa4733f10f13b050371047145041bf6526e916c88f6330a175c8cfaa81a9cd85bcd03b3dce7feaa5540468429a1ba9382d90238bc77ca9ee781ff2d5b8b55f58920b07dfe0e45c0b645f106369629aadc73ef3355270694f29a9f03abc9d75e6509e943dabee3aed383aa181780d6bf0dcb3f52b1db9fa3d25d10fb7ae1dff531b11064d446cf8b7f5a90d371173b102d0cfaffac9c739fc903a9a2744edcbccdf754cbebfc4c2d0f8c1aeda214306d28c819702ccd3d2a7e8d567cbdf169476b8702e9c9fcb8bbe5431b86837034b6becedafab66e99a424e26e16b24d39ba9fe7aa74529d394c03eeb8636fb803fd05b24559a921be170f38e0714f5f350805726e59fa4610200d8d2bb5d281d0919cbf7b609bb0410829144fae0ae3038482f02946f27f04e663390abba41a661eebbc500af464d1c004cae8996ef5ad6e473853d1272bb99e347fe12d6506409e67611f9edc9d4b26c4c155b47a00dc961e9c565f81f594e6fabe7f81d6ee48e53babf138a9a8b0affc98b02e777e3b2407127ea68a82d79997f25619bef45045807c0e881a2dfbf689c573671b25f1cc75c46bafd109a1158ab79bc248f5204199a288183abee2f4dfa2f8271c88eb55add4a9636b2eb8caa965fba523a77057163fcf2285ec09642032bed65b7b81f48ae98db1890585fbb244824107022bf942763b5b22b2a92c8daef169bd11e61c7a7628255f72a347e7131aa74a088d19ff4237e956d2cf3a45e4338c2acec2cd7cacd43c1eff53c9d5fa1b9aa6037003916b530882b9fe2bb49e65618c28334abffaf09e1b9424373fcea1e80575b6da4914d7369ea531302eb65ce05cb38813bbe94ba9fb5a7606ac6a0d27de258fd139c43dd8c75f1b578afb3fab5cf5ae846978d128101b5cba37fc8727cf9726d3afdc622196e51985f7010cc11ca791513d4055ccc28ce4f0c55f3ba1d8fd74efa1005c52b7de075fcf27812bd30c959558937318760f466fadde3d7615368406be8179fc02871d6df042bccfb5ecb50ab5bc225cc95f60fee77340324641100060acafd97632dea72ff51ecbd477c544d366bb8c6a1f982aecace7689c39324832c9868e61cb4fce0fd825d764fd377860a86f69633f6054b33594e0ed72c95c8c185d41556d0175580bb102bae11e6dc00c5e15b67fc157147460f05b6f9a8573f2721a272293099d76c124ad63ebb8373824f2c1f951b4a9310f2da8d8959a509d1e22f7c22e863ebae046e89c406ac0ebe1e3017f8cc853d7b1d182c3ae5cc3393e03caa8776798f1439079006e2835d07b024ae5420a1b06449d3cdff22b0c80ec23a7963ad09f7f9512e20977d60422a2418441d8b6d0892bbac6a7776836ae62fb077638963c255349eb59fe2a1e23f95d89f7abbbb1ab7bcc588ef52005fcb1148f5a48594c77a2b655b901b7c4ee9f9705c78b43fd3528074ba235c5b64340ec06d9213c70434d054d2e89a44fa09047c04723d296930fe9e1c6b7c8bcdfc7f01c0cb3813edc71770ee0c0b432bb15067b0ceb8267fbcde2ee3a447ddfb93ce227d4b25328de76188d12bb97645d99166c83a62754492a4461c7c1015ed8c8b371f5117882812f06b3c32753062548a4d799db5daebfc688e8e7e93a752ebf9cdc398f4affbba3f0f37736849747321752a4cef095060e7a7b031ca341a823ad2370361c20822fb8dc269f488bc5a48ce1b3531ff3aac3a7679f0ff57e43285f6f6c72cc90fec8181984931abb4c35b303fa5d1c3a49acbe0a5cbd92c007de588a39175610482c0c77977a131e062fa0645b6ef434c74880bee72f31b43f36ac4a3d2cfe1a29d2e80e51b2509ac9b16b6a687d344e4e8c23a1755bc50bea8a24bd41632806f0af1c07e740133c5471a6457a99d99b7624003ed9e44cd62e7743cf4e66a7984012a0fa90dd8e2487b2f1efe078f98b81f0a5b7d0687d74e1947e5363e1d6810a83b361222ea0c4556850c338d2782fa05160894d000c7c672e4aa3aff53e7d8ec2a7bacc772a80f0dafecd23bdeaeaed27f057d14e4d8d2d4ed0f30131b1ce621d11d7cba36876a06c3b5a7f3a9939b392b8d89e0285c6bc238b08f3105d494e819c1c65fa43aed58b731e6d46af341e5f9e7f12b0243ee72e10972d11284aafd848a14339dad52b8dfbd8981c8e6cbafcbaa7728bbe6d70614783577dd9c83b634b1ccc87ff7d5c27a32e07f91c000295e73c5b3f81301a0ca6ca47537a41ff7fdb9dc8066dc881ad9c341c6956b638d699d98175db05eefd5f03a3727ff65bafd20a9e1daa4be5f67175dd12fcc0982cfaf5e4c251981437f202f52732dffa4c3bb34207dcacbabd561a02dbb2acbee5066b86463c3373dfefe74ca73e469e20945a2173616f760e37cdbf7ed4d5624e3ca44b650e933ba99e9015875738571144a98352404f676910de2a02287303d2c3f71968d201f5fbc2f5c3c4648d588498547bd9fc419dfb068a37c0ae5dfbacc897aa7f6a844fd6c333eda755be21376649a6e161211238832882b4d8c21216349198b935b2e5b5b64be3ad4d700765c5a5b777c4b7ed7f33842ad566ba0e6139f243acf5ce3a6112114221446549866851ebed12f3fe55a6163dda564218abb263ac4acb4701acbd5c1579f258ac3c6d737540b3c1b39b3ac46c000c270d074b4c95a1d165abd480acfe76061f43f9a19b3883a9677ebb20a47f2826a32eace2c10ef8a9de0b83c007cbe18ff66298e5cbc5215a8c9f11fc5797dc25af4dfc7c6e4fdad9352ac6cf0dcaa731339be1ef51838d44fa9cecee29accb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
