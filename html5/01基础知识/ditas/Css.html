<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de8170c02ab962ff534d1a5ff8d7659d85f5ce9a115c8343142790e10efe5c13221f0406f762717e9b2e49f2eca19cd5fb8a02968a0e04e009f67ac44e9a9de09a4c2244b82c662c336f9bcf4c2250aeeb376629d4757ece121361199cf1afd954e0903079414eb2d5da45a2e8d64208697decefeecf9d1fe264e22497bcf478ce9ff334cddbe9259327d86138242620509c539c42b66c537118683b9554b84ea39177299dea3bb5b20412de83a6096ddf59373edf29fc3c872e0e88d6f52ebec55fd01415f8c9c0cc9d8b80f1ea733cf901776a417049abc57def3c61711bb6cc92f9fa0d085f8f680280cbf7d09c86a3cb9a55af7cc10b411393e5b6c2172f220fda1cf0f89b04887dfef1b9f923422bc104ed5948935501554367310e984e1aa7eb8061ebd4398c9d04c1504bd23681f023217d2b380af5906457c152d94d7044c7a921bf8988e9d7fb05a9d105ad4e135b93abec93d4f9927f9160527885b3105fc6e07a8e2e6cb413f5d3e2cc2e55072a202e99c061c3384746ec84b78a18513bb468b01f843db88c59a7f19ceec7fb3f00e9676f4ef52c99ddeb209eb5bf202a625751539244cef995015abd22345075e2d1bd85d6280927143a4714dcb4896072767326aa665848922910b7a11f9da5587eb7566b6dd2bb488ecb12917d0b1e6d622217954f1f19ba2ca9ff536628cb3c38fcb384548de827fd586f87c44c77b1977c728b603a2bdcc715cf76bf0faf6c0e2f6b1c3acae092026c58ea91e1f4921646db6d58a58be1bd92f17a23863f4221855bbe8fddb79711f5fefc1be09c0c5733d97d34a75f943b3619c820bbf80e147cac0f15e61298ebf14f0b362050c1857cf449f338bbcba4be5b8ffcbdafaf5bab169ec4d1555dc8a7af401b16fb99e3ff1a0bf058f30380b8a85efab8e3f90510589da5bcf2be0bfc8d42fe7cb1381159187f78a21dd3dca25018b0f9d43e7183fa0de766deca1f2865c2866b60973c987ddf7dceee528c3e1dc942e6329751a699d85a2e48d7c3c76cc0d59f35fa42296e1d193ecd6d66ea6a8f9f728c5608a1fc0dcc34220898e0f8db4d23a21987d7a5d231b2baf2abc35537e163ff151ba6dffa05e4b53c9a122f4e6d04599d116ae4a2be7355a501858d786b330d832c082e92a7763bce01d7b66294d46440d39ef42b5e4d09282366236005a1b06806fd6af0a1aac6a775631ae32b72ded5ef56617a2c71879172fb2f2cc40ca05ef6c5e6b712e85daaa4871c5a36ddd1f19b040cb8c4bab15b158b996b97835c6c248d8485ea898592e9d36249911c7fea2b649c42a43821d03451ccad850b600181e5e4e3b881ca744907996981ffa213ab10c3fe246eab424fe9c0c4d7f332994a318a6d51a0f16ac80bb463b7e8cee5c973483120536d9150a87250da84f86058db177c3584a83d9d0829b739365347edfded37efe0356a69a0b57ec7b30845ea34afc93766394800a35e98ee6cb4440e8ffc6b30b85347df497e2c2d0d53018ec95562ef143eb065eeefa81bca73cc55c8c4bc946e205a0116718ddb58f13630ef0617fc955400d1c4a161a329fef859b7c9f1fdb29b3da1cc099b399cb21046825abc973384177ea02f00603d92a55aa8af87abc50c4d6fabfeab4532ef72ed3d9db10790ec88b97223ddf417d729f8f96bb1af13e01b2f14eeb0fea4750a3d738ea3e180ebf03226bed73e2fb1813dc6e72a75be8dca910292e628ddb4c278a512aa802d01720bfed21c703f24f183e88ca0c5b509643b00e25c8095ff54be096079ca794f0e022ce8965fb053f737ec3ed4ef30ae1a333e75300b27c23a64b7e85e5d7dd43596bfef6d33a57512dc838b5e7fa3205db2b56dfb8c0ac79d44e4c1d4a66466ff7349775238f8da5b57f5a3e37249a92edfd7ee6bdfcf2392ce41e1a86d175e6017ca9ae6e5bc30ab7caf879e71ae8fe6f87fd45a899653658ddc38473cbe242b922380ef75a09a6656c62173379d0e95eedae8c6678d2bb3325025c40549cc5320972c7c7fb3ece1b168655c918f6d579a7c8adee8998e44fe4567a2bb4efd9e56e4c69c257ea7b4647a80f8b130068e24e5f5e242f5136e42b6f3827ba88cb6e7d8e2d2961d42d4cc0894edc1abc5d476cceaff84bae1950e1ef79fe467fc9fc902e6075a25e75ba41143df468529488e501cb9dd66c6ff7eebcc2885a6e8999482160f975e3dc741ba187ff8d8264ad6327731c98b1855081166d11a4d5b2d56093ac911196eee007eb05eb3e4529766748acbb38e121ab1ba0b0260c1153624ae3485810f409df283583351483a4e27625d608913bf668420b7c0d31ac005febad7095bf52d309beb6643177afea225875bc8d2c8135a2a9bc2abe03b50767e17410a8fe92b47632ca92d9db9945c19c4517a3cb14d74bfd5cb57f70ccb7f9ce0dea3f84d47693e50b5e4c42d9066208a65f53c35d9a7efb1922d18ab70e0edb8081984c935c9407f714882bedf6797544590584e62d51f7009fb1f866eca8f760dfa91376dcde16e8fd0a46670ceb52038efe2ce2109a01bc8a729cf2e083eceee0bb1f18adf49dd0af462ff6ece7a4145eb669b689c8edb68d5dd0e5126597d32081bee0ab1d6c40b808085b06248de5408a523d4f6e83614a84cebec874b79d761d378a92ef742eaea3eb668ad138f85652a6c844279a64e7d36a31f392f3d93ab523a844a85e74ceb1cfc7424ff5d80d7d9e1b8ba8b922f87067e00eb75a63cc8def8c208fcb55614381d6314eaff0b4cc37debe56fa111cf0b78f81339a1d699ab0bdb610be830dda2f69840494f1f5451e4ed52517461410a0409b09adb0549596c24255681c7fe9e2ec5480c2c387d42c16034c69069d9e3b5857290e649e42e2ff330cdeab92e53fab5d2c5268d8cfe8e66d70c66c36c6a0f461e6c71b823fc6ba5f1131ea16800f949ad7e5d3f57aa98cbfab1b75599c502343e07275f47dbd83d48437185799ba98a7c020bd28ec48aa3bbe4877ca387e1900f71d6b1823a529c176d6a167dac22cba1f6e98092b320fdad335ee3b923fe165d8ba1ab632da3c8eafdad47eb27c1667e14a08c452402a724ed411a22a2e3df353a162b150ac9f1816ca2bd65aedf67b73e41be1eae8d2a739bdd133406fecde2351f59f0755dcb4d059cb762efe365d16fc9e82cb674ae06eb1a41bc3bec3f1f1e2754d1142cdcb238cad2dce5479afb56a6413a52a976f873efd9973000bdca28183766dbc493ca7b26da8abefdb89ec5cf1fd1f08045af5035774171ce469dcd176f51fa580cd18f7e6af290484a8d88a2b7d0d9426030c57f011e62f5a4558bb1ce9b24388f703f68c3af032b7ca2c1a6cd0592b3101038d4f7def337fe616d2079213e17303c3881bf2963f220e50539f05d013d99e376723006e0dfdb311aa46db904369b364ebad285cae8bf2f5038478adf69ab145c5cf236fbbb16d9e56357cba8cf70dbd17f74fcc951aee97d4a8c3d60e3fe49f7fe226e08ace70eca868477081e834f38bf5772d5654a6aefae7168fe6b7d006f5d619af9c23d252850338addd32b442f029292b7709f9296637e0f606602eff0edbb2cde4c20cb95bb5b7cb9d800ddd6a89114b1528cb7cd4dad4214e418aca0083603f8eaee28f9c0cdbcab74e2b03d50f2b4bffd00f30b082e57e933f5e381c98f6b27e9e36e15e2b12dc2f51dfd6539acf900e08c6c2052cb46c19d808b83d6cbfeccc071d52bc9c8ecb22964dc03dbe3d4176d9754af8640b0dc3370c8e80c000db229fe53daf26b0ed7f8c10f2ea8e4b55d395ddb94789db6793a3c9ed0df75665ff9dc0e150bcaf0772c32dfae9c60f3763c11e99de4fd03a6cec3e3a33f51c8673cd2dd17d32aedaa76ea51e4d19c54772d185c735cb3c7c5abca64d6a0ed7d689de70aaaa387848bc4ef0032ca7d80e681a780621254f4cade7500c39c9215ac4dd820816b6623f0fee705217cf589b7dd9679d93c57edd18b0305f55adf44beecfefe4f591c65b3244e7ec50f20ce325b8229acb02902f1ff715b81a41a6f3763906410726535d7d356858b07caf11ba78935241e55294f5364e7bf15f40ae190ac44473fa22d79ffda86f7194702d175f41d7c58812e14bf9b2a339be5b361fdf567f0d88514185f33ec56ef3b1869e53fb78c89a2b066c20ccd79afc588f710c11d6d4eb57f85182910b9984b7f8b24b47e6326b07c3b28b06b0d39523872828af52cc74926aea976fbcc6b3fb91bd28bb25a70e4070562430fcfbae22d155f2d3eb60e5218bf63240fa2e608e61024b704c28992669786c3a2bb490d274f15972248526ac9de2997825f147f9049a46b27ee93577e9021354863c3ae7adffb97c10173e29bb0b585ce9f932660b98503cde5a35c3c0ed76609ba969981ed682addf0d78a7db94cf89c42eb1030e19be66352e7d7a9ee2edc5e1318f732faffc3bf4ed71ecf97736746a10bd70e503d6412e818d8ebcf33fe913f643507dc31439e1f74ec4e55ae2d2ca08b8cf45314009a23904e1429c09e65ee018122c5983788580600720abdcbdaca9fd106506031e1aec4de832580a53f96fe14374aa24c9d7307bdd02b554dbb7cb5734464663af4ba5b1f924e753463575627dedacea69bfb996e49cdda70f5ac6c5562b940583485a61c5e157edddc3315548979acec3ca4018a42547524fb557a119e6b78f8380002d29061b9067c1829e495b9aebccd8c5899fc477f3767d00d766d78eb43daf93cb6fb947d4ee6c44dbe27801c564980da3d39113fb19fe16024f5728187ba20834f6bf8095a7ced44eef44326872c34cdd128709bf257abd4169257ccefff68e5bef9e45966b07ece0f718f1e3971d89e208753802d2f4d513b7a6d4f44343f37f8e2b07d3811f4720bf3a3420c963151b774e7f26ff476656065f0b049d13c82a934cff8f34258d35af8ca1b6e33661d74afda6dd5ea097b387378b16afa6a7808325bb6f417890f3c858b7ba3b0f15e253e40e6af6d506d25a95f991fead96f9b15fea8d4c2c41649360fb5e1cea0c41e1fcf82d2d032592773eb69a4fc3de6fa2d720497ee775cb031a067bd89886feed00227b22a021c52b57c36601d9599ca7a34bf3125e3855fbccb9b3b457def62979638fb16ed057635b04462393a8b9de45dc8d2a92897b8bde9661845e54b3ad076818849ca6774ab26ab8d45a30d997a84bf5fb6fc57ee19d401b0254c5ce3c1f0fba2eb42445bf36443eee9fa4f64b863a2d30047a8872aa3146f7d45b41e6325286efb8bb051655443318e078f33c1941edd4cf7faa0af7d2e0232ab6b2f02183703b4e83ae56aecce68c6bae3594a218e942bfc4295ee60e6c8097e026fe3da3443858f90be8d8350ba24355cedadfd9bc9659b4630552c5883cfbfa6295e0a3fd2c26ff7b79a1a9b4aa817e3a124c2701fff72b03759a947c83272eac53131ea3867f7b36394b9b0fd617583771d36b500324a06855ba406d7fd50c4c9f1d8b547bfc6d5f1ec192a309ec381b5d297f405ca259ad43b2835ff7cb4ec1ab074f584957d2cd5ace9ff648fe0ae3ea9e7ce1f7212d20a04b515398a8356b93c846d42d6f6912e951d25d2653ca8fc607ca832ce6a2181db89e3fd173aa9317e72836043932ab00c813da8ab55f31aeac45928238e56806395f4b597f8357578404794ca39cb23efa93ddfbf504863f3c0ad30e7ed5a6d9c87864afda328bb9c72522eb06f8d7d1a0404efc464c02a3696ec51916ed30f6a155b49cc7381417657160c539abb0b13702f050147b3494c3107864721b49950a30e940c77ce510717b1010206fbd49df56cc6daf9e60d50d7a992fa4b6d84fe94e84c09204fe034e76638fb6583dc76f0875b5e409563ce9e2cd17f012d150362d152dd576cb7a47cfc2051ae208fdf466b3124c68167a83fed4dab9f26b87fb921354c25be69427ecb53432d8ad02b247a22ffc6aa234d95cfc561c23a3981b1ff55c5571fbdf4cd2867c0728dffdccab7748488c444d807e3bddeeecc543b5fb180a3d3295488c2c068556a8e3256cdb3e79a6b860803444c38981d87657e65747d1216c870233afe7ce474459781661d86446158767c40e3009861837f838e19b135eb271630f629cab52888d55e1e00ce073b163daeb654a725ffd9c3512799ed17b6684967975c40e38bb085bac435aaaef97ec88b4c780e3280d8f0d16d9a36fa9af0fe357ec2f76539275370b93ea84ccbac7c3a36eb1145eede3c04466d8d583657e3ae76ce4e415ffb9bcb970516071f73ac375b7fc57215363b65acfd9747c3fc0e6a044c2ea4f90d68e45e2c58066434593fde0b0ffea0ee362f67c7238eba5469acdb2ad7eb2c719b40c6d682efe482b13f781e51ce3295e57b05c7149ba3738bb8c63f995279038d9cc5ccb0444cab98893ecc7b5412508c8551e3a3f08d6e55ea60956ed69257a2101bd58c70dfd0230a2fe6fb6c76e0e97c5b0e7641e814eb3bb360558f6c2a3d9edcedb017af8cb4f730d0b129b294ad6e42d432f9c57c09164cd3425e27f16fc933f44b7aad04e6c6d67c512de5ea96b230079b8e024d9e40d5b65303c65ac5d99419ed80561d22ca107ee90ac16963b098bca2f09dcd16b65b9089ec5f1e144cc04d72fec3ecf205958196eb20c20c598cdabac8ad9bf200c71515da3ec79d40eb384b499608cd8de94a77fdfdb3984a87f78771cf1ad84ea6d0c25dbacd0dcf260eb375f0d31b6c1cd13ee41f3196e01d585df6975c6d195c757029c23f398a24a0658e0051349ca71f49073603063684e507a49f8a20a7339e7f3d2286b3ce3bba57ee9560e33e8c0dd54a27b04dd1e1e9f5382f092f3e3a094b41686d5d443524ae812819c0953a67ef0338902d438a4f01bb6c1de8cf0ed6a7f6e136546eae193969f8498f6e76d259eced44dedd76f8bbcf6f231c342b2422fd4edc5aa7b41b74b2652a1ccdfa24c3bdf4c88db6d7fbcd2fa09b9405665dfdabc151aba8037b705732aee7bfd9dfdbed7412fd8a7a4149c183363c30e02203673df8acabb0f04956a1e821708311923ebeb47d2eb8dce4587e31c89468f27e74f3cd7863ac40e7a2548d1e86c47fcc3f5f71defed1e12bdc365078fbf9494c0660ba990e88ffa75c6e2c60141de486f91cc9dee441c6435c739c1e5415bb8e225b55827df2740521fa13afc3b9e663764c83da4a4b468e5811a5a162788fadee4352a567d6002f3db705e3e325fb0601f1723a0a6fb0fe8341a4b1ed9e300b770f5603d1892681eeb8614af73878f6c10952d2c876be57baf8bb9d9b0516f3d5f45753db800e2d12743e307544a5029a9c1199859a229f46c642e2c9f553749b55f02413cd2241787035c76777b196aff1b882638b610b9c6a0e779b936cae4eced74de4530c2d2de840bee5375cf14c0975973f8c3bc92d6f49dcb6e33712270f363ead48bec4a303d88f6d830284877bf6a5c333e645f0bc0e3c86cbb079989db798f79033ade353d3d3f838caa1ec5b046c7c8c868902364a1958cb2a3e7eda573eeeec568631ed443afb510f15c049be6255f28838d06f0a9e9f44e5d8b2496ce9f63cf7a971a2a07bcec6efe46c8718b54a8a7d488816b616a8f4644993aafab48cff022d8583fb1236003c9d60a61a567824131cc137337cc162288d2152b8b924bd5d68cc58a0c54c0e533df509468c81be729585b38d3d00833e7a882ff19abd35e64720d61fbe3ba0d25509e42498f78f910c90b5885ef88d806479f0aee1bd365553e44b57c3e8097a360e1981b06daf5061c6129b056e1504079d50b8a158fa939dc836976f7acdfa249928eaa55adbf31a352313a3b9de0e599851759f85108d7c2601c591538b93ba4dc4dbcbb23ebfca16417a0b5653e48c416e3d1f6715fc9c7772278dd24bc4f54f83acdd64e0e5a10da0453099bd9316c71a080ac1bb69066b8c3e640bccdef705bb23f79a5bd2da2311d88da76f3304c50488e1531ee55cc23542a441a8da907cf1153f14a2e9dedd714d00e08af529e9980425f2e1089d8cac5d6e765cf134f705e691df914c42bcc7f7f3ffb0f97beb3669eb753322bc04b173cf043e8e4a7253b8232e744549a4c1aa1549bd297ec20b28318d7704661054d027ac4ce66d8c35ad48a2451d027bc6def979dab10479a086d4106cbd671b1330e7d79e2e4a5f9e91f8d3cffa44cdab4df77878de11dd9a1b8878bff590132c31e5822dbc990e262505c64ff8cf7e5e3af317534dd7b75752d8934ae7cea36b82ef31478a8a33dc75569fdbe82faeb2cbb3e7691cfab79bc422eef3b9a0b03f194a6fafd797cb855fbb5a56721e8eddff572068acb25dc04bb24ee38474c7936d4a7037b7a676e6a2b4e5d9b3696d8c3f18432e94375081bc17e0eed756e464892ba812b981fb858dd503fee338852637aa6d708f6f442bb99489c61b007a200b191c35ce7893ef064a80bc3acdfb15eb12977720c1e61dbe558cc041a1b9ca873bb0bac1a334f3897847bb88210c995f82a56046eea7a907db9ed1d9ad8c09bee63acb0e88195ebb500da033167c14fad5685348751a4cc795eba4b258996d47688823907a1ec4bbe5026a664fb4870cfeb96e701e9abe7294c29cd45e62ba8c28587dc633f1832433f707d7b055edae5358382f690835b223836059a1bcfc5815279938c96fa3e459697d87b353956560d806398a9cd0de8a2bc85385819a70186936cf2001a66ddde4e600a7d64ae082c196817ee1a02550c5aa7c361dc7f326d11cc64ae7d1112382057217d9d9349b5cb03d456d7a1024af923524ce75806f6c16c732adcbd2b5adc04d371f2f6977e9fed552261d10d52e16d9c45d981cda0dbf12d2ccf6acb8389c12ed13eedd26aec0d3239c129b6927bdde6f8fff05cff28982854b0ebe3065b2db02675810fe7306ba278039ddf6449c8266982efff67da3adb53ab28c7b91d9a2e859000852d7056811cacd406ec93b340b5c24e7603bdb7d150c79afb2946a43edbdbd8c95dcac9024eed0e6f61917ddcb72b4178d6f0a12cc924c8787f01ad8f0adb52f6a4ec2b62d20a655a01db7105551b60ab6d165f64e33230ce08ea209a6dc7c48cddf30deb3ec9e4df413706a7b01e52ff57a823eb6970ac854518e5b2ae0106a2ee495cf754365b232f1a0253cf85d2a39e2e38625719e5e2005f05daddff8fe9d986e8b9de75057daf885e1c6f722d9f847d206d2f5a665a9a34f7c63ec25f4f264e64f3f5cfcad6c7ea6c3e6886b6f226fdb75831de01c7f4f1251a03a32a281471d87f888d7a31000721d30986c5df8415b57b98a6c5cdb62bf782f6306cd0ea7b89b97613c759be018ab0a62ecb1acb8066a488b47486fa2fc0747087e1b41a459b863087aead233f3eb2935ce565934cf1aec24869b7855582a63ad1ef26a91e5c69714beb1f6765d703ea737b26b9c113363396d23be1f56610729ca62a80fad747ed9aa85d3934dac615950473da04f10e1cf4c58b46b1fd43a59a659ef91a8255b5e43069de360c0b8ed39e4d52a1afc774cbfa1c0c7601b886f1245eefe7fc1e87486ab573f38271e2c4bb8bd1a70a5eaea142580f754799cc63eac92584aba07a0dcda0367fa1f515666546478d0e1811eb4faf37ac3bae360f1e182e0e3cdd2564b1d0f81259ac397ee5e6b2b4a31ca57c2733fb36568a70787c58f2a743d635f21aa267dab1119c68e5939fc1ab5e6a5d957ba1491271da2ddbdc0029ba13d187b2c62d4b0dfc077a5fb34cc1bc69af30273727341489f32c9eb9e64c6af267ec0f8a86f26a58c8fa265e269fe713cf2e55107c7417fa9e56268aadb37172eb36833b049fa2ddf804b7f6a7fd434caf06d31e4c4c8bd2fb1d53544c5a5a91ec46552577eb92d61897cd33423e2f4212e65ef1f07e5c2cb016c9adbbdf71e2c9e44f78760e9dec105f483a7839293c87b5add3f006d50d259abcea5e8e764723075d4a24be970859ddbaec0bfe282fd90dbb116b113fc4f619918650ca7d35e449466a7635994b48b9de07e4b034e6ade8065056005354516b5752236d49b44d10dc48a93b6df2a80c975a8f195dc32baa6588305bae56ab6047c008cf32e50c1e161b1cf1246c38fd583bf25e9bd6546bbca04289abc55d3b938a86a5f2d1a1dda9293a884a2e7411a92c2bb5d4fb4bf177b8581e1c0aeedd61862d4c730d68560a2309c95b323b165796daf9888c3221aaca35683e69fa28d0e27dee8247fb80ea6218a3513ee24553f02abbd6484333841d86dd390a8fa6768c26f31577c2f8c81c4300984ee5fea44ca2325266f998a8065184931fc568fad87b6eecb089ecf0d1176a39c21098fe9cb876639db3a08f268e30114fb189844f6e5ad8c9b0c33cb0d1c440604d52e7718af8f47420cd32b2e4782daed65a9d4b65f554004e336569be95878a1bc1c26ed3ba761f83f531b46c0166cdfa605cab8ffba4ea1bcf7a4a61ef6884aad51804bfdbea409037c8cd2f52ed51f9eb51061d08decbdcc983581b2f9741ae0216157efb517043d480fa8a8f9bcfb1c0d36c550ca88c2d44549b12d4e6183b3e7f382cd08f0e58dcef826a997065714f419585b93edf64f4237e6f0ff1665e8d74f50982d45c26700dfa34ddd3f8a39b1887583fc5e1467305ea11c94e4735a4a0fbfe6b2d2c4d2f0b7e6b58e5ca008b55301a07aff2e306ab8bc3b479dfdb9f356bb5c055fbc26b66b3eacc23d1e74395a35c7b87725c6b3a67393186a4cd4f8425e5fb5d8f027269f4d60b5be842d30d242405870240b8a797e4f32474b340e46576a289672f96cd3de3cdceb7a7e397d270407f5dd616c31f18db2af129f7bb3c3971ab2a9976ba2addd74016e1ced4e107ec2d2e332c1de0925da9f3b5c1acac910255ab3c5cea857f831b59e91387202467313d1dfced4058601bec5c768cafb83b00fc7567dbf94ad43adca69ab8db9a93454482e173b7094a91c62b3f8559185efe1c3b828114f459caa23c97d4e0af169365fac76d6aa72334f97f10751273b263ad44a8c206df50e36b73fc0031752b880b38e37a1cba4830c28908949e068d16c6422a52828e62aad817fcad90dc2d60155120f4508a171519b4d901eb8e377f9f5e9b2ece98ca0c6218ae1b3348fc5eb6e0f35d188cd8dcbf01cae0ae5934ef2973b1fafc7bbeb83d6e35fd043054dd8dbef3eafa06905faa0012fce146c201323b82bc4bc2f4fa023ea40d5629e894eb181ac24abc62f2fa6d6c790ace0383798d2cd180b9a17fb75fdca036c0787d5735f87a75711753c39743af2c6cd83bbcb915a918992f2bce6f3aff4069260d3e70f137ba0bf55c409b3c71e027320df9684671d88d0cd2c54dcb2fb81a94a481870f62af4e534139330c58477b058afffdef58383eee6081244b645da615f6937ff6e486e44ef01cc6474d5596eafc30a1f44eac81af79a1da988e33bac495a95805faa30cbfaec78eba53042634474a47473f25afdf5285e41299f5d5d0c720f2a8fdcf663339f4b9a7574ec33ecee4513d9cb4893b30b3a079c4428b755f586cd316b2df5c1bc16b8e5d971a6b9696b8e259c91765f532379cef196a38f9256aa9aa1e0e4031f26ec20e0de5d91f4762398db65d5d8ce75b7331cfaaace9aff4269d70da1da6da971e5734a3eda99e8d347b710bf3fbfb888fecd0587ebd6d096386572cfb5e506844e876e65544e4fa5ae871d61dddfe50513fccc318e54568c0793e0b8b225a27e45e327669a5eabaac854db95ac03f754f43e9c8f255f7abfd6a6a2e75b545dc13ee488eeaf02c912e9687b4d98b1e6f8736c87c7eb6974f0c04ad77de8cab1ed8b861b2e3cfcc6b4a780a69797bc92c2f3b308ec45b3e3f5507fa7fc5e0cc8bc722fedeee7cf3cfb85397135fdc2babd3dcd579f59a0c79de2c6600fcbb610628dce03479e823beec3afc0b6e14b767eae02c4ff15b5eda2af9640cdfc431f00c0fa89e3bdb850a5b186deea7a77a237b0da3028e90368f79be8f20fed114335493920cdddc6ee6567da71394b02254016a8bf9772a4ad83694b71d0a3d3d5f3dc10ec807b64d190428df3a2fa4b358cc9f8d6674ad701afe13fbed2076f2a6189f8eee94aa563702e6befc72567e0fe50b0d3ddd5c10782b7cbfd8e73b5cc589e20b5a101010aab259d9e2c3c66a4b581ff774bb51aa97756fff6e450b1aa818b5497bac0585b9000e1f319ca0b2f4769ff3f74099a8d098bcfc6aeff090f60602cd061dcf0301f640d3245f467fd6ed2a364b7bd3646b6446aa3fd21accddeac8cb2a6074769f438859e464e72dd4baee66e55c6717b11aff3df2b72ac8c366070a0a9296b15b2bda72872f152dbccf6004f9225210bf3f64357f5f2997e1c507e3282cdd2b8a543a8eac9cfc84a83c56948a3f8a29ea540071b4b1a883aa95ebf8e7a2bbcca49ffd0210fb4e87e01539dc1b70f27ca91414906409ed611cba93da1d363cc5654da5eef866cae3c69d9cb1e5d6238bb3a563608e9e87be5a95a74dbdcd22c5b77b0b7ded5d48cb533b0919c9e198a12ba7a2e6d0af6bd505dd6ca3b7d6d534fbd90ee52cb0c6829ab47bf88ac5abd7b9d7bb61f002391c82d603943f862c439f82e22d8edd8e6dab5d3655481b6db580db5aea2988c6fb0a75289113a136d98251499b09a8c93f3b452eeb8077ff4999e62da78d9c60a232fb08c8d441e05fb92ce859e288293769f502d7cec768b0c097e14d7e72038d89e476ac12e0e9114e4292d41197827a7b103a04b1eece6e1d55919896a0425ced91bf70138074cb4755732957c9301cadbca0be0d1a3acb4312e3c6f1f7a595f476f0276eed338cf7e7442db662aca18020b278a33f35b2510dea46ba99843dbbc5d54ca4b86d2208d7fce53bea1bfd3cc0884df30c6b1ab1aecf8fe9758a398cb01f90d7466b67e1cc1fe4cdadb1355bf451e636fcf0419b929306ff7eb7065ba3116a2eaee7f0ed68e30098464d9a07eb97aa558dea0d5d979bf0ca81e5bb22545a30ac5459ff4db5c2e9a79be4897b87aaf3586b74c1a10a945abf9bca4069eea2654dca00a723ad794b7267eb1f8bbade01c7841cfd914a9550963155fa2d6c791bf9e3ae2ee422fb8d9bd16964df5ca55e40620370bbbf40275a6e28a1eec718031660f86933e8a34c398779bc2b2b5df8980cfb658335026bcc11d8d1025f5e8d8e78d6c0382dd6217d00566045a64c0f3b27dfc9753cfc0596ad1ca80a6286534fdf02f839658fe296feba64e52f0bcf9b43558aab76feb2826179e59867736bfb0de2f10997a914d517a6abfda7134c605791c590342585f59f0638e54226b54fbfc410de89c05488e910d911184a1e79b832d56641e0cef7fb4be16b29300d38c7b87789454ec4c2fb046c33c3f17e4a941178cda087723d8419a0cd068f32b4c15b93afc96548616fbc088d1a1907f63a6e4595552e7b223aabe61a747dbbd1498033a604c11374ba72cd0337bda9101e416e9339bbd13db09e559c4d45759f3f9b3ed452f66ee35a7af3a0b3f358a68dda26fe58719c625d689868ce75740b97158ba45ada3eade0ce5759c16f813ba615032a0e17908c291cb7f3e118be2ce405db2204b566feecdac77107f8141edd79efd7dbc0e7fe8aece076b7261b59eed4ee08d849c353678072848cf79a0f83f849566422c69b0accf9d8d9f9955caabe211a8169b7ec4feec791599ff185ede2970baeb3a365b003270421ae32c7334a34e2647e2515a569af571d2a7cb8206ee8aaf99289b20c007d6f20a6a8a516d15600307f650d6531b035234b0eb2047021a41b41f6e3e9bf97bdc9420aa585ef6c984e4914d9d2fa3cf758d2e35c5d003dd5a66164a658330ab2db4bb03b9ec08872b08d6b6c59a9de8cd8f4fc3dbd0b34c6898006b2e6813b23ae9983d1ed88b021e81f4fa65917a8c331318b5a98d4fac9693befa66413880d3f6d15336a29c20370957feea42d40cde44af5cce472b969a0e51e1d864e5e735fe68fa6fe562c198ab3dc60a44cbe2731a07945237bca867a6494728039ef6e5f0bf37511be3dc0a7a9cfe514560919bda03653b946fd5f94c576bb0be411ce33f99c0ac2a13c4b16cd0e239f625e4f7f3160434ab9ddabd29cdb5a3aadfe6bcfa67ecd6592563cc38603510dcd45a929afd4ae79854176aa1326dd3ccf0e1b707fc89ad8677004a448eb73f4408708d6c4f9ad72baa1b057ab771e32bb87c8b9ed3ce0d6ebb245c5f1da0e11e6e19be132556256b308b0980812f300913095b6b89bee35497c77dc04ae1a8ad9de8bceb70803ebe98fa9b32754695493ff6fad2d19cd67d3117d56e11834f2be2e5f802a2dbef72b25ae81f194236dc1bd02964444a56f2b896205d6b531ab0aebdced1c4745154b73169bb65fa76c3a6972a667851e62cf41dc870d180937ed4e9fb62b406db6e3966915ae03185a81c934fa7035e6d016ac86f7d410e70b45017d1403399e5465316920e73f23caabc19f64c0c1b4f0e45bed9244e5b4a1878d323af10772644af9b0413ddab9d672944732b2736fb7c7b3decc48c1f289d88934d15a60002295d09815c17a1973fd549df1f8b4ebfcc680fc5873552d92e7414f94811935b1feab752f4e154082f103b27b344834fd8bedd080ad4235bf08af89e18d3f6275f543349b8dcbc2a412ba18b2ee771a4956929ecd7d8e80245f29a8f3cce533c0708d798934fc6e2a55c2f865a5846196f48c6e10eab06aa819c3fc541a6fa796bc68c8cca5ad4fcaec2293fe9813ab5ed13451c5b3718f94e7891822632a0a63ebbe7732cc76b21b3d1dd3fb337213f506c49172b734a3bacb5eec07b9d4f9d13bf5cc2723a50444068283cd342552135204bfa2f68e6cb2d6ac58a31fda857c32b6c2597adb5b803efbe1adc58092d7885b79813ba61d1957863c70af66dd26dfb8591a6af155df212c7b21d03a5874c3584817c9837465f9628b2e93cc1fc76bc29471384550d211fc1496b68c64b46d87bebc1232e9a4579a7940370268386b61a424ab997bbc8d6811991bde936f1c93f31dbe7146fe90d909a99122a5805e8a392c8e261d48a13feb2ca5ea8c0acbf17914492b3291ec86f98586ee04468c7427186f39259533c2c58f5dc0ecd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
