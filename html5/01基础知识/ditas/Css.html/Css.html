<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"849015563fe0a415639a2a8226a17b38477b965cf477421c73ef2dff181d9e7d00b9f6c103ac0b7c646de332114dff2fc3c5132eb1d376d657aee05ef82f86c61120cd111253f29c12dc19447cfba9d79a7cd5367c7669775fb4f75d7467199fba1b456dfe14e0845a5ed8301bffdbdbcec63171bcbed91f8e337d6235efb79a8e71268f1d0ad2db4dc85fbb33991aecb44086d42241c8ac4d766f918381f0e9a0549229ea77ec9024079c20e75573f4ec39a9253cd53600622a3cac84acb90080c3e77e5b6be7f818104154f85fad987ff3645eeed4be4975bacb88d5b3499f5d2d42607d62bdd99d9b2b031ef6fc82a880d4c973e443d10f7f190bb313e093af1888e5f0c8d4de2bae1d89bbcb96df8ccd33bed4b9980dad350db4a0115c2a240a6938db6e4eab35474487b4fd29fc1b3bced7e3813822377b04729c93f332267fbaa06cb05ba030caeae73479ae2370e995c4a09a571c6d25ec1edeb9456482edcc89cdc188752018360e4b4aaacabd86854b8a0dc21ea1c78f0e62d8649376720990ab018f4d180af9b98cb199af3599ddda47774524529b1d97548d69314d76a6298d9f110c7a0a0df7779c99d5dfae607f19eb5b71e01a7608664380628efb4987c4314bbaf8ed21f029fe00c72c68d541183f1253f9ab2abe9cc2706abf86e9e2209cf7bff797960754b0c09316532426b5a83c4e2e8a349f21e59b55ec37815b87e75bea9aaf5da5ff9e72e5ea39782602a021ec7fff0ce290bbadc5a32a9bd0d148140755e101ffccd8e5f13c9e2abcbe590c5f701955a1299d8e3acbbf10a96f55a30b895f4ed4fabeef5ef2ee44826d96ca59f8a1369261da54060377e23b38710c2f0ab4743a593569eced0bfb21b0f851b59a28eaadfc602693ee2407e5c4355afccfcc845d0d28daadccc7958df66760080e40fc689741be4e7d1dac89c732088186c22d5aeae95807b0187168a3369b96b230345381c6a4403834e393d0f585ca89a5a4085867d03be7066284d25d96236316b82bee29fb45f46a73f4a2e990408391f4c891d8fe8256849b2051fee4695d2188c37e0110689f14622fce8588f4857d79686c17b3e7a4c2ffb877221ab358047981074c53a3d10e48eaa739baa7778ef461bb83234bc7c56e58adff23a2ed93e02b6b56825b90cefb85727188241d2db4ebcb8507c86e5da2c15a883ea0bfd46a1d76c71aba7ebf2f20723367c587bb434355265312a932cf4bdc98d55193d2cca168ac0beff2c3e80bb2abbb32835fd619bb1f4e8b63cf95331824f88dff2525cb33f1f323c9cf6cff3c43933721041adb7f4e38e8ba8b7bfbfb1aa56b8f3fc052ba5f22968baf5f8558572c5c88711e44e7ef2f4fb42148fadbd84d5f1caa34beae4df38bfd99be22dda912c468c915a5cf0ca0a0fc5454e554b86b7a44d52cc97efa0e04d5a064c1423ee5d895a766c32b5849dcc50194b1d85d79c9b4d858fc4564557f18cb49ae0c62a6f4b3671a3006e06dd203f874a75f5dd88b9f50415de6485fd456ae016d1b19913f4890969eff78a4508a4cf4cb05fe03a174528eddc9c64d5b2f0e8459720e49b5341819e904c99ab2a04e09e92f54ca0d468e87beb13539396afbf04c6b324f0703a474ea76d6c525440d0e4b6309ce6db76ad11afa5e2831632ace36aa2c2592fc50b455a5ed3c79175cfd603d9704140a75a47a61b131bbec53ca22e33008f1406a8e2cdbc9a6f39606e8cda3314e1c3e9c44c6783abbfd074c31d31d0899cf73a88a46b3853cd4a81c3c05033ed6df48bb4c92bbdec109f6536a8c8d3d525354b0a5fabdc9a653256972d772bc7b5885b0ea8d987fea8f532f792769c74043815d5208551661de1d59ba9d3a3d703b5d2682f45428d2189964b249503452c73a39fa3a2bdd79a12708bd14bf2da7ed3ae17baa4ea388e39c8469cae523eac52f77febcd94cb50a60f854344c7f2b66ec072492ab0dda45ea8f8952f7dabd1768cb6d5c4f31861d7c34e3b9ec35535396f16851d921567098dd115dded7d02f505506f781b8465e23b1e247b67f5800538d3ae9681a2acc1daef370085a03962b86d5dc108964b8d9a8132fa4d44cbb1968f5a79fe7a53f6d7816bd6f41ecc011faf2b6f0ffd6fd28d151371373309a8759ff8d0009c76be57a6ca8678380b173b7627d90a94fe06802225b507c8e1442f3142d174556827990ff3bba66e6f0bf75bb355a42afc188639df840c6f8156f53a7ee11e764c012352acf71cf376238494a94f1649629c2fdb2b2d3236d21a6047ca00248fd8b0a9e51fcadf30f8f0cb733e4d8a65edd6748a1fcf81ca9aa3d71e160a50566f1da779b5ffa1978f74d89eb1b3c2a39c45737ff65c95b71f5b81f5fb93bd546115832d952b3eafbd55e245075d8b7b36b6500e858b98d115ebfd206cec72ec2d60ed52ad5e5c62998bc5c8361410057cdeb7902e2b06773b254e6ae40e61dcca68e2f95a445263ef1a9d09b7f06523efce582ce448a2e4b5c97d22a1df02b08317a59e0c6ded4ee24668d0518bf3071463833653456d7ad176df753c2f49070d005e724c8001b89dd9bf42a9e8539e954d368076b0a35102653b71d6a36f567ce4660c51cdd1a8b0eaf016b20bbd13ed0fae76279493cecb8505c753e52d00fd30a065358c375b7add4481a4957464b97437f07b1a7fe39549ea4063783a1069f02891c6add7f48fea76e51049c1b61d4b1f52b0f62488d63122cc76bf440d1bd23372ed22ffc018e93cd46977f2c9a581470c86c0690a8c03f4302ef178951cadc21dd8c9ebe566128961a48dc91a8df1ce1e3c277fcbea52e5f7b370a95d6c6e426875ea5bfe81ffdff38c21de99bf78a19be3d85fc1ff83dbfc7bc93aab915f3b03be5499c0ed4140bf768898d54415804bb9a3b6cfc1d2599271d749a3af270afbde0e3df177ca187826a154c3996ee02d223783ff5d8c4e84f70b6eb5c09c079a4911acd9ca994304bddeb9bd213568f6e41f517dc7e771a9328a8b2923e60a9f7d9ce42f71b23ca58e04131811c83ecdad80dfd568efd1f30ed1ff1fa4f9e898ffda4c4bc5038c983d8e603b854bd4f405586c108dcb8af5b43cd1ad2bd2a08fb7236d32c46d61b3169bafc01438364fab664ac2d80087347a88e16de465473616cd76ae06b9716055725bbf7fe42acca224c874ca90ba9316d19117328e27a1f643a322207143155c2e38691ba4e71a106533d8c683a8b5b0ba17ed7bae88bb6ab8dae1dd8656bbdafecc885404421840bfca724424cd0422c1abe0dcc444435928ea83fb0d187ec1d1a623f2680184966f75def2945188341b2d81bae8d5d1ddc197eb82530b17c6f5aa188a223b3f34c7473e41e6fef3f9e0acec1b5cd2ab19ea743fe644fab4aa563bb179807f3adcf606a956c599508f6310af375504fecd0ecacf587debe5e0e233cd4aa8b139db406e7184f279f87077dba6443eeb4ac28391d7a24219e6019e1f4f9bd37aca5ffc006244bd134a18ca0f0ad0cf401b14d2c3155ef9bb3e8bd03f1d0441b6fb889d69635f3d92811058629399c72f7091f183f62623ed4f5dfeb80500ad5cbdc05afb4aade8ab7ee59501d4bf18fba815e6cc3a5f5a782f64811e7f3780972dc306e4426b7097071cb26e4185270d93778007a54514eb13df80e0f8f5d964d1756957db60cf8c570ca92fbf0ce13834d620e951d7ba42fc6c73ba74c3193ffc71bb80516b2d15d3f8e721c8b7c3f393636b3614d1f9d0adcee9f2b3b731d602e90eb362316229c9818c0bb1fefb2eafcef647cde435386eefbee1f2b6a5675da9020019619568bc4c95085b679b78832cdc55b60c6fec8ee06601c0d60c83f191876484cf0797b19e360f8a4e1f922e49b063ab9d136ba3bed62a0542fa7d631bcea60eb6a7b781abd3e3ad8ffdea9bc41dda8f9cc7ec15cd897736bbefffef60610b8278f1e2225c045a7b3890a2bfb9a9bc059ca905b5d6d3c6556e9960d9f076b1848c65557017edbfbbb7f2c337411da09455fcf953be785d5fd042b1895f60a548d2966055176f38fe0963d7df2136f1eeef756e8545fa5ef945ca42d7a4f26d3ca586b9de5a404859ac96aa3968d6dd3d2edd33bcf459700481ed6143a49d9c48b0f0cb5e30055f3fbd0b582b3d9096e003d2dcf0ad3ba0b93c444680ed7162ac13f866756c26b7fa32b9b433331a98d76650ec636748985e86b4e41afc91fb9027e1d05d169756fec92ea34eaa682e8b19fa7a6b355f8747d954a05b97a77ac3e23fb9eae62c1f21f0917a9e5b3840950b7888c024a46ff14d2a275d832f9819b25125b13e9ec935cbe81e36a53ea4f1d300b6f537fbc5c93e7933531f471f7ef97a682babc7790ea2fe1697af49828fe4e045a4e58fba2e6cd040cae8da00340a495a3e2b102baab626734306e33c93f641a2ce091dbc2f8539dcb5928b9c5c2abb0828e4bf7a8f2137490ec00ee8a6325b91f6a9a7d07bb8ae4612c9a22f07ef7c8ecf26f43eab32107d7f6b642a37a7458d18d12347cd43793aee4ba3d4692357cb4528c960cb28c71a99a1a1d12ccbff9a20f8a2a8a12205429a384fcaf8de1b5e935516e2d7149f41f78dc523d574d4dc9e7dd023ec156ea24af14cac71d95ebbd38c4218f3545106b2369d061c5e4885cb1aef515394282b65438b0704277d2cf3e467a0031c5a4e169cc4337b17bf5f045927207b37e03ac2df457c8eab46c98ddac704e58c13eaaa3a5136ae160abe6e8ec7e5ef9a24cd0c95a8aa45298cb180957615429e4148abce9dac1daf1448826f1d10b255a703b06f7f688d46ab12e5c3d823d736559676ae6bcdb24af137a8a93ac7cab4a48cd03f18d32bd4ba29c21b2e793b4039a5025cd0452896afd2a927ca189f04fd8a589a985503cf82f6b86561a03b5a483d78d40f541c3225fdfafc82047bf13951d6ed889dd9f7cd112687446873352a7f265f9c3a39c92b3eefd616fbe3362abc33e34bc3ba7af35a2121629bd70be9bb15977961369f826f260546a4b95703f23d54ea8ea5c0c0f21b04d6c98edbe7cdf561e27647699e4ca9963c91d1f65e7cb6839930d44ab964b65e5bd9ba19e2a0cdf545814eb9bd8e5215c719469bdaf93a58ba88fcfde334aa5c6ac5e6147ae05d26199cbfa1dd2bfcb45fd98bdae8400531d7271b54a85737481d043ac2dcc10c1f5ec3a2476569e475002ef49233b29e6ac89b967687f539c6ccaf078b42f71a27e843b391639a461417b9b9d17c84bbaeb9366b41a19f55815a0af1eb11787f8375ae38cd28c8426939a6cae1f07ba7a8662da50bc87a806912b8bcafa0a2f44438db7e4d8d066022d807a42451219ec9c8f0b6b09de1859c7b927ccb65367f3be538943a13b313de863cff6ff3910dce085f18bc44c85b32b8893837b3cf3a28dcac3ea92469aaa9dcfa0522d114b4097d79f719b63266caab8fe458c1080970f8591a49095c6421e727ce370adc32fad8e31d1135f2da7b8906dac52f03ad85c662a4ed18708803a9f6bb0c2f5a732cefad01b52196ef84a133a3ddaed2a42ba525696d394ee0d34b6e16af0f558cc271c26c3f1ab673cdb03c5b6289558b085d9243089d603ac36b161352ac4684022c5814b9bd4e78514cbcbfd3c27f48239fd4430a099db6630d2ab92eb05bb7409d1bdc02596815e47542d00215fb6d1ccdcba2b919893deba32330f4461a73ca04323c707ee4c5a8281fa31c8d585f22bc8af640d6250fca77fc14e6769b52481d94750a27acd00060ac2d4ab9197ca8e3cd716d15840aa1ee6cb1ed8b76018a8c56ce68c32feeeb28b2c544a62a1b011c3b202e5933a015be24953cd3ee4db3abd3b19d99ea918495198c9b93ddab411edf9db557f10a3baeae819fad5782a36a17a0ac71959ce5c6d0f7d24195517cd4edbfe1d077ac18586c289f494d9f84aa09bbf6558df51dae7b3982784f6c7f1809314c957006719920542567199d179dd7e0620a6319d26d760fb9097f5f2d3df8e3cd23d4414693e5c8413cb261b1ef6da11b5052c2e4f3ebb9c74ba1695da5e141ae55d51a3c17c9f607ba1d22e776e8ca497ef28034a233a237d933a93f38cc74a6c22b9491a0dabde364a698a940243c718fe5fe7aae7cbf4a52e8a4fb507a7a775d6a252a125726874a5789a8afdbc5543d4b6ff0de256e35bf5fc8ebdea7b42ecb05b07e27d1f26e18e4f25d26bf3b741e65a629eac22cec47747332afa5e331430e3cbad70247330bc30370f6cdaf00d2bf3e9e7c7e0bb851d8ef793bf7af2e05ceb60eb65a3493783574d7a44f86a8f750a1a2bcbc6398370a10432c87e53394df9cb79951c96f64971926330a6e17564e529541c58127cee14bcda4e9ed57781545972cd31bab793b6f07a8beb6327f978c3b527dfb7950eec5297d9aabff122677dd6f11a5aa790225c5abb79f8df305dee7ce28003ee17f9e91125e53aebfc9521069add146c6bf7c6801e6dd800693cdca74f6bc7fd7634ec671a92248c4c13e46f4fb262f4417045c342462fcb5f23245a6954fabd548d8428b0f1670d1c8f805ea523b350fc0eb78656681bc453de142b57fe9c7765d03213d21db134e65916e65d2a060a7803dd54ae8c725d5563a249514e690ec6744364aea010ae3b8134af402f2da9b27c5e865c4d5f3ec8d9c0c04380517a70cbb2e8110c7c7cc1c8b95bbc0645bb158299b10a839a5440f5743f436a134a545426e4ec76e37e473c0934227304032350288bb6a1770f5c7484804365af5dfa59ed60d016a083d7b0a71c6edcdd79c744f0c0fd1f98386280f3c6f262699a6db51866d0d673612db69a1cccbb89c3db868548c6d907c1e9720f7823cbad3d775cdca8b92cfb441d38264576ab006a61305011d50e8677e0bca784d7496ffb2674e5894e41582cc4aa04a53b0aac1a095bad6625a7dd6e1aff116662b59a8e8d8284bcf9f6df5edb3528ac23da8ca2f8b7aba0fcec84826750ba07b7063fb05a1c02d35341e353e0b1220ecea7f23cdc45caf34f5eb765f3ed4c043e9e99c258866bce03a3a32f234f31f229c16389133a547a289692fa2097c54ac27d0cde3a13c981d4ec88ca5597f6cecc87d8f652a221ac616236fc86ce210c50b4f98ad3aad1ee6c2e18b4937ddadba63ea90317146793f2167af7bc3ebf4af7747a6d6fec70e2baed471e9ac064381cb7a0f303e2960ca02bbc34fa1720ce645e648bc1a0f2cc64f73a08f96fc2887b01357f7d5f9590e984f849839fd97451db969b0c76243d59f5e31ee15b048f481635cf9d542e6c6fbcceb1c54ed5ab0bebd5d5ab91ae578930a703c16fd1698a1d4fb61abb2a4af968e9817bd00deeda0b0231b98cbc326b88de763d9da28898b6203b0b466396ddca000791463d12476f45599e61930ddaee2fbee4ed0db641071bf175aafd0b1fd3961fdeba7e32370681c993c9740b668efe86558a80bfa632760ae0e43af479ddcc5f2cc1309693f6cb65e8c0910539fbee03f1bd550891d533b919609ba2d1392a30a4bb8b02598ff296a80693a8ade36c731915d84f5202b97ecd73fe94553865023c3a44f0eed240925ac8c18119f5c59fb4e6b76109fdc5926cf9aeca2fa94e917ac1bd194a9dcd4aeed095f76d4c355962b7d844ba97d89ea68c26a0f37940a2864e5bf0a718e9d10d5b678a59fc1fdd18ab88358ff47feb02368b5e459eeb4b7f93438aec8aa4ea4023986094f99296a5750faa73fab441f2c7baa760a5fd4f3f9b648e2105abddcb610e927a16e2016e31321500df1caaa64852a1284e195294069d7a6b3cc4856a20fcafd4bd40941c74cd0f6d0b13b5c4488743ca01b4e4acbdd5a5494b3488b0b2d57e60090ad8c7300aa395ab17c712cb64f56a3c655a4380f1ee94c5bbde2eac5ffce3532a0b5d50ce91efb0a8c524c7d2e7c708a3e60e3cec21198f06b49e64bace2436b6482d7a6cac4bfa0d589c1ff9c33a42762e346a146d398be4861c6debaad114e0006caebe71fd25fe34b63f458beb4fce36a921b08c1671ea5efbf470161dc0b6b3c296a6272e7eb17774a243e2279310c6da46f2f09b3e76dccd3af18aafed2ee66bdd07594aca9e3f7144f197e1dc0f7dcd6917c69ff6451c00612f5262bd550f9766974ff1f367fa395d5cd9851b91fd6eda9ebb54b330c6efd97238a12b010e26036da9364dd9bd209d6b40abf93263f945b9442eb1b3db12fb057a8fd561e382c3976e35206b867ca2a5b01cdcfd25bc784316d04f46d14da94cbfc95035e487f287d610d193befb57eefc22fca95bae98c69c7bd4f9f6ea7b9f429176c6ad83f42ac5d3235f233f4780842b17049149ca5992b78e06dc09cf36b117332c64ffde2a7b430ab7287f63d1bcc25cf6996735ee77f8e7303deb82e7d511389477381fb239e3412bae8927ae2af86d46f69021688549f2bcda891d44d1986e99fefe7a56d93b7e17ec36fcb246963d186e39acbe29999e4b39f5009e35ba643cbcb7ff2f8b126e7ce40384a30a8e0593089d10564caa365c739cf153f20788eba51665a8c634bbbdf31a35a1b35dd8f73192328e2a6de67af45cfacc7cb82bf7d27b38232a8a2d6015beb98f7bd102f153d0545f2d03df09e067625690426db413108164de7866d5498d5b8f5bc2eb26a1bc07bb3a8aa402d5039607cb27ca666e4475a4a1a5c076eb355b5c874edc118c253f769a620cd453f1dfa2fd7fbdad6d3b3592ead14e5dd667715a819073a00aab4bff618b0a0df569bae3592b47c5e2c3f682f765620f828f212a11cf896ca96db80b7f1e25e2ceb2d8657aa30c7d69ad893472b6c6dfcc1ffec80b95592ddec5b4cea40a51a66a8d7375e27a1512b018e8c516dcf3063a097b05f83d992df2306b13bc59e46c12880a1785d903f56fcd41ffcd91a5fa759f8c2a3c9bcb4ed07e4c53e6d9ddb30cf3505d9cd91bb466fdd2bda47cc02417aa31ff493c69c21c933e59758383a93596db271aa1c0b7753caa946c29b428946ad4c2c74588417daf557712946a32f185b305d7cfd8e6328a17bc882d00fbcbc2bf5b530eb17856d9f0805d1a5a9355023a5f0c3c7f2c50c67c33fa15d94d6a7e768e1544098436248e346e4ee36d9d64e143f78f95b430d47004920eada5eb8fe2253b7df4f9f0eb9eabd5ffda7614d856a0e59317c5092e740cafc7f818041462524491d5883ca7e3625290adeebf23021bce0647d40e5fbf45f5ca552606c1353b8d3c09f543a21cf7d6f3e9d59772fc4b1267426e52776f0a9ce396e3ddb3c579c6cea7cd54a35e8b9ed08f90de5d52e95ac280ed21a201d5836269e1830d31f0100b9d3b69c4c3f977b09f1adbd42a3dcbc9af66e6022ce7b21fc101fd1c2e501242cbcdf7e746c1745c5813c58393a0589b3650adacce67626a718aef4b1d951eebe8a9b1430c5ce3fa00542f545262218ba8df0347097c3401b918410471c7520d2bad13bedff1d548d3abb4c17836b22696fd851a05479674fe656028ff2062b2ce5e8425c38d0895d15505d9a5b9c4f785108f5dc47c1ca24a59a815e2ab542f43d50faa6cb69f2d6c29b605fd44f5ee6cc7f611ef4494508f2764f04d18592f28ffdc6cb5590c2d770beaec75cec470fa4ffab999a7d0abff871e1f9721843f8a88da6703903b9d130f4599749151419c7be163cb883104a68a6a7ee27a5cbfe8c335a5371d79322b1610252b33bc6d3a689f1d15cd3bfb8486e65cd4ba7134172dd78c97219d61ae4c7707b18cf41fed9ff1c7f1dd9432af19829a7509318a4e13cada2a179a6bda4aa9b4f09cd9c41ed360d55adcaed38bc5d72ccafe22c109eaf3ff288440ac11aa819dcbb60741ced9d173878a98a5423c1447c61d7f7887b6cdb9dca77a5da5304dbe56d89f4f4ed64e5bc412c62aab35dd5a529e9ea6317889d0b5141e169536d7a857fbc326f6fb75d55dcb75ab4b08694ab52c56a7cb9e4c0a11301a77a38202565e72924039b1fe88595cede1b75648c42e95fb67cf561a52c3cda983b3d97e466c635765f2d3b04681dabf9f71b14aa14f36a827e8317c74bba0bb36f5bac65bab8d4e3612603a698686f885c2941ec797fdef08c7af6bfc3caa2215653335318dc4178ad1817f57cef3c8ce2254319065d1e206ddb1dceaec24ae53299cfcd2318dc55dab614b4104eedc2b3f6a0ccced363d585bf44a225939aa3391139ea30fba15cffb94d78a056c48e3dd02f59cb5d2eabd6194230d1c42e294a59596b257c8f284e3a8826212901dd957397a6941476009811ab222361ecf3342e18844734085c9d802f5568b247b9e01af9c76b6eb22e37aab3046d97a740246bd02e38d0c08138dee3b03e9a1ab213f82a8f4df2a2a670e53977a7cbc6098a2ae4ed58b1942f0767cb4c37e3aa10a5655e750240d31a55ceb5c72e20ef120c5ad39abb53057cbb3116587b01403c4d53784f0cd42df7d1e1f1175adaa4d617ef454531a61117cab541aab50c2ad16750b59254258023ce552359f2260801308c03c1202c8fb5ba95bcbe550ebc8d484c1cb5115c1a27eb270752f8a5b897e64434b80bae1c8b0c5896a098418a7fb3f8c1834ed4d079afcd0c1a7629c44a31760156cef7ac8cf3f0a40ec6c27087a22caaf85732668a9910a1d5ba8b159134630c69895429c83dccbfe9fc48b4349b0708a8abcb1dc2965ba5ee1032ac04e9d9f4dda87f5ac6398c8742982f10d4cdd78716eecc1458cd6683d5d69dc4c0a84a64bda62d8c1cbf2ce40e0d1b45b01996eddb3b039aa4d6d471535f210b737404d28c081c95dcab82e18fc79d15879f21dc32c5c6cb0a1a8d397b4ca5058603642419201fffa62f976930dfba252a44c5750106a343f0333d32ef9a79beba2eb6aa5c30fceee9ad5e1a8ee723cdb3e31b6b9f6c6249370855ea5eddc87c16c15ed3817765953ee54a1fab7ae5e6da7d7136ca69faa65061f2893d3f68e144ec9e91bc6d1e3699bad378fce266bb18a61197e6533473e6092a77b58fe61e11e8594855319f825936f9ed1b5d6982797b9660fe2a8ab5b00c6b1a8da1a6c86847c74cdbcd8b8935f01e07a3a8539f65729e2ace7540efb6eddffc579a6f94754613ebf19d4015e33b3dc0a2561cfef0eedae023e2f6a583625ee72643593afaff9e8d8aac9d312afc9c695bd5a552a161253af9fc0ef859e116e134662bb0323240ea3d93d9ff22d47657813183fca5a0a69f9bb4747cf1f92aca840ea98df3550ae64f2ce35536eed68c8b2710df5d3810c09f6f2f6bfcc812ab87fa10e64830ebfe3494958c7dd7ef957e2eedb5edfe5bd3696aa94c8750fdc58e68ea39d9c18b2a0c6d282433eedfb562401968cd8cacffc3bd5d805e8d641f1f7f1959320393e8e829c04c264f5bf2a8d9d3d07a9122e5935271fc46d2e9a2e7b1eb1a41455538def6072a5d85bdced6f62655be53e3ec053c08174ec7bb97c913e52f52da66d3ce072d114b11b9aa07daf33d18567176db4d567a8e94cb78eea6e754dab57d7990aa3b477f6bff0cdb84e83bb3fef4a60bf32754f046545a2656d93ff651b758f80e0fc3f62ac6348c3dfd1deb5cf71a31998ff5d692f181dbb2dc900812fda93c70280a63b6b0c212c7388b7ed40a40daa72fba87db9f5ede73c14dfb01d5d6d181ec74224b7acca59cfe991b75f7b98242b743ebb7f0ba35dd3cd4e67e47e305077b50ed402ed31d903566fbfc4448fe9e76bcca8be5b62cf2e69ef3ee0ac327b0a9f30dcfcf9d8fcb231c84c8fa65642d30d382f8c838547bdfdbf27b1c071323be409338dc22456c6e175a84db0a631b1990b342036b0f282d169f826b3e21e9e36b8dcca4e43bbee796b5f3c817114e3dbb6a609757b04e9e379f83694c6524dade227d2cd20f95c30da69fa4be85df19584742439d62d44bff8f8d3e17091ec20cbd9b136fe813e83da3a396a1c2bf2c475735fb3cdcf7a0ae7ea1f1247777b251f617c88879f2346ea0ec236a8fa2524b13a3872ca11f20c73361214d5e42a24bcad1702cfe28f0e4dd1a6e3e988afcea0adb1ccd8b07effbb3a5a6b833a549df0ce04f14cab9067d0c54f717f3f4fa5333726db7551e50d3bd0bdaef0aa8b52a12c93e412f5e4d22669e805c11d39b6c4c41826484ca99593c691151c7500b1295b1b601b21e58633172b45c8b74d08e528f449ed090d3c7053d49328e74f9bba057cbed429c6bfa0ca21d7c12d0f5d68c0d6b41a52190c2f52f4c3551040b7e893880ccd6426934b528cf1a8dc6691b3e79e42281a97155df0a752e678ef77587080ccf8781b94e1984c53ee8bf9e0c238a3852ebfce3b8c7d96fe4764fb760aa4ede83296a4e5d7721e8d0b816e770e861e185437c11c73abd78e9b95081d4672587715a94467e23322e659113dd11ed09e0ce59a44d6fd2b1129b2d9b9b918efdcbe6d849142adb5c3688a5c8ad647922d1cbde5c45b4080467465b582354fe1e6e9486d5cbb00cf9bc56e273202a7fb1866b1ca0aa6cd55fa9e98e3d4eadb8dceea3f9b0182b7ce955441f33a1d31896f719501782834fa94578cf56b32add75e57e9deadd122bdd027b34673e839a01098eedc2f1b952da342b54964e757c62c097ace198da618c6a2fef250fecc6195b27d47aacc13caefa6a8b9a86292c0b932317b95547fe8796973e771c2d16667e726bf2488be34377c4ba4ed3e880078ee8aab70fb675819bf4c087fe3e14cd8ba7e934c36f7836f0db023f8798d1c60307e57ce7cc39bd0daed2d1c47f803c7f14a448b6ea576e325e19f5fce9d01bd5d1cdd01f733f4e97761feef03379f33134c10392ec138a881549ea00b850156f91865c16916a512fbcf30391ce5c3d8f4750e7d62c49932fcba66339dd21f82a524ef46fe2097f5b68a8a99205f56d5e0af099bb3d51cf2f7b00218a47682bbf467659c7dd45e8c5c4c8966389d7518606a65c3e51cd3488634c6d7212f009a5a1b7771743fe58a6b1f642e7043c1034ad5ee36d63ea3e38df723e576f048d12ba30f3c835bb1cf80b866230a021c4c900dbb2a506adafd43aeb284affda7a6b9bb0e455022eb2da367d7c62428ed7857b4aba5ef101637b1e4e65ff62cb98a21456c2af2d9a8b94df2f1ac0830c3421c62213e4392ca2045f2a492133e502fce73e65c769b4761fd2e96314c585fdb4a7a7b8d53e1bcc950c51eaffb527fb0d6a0c41cac8b4715fc895137ff31ab9fc08ad216184a9be69b50768acb5019097cf7bd6e7edcab8041e027ec39bdd5fddb76baa316b1347b76e9f6df2fcb37704802b9140271974e6965d778ac513fc3c2ec18b1bea3f8c55bec44ce098a063ccfa76fe62d0865bd721de33aa4ee4e3a5fa5e13d0b1c429667c3ced73acb21d66168cc1511fd6755b1464ddec2c96cc24da93ef406fae07e7057638adcf47ce5df9e4baa326ba0b3f019a148f92621325087a503a86dc5739e9c442e2e4c5e3c5db30cbaa9a4608e0c0045d4bc5577cd670fe103fb4eb6bb13572fa6be10112ab45b7d08000ce596ab1ffe2a1a0435a7826868393ed22aa196e7b337f89967da788ee18a23a2e64c1e7bde03056884abdab80d324c97131aa77c2e168aa1c5b99fc577674f5e91a6e323377853b958710fb10b4a878379153f00abc1927c6c55b39e15e24703224ba2ff10ec2de9b10171649169146778cf534abde0783d63ff071246d7a37197e9486f4c2e6c7cb4b79599fabf7dc1066775acd4efd2e95761bc60972925a295cd0f83a03238eb0dfc0cf2a61cb826ca5171b7053a6d16a9cea4dc86835e887330e148681e45c91c9c2b8813b2c5d76a96a49e96ca57b2aa00ea049001693bcb56b829e1b405364d662c163fbed4dd794709b35fc37d8744dd10eee2703d6a46aaca14e8a777e9c1988938e9118613f53b33ef8fa7f6b7645bcb024bcf0133f96c18887e1d0593e1ebb813e1ed201628eb446e38bb6169217297f2d144432f586a509ea5738f29fedab54b304d94ebd785d002a10b0736be235ecddca29a4969ca39826677cfa14a1f45caa9f625549779b759a98df5fb82889c9ee31017e11626ce7bc12bcc09f4d12298cb71c8f1f00cf1a71e65057c16a8349ebbdeb77b31d4e475b119993c0fd1d1db9c300431c12e759a5c0f1a67aa015ec7534b8f2f558db8de1ef85ea90dd5ec40f2ebe22c74ed971a00faa7ccb8d89ae9b3933c4386731d295fe028543dd3f83b5976f8333c2bede5c2efa445a2cf3e5910a93bd9ed4de8c0c25ea0be2f34dd43a08423d52497c9a0a9412376420934ba38ca45a68e050e86726af84e8662faaad8d7ee3238c29f4e88995b5dd6fa1305c96ac24fb13652deeddba81938890e5f86931d4b107d6dbf29ce5271039c33510a28957bd6eea3f12c64187dcbad48b47f96dde2f17ebd55c47bb2c7024b73dfcf006e96707fb43d9a1afd2931e9bb2804e7928aae457e3d75dd01a4a0fcbfc8248e96d2b15eaf0820f99d9f776601b3ad6f904b99743fd45914db4eecacf89f8e0f69bd57cec0de0c6bf592cb2bfe72b8b6cbe9dcf928c449213c0cd8740003aa5acca15d3f69100ba6a515e39688e9945b20264c5081ed9c48346238e6ec170363fcdf24ac138d4545e64426740fc573b6e0065d9aba82bd2c2d217b4783b7d529941333f0fddf61cd4847ea070cab56713d3ad3efe8faab013d670d9bcbe591b7fc25c50393544ba353201c7955166739a5567706c5d43dfe21cb8ea489d16faeff7f9bd2fe0d2578e26e5def6a07ece93232c4592ed3da49601c678b30b66a149cf99a52cdc59c2323b7b8e50e561c7e743b7c406e9245d4056f9231f96b2a0eadc66f15e63462dd7687fe2e234d3aa686f4ea682b582d1a0f7d82f54af830d31de724cc356f5646b061fd27dc4c8e3b32a33c77484fe928468b4a8d43de9124920297a2dc37ae010e3b08d4dadcac5ada782b4870aad68024f0e22685d6cf8f4a59d4877f1c148ced2ad270298e136b66684e3083c85ba29f1d2d61554aa3e90f1249c05820ce96e19df519259a7d0ea6241a578d1a29915eb6cbeda7a0d150191c3e87217f97fd37c861c55e4b7fce0ca0cf55c928cf1c8942d86bea4b19354e8a822af5581f4ce8aa3144c787ef88126c004e4feabcb8cc6d1ea00b4c036a566af42d0438","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
