<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34ec70cf77bc2b41d3f188b6a8c72b8472865e7f04a802211af71cb68d8c7c93327dec2d1f4abe3ed3a7a6ebd286d96faeddc5eca96d934c5f0b9a29748f3bd2ab3fba5666a972768fda817a85b7aefe4d589dc6054620f9191a934473d8223192f78504c7a42219f855ff5078ec609184feb952f4a29ccb0e906d9cfccc4f994d8fdd3b61694d4aa5f13ca0ac889a66c20e3728e6cd620c68101cc2219562c7ce4a07790149231b3def63c25aee6f7c2509eff70167d4d91598c24f81af618de3d1abb7c48a617b3da3565e1e9efb9af8b3ba0fbdd4eeb7d33d5e7b6e65663af8df907321a0f7fd10e04be82126475ee405b40731bb27e5135d6cb4c27b14a79d3b759fbfdf51927c561138b0c65f3401ae4dba8d5af1a7b591536c65896dc9b41c2db902dd11a5cf480ec2d799d6357f615b267cfdd40a55faeb8b73a2ff8b4859f4aabdca27625085e5cafd07f57e6a159ab602d14fe182e0d803f6c43b096c70d6d41590b262d195ec308418b6be1249b822a4212624b4cc5c0f997e863409df55cabd94e0aa5180daac170b564442049c60a19b50eaba77c4506e50b30693fea750847f3acd553a8fa122ac3d4730b9591422f3617d0e748ffb3ab21743bb57cd50943f356f87a8074d65cba6cce183ea618ca217deadeff10fd2ec939bf832382a3d83274966129bedc4cec0cb51be97c16733bc2c3da0e2d60070caf7d1355f2a213dfce3ecfdad03ce3f8204b743c66ea1e6737cd9aa9a2d5c1ea896f634482864e8233c57f1235a0310193a3656722ef097857c29f495a72926c9a4d63c7c5758ce3df831fe98706ab0a4ebae1032880ae413c8b74dbdee84c9ac9be95ba448e6e99118727b12af6e199d395402c5a8d740a21de9158ac06e3add9a6309bbba64194b9eb1a97f35f001c6114b9662c9e47a260e2e5f9f9bb68de4378dcd9ae2edf231e9c7f6b415b0150fcc7fd4033645b2ef6f05c9e9daef116b973c331bae5f00ef66630d9a3a156f76642333fef5319f852f930f4b9c32233364cd7c4ce3fc2c51748743be81a968f6cf36619a132162aa9b32878a6ea81b8ce5ac93bf9c46bbd94632f48e1ac2f732b416a58c13aa199046aa069dc4f3599c6c45414410aa92a13295e3c2388a07fbc1b09e9678ea17340b77c74110ceca513a11536073e83c2a0adaa535426a3fd4a9a6343ce79c3ba23415f11149d311f500dd514cd5281bb654b74cbfe5d597e8004e13bc5d6c44b2e6d0643c1608cb11bad31f3d0294519aab80b8db5d5d9307952de5e7a0b50921f5757fd38b2ee27fe9ad5bb61b855bf103728c2dad417f0e59d2bfb59e5b653996dff672457ad2a2ded9f3ac14b16a68da48d7c30a7bfeded1cc4cf13268edc944ae69e1da63f7b61052eb188822e66b27db09e8408f9b282d3542b0d7f20c5f2539b208eafb3529849558e66d29d4b34d5ea480160dd2b4e3057f8288e2f8ddce40285a6e3cbaa4afc0080a0d2131617de5f9609f467821bb5231ab2f6b20e319514a08b4cc312b0f2b078b114decee42367d30698640de306e290356775786124e6fe28aa944b5a76c72388f7689f3bb9da943128722cf3e57d87d97ec2d84180d3aab764d681b04599ef23b38ff1b56f8e9f6956271f2993b4cc5d7875ce1291fb2450a03061cb38f9e338e1b864ce6050bc97d632972d4b95eaac1ccb3d595551d6f3a4a54c2353624a0aeaeadd255e0b4629d29b6ab5a62aecfb2d5392c00103f5536e7512b761c4fe2deb2900c2c05b6c74af6d0aafbcf6bb5bd41f908073dd112445f532b2998cec8102d8825e49345fb1f0f9264ace3d7d219a31519dfe0a993ac1ec09cd1611ff08e15872b7271a98bc21bb07d75c0352cb259f7492569c4a354a33ac471ebabd62681fafc1580b3ee097b37171fdcc51c175e300e3026138d27e9399e2c7caaabf8c369814bb23d969bf68a9be0c958316a4ef640196a4db80e6eb578ee7282af97f3485b28ee57793bc15bea56946c019bfb188b95a01ba7ba86c574617b9c30fb7c4f51eb841ead585bf8ae8750f916b0a3bc96b2a15e6e703f8e090e5fdca2f4aea2da22f1dd741c28b1e393643ec9edd4c6b63351167ac52dd48baddb55d444d219cc7a97463a88687d8b2155e31b6953d33794cf4f80073cde47b37f86e43917f7eb7d74162245933af231d173f4b9471076e9bb1bc14e533a8c9e6fba5542d24628dcfe2a5665ad75de6a58d1edb52a895e59fc4860b084739dfd5c1d3cbdf9959f1b387b2668a3bb151b7b343261ff69ad5be657581fff82f1fe60e9ef8ff28ff16917fa992f30bf5ed24633f20be68ee18fbe15cba1b1977870ef3f234f3f5b6548ea11436b14d96c4072ceddacc464057b2181a58e4c2e8e2a0c2765abb612ca9562a682a7c371eaa701e0efddc27efbe50e9b06f388616758d318ec5e9f3987f2329e0c4d10795474a8c5591b6719e6643cf3c6c7fdb2899ce4d359d788e42201b34cf8e9018b37713728fa8b47b1e25bab6fe479437c02a734e36e4b13551fd1f4ec9ebc208cfd7e26f7fbee49555174e35cadd8277352e3517358aa185d8d7ffbdfdfca747aa72e05e576d590cedac6adeafb40227582d6b6a08fcd44d443aa98f041191b53b068bd87e486792d86dcd8e38295d695983faa816ee745357e7659f9738b5c47d9f1cc842d12568f43eb3d95f932632224eb141feecbed124f764c28d4e624867c6a8112c241c53f8188a8bcb862405e5ad2105a1d51e2d1f9f1f1e01dffb0d875105cbe2522d0e5a4a6f808261b32dab0dbd813eed9961fe6c91f15d5a644beec1b81e93d21363d42ce959114bccaa64a6e62b6e3fb7583f78cc39f522dcd7f4a5a97b215e4b1f94f6f42efc461d44d18b529ff26a51e975f8a5a78d49fb6b9c8b9d9d29664bbb737fafb600e960800d119fe3ef9e0f66b65c12d76f70a78b9c660c1123162e44e4b825813c8805410037d98499bd30ae1f20e804d2e62cc8d9d730f9a5b87e867e066c8e3b820c885a6f976308b5db57e1f27cfe9e434189bafbdad5bf4781a92353d3ff86046b04184e1c42d825fe7045c47118ba84d7b99bf2dc7079dbe40cc638fb62ab6134e3c34362769d781a7419fe8393d3df30996c6c38876d402bcd859768b1db66bbddd5f22d72c4d4c65004afa960d8c28f1019c4f9f7fdff10944071f1b9d9dd289ec1d631c1b5f10148783fdd357a972244a1bf3fb67a7d9ded66818498277bce27648b3048ef41d36d9daeccc0aa7d40ce8163d51ac7d4271740c635b5fed353ea5d214b47b4870271817fa7e155c691946d44b3174ab996f18c1042fb98b3cd01e3c500b87f2ca7a67aa0a030e77a987716b739110a2f2d17d484784a8853c096fbbcbbf2e9d38d9e15f63f0c789d3821a62660882b3abdc3d95df82ee175841bd6b3c067454a79ab0605b946979e50b24bf7b6d7722f3c10469493aab54020d55109ae7a1cbe56690eb5114ff62674e658a265b1a9f4a0e3f7a3b572ece7f1ca0e86befbf4c69d28a453d3d8fe19e66127d54398d93e60eaac59d6410fc22ffe833a7ddd959f63afdff68bc719c02bba50ec9b02e6a6120d5c83438d8379f960184516f601495f75acb4fe9199cc9d67e529009658f46e5862fc7adfa503c38815a86a9b7471ed9baf14aa9484693cad18b6c00914eac9cd19f5c3498630baf92370fe267705cc10c57c9530848ba50bc934e5361a1e9740ff5e1014aa65152f9b8e30a7bebf05643cc105e88445700802fdfb8c94a68ea04cc76953f74be366ebcb9df6d1305fe365bb4fb4f703ec6b1ef20c1f376db5898240b264c2586d00392a2774550cf9032a4d55f8eed38d4b6fb053382cade86a5285a27c3df0d44924a7a5f9525cf3dfecb7cba86a5217aa88268a4dbf1bb994db07d943675594df9b9c0ba510232834ca5811bc3d0806ace8ba19c8227bfa6a954a5d37dfffd59ce6a65463126ce3e72db591e4703881bb8dfd639e7f055d902077540d22f4361100514c2262879fe8c2ba6ce71b320e8c4479960a3f799406039e2f53236bf6cb2c220a6c0fed242ff536d9421a6fafb1092c433fe5c5a66224af89030d477001a261f15c8944a59e7627e1ca8173c5130e68d3a56d44441e7686a61c2aab0e958c1f7b4e2283df9acb5fbd2e09a6730aa44fc38b214d19302428684b0f48849ba25825d2625f73ed65580adf5446c3e669090fc92bd865edc1d28f0b64114ec446159bb5a3687ee47a072019d30f73cb34acc4e9fd1eb73d25d949ce3bb45711a5746707785ee379f744a18a4966904b2678495f70e39e1ae54e2d2435e85121cc2668d5be3c32902b796c634e3e3319030215032545f6b5e44e14fb77ad0a654bddbcc9e813c0d44b3b8a62a750e5250a24f8389f5c6390143f04fff1eaba6135044209483788e0b650da417b632bc036d7778d5b5fec260f846d0c81f5c0595eb967919a289836d1624b79784eb2c3827f900172674b7c7097b84b02e0a1dc9c5c778ca8a31b2c4a9aeb0c8d1b146ee37a46c4a0e7d9b7211ab196c94ade6127007bf069b5a9752caefa2e6e3ec8fe64b55f8036ad0aee98eb044900fdd36490baf2df9a070a736798411fdb4b1b04cc5b51257b122d17cee1276176a2af040d882a6e836ef0337752f8ff30e86e79bcb6409f0581b6c31072b63bcc3787fd6db187bd3604139f1222b3d1f0c3b9dc827ddccaecf25762382e31a5c5f65824a83f9b241ade64156a6b7ff925a8497d6dc160421758d0e9c3eb3aa768fadd1f359c58f7714d120714bf31394ef218398f2a992d9a0bc95f993d9102744d71ccd1f4f7957a36161f23eaedecf0a69e95ee5de8b0f81d0c6111bb42b8d1e84e8652681d8a63fe595a52a1e80e5dca0861bf106664b24fd3d7eec688d6858a2ff621f00398a6e7c63e483a7aef4e8ff565d1e1654e71e96fe736d6e7f6f9a0ed3498d2c63f13f8b911c4edf02a65db8e1eefc49c48d3dd14c624e685a2cab26d450901161e6565c18909cb69cbe59f9a8a3901a791a28ec60c706c2374af8a31ebf2ae9bb63cff62d6fc49ee80175c7ee68be0b94757cd38296d37cf305ae2eddbe875f2a038fbbdc29eab9a4225b55108e4362a66bc4593b326ccabf1298537e2bd43008ff6782563f6131e43d0aa842902b97541c927aacd9c1cd0dba70787c26fbc52afd72a26f8bd7710d2925c89be3916925ac556f97273596470549ad22d99eb7a98896da77b5780027d6e13fe5768d4fef0c8cbea5217dce37831fab4ea04383779df3e504492ad58b945bd6983028f5110b47baf3ed53e103b5c4ea0392c56c6603406801cf2707e36145edaa0ee68107e188ebd92ac49b63079bea213498dfe0fc006832085961ec9beb10b553d648120001e7010dad1ff6ae8d0d1ea16a09eb538aba04e1409f9b180eec12f9258f2a374c021a0935f8f81c2d8f660830beb62273033c1c5cf0925cf902d127d0aa1d7688b5862fb5ac7a3bcfdef57f1414d08c2be09bea5b540872333f15a40a1e91fd085831b7130421a7f4bae882f5e05fd7890b1ee9d88d223a3de39842cf73791fc551b90310cbcde53155fd3c55b717b5aeb073045d84c3b91cd60e2869cfa9930c12487b1df28a92505f526632a40c29ec3878060dccc79e5e1b2e34eca0396790b2d8ad35bf1f1972878094e309c5f99137c7b4f8fe54b8e3273ff45e7e6ea8ec673e4fdfd0f02793b1ccf3748e615aedad554e6b7394c135a108f5e4effe4276d8837e9dbdbcf67fb26e1878a0672ffd72d42b47e5a6a7be32a436de5f2c9b07c0949551aa8dca07d7fba91599838cbfcf607b1dbcafe933f32d9d7279bf4c71c30ebbeca34c4399f31ed75e58d849981aaa69dd4e4bd4ef16ba9e1debb4785bfcb1a2b4bd6378177922e60d21fb5e003234275b1110a5b09e0e1f8ae6a8c6f1bd39c5a9a83e120b9d17604cb5edf87009b51eb178cb71839a6f9834d06fb6eaa6fe72a03fbf549baa9062f6fdb99204363e4771327255a81eaffaedeb90ed799c9a6a3bc5a0ac7bc3c12e59c6f3e0922e2033d30a70213e74149a5fb392d6eb2d345d86ad485bcbf32c01575e2996f0a98992d1ef3ea4391047870ed43ee0007f3978e920ade8db2096b4dc3827cb5660d2f0fb4e5e0f859e363e9ae37376296c4eaff910d4a4d89e2e6d1f054cc612da63d7f8ae65e78ddaccc28104849d0017b4101ee46ea82434aaaef68bc8afc7fcdae851aca1927f912609c4af60c98b87271228332683c87f5accfb799229280837a19c08caa4ededa156a0598f6235cea3698604d6b5c8cb0b7830f7ddaef0ac423d96ae7b60ba00e1184ee7f27cd61899bd8bf596a6cd4a980d38020fac151d085389a62870733fed6162ed26cf7b9d140cca486f6009a02d2318769660a1f288612f64d7cc7d0026536b6ecd45a7d5ee0a966b937dddecd3807cc29968a9e5de61f4b7f6f08dd275cb83ab987a47509db208cd01ad61fb602bf7495a30fa1eb1258abecfb427d87a5437d76875ba17f3e8cf53584723a513971b83cbb1b67bd9e738aec52b3efb61d6cba2635de3a6162edcd2561cdc2e7fe4fbcdad9fcfef2991732277fc92a810ef7f5c08dffb88bd05912fee425821b8e33bb4857b36a919b601604fa7f128a2a40ca64f7c3e8f0ab0038ba5b79acdd989ebce6a2c5eedf0574d15c3e6d1a02d989043587d5538d215599ef07d953638247fe06a05db3b30810eb0eca4550fea6d999a7e2a5bc671c252030eccbec3b87da0f2723f8e9c1e0d58dbcf3b54de66b4c79587ba1a7ce203ea7fabcd727a7ac4a855f17e393c376978da798a0aa35aa6b5e30cb099279aaa557ab6c6dd905e557799cd3c91a20239bd0b2ce1a13a4bc4ba0764a5e1c952ad96bd62a71039923b167e0176e18e53549fce4b8f7728ca40894f9e3c0ae1ff48bd257ace08213044ffbc2f8c2a677046d8ecf9c5a029c7b94b62a5cdc827198b1c9a9676a73a98e4ae7e25ad7ac23aec3c12f35760f1144ff2f50e4103b76812eb60b94555f3a45baec8cfeebe8230cbe955df9a58367fa82b11b2cdba2ab95cc259ebbee846c26f3d2da6912a99c1bcbbb0719b539f62cf2bef5ae63dfec02600caf1eab23315ddae56fd99043084b169f50855c18f0b71ff4cc353e1c911bfdb1b5183d21f8761e4ffc87a8534401a53ca55cd661680ed45ab2dec6540826a3ca6906525f18b7b1212d39c6acc8d4a7554a03cb92565b3da229a733622a36960c40dd7a1375a04ca75cb10ec74761327185a7115ae67adfad606ba9022e8c63891747022b51eeac3992ad7b7da697c055c2a21adfc284140434bfe49d4d9a667c7dc347a6e9ff363d39a46cc22e94c7fe06bde0bbfae0634d04465c69611c35b8286fc58c18c88346bf0c4d08177b7022eaa7e59c2e2fbdad82844fd31b5439c7a2ccb84a53b0ac63a1223b4f233dbef4f36bf24266fa1901289a717b3365b5238a9ee8a297b2d04c35ca5b55551971ccf52ccb6bd8a72859256719057c3493f2731cef00429b1d218ba75b09c2f33ee6b949911169facff4005f5b061a403bdfd2839d04383a8499b9c0292cc2d0d28d46d23f0ff8b9e3be39c82088091b9278d6f1b2b5161546155f0ebc1314b1cf5e3a208c712d3f1aebce9d89c625ce5b3ada21b230083833e648a08cd02f64ac9607aa87ecacdf932976537f717acee9c9f9c3b12ce64692b05a028df80fb0e2467e92ab7a12dc3fa600af8a96ed22c06d79991b64646d8cbc75085a74024d425ca6e18640f81a59192be007187c7ebf9e0a8cc47f9bb9af729a20c0c580d765cd9320a74ddfee58c52bf80ffb2ab69ccc5458208a2c8fc79163f6e32c33de8e8e6e439593cf0e1a9247bb7215f7d0e5a3e9cb8214d0cbab1d30b2dcfbbac8d580b28bb5cbd3881d30b671fd05fbffdb23234b0c452da2d05806d6e9a9b02e0b1b1d2283b09a9291ea6ea0a853259af0935acb220df7c3dfd4b46b42d5a186e78a832d712f05d6a11e34e03f0449eb2e314d917b2a1d7a2b35a0a7db6229d8a488f750b1bd5dcce39d3d67b28f183519db82e7592b0a990a1b9600b5ed694aff5adf3594f04f1ab209999b087985520ea9b5f59debab558f29d94d80d4feba08a6d9430235bab2ec2a2273831bbf2c141de930c4050abff2239d7c664346c748a8b76a452a2cb1753881e256d28344b4945205ba5f91bb3f1d8058ae847f0ae90d03ff0602786ebca6ebc155b95e5cd6bb654e9868652bcffa09e0a45e8249fa1be1f890eadf9157b680fb0cd075137d3169794a776fe003e44d70f2c061486469f4670aefb4d5e6e93d5a904fadc8c5c50622ebaf7ce14cc6548203310655b8a197f7e68363f93ca115f7b8b94c8a60bac94e8708169877ba1698176adff259912229f8c9e4a73884ae2dceb8826331283c02fecf3a3a63c8f495e83e0f446fd0b91f47eea940bb6e0df9ecce1e1210e82afd073de7ddd4ab685b96e9675cfc30656884232044c0d3f9e48f13b5422d490197ca394f02b5af2568028cd5242d68c8975dab078e220d1593c9be6d77a4cbf37c2f0bcff138b367da14d6ac1528e2e7bd543dfe79c66b7c50d6973d7cfd1a2843fb70a9a2d9e1d4770d3140a9ec88f0e4bf359c53529025bc6c7a2b8d9f707ee9a5d9a881c4725764d83d004e49053bce3fb7d1e23f35486e9fc405d174586dd4148015861c3d2f521ee58b02fe48b0f50efcefd7c786de14e0f497ca13bd1110ce692b6e760d3d0eb0b49eabb2a9f01addc52a41b2cb73521b819221ad8ab0727bdc16e66635039eb07f5b0c1af745bf95288359fb6f26c3262ff835bb227ab29cda56aac9c33ac43526c1bd6df4d2f9fe6253131fc3e30aaa48070e68bdd6d4e26217137e30446faaad2b22507aaf3728cde1326e477f56c7cf06f7724b6673d761955687b5947c34cec4fbd9603734b10bdee7fb1e9047f3deedcc2f9308cb3780560b5e438213f28673b008e04439a72cb5d17ea2039f48ddf036c326aae7f78035d4555c05fdc0f8b23deb0e9bed96bb0165c6d4c65d17c952663f7beb4df80aa0193841cb9bc903e6858534bbe907a260a95eefcad73357ae2690a16630d3919808b8543d7ff0b9c35993fb37e6f714df4a30fcdf23f363f86aecb827b7f1522fc297a93e2e1ef225784c4768e9ba47a827b87683fe9ef25e15ce49ad98f738a9a83cdc250c7884a0878c9b48da9bf68f0a2e7603c7f23a8339ae21cec467384c048db159597616139bf844f2f836c912e35a35520c7e6beeab93b43363c6291eddbb38b79ac274465c8bb3af5a845bf52eb9dfe1e1375b47c52d775f7f093a1e9f4cc61a6fe834138aad1c0d6b05f402b0441bdb772ad1b352887013e77cc069911e20900aed9c164d031a91171ddc0bd608d9b7736c74fb658a65b248cf2d48987943b0b70d885616fd18884662d7083f6e6cddc961cb502cbfcbe3662095e2847ae14c646e7952879fd24e9847acec14a0945c361062caf6fe2b1b754505e4a14289d78abb0c2a5b4629a18dc3dcd80efda4a80571e293423f04d8994c307826e48f1d4cc6a7c5a0a6ab8ff891ded2dd9a266b502cdd9fe6d410dd043e2a0c60b9879febeb30deb264c43ef085ac87b1a363530d2e799411dc047d285a8c79701e92897f76bb4f511554ef0d0bcbd46687a2ccce86ab12f8edf88bfb76989913aac8342a66ce7f8c7c61422be931666291a56f860803e840593feafc3ad81d427b6f97cd0ce2b4aeb3ee5ae2ed0e0029e9825b6f9aec06e73130ce791a0c0ab6c07cae3bc53da167162045aedea056405ee2293154063c1e965f52539c8c7a6b7531aa2bc1170859804602252eb621ab76d6a952bf962bfad4097563383a4711a9fb3731688c0522064e48494212e1a6da39565f24edaa23f5b7f17870b0e938ef8eb04e38acc718affc606d6b2df303debeccba4edbab718bc1504f6251ebffc48de03655c6209431411bdfb58a1af1238be89f85d21778db7f7e5c5593aacf047314e25d376eef0979be3e0e3e3c2e2a0e0ac1e6d3d0a8e69a8cad6404c753353064d85fa851ac9bc30311e07b7d1feb38c9ba92bf1512bafa497ab69fe4a43bd0580f0b09dc108cdd1a6872f317866270c12b39ea4e5821188e15eb726abef1d7025c7c76f93d2bdf03e9b20e1d9dbc0d1f914cc6738c8c15c8f30e31ac4ed754adda6b342948fef8ddbdffcdb74b1276ff3a4d4e36113019730e2f1d164df35531c85dd6d5c151e0496ac8e2fa3d82fc53254b398a12d6b29a22df3e11b6d8d6f39637edda7571b7de04e67907f5f43e921525e6967248604793e2c502a0873eaca93fa35373294e2bcfedf134db18bae60319a01598e5d5e7ef3f40c4c37d2a12150bfc7b82556d7843643aea3c5ba4021ad51791f902c763df2baa27ac2805f3d7000a9a1fba650982c53d36270e1661a6384d9cf1825c074d710695938bb85ac80a2081562f909a76446ff07b2015181eb1e2e8cbaea84bf6ceeb24bb46487de12cd27579e07d31302aa6c5683ab5114a970163b8e30d726718f88668aac76e9c5097f0b147ad2beb3e0c2506f9e5bddf04327d59de05df2660db47a430e98d94b2cb13169c0cc5d0c32214694aeaae29573b0cfbc7eb09e93b6902393b3d3eebe040156412c8ab91069a637e6131cbc7827882e549d350700f07295f6a303ec62dfcaf537bd5d7ac86569c810dfb80c418c8a2e50e0b18f10c1a37f886383e304b3c5357f098101a8c28fcba64496c9856de2aa3d9adfe62e32161765f7f9ea1981c9d41c0b3d8d318c1b740a4f7f87e7cbb074ae14e1bfa9ce6ccae672cef4366537f82ca4304860b145ffa42f5b4461f3d165c5ea5897b4f1e576cc1a086b7495522e25a95060ee4733e5d3172f699ffbd21fb92ba36c5a245142694d1f3d4cb5ebf5b802e8910b6e6a41b990ddadd85954c48f24df11081aa28701ae446a9d019727bbe5b189f21c1970d22cafc393dc981ce5b792f54a16b13f87de230f316368a9941f2dc0e0ce1d73277e5fc56c990493c147691cbfbf179704291bd70f0dc93ba1cfb2de468d913a7807a58cf9ab0fe1b726eabb2d918182c525259ba393fcb9276da48bbb84f651b4fb32ce578116af84a5e23ceb85a1d39cc38c0b324ecd2316cceb7d721430c339270a179cc3530b8141f33a3b709d9cacfbf1428d75f832cd9cb41ce424d2e0dac3084c115cbc9266db973f990d5cf85d4f960063b84a965e57c326122ac2f379a5ce3cbf65417f5c7dede984fc77420b371aceec8eccc5ef83ede4a08152b62c18581f1105f8818c7e7d5f74391fe2d671e3cb1771612173fcb6c15d6ab2b157a8e6270a5ec8aef4ca150a82157ce9c83ddc81ae064d97e839a3ce3078276fb8fb36c06ee3954ac0aea81355f76a0657604e956ab29420238a7f0a6237e34c483999e903ca0a0b026ddd1cefd403a859ca2eecc81f0465b30f43810abc4238d3cf8a8e9d5c071a860399c2522eb5ec5f87769f1ccd24e098492a9acf950b09d82746384fc6d4d28fc66b54f6d086a87f0c09e32b3aafaa6b2c01dc7d39c609c8f0f96b0fa8f7c14cfee27206ed37208fb581142a6ad18faec7d8fd27d98d3ce4730906601c0518f34e61e089fee114e3213ba5047496f6a99999f8e9ae7ac9b727ef1a775cf8e1354435cbc54a7eb1d029b660de0f0ffa6139da7a127e6725a92d5b44177a3536dd6caf7aa9e6da41ffb2c21ed22c05c6f84318090459c054ed66c319485488ebe0043256dc502f2f6e39475cd0685e37af5410bf7bd87b320fe77a450f32005779693b80de9e078ff9d27224c2d1ee57948011ba08c859b218ca7a1f3ed478d67155e2d1803a44aebd8b3b60d6a3b1aab6b99fadd16954525e17f10937a2500ef93103d3f316cf8cb6235432a7441fb1300f83559754827b43ce34b5ad97efe97112510bdf29e4eb0b8acfc2244f28fccf93bf2d1ee0c3818a73279f60f866dddf6df245eeb9e01c1684a55c9ee41b1b89d5351afdfc9a5595edc8afbeebc2b62ce76e4b313a6c2a98502cd2ad304b3bb69d82514f211c775e0463b1df94dbd0c22deaa00dab4ec081df493d288c095427ea8e604ebb0db3f4091c0124d26d9dadbb074e01041738008504cda28833e31efef04243ee89fbebcb12629272fa6ff1bf198357fec4c4ca7f01bf3a12b7824e722c4e1423050d087fdc40afa759e5052b972a06aea6ad940aeba87de35ef57e9d3e0c58a5430f00140acdd4f9fcd90ad359b86ee07312e2c77616d597e33f0d591ace676f8a943df58eac467f36a4d8c80094ef5116a7b5d2d64350344de335b51ea887db965773c5f9f1053bc1388ac8d3cb4bdfc139028669ce5071440f30b18ae7539ec900bb8511fd4e78db1d3360a238802542d7b902090a087f2bc3271de9e7959ae4e35e76e02a44f9cc91698987457c757428dcae099f954105bae4b4e2df9b302547969559d9529a11177936d445d49cf0727d2d76cfe91cf1f250403f97f6a320c9c0da4a8439c98161fa54d54a8ccaa34fd0bf9d292a13a28c7370dd1f5dc9f9e11563ec81af711dc624bb77d0bf27e4d14f865d991c5c34ba64aedd678e7bb3f83802e6c82887c99c9f9e55758621baf0b48092e85b504d3e29fd946203b5540ba4f01e710f1503f2a64e6bcb36fc11d5a3cc2853a73c68e79543583cdfb33d1629c07d01d39f3096f29c421a6c7816a0dd875359ca1f6345aa2e527faa7995daddef93695530df60d8c85fd0b48c0d6aa8910e4d534a59c80f6a3749a5195e2b6561dd3204d97a5d45e49a429f5f9bda0a55dc208e5a99a627463d687ce0860af40611bb89566285f9853f502956e1a35efa7b1b7b3232760eae8b2ded92b99bd4f7827b4bbad47e6572f146465f665257045fb3676b4f2090bc438ac5762c06b05713dd36d517a0776f9a13b4d1e2f5c0ec2420071f6980f8d60c45f2f3cee8da4b180a9be450c65d526d5bcd7a26c92b92e0aa666b113fbb87ae2aa452bafdab86459b021f9cc264d82cbe4106576fd1b83cb91455dacac41d7b5f3cafb834086f92652764cf21abc59d4544c0ce9e53d48529716129d41db61b531e1fc2c135cd430004d33c63160af28d103ccf9236bd000578dad05e6deb87036a7f725195d3812a901ffd2dbc18813c98abd4a180838eaf1b0ce2375a59ea6a7874e1a2e8003dc3ba11b5903f573a0dd3c502ec9a7139988f2a7c4076d396b443360a4683ad8116e3cf85aaa4fa44f39f3ac9c4839dee3812a14d68e36ceccd9a7eb016d3ebedf6f710912ce3701afa02e05ead8dcaf382ee88df129abb9f8fd9956102401668b59ecd6763ca303c37b13f762376e4c7c5542ec9b87841d06fff38559402bba95fb5e7e8c421cd60e0c19618d2934b244d73a4a55023c47dea9681f3b1093b0c3cb8f1f18027d227351700b325811044a9b547d4de36690d30280fd0715c568cd4010270764d5025cd0b28ab3c77c4bbcb1a93467be28f228408367880f1b737e55269d1fdea652901b2108a6c4c912c9517fac8a6f3cfb9c08ec99435d4626bcede478f049464700a5a8f5139f774b6b311ece5aa0e30ac9e194dfa2b4fea19f20e0d7a0d83f1f2e8b31a37f331bc71634ad14baee51f50c96f6e8e17d9e3146422d872cdd39b6baff0df1c56e2c01641263dbdb0d8bfae0c291aa97b1c1d2ea37ef77054fe13810f7d801ffcf2239ad8c0b4b06009a416c192d4ff6c654650845a6f8faf459b978b767f5d7a987be06dd48edcae4139b8c46d6e7f525204dcaab50fb81987d2764498bf526a1a51c73afb8900724697947e2801ae14d60f769084725f585e59b308e1ad72fd530e9faa9bba588a2eec52a02b6bbbd2257e0f73d932264195b2bf2a256df6f51ca72507bd039bb8e640af4b74ed284e8f68501fca103f8ee9b3773138f418c4c6ad03db3ea2e35bffa332daff39479dc3a124ac8bd6b3d016b73ba01f5526d25a83260fac91930c509fea4c5363732edf51a8e04fcc289d11533f81688131c55d04e2a61367330be0837dbeb9106eec3334275d344dc70ce98cd41c969a93580784dde7b76a91e27747f06351783707be341c61ed1ef882ab1285d48607f3240133073383d2a68905ad49693752f27f6e8afa81934164ecd8f4ecde5275b2ae298c95c5cb77feac491a9d29b8e373553878b0deedcd05801f6c560be32ecaa5a49aa913ece9d667b87c45b46cec3db3317576b13d6abad60de72a6809d898f78e28665c13ca4d7c75eb73f7294121b499acde2f043ac45334b5faf7c04554f2e5e4bd8d475a26423f05a4349381fd6435cf565a36fdc654bb08df1cd92d7f0a41bdc279aa013af30d447f4b164dd0dc3e1c00ab765c1ee70004ee420bf313bc6c07e4f754edc6f071da4f231f97b5bfe76fd7c47419ecf884beff504aae2c2eaa233bbf002c1cab0628328a08db6013a3575547aabe6914d667e5460ba9c9ae3739c7a399b1e3dad9fc13b3685b4255dffb3911f778f7873a54d7d1acf5d8c104a4f1e0104b866cdcefd470f54fbed2e5398382716bde7b03aa2554e093fb65eaa78e548cd2343f12b69795fbd525e59c5d7b9ff4d2f3afbc9f565b1c2fe18a1bb50adc1f7bf76c622b2773e068577f8cad3d53ea1a9b191af9d0922ad2116f6fcac633ab55a04d1d855f7457e70480400c316e1a8ed58f78a9c9e39f2d581ad69dced80f0f32767b82b9d1d5cdafe008f0c210048da1b650e72d06650716d03b648d1c4c61d93d36fb4158d14f2bfe436f78b247f2f80d7118be587e1dd1fa58fedba7ca4f4926ed9de85761604622aefeda608976b823361fd439ebcc623ccc341771acd0bfb1f8c76368f630d3346c99ead29f412f89affd9a50e4a1922cdc0ade509fadcc0e61984bd03c66d5d3edfe270db860e34f54284c15f035901f44c2592140ed257af7377ac7060c81c8ca82f3c2e162d4dabc21b1cca6b422dfd8ab58270ae4288ab6b4fc132d2678c5e5b1dc39dd90bd7da8d8aa0cd7fc910f70921c17da2c665fafa14381e7d3d3761cabf036c1653c805347e5fe08bea57eafe82867e18a501c43439915cbf4b7102dc19b95c2136968a65841220dce42bae8ae3e6eb8ba714085634596cb27f5461368cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
