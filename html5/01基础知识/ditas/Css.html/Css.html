<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63576162137f6ca744be6b16baa65386955212afbb9f05d734a5f4f650f18f38f68bf9e2ea268216673ae8e43d4301d30a61170bb3a57049b82ae12ede4d6283fce39bc7ec70d192fbfba10ce324b910115e173ed2368fc0d464fdb0d5456d65365fd240f5f8bdaccfd2ac6403174aaaf20e1198ec58e0b0dd0024b9aadbd5f0a408315b7fb0db3897b75e76cd3e7a75325cb43ddb8bf0c8644c282c7c2a89b06810d56b693d431f338dbbe6a6eb3e618c29b33213f24a6c1d286077aba2605489885370f6b6757a5f0d18e5c7457c8db13b5a19394100fd1389da7c82bdd5ba9a2e950e86efd156ad08b6577b5328602f30d6d46538acb672711c7d0003b92f47924f71a8b8d600f29330e55057d703d151b73b3a3a98a5ab81f0a94fdc24117df8aafffde4c99102d184b89f029980ca91ad6ded5817329fa114956ca0cf68205815a10695b7d81a1c539a00b175936d639960a60c4fa19f7d31c5f3e3b6e59aea17c862a479e51b0166a27174a7a281c38c245f9077107d20236f248c1d2162acefead3a1e48780b4502c44ea9978fc8a2a2223ca4b406fa69103249fbf6dac1288c63740d13c5bdd62219023a57857f373c7ce19b094664a016d5ea56e2c030eeb98e88a3e208c2116d44f580e70323fa0fe226ccf3dadcbb72cd4e028f1675676b650c0412b0e573ec4759460c042b49903a8352f6963d6b30151bf6b519a54c58b768514f9db42d5d76d6eb87925ffbb7556c9fe8c970756351f6264c9bc5e13374f259cbdb6e3162cee859db468aff1dfafe4eb181712af717de0e58df82edd9a57a4cf12aec362d0a4ed7852203e2d6349904a7ce877acea90b489738403492cd4e0f2a3c3e531b043798f55671b780bb09a8c2e88dc1aef2fa336e4c75a87da1ca24bc624f397470a184fc8a7788c44c1cae4344400b15a344b3b83d4014de5f699e6d1f71bd23742753d110c5b369349714ce004ee6f975ea6dd373bf9ddb4dbc2d8001c20e66cf1b41407b1945c20aa1a37be900fb4aaaad79238ba4a7cb5a095923c8e535965a9a0682620db02831648047e0d73797e0a975b5b705b824cffe934ef7851f55ac6e5a711db2e1a6223b26985446df97a0a4ae9f2c6752860b241d5800bfa91bbe51299c8b1f3a7c2dab410fc4ae98a8bba4d1b28802114ccc1fcae24faa14ed8c56d0793cbd2d9368a992520f9fb3bb1c1c8f617ac6c64d5e8852449b95269f9ef554a4a6d4fb45a290107d433e0531382eebd596ed35702315adbfdb2edca548fc07d3ba08d3b2cf54ceafd6966011e1262b971f380f9a514528ea775a2f0d453734757a42b2ba06787b42fb5046f37e407ff07af4967870bcd197ce11ea75d6ef590f23f75fa706c30b9cd2b9e01bc92fdb25231eaeaaedec79c3854a94c227e44a79d60b0f7db5fd63f39533a564ec36cb7a86f553f8b2d60e74c92ab4b180d2185194e6cccc96069c9ec8dc3908c723ff74237ec77375f9b4fd5feb4f2f85c960f2855590cdbe55ca9ea3d969e4d4fcd9041623157e5a89e740a7a013bbebae2f33815821269b2c6a32ca7e408394299e4081469bb98256f8de135040700e2c8a541b491433b86ec6ea18c90f47e983d4bd5d1c7a15928e873c1baf712f264462dd9ea1501637d66a18062911df3bcf8d51b7346f98e52094ef3003c4ba42ca1e621607dbda6a9edd57db7481f4d692206d28a190e92a6197ce93640f0ef3a28d76aacfc4a48c7bd5be9901d6e8f087e5621064462b2ef9fe451f902660476b17bc30cca2f4a6efc53e816504863e33b01ef72d273d301b814a50f1144b6b600ec95c41db2245398a46de1665a5e34794ba06866f1f1fd881dcc9a828493cf018c9a66da23fccd82722e4cb4d942a56dd081f8efed2e73dd5e483c7a6accaed90714a2694d88121499b45c1c426f4b5b35b00210b5e68765d0f24fb72d8b959668ad635a1360069587b309baddd6bbf98cd5b42fb7a0b3cb08af36fd6ec313bb942b3956608236e1e820b0f19008465a312e3a308235e767014fd5e7ebc36458e7b3d5a1cd27c9afff3e3f7d41ea3e07621fcb4943e95efead94f6edf88d2d60ec82e0c26484ed3ddf3caaa52c3126e4acd79fe7fe5b703c0800c4797db9efbd999d9d8925de6349bb4700a6a4aca4ad759e050cd8f8c54dd05c69ce976618083b0dc05271fdb2632b304a26ae34bee4f44f8833f468c804b4893a7f89c6bb6bb8d9acc40402b8cac5b2488b0945e70e580e4e7e13ac55109095dd9c93e07334a18ab090b76f42212b9f9c80fb1dd4ba2b4f4dfed38b3d983588c2308de68e1b554d0d8c913dfdd92251cdb2462bf24caf5e129c68d686a19b0921356bd2c023bccf6365aaa93262edd861d8d3a232de8b030049d65ab883ce26175586f7d730989fa0b6e3fad283816f08a716db2686b3588a2b70cccc68f0a3292fd695e06f60697282b539a7c9da1760fe73eb58463f8481f3d1ef0d54edf0964dc4342ef0985d5e6c85539e83a66e0fb90d6406ad2841d2bb274101780491cc8bec2a4b6144d8bacd96f6b780d144062ff4d6497b9a4b7d9dc781b7a34870a958094bdad0ce7aefaf0e3e6883fe2430f4c1a6de7a4c4faacdf480f0324323395c6c4d012855de37275fa70bc0c7f722be442fa7ff9400277d001c9e3689532b5bb13913d8cc2e3f358958b411892f6de77b9fefd3f6b4155a63631ec49d58d901db564f90eae4bbbd2ec0ddeebf52582d26d587834d8d23d2e016a6069959edb91723fdf742dd716ef8e84f6390795ee71198dafcae53341d6ae5e8741003982fbdb3b97781b18e12fd996311a43e1fbfcf3b3f3200509490cd8be19e34d04497d67cad5bd117fe993f2a0304b04cd197c76674dae80804a43b4932f3ec19834116b8fbb6d802bab342a12309dbddb8b798b897a43b5a2364343fc0c294832e513a0f5e58e9d106320949a037755a86a59320c3f8f6b6847d54f599ab38028933593239d7d80f0f47d9b4fb9f12c83a07f4452082eed88e28b06f0a0137af876ba511ab73705851dcaf549addba44aa7a88afdb4fd45de829c5cecf7ef1eea752560979aba32899fe37089d05cf14a3e4816bd16981703535943228f7d4ac0384b05a52bfb195ec5a95520468bb12a1903cc550d3c6dab6956a19f7132404c00a85bdfbccfca866ee8621dcefbc53995e8c9f4691f46c7aa3235fcf8dffcb9627dfe1b4094cfb3f7045c8f4ebff0743745a69c75950224314347148b8c203e17ac7696759b49a83b758125b927e199e2001b8f2f4626f08330882d134443fe1578028e1cef274ce24924f0ce2c5a7a0da7806a59d88ba5e728ca15269f063ce6cfd7b64e49c15e8dbdee1468d98af46608fdecc1ddaf87f9e218ff7745f3c97c68249f21de3938ab393146aad746d6a671c207d3d196d55af03d3c92e6246536d0dd38328757fbd6dfad2ccf212e525e0c39ab89282f3ee1ca974a1dc451fbc9dcc5babb6b9a9bfe01d3db8e0c8e63918c3f74d66496f7068c7e3dfff92a90d6bc4f7896f8343e49b96fc3e064f05c76b323f24c5e3eaa53d126eec40a716dc6a7767fa4c40b448e2cee1effeccf3c01c8aa2511b83f0352122f2cce65d1792357d82224eb70221285f538ee38d768948b5f7767592602a7198b25adea716c3aa99c90e0316d2541bcdc29d4f82e85d93649e892f6a35864380e8703ec80d731820b6ae8c91078d99aaacdc61a5683aff738478810e896fbb19f3445314bd75f51dd2d5d0e7c098f0042d20207508bf1a1bcd63fa014219b5e466f3428c8dceca583900e2a44bab36345a35811f2a2f3cb70a69faee183695d4b9e86bcf31c82fa1e463b2d2f75191192e405ffac10691b8660c5da2c0baf04e9c8c2f3452d37ed1802a74878e3c5167d6387a7db78a7729e4ba7cee32911cf37da1b23b9ca84f1fdbcd6ce3cee77720c5035c77bd2074b2911ee15ca21dca7ea37be973466853688d521a96f6aff6089b5acf4c898dd5619cfe846d16acf2606df69389d488ebf11b8e9a5cb12e01f8ca6513e214acb4173db409c000e43a47de2ea91d71c894d419f5e47864d72360348c4838e4a7c0b5cc15c148cbe58e6b8673727ce2c64a6ab8e719e7931350448c6f875a766d5a3bfbbd5d3e035287c8ecb35886eea5eb6fd85bfc5379670ce84cf43b6d71f31d6aa5edcc5a7d3a95af64102ee2b0bc445785fb6873b704c410a0d45f0cf5db15cc809d60cf3eef5a56c2b2c27b7c0d488b6da95059bd4bf7ec2ae7190ac39250bdb5a31f58ef45ac45cff414c9f9813a79ea445fe321405bfbafd893d8a0896e2cf4785aae31a0fbc9200bc9e03547ea83d226ef78adf3fd5957fdd798a914918f5ba7ca613b838a7746814d123ceeeb21089d6844b6f56a887f74012360844199418460c54b28a06eb2296befc628fb90234b6d89170d7ff3e212fbfbe5bcdec72136281e271e27a79f33a7d0c55509a26b45c5bc0045c30da878136581af991244462b7d9c563b46140f85067739c493be35ae0eed7f9fb5351048708da8c0695100bb419b73aa77f479203728c9831094d3ee0d1b5c07a6752be4ac12e24a15c87acbfb9bc78c93799a1e5131a5acdfd7e26c95a13691bd9986abece5c68f066e8a2aa93f061191129d771b9374346d251ffc3316d07d75484d3fcec081a4616ea1cdcf8cde2a4d747540b0fb2189c1745dbab9e91a6e0b396cd91e50c0e8ef20534f86271041296bb261c94a02b9c2368022e9e476a827cf2a202a28f1c99898abb79613e31a7abdb2d5b1b704be87c5ab2204ac7d61c20215d5aa9c96c076bc7a9398771bc4ccd3e0c7906735c4cfc3c03737386912ecf3b162dfdd7733cfbd6344407c868084c102ef16c76f079b4f681c964245a5a8e212da629111b31db7652cc347ecb1cd23b80fbebb640faf6ba97262df456b1711017c1c3daa1656b873ad0f00ff62fae464e22cad925aaa1916cd9cf0db73f0fcb604388e961b6ed4fad1a0b1954c312c620bb7af636eeff82932e1a90d09b4dcf942f0ce348299b2516961e6779bea66f0e1d1de0ea8cefd31de061fd9a91e75b00e679ebf35ddb39d411243d2e2ca5c549a9c13f79e4d179d61fac775bb2a17f3bb42d830294e08b9794e4e567711aa1b1329809d14a379a9676bc155dbb09420590e824098822a2adc97a67bae344144006ffacf2805c2cc98e5d0703a9efe2f0a527e853b1f54540c9cbf32f40135fdf3c4fe36fdcfe51c372fd1a3bc80dfcf9976f9dab53ef47a65ef33339f7ea14a1d6b10cd2f99dbb5c26b99a6f930ddeba62af6138d56477dac53b64dbb96ef17b1f39bea87fa0caf5330bed1bd7db78a1c10bbdec70394acdc9c61fdfcb63531e9d38996e31139667a5b685f578b1f6310084b62b51ebf34fe80256988dbd34cc81bfcd88bbda670620cfb25de20648dd4b3aee99380c40c3b08c8a769c9eb5fe0101ff11cd62bbf4bfa1936aacbbee6d55bd0bc4884c528e1b4a9c3c128512bf9c309a0f18232d947807b08649ba6adacee67bf93c33909cef6fdae270ef385cb7ecf91e5ea35589d3d72d197024701b0dd3ec1d0427c445e475d60befb2ba76d5c5a8acd6fb3a24a2a89a37e1ab3f2734ac46dab805df03f2290ff92d919f712be3215b6be18167b1dd8967bcb0ed425ed51a534c124792cd8cf8b2173db92638447c5bcb902af9d53759cc23e82f27de1569bd73ead38db96c71e727312d8e5962c56eca00d4d2e907738d9b4bf05faad00d8dd52806e6f84f960bc050c062409452b001055f9365471ee5a7d6dd3b9dd249d0dc715af9faef26e20ac32a68746ea0cf01617e77ad9385b6e5d4f958738552d0bd7fe96a516b35374c9c607df2c14e2eedfa79c32ec9c88c25689f4d8750675b06c691407774bba4186c060acc3fed97352a6598610c56472f15853f013e85ceb297bdc47b6667a6733067cb988b9c1e64c57dbef4c0787236c770596d22b06d2d9ed02c81684c5f82c25211e1147c85ba18c9fe4a501202b5ce8b2a3e7b66125122c9c5f28cb3de0a6ed052b22111128d012d954d7c699b40bef01e73445c68fd932399bcc699f4e991dbf7b86600e999d21957b53bd30141dd3bc8934359bac77c8f917d87c791e084e5728630c3867414d4c767d0acea21838d1cb9cc1be84a071537192fa229a75d9b128ce3aad3904e68930d64ec906dab69aa50238a0c60c7fa4ef7cc6962027e966f140f038f234ff4126d681dfdf1c1405fc89023525859fb5f317b416d60ab63e78baddd8b55d6c1380b407903cff17d873450376aefbfb00155386c01ae66984cfe6e988aeee2c4a214e7a5c131144ebdf3bc81af15bfd4d4e9318a1def339d83b48378eed26c4342c11288e068e406a3ba6f13e08438c4c9c35effeb8403394b736975ded6c9f90692ea0c8f57b27240e0995565d2560e4fd6dd087299e0096a2354c3fbe04aee01638ca0f70650d5511254a5b1694225e46b41e6a28061ad4db558ae9460392092958837f874dd871c9ec48f7a9b85f4f222315063e259594d989a922508888949c4f249d29444f00715e0c307313113d4d6777e30b9d457030169058ecb56a71144c22b6ba154979e984e6f162a47383d9cbf07855566fc255623f541a6071e431912c4b63996731c996e4214e842154acf2de1550808bfe82c35a58e50005f2628f723294b2df08b2728e76d1509d29a742deee6764c0b47e5625b9ba448bb7d4d81b39b10f7e8c21196ebe6ff3f57a590f6b46be4d38297cc1d841f7eae9aa6fe915dd4ca6df174d0b4f5f1544a52c0cb6273b9abc65a4163f4291c7cd369be0941208d477356fc0cf549d6cb94c6f99e8161fc58147ee5ed5ea91adc3555eb5f3e6ea33e48ae0236c81789ec442fe3f74848b80a5c64e866db903a5b7c46d59b4407f21766a5641fa38e2cbc3f2c61a82bceebd156159e7f6234513804ce36ee062bd8302b3239aad50fc60d5b6faca532178df76817e655da334d7a5d7c70c2e100d7618399edd7c16a94bbb0ef2dcae976a4507738e2c393f1b5c0e9cd53a3cca52ca06f2e0c1106434d188882e60a01f1553f4f23f801ce5a9e87985c384ca08feb23fe4e7ca588a3367ef683a2cb595ec8731869fc28c49dce3d519d12124565a32390cd80ba5f8b03303cc17386e122e7a70a5b8d396e875b458c4d9ec7c668609cc8daa0500112244f5fbac444007f61cdadd66a63308aa53bedb899e51358c792453be3a2e44949e58e06a06ec4824e77331da75e6815bdd2e735a57a9f9294de247287bda276a90956b56f22856b702be6ab77041380467134a832e4bdca4a87e75fea09cb69551f7edc911306c1dae57d03e01fe12e2ff6203be9efeb4240a857aa84b66c8d51e77034e6c94b576195279eea4ca23f99193d110a85e03ea52afef8cddc8a74d0e23f8b138144d2d9d09da904aa81fd714e6124d78173a5ab3de6146a7952676ca843c16d9fd77639de1df1a6323d52901f00a78981de5c093866cd8e134815827b89845fa5d35de31f337c2711f1cc352b07663d148d179f46e63623a25d7958d6902a3e835f84ded36363a103c4e7fe353fe766ef35851188d16e99140e2f54583f383573cc2c1fe965b0a007e93edcc3b764e32e8066289c2873bb01d3200335198435d34c65c491affc599a2162d228247781de50fbf23b84feb66220c489f304b7feeac683aa97bc26d68614771f08ec11d108e0a300aedeeb61fbb05b877d5618d24843e6522f2afd3350fe344c41c78d12b1efe4e5cb21bc1987ecda8f83d1aca26f9bf2b5328e8deba01d219cafe1ece612f4701c0b7315636076104b1712ad02c42a2aa4c29511b6dd79d1843c167366ed1e7ccf1024b7895c9355445b149455df3509a88132fdca9006ee362a1b2d2c21227f527d47a1e7706614b726636ce13bc3f0f8c831c88742bb04a30bab0864759a2a9babefe3d7848311230fa3a20b70d16b71309aaa98fc132b8a51fac92632a315dc430b1945e5fbece202e7f8f47bb30b89522544d39dc8f665dccb358dc1ea0f1a25bad10d89bd279f6f250a0bf6c9d0b2a5ecc8c1809b5fcd1984fa4024d5f0dc47cffd60ee6c7fa9cb056af5ccac692cfadbd91145f826cd38a4aead7c3da58143fb879078b48b3b48f2f085bbe0b4a566f67de6a5550d872a1b4fb32517d5473f34559a38a62ac49cd519ec29353128d5f01da2908f938b575c32bb100f4fc97601004fc5c3dfc50508289b56527b11408df17816587fd21c398da1bc8ac20781577677f0096d4fa5affc0901de7005dd100672621a09f670edd5565051586bd5bf7d68435ac0404e12a6e66656c0eb253f53d3be15d4154c90b4ac2244096340b5d5883dfc7a3fd0c3b1bccd71e928d853509f11f85f68c70952b61b844fe21bc1f9caa51c330d7bebe8eb6f58f5e69c72b9141a42f46dccdbf70e1a266e9ffb498a249bcdab0601484aab22d0453f0ca9e70ebfb72653ef57e17d903c3ab5ee6c7f83c930377bb44563cf75beeae5c330c1af84d879c3f4972a34d5d19e7a502d76ca5cbeefde1f33da20f7050a56411d3a8db5fe06d0236a75ab6a5d357bed2f03731724227e7910ca6ad7c206adefa44b6fadb465065c2c399175313ee26e87b1f222519c5dd95eba9befd01f4ec2261e8babbf1f10892c427935fcebb51b2bf076b569e931bd11fecefd80d02ae9cbbc5ef4dfb28e418d25675d073b42dee65e3ba48981cdfb59ce94dc4d98128d599cc4a23280ca6e979ac673e63a31a3dd49cb5640642b929211dd838f42cc3cddfc57f5f7f86a74fdcc71be0b6caefc9499d7e15515bf111a718bbd8252a1898090e3ab6bf69a3de6deb843684e9187bdbc15c6522f398400102f6abf4c25ff5a88ef2c2cfcd19dde56693fac0e4005d0a7493af095247e0e16c45238bd6bffdcaef24e5cba4876404f2b5f4dd6cfef86fb8b2c603c4546b54b46672cc50b13dffdf32021abf802a25c7b94a1174709ac8d6147b160605f0872ccf11d2075053a283b801f8d8f93cc606b58ac92b7d5070cfae1dd580da7515bc225c4c4d326ccc4b1e8130a6b53dd8cfb79a7f8b3ca9801f16a2e460fbf39f8c75644cddcc6b0c770f1afb6cef44b1a084400eae6ef5179b72a78547883efc5949e3a008bf6053b5cef2421480d37b35f8c57473cfd50695f1e16df799845a1687856ac8098538c92052744a74af68de7a1ba74126dda8c38e1fb431375ca960b5441ea6e86e36afc10d21b5fd603d1072340694bb980715521865ec4cdef90263e26ca4e1db281a912e86bcc5ebc52796ac28000ec57b121d1f2593e8e197d6ac4872c38fab63c04f94eebefc6568b96331d9a504db2a6da77b7a9b7429b693bace711ea7b7cd4a6fb52d0f559f02e84f009f97b6aa2ff9d67efeb181750f1010bec3cf6d5ac649a29e63b7b28e9d736da002bbe1074c3ce59b61bf74b8b20c3a8fc47f1b506371f1042c75d99300018107804c65bff8e33936d6392e66f328b32842858f11da4502b41431115d8aeb3058e5f0aac293e6a3172e29b478f5dc01e31aa0c180cf5ffa6a306fc5fddc72d9f9b61cc5cc1851970561470e673cba80552824a1833aa2212ce37d912760c50efe44de65d6c120b6831b6056648b03da858b60c2ae26243e0f135fa32f5c0bf01ceda0df5dc5fc386c3bce8f6184155fed6045d40090a1ef24ec81a92574f94f9e261450c570fcbcf4dd44480b41bcdecb0237555ff2c426763f9e8b741e0f77f802f228b5eaacb3758d8203274eb73e9a664318e0abf7bd82164ea8b4a2d5d8f126e610163592f968853b98fc7820add203ebe03ec526b7e5c51f2793ffd5b9fb71cb72451902bc13759b4e000b21f376689b07d0cbc3637ded1293641b8d289937553a43783a03756653b7e22671bd486aae73caee110af7ae5f9654095e296a0a57044a8fea5ed3573d6045c0ef5ebad3ab6d87af65870c3a2e9ee8f7111dd9ae11c84d059b7750ea91157de3b28b2a300f8dad9e9fe9f2b5e49d8011036b6456ec90c74eb708435da22837e127224e4db1f813a38d109096667dd69b801861419d2ee45c12c447e3847bc39367456dc497805ee1fc7a4ab92e165b59fe4475248caf9a55e3841c1056c4782e2d5de86222a70f5fa8ee8775403fb75bbdbefa9b40211afce549ce472f43c6667f5f85c714ce95ee786bc4cc347911e9a0ade48e482b8ed39657e4b77a3a87b2c5133a05b0a23d1ce0e5561f1f8b4deb8573a71138935d868d4f7be9d0fb2727a121d9ed1227eddf4dad759f3f2d91c650ea669378489d2bdbd1ee11410682f0d2e2f19be36b77230da27f242203b971271296ce6775cb8d033a4cb78381504b798ab59e3984d9d8af472eeeea99b3c2557ddf7c6221234e4fefe950d2e65c110f221c7f213ac818a70d6f5afdb98c302ce2e829398e0889d80c6d340e0711d1f84a8bed24c61d7651a349360ffb1cd595eadc29ef3f37dd42ad4b34837ff5d2b84fdcd394a14142e665fc43dbbef2178f1fec90fe9ed2c012c67fe34cff0219ed36335943e9baa08567e60a772957879398f571540ee25b247046f7b76418ffe84ce91963c3672acf0b09c56fd94eb4fdc8811044dad70df5fd10d6d9a611178969c112e61755568ad1c5ecc7130221e57775368888d52606693ae2fed5d82bf9389ac81bddb8781b63e3cb8adc7c8d0d6290192cc9103c5e2cbd494174eb198e2b3fdc7de3cb3929b303cb916682edd5e715c7b974adf532f70b3140dc537e7c4082f2e0e463afb139f12ed6991891c5b4e4fe8c4803e1950f328c33d161b59eb8a120516c1e3941879aaaa38a9d7f935056e15f5a70cd506bcbcb43d29cc7243db733a1830a65baad62dce20a03d21b3711d0b101508da9b51c09b10fd3f10e4bb9c979209ef83c8f077990fb23ca408a019bfd887a624126ad43e03cfc989337fffb2211cc2d1fc0d6b53c23a796f5648c37b5fdccb2d93673a99ba131208a6bf9f265bd82f382d45cb9a41916fe0841ae1879633670b968834864d8a45d2482fd97f20b4d4a682418c88d6fe01e13a8d8ee964827c76fa3c9660acd7a8943bfb094b01846dc88caf70f7187bf62a3bf7edb594bd275b50efe38a1b3024161317189369fe5adbbbf98d5c311348c22e214bfcf01b219aa316ba18edd715b730f6ff6c5448bc3b79577d2356c0e8507742b498b8dfcba4ec302cd8765d52a873a7d32c77dab2645a513451edc1c8e55590ded00527d8cb6a0a02f1b5854bc34a3017df79b94bc554bcbd189b7fa1d868aa450af5eeaa8297605c78e8f7799da9cb6ffd5a4e099d23f615317c84c7f21497c4df86009d038d0b57a75765863f0fa26b9cf27469a053a6d1057b820cd9c84bfa06135984d928664ab4cff4379af7ffeaa4e6c0437cafb4f3639d1ead91971b9dda4552f2e782acee8bc1b2da797ecf52bcf4cb8cc7a5876e29d16286191cca3158b80648e2ef9252f43d1016cf1d328e48beaef2e9563e2f34600956a436fe4dbd6e3fdbf7c13a30ec0bde55a84a85b0c84ea169c307692968e49405bf41128bcf966f095ed2e5d66559d960a3abfcb278c8507bc4335e86e03204a9810fee94b95879b6e8efd16976bc73e5b301128a5aa51114e0382035ebed9b20dcd12c98b9c569bdd4120ef6c377297b56f35a7cd93490af68f89f7527c9fc53a17e9d327a92520f4c1d36ced5d55adbd8023a536290c3c4d72e7013ef44ee409d9495cac81cc5262e0bdd39d0209adfa66b2dce4291564bebf2a42086877fe0c5fae521cfa288842a0a94f0ba68ea914b5772bf89d2fa763c50fd1102128d8227c4b6633840cf87b815463ddcd34106065b31a3c466bfebe8eb45b5c69d00703dc906c907465c6c484c708c57f8ebcc10e58598cbb89dd78336793290950c0109f4df9e17730dde9be268f113a2c687953962e33d0db5d9dab48ced58c784db067c9aba2d8569c64eec85f7f9232bb36cc52caf42a235f69d717c4cf4248b17a1cca3daa284c76500afd61698a5effad88972178c4cdec31b34af3ec433a8b2c72f6e145961a4e9f8099e25a99e87e35724e2e7ab429a74068dee686f67d96150deb0ba19b302197ea75cae2c733b12208f47bba99d25b745caff585e41a84448836d50614cb1b651a81cd687b95d11bbf417e128f7df23b3f54e19af38ac896480ca0f47b7efb6b7324938d33bf208c59dab2a6c56b3442b630ddc910fb45547656d26badd3443683a98533598dda47b4e366e3cc3d26262857733256d204faad2636ad10965de4e293cd9166c6550511812410fb2220211b637841e6cb5e719332a4888d5df5e051b5397c8fd08e669c3bd0a2c088ab70c9c1f1c8379f3f5dbe7f502a257f6b1d185093f74303ca6e47cf15ee57c56e2d0f4693ba1f63f2143ef9728b56885e05b8b808d42e6212463e83bf5825d46b7746e305b6aa0221af8d63963723ae66099462d80285789b5f49c526b39cf4e0973491b63923694f058aa6b62040bb4ec75333a79d7e7eaa19f61dab0af4ac0cf97e015587fb07b5c1e7d8e6758702bf404dbf66ff182c9425e04f366a71735b01a4ee8e537c0a86b89be80d6ed325db6bfef7bbd60a71d4fb5fc20eae51e0a9cf6a7efdca56374971755407c59854ba350ccc2044f4e1d85b7ee46f6de44e5bb4f3504e8bff9da33d96763c003703c30c55bfede6d4c48f4e8a3359584956d90fcce91d9a444311905a24160afa10ca6aeee55ab04b1e9e50de45a952c5f31c1eee41ead330cd31f3bff710faa80c87c19caea3a14bdbfec42bdfb3df183a4ecad02c7e0c4161d34b003f2014f3dc601b44768ea03fcfbcedcc764117ec5321f080d21a9ddfc10cc4a7c26691520e7cf3643dd8132d35a784cff3da8b073a8a3561b0f54d912c06607361fadd588968fa81e29ba426e4bfacbc5b9327e7d56bfd089815b015b7012b74c5f55fa99419a5d28f7efa2d6a147dc3005a525b44dd1f003025c2de6f410d21c7d2c03840ee3016be2139e677ca2bc8dbbcd4021c2096064b64e8446ca45f0faa6d8d211767289e6b0a1ce40129b0d9bf71f0c50c240febe42db29d2b9eb313f0f4688eb9633dc5ba643a761c592f48d5dba100a6075c85198b4f23af2784739c96f8473cacb64f2e04370957f0c5aa53ba449ffa396b3c75d4be4d0494575adcdce325500ccbab889c6a5fea64fe68f99508c15e6512609612bc6e2e123adf0047d99b0385724b5e962f6373a7117b8d671f4ce79335500fa9068c845edbaef1f4ac0ef53af6418c3e165d1b3b680cef45548b9ebf6bc30d0583b15ee05eccdecd054227f172f0534ba1434d3fbfec4529b9e048511fadacc683d0bbee199dbff21627862a49a8398d8be67a39ae628da9302e1894e27f221eb54238faa4194d6c083ac1a49a6a340d9776a1693a2df7d41e2866847a039414e2acf40b40a51eff805917dc65c552244829dd36be7caf0e969519bc97fe047fdc3048685068a9c7bd047c4d596a75ca4e7944e56653361fb768cdaaf04dad7f074b4514472c8bca79660dfa457f832750048c630b457dc0a93ce33466bb66785448bc1926e75629e0f264507021cc5cec3eea024ff7b1428e1270e35e7d4422d272bbcae5241af1585da1ed21cbb4cae30bfebb85bebbfbeae1495974726494d8c611f2fc64cb741285c8e59792dbbd8906ec20fda743919d4771f144ea19dfb076558dd346b1664fe1399a30cbb5d02e4278d5f6fb6aee9a776349587344d520a5661b3e37582e6e3b896fd755e8b517b0ad421d5a848adb645eec0b74582fff676022e2a0558589bc2ea742a16762db5e9450dfa3da4d11af8c232dfeaa22eb49d28e16cfc16a44b38a8ba87eea9c993d76bb3bb7032bc1ca274917967ec211f13552964cf2c629c4f7812a6abe53f27071c2510fe7458ff18833aa2956e173468aed1fbe57060813afa5eff4637cf2bb3eb06968015316398df2140be585c4c85b438190f7877fb2b3cdc6aac9530ffd2e472e3016a7635d9b7fc9934f45343c55f2ba14259d755f78db388ef259e9bcd3b74a13af460bb0348d4a78baad5baaf1c0d09d168aa5044a58cd2a16b1466b46151bf69fd5417b2ca2ddb95fbc82ee9c651b1c5ca822ab918a5fb5b64ef8cd456232f16b7733f425f22b50ccb2c9eb5a282254e3de73368aaedc777c28b08e93cce918a7b5535db19d12380a64de9426848f17607d592dd50327bd413114171c1a095de06a90608e3a9d7c6726dbb7821fae0fe564b26ae4fa9493dd3e48c4b0b523aa0a09903de53a0a067145e84f63a4fc6ba70b317e2005cfad9b2818d7723e51cb6e138fe2f2bd3723cc49227a6e7c3a8691a2db39324078690e219ad330f27ec67724b74528d8b56c7260233e8dd2caf299698b64d1691aa5596abfa4ee17e1408e0f0b87dd6eb19a1b3ce459244963d179cac4b0408d0731323c2f6e5a5815ee8c20c4568c1b25a6088c767fae0196b96a6871021cbf08784789c3c214b007aa97d7c6df1e525925e62b6940a0dcd5dcc9b3bc5f6ec278cfcae1ac3ea7a1f789b9f5650afaae482b8180b0e4f7950756b9e5bb14bcd38699d895c3ca5ddc3f7ff5b1c84a615993c01b09f92632757facac3d98b36064a741aaa538b9da1f8e88709098a0e4c86e12296c4ebb9a703ce786251aa3aa197417137aef66135f32cbc74aad9423e7932cedea644a27d4d0cf4e418b70f045414767d4083970a66bd801845b8737bd0428ed08552cc2abb197f4b281c3120acd2ffe8556c9accf433318f1b658871c48555cbd9151690b4f9327785da0b22d062c31c719e51d72c80f6e3938d3fbf80403cdd34970551b63355ff520ca81315fe8a36a6d2dd5868bd09f87429743aa87f6b1db6cf6c7689219b7bf1041dbc73b02b23a6d3e96c6135c8a6ce3d06ab6886640b193a6e384d887d1d176a1b7ae8791ea823abfa1ef02c888c6b6de94575cdd5e5ed6264f52621da9f65fe162b6a9b630f735effee7c4a2349aa03088e6f26aca98da5b18e104944780840f2b2ab32a0dfd81e3e05f194fe10f5ca0208527519c055545e98df8a2e7927e72dab59a4b12e7c6cf02f9605272646dd1962d4b201e881090fac4a6d4f30bb0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
