<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ce4c07ea88a9e611b08df6813ca8ba449a8aba98e80490a56bdf1c1400b6497ef88666282edd1a917491f5e41151f61a9426411732346a37991f0c863b130c309f42f140323f8892314c0368ebc59300c7d7608eda99ef12ffe8dbcf44f57b8cc24ac7398353969f021d1e3a0d30e09e0a9a38106cc7d266e5b918ae39e79eb53389ea71541dca8156e57e71a2a75670285d339affe4c46e99ecb132672b8679378699d05316b69332b3b25b767a2df6ef7dceb18fd559fe93817ccd7de2670bc131d124a790d944a656f423986931da20208f66e73fa4c36650d6d9ef1365ded3d0fae046033ff923520ddb05cae7bae4e9489f75f8392bce8d965092f583c635c07f8ac3af3482f18d690a02d0859f657fd7141db5fff924d9275698f6cd4d4a5fce5ecc2c04b791348dd2231f835413c7b3ffe988c9a99f6e973bbaf6b02d43d786e581bf66f8f5eb78855b7637197014b5b1555d6cefa4e24ae33b2c4b223d0a57d139bebee79e8a79f6b43ac3b0252990eeb466c0c106fc6f03fe319cf6f4a297ce07ea1b5b0627342bd5bc20f447816245726e4ec132e6f51415615619a5ba8ed160f1b877ec930e73f22e1a2cf15e1dd4365e48da24ee9741c2f3f609ba24b8c8cef0c2041518f1eacfbc47908c112226ef1233783ae5d83758f198f343ca2adab6eb981ef91d37df9066a230b54823e1b74a26744c33dfc341771504b1f301ee6548c8aa6e3fb80e7f69747edf15e44bdb20641a227dc030ae705440cdf11e6e90ce0cfe313ce421dfaa84beeeee1bb2c06a349bb2d68465ae9e76b5d46b188c14b19035dba174ec6af2590e18f20a1b9c4bedde7402e48ccd4c013112fe1c7c781f03b098f1325509fcbd5563dff532d3559ca1f951e29e93dba941dbdb9fa6657e3a78283e749ed7bd6b6cffb2a53a348b3e1e89672f3745bec75a33706f0ceb8093eb5bcf616416b125f101b2faf93f743efab7654abd90aa623a127aaf8423f7227d38dce216c48008d758baa701bc96bfdfe733c8e216b033310d20291a4aec543d8566ccd4c0cd48ac4d2583a95ccd8dfb5975d24e7b15c6714b025b2b0426e846f97d8866a36c24c9048681c4edcfc1f126b46b7b1353a159de9014e8f9a89284ad5581ef8332a68544ad4da7aac35d4e069b99d6ae1819666b177dddfe72c6e72bc994d0abc8906a608936d0288d6e5d18145972ffab7a16ed095408739ab377d6cd7bcc26342cf83568ccd2f13035f0c727ece917ffa30f191ab0375366eb1ee8c93d71533b75f434330d69da7ea9a74f8974fb1d9f1f9ab7f340a59d7486cf06a058e4425be02dafbdfebe0baf92afd79437a98d88f8e8314a03a3dcba0a6edcf6c39e5756f0c7bea846936a7c0b730133aa57d20faad83327f2d7fe54c9fb3a7967aee958f20eef283b2ff9f6fd5a36161fe2f46daae3f6764087398289b88a6a35aaf7bbf6ad0d7651a61f030c94a5fc3a258e5ee8a0c81cd3a04888ac8a7839420f2b86515e73d26c0e908f0e1e09a1c41e2a9fe517bb248e62658f8101313e7fea37da5f01a9bd072a161dfae770a0a283c5856c576608cd33dc1c96655bf6604b2fc84e13743afe6586afca40309f6799e0e7cb8a2c2145dc0cbf63ce9798fd7cab0d7ffed612880a114c2e359ac6c787554ab402af51027e5a7c34d9811a0ae021194dd04731599f33c27d2cd6a510b854bac941e651934522cb6f83244d124669414989ea0be6262fcea029cba00596327c54bfcc799c572c87627ca35537668c710abc8eafdae89d6cba0c8f36fb5ab7139920fe4eb7108a131d5ebb18de034ea2d5f1721d9a3075b1299ece4c65f2effc30ba31f0858e6b5020a3c7f9905ca6f145c2593055512a01f65d7b37d8983b89ab6d4affe0ee8ea12f2f1db49db1fdfe4a5b4b888925aaa8f95bef6e2dcaf8ab48366d060749304fa25a651762bc45ad010a178928f9b4c23c3b070bdc2fee2534ed717f89ee10aa72ef49df081c76ebc25ae7c8fa52c59887b1fb17096f19682a81522e5b51caf137729a98ba5ac8cec8c29e9ec319176eba5f267f338f9e6376d5ae9d2eb4bffbe3dd5ace43b04674cc3fd2dacec3a518c1630889c546956afe7bffbe9b9cf1e97896d702f6ce139ab798b4859adf27f205fb3da1b2f039ff57b8b7fdb2b01032713d440551c4f892f51d79c3fbdd4140b6d315aae019313e5c076f720300623c7300fca0705ac60d2399840076b1c398b1356ba33af57d3e106545d600395b8fa530e0ab35d577c83ad75a3cbdd75a795771dedafe966a0ca458cd4ecaa74df363582c772403c65dd501d7c17059818718639edd47a3375cdd4304e5fd4e7596a7d6b102c8ebb22d7f328c7faf1a0971849e6e6391ec0a69083a8b8d1aca65f711f5d466fe7306a9cf15c9ec08e5cd4460310da22a191ba83423d1bc9ac4ba275fe3fc48a1d546b96067d7deb832bdee293d0147f7bd7cdde5927bab5619e663c8d8ed4654c82508f51bf3250f980d752c2e154768e790e831e944051303b3dd83e5198a720155489b38f0affb427edaf8467071db83942b08ff3c31f6c215ce979414074eb1eddf86b4b6d17450185fcc6ad8e05b4f5a3bd3fd24e1879026d502da213a1576f2f57c81679b2291d67db5fba34af1dd4958e7c134c0a6552e6a9e11752e063c2c25b29fe176cb7af9bd7d87e1caf9311c90279c3c7f51b977a075593143e47b84dbf724d54c877bfc4580ce67c1a01a37b936b6d14a370657bfbdf266b7b70a159efde3a6f11d5d4a5a5b5d999b06bc34112c61029a068ec8fece8c5dd3825b630b86055c1b914fa2a2f3fa819fb0a0fa9827bbb8929e62aa466b329ff32c08dd734cee618932d9d3e7b76603de409dc4c7d4045e79a7b182816cdd6c2c07f88ca270cdee2f506e9c5d6107427d918ba4e80e77326206454ad4da28084e1393c4494133bcd10d4adfec6550f26d363c3703a75673fdd6dec5962eddae1eaf135db4de71c82a6c2f6bb73747dae3a811f42d91b3e293ca9ec2e436d0e90917dbbc4659363624f2dec0f42249036383049b6c47d3c85f467975332c1e964bf4a7fe377b1824735c4722a47742182672d232b7fddf329bd2b016ca23cc3782949e1950289d9e85a306f07bede49a7f130020bcee46034611419969c0ecadb4890d2aaebba07a57316a73d37bee3fc0f9c8bd4f14a19ebb2bf372f7dabe98d3fef16419362b8e3111338e70ce48b09a5a63c44cfeb292e0c46571d48e93db4caa2559a3d7490a9b9e1229312951e989a8ed156b9689c5553e5ac7169abf0d2b97cfc34bdacaf7dbd1af94e7513f3b05215278c0329389767fdb4c46ef1319d5c3d042a4dca30f07047e281144903fa37f66882ac3ed2f1a1e32c8f97afa26edb50cf4efcc446e9b20a63b1080b6dce431484f10fb68122a01dbced34a37e6febb0c28893eb649cc829013a63f05a2eddcfa6ce772742942a5d030a0c6a228e3e422b4efdd97797b2227dafcfb681d970d4b87a18c04aeef52abc5f9de10311898efca0e71097cbd21d0d34b3226c36a4ba9c52a3011226b8bf78de7496ca7fc8863fb5923683a6fc505060e75066b395f549754cc3eab8a0a601fbc5b444447a4e0844cca8e53c91c072d52180be1851c9903f101294be4f1022042c750fbd4bc30e6d9899e0584277f882b08d4987170d5599a81bcfff6cd4140dbff93593ac43ade07a3a419e217ae3883a3c054fcadfbbb87b71aa0a960831e8590acad9afb757fa6809a250553eb9b4c88b1784a7b3f55ed30a5285f123ec9a09557ad15c66b60eddac3c7da29d5de4af3b0fe0c6ad3ce50c225d9d6dd3d87c403cb983eeea38cb681d7e92b205716b8a5dd5008040983d258410b9d5b39ce435e1f441c6f7c2a8bdc01055ad97970bb96d2beafe32db7a5b6d01d1ba0b36c9652fb2ac032bf34af6e18f3f67c3f830b414dd5874acc56a97ca2c3ac23ddccf8262914618ba2e8c8e0d9d97988348e6905d761cb6f2dcdec89695df2f5d251fc668b904558012e60fffa36198f7287d63085f3edc49e83efde52a4bf841c6ddc38f8e21698d26c2dabc07fa6255f6039cd53837b850d639cdc752c147b8c2df690bcbf92c59d3d6dbce649278bea4707d811e3c5c161069971549e4953dfeee98f41f660f3c5f5840f7c25bf098f7c8cd52bb0cfd4f1fb4748c7e21a989b1ad60055b16b5c514d503e5873ff8bd135e3dc478bef1ab23014838614dd1bf746aef9eed709167507287a2b66db9ea145ffdbdbd79b03494370a7a1b327a50884d8bdefbac3fc711f88c9bde13fc3381c75a058089a45447f622f8e3466d132be64215d4bea9d92ca5dcba934015af7694eb459a98de454edd91065d0af5ea2313a4748018a8ff5855827c9db9da680718ae301294222d2ff920a28862641c8fc04a6b43d14cc0b21cb36c56b14f254eec4add124bf4c7c64e8e0de814c2be09e5cec64d96d4500e32e8fd664d5a4cc74d8d58b9ee78a922c0e279092fc263d918d4ea213425e7532cd8f44483139ae49e50834a72a5a7cdfbaf9f63c84e1ac015351bee713fead3352dc6f4f3ee473728db1091399b2289c134b832968ab3bb94de3a7fdd0766820255a90f01e7683cf42e4935ce3089a86f691e784d600d93cc98101f144ad39301a31fc5c3ea41bd2b47fa02ddf97c77db9996cb02c2bd94dff48961275fe40c92c7c9bad60c8fbc38856e671c1bc2391bef6c24fba35f847ee4b59f12768629f3e1161d7c11db9efc6046ba0aa6172b6d0c8946169efcb2886f5c874d20dbcedf7cb5053d30ead6bc6a08000ad7c8d5d12f40226661f7c9571f168cc1764c0dcd5385d26d4e7500cb8a6594a5867b6ef7c066706ace5089988b4219eb82936ad51e6143f7e2a5a9415172cdb3a2b8fb42a7b00fedf24247720c4016303e2e1c6313ceffe5e697bb575336dd4d37a7e78327f6b09579ae8042bcfe1b6ee2ea4e4b3d34643a0f8048c1e7c47b0323dd936d379216eba78030d50e1c861688f18d7b8779e6a173d00c895cfee149cd9b387b86e9ac4b9e428a6692890541e90e5da9e406c65c21e0bf380d286949f6ab3de784eadfa833efb2a22b31988c60603494aba734f3323b21c61c98cd10b739ab2caa5f5ec2db748a00bce6beb58cdc011e06e25df426a9e723eddbf5e28815d937bd0a2929ce51cad7198024d8b4f09033446fe47bc9e3c12cd996f2da8498515dffb0029444c1b0e395c9327038083717f76f4943ac3bdd2904816254088e493490c320702c135ecd4f5ddfb895621451c13030ed9104a61786abed7f35d48220707270fd63f6341749b46c90a880eec9075b46ef2214ddc1ef5d7f0db664516c7f53ecb0cb0c74c2b0b7875d562f441d0b05f6d194ce69c031cd4f4eae97814cec0fe8a5fc2d37aa72e8c61c6dea9f1f1f17089cb2b92b7f000d612d7f76b19fd777f1608062625900be46529fa1821a9e336d7620a7cbb7720637e305db860fcb006fdb8de2ae4b4b05b25dbb8fcc4a12992412655a3baca1197658b464edf9329de34a0f164bc0be98e27c723314ab676a12b3a7c97f0e571b8605c073f9dc53d5220dda2653372ca8bd47b1df4dff059b7d085390eb3fd75b34e7f4d490f449851783d68029450bb03b43e00e883c70f9671a087aa276003be1347307a0f6381863dca61e062e98faa19fa89663ae6940528b6cb605fc639493ad4a1da7bf7be0ce5d4632e5e866d9401908748f260b6c9249044a0dc5ea3773f89c54f73bbdafb9cba95ef61fd513461019bc96dba48c3ba978d212fa44322f9d6313d4e7730521a82719de3ab141d6e747f4b35b36601d3fac2925a9d0ed9b68f9cc4c4f5412fbadb4642f1021ee86acaef7da814acd71527b6c32556a4491d607c9e8a48a44df4d8b4fa45b7545c1dcbad6e62d5d46ab3bf8083ca403c2e6769940506f29940513c6f600916f007fdb8cbad3930a11e69c8c10cfe7521bdec4f7b8cc116b42bf47daa38ca0b963cb8306537a9847c0d8b06d3693174b5ff2f18ccf53a502784d9abf0578f7aa308f342994994794ad1f14a582bf9d46f7a076a7db3b16a50fd0a81c19c6e1abbf094562b712386c868b35499087b29c72ebdc2cd190450e7490d634e93b60c3fd1f444a22995193fb0664b171c44b77fd1414cb73d27fa089ebffb65948287bc3b754312c294b56970f2e254cedf6854b84de037b7c65a1eadef02e173358cd90c55e615f4679c3def83b41ed0e7e1eca73a8207d11e6d1df9e626b5b3b64740098e1ddf6039c78fcfd6f3e603cc66f3d34406b1da7a7b59eb3c3ce58fbad6c2804034a0e0c3102ba135539ff3906b63b4aafc9abfd325b2234bde811cc7374dd1a0981090233526ca17a0d37786ebd6e0a4ce3640be97571e2e942b51cc3564d82adb3ad6c61bdef4ffa0e9c8e639b016ee2007321f6d45ced0c2e5df1b50ac1c72b3366a954a8ca914401ba104bb0740a4d008166edd6cb151c0a906a1e1b26ff3aedfeb0c31dd3cdbbf1cbffcb3294bb40231239123e49baee95c3339d05699cf719f67f4ca35643cb15fb13bb86f849d6216dc0fcd5b5d2091a6064cc23923564bfe8be175a404557f5e0980bace4b831954cc8874c11d83e8bc298b54d4cf8f5b054f4c4c370c208e57a8eb34704b4f756817d7dbe4ac212333ab43002051a68403d97f1a8097aee01129799cfec40eaf86b24ae479a674570b9ef3b415f4c95c9990148784db5cf23ccde83ec6011ad2cb6858eb65827857721161611ef122fb2b81733edafca9101b0dd0940b7ae2af489f768f4e6c5def61efaaca044433fc6bc12aed2f7e39b9232babfd8b875b6ba0fce4a016d674463c08a406b88244939415cf43879345bfba7218c8dff2ab319465bdc69e24ef6b6fb8ee20884637f73b39705735cc97dedc42b745d8839e4cfd38202afeaaf5520c76e6f41467bb524a95857b5349d2de177caacf6928a8de83332c1a3228e0f030b471ebef1c422cbfdff1fb9011e5b61340c40bf386289036c7ebe70cea7af4e58452b057a94409e40e7de4f02a9fe61ef00ecc46422873c43ee12df06b4013c9b60b9baf188a85a7d0f2af1a17df170ecd9efb02f68dd971c4aa2351111346246e14e2dfbf8c02d4da9b0fdf1778a2d6bec3f96c71dc5c8d8cbfe0d8682ddacedd0163e51a1864775389bcdb128006cfb9ce786f408b968a5f059a2a3ea47fa492ded30b828dec5213b0165162513f3470d4582caaa7c1e79bdab0a38651801d1e6572a9644e3ca172be3544bdc0bdb737137200410622d7a960b105ecbba1f7dc08cf96586f513dc349f8e1cc93414bbdd7589596bf6b106b952949329772a92b981b20210561fa4d9e276485783e493bd9a36e11e8a07dc91de5425716946ee16855a7b4463616db6e9e54e8c4f534d1869b8a0cf839042e3b65fa712c369a361bc148d51521af33c28a55b0b447050d47457ce94d26f96866c4f3e3b17dce8c42a0aafec71868676bfe3c2a1a53f563efd55bb6de64aa8d1ed0b97c382a73b59904efe459b6b81e4c2a3411dceddc83e0cbb3d08947061f2001abb962c496b7453c7ae13651a64e99309f615b67648038eb49319739e4d205d638ebc9492d3ba0c7e32da9de258a3c4a7c4f33f1b947f6e0674f34e75c26ed5d8c4bc057d3172e0d22de2a318eb6e71b5e3d754d034d60ac3267a879f126f97f396a5622492ae3735c18b54057471a44db0cfe3529be8f258f72d57bc65a6d086d786b1b211d9cfdf68131f01f1b342fd377b7bc12e542df866a877d5bca5582218e5b09e2a841953142a099cbb7be5c735e53b8037be05f23b94d8734c8fb9a096f3c64ec811269ba28832b902567dfa341770b534c7614d0ff9298121d3f1bb71323f82bbf88cbe1fdeaa5c30e318d27fe67333001efaba248ac36afe9e0bc5976635c8b1a5ed20c1abc4109843c3bd187601e0c04b8d7230a7f27cbc384a5ae14b89a4b5515f154ecfa6d25dbcc9132ed86800b575d98728fa75ed70b1066152cf74ca5f3d08986bc5cb3ae62475aa0eed29e8c60f8775caaeba0ee64ec24bfd2e2bc05711e9297110e0a6af68867e6659a3c89067fb3807fcfefb844d6a69cba9ccc7ea1f6605d42a634f8e8e10a30c6857be6d5929291854614b257217e338e7988a171631a6a483165bb30a23b8aecbeb3cf711eb2b20e5ab5bbce8c214aaa9127263ec9d3792d63598d4cf83bf8253ea6b8d4d930dc768b7cb50b32896bde9ca1e2a688944301ec65573bd6e50f147eaacc745fec9dd24d3d130f2e0537215f35a3fe77d32fd4ad7bae95d9f6f47819499c54a48d7da92b1e1174198543bbed4b98bc03ed24d46905d10c5ca1ca40af01eb9501a0d6f20111086604789d0ca0ac4f21a90c0716324b3982a8c43d618bbb7a408158944c2556a086a13cf988ad1372cd29c013c81da4f6a595645fa41568a97ec977ce8fbec9d0777038f9373b1bd7ae7cd6847d195f0260dadc52b1837ca63df198cc64d65816763a8f2de6868585b70e61a462b0a0330e872cf38ec8a70a3f16af6b4799087109e25910e768f6413c924b79e5a24d73b6451bbeb3042a151c0862a642b1aaaf11146d5a15c30187db6ce2fc042b7703dfe4edcf48d85cfc01813fb6bd1f56140e4ea8de6ea165c0dd2cbb12809f45e52bad5826791181316a6ba755df57692b80290086c912f61b757f0d1e8d08d73f3fc4ff5dd9827f40fc17cfc824c17428f924444d3e216d07b775b55e09b53a1e28453da2efd02c3d8bbbacd34473b9fd28b9acaf095ac30ab322ca1bc1b2a65d8ca7098091864b677ba8ae2abbda1a8174dfbffa3c69054eda3f50a804d7f9ffaca1038313e40a88632ee2d6d678dfe8778f2bb66b5afedccf031e0394032a436fe1644a8cbad016d89b8254933a9927283bf15d0511f9daa1c4a9007dc04cff1d7080b5a007dc3e06508f95673798cf8d9580ab51e461f2142f0c32a8537bca982fbff98f0f8e3d3ff87b03c7da5dc2ba2e3f5affa5766f4f88f9987898d863d70eb81e6e3f2214dbb513ebbf00c8d5763007a67d2d3b47d8a0bf38caca879cb0aab95b36198977fffe332355a1044d2dec098cfc46bbae37d995f3307f934a8a1ddc0a6330e3f29ad3777ad4fc21766754f988907dfacee00eb126f4a90cbe6c7432ee9fb4dd0ccb320e0503ac4a0818447e4ddeb976620d91c6abc7c86206b22df93105dc8f0bf6558a1b0744e4114a6282a433d4ae7ffbcf9463eb71dbc322bcba1a0d2f81a6050cc76f5ecd86a505f9435e6c146f1f86a6d0e8fd9cfe905593c1d0bbf0d170cabf95fa4e27ccb061b3a89f2275bfa1278e75dc1851599509bfdaf4538350876b2ab70f2499100424e3adf0cdd7024edcf701f9e55f30770080a40106bfd986a43e68f11065f4cb27ec8f824e8af3d7bc833eedbacafa2025c64808690f58042dc230fd341a2ec2999e799d25800d525f70cac52a2ee71f6e7951db5cf4bb379183cec725fdeb4947d4ed624dab381307ac3efa5cfacf072adba972dcfbef33a3c8ee6a9ed5af8644b97be251fcad9cafc6ca4c3526c46c8a196239b88aba438d42655e2f434e41cda7e1d814c0d056670a0b5086b6223e0e8aba4d246dd980484eb06ca2112e4b84f3ec9ca0454f92150366fe45b5a93d5ae44ca4167d78fa651e00250130682bc09db93619f9d33518f3cd6376561f792a3b3e35f7d722d4f9acf4f926aee32a0c0d08dde5a8912616fb856d6f157dc45d0e95cf3d4eb9daae0aca839a0180d2d633b819e4446d023f19253a3e94280d0dbbfbd11de9e3f728d49d6d6bd3d298ccbb0d49548358280905633abe771846382c9c0480ccba10c0f391cc261d4451ec62927c18c62b5f188a81a138f3a6c2f51ff500ba821aa0b24fe226ea0f281d0117659226def0ac654dcc6f257f0faf45b69ee3cfce87dbe1a594251f13519b9c57444fed924b41fb832547cf7b658b21b1138270f375f62a2a154a973eec7166f036f0115abe1e054af63fc9eac9ee109d4330cdaf923e3e98a5ad21f786b9a5d5dd60e43f5b6a721910d8af5413282a4af4a8af5bea003fd2ee5b0a1a3fef57b19e2675146a27fa217855f7d3d117ba022178a29c8e9cc2b1b8b50d3e2a9e5645f0a465d18feeb0801e961c5df56a4cdba6418b2ba37bbb25000a8382905b1a1fa601115af4953f173f43ab95da24866c1d02353c0db043122892e5cf2305929aab76b2900405eb69b2bd3cc88bb93b369d809086040f774575c71d88086bd7921db7d93d80836c8efb9977d1c68277f1b6b45cfc37827805f116cd7b793528d29d89089e706dc3ebd4e22c1338517f8b53044f1f4807b4e2afaf731b347c3d51169d73f7395e823dbbec61d592882b5ec76719fb8e4a6d0481344bdda32854674781a3049af83695f6d7f468fdae12bfd0e7113e140916eaab33a8078fa4be000579437e6ca4b95d62c1fd0af37d137aa88260f052c6001a34011def06bb93fcfd8927474f90de3ae3444f760ea1dfc4ef7eb536738dd2062cf5de915770a33a3b80f48e25ada032e0a80fd487bebebbe3b02d9d35f5b3e60829dc0cb5b08b99c2c94ffeccb93345809dce405bd02ef1048e717180a13bf2c1881225c0f300bcbeeefe8d91a1cc0103305320094786d60500f1e2e367e85c8d3a6a9c9e9abc0cff79fb500989af18f6dcbc4e06e96fe315b3c09b8f5abaacbe33c0eb5d16e35cafad03904cb1d018b10ea284939273860a25a2105ab7a7c5b6bb096755d0794bb6944c56776d46727acf3fde22c5b1f85b6ccb99b927a73d3f1ca59f33e1f641f1d356f6149cdddc5a7a0a068caec62a28d86517f8a36765a1f9c13db0bbffca03d17f6fd668d577c962a295d5acc93b871d6f5b96f020242831bdb6ab9d5e72e0463acc4152024af6e8a6dfb0ac0a112188b252399727fe8dae4edd3964172e68479c56ee3fac3c6bd2b79cee79dffd2d4a48557aae89ed30779518c310d5f6413a7993924ce90f3db64f80dc70f26254ca6dc1cb00f3952cf58e0d0af548c53e404f94077dba072a5f638de2d364570a288533f2e955d823b80dcaf0812ba065526e9f8374f7416ba4ee697a6a2c59fe29ec45ac31dad5eba6accf12198643c5008d0a20aa858d4722b761bdb456599434c210834805e848ca53d5345a4f65f4283446a711b6d4f9e7edb4fe287fc6d68267a8a8f03df01857c2716f9267ea067215511aab0cf44e10c9cc8144b040e1d4768bebcff87e90b28617c6122ecf7940dbaf452fb5d8cff50939312808d4494f5056beda7f044c3407ae02049c5271dcc9a1f585a5b9908b1df759b735ba8cc8015963d2461031f2355dac44ebd277311e222be34f412f6c4888f8f7541d8d2a2da68346b5ea11458a014d4241bae87669036aabee047d43412ddf44d2b3b13325a0db9c98a950bf2f82c76f3b2db14ab564a9a1001601ba920b71ca82fd40f9fb5d6654f6d7264bb6fb6f9a71733bd76380b12f43c479512f87d78a7bc0204ad871ca3937c0c2c9c5d491c54959a5b3dd3679b4e4bf56a4c74bdb300c2cfa714afa0d0b77d9bbdb2605f27023c560e6cae141f5f0156800b9af355486248822a79d20178063355ef54d7108f9d29d620ec2f489c1335506a692ce39997176bab601dc36da2b8add2f31d19a6b9e541eb3b9ffb535ba0ef4f2835fb3c50af5cf9529b0b49b1071cfb5c812bea92de9ca57431f19b57d5901256a1b4d98c8468cc681160585abcb34161f611de5a9588e85cd67d720c4d007f5dcd1bd86e679450670eaae289cb15d67c206aefabf2cca7c896022985f0bda570710ec315a0727616543efa5e1ed0e51248a31ff4ab7339125eee8fe50e27d462999fd61fd496f62d426e2abe8e514e72b8cda8bda630eb7aa0dcd87c8e6b6e981e1e35742e0b50c210a3a07b47ddfba4fd029eb3e4fefa9a9c290d3397bca75739484008abb49d1fa81bf391d1366cbb90ca13767ebc0733a46273aba137baefee365fca0113bb245ad74a24300e1635c53049cd0ffcbc8c4e7e2d111a4ce7ca5e8f45ad4d39bfc49e9c8ce47f9c94a17cbf91fef05fcd1294c46a08e7f30f7cf3361c249ba860d340bc4a8ccaae8e5d43f58232ca96c37c4857ecbda6e81fded56f60d4cb8bfc74d9d89cef352464b398bd36601d815551b076dd4ee9b3729b89f1046fd196229392cfbd9a5dbf4d20aec436933891f07148317ec891da03a9e0e1ad5f80b87866ca4d6034beb0128eea6b8e6b32cab33d56ea68f2a17ea51b2213caf6e17b20e16f805870ba9baa79f0ac80a19b96f928a6ca2466e4ac55b9130114bf7d06f13d25765d44a8aa6c4e44bcaa11501345265be64c031e3fc50e935faedba651ee74cd556d7689c91707530386f0b583ea25eb027ba15a5d32e8cd07e14f2bc2d544b0310b8c1323d40c27d33747b20121e0aa100f0eca5d1763dd236ec5da28a260f0ac6cf8aaffbcfe612ffc72cf957c776ddf1ef921e839f49bd091ba950704b2d44cd9a315dc8eab10a1f6f610c3df210f4e78ddacc3d4be5043aaa9030d4f5abb96e80311910b67d6619b236cf0f0d5b2105ef69b5ec103eed1d5713f66402926128e0a8371081b80e20c7f13d37c537fe27524a8f7bcda7743364b86ea1101ede566499c3b7c24a9a0f619301948d1b83e6ce629133d322d42413f2e685aa5386061ed81ea785b28c27b9115f7a32694b9224d6acab0d578fd439c921f278264fbb5a4eaf05bc9742ab70561c720e68c59666e544ad64413185bf15e42786f53d5edf7df9ed58fcd6aaf02f9971a081957ddb6696b635f4f38ab648551d0b1e181acaddd956bd7a5421c31084b8bb8ff711f54724397d43ecb5f726e0d39df540891c8ec4b0e444393be099d736bea31957bae57fe63d6f11829d0a823d471eda5f1f9015f83dce83d5a3efb38134ffe4624a1f20be892c0578c824c0ea3f77a5b3028758b5a6edb928d8dd620530508eba9af6263f0a0e7fe18f546d9733609d32f4c57066517610748fee922823b13acbea65d510e52b14f53be6cb7e8da4585a15adc5d0ed2cc876271e6fa7978e8fee819c8937b70f9ac1954dcbb1fc0017de0b2a412c5b9db1ffdce46756bef27a82c6c3972ae9538074ad3ef6ec00441e732f105f36c6aa11fc524b87722f16f3224bc45d14d27ad7cf316f7cce3ac8508458feae0328b685c74c6afc8a07bb7d5c219b3e80cb9b5bfe4fd37b4f06559955691aa9cc4f06b5759d2a588cdd6da0840dcaeee2042c3cc01910b95e835f71c9d4014690d2ceefba5d0e4e18bd877383960138fa6fb2f7ba6afa378aae130e08c2f8df1764e337b716ebe315fc682d1bce0234f2613fd0420f58c2d463fa5e8947ff440d41782d5ef9bac370955c9320533fc6b1e964ebcdd1fffa6984e4b1a201539cfbb93884bfdc422e6fb701155eacdc78dc6875669b99e3156bc837fd1d08eed9d48a9f32ee5b87e7e8d0cb4ed254fd64e35eafa6ad8528e9465438369736dd2cc0ad24ad2d07cac7211a01dc9b32b9e66451ce374c983836e27ca55f7bd5cbdf0fa68a372a45891a76d8c08062db553833d1b47f5ed69f22c6ef3c80901c2b8de13208f13fbae06bf1ad67dc3107bbdfc5327bdfec3850df153a6a29ff93f9f769fd74b5d4e91c0e238433d354843d45d3319d283352b7c2a4c23611e2e02cc738d2cd3c5de4a09c3751de13330ac8eb0b62ce28cacda3b75cf8bb04033727ed919383f84173b9db46b483a5cbce6e2c2b5aa814dad95bb5c6665944b7b0bc025b454b12f34b6c5f9891ad040d147fc6094dbab0d04faa71583a023c12712eb0d7bf4bec2c52a9585c0f167107662a8122f9932a1dcce10c03c3eaad3e79fbf734ccde232d99c99ab06fa246cc03ca549bbdd80eae6514dae55587f321d9da68811067509193879f9bfa2bd589c9b43eea8e649fbcff78cffbddbc927e1c31d2ec93e6996aa45070ab57015853528c874c49db17356fab4930927d2e79a8df5d2a1efeca7ca56e1ea63592ba724032dc7fc2e15d070414f44f484c2a7735064ee6db8f9652dc4921ceb0255bd84101f55ff460daa30d346c9c8ad9b479f8dd9233338d743012edde6c8cea521ceaaca3c9b394f65aa29372b836381e72e4354bdacc7caea1dc8d40a1d449362a49d8963a3ffcf715a0aeb294926c526c0e2e010b972b7019cf6933e30637a30e5613895ab99535ec7c14b93b29a744f215a804a4c16c92850bb9bc5666db23a2266f5d9cf586c81effafcadebb7e076d85084ae63ba5fa2b8b8cc22a2fa85bcb8954478bff2c5ecf585bb38b49bce661ee93dd5eb135b076280bf553334d299a68bccb250c32683ed466bae3ccb10a36432ad6aa92f48f96b16924a66770f8b7c78a6043e532c4262cad32075fa99cdaca251effc43a100979e5bfcec326cba42352ca16361e1c6c3512c7d6a084043d16395b57334acae7d64d7216ed20972a1b1b8ba3207fb765ad19b1eb4b883a54dfcf9a32ea2c43afe6420feb61b7edcaa82a199ea136cab363bb16a73534674393998e44b8cc8d1e1152e2df58b24f8e341d67a2aa44d4595f4ce3bef5203d630f0e9d57522ab0bd9ae34b2b6ae0b2f84d39d489d2f053608a087a1bbf8766a7f279c1ac3152d3533f01ecd278385f36a5ce9a41b1b1ecc65b2e3d02853e115ca4150ce7a0c07fd65bfe7bea9283dc38b06ff1e57b1f2697b1233a6ddc7f9a95875cf36c37b58f0008169347dcbbffe90691766c34a26e14637286035447db88fd86f6fc250d2eaa2215e564dd861a7ad04a0eef2e0630eea82d8d2ce8120b76e24cdd20cb7918ba7f122e8d5105e47f4857f447e9b3348ab62d07aba7b62a0856898fe05a4a722f217df52dbe5796515fbcefbb48ab5f2d90d42efb4e845bdb994cd92e2658491508c4c2d7d051aa27f9c7e9913916021e347065e17cf4a4420203a0981bd274fd705f58834bfd164bde0c2d72f4db41d309ae40ad45f49384411ae03cffc0a0175d4db7e645c092970337a1d7b603f8bfcb783cfcae6b89faa2872cf745d62aca0e8cf40b95625a8cba7a80b7d78275c40de361ca4bed5633b6b1db9aec3d63a232573ecf18da5dac5ca678baa9b64f9c43d1ceb63","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
