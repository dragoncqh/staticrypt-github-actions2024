<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be9143672a67752fbc9d1bd9ae9b8b35fe6c4f2b3b2eb5cdb5a6c1fa5d159db6fa7ef25a29e6b97ed8b4ecfe9370011f7a0bce1dd17ea1205df3ee1868c5602a663e1d972e6f94e32c9ca93471b0b402d347bbfa0366fc2535487eb10621ec690070d38e4e4e2abcbcc366a51de9c66a047af6368de748ef817884db4c2841a8edb7086ad9f6be3ab1ffefd9e6063d7725ff996c8e27c97578937bafcff10a0ae1b93427b7c658425c9fd6977047e9e01dbc45d6ee0947fe5400546424b6324de0138e299b8839d4a58dd41aeaf6f0b830b06a73ea68e91a20eb9bc31bd7e1afd198a4bba4f5be98c517fca2161cd03c4a93d163589f6f2806fd3234f2f47136df83b83ec8b1fa58d14ec5fadee296bed259112220e69c1996e2d5a4f5ba6e230403cca90619fab2a8f644914e702629718bf555f5ba7aa2bf6576d59de611813d01d4a3be9e5f9cacca6100aeb8b6e86e50c0cf05b15da1750ef83d3ac17740fece7e7419f179ecada71c0e110e529b665002cd21507e454f67d758e5ad7fe7b09ad74f94bb783eb02d8394f0114f7ee12faf47771b02fabffbf961d86e4d97eec53c9c625033a5bc5972e270278f82a09c6c92ce6f7f15ba10befe603d7da53b446618445c838b30bcd6266ee10da888d8fb35d9e6c0ae1a5ee067096dee3fed46a4e0f380bd57312b5461d3ca64afc472ef3d1642effe9ea74314be15bf90f917bd8e4e613edb308c391c2239e1bd87709ccbf223251568947e084fa4217469ea706112164470880086011551be8705e6af20d117f2bc5d6a6213dbc4cab467cd47628e9f66f1a73e2a1f9b9c0321ed7cc34d37ce39c8657b095fa527c5a0dd78ab4acfe567e1360f6331bebfbf12baaf8449262d673448149a5bcfcc084a059b9625d01295a36832bac3eabd2859a33b97b88d577ca4249b31fa5f2a1580d5c09f267e9c6560ddae0fe69623d458ec1a80be03af96923ce4855b9377088d72aa3cd2dfe042ef2ba1b003bc1ccf36c83721a4327602067de0b2537479706be61b73ae9fe689789f0b727c60aa0d9957f17d8ef0bc7a41abf2d4bd1bba8d37a681d3c95a3be072448bae64b84fd130f75f5cfc557e138b2e8aead410e79743379b0a3b3bf725b130e35ddec617583d6e7885e3a4722b16d9c10d260d4396cfc13a841cff774134e9abbf3eb91365f18f03372dac4d8c9a7060867894ee42814458ed67efb1969f83cea9f780f1c808641fd57d73265ffd60c1835802193e1edd0eb5ce91e9912daeab88360ba5c23436e165f511855a3bd7b5d182b013a10a125c91ce6284f8c2bbccf30202f7f54de71b6e5a552a83058004c4b9919b363d0ce3a34bd0d3a69047a1a1714de2d011e9a41f153ffe892e450c41c25f92db62b0d5280f72355c4ac16170d8ed25abbac44c4e092e2ac3bbf9164cc51ab3a556151f267275fa0ea338a401f87dad401003a19ddd50cd9f71a65ec297bfaebe0dc72c654bf6df4d6c130afa7cd6b7d97f8f018883d432ee44f551c9ef6b72f13f53bd198e5d54b53290e4378c21ea7fb58980cedcfc92ddb1248d14e571d8343e7818f51ad9109120745de15963b5838181a746105359f0d071f57bbdbcb991ee9cc82c707666451067dd8c5e2acd14955586df1cabe98fa1aac56cf7f940168584ce1521e056a0ea2f9b6eea3e8d3c61ac7975eaee0fcb7315cd52fe02cd3a808a069597be9830827acc6ac0fea6b7b392817bce9f83155ff674d5143f66dede925ce8037a80a7b13ef8ffc44aec29358e84688e679b0a410ca2b66471c4b9746cced1624b448db4dfd60b596c5b20e1bdc290ac67bd2c38dd7943fc37c81d1f937014d35612778e65f607ef77f7694fdeed51b487fb6d60e29d076d39406b97d42597fd40ab801845e467b5de57dc724767d095dfc32429f919314fc43f5369fe85bf690254447d090a0ee39560c028d0eec7adf97fff5d4006f22876a469d2dd28b71bfeb49b1cfe270ab0de764f2a05b9326b9629c807526d45ea1c405ef29ae15485faacedc2012a207b0c9a0ee01eef4f2dbe38879318a4f7cec79fbd31c0293ee95803de39e0a31a8d20c97d1db73ca410995c4015825ff4ad8bf25d78161e3776e0cb7233d1ec63fb673f04f278496c802308e473f64c09b2cde34c5c34ccad42938dcaac99df330702f7429368de2473541e55a90367dd811a19714449782b18f22229d5bdfb369392b60640bc3902db260a53a1624bfe11ec55e501c2d0651254fc1b1550853e8e47de5ffe2445821ea1ce59c49cf77c0a39f60f3466584f9fb3a0b58f7e72797e6be77ff026d72b61b7dc6555890ae26bab4c7bd9b1d394667127cb8b9322a2a1065969daba5d39a2f7e63df8c3e69c137c01dea87a041e35af763505fecf9bbaaffe5c675933012b95065dee4d72941fd1e9b277a0aca956643e99163e67b95bfc4f2b5cab6fc77c8259f73b00f5c813dea490fa74cd1ca05179c24789a661117123dc64ba766aa313e6fb2719255670c0fee651cd8929be1405477d4669dc032ff18b4838ef1969f624441ac31905ec50cec8ed4c92da1b6e9ca076b574f6d0e0581b6151aa51ebeccf8394ae614583181db3dbd9bd3ba62a2d0de5a1496f2b78ed3980cb009d767007966a6588fa93857cb251de47896a473c0416ff25b476a797aae58f49201012ffbd47d2945925905415d69a1b3aa295a50834bd35f1b10c13991f022fcf1bdee0438dacdee4718b3da03c559c01d404c6149c75cdf4664551ca46eda8a04735cfaacde8271f742c0aba97a2b91a5116dfa7f7d259d38795522671481e535340f1315fa570fc552924286193897b34fe141d718c19d050849c7fddf888c8268bed15e3cfa020eb9dac4a33588fff84e8192d1079e2301f1b16a2703729a2511cf4f9399e9371b17155aaf2f9829c6cb3c7d4336e1c9bc789943ff31e063797bcbaec8476c0f7187415da16625dbc72dbea75d6bc2a5646b72f678fa03a97b6a06a745b6bd1fb312431ad9fd03284636b0787836b2f97775785e5ba943c2fcae58243cd693e50a829b16b0ee4ab2ea7628a303cd3bcb99024fb0bfc660629de13b03d602b2dfed82891482df3ea785906daa0dad9611f3dc1ce64bf4bb39d3b17203436a457ac222c3abf790289bdf0cb98daa53ac2e7ca9e678cf5bf2c181b72e7b75d718cae61be8713abaca360aa5a53032cae17a31bc7db0909a6a7afb97a258c46b38efcc5e1b8f125349e7df1ad7875cb84ed52948a1e73598e6c1764c6815dff693458ecb30a3e4a0824103ccff900a08f688984eabc60837a74ce7d7dc49ea0c29d131b0258366370aa3a06163240061b8f2d5cba9daa8112c7e6d01361c03fccbc943c24de58ae1355b3cbebad428f715e97610e26de38e9bf2af3ab4aff677b4e3c6b90145b8fab3ef2e5c09a1ce5d2dbf343bd1e5f07980e5b27c34108ac2a84eee6f25eff9715620e7b38e6aabf01ffd284cd645b89e1cebd237e65e372bbb8095b85cbeeaf798630ee460f94a77a3ad8e6c4e5df19380e3cd88b215dc299d83348b6865a35c93750b227ed9f526804f77bee9bb66eea96fabbf92d5ef627ab83c17d8494d0e766a2e5238fcb2a369e9765540bb6660f709721e0c9ab06307ce91a5d25af19bb4790c6376edea8638800e901cb03bce92c863a71f03a3e3c1128fbab4f8fceb364c42641a510c1babad5a97d6eb590267c5c0adc9b6e692b1015d6f219dadeba0972ad55c5a8cc1d84059f63b4c69081e56d582fa7851e166a90c076c09f199c93574c37ad8dcb62a2b42b48c7fdaa48cc5fe25b6b423a8fe794448c473aedf3cf3d9a40df65643698dc5837ab302687e014f10bad7476aad292e47f4f50189b805a53da6db6f0af45c10bbaf54ac7c8ee268e5d8af060e45b20755b697944866f7b86e1f3e290cbde703bde43b392f4f7e3b1f93d176648c25a9fdb318c6a986e14b299650581e373ae00a3a594defa656fd826ec023102d07a90358b235a2c645ad102baf5159af5d7276e605c7ab19949e768479b06ce0d6abe0b5f8a49730b5a0cfb67670df73ec16761263a6c2f4cb8f0c74587be14497f94287f73b67cb7087bdfda8d59a8c1819461be0bbf3a3e3eeb6fb0cfde53e755d9fd49d5d0ecccd0a2f4b94ed8cfe23fa543ea0f6f9846c70adaf831b8a9589dd12ebcd7f773f932a1990a96958b6999fbd26462bf59414d098ccbb044f623f28dd3b2c4216f752c5d7033be078e7f6b641b25ee0170b7387bab6d58644527953550bf00ece9705639e57b76bcf847e1d504694f59a9e1a903ec7ee35db74a1ae8b23808b6a639fa765c513d789bf3d9dbfd3fd57e86a4dba61423bc0d04e2a5ea286a26eb5498520e9586072a18b5914177297b3f132d07bb904855a648814468d2c2da808a9885c5065dcb7b35c393e3975b9d1a1b64b788afbd6a74dc1df713d6677f23b1cde196c888a32dbbe496997e864c4322a50cc80fbe8d41c2de09b0f100eeb598d12825a423b33b758122ff8666f03ef2193ad4868211bb731c7ea975da5b0a48af116d9e43e9ccc9e452e1eaf917fcec60382e16bbc168650e34e476836463fdee96ce31454b04e648a17bf001c18aef758115e780903d91c70440248897ab4477dc5bfa9551036078fc4d02a1704de4647646068f7f55264a797341ada407a3b1a8fb9632b28073c9787147f4bac0cad6f9078cd6e1dc05af57bd070b6b7d674447e6c08dd68432faed9532a3b1de390f3ea920c14cb2f62efd24ed4698643dc0bd8c77b27f5ff0dd28821f2bab4728c443785e3614f25277f5706c117a5070614b8384b4dc7fbbdaf0389f51ff544e4a64ab488515f76f2c73d485c2ec8a7e47829bc931a955ca0aad3095528f671cf9d427eafed040108e2f524a83140b15b671a7b665feaf44bd2caa081b6abc25562236ea4f793ec969ff38585ef277dd52a5a7cd1565fc091fd472fc7cc561da195416913625a0b4795c53a7cfc900d6ba1e4121e7edc7ee2470536850baaaf8517008f57c9450f982a552281995f17df89699acc830db9d6cb6dd410dc373b193269e974e6ad41d76ebf4f25e31697c04d9a8124b71a86f04e41281b4ee41fc63d3acc13e1c1d70b8f4a3cdfa4ee937936c6463b284e3419e5f32cc575a4472274eab9941ff3b193adb916d82f0240e240b7430d820097fba67600f63843a44abe444893995a97b0a85ddace307af8af09802991eec741b3181398a4c7dc95afe52415d830ba04e6938bd8eeb3c97b8eb8e974f9751ba9428bc9bf4261a6989d3514ebb7e0687fb62dd5d6cd456fc8362e1cfb92adb371fab6db64449f5c825935ed6b5c872387a816d907939b603d620d663ac858f1a0d0ba59a2d69dccc7814add8d7c8c1b4c147fed4982d808193d62a18eb41c72682445e8d503dadb2406825f4ead1bc57949951647843e9af30b7a0a65b1acfaf8a8fa75da298a84761bb6fc68e59a277570ebd1c45ba6b9dbe9d697597ccd23dab9c82997d3d551860d7ffd6180151a8ac03eb325d9ed5d1cbc424c73756e932d48c42222ce499a29b85c5e29b478705963f943003233112e1c68bb67433db74f65d3ce807a5543c2f95322519c2c8659a54b777927127f9adb8a317ed22b74e2c092cc8d34dcedaf9c097f1f88bffc904d131e84f43705cf3401fedcb6814c3a8e72a286a71b98dfcecd4fa10e01b29817ebc29b14b73b520f6aa9b0597cc431461aa3e19fabad2ed5f85aac4eacfb409ac6d84b73b2fff5884bd3bd2656284d9d7223bdd380250b8392603fae084df6973695cd1c130c1e7c3137a00f557f960fc786a930baa40bf53264c8440e7c68e8c5aeb9ed36497e537882e15d9c7515a1a3298351874d06e9c72aa5df041c08fd3685d7cedecb3104c9aa67d219bb818f753679d478d516df0502c99ada292fda5b01b5600b99c17068a7d2535f609053eb7f598154a29046d449315c36698e416178074f01a30c095782371ecad5479507ff39ba6e47b9cccee9b3f6530c34dfa1f82a29b0fcc4a1d17abc2b81f1789ce6cc783b75bffc42c40e8111b39327564a866071dfad059bb8ee5527bd6ef9bbd37665559a0152326909f2a2ee2a106bd29051a6569d222a290028893cf0c1998aed39103f26319ef7b2b7bbc0a231a2f8e4fb05e54e542cd4ae82a7002d346c19f9602ed81aee89b63fde9139f83604ccd19759ee39272d3f46a3b5115873c800e70a98f3eed5159ceceba439b114c70666fcf55a35209469675f1fdc538b946382ffe96e4d4cd45b4e189eed377162981e972d87924d3118819befea172f29effd4a82ddda3a72c932a5093bed499f5f22065ca732f94164de3a8a380e58e9f501cc004fc0b15432e1c83087ac7c16c47084d2bfb92ba3a3f57b799c463989b229886b2e3ed8f4180ac803ba5dcc2c3864b706640fff9e619048c8ae46bd34662e80bf199e6309e9239d5b48635507cfc3cf7ed8a9f34750a33c003079cdfc9703ae82cb561bd2cdf42ac0a2f33c64a0940e8cd20f595d6628d8ee2c319e95e5cf4fed8f9b29769f6b73f5c9ca4458a00a49b7a8d20d0a0ed5cd0d70b60d571fd1d0d403763e74b0123bd3254bff3fe7f9fe1ff2bb619c9fce1c6c473e9d2323532910b97ee96b65698e69918069c96af3d02649c482cfbf1c1ebe27a0c53ef1f8995f243918db115b0c806c797d227004b87353c808293b37cdd5de0efa53659f4f005e38442496c9d18bae1312f342330c26e983d1586db28b3d39bb3f58a074365aa923829cc7adddfcd957114f93dfcc6aa7bcdadd7576f2d76460d018b884f9d4ee3e153235d7f7c7e966e09a3fb0c8be2724691cd7dee5657b6b8f11f21dcfa32dcb28c0c85009471f8927c45b7c67ce1d410cdfb65b41759e58598c49e373df9d350f8cae084ea359c4afcdfa129fd6269fc25691fbad647487fff16d5289f59cb7e9c2787791bd3c76444b61a5a8158b765007007d854183e4ddf0cd26c42bf1983cc3994890d4d893086e97d7cb61dd5102cd8d537fdf5bfec96637b0c4b5343941eca2ca3cbba384d87539eed082059c2488d43a3855de0a8bde303ab0537254384447aa14f5114cbb78e27618676f6e84696f201f086d58fe6bfa1f059b278328bc06c5d56b0467147ea9e91dafefd48e14f8cf8aca126aa32a9d0b54fdedc9cee397fae47fbb44804332f09c9860480c3a8ecaf855d4ca317ef11c2c797373fbe4c2566772f9f116b6a3b53ac46168e5e01efd9ad3931eb8a741e35778abd189c0f8e996e284331f9f27628597bef4795547ea76702208e38d11f0ac30e0b7cc0e0c47c223d62803f9f609998fcaf08d5dc1698afbc041255380c52dca69b9e96dd9401db5e24256cb81a41fa145fc4624f7c1f2e1a69f05a725ecfd105fd1e2b9c81dbd94cdbbaad6f3dd975ac116b9cd23479ca23acade7eede7a2455d85874f9dc95fc884286f49df9dd6141a33060d6b02a15b4c8c824aeada1a307cd7bbc2ceba6720859886618a09ac516eaba159c94a651e6138d378bdde7431a9f0947261470be83a0aaf32bd72afa07a825624ffe44ab00e14c46ae2f6969f163c354dc18aab62c5259090abb9cc31cd2d5ec676db68c4fdf02c00fb6a7ab086b6295dadc0302493e1915b4b72f2fb33133c630e6990e2fdf940d8cef8fbff595357498cabac0dc9fa8d35b96bc051f5d227661d4c44aed1d6691d2f4585eda942ea987671f0412332565b841cea3bd247db99f6aa78721ff6a715b2ac4717a4387ad46ac3203c005a31b45cbeacd745de663aac82f321a351364cc5aaaef698b84ced5f962317d98143e60c81e24630b8d1d1b9e517af7bbf27e50f8b45edd700633dbb956e8c0c5c697dd6e0e28803aa0fdc75b98f08ecee80b06ec29c259c9398fc3222cf62d8681f59b45d6713a7c7ddc49f29fe4c056917f6b671932e80287feff3647020339db6c704083227a2feae172a95731e508da061a72cdb1085d4aad57e64901deb55713b66c6db3e46a01678d2da45c7d9e73032c99368332531a756707dbdd93efa77c74a0822f6f3f4893517c76d5a972d10de3b20a4fab446f88428e2bdfa370bbe5bc3287ad8e23352c28dfaaeb7f64507475222d661202f957023a0a31816f775497e216424b11909369b66aa43989fc0a596c45ff27c45c92b1a43c0357c67aa6039cfeb61cf930f34cf6fc20453af3588fb2e55a291ec57e849185cbf70ba71065a8c2149ef8c24a0a7e0a6c2d43b6e03235db52ee0cd8b95a1a4d3d8ec31d6c940878f8587df75b61c394e26857fb4a7bfb004d683d700e0675a7284efb11ada482da670a933731684d5cf0fe91f9e76d21e03405dc9a4da312a99d2db2726cc2b0474a62f8f0f279b47ecc3dfb046391028b97f0d2f00202291ec8b79a54cd250e1df7ac7d6a4965f0caa971034ae6f8f67b4c930e6497648eac1fe818d96919a7bfdec364490fce04023e70a679634e81b102fc7462c06df6dfbc1c4e1039bf6eb542f095cc0b461ea654f6ed26378b5c84c92809707ee63647ea73c1b303b80d959f154b6bf9233ffbb30ae20f84a447273dc57ac31a209cb23348605bab8963388bcfa8d7b13f5cf6ed6d1b0f0c0ca74b804e236da15c0dde09b96dd0c97110eb2c75d419ee12652e047b9f26b765d1c65781c1145e60779582e0d0e42312c097afbfd74178319893cba0e52ea61f7eea3d72644efda0ea1c86e5236516c079be8703d9b63cd0f1ea1a2476c1253b0cbbbfe27dbe2e2b1f7ae02a3b504b6cf1c686240bf669da7e22ddf9dd63e09d62a5ceaa69ccec1cf60cbee61040c7228d8a240e1167aef744014f6ff1246402f1eb37b280e561a34c667f9439415672c7f6a1dce8bd4fa937e881543b5655b2919a9c653b20db91d69141532fa4a758d88065f39696888a29cbced7d03cfff69e6b4a01c617ca0c9eea30e206e0db9af0bf30aecb0982ce9513598a1b53b8cd3aa796cc17e789ad96dabe0801dc5da769060cf899fa6c686cfacd134f03f61858c3e260f95675339c719d48f2ab2c8941717212286585a6b12a44d0df65cc104d3ae732a462ebe3ec478923a9da813a9bd8aa84b49fd89d752f4b60294d6f9fc322d2ff24d2212d7e1e7dbe9ec2c4f96cb8828fc19a6b63e377ed2cb3b555e5909138560b9df9cf85d503299ba04b8af3aa8ea55c2fefc3ce2fc4254a8ea51cdce2bec8af1f90f4f61e0884d6275a0f8e8accaef215316dce12c49f56fa7f8a92e7c592ec488ee301ee0821b160900c607ba4605d2d01e1168a8c85032a9e5950a9222d70c6ac643db00040be0b918a74ba7abd57f313aefccb4f70174d7030d8aed08fa961a18194a207e57b496654d05276a437042ac39cc9c355dadac30e09fe972313b914a687c928b9f7851a69c97fe5f1ef1f275eccd795079ee7dcad30b3ccc307d15dbc78ba396dcf9d20bca48ad120d2dcf40844ce9ed719bf1b144c5bed4afca73dab2d7ac37c446400933db5cfe0aee3f9e4652c38115856698ef90733fe672039ce41e173b905dd68f98cef8e7325e36e52022a892d18cb76a7efa93e051c04d43ac933bd22e3bd96ce0a3c68f1d9cec2f3adfbb7654480647f1fdd55c77a3698d7bdf8bab3022d59cbd3afa9bb22582c53b45ba7fbe1977c23d82978d3e203da43045b74541527524c4bdb2e86c545d28678e3eb01e0323dc73360e063f7ed69e507885ff4a8088965711cc41884d7d174c9b8352031e4a561777a715e767589aed3f141456ddc454e516cd131e64c676ccb18cd1bd1bb1b42c78c09cfba96c6644250220ff9f33a704c2e6b998c892e225651786d006e8c4575ee74c2fec9cd978fd60b1c08910fa308457b8251514feaa8a13a36bdbd00399e11b69597c9cbd2b7d945f48dbded8b630cf6f2a0c7f3cdc1f01101bde5474dd99139f5b9173490e1e76a5a21c9ead409a44177062237e98f0bc39f778d74628dd68369385e646c39cce125d3372c8f030ab41d2a35f15d8c1c46b64fbe10b6f2b6614925adeb1b780aaf77f3eb34113fb0cf98e13820fd9bb93355e69eabd6bf8217bcbd563f76e2ecd07b69d50e008c55dd3a494f517b688ffe0df154a5ccb27099f37e3d090371a96d98c1c46fde6f0c12d63f13281cad07c7131016be818eb521923e552a54bcc63a663a4ea65f149bc9cbd80da3ae21391dfd5ce30ff0bd2ab7f69c2acffdc7b4cb163203af14a55fc66b781c96b17bdcea42df1f986bd898b1db0d09e6ded805e6834f35051f115394e64976f07c7683eeaadeab205bd4855eb32ae4b027d1a014f869cfc868171f580402522ee9d6196591d6a262047c22e039741495801690880004a0cabd80bd835f8ff524dbddc6a5af9b44899e8aedf1023df043319c3ac1b3bb0e2a16ab08e2ca5039842d2e737c629a877b5735634932a57d62ec16eef685a3600c2aecb532303081bea748113a11b9245b9f2d7a1cab24a08c14ab98088354c9e5e0e6bb6034ee5d02893fd68bb41a0b64f343b4d13dc364c3ece0d6cf8faecbe6dbc6b0bfcd0d8d08a62d88f6c375ec2b37e0f32322e1bd9eef4e7c5179784b632a7da270e23bed5ed72a9a9e91cb27f082ffc245f17b1a7447fc55fb9368fa66074b207c5b95ba46881d24ab28f03fff98cf6c7f0bfed697897ab2e8f2ceb075f7cd3f87a72219de5fb949cb23e90df561eb0c3d0a06448b4e0ba9fac353952966864ed76a98d5a68c59f2ac08e4cf6a72679c791d7fea49236d9178505d35b71c9cf291e679c36d843038708753d519104380b9b85be44a48b31f67addd546046eaf7496e649ffba475b72fe88da69051e122b6b378f6ba12d7643c2839ce48ba49e3ac57e45ac729fcf0fe673e1d172187e2959657aa284341b296a481d1f9fced13fd6d3a8f552e1626e05fd219fad67c3ce9cd8d2ac4c229101d52d0ad342b2a7327221b187606ede25abca0b011d1b806f4720ada1fdca169b0e65845bf46e317e04a486914fd33382ed90ad6ab367ca04d2fe7ca1b70a5c14be8eddff4f488823071a5ad26b4110055509a7d61d9ed7d39e63c5465bd7c9f6aefcaedd440937570574977975bc42ea172172605a23293ac25db66634577bdffb0298034867ba3b9e5b007195a7389eaa5a40337ff7411a33491961f2919d708c377299abe775bb9e3a80e2298ed81ff465f69c881233cde6e600b9f3c7038b45eeeba9624ced06cc22865555dd5d650f826a775ca04632ecb4338998c28298b88338991bf124d8c47288521875ceb0bdbcb0801711dcb61e81d6260eb62dd10bc5384e0d3d61b4b0fe2b1f7c84cbe8fe202af34d65e2a10e3a4178c9cc199f67402a9e5742353c4e166c22a2dfc169e641dd1ce0d89330cd0d1fbc0b7d8fc32ede46731a569b62de24212d7e9a5612ef644613eb7944d04413899b4f33dfa72ea5484fb82cc841a3e9fa244f3d50e895fc7bc05c6227b712903bf4e5369368c51b70d219b2f7717e70a46814514fddf06f1602816bad94860a113704d5ae10f1e445fc07f763070cc1c13b886461a4fa842b06552b87fd2c491317dafab1c46bc25f3fc8416a8cbd2b6746708b5222c75c0c90ebf1a4bda2a89cf21ab8b5aa1ef79f647551333dba57ac6c59fddeacd45c0d6bd9143d4af75e624a7cc40152fef24267b1bdf9c2c19084a8bf1e23539d6263aaf3990d3f8a39228afb3e42ae0efcae35d15a2064a80322412804d4e6326d06c67a42bd0f4b5c77f567a87c8aaaeebd677749d45838d3fb8cf54420965132034a1678a23283ea0764b52c524308ca115b9812f88d68eeba769dffeee7a441e6c5604283e56a62208cec915c98fddfd2c7e5cc34e82d3d2c54355eed37a62c42b79593df9d350a5836ccb211f8cf7e9710a36f2efb69423a18270dc7aa1421429789b66abc3e427472fbbdb04227ce9c5b2251757dd9873e9914b8330c08c151a0433ed17a94af157e99df455a651c40c01592bcfb3043175d99d7f9023a493bda4d8b2fff5944fcbd1a90b6ea65569787aa4205001706434acc9a086e31795c175fd1d0e6afaeb59c66b9787c21e74b91ab2d607080c08f0aaacca499b1647713ea5bdc00829fbc9b9472e72926729b790eac57f8657c58069ae69f48f10b8b856af1c540c06cd23555e53a313debdf94afc8eab97231721e8f7f5a8a729eb4fcca3fdfc034cfaf63969f55b0bd624c4e2adf92e7519eaa4ffd087004377fb5ed2741f02ab226e7f366b450a19c8785f5fc6258c504365910f2327d13d61c4f4314f0ac17fe0f02dc67f13dee08a8103e4801b88de9bca4b707a1fea0533d3fbff1b5747bdf00166335701ff83a27942202a0bf9cfc2ca66774b018d709008c4564c5951fce0d955bcd455a38be78571ddf410b6bafc27132dcd7979eb988a950be1ad8c937463135dbf9cadac10d21bdf0e7e2747281d5a7f515c25f2d361aecd2f66c39cdbc22e9f39e4182629f6f7c2b2140eb67c717721c25259a3f8bae5de01076ac55184035256bee2e5dcef54c7c18acca6b804cf6ca18aed5c0e6162c742dd3cadd15e506ded2d4212247d61c536840fcc0912d5a3749d5a1aab093047aba257509b47f589931dc60ea6cd31f88dde56031cff82ccaf99cc2bbc4724109213341f37080b4e3538d0815756cac2dbb3ccd2411de6d827e2c945ff74433a3bff3d1d8ed7a0cf6440e873750ed61b6c5cf2048e3021054b40ec0fb140fa6395e0ed552be4c34b63cf8edea82a638e3ec1753c0cfe2e308934c48c35f527eb6b539c22c0f1f69addc89c00dfcb9fde9289c81ad3439a2737196b677f4610430e4b979edba43f3f89d05570a0df4a9de726f81bc68c1b56092c5d1042c09055a9bef6a68178597194f9e4061cb6785aa6792a9468044d0985c58933e2d0a03cddba0f93c6b30df1d27e418bb6b474526dcd2d0226e2e45a0f61a3a3a1b7df4a00cb1bff31c77e6da44c5bb683b1855ecb739b80954a174f359ebe59b87a48fb8b885a6258519b3fd5aace2fc5445546d79a2b7ccf6be4bc9274da2d436f4bebe14f1a5a50e412c64d6b0b64a490b4ca73b6c7d373685bc7477a97fe5ae6ff8bcfe04ea2d9cb7708c0d91826d77b96c028b29f419d9c86f856e6dbb6808b5ea6e12801490d9e9e3dafb8f9b65829a48aa9af19e90c32ced8d04625724b4e76061a2421bada1d9288259fa260726d066cef08ab72007cc0e2ea447ee86b5161487a5b671cec1cce8ec18d7aaa2f7f2825d9acd3b87e3b37d3ca3cd6045dff4bbbd10d355cc59c71915465df2abc2047a8b4cee05597d77446de3f123ef3a9512bfa96986ac5a0f91f73777b68fa47873d09b2762556933e19afb46ce65d39ce75934059604a7b0ab191a8207fe4d4a6148acd2fa294186d29b00d8a6883a1971c4463dfba67195df22cce98bec98dccdace45a69c3f1d994c7191753a4929be5bc47a1c9928d4d7b9e2c5653462db93224fbdf81f90122bc12ea952559d247db480748df58882d0f3eddcb4604f0a27198ef4176e8f92b5ebf2afc0f8253ec7a6fbf09b06abb0763f724ae9193933bf6e4e1e7506b42ba8d6cf5c7d6391b77bc6101b686933586720981b677f724fbe74be984e3f0df4ddb492c2078d0bc486bbea624981139c7eecb67f8e1918a7a602430028984acf70ab6e2cdc062cf9d338e08da7225744576047191ecd34959d27c5d7ac9e8b3c9f22e46cb9eda487c53cfb439342599e14571fb52ab500d17097e93750ab8766fde28c2452b12f3f09dd4223bb92c4e6d305bbbabb8b9ed9d3c45dbd463d61fa445ad7f13bdf85741d3c2ba4ceac33fa13d6c5ef9ce183024ccc020424828a4f2a9470afc28e8826eac3721b331bf9a68326928734397dc184743eb31c8c0e8c7a76ec63709edc50743ff8b9329be27ee65184e4a750ff5882f9ae1d0742de0f18f17be32c8bf059979364d3811dcfeb8362a62bf41d6805de8d8c1735d0233995296b7348145fba9d75615f0cc66a58bfe8ece6fdbc5ba082ad3874f621cf9899d057f8c394a449ee00c24e9be7f688d44848aad8ce8a9edc1f4ef3a772aab9222dadeeeb5597d5caaa9bfd1783be0d11d434154ba83ab578017891692689a2df582ebf19943b53abe4192cd9b943c54d05a22d9259a0fca7a8b30f02560b98d352e1e59be2baef90d164bdd3ecfc24999e323297d607887b35ffba21b4d9f7346e1c3d383c6674e571a7750c7c13323a3278ff6aff35d364519e2f562b6ce6e9a3a40f41047c12d5432ac936638b7dc28df36265adfea5bdbe597a37227cf0a4f90b94ce9422b96e5c320c438c5d38f844df4bede33173a9d0206c50bc6ae2c453dfe8564bd812a0f8a77b2244b9428c6b348465285dce46cada38b5e3c41772d601ad4383d41b4af60ace6d5e00fc1d1c50185b700b680b67c8dfe83b9c2b7dc703e4acf0c5d914e27bce1e5739f8429461fbbe0c6e2752c5bd88ce2b47916c4b1877eb26196540c24331984bbb37397ca17d394b1212fe2cbe5c3114d63fe1ceebfcca532d51e1eddb576100cff773d2b6f2ae8978ad837c60f322733024ae43b5f4273502f338a87208eb5be15fbee812358e2b26fa6c5c7f14f71f34858e14fc058b9009ee8bcd67ba26375d5c49ca377fb7c41194cf0d41ef65e72ce3bbad1eeb0f6f9dc1478c216f80f9ca8df8c3aa89715b8018ff426d47f28505e5c19930a39d14f63bdf6a881898f8b83d5832e07545eb5ec35fd37def2f48a9c7ca382983b1c462876cdcc668560d2c8c14eb67e699ac594099ea801026bbd7b68ad690052287f07ebb6aba2a8ff5a23655983c1411338be5cd6507874666b9dd0db89eccc793491f2c8cde70c37960e67ed185bf4c9d61d0c28f39bacfe08be4089d3642e8e0485c1626672561f5c1fa699163953edfa2752235ac2e52aee4263fd83591f576a1fb411abe3fd854f27604ca02b84c8c8fa0885f53a1384d9951f7a7d0e5b77676afef4e988dc953abebee544958ee1374def49faedb8c19df0b0fb7a1f10a08871942a439a5b635f5d2d86efed46a24491e1109dc8954a0158d401ea15c42872ea1bdfb82912c7169f480929f98dfacb8ada9fcf9ca3cfd1c36d89d7c7ceacba07692ab642000c99bbf35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
