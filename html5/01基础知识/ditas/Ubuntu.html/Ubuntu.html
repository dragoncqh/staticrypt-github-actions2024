<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af6518d9f557d7c86855603d1ceba391025857acc4e7ab482620f3f32c9bc175a6bdec9503564d8cac331c3bc71e3f7ec513238a0eadee55cd694cb4dcf7ead73fc09b529c8341c721832947b7993691093ea26706d22e711f5eaee6ff65cc306d27f7d8ddf154e685f92e4b086d148f31c2547c571d5ce368831b879b5c8af79d130ac9228be9034a8f44545a2e54c2bb39252e696cf48dc9a0ea9f249f97e5ec5601b1a9e0b2947499221ae6642a4fedb1352c53819e6e45fa6933c40749ab1e5af50247913e619b463232b5441bb394eed664a492e2b16a15eedbd2892bd82166a674960aa85237c33beed6189e3292c9a79d42fcf7a05e65981e52d7686e1217bf1018aea8f50dd3f305e55bf0b83f8587a10d3c615a054039e37ea57fbbd8b0985ddd87e32b98dbe29bc3f6939eb1d936e6e8ae659f0e885d8ae9377794c7a23475f8c963650255d956f318ee085545cbba17d580cdd2d1bac5151f95015723db0d8fa2e5ed7e1519c81295827c22668a820605b31b5bdcb7acd6cff402ea8bb5d059d3d93fc6c78fcb18926a74f1143a65374ccfef3e7bcbabd44737db77c15fe265c7b0e911dc1bf0b401d9c44ce7084fa264e13aed40e0da8a10592e28e923152848506fa994d31f2e98bc3ec5b552cc38220e93d651a761c46ac87a67a80c5c374a2eaeb70141dd04b2ce01a5bc05d19a6496bd6dde2f77c585ee7ecfe9cea54730f92db7e38aa54d746e000a36f261b6578e14b8a16de5a78ee11ab1fb073cacc34d8b0f83b2bf70b4e8aaae199502a57e37a02d83c0e25125eac2bd694d4ac72cef5dddb03a13859ebc3e2b355f24c94647ca495a83f25e291e1756a765c3682e99c77ef4b3cae02f85051ea2837b0581c4a24682fc68d806f7f787b8c0155668e53d2763d000f77d82cd4c89e40ad3a6a6ea8b039fd7b806032317fdb299ecf3fb0c5f6d94a42b8ec92240c6621344baf311deb7915f27f44624c97300f277d3e72f4f185a142b082bef47c4ce98a8823dde2350b43ba97aff43415f8516e5c93d9b2538be60a5844c0322aff147a4202dafad8c3c1a957d0037506abd36b5b7683b18d49b7cbe8df6d1903d086b45d03337511d06f38ec9c520b5ca50389dd7f03868e821ab9942103afe4974515495d24734f5e01f8e5298c4aa42233360bbca07355206f05692cd0a4935401762440ba60240654538aceccad9af6a5aa394235e2a5f0f81514dabf2593a1235b47df0c75cc052d4d5d8b57af97f7216a6572fb300c81d5f991612d694d00b92b431835a0a7580ebcf9387a9d30a610a37d857fe036225e7ac0bf971e48e60740bc4d10b47e19491b33ca4aa580f547225cb96fbba0ea64f383497d4d54bdcc504896a57d99d289548830c216eb258ecf759f123ff55927bb86d67bb4e456b1057cddcf26fd1daf4480d61329b09d8e52a3a78a90ec657d00c2931d7c258146ff66b237c1b8b5de9bf741cac3177acbc950456d9836b2fe559c73e2c436b9844e7dbbe8c58e290c8f2d0f46807457ec23d0d7b749580e054ab1c1ffd27ed671b296f176dca66c90a917a72cd014b4ce670bbba574e0094e18e8306ed092ac31c67a5f8d276fdb5172bcd151f2ead8e75d0e904b4f54237685185eb1de2ab21877c1f013f3eb7059c74a2e9ca99fd017fa81a2bc6bdd072125b5fe488e96ba4987e25288cb21960ee6d8a06d5d5b8f6ec7bf00d434e84d34be69ff305b092e5f127f5ee88911b1d96ef63cce0fc5d5e4e4a4ed35c1c0a3792248feb1437284c4448d5f2eb2797893ad573553e86a90a33fffeb60333db52ea8428c1ed34676532621549b098c791ac452a207910e71309b31291480dfc8705946c34ca64f177f420167676eccd974e228d057f42b0be980afa8b86329113bd3989fadda3bca5a7f9c69ad7e6ecc96ae5441c51eefac3c5e81b8097448f23f6f1ced9953aa484a6cbb40288999f692aff0558328890c0831832a51a6a5603132117bc57d796dd0dd7dbf40e294fadf68e5a6a7468b05c451ef23815a480cfbf3ae67121ca3c13fcd03240681a5ce51ef25f78717b83e31d45f1fcd07eb24df3ca7299c66d2c7b735540349108661b7e2e970c1e9d497668de23009a12e8c6ac3140af2e1d51d892fa0bfea57080d30a7850e6877708a30627ce45472dcb5dc1a111c956eef1c83cbcd5eebdd0c7ea3dbbbefc3488f20b8cd2f8b2a8a2f19099e866bf50c5e0358468a55da56dd75c3840981da23d372ef18cc99c88349dbae357e2c680aeabc5d9939a86138ed85dbe9c24a9777955583907f4fd70bf4c596e9938cb63b42ffb0f0eb757c00379233112d5b5b161bc72f3edf1bde14a19e20204e0e7b98242dd03e51fe4c48c9bdb8e42252bd3d0941d3d215daabab02b7889110362b06941d3594c562b8c9814c9c1db1447509549084a1c8bb01478a88c3631564d27188741692697ffbce0b662213264fa062552e60e82a3a0341e16a45ed837ab64c57acf05d50decafea7da6944544ad78ee2cbe16f00ec70d34e444a5ebd3bd03db7f8a2df10799aaa75bbd72fb82894d7abab9f272dd23da2f62524019a63c809e6f6dfb5d57f8771e95eb3484d8a2900f24aaeddb7a874b8cfb497190c80813fcff56a30e1a748120f30a3fb1a0bdb6e6e61b4b671a69c97498d8484b38cd5140d4e666a4a9686301fbb4a271ef0eb799b9faf2349a1cce51a3de7e82455e00fa4169f8cbc159a1eb7a9e9a38ea603a1d59c211e652126a6c37df2b7d4da4ddbc55ddbf10617b4704e5599ecd4693555034c992ab10eb882907f24132328829d1162c54077c60618f06bd0b8b28f70fffec78a2b2e9ddf5554df8f0bdf9fa4668fb9217f093331a5d65a2a87513da65b7a35d7710f8dab90b88a8470198a70e9ff482258698628a7e1c41ca9ee7576d200a5ce17af41297eb2dd7b91e9f5d0c5b466f0788fd311042e6569cefe3feabe94cec5d2c6408da104962bb36a0fb7cf856b6410028ccfe2c8d81cffe493704992f0a3103ce52b75fdb4bf6bd839b0fb3ae9be427c2ab9eb8a61ec8a0d151ab8c47c41f3be51a6f0a369d1e695f6ba612faaa0a06a7d8ddd051b928a0c0de741f7b0f65a75076fd00734cad8d1bb301b783ee36037bf6387c9ac3d00b028e91d364dab3823c5c0901e7af36f7f599f88f790dafc17843982ed52ce489ea6a339e6698c4b0b14ac0cad8cbe3f97671877a623fd7c37e8ebe062ef4995116fe11a7bfd9b85c309d856668f0cad3d84c26d10bd8ddd589e4476dca77c862c46fb2e23d6dccd1d2514debde2bb5abef606e512b57d05d9b38094ec33f49561272ed5c89fd115ae1602a37a1cd60e56322527769200dfbb6d3fbe23d3d4e1e5b9823a91052c175817601169a828392ffba3f9c9322fc8e703d8ccc3b7569ca275044c1f0c0c7dfe7169b8aa9662e00aedfad014857655a1ddeae0bfdd34ed2b9a76b8948c123c83a2d67acb01295813bcb7cdfe10521bf37a170c7d3502fcef1bb77d04e7b4eafae800b7c69e6bdff975a8b0db43d0921d8ba68e179157b5e649b4f00910f853dc9dcb0ab2deb316bc62b0d9828098515828a4fc25fba6b6e0025531659537466fdbe32320d83513a6a7313b62f5102c9bab6b14523a94c9f58f2856306f69dc9d56a7c27d10ec0ca59a47dcb8916660142601f63db8350026bfa2cace8bddc345d997f54f406c0ea97aebd35ce2e0cdb43c328cacc527c45f7ace50861d68fe82786a2262c37e5d95c12b77d779576d025d86aa4181d9ab9c0fcc3fce1d8f8b5341cce7edf4c30681c0c7bfdd2a5a22baccfba8f12aee2d84572367f41c75c0badcd97dab72d643b7530bf8c383072b2f6fcf08d7358edbfdb418a99b1e03a6676607d67471fe25f7a46905ff11c86128a546aeea5852d553167defa6202990c9760c3e5b0e986fc8931c6b6072681a25bde2c289189cfb934fc896ce88737daff319d1ee8770a2efb91c63034942da4143d6d268f780e8e2d16ba48b3f55e5d863a30296bb58d3608ae6ec14e82888362caaf0d2190fa93faf360090f748f643ffdc80deb40b1ead6e05970c4921bb5f3b290ff038fe9ef13709dde65bd17480973597de8e1106e3b84006a35bee1ff0dc13b78b220c587c13bac4280e445c0b7cd0fde058cedea43e23ea532ce942c7a54c290111e2f01add1139469053f48c243d3fd7d2a768e7ce6f93271e5aab20e9ae19ac04c3fab6a21d839efa5b97f78de0f05df3df0970e2294c7e0c855006c63a22ca06a0591edce074fd89f4b7fb4d08de3a894fdf65a00698651ebc8d261594191feb541d3537d92aaededb246de2aa5f827763ec3af5731b6fc3572339364d1679e8f4ff60ccb5d9977c3609fbb1b15a17763457f5503e22c859f62dd8a71dcada2108e33dd939b94c37f18368769e8e377785a60de13fb22b2bba83088f211735c6c50c89eaa9b59b76178802b3ebe999f69eb912d0d5239361ee68194738f79953a340966c9859769312656d586a84dcb411adea16e17fcf2be41e063b29a6bbec5d263972f76b656c356b8b90aa722bc888b226b211ecc48dd9b96d067c67b957b79e99a5d5a5b661651808e29d3ebe3409c92eaa08058fde553f400c4f8875536b28f6f6dd16d3eac8e9e4c42d2840ba7d1e645ea875fad609962bcf14b64d69685682111532b43133e1a9bdbbf84bd53ac00246ac33d1e281a446dc0de24dcba0ae25d8f8c0d5e9d4446e8c8aa8e1ce7a2a33aeaa7eec55247a8f64d4388a94b274016b631bd28e6c647bab16e6310ba5f67b1ab8ea9639f3f0564f7a8dbaa25bead905f7bcad45bcaf74f901c7e075b48bf0d5c9e5edafa8a608bedec3bd9aa466590abd36d55a37a034f24a92e459834fa7f04b90afe7ac751c664c454556eb12fbc9b26dab13f552185cc48ebc3b42eeb81dad74d9e49997596615fb723bb73a7d5444dc334ef9c17fb450a034ee8494fe039f5566337981651ed2dda6984f9e38409078d20eabdc59b9835017f1984c3587639ce197b469216afd52729f8e2b2920bddd1e647617bd2bd52022d53c63c9a897f1706121b9ce2ffc5f79e4e6c56c4dc6a1a8ef9b57922b1984ca1ed1fffe8e6e0b5f0db7235ec05091b328b2dca25616d26d877c2ca82e40cced8b93e77e35d011d894112b026de85ef98b71beed231796d974ca149e6620da755a91d1c4f07a6e2fa3ce3f3d01bc76908663e1fb8babe40efaea541924a5fb2249966817dfb5989ebb21624da0e97b0ff5bce710abda33df5da632a5562f8c8ad21746a2f4b871e98edb347c0c6abb1c55b79092ef9bdbb0213cded73b6c12abb3ca95f488840525cbacff16ec1ea24edc7f2d7e3c1f63801910f7936b8547bf4fd914d6f43db450264c22c3320bdcbfd9b34e572fbb34a2a0d3f72080a8119672bd7ba096bd755635ffefcfceaa3cae808b57380ccda9aa05d4919b98f3d11c35e1af17934c8c5bac6e7b6b74ae77bab1b2a4bbf9ec1fcaadcf30dfd354794c11b60be9470fca6c2f5702d86cf5772259f905e320918a973df163bb3e56744c3c758cb6fcdbc9fd3fa67ac266f402d0d1b0d8d2888ad1350e7bfbbcc762afdb4cc26401899abc6c065980d6befc273a7421bc0439324f2f8db70652a715a79fc25293977cbec3b02dcb9476743602ccf332b93e7ad0c6c51606226a8fcc1687af57282587c3e7660f727c1054ed2b13b5cfef86fc46bc3945eee37f68e168c94904dfa044ae5e7e0c69db68f280396d3bbe221d68961411264841f85ba5678143ce0ed7d4bdf1382aa836b3c598b76b39ec9322775f898d1ffd948b5addb55e0205e0061739f8f0161604cd15ca3bee01d2ea4651f2a796e159aaabc776fc2047b9ab504898e7b502a864428039e8a8c46a75d2426bca5beac4426744c8709c355ec77e444f011e8449528881d572a1bd839509dff7c128e1913e14ffbd1a154f80e34725865d17986fe92f14f5f505ecca42222b5d14be5f64dc40d7ea1419f8304e78eb54998efab70420a7613183a47534ab9ce2c4b3ec482f86696ff290f4a5eb91b27cc988cb679f9ffe18bf092c4a17c5ff1f20b962a5f8c72f9fccea404ba7bb738070a6a955af5baa50d6efe578260a92b209b250b6000728c2a93dbf52212cde5d2e2ed2e90ead953e7858eb6f8044aff23ef8418c4fcc5f558f277c60c97be487bc2f035527d1c2cc27a38a3f772c9c2a2ea5327bc67f7e9bbe8eb68ddc1c31c419b22b19cc4c903d4051a9f1d5e654c33db69197c61f97a5a39481e216aa76d8ba2276bb66ec3ca10bf112352f0ffd96de8464e634157629ee967f87582b5eb5bc0b0b260c112870d81cc3ee9d4b137262d4fe55ecc6790a11ff7474831c81378add4abfd1b467cfb6feea18e103419c5a9b454053d0d71b35435b681d0988331a15f969fec5e4defaca19563317f26a327a70fe5c2e811109c0be138880ce03105799757a4604fc883c2529b9f03c11790f81712cc58d39de2327526c7bcf96efc904075804c56339286333626cf84dfac8c9ef2d4790c8a4679aa7329cc843ae0ac74b9e317995a82b78b6054dd918014ad1be059aa6d99187b8df4aeaa1a153ba9d951d40f8d72341e049d2510dd890289ce14fe22bcf185dcd4f5a16cdee3417b68a6d1d3e996831f872235eb8db2afa2e961ce6b8d2a5988e340047ec524f7f872aaca50026c451289af687e08088cec8675fe8e8d5bcd2f2cb3f095441254fad707f5c6e18ebdd9cb17be2fa0acf46de97e1bfe02ba9458ef0cbb8f1ba4a76dcf036a688c4f42a40373b542047e1fd38e2f1ca01e0f8df8bb1c804c7e639c70ed07c56422de93995b42618749dedb3d4fe77e698cd002ea72cc9e81c1c8b5aa935ff24b88130673ab6bc7f14482b52082fb941800f0f5e1b51b90e08c73e92380fa1af68a72337e85fa60a47d2dfd4ecaf5ed6400d151a0fe0e9e7ee4dc793776b548ad4bcfda56120b4e83540adf7634e5b4a93900c69cc65054264cde36e39acefa9fe76f8086e77c12765a82a671713b0338e9189e4c9465d1ebfda767b7f0bdc62e19b0292537cd3a3913f45b04237fc0d9f9f0256a698ef7b9030c9c77c25d9e254cf0a302c9bb9f9d995d1f21350038a3870d59fbd4fbbf858af5328be39115ebe39bb7550cc71e74d36266125a96586f92a3ac96dfbfbc8130876367176d440139d4724b0b7dbb6c9c263068f965abd1d6dd2f89514475b7c7b55b7521e22af8c213988b958bde120bbc3d0efa56715f88b58a9fb65520c47ba40a29809bad3631c92e0fb151ba909b16ae4b04cbc7c1edcc2818197a7db7cee61d731fb4bb84699e87a14ccb26bc7762fd1c4aacdd5bece6cf90c018ea4395308eee54ca890c62a0fc0de075336697721d44c372f8128bf27a2fc0367c3cb127cd3a12d78d8c0080f170dfe568f22bc4b4d5558164021fc256b31ba10813c69f3ac7925541b8b9712279abd223cc6c9c8fa0ec5181d50d18c1943876dcb0338ab337a0e10760cc61b6ffdd35e3721ba6136a68265f9a85846be686939cab65171537f5a19076ed04cd8ee88cfb31e61c7f90ac0e5eb3d2f74e13a8994aca974d85d1aef221b15ba5e54f34b5fe3a5942cf9888ba47d10173cf560bdeb69fe00d5ddd6fc30dae9caed9fa505e5e6136d87c3342c320ed78a4112d6736705dbc1052582b16e8d857595625120e40d0fbcf5f766e94625372c3d6153972f124f0fc82fd30e74543c9b00fabeb717b72e5da9f0271b1205e280cc726bfc48390d053beee6981525abd2c7475d9961786fe64f35a21c18512fb4a24fa97834eb73f71087b76cc347eb884ee6a97a29f6b408ccb94d5fadeed97b6f471e3075962134cde47a4bc5b27c98372db2b66266d42de631ffcf1e0517c058dd7931703eeeb36cf0368eb0c461690bfaa1dee1319ed3b3c781b9a4f41a39169673755d6e130c2a2c94d62feecd65ff8095ce9e793d5f4d613e4539b091786a9fb13340c5b81fdd61773e1a62c50203fcaa5aedb6cd36e66ec13a60aab2b5356e2944bcabb4d7aae154cb574c8ba1830a02bd1a2e92659060f9c12daac78b5aa531b3a8dfc62465faaeb848e8c822fc19a1fdb2564794e7f8f11816757e82787d00c57ce6aa531700788bfd85a8292548e267387ee2b8da63827d622c093f6ae7e5fdd97d99e163a0fcfb07a0c2a937d39be7c01950b813388231f762a7a1385e0853134cf57c9da3ccee3d280a182b2cc003004a5ae7660648a86c821bf0fcb77266c27b24f9fc4b954b736687bce8c5f0f28ceb14ff6ffad178f6342ac19922cd22ff0bd11f3d7ab189f3690478e660b4cd17c8c00d352c09fea5519ba7d716c0130985063cef3decc7f4c171eb23fa4be091d587af67c08653b94cd6455668ffcf2a27816450e94e5aa6b70eb3a47bffa42c5d72a39034a514d0a15048244d24e6706e0e7e7b85e5a2ab3c4402a8234c253a2f2024d2395be80f802ef9a24814338bd6a668909a071fcb9be4f3179f00ff3bada578153b32f67e307a2c6d3f331d441a448320f52e92c10ba36ca537f326d9aff3cd4acf28701456db43491fde528ef122711a6e5d7595d5bc149b84fa0a8c101b969a7941b376f2643af884d025fe7f2c675b1efb9776259adccaffe7eaf2b369bfacffd6b5eecea0d645dbbb9d072e7fba01a737a443ddb3ad0ce72169b01cabccf7fcd91deb5ac66be719db85b4bee764214da75313fcb811c1f6c63191b9f0fbf6728ff4f8f1af4fed699eb63bb30412ed8f5e251e77de89a567ddbca8aa36064ce8544a531340a24b31aa4319cb3049f8f987638df6a68d0d5357385c2c03a8e49a5342e68eb759fcd4f3658920c3320b79c036182cd385764b27cfeef48bf289f36128f3dde8053e35d6212806d2d1719b75d71c7ad0d908e0d2c2ef95c06a559d6b3b3bc8ca1dd663768c73d40f480e0b02ca92c25c22c1b44e0e37cb5935d7217b8d7a7347d9d7d66f0f0b010b22f7cd9e9273c851079bd6e5af8ad282d9e1660f5e0b2441a3bff99345ceb2851fdedeb30fd07ff270d5f8dbc15dd480c205a9ed341ca4bc2bc1219ad87162a8b3e8330cdb6c411f21655eced862896f1ea0f2416848550881c7047a66d13cfeb13c8a18a041276a026f89f04c3bad5a61d59fb48a2388936ee405f53623490cc794aea47a16c92a7135cc3b99202dcd5edda978c29afc12f7d89b93695b2a2ab4ec0dda5d85ac229dc3dbc8a4ff63251b9dfa2a130274f18c2a30c304f2a76b14f918a7e0c018964a632269d0e666fcc1cc94b6e363db8b514ced13d52f560374dc5236e55dee257728608912e82aca714295a98d05c54fac193bc6324b5d00663f066bd75717f18d3a5e87d19068051cd96e98a6874be2fa30f916e4f9d038e0fe9e5f754094a1322d4e5c57ee61932ad47e06e926b2910e596f3ffa3e19bd5422d6b65c259d6116b9f9add9ca003f0031d0d32d6ebbc6e621d9ae81ff210d9bda9d888b7b2f4add8c5d37d93fbff26149166f233e86130c60b42947e5173c2105b13b5680483be94baa6a7f1ae2588cbe6736d1d2705cf7896953086625cdbd63d276df4db324265757b5f5fe1546c564d75b94d52823d932affa825b370fcffe5bb802bd5525a462d1c7b520138d058e4be415f8600577911b1fe00c11f04ddc6459ecc62f78ce14faa8b3813694fb065ff7c744222a82128c62b831774ca8621e2f64100d773ed5ceafc056661baab314837a9d4437160c8ada93644e8e7da822a1b6717a8fe5142093aa2b155a974706b40df616a491140a73673c1eaa5e43e8d0016be45d75e348c3c487856ca1ef1beac5f51a8d1e536e282fc1d82ab887e0dfc29ed3e0c3c9dcd0a31b178cc77f47fe29ceacf44a38a75da7e265a177061d8738f3e1e2e3b9556afec2df50fb53b8a345da5f2d57f705770be6a01de68968d79ea5a7722353267ff9f9bf8c85e9f45fa44d1322343933ad753e87232bb69e03889eb67d975868717759f19b5caf24ef7ce5af1d0805f0e43667a3fb7a734552c06f5f42d8b66d37c0bebabfb59bfd7cfae08288c1cd16ee95e6159583b45a3c262f82cca88dafa95d9859fc5efb3479471d691b698e051602015916a4cab752c3cc41718368fb5efdc7eaf3bbb17f6ab27f8822235eaf76ef50281e5c721d9652aef360243c4a51c76685d5d00e1727415bbe80d4489c27284ab58905c48cbded80d87003bff4545cf70d924c9d1a2cfa7649c394ea9649da22c966a443219ec5a0750d08329e02dd478954e78ded472335fb36a505f6ad7749cfa8e61c2ae51f4f0c0b6068b027e2ae0646281d6cd50863dd92b4702fae35cbc3fac9336c45bd38562b4cf700fe77acb71723313afaa004644b0ec0078d6ce703d588ce06338349b544ef81490d0f507ebdabdc64b499833457c263e1f6f8452afe0417f3ca919fd1fab39609ee826ecfc69abbcef6905798210a0aa8b6ef05173091ba16038df9b6115b877dd109fac29d354f2acd9fd538e868037fd015ee4e6b3fed3d26a8ad6e04663091a71fe229ea5227562fe6bb3790667aca8d3be47f90c18a36a65296d6289f8aafe448c0c46843ca3ad2cdb215215bb6be0acfa62a5a88ba061df894fd30fad74293918f200e17a4fc28fe3ac22cc0accadaa7a9cff40d14a5428dee79d4729f9f2b15fcd550d76a800e5993ea12cd3197cd3a58a83ff8f54569d5ea113a353a1f713804d1d8334cd92eb04ec1b3d0d37cc0dccfd693021aede97e88f5a4f949bf034d413d881d4819ae77cea930312bcaa974582e26260542f9630f0e372529935345574e27b599699c03412418f27837427524b9e39c0392e681418be9d1f10e0b823623b778c5eb8ebfdba834d1614d62d31faa0b751be36b0cc45a371ac53e17e758a252cc6bc3dba8507d7eeeba8ca28145e02813b784f80dd9470a90e63f5a00dbef2b5ad9cbf1da66d6f8c27387722bbfbc53e1cb8e8db62568d1ccd9b55c0be37357d4bbc3f5f676739d95e1a7902106fef15cc4b4085cad0fbd1527ee1933eaad3f53c3f915563e8b96b598e4e82e146e8ce61e9b909df68aeccd5e923ac7e2aba06bf08ddbd557a4b8477728425ddf1a66e7de1cf70af68da96ed0e852cdbe25d4271fb373085c74a4e5f500372f1d2885ded150daeea8bcb29ebc362e1cf38fe512acdee009c5c4c7ac231f6c0c6d752ef67437eb841e510186e35fc616b2adb92af6e600b2827e75919c4136247fcd6f4a46600b43e415595806c9157b7ecde7f10980e3b731a0d88c07ffb40e15ed14cf239aa1fb2f1a52c966f4822af5a250f2491663a4f48bfbab646d26fa9a70a6ee35ed2b1533c2226e86cd5c9eeb57ce4236a0f197c4e85f88e90254fc7f37a0f995e4aa87aa175aec2512c2fe0d21fdca9904064422e37ec40d0907c0eff2b7b8f3e40d45c487449530a06809b73ea4b9d9cbfc6a28160d871fdbd51b99c2e1721ba5de9e4be3958ea2b53ad06c0eb6eef27aec7a1b78788e8c93fc6f8c228ab148172ca11b351a5851c0daea382cb7787e182613e14db7346c9bd8f5027b4fb6fde5009c05a326b2f1762c41e8a9c3f013a3d49fe919ae6095a622e868d6ad60df7d150a9d27026e872d1bf544e81e05d425bfe77a3106693f70ae96468f32b3ac29b4161080487c0d0ab22167864f5b29dc0cae80b7260430edd249f3878bdff478b55103b070a827c5f47da1224438e73d16c347f34b3b2f31495bc36adfe2a46a0679d56c6afbaffa07308e3bda9b6b31f087a8aba84e6958b0ae8648e2a864efd51fbeaa439e0428dd4f69fc255c3b2f69816859b1a8732756d51f2c4acfc4900d6a26a27b8734417e42d3b138885e14816b4339c531b76760f4f2b68810a0acebc7a662d96f8902ffb76a7e6e2a770f50ed33f036135610083fb1c0fa2e4e623973a9e5ef94ad7b0a325d7ae30335dc06ef1b5560c34a294055c6318811102ffdafe246c8d550caf0f81d518fa0320d4483d79c69a180bb9002b0e9c53bd5e8b560c2d0f1706305ef4a63f68226349a5efac3791d580a9cbd9b04e779e09a5768a1785757fd39f4f2b2797473ec74b7a590d7ed138186394cc4914d8b2e8d2ccea52416a31e6a6a0517ea041b8a073205ecbf992cb5577a9df4749de0f1b3c32c5627aa9144f6187260fc6cdca0b29f8f6dbc29bc9b7028c4431508d4cab96fe5ec7f5abf2597f0fb18c7f775ad5dfaa04efd3bc81f8b1e953c85de80a9940d1b602909e366ac9ff8cbc3a789e1c9a442ebf3e3cc53c613292f43aac1b824e8f9f341ad534c96a2db340669832752d4fd32e162588caedd60334eb9d9719f0c595c6133b34724cab4ee02c3b80823c42c7ad767e5747a5c39f89d930330b3e93dc5740c42d55fd0942d60b88efa8156478ce9b0e0a8d0fc757485c18510e19a022bb26729097f5d0dcf977dc3c71732536b222e1027d47b14c5b39f640e0457d3e88426045de9018c2e9e5964d4bedb63c458bc15de6ce824a3cc377bae93a3438193b9116fa2b6642ee0e3bb3f0db6d4f674e7845509bc6990030125c77c433ae6552463f5459005dc21377329881f3126e166b58b9626296faf64464ea1487925d9b81f46ec5e89e2807b8866ab754a605b96f09a14ef2cb7f2eda07566eee3a43a6376d56c3de590a5316e1f1426de68cd2fc73ec242287b09e08720fbecde0fbb11e240073cd870b45270f72aad550574607052dbb2d27da6a91b4d93b4740c7c373a37fda4f03b07d85f508a367d7d275eecb58993ccca4356a044dec6517be02574a2b27b88d3f7672d6ed731df1f8708b9bee52d77051fbfa68324b92301f182d67a9b05aaf1a047c93ab56d214a1d6dd54119c518c1f0289934c7ac0abd74e0e2efab84e2fbed59cde0dfb6fafc2008cf2d9cba7e70752d36986f6d310cd10cec79ea81f35bceb24f208982f788996ca46d97ff1d92ffe92b45efd415c64bd23c863e2eaad3151ab334c75818ced391fb7fa9ad9f22e3c380fc79ca7ab997229db03fe8965a6b845128fd4451542d67dbfe18ce0ce0a9af60beee7c4ba4e0d848dcf591c0a7f81c26d642e89262aa6ab8e227616bcd8da2fd327464a0076301feb071b1797c0aabf7fe43dcc0e0d34b6d414dbf5c848cc3bc85597d7b31291a8cd80d5cbbe5ea7d0c7014f1ec854a41a167c5ef24d3826bd202adaebf48ab0b7d5943220068cd3982c267b6a7710ef9edff2a7c3cc13215720bcbb3f6b96bdc59634919f5727aef12b7d7f2a9d8ac33bcca29d18cfb20d212640aafce95727bcd98647f5af9251df8e3f3046d7cd880742d344a1060f155e2923c9c1dc78b1eb43b2044ad094aee35e7b145a4f1a21ec7bfe56098fd6669b135721790fe383b937bbcb883c101ed9a14f30266278b868c87144aa4838d39139c77adc5e5d27713d5dcae8a30bf52c6d7dfd113b12ea38a9a44d480da38e86e845ab93474f380398f8ea5301f9a6cd75561dcc8fec091be061c31ef7914709f566c16f7eca8bff6ed1afe869a106ef30407e7dcfca2ae9ee5edbdaa2f8ec1ded9181bac790802540d41c6da90d0fcdb3c423085162522d641c112824976de5afd22f15b48f9e2dfe7b38784a9eff5984d8053f51f73f914d39b3947a0e3e4572b37fbcf15b418ef286a4e4ccb498ee2f97f1eac02064d06541df4749215692d44f1501b8b2e048849cb44ad89ec747972fa699aa08a63803807bad577674ad704ffd11650b3bc4b6a77956c34db6f9b71ddfb612c413b77c9d30b43289b9bd2c5c12fb78cce22dd082b2330850845d7b46b83ad1ae02db288f006751dd32558b0930dae80e08ba86831b4f9729731d2c5c17d18e5e6d15ea73ecada4f2b20a7aa6e2ac77794cdb351f9f95fc97dffbfe0cd24b470d4f7a1289f532d13b95591c49d930c1c8b47fc561c57308102671f4381e72101089e1a4002e8386aec93dcdee40dfbe94c68346ebf0ac617e02b8329de7a6a4488b226176cf775392f2784944f12d7d103cc890542440cefc8ff7494417f750acda9fe2fb51eb67012dbd6ca0b893d96ff12514ed3d3a7e0c0a92b6143c86678e9566a9db44fb12ab44f7e3ddc8df5b80734d44e79f772667c7a4885e10c6696f7117a6efe506259690350f8d6a667825fa57bd02f79852e06ed8b3e5ac872cad302d452f07d26a61c9fcca0e3ee82fcf56f5df4d98f32f9fe9c8bf61f9874c9b79ee1be162870026f81aec263ce91b92d46a42de6d609a1cddeda4d365f9a9736ed4ab9e790a1c82df7de468cf02f1c8ca603b5732646b55664137d56079b383e115f6ce2c8c8165b4a5baa398cbf6e1b9406473f74fcdb662b7fdf23010590c0f98ced9b3fd38f124110b6e0ac599b61fdc7ef64b3fbd69815b09fd46d73e978da9dda9fe87e5ed2a358033b65d7fe6c23d42eed4527f48c622183d5a6702147cb3235a2b21a547cbd66a2ca7078c92a5c0f6cdfb856beb8481b2bbd40c31e660fb4aa05a9e4fa5bd3ea12a186d5f2593d1b324a7fa436a92dc9d26767866cf7f06859490dedf89f8e66a00f09b4361c869857f7720888ffd8fbe8c66b6b42f8d6ed2022c798124eaabd0a6456faafcca362b7e60db4d65d1cfba4e75a292c1b86f59a5f7bec308a4621a84c8f853c6443603aa4a58d444f7086f330aff9e8ad05d7b99ce8aa3af7a843f9c38050258dbf139ae3c1a5eacb697e9e45a90e61c625b85bf8188ec971e790ce464d4d008bc84384e2f9bc63b40fd64f741ba5abee5aa5efedaec177d2fc775c0a2208c2fdcbdbe1187e54f33f2af33be58274e391dc713f0ccffb07a4a3555ecfbb6578fe21f82038c45343abac2a232dedc30a99766c5a1ee8f5cab33d3dd5a4bde49be7e308c0ef18077af284813030ab0bf9779cd451c48a2c02597c28bfa915894301689680e0053021ce14b3052aef9dfcf2255798f3c2b5d6dff7e1c5813aa9c6e7e25d6b92c5ffbdbef3ed7ffd099c4440e35f6d3a7ec8f169f07c4a29a00bd742ce59f355291aa4fe35b98722a66aaba5f0b035cca2d9316c6463d0404cde4969aecbbfb6098ffef2592d3ff32218dfabebafb037bcc3886a0cc0225869cf5b708c13edfebcd09ed01d2a2fd2d68b9b96ea73010b3155bfff0bd59edc0304fa05b4aacd58e10cd45f9420ff80fbbb89868e0f8de3e75dfc3c4723638de5cc733852118e4a5560b7119cd2d170894191463fa4b767b6c7dbf5f3e5ec9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
