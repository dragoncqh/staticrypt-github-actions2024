<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f81509c88a8c9e38a8ce052e331011f632ff5aa6bdeee5691a6f624f10269aa82765061674ccec031f8cbc2c68d110a779bd5b33901177a6733764e004e39cd01dce6b76a395592ba8c0d5ab6afc4f4cee19c8e6e30dd99da9870e281a65bf61aabeff8d07aeb907b51516fd21c304f90edb7296294372b652a78d79908b94b8c63db1469dcf977cd227b1145c3dcc6c9ef2fe2cb36c04aa1c19484d97aa8034b97b7b018a667db5cd4460ec26c01e6a8abaa2b7da537f6f152bf0c807afbff057d95db5523538e9b894815ad111226b9056b66531937f135e10daba15d9aedc25b10c75659d21f161b25bd88d6619c00ec4e38bd30c185c3892a99f917f6d2d2c5e1291ad396c168b983df20c0ec17f8ad7c47f6fe909db73db5a663c14b669b61b4792f200a2c1cb14c74df8679bae517db93394b2a1d5f6961fda3ecec414c8267e2992a35572b8e250a13077084a7c99f8c51443e2a05f738ba94d9f5b66da81f75ae71b2145bc80b41359db997c10e6721aefb404f4597e45feb5cf78e60270c0f3931c3c27f3c434cf466e1a89fa6cf192b6a85a79cd00dfe7950816f16823e968dfdb70b9d03bdd7a84408e42f92b08e929e978de49dae81ec08c50f120af681797231ea4afb2a238a84f59f4dde29855e43e95bbc93e3a525c6a10cc4fef4d242f70013001961416ded46d4d6bd38ff221dfd777c369004afebfb8982e0f0b48c48f3caccc125ed2f7658ad6a900922df43775d6ec4181e6e2b3a94c53e6bca06db395884f3af5fcc5f715879f9ea53971220c3e234d1c58569bcfd9529058017a69a1ff08371af0214b9a66149edb41f66c308aa7d9c063c4a6e85ccc7b95de7510145df962f94fda12341c3cc407887de2a48acdbc16b8e810a3d0912f5652cfd3afe087e30acf3ce7690034a03224650a9ae8fd233ee20d1c4ad81b3fc9ddbf72092fea78b67687d7acd3ff49e8ce3aa8cf69f032220921829b4f2bc3e65fa345efd66d14ca3713a67a507cf97936248dd4e9ade51929583953b72b6ae4f0e7038d1cc035e44ae864637b84433889e782fcdb88002502abf7cfee737e26954e654268996f7432123607aa2d4948675ddc5ebc7eb6e33af92d5e300f75facc8c88df0e4d1a3bfd0d09e514432eb73f0c5c3697a958e042e1b573b087e7bcb004eac935ee76db9d2289a655d71c3dfa9b4c98b2e05f3727790f390ce8a46aadbdba4e9e1c599fb0c9026a3ed9661ffe908d8fff7e33e504c2f836102c717c34731ff9a6e8c9fc710207bdf205010f711f3a2a0cb5f44733719565844c28e05e5cf88ffd602dff4a19efd19c75d0b22aaf046db58cd4d69a023d5f5b2d63d064d15bb81d990f367ca855041fb1540b6fddc502dc5272469d5aa0b825a34dd85933e41352e5cc73016460e0a3541a6fcd15238b91f01e60edcea6fc91e9dff3961730cdc4012a96b6f4d90a34ee511e2a69bd148d70adbe038e446eb521ca9521f5f93fa966941e8be74e55cef25234a9e6b27d03f51c2f26b24d57178fbf907ec2a206e0227b67901615a2fd371decd41b58b85d372aefa51ca822a6d4463c678aa8d344b3f832f2a40c7fdda9f2410a222b572847308274458a27d6bf2544b50148f42670e793bbf1af1e176fb9cd3396cef672f1b4447f4b90170d86e8b80138852def7f28e2241e8dc7c75589441a4f04d2368f2522808f4bb2445b31bcfc1c4f9e2dc312ad58a94632663f05797ba1c97d4c1a01021f274e39a63182e01c422524926dfb117a8423a0dd07a811ae95312057bd28bf07ee9ef91ef4f2cdfd328ba22615dcfdc6d5a792247a6fcf27ff0567f6d689a8aafe2829a5c296bf9d949273859f9b426532cc76fb45d44bd394aa063e758ccc914bb836a46b0aba57d1f92a0450bd837001fd7b9e081d1ee808ec3f1540b72d620901a2951f12b5d39f13a81021363363f97af9c92409a2633a8f5fd9eac35f276a4c82f3e77cf2782bdc3ed894d429cc1d26a5c214fe0031ff0f49fff06113d82c7017f2a44db315652e56fe5c2b0346498e3230766082d0695cc9d02dcf99698a004be17b09a76a97f088f75a9b2f2ab0f38dc8839c64528c5b2cc54f79db813f7aa2a816d5f95902ceb90c71d2d9b66f1aaa6655e6a2a194b8d789c077085c25f2b1de794bb822eae32d902720d914ea69dc12ca53723d0ca7ead00e88df3a459e819acbc1095fe431c24c2db352d4c5c6a2b7487062b44cfb319816434692dbce0577fd1f1667453fa96f27b6a1b2c2baa13e83867c17e72beb7f05e0dd88c79503d4ea39aa346a0c1e9ec2b2d533cb5e5d31649b4697ec68d399adabaea543e0b05d886bfbb7c7f56fd140e16639ca6bb0a1d3170891d924543a9d5ce643276a2915c6a04697a505ccd2fd9b6877c95e9b9fb1b8241de68d9c2770656765f67566fc5d61ea001868eab070dbad7cb2780b8b6e2072d02d7609ead833395d2f5a89c0789194117aa5ec3ae02fcf0958320e85cbb2888fdbccefba0852cd88fe4f22d893c9efdd31f2d3d8693b4b44c4f12e30cbe3c8dee355f83b50206f7b8642dfebff1b57661980baa2152910faefd6b56b2d5544c94277600e84c9075f401b66cceed21f846d1a67b8c4bb77233cb29c0eca01d4ff18d70a36bcc4a7d62074fb17d5ad1c33f6620bb6d5dd5ed87cd9a8a3ff2b5bbd86d2665156eee3b7abc37cdb9b3bdda45448083a629c2da00ea53ed8a9e07ede041c8142e71b749b5e0091eed5a85acc36577a28a19a42d222ce44c6f13c934a7a90ac630125c22f3a947c5c23227abee6ddf45855607946dcaafd4085dae8bd465fc7b2896cc1a118351166da93b9ab3877cd38dab18b209a87ca99bb4a4c702aeae65699cec8819438f7eaa07a33b510998ff7955240ef97171cd52376c7ef287535d09a0d87e3030fc2cc9a0c76277c62e60da898002fc46ca427c6c059a9f157212f85d43b5c774fcc1ad7a153d4538dbf78249630bb844ce781d758bbd76fc63ea70741351242ebf1287c2f1bbdf7cfaea1ca7a1c2992ed52ae1621a0d6d27683ab2a236b65c8e6c591871ee3d72c48d38adac941a61304e8c58c4fdf02e5f02ee7e3d7f82e1b77f0b44c95ef258d0b5b0fff8209c11c7ae0e7f7723fb1329ac4c19a03a566d60350e97e793b3b6020c755b451b92b2d5f8ff2514ceb82f6fc412af824b603cdffb210e197a3e6e1e6e415a1f4799d8966e41470e9a555e9a096fe6011db6c1231774380486f15374ed87a9fb703d1cb3f44f22f3ebf4f6f80c6e8eda8420b0451101de9540ba0111d45832492fa17e1c3e542ee31262c082a25fd37c9a0dd4772e0d56f87aeeb2778a018ad87a2b801b461cab61461dabd6b6193ee76db05a57ef6b1eb56c2fc039fd0ddbf0a30e0f226b3219e0156f8b1924616562055ccfc083353aa95a68c53cc59b3c45e58321dcf94a8fb8623350d86a4b83f8b40f5139d3052b778335cbc4fa26498137caf3e8bf07d21435b39a8e581ef85589d13becce9f5acba3379cf82217473589210e3b335be18cbd6477eefeda9d0582e9fb48f285906c52fbfedc519ea051d7b58466839b0fe8dd45686c646b01e32158a8d436d0fd724036c4e2264670e0a98c4ccb640d67eb7c0d01b16d2edad2f7ccae6507959ee4a98141d1280b874584a1bc73ccac1c9f127f8251f7e81b11fa50c6932c13206e58090b1abfa1320de18aaea03ad558c931aad1f58ef1f57f70e3032c0ee4f151e71615668a8adfb220027feaa573135e89ff9d1c8f1e72aec7d2a5d98f1db9ca8b0760f75b7dc4cd3eff63c89e2be5d033057f1bb862d66bf7db342f336096eb78c3e2ca456afc1aba918f21974b3dc7096dd1a74dc3d1bb9b3a43b19add6e4d0af02801d9d05456d435c4bb2f60dba01348c18dfaadb4ab87a11ec8e603a6633a058eeaf57422a1593552bfbe0b55b3f6ad3acf2686c7e6d24c3d050446a0f2f5bbc7a4f9dd591aeb143b430d7ea3c6d786ad5c3e966b5cc0914cfae7c6c23b5392a7433963a44a06bcb00e8e5515c4ddb34c933384a1e3ff1a1c6a53eecc3f2201be222bb6d2892f1b2c5181dda0a9efc61959fb19d79ada27f7d64b5bf8c69bc77b918e35b91fe8a6dd78c893abb4f0e5ad14a7ff97756ea58cc8621a027abd9dc328d4689f856a68db3bcda16448f5d8dc01afbe7f2582b80024364a04adf3cd54b4ff2be9cda7dcd9d18f597c9cf461da903418cfcdeeecf4d7fdbcea4270a80f88b7b2db755ff36324b48a0b733cfdbd869eee970d39ebb227c71a460ef7b0656aa3e497d7b4eaaf14d0f74b96662965b679c8c25383776408ece401ded321019029c8b53f2af0a3265eaf016024b02046659801f2b03cdb4079dc0bcc6c1223cd30522d7cd91abc341dd10f59bc27b4898fd9655d1993636c670bdb91a5297b5060a877c2eb8a7006e1bd42b2c75ded606a2b4f00cee2f75b0ee7bb8f359b12de87a33109d9cdb773d4d6b4b720b7de72169711448c9acfa6e1ce2f02a27079ce198fd3006d35cb641bf78046ac463181eef0201a7dc3979cd079aad962893d389f32ce9452a60c07f8a5e6ec3a35c50f6566d8e2a80098de01fb35134f81c5bced1b5fb899be159f1c1a8424bfa590db044a28cc25753b485480a3ade21aa525afaf9391f247063a3fccdc04fe19587b7491d37a45548b823344bdd6f81ff36d7adaffb98c501bfa2f80ca87bf7cbaf36f0939ca0a3dfa79424acc3ee17177be8c70553c9eb291d1b05ac703e98cc895869ec82da828a307ed0ec7b8a7c4d15cc205fc244957cc5c6aa2479ad51fcf79bca17b27248d04207d52fbc2a03d0442590014b58f73507afef4e22eacb8910cad83aca3b26be872ded6d55122f6252f5a0032e8a36e779be03bd73f409d20410b746ab2b189be2b38d4286da09f23e5c58fdc3691cb3dfc2603d6c13c8473a6dff584009ce2b003f4a5d9619eed8bc9612ddfd2c444f633fd3bde79fb07e19dac91d67e1ce35d9b35034951245c3b6cdceffeec93ec6869e2238e250a2f4ca21cad2c37b3d552c3afda6b664bfb66f2f08ead73123aff672d27720e3815cd6f71655f1773582279a4ca8142aef225c1f72da123c7bf17bcf8cf0e5844de3d5332bff51c28a3791f4f9538e56e438cdf0ff77e25ab9ddb786fb2a4b7a51d00df89d8ffdb7196535b90996bb13c1fabec6a04bc6d8833a30b2908b2a0eaa930b23186267c2c2712cf405f95c34f61373e49c5729c74007112ce4ff2683fc2671e4963c386b09f0721c5ae7a962ba6755496135e75391529db11f7b68aa3674a711a327dea2fcdde6e7ce271511879a7946f781185f1b19f53ba404edbbfb29bfb9efd4f76c2426b74c8d5fcb35b0da3b3a2740516e77857417bf76198044bed9cf3a2f13ccf89331dbe64f5df9bd72d6a377f38a64858e2e2e73bad3f3c2864e73c43e7ceaf27d537cd274a5d113294a970f957daa610b7e8cbdcb6ad5dca5dc4d2a6f78a94996a76b65dd9d144e9599d1f99e5b7c4a334dfc2b3d894d28c3bf6424a8a1c0dec396c1bc2a68d115e87ff3435b1b56f7ce7355e2d6ae9d90bdc55ab3aa0dab77715bddeede91d5fde240727d8a50fb8641dfd0a72bb6e6e8205805de398d186b3d3775aa0cb788a58dc47f7de64e1193f23533cce1b4880f2d83dfa946a0a676b08f2eff18515cb53f7aa25721de7f547c2d704727c837aa6e7f40b260870ffdfbc468e9cbc34c72d17a407200781ebc88e277efd37a04f54c82141b33d6feb34c96dd12f4330c7fe85055927987aadfb7143c22606112ecd4d97b52c1b22c251046acf41f5742ba5d1e26b3d5f3cda667426517cdccac8687cc9c802684f4d4d75cd5c25ce18dd1e7583e6f8ef8f62862af886c47fd24228d31f8ffdb2b9d4ba64865513ea0cd3a714dfd617acd56579b0c546f796a0d3463f3c12d6e162fe84d88b1473d74b37d0fe16461754bb3c7803e0a5e405a122f458cad43e4369a573155e1f857a2bb8a872324119d5eb808c7c746305a2e0b8f4ae6f904ecd964d3f40f0b0bc0bc85eecd43609f8b2b23184fc12118a17631d7f80483198708679f7d2656f0d0416d255299c05e62a2723daa0db2a9fc430eb3f8f2b59a479c359161a78cf6c6d765d54b21d28e8346d37339809d0a7711857d01ff9a987a793d415fffe3433b496f9c0c51c0589ebb1b22124ef5b7ae537267f62ce5dd5f4be464b5d567b2d501ab62d78ad4064401179ebac832cf0762b2a2f8f92a02e315b03a38f649d0bcc3c20ed712dc8f407e313680bff735539324132815ff3c3c708cbd00a514f88da118e40d4927162e742ec5f4add5e6db01959140a1a95435d5066987ead6a2c63061b90c4622f2a482b148b44e88efddf7db5ad3f60abb9d8aeaf6d0608a6ba649d6cd958302a19841ac4ffef1889211992af54b6bf4b675ef40f1e6512b49c0701f04bce231b1efe431024a892215d0885d79ed8447f4384b7b6c9cc25d3ebe0a572497a324197018ec9e0abd22a615f329b830fff87c1a89ce89c414fcdfe654cc04e74c739625ce34809342322095b2f54b6b6a6dbffaff9ba6b27c3711c8956321329ab80b5a8454148f8628f5c26284a51c935e558af367b8c34be05250558ff6d2544d1a271ead69c3ef7c8b258e7c235d457e78a4e6e00a3e24df0c4b2f329bd4d111845cb3ef80f8ad8932be63f621c4a5a3e14ab6d8ce284ce60ecd50e47c86e8c168ef0b48e79cc8262c79486e054e729c054b52e32d9a42a1e72931e1f661be525574444b906582c69dedc3606dbbf35529ecc3ca94caa84a7371dd5dcdcdfa7ea46bb3e224a0fb1df2216a9881508be0925b10874c72a5bb02c2785997c8ed637c0f24e2c9ecd6acfb5689cf5e93fc5fe6ab055cd49d1b265928a205af8dc180365dfb23af15b78279190f5604117da7dca7a5d00b569341509a0e321b71bece9dbb4d4a8fe5937ff741031ab2687e875f66ca8f605ae5ec9cbc92f0aa3ea14782c4bf3c59c08aad90f5af63145963e95328a557eae381a8d9e18e6f9d58bcd912132b4e421239a07f3f10059b889136c7fa6c64dbbbfc7d107f9a34490579c57c4f74b00f9e2a7d252319d1c94ec20f2337ceecb1d851989765e66b2f2210aa5ab45f1d1c7d877b9336be596a538745ba79cbf36cc326b25d41d677b18bccb32f57d7b04ab8d0d1857f000f5fbf474ed73da1dbbc1360d2b3d68e988db344672939ecee82e7b472bce212a29de9b19888cc8c51e32e2b072d7366ab8861b9f7c14d13e6151560ad68455ef5aa56d98a7ff190f6b825442bb424614d60d9a0020bc3a9e1a1af0cd5e85b1dc35d651c8c6c3029506f2cebc720a8ea5309fc1d816a7136d1239b95d4b066882125fc5008104ca5d350e702451ab98fe7891f70e127657f95601c1290da20f8489b389e8c2b379aef7d437af8a0042e5d7a3c8f02e0c089aa26581126f9856c8f136efc28f3229f3fa65da8d1c3bf36f0b61844391a53177fc6e7dc523a379a4f49a23e306f1aa9caa1276927a03041bc27f04225ca9bcb6e38541af7ebc710de1882e13ec7351104fccb5cde36996933fab2ee10a66de2d3322c02b19c10bbe55bc1a9fccef3b9d1b1d22be124040443581d9821e4548381cf7054cf42174766dadf1bbae39b0c9c6f775c00207f21c4dc49fb7aa51197c9c85da0f170f7026d4c1fc920c1329c2a430af5f4bbfb9797d41d351233d939f13f3c562347fedcd4e9881a1d272129ff49f39c6945fd7a1184fa8d35c1341158965c5c44da33b62a16e0153ff8e7ff1eb3dccacdbef7b2032eee0af50c7af0f535adbb36a4a2382228a4896305878fedbb233a38fa192d5e6758a75e32216f3b5a8506e29c2114cfd0a0ee0c143718abef84b8f6c2ac97e29741580aafc142313bb843a5e8aee9932cd38501c3ce0362cd18909bd1ece564a6468cd920cb2b721a080eabcd6ba362def9d9d010cd74ad8b4d6c516124f6bc0d868f68d8c142d34765c3deaf797ccb749ca0fd186ca8d4f885c79604b7e8d8e7fec60fd246a1127cf60d854b99e400065a79ad374ea83903a79c6f2def0897e14a1f3c0d2e56b8f4f2bdfd850a6a12d910109f03d146cad2997589b3ae2c874c2ec124b5f43427d40f9317b35375df74906ff1930d299d926b25fecca434b1626dfafc1ec017f524a0fd9b23ba5cf8faa355627e11026445e3f889990403c44994ea647ca239d9b85b1be4b671fcb6da64c682fdf1631376f405110c41185be67f2ed1d18f710fb027a5415480fe8564e5c7194b24d5a52ba2f6ab1fc58e6dd2e1ef4279b3f1a75a644d496c42e4c53dda0f47d6f860c10fc21c317f8b71b5eeaf9536f22fae5533904c7524fb431be21cfed2972b65f3a360b0f8ef84b1de8728b7df2e9accf9a0ce0968a5e5042325d357be105ec677f87d43bcd517a18ba92f96e716c469c0510b61343c18015ae7770a3dcf0fbe45839672fc752f9fec01e7f90872058f82fbdfc2471b83d1f15182ef497c3b3347a0605f93a7a6a85e4cc71c19cc63ec10dd80d5b3c8d77611ec74a575c3a95ba41835f708afa23e758b314c2200de244ced24b23f3e77b85e07147d5320368824aed9c565f17f73d88c51796e05c1790ec7a94becaba5265b1ec9741631cf50ced77321539657a2776fbb38727073dbf398a79080ffab4961688ca5dc8924bd12e05b4b294e5fd8b6922a55ad4799321d5dbd27489887c1af00e678fa90041493be48dacc960d68e4c01d2db752fcc77023dec255f58a74a1540308cd7ee8376c95d9fa7ecf0402647415cd5b683a2e53ef71c0ee0ca4678e4e15f2560ce44d6d5b5a6409d3d3020720d567ffc715a76a21f6b41edb71024034b4675450a8dfa6a811a891374ff9be9a15734a7ff40491900ced9b2ffd707cab2652e668138f05eb9bee9b1db43aa0651052614e397ff9694ed79fb4f2d7f4c8a8a7980d69a130662fa095adf4376e3237c5a827f3cad2e5f6342db75c3d8277a7ceb85928f66fc77c6ad26754c5e8f895e555ed4d4d062f2fab858b3306a95206933b952ce297e91ef370de4612592584dbc36b2d76db527f7ddf3aed1b8695149019d9cefd5c93444998214bb076342630e26776f4c02219cfc171ba8d11b823604510a9aed16a9749c053d1c04c9e270e5d0e9c2e468dcac15412c966d6414f03f270e3d968cec7e647e9dd8e691a392e75d6e6f694b7bc88ca0c743605b08dad34c1dbb780c19a7d5ae65f26a454a5a23d4d55059720225ec8507160fe83c59a49292b31923eab096b9608cc6af1e160ab1273e25f0fe648e635b90aec4f7596866baedb18e57397061407bf102514ce10e0501303bcda39e22d3548fea72226965701f24070225b9c865cb0ca15e822e801bb4aed83c7ebf00491ef66e3c83a2d56a98e9db2a70869f5ed1544d7a557b2ab55a655603399a410310620fa7c719ce9c5207f903adc261215c7bee66647a0f3be0667c7f9b56f28455e70f070537921c528e05557d75a66c2412fc600ae623c6a7d82b31420ebde93b2dd7052a5584e26dcd3c5ef71105d4b31d177384c42b7faadd3f1acbaaca0cccb63ceabd8e30147fb386bbfcdde6235f2108f83bd57ebf5aedb6139e71e38db0d5bda0690ca8176570ac3d83f82a301e3679e2a9c2c0a2706d17b6de213181b61103fb93b6760ab383a8bf244f4f92bd7ec7b007d4cb5eaea97d8e17bac751e80340578a3c4b7ee2fd0ad70de04d181d166fc08e50b49e3f1ee86cd1c004f7954dcd8375db522952a27b84877c08576f1c2a0920ff8beaa52c63f885aaceccd814084338aaa2a8a06bedb18709d5f613120136e762c6d97491f41ed8bc8151ed71ae95290e5fa0ba630cfa68fc1525415e126d1bfd861cf4ba01bd0ec32401805af205bcea02f7c1dff1690cf7ea0728fbc8fca643089b18dc244723d8c1282b98b873a2effe13f09eceb374ba3570080b618c9c9ec0263238c438d956781d77644e67608bba7d0c31bab5266906948e0513670f21d6d2ec32a7ae2317a4cb6181e559488f758bdbedc36ca95e71a65757378d0d69ca1948f3261277b056caf5a3c0a12c8dcf19ec1fbf5fd8e68f5e6f37e16e69e35ea176e3dedce96fbbbfd4667ebafc763e66ed0cac663b991455f2ac65b5b91825875b64f4efdc20abdffbf1761daa12819f915f7eaf7062fa131ecf6140d08e557c93a7268c61a6970186134fd96140ea0033e1ac8f3ff49712bcff6b125b5c55036b4632d346f3b5f4eff0616bacfbb265b551a2b5491a2c7a4b28086c0b3d76ce2fbab31f5241b18fec2470c16500a1ddf8c1cd9e40101bea394e7bd0ba43d3d263bd25fc903857c417863df5e1e7467052b85f22a91f3f421e8e5a7dd75f438804cb55da706b7a90f04acd4229fdaef11d23880eb1df47ded6262057cec3d5a06bfcea8dd1deccda79070e8faf88cd15775d05ef0c66cdfbdf980176cd9697c4be774676f8a1389fca16efe51a19cb4a878981e17a857a4e01f2f7b1af9ec4ab8e0162b4f16da6a554bba9050e5d5e4ab51969b960e0d62af925cf08e2d7bcfded6c0ac8930c637b8a5bab7628a1ea24d0dfef33cdbbc0ca7ff4e991565a0c4f2fe56f8e3533a14518409bbc57d66d1de3aea7781b4adffb32016c176fcce9e13f435fcab06973c4171287340084243d3bacfbc6fdaaf6369790b94993111a92ce0d8a4e23f114bcca9f053583069da0ac41529fea2eb1ed41e49c41dab987700471aa5dfa970ecebd3905a47d8b2ef9a2a0d1e7cf460aa19fc595acab437d85a26d30f688bc7644190a910f248a3f7df1c67512a6c011b356178de7c752851350e87eb421ef3486ca7369952d562d473a63d63d453a8e9bcbc65c7db12477c6259cc1a562002b3ff10eb021927b2e8053a5a97d979633aa24a99d947fbbaef53b2277776011d686165fce34f97bb4be068118de20efff66790f9a505d12605ff4ad36123fff52324c59be44cdceb3073606d154836d096beecb9f69e743173c05cc8360ec9c3eb87e49d3265ae456d92ed9ad9f2d76ce7cc2f076fe2c369d71b285a82c7081a88c5a2b045fc8ac17fb0a28093cb845891ada4fc6eb8c0c22aa177460fff16d5db60cdcc5d4e6f199b011c8dab0d8d8378f16da61390424c5f575033b84a35d197c06d7e44d685b53467b3da7b43ecfc1646582cfa4ac23662d6606ad2310999ffde41fa892f9a694f1a6e2bc0772cb8858f81689b4efecfa8ee7833170a90fe4a038a1dd762fc5f14bad5e29debe4576315a9e0ca15d2949217cfeff8f89dd004d57963fd0fdf7e14907a78e25b73b56345244888a32bb6aea410a130dfacdc23d46df8149fd79ec319d1d3c243ce5ec59f992a26aeb0dfcf229c6ccf5391b57342fa5dc218a9f6793c988fa339e68a2443ed43ff2e7017f1143d432763bd5a88377242d46cc68a38f37263885bba0db137df31bfdb812e49fb999df14eb608e91a78783d87ec4f8fa23883e41e0f6936851fcc5e28cc4d11b660b1ea3f556cc47f5fda5d478394a04710b7878ee0a35f2819c8fd9db053a6a4785ba9c4cf9bf2e19045e478a7f97230fbbad9cbdcd2f8f9ef0af10a41d2606bb43c5d107c62fd6fb73155c9eab724f01f18503cbfe51a0a8885e7b2709394baf3ddfdd77b4708d138decc4b78b9b65e66c7149336959aaf9127eb4bcf4904651e397682bca925468f65a75daa7a541f3cf913dbf0e0004857ddd082fa0f24967171e4f3e4dfe7077ff10c15f58e9f057aa043d6b7e30041234609a2b5460b47993145b765a8bab871bada396e2a42aa8a79736448540516059abb80e3d31a4e5cfb5290ed731334a374921fda45ddeca1553d67eebf03fd766ca18086016df1fb46101454262ac2946faa3fd75d434cb6bbf8438578ad2c6087bec0c60f8e3fdf868d8e65b73eee1af7e0b937d847e5df96108aeb6e87c9bcbcff99b9c1fbeb82183b6f97036c4e64cafba1703ed39e5ca2cd1b8147301a9b3fb4e8dc002ac14d5ce3bab74abaa1d5c0e9da910b12164b572184d4d733628956df4410d269731cb9b48d292cea91efc841d6564af0407bd906563037501fd0568b3bb3ebf004ba74171188318485e97f0ca49725c4a496ccce0f994a0cc2e3ed5d0c782a9b1542bf15f43c5d0ccfd60f0194ca903ac464f1e9c740e959b5aa71b889b58128e82479cdb4726115aa4deae414ad3fa43cbc9f1e093df4cee6667ebb2bfde6ad99f91acff2f88c540b7ca81e7476a12a23b878449579d6f6071747fa663ed91e6cd3816ee33a458490fa365de86b3faa9e5f413602c4ad4cefa25daf8e6602a640372373b6a8848051a228a08263feb404a0232b50f6071b42ad9c16c97eb2fe2b93c7c7bb9321f946f6b69c27bde5441ee3208eebc2cb9eb404e29b7484ea3a6d4eae7923e8e6d2d121e74ae421273b257e140b39330fdf244e830c961128eea149c9dba083bb7dc86b3d958c693c6cdc6a0b1b69d547c8549b44356cb3881801adc33b2c67ea5887f044680f65247e228990386c2507d0c227c1b6f1eebf9401d735e9df34a25a1e145355c820cc3558cb3cf2f91140a88eee1f371a0197db0df7a8bd97f77fe2ad1f11b188fc76022cf88713bd7d82bcb04410ebd4ba83a4751258d06d8e7861d257a7b87f651edf4b19b1324a7bdeb517dd3832e54ee184039a8753aee8dde1acfad9ba995306f56028e7a6f972857e7ccce6beaf6e414dde330d6caab9512e65451e86aabf54e15b3336d09c68b13a4a65f4843cb2b790f14a8a10766f1948295bbee5c5c8e33e2556074c27e0fc263c1d425667862eaf90cd14eb599d1753718579474d530abc65810bd314b9da093d304ee9f2243495644058ea881a6636561df3907b6e8ebb75584d7e3dabfb6c9981a43c8d99e1cd123237207d4c0e6cbe7623692c798cfa6af51cdc391e6e22343d9ed97c8005e98c5fb658f9e7909ddc2bf172bfd950aecc953ddebb8e06bdb34d05e9b52a04b22888e592a4cf9688276dfa0dc78f7cbae5e221b1193a45dc7c5db66037c7d05258d328ee13d0eda5c0549aecbf7538f0aa04e1a2d9ba0e5c753508a4d7178d681649cf6e9da5299c59ba35c727315b498fc87f7ff1bb91a6feaf09935d8e1c23675f397c839421c475d41c45ad76bddd2856594b3452de438b6cae63ad34e65922ac5192df8cd945d86dedeff23e0f55ad20e9845b7fc91c8d623576b2dbce1a00037231bd9d7b33c1dffd38fea6cf1b86df7cc0c2a0f875acd26060d12e43a1b31e360bd2a9e93a31878681c08b6ab925a00529c4737f2dfb6bebd159c653ab69bd040ebb68dfd4245416a714878ce24ee70e28a5d66e19cdea74774c75de4e7b30408c1c22fb5b3f65c5f5ca97ed5a55a7c8f25dd0de8598bb64bf204a90460c581b8fac52ddf2d13772195f143518cf795db68179392c5d9980c5516b00c1e83269f44bcc37aebca86181531fafd2f7ecf695cc3d28357116465206a5fbab1dfe3d619855fde3404cc815bd873f3366e0c8fe5636c1e66ba7a07462bea574bff5d64363fde59da6c003d6ba173b39d5ede888a45a6d037d6d7e6cb4c5bd9b63f9a405949f4da767c211a1b5e0f7f3246517e2f80e9ba88f5cb08e2d2e5568fbed9ae39a49f54d819e0530b2de07f215e5449e588b9f18eed008a0a53b22963644bb0c9e22381f1cde8202e5400e76ff6269cb6b8b269c5a646c700bc0053e23da762e37ab0628f78948d12717540e333a93f66ad26aded7e81951cc94c91f43319008977dce04ea49a239db9557f777e7301e8511a6de060bce6d039a7f13d84166f0d7657c2cc7f4751493fc00c589ccf5fb4c08bb9e6c3610d2fb449956af572c5a43ae1953a204dcc3c720a1d470f8b261b7d857273739434fafbbe04dacb28694d9b9ba04f64653ddf50b1e05c9806980d8663a454e1c99f7950da25f80c44fadd4c3bf321ba65d073cba52157494a15455472b9fd920dd1386fc6d5d43a2ae73c78ddb4e756fb2e8e715b3abeb18f54335c3f60e3fabbb647bd88262ecde6b41a713adc9b4124e07f7be95d89bbb3491c98816143e76ad3fb267a302c6068a51b47cf1ec9ca8515b347bd9804193213c710fc8fc67d80475b907287da3191b49719befc040dd35cee219175d493305f72d740e8c7b0c992afae54f645e95c2a0ece5fa3381c66c9fbb24bb555296632ba961cb07e315c3ab5dbc0b6bdbe53444aa28ac78303f7d322b2e683cc7d1d2d3410b1c5baf64c8cc1d3d4a1b374becb072c073dbbc8749025fa1d8ac9d4d64a4ea22b2f2de5676d179b744934be0a95e91dcfda82be36cf5f67e396b3837659f33528d9b6f0ac93e6cbd1685d120b887e3a7a55085f25b62326416e365e257b38b378631048a2bfbafb5fb87c03aff163434e1c2da5c21cdd41c7ec862b6ce6f21ba30d4f09a467019d2aef26ec43e005e6ad72706bf2a7b592aaec18a80044a1c9fbe41a1260ec5dce3b92cf5a6ec4df5926be0f1f53faf885062a286ae4b0eb3ef8723698a67e6c8c8e8807e885eb70854d6c8aea22944230d43648932bd42542d47e0c31882b22d36a08eca625174564a13e6767c1067f2e8cdaafbaf587cc46114b381b276d5bbef71847b2963146ca166b44c172a2efe760f77ac77965437e55cba4ea4ec988e3a10162f90da502d9324ef784c4aa87cdbe2335d17e16d898d06683dd709a64156cb4ad731613cf02284b2c6740f74f093fc08d6eab45b251e745dada69d52141dbb1fa4d7b88b2504597379f6a1d6958323c88a102db0c956ea8b0b568b1b0fbdc17a8bb61c2595c3cff2b2257b8b7397234b8abc71acb004f3fd1b7636f6794b1efb6ce5bc386b66b6fd0773a1d9eed8edb7bdf2d791e5db27c57fb2d11cf6e47b5b229b295ae06f2199d267537001ed03f4ee90293b1edc1b9f1abaa36f8249701bd025f31b9461b434a8eac743db75f3cbf59bcda531efc8cf4139e7dccf894a0486a10c3c50c9af16dca50b1195f801644f562beb03ccdb40036db87a6af675b82d538a8fca9dd1abd21113e0c781d9b30fd807910ee0b6588a6176b5eccffa2960d9a1b930ad6cabd7091229e5296b25cf9ce811c8d157069ba2bd2432778c59d2866a94b809638d46c6abf1b40bd75f45cefccac4e528c1a0ac7ec127017d15a81187ac8116fe5493ae5a6b05c461907833bac0a1b4c667df0c8ed66dd4080e04acd836f598410d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
