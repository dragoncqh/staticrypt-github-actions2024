<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85345a71d71ec2922d0374aedb4fab7d79a1ed9dc6b0269a765eab98a5c0d74f4d0a40ee63ab87f9ebc22eccd902ca20b32e8d8b22577617fd68fde37d4a6bbd70b3817f883132b2d2a0d961f1c5309d3c4cd52ebf141ddf7476a3f01beec4324be194438930c5a97659b5316a34f85ac5c4ed20afe656f8e92e95350978f0dc08fc2377a6bdbc95bf16051eeefbc52b5f9e0b6fe9f3fb002281e0fac55a32f1cd87ac2a18c906df6b96ea4e03460e4acfaf661197e2df3aa769c7fd6c8fd9ff10051adf7fed99f41eeaf7ef7d78cfc0193810ffd93355b0618dcb31ed10e2cb252db9a8b11cdd199495a0186f563962eb19da283674c392b0250133730abbe8ec3d3f98d65e3054ebb6baea2f069ce2d9958341c9e19b850d966987095abde601efd8346e78396db10bd01d52a4a487c95ddfd279c17c84cbc42466fa8d0e15cab3178c62b32a9403d2d3341d45d3d06fa133048d0f536a1d2defd8c8682cee7a5dc061c5407316498c0644da579c48e1b73d4b8618f29680a1492b55bbfda396f6c662cf7f15fd4981ad43bf807ee0ecdaedab240b54c8e19f040ff9da2a9812784f8be83c6fa09e7c54c6a1d6ff707ac44bc09692ca415983259656dc8cb47d95265a5affd5318e8d9084953d4896eeb5cbc951454e15365362a1271d53edee0c6eb8abde059ad3c9accbc8628d5967c8dedbd0a82f56779872923bc37396b8cf5859955f8b3b2ab878efb80a76965c109f72e1dc43ce4e1c690a9e554194aa94c5a35fb05f87e71ef6345d8a12eb7ec8916a0d6611700825b5e4d15908d1275d985b4c3a628d38fadae0adecaf59eb3bfbeb23d0aa559af9ead6e1dfed9af029fd6817b2fe050ccdaeaaa8d055821347177c8bde6b511bb3d1bab119431d4db91f5e6cdd73b577f3103c5d024c60f347dd926541e6640187eb4b2b8420ae7b133824cf449452cbc2a5aeb86f5e56797a774ead86745a7d3ea6b0288d87ee8b826839fa5989d326641c1eb8afc939ef5e7041abb21475d7c694c915ddff8ac48c95dab7d644c54c1fd182b5a06a18d977ba221a739119e69a88a54507ba81e9269e7948c3fd2f6852b02dfe43e79e8f5129719d6e25ed03af4cd1c9c863d4896398b4e22e0f2cc66b1e460d4991388d6bffdb6dac574b88e7b3557f9974fc5bc0c6b3bbaf7cb282dffed80722034c75e04404f06c68467e4d3f7c1111cbe899bff269381d667970f6910a59158a15305bb7bd188dc07652b072badfb578b133286a705dbe5244664f92372ff35de8799dd14220e7f243136e786d09d4a9e0895db0b0035e202077117abb11085a916f3f4d41ce7b3ea26caa872449ba4a05c4d42901a26dd2116bda31dc0c9948be15675fa74d69b4debed9c4b4cf8e28cb0dd8338aa227a6ac5a157543a424e43f71dea30461e96d03e8782c8b21c4825a256bc5c63044468857ca217b95b3749cd75dcd4fa1e7d96b470f5c9b2c91356a9de210921bfe885e846b0ef47b337b7fb0e8f5b892faf9758f1b7ae792296d7eaeddfe1eb05980dd457791feaf4d56bc09007d4271b1b4e356b29a8db3f19aad4d002c6d5fb41d385e16a590d6e05dca422ac0eb44d37da52ab3aa9e5dcc265c1cb56ba1b03dd4412935c89932290f92fef06780b640c7be2ea0207e847517e65ddc114863c9792524105be1fa5edfaac520e12852248b12432f2eaee4da603730e7eccff08fc304df78442d20467b9abd0cf891bd890100830ef0805f5897fe6b69e4fbe63d12b20fe27ac3e6de04b3c1f5559454e1816de1e4cde7cd406a9d41e67ecc0f289a0da03ed04b02999efb12fd2f8c3c45847f3809c09a1f464c7d7c212f87aeb5ed726d9b45ebbb25c589a8b48e5818dc4b4d6e49992100fc2e68c1078bc1446be239b03436f428d7f213e9174601c21b52394960954f3c273c48283a6ab36e5a771d2e0b28a4e4a670d1708aee17be9710d2cf057124e817d82430556c597dd9a7364c0881dc17e1fdf8abafb672985e9896750c3c359561a4e4dd6a921f7c1674f99ed1fd01cdc74b534803e3d257b0c91831427906804736ec5389fe1ca265b05d03188a3c708e0661de1d9714d9b4ad0d4d48a0145c9793e446fbe842eeecbb22566e6fa47dcb07b0fefed6981ee352ec6067e5bc2c9da68f653d928c8a96f258f30c555b0dda8fe76a8e4761fa857e242e96ad0cc8d72a0a9b280af7495c736ae5696f1bd8c31f9e996614ab8fd3ee2a51080fee58891b9e0215a1ec18c3f2d7140f7db89ec8e0d39dffd27d0e7eeac3be59a9d3461a833a2ba1d756a3ea448181d739979c4586c659c527026f23bf672dc5cf942608f6894bf60bf6a1a8716cb025581c64914b6bd0b423a737b5df827ea40cc0a40948d4e0037ff889467cde9602f955e3ee1c31efce41e50b2ccf5cfc6cd0fe9c1bf0ddedb9e67ba4f3ed9a36f1bf45e8211d9f647622910e36960f4eeca0cc5ec7320323e04d8dcfdbe3dd26998f85178d6dac3947259762fa58c9f038a5e3f9b22ce53bea23a508216403b7c388d21b89c44ff440cf2000e9021e630422360a41843c9eefa5f8b6fc807e2e52258862b6676df36f8d1ffe117aa219534fa89ef63965e0aad60c3dd4af00f12887d7cba892852f0d1ca2246cc6358a94591c2a12bc37b06f1379797fdd4426edfc5c04083fac1bfa799089b55bd9e7a57bba4cdce6e2a8f8c923a41ef47e526cb2a9add5204bf1a0e5fa4578729e271b8819841c59bacc8e8410adf83091b16d0f7def7f54d54acf68a5d93fb949d8bc521186bb117b8802e203dab2740bb7b038a6c0f2bd9eaf5aaf158cba58bcfaf0d76054dfc56b2259ec3420e7e0b058a631007f9685c9f329f3a4164de7bb3d92aa60bf13494153c4ffe46d9cd673a2c35e75ff92ac060a6ad81ac201f6aab2105daed87cce093d3e4838448e9a5aefce6fa81f9afcfbcdfdeeee4467e181aef4aa5e7149de40d01a1e8824276de62809a76e5e09507199dbba7a196a88d90cc7a4ca4f09d213e2f091ca16c075493fdbf8e5c38d8fb806a25c32c61910f52d008694b82c05393f194574622efe40d492c8151ad78974410f78d186a51c65627ce71d70b823a2023fd70afa416ce3d9b2e9c18caeb48d3784e70fc87f05f227dd2a273bf1f29b847b206c8f5dc35927d48062043a48cd59d8e6bfda8378c71e853717f363d3bb97e2ff7aea9530f83a78fa6def3019189f6fb282e486e4d86d3dd030228062ab7e3ca46f4f7d242e065d5faf7f9d4fff6f3e031dc7b1389349ad297328f8ab6c79b549b327b37048776bd4e2e3df72b8463d0dcdb43f21166d6744384f420c731d2764af7611f659ddc73ea0bf35e278d18e0dde08aeeab0081ba7fc0a356d882f75824d5e555f242af420d18a5892a538e6b09f12be9a4fa6c3ef404a0e4c01208aade7fbf743324de0543d4cb10636d93de97f6973083a138670d241712c0231cf94de8cc49a849dc3a2e7ff18f9a70e1557ca06cb64bccc5d42c937ee01c2ae9a09bee3bb2ef97404f4524d30faf444637dae45eb4fe1601319f38b2007f0ccc12f26e292465b7d02d72cc58d827fcf3121c924c116a5670dab623f642d6e08454719b36236d07e6cea46fcba60b5738b28210e360f5cec46d51e456ef5c4e6c4a60222760ffd7b81f75bbad758866492bba2f22af0bdbc6ed0e0dc5ada4d740d5196005570546b8349983154332a3c53121af87b1df4e887a982fbf3e70a9399ec6c747fba221190ce3ed845d1baf9e7ce2ce20e7d2d2427fefbdba447f1568f26fcfdbee25b721ca7898c4505d26661639b95e39a0a5e5a8fc8af72693336aa68c1f20246fa14632698aed94bc5b8ef77f88e31249534d7fcb4552be2bafc09a21a951b4525a9b407a6b64b22da9e09d895a3aca6551b10f235417693559becd14b29da34ed8bdd4592550721b9e7e32cdc0f0d8947f992b2ada08e86d27c3c470da71aad7bc055d17ef51826d434c30b5ed7229fd7d6903f2fb3fab04dea2cd2ec910a74392e0c9b9434865819ed4755e2407beaf86c8c64b50a804f3130959db2ccf47491288a31575d156568981652e1f62bfd7f7281edaf97258dd6ba89df6fdc408b518a3cadfe9b2b14dfc05196c5a5545afd6801a4080d3d0ca2a6da2d0e829586f19b896f849b7095723b0cde8610d98cb76f299495805e0daf541e22fd814157ed84fb5e42fafa42ce9876718e11d7188f46a966c79b0eae2045750a964cae1da2fb9fa91d7b09aafd4b85945b958ccb6c9293de9f536cdc96203e2799881013242341185a82574f396087a6c2c417f0d82fa5cb3012115cda558af5841a5e4acfb820e27d17d578490365aea0d4956538f98dfdf981035b9b4f8fe9d0d1c8279fe2d3943376a50492143e27b17e13be3562cd40fcddba25a0a66f38a11a1e9a19d70d9641cf9062b6b4ae388b6aee1a737bb12c2c58ad2f4be18d683cf633205c411f3a9f46d56cb8d042a46661c35ff4e7dfcbdd67196f83226f588ae2b11e95d1ce53cc25c30b82dc76938495bf1a6dc2fd0ecedf58e4671762e986bf2577ee09898efb3d5badbb5df826b25392fd655f5be077d60dae3cecd84a8e1747ccd605a8205450386a9a5f28c3aaa3410f34082790c51fb25c4e2bc0f6e91b1874f0743d39ffdd8bd0a2e3cb05b57f44c3a813528fd84b1e7b380374ef9b5a2636ba7db4a3e2a07799e2cf56065d77109cdc75f55bbe4a28c50a28384d3bc20e44b368f247264576807950994dadaba7c26cd6e19bc18bc3acb7e8bc6abb4788a55959b2883c7feeb2d40a05cd08b3d7b911741d29e6454bf205b45d01e19f1e12b2ef694f4ca03e085d624297a685f63d31792067a21565cef2e295601827fbe30b5f796f19660a65cce97cd256fdc712dca0611b04814b7357dde9f5ca70bbde55ec2d0e6f4ae0d4aacff1471634b9f63765382dff43133828ed837bc2e99a4bdc486c2bc91859d7cea580b4dd87771e24a4e490d11ffbb67a4cc7db06480bf377da8ac04d5e6a341c8c92c8c25829bde4793217bc7bf763240b049e66a0b1f993263969941d82ff5c524ad6c3af59e333a5c74a2d6fbde73b8a9a5e133870266a2a306a0a21b0d72a3c984715471be949dee16bacbe546947fb585e9a67c16d068e9a7861dd1236cb6d85abb202a1f2ab0af40185b4a8f5d8c0417fe50b9c8959a048e245f33d508b047902f1827a8cd1ae1e035e813f4d81c26f271fa6db41c182a1f2af72295265fab58a276e1808d9ad0ebc71d6c47c89300a534ec362eb21a1f4001221b4164d1ef2960df0343a3e386199dbbb53e4bc4c6bac1df4fa058f792b6e23fb0ced7c15528e62dd36fbecf4359e30d6128c9ef21a4a06ca56da13288b7f29461828026dc77f59fef47b5e1c85b3b223c4ca5faa407b997bd596b8c55bcd01a007c25f0fcc79545f7c17c1fc1b1acfe976dd906969b870f42f188ba9cc5537036ac4c7a40a2b642f9f852b726116ec204ba2177134ef06dee65c4c7a836eea81625cc4ebd1571fefc96bc6d7a7f756f86b45ca13e84988f0bc6f21d4c6eda33f57fc3ca11ef218ab088661ccb64f4bfbad46a1e60694f7395f3f7f07f8f9e979c7a2909b78f2087129042861f6e1770240bbed13e02b99f6fe90f4674f6201b29ff2f0a3b27c501651af358e4c6e5fbf4dad5028b7cf0e943d0b161b6db37be3550fac1805de698b59821897a12c712058479bfab5453f2ac12cfcf3e6bb78c44178ef6451aa5525a4e867dfa02b452031d01d108459dd1468a789dd350cff80b0ec1c8d837600d11493a395a27089d4ff75ab25fce00761caef9e5169f07701f80058aa49d623059a29df980dea485fe336ddf0237f00502f552b9903b4f80d4531b65a6c7b62e875bc64a070e925acb74e6744d56ef63dd56756cc915d89425b855a42cb478bd0ca4255fd94a861e7afae8cf1faf5671699bfb1f1fe9e338514615ffda3d1675039bdc0d250313062e324cbcf4316116bd9e4b1ed675c095808e120cf5cd636ac61a4c6bff0287082a3ed43f16ad5a6995a5ff6899e5f9f7ff9753b132c452bf742d0b6df7e9ebbf26133763b01dd904f0e62bd9b9c6beea95225e0d1514e027f84193c3da75c596e3b1a287f7a941ea569e63fe0ca684d255d92aab61be25bf84b1103e12acaef918d974d1277c3c82c09ada78ad7d92a4f15086f60cf33d27f8f7b0b9bfb5a0d9ffeb178febfe44b746ec9b583d0a29b88376a35bc96c1b6889da9dde779e57e0aa9401727a3a2a1486111fc8dc2f3d3715cecc310dbf78a2d6705228a777e2c80562d220883a66148f3357218cf6c5858f71384fb0d55e8525c74ed49de72e06cfc970f339f4b9945b9802dbeefc39010193d89e3b1deab26b131cadb29872ea0485e65b26c4864891432b8d88c8e897ecb68d1d2993fdfa2e7251233b9dba359bb3619b610c0ba779a43daaa079eb10fc4322ce9b6c87ecaeb9fba9055cdd118bd515536b6b3468b5ea586b8f752867f4e144e4ec18dd7d8495ab0bbd1904f1b6bcd5a5eaa9ed30b9956aff1e3ccbb6b50b91ba4b6231687ab25ed61c615be537a1fa48f1b768078a6aff4c39e5d8e9c7288db4d4ee1d3b7b37464acc490fe913e76b982a3b09662f0062fe71dba09a4ca469293b18dcf8e4a6ded8e06e4983d01521a1ea5a17e292a7a52d7471520cf465d779bcf60ab27bacdc9dc2c369da8b7a9597edaf0a170e038210347851663ce67d2260ad799ce8d340abe7af49b52fb7e6241f6e19520738a17aab5d0fdebb9a826502f4bc60ba1682e78d590097938204b5132d1c166ce9c996c9e2f3b65892284319bda61631b780dc15bd19d7269851958787a04134f700c9a4d3dc9be0657f62e7a1828114b44470ceb88f97ad323167d4abd7a49d7b5c4e81a6a75e46e4910db2661700611465f7a5801f96b3eb3c064d8bb3be25127f37791fbb238fe187ce6718b96ba5d683e8424649baefd5a34592c9b7cb3f83ad4ee56665765d6089f623a6d075258ba8e84fb826eabf44f169c7627ca8fe67470338b765f9c1f6516cc696f7368edaeed3aecd09b6d11f8f5d1f2400e399ec604632d0b6c061ff18d87c6545e07a100b9127bd2cc374343e6fb50c22350114e9687b7bf0e07dcc740b45f452eb6880288de582abb974b862810853c6d8cdfd1c9dc6eaa944732e1a617fbe248508489a0bb83c8743c8ffeb4e6df3ee355a4debc5e61de320bc013018e75c21b81cc42486f40beea74869286a8d4845755a4f0e0d77339a7218c71932e43e67f5483a26af9d81d56832ce1f7aa70d8660c4b17514d31009b395e6b5357e67f364302db60337c7143e89030b9c5940acb1ec7bcecfdd95868aef0f6b4e167df8e8aac04deb7a870976d14e0d12e635652fe255e074ed65b9c6205d2f487e6ecb3d34af8012ffd6118e6e00a31c96d53d15bbcaa87f839b7f4d2b026ed0a02a48ec14fe2baaf6d2f3ddc3fa82022ae7c24047916b87913c2a8cf236cb12c37ef5c6e72701d98807c970f2e5488b9bf9cf6683321400e75bd1b2c0bf6b95e6a48d047fb3979b664f494a814ee997f9486fabdbf4df130e5cf8db057961ca01c2f92a3cb972d53f1e6ef6a1b7d31fff91d2277bf44f07ba3aded4636c104027513472e885db4fd82380f260e1e9d20c345064e5152a48f7f172e7a5dfd7b1fa68674d65df7a0b54418af024d7494d8b70dd725cc939e7db7de41142c9b84274b6ce0528f61750315b90bac1a97f748e048f4975c385016c784143bedac5606d383a2c19fc03815f39a498459d2d06cb32ffe6810fcb41ac73c07cc6a96be30fe594fa794492771eaae3437220f90fdc3b8213896c058156f1d261cf32ff5d60590f96d728b4d133f67338204103d5e8d1227daac597dd735fbb8d37327602851d6284ed82fbb9ea38d22f84554ab13de0679ee39644a33697cc4ddac75ce6a6dcefecdcc6ad0e5d257fc8e0f1ba1eea435f5cf4d1c221b2a782a2142a5f6708481cbe6332756f47ca4c636fc29c9eae4f03eaad745b9d9a4ff9c3e9004dca12a99139cec3dd2cb2e24af34e833eff4d0e0dbaa5f0e82f977c693a78592782ad3bfd3e078c757f93fb3151f83ae2f7717dabc03b8bbcb0f0f981361f627332c2fd1370de3e322e35a77f1d5dab653594721f215c05fcf24736b3f266da3eea578aa807a85831d36232e1c8111a983e93176f72e4d5c958c588d2f593fe10d183cd1db93a05f7a5561dafe46b4ba631c099c1622a4239ab0acacba24fc142dd4a814d292e27317ddee6ba394c1f15db2dd6239515a90dc3bd3c741274141c12e139da4f4b7ca8783448a5a21d001649db29ab945e4c24d8bfb274f78e17f76cf4986952e81a9135256562cd77afb453390d06929ead6830009c710d3f5011ecc3ec9ffe7aa4c343232114f35b80ac26009796b86a1cf63b670d58f4bc82d4bb7c63e63f91a7ebfacda5272575f5ad830293f70ca4c10406d4538f118fbc2f757e237baabe38ed836343f6329b72a306d90b69b5f2174fad6477e90168d06994d011a05693c947f7064b907905a7f7f746c8c86c5f1a2d248e6c906c5752c9d31e0ea105ba8424d3aae0dc72c1650dda5d34ee818778fb680d1e19a01b5bf0ff1ef5b8c8363ce3b6db7e2664c443bac674868ce46102358c502ddf4fde2bf8c68edca705d65b94091c9e4457ea1ee18f72212e03562f4097e9bd9addc2710ae9daf10a6d2c0d6c1595a51345e23e828dfb2448bf073f72e08b020bd00da5c4fa91b95781e1e1975dab8c4cdd56014e214f937e33c2202cc7df411d8febb456a99681fdf747d7af9f25f9b444b9e38aef7583d0588f8bff94b8db7d7470ce9abcbecaa07e03c8b4ed47094d60714fdd9030395cbdc8d2e8b713a01a40cd9c1df28846559a38f229f9a28b6aad19ceb80047c188aa422ce6d6b621c192c6f146cd4157dcc96a119afee05fa7ba3ec1cfbf4d88e34c155a602f067e5b7f7937351107e1985d9a6571ad7ee103c39946323476206bf47147937dc983caa7ce1f2f46e832b8ff6e0668e7a70a27b70919a466225f9f0855e716e84126ad1d6834be35c4b73ade30d596d96e9525635f1a78cb2940d1659420704e45bb1388d60a1a2d2ee40d96c040a3d3d55fc8674b717a94ce19cc85681779cf5bf2de260cb86032bd2bb138bcec85f6e6d4036f4a40e0f8bd1c5630e2412c84116bad6c2e6e2ebcb30e3cedc1d0204e4f8d903cee3edbd4f32387ea0f6c8adc16f684536564856cd85065375c2df78bcdcc59ce2f069fff1bd10bdbd91d2a67513efc320cccb82f7c045517d9e55962873296b53cf0bdffa75aa1ba20a2f82b3085cd66dc01241e2ce82ba34b32c6a1357075c5cf9e32d18e21dedb841ede6172f4140e11fac3e22e374eb34c07f6d42c822f6dd79cfb02058bf56e721b9cdfd9591c5d540f611bc04d5fff3e6e867338c755ea4eab4318a4365a33717ed8b8b602782053ae36d97e1c7113e66cef1c0d368eb803943c7ed3c8f1a92b810456a63e54f1ceb0fad268ee1b7af5e4b032d45e336dd3b7e9f300d79c41b1a7f54deee4c6b92ceb579c74f0d03b02bc4e10f45a6c03041950bff7cf5d49de92f51f6ac6efa266cf9b42af2642d2662b5dd486a9f4e8c7638258308f076dee61078a8151f76b71ddfd1e2494edbdd14f167e1b0984ff400f5fe0cde4bc7e5bd10d02dbc13936c75b751de10fd48cfea01af0ed958f38921cdf94478b8261b73265ba7f64d13d94440216556af1f4492b8c29dda14ae6d4bb2271a3a323cf779bbf9b6c7acbb327c05a006f33c6006a7cf191050570f4568733e0d54ea6fbf430043988970143fe46a1d69250e721748257d848476ef442951516fe27edcbeee3d3a133b019c2b68310fa5251eb1e144bb920341964176d1927628ffbdfb46e415ef224b7ff192060392b94333e55c44dbe0e76ed63d187f3382025aa1819b2b4d2dca37e243538488eceac92fb36387d9e4f9b9cfd0380a2fd522f21d906ec52cd8e59ead7c4d9d9fa94aa30204439f6f610475bb68807ba80b69681a8d2519c12d74280ad64140e978e7abfc1e570a821625fb76867cf943ce6239434a62ccceaa836e68d0cdafca1aa458d6ecfbef9531d3c423905a1e1e072806f891872db46b33fab3c011ede259e8a4705c1aa21f513ecc9aa1c7d329f431ab94f46d46ce47e9ec18868196b85ac72a5001e50f5ce965c674511f0e0487c904f5c3112d95d90c6b229ab2611e7bba2942396c1f8ea2cbedaa265f50d7f571c891ebb0327895df61b81ac74c2fcbd2cb1a92ff6f50d7a4b17f20a18b86450a17bd8d2f1547e4793d6102fa72a2c7a45cd048800ed87243b94593aaede0cf17141b5b3253da22479a0e764d33e46dea77fbe84d1250e9e973119888e625271a60f5d985284a1cdbd0b952b7c4839442949117b296d5d754c3b371a9457b1ffa704c0d77735ac942b402fa447563dd92dfbcd9b116a4ba16a9833d4b63b13498999b17f8d3376c53fad97cc6566384ed1d70aa34288efae606df678bb3feffd657c6bd3495a7c271b1b89ab73eb1297e326c5ca8dcabcc1db84592bf79f6163774aea7821160d0d0db89f5a27da250a907e102f16ca5438a5463b362ecd10e564e9495a4f0d25b450e2437fbbac1c162ae0f2c2bdd48f7717468bdfdb76d9e6c4903ad3696fce05faf098676fc2f3da70bdcf47112f4be41060b66713240315f27d7be7c66b089ba902b56ea8b6937c0cb162cc55005594d0bf3e5b4d2120b954eb5dee1a85d69d3ea3a02760383f5ce97b3eeb43766ad5ca0acdbcb516bb9e789f67315935b4d66bfd61b34919253d8ac1d87ab9564b4144ce025659206161712e40d5dac0ab2a10a8b7b2e66ed55282f4b482d5e945f629a984838eb5dd4fac1ff9f90bff8ac384f032be66420c3388396fd38cdc1614c0679c3075ebd6d1dff2c2eb54399df34a161889769378cb9db704cb3cf976487e82739184dc5368baeaf2a0116a0008088f34efe8fe8af075fa4eaf2d04930ee68aeb6d787744b2d2603814dc9387541f4c784420185d8783f9a8278819996d225190b2b8e193c8c5923b9926cc86658f0cda8a5b81092b719cdcf2cb68698117d0da6dc3ec242d3b7fdc86111731b1b3f2a52374eb520a25d94dd95b0ed4ee28a6aced2dce294ade322672da6ae2f72eab50bd5d42edaf9902d8e4503d4d7d36880ee3066d57e22fe039486db61d8092bf58102242d80d09d2abce04ec12f2c2b81b6c25762f9f0416ee9531aca68ee5d52a89a25420a2e901685bfe88e7b3795b824c90fde33bb0f00991d7ebc02a7f507a9c02de10a83a1e0a041b93bee93cea556fac950a3d544855952fad0d56df8f414c9322d74c7252da7b4662341a4530d204a7e97a2c4a61ec8fc67fb1dd5a2c849bbff2327b4b15cb3c7367b274d6a6ad161d5224dbb9e03638a8f120f1e7e8d9c8ab363080e716a32d0213b47f5e38e63d376fdf4c3da6e24547eaa96642b40f4a2474022e019eb0dd6f50b2aadf5ee8979298187049608a427daec3c0b5313b59e9f594d165768e25cc38fb4f94e8abde60adbe090b5383b38142ff71e92889187296ab5337d80f9689adf3f24d2b0519dd41a24e256c958b94b44ac55b396617d0effff8744c22f1cedb8ad9bf97a1f37f878ebfe40e5d53c3fbb1a53482704b4c90f48635fe23d6959c4d0a2f774a2a712ce7d5330e01d5c20585c2ba208c1b9aa74796b14bd8fe149a22ff546309e17c6a7e9dd99c31e59f3236763d221d389d31d9785052f040172fbe280941f125a784d205b5888e35da6d042a812b676b1dd59a2caeb8d2e0ebab7b9791308243ff3d9d437cebe60c2b1907582a530a44981d7d1e1f3003a1d616cdc0464b7bc600db295fef1123fb2464485d0af2e50164e22c7fe00ef5421c7f5a371e2d65e0689691d2e0a94f0820665e5f7f858c9f1f95dde9a7cbcb189d222d34c9910fb4f8fd9252c6abfa5205243534e42471a9fc16c4cd595ec708d06446060a36320df42056dd1473b59639256adcb64b5e2462970405e6a80110115eb86fcd2c078dd0c2ab3785a63e0938bd2729dbf64cc644cc48daec4b685c6d3c08c9941b18668cc74d0d6b4065f88f5c09599e8531ea92d15eb79f8f14410c127aa77ee9380e74b6a1f142ca96c2cf39b0fd81184f1e06b5cc6354aa55ee34b2f2268d0b80954c93ee59fcc419d058fccd6a29ea7277fd8b9857a31f94c681226448ec6da40c16251269ff126b5b9cc4fe323d24c6316ac5280d5fd99b69c4aa8e5739e9deaa75b8a238ce525b6b1e9e8a12928b801f3c12e590748cf4a12ba815c099f3c8aaa4708ac6d6a1f14bec6d86058153a58b135d6c671313bfcedb644bb279baea0570d84d270c541fd9701849c319d7d0b44d9c101374b520f37d24b5c17bc969cecac5f9e0ef90a5712ce897b1689f3d3e7179ea1676d8c4cdc6430c2c3ec96fead361b6c03b169b4d2625573ab252ec1e59730554465c4052ca123fb6e0ebdc96f5f792763bcbd626f68d2da947f2d9e420bda2ee819b8d4171686e5f1a6e0975e8bbb732e3f2e4868b85aa77e09ea37542e4546ddb20cc544a1fc4653c983649f4de70a9fa2bd51d5a7ab4e0e662c062a0cfb9bab1a66470eccf326adc4c500076b639b94117be651e6a546746d4b92d0c99a87267f8fc0bc7102e80bad97b774dbfab8b21eed4f2b891b7d2d5e085c5cd9ed92e6ccac10af298fc9b90a9f0c0125bd4d69704f0731d3dcfaf3de4da20f3dd6faf9f389b22efa8bb7428795b8d42c5df95352d0e353498cf9762b69d906c491b536f90c98c9d917bf977b89d3e8666c974910ad3bb16d302304c7fab43e19c9ffec448b231f6f0fb4e6845f3bd01bc6733cf43d5f8597813bb697a6dc956356024d0b22c929165f27f8d92300cb289416ae2cf07041ea31e07f4e074b742f67e505e9b064fa072d590cd81224cf8f59790b753a9bf9c3966dd8e710d223bc15827eda4a2499fe116bb5cf1c2a10e1dff9b046bb9e87ba71945e7e46f107a800fbd4c475253d2049088869605b7bac29701611eada6de38208fbf7e4722eed992f11706d7e1bbdfabd89e94eb7ecbd86b3ddda5fd72dbe187f7b94fd9bc36db1b1e0f4fff419f3b846ff45a490f680a14fe1bd688d30977e61f3e03c7ab2192df81de27b508e56d281690220c7769d22126984efd886ed3e7ff0490ec9506ec8d0a06d746a81993f897dd3a8ac744d8251fda884e460d8c2fa021bb40ef1916623bf8a66a8b91e2a5e8ac8702c7a7957fd9bb18daa7bec9dd4a87c08a121f534a3e6ecd24321b857d593adb20a9475e60a635a6b43e716c92c5729ad0494ab2065317fe233583f96ea655dfd355a01bb220fd5a3abb224dfbc5751ed569df39807ade24e787d9edba77af23122006fd60d15047ba7a075abaaec4b54c05cba637cbf050d6ef15dcb2e3ead548da6e9988523d76c5cb20763cf31dac3bbe69513a6607f7cfeb19dbac32de1f13bf4b4269f684b7459b0db1ebc76a2b848702d1d085a28b40fda1b9e41035759319c7c11b05f89cacfd8de68a4210f56ea94734bee35f2db9d7d37985152128a946b37702efc3dc5d10452b62db710ad2c5facacd4272480d602d04d02d5a67a9e2d13d308301716823f5716681720231f65df50aa4154f414838356137e396a180fef03129980e81fbd7a40a4f0b6ef7da7f02b358d5ee9d3a8ea5d5e873f7ca3234179cdbb7f4ec494fba31332eb0f31ceffbb50533f340a43dd1b73263c0125e52006f01444d91f7d53cdb066c1e8bc087bfd0302b974b0a459293c69e1ac9023b31d2d5fbb765a88324ca797912d50185b3401133c1cb1042f26e9ec0c0f78072d00e20c45558c513a333c149a97ce60eebd56c253cd178cd073bc38ae2db9878b46a427e34e8373c1d7568f54242cc9824754e77fb101905a3e15c034fbf34382b94ee0b6bcce519c1d8e17133b7ad914b7866456200815e786d3e0b907851cf2a26043c1c1c312ae4051e09aa3a09a4b2fd0f86749efe3fe2fa4276d015801f961ea67d9349defcd7a4724db47f9b41eb4f6b42eb6872f36f43ddd42241e2cea56e74460f61a77c62a210a4b3e041234417d50c7046c76313fe5c822abbb8ab5bceef76afdcd7c339d8a946437beab92d0be6408dca0d801624b2377a3b5ea202f16dbe2de71e48ea654ad6e848f0dccae6aa38c7b3602824ce9458bf84b5241d04b3c38915349a9f87e3982c88e6b4b89e945b334d05a9fc58e7c37e84b9657ffe0ccabacd3048da01b27a41386f39440d2c80a5f9a3964c3a5336a76baa923fdd4457aa9458bd2e63b55c60dd0597e5b68ccb2d6459871e78f67837b127c460b23768b0772357c7bd732f94a503b6a59c6cbf6e701d6f51050383faf91a023047ffb541dace051f6bc3ddd4da3c8c9a6975dc3d65779bf3cdc1bf9e9a23dd45d82f5dfa04c869a24c6059b5f6058fef4cc571abedadbd0f0803386766014bcd8821410dde4e516e845e87517111f69e567010f4acd4a34c52d164f896e6e77a2745fa1551c85c0bd085568086253934ed9a4c9249f3b6745a2da1bce66ba6ca088c2785bdfcb5c7b0ebf8273a4a92062036223e3ed77490dc558c73ae1051e235f1eef70f26b48a06ec7886b7fce894ada314b5504f54661cd5f4e1e185781c86a5c4b8b4a7a534d796d010b5d7044f255b1ae32f71ca7991469a42bbc7803dab76c3edbfd83e862391055c2d9a2ec15ec3f3da1a9da46a30b606d9e559016afca2d7d908049da68e6467f342dde81c2dd2ebf095b64d055f37fb9f8354cd2eeb5e1ae5c6d8cf93d978bbf074c8333f7f1e85f8e59a2a02bc5820fae02de51bd767de522e16cbb32a69cb4a245f70540d8327ed5df2e9d8f854c143f931a2f39fc4a9539c4b1f2d2cb9b8bfb3f982d896c0defc47b4d7f0f94ebdc87115771453f026dbcc036d052e62e9e262ca0b6b27ed05233aeb455da369b9c4645747b095319c5a17fb9cbc7b5142a7105c416ba8b9e08b50d138dd68f33fa3bc26cfc16258432eabd6775e9d689a531e7c87ddf430dc568a2436fdf78c0cebfd3f4b81e5abebafcb2b90072223165d101f1bebf99926a068bf8226e3206a5a718f6c5e72b34f960a04eac462303dcd910e338ba93cc738a0c261aecdf305985afbb81babacaaea05c1af0acb8a59683aea7e387e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
