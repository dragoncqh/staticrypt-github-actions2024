<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d29c85a1c7d780a597ca493f237963616cba6a8f30a20023f5e00c0a5f9ff667f57107cb9167e91eb7148dc5f8a45c068e2b0f83bd95ce24cb49ae05661dbad175ac1af5da7e290e0f85f4aac446f702a1c959c7da2876be04a150f6df51c959c3cefa7092d30bc83be35e56289d7234994722e4da8852f6af9aafb29b112001a649522b3acae576eff5ec42ecd2f366892198b588de859efd611c427fe8e170e9254b830d4ff373b067ee6680374be9edc9fe54401373d563e0e51135914dece20099786ba18d3d40466af4ed2e283a2518fe226dea7ff91ad7357f832e3db90871594c3fd6e10889528a62b03ed369b7160971a16cfba6e2db1fd68c95f1c8b2f349323d5a4f53aafa9aad007744ae117a1dbf72fa731e816ddc70fc25ae5b99632d5221bfab06a657f2f373feee7df9fd4d757770d8d89fefc5cf5ccd60b286d41eeff1c3c0437cfc63cf38ee8d3446898a49563be06faf594745b9184cf98304514ed59c3c03c5c6748b40fb570aa4539829da6ecb177181285f48c3c1e7da8c9beca82bf8a26dfda08aca9b8d15879c033a7c31bcede501b0fdca0d1741b60bc295d066181afaf735b1db5b9616c33b5dab66c67446c32fc9255f932fe9e3a59c02034b72173cc5ba6f3d44e9b700a24f1b358fbaf3fa8fe9c06d604888a84cb5f664c9a518d95b238ee13afca15eab4dfe8ec2a24d676bf2322b42a91687d83850a03a53702eb758518f3048a1900528a6f14d4786be7da463ec4638fbf0157403e491a00b3e1c05081ae3b9577726b4e0960667c74191e79b65fe55ae41f538055362c7f679eb9100e5fa4d23691f59bd671528540c6cf1d0da5f31f80eb010a2b03b42f973325d098fc3808c68464eb9706e404cca648b3bd08f93634d8cbd7b904c45afd903b5fcd142437a4671d3d8347f4a55ada7500e8b588037597ea76067d0324759d84d73bd19e11edbc6721de7684e3c7aa4859c295332ab50d39121b20af0e434730a03d458c2d49a99450aca2e72d3c02cb96fc0c360e6fedbbe645956140794a960488e511275a059b2d68fe1e9d970102e87dba3f9095adc3388fa2afc4f31daa5bc73a2b43dc642a009f9e256fbda3bf30ead6c34848aff2e31bf4a134adb940a16980b885c80ced20939e89086971cc9c18556754626e7bbc420c9ccade9620f2fbfbd38198ae663a401794a046f5cc468e20cc706082c5e2251f9c79d03e35cfd7e472cee4023c49c206617685ed68058b13bd1c580b36d0f17904030b10306694d5ddb3f21e57fba7d9b726654f0dd743add52b834f7c121332496cf49c4166a13cdbe6db070e7b9d795f987876830128f624072bd0ecb844f600e23eacd62e95fd566fa670b8daa37b15f21db956786eebb746b0416bc9ad86d675fe3d263dc8389fb4ad8024c7f2086fe3ca79e158656b1a4a5ad9982c8989b293c46bcd9ef57a1a55fa8ee06c1092973a0e3e5af1a01b48ab409c545157b4c15c4763669d33b8694cf5bddefbc14c6c15d65e055f6a8f7209c86fb735aacd121b048e4fa78221b1e88a3c9a8b53215f131dea3d9ab6e9ea32bf3a499d680c8f30d63bbeddf537c04668df1a42c237911fe374daf8e7ffbb3523c4f39392f4a19eabe3fd505939868ab72bab08475f0055f31980da39c1853127f5434da466af44fd45bb127620686945d1908782fa9bda18dc0c5155db196208b16aea79c1bbb24df9f0253dc90dd7755a7a19571262e1f81e0807462ddc14c58c287635d555565cd7e2541a22a23aab756a7ce05662e5b140bb1c520a13d14917af1185a98aa46ef7dcd1ac7738964bbd180129af44c395661cd988b1bda50904b8ce157a173c71d7e78ad3364504abece4d49aa995988fdf41067da6eb6c8a84a15e3c34b018d2218e5c75b9ba989beebcc313e982059737712177d8c3a24a7fbf790d4497d398a5f06984e4be8aa0e718a6881445c074a6f16c908ccc65afa2b69c9977934662b806bdbf85ed5c5a9ea12b4607f8974251af85af2d98da8d0d039e65e89bad768b3c934ad680bff2ef94a409f7bddcc2ef19f72fdbcf6280b33228fb11a2d6f552df41e7dba3e1985db9de863950f4b157f8f1b4007251a29d220956ee5a6c29b62999039377c0383b37654b7c4317c9115861fcbb653bda11acfce3890be7be6b3b15cb5d066a56c7aaea6bcaef85a1f7616ef5396e42b9adf94a3e0557eb9143c4047db307838d6c8648f287c99604753fa040909f9675002f022a3d0aa7236ec6513d6ac767d8d999528ac2f3fc67def9741cdf5fd8b0d862dd83640022773f8b36026e00e811bd460cdc94242161b6850bdc991030fb59a4c6e409671ca1d0544d0082899f25aeba99268597e6d07c4774e7a0cf997422ee346b06128cb00f722f26a17ebf445a584f3fc3ea3d55610d961d8a959f411f1ba7e3f7f91dd4c60d8859bb94ae480efc9504f50e302942a11cb4f0479dcc51091920ec6a4f6be37be7ca88b5f236a27d248b7bf2763f729312fa2d11261c463f4b7ab97110bb0adc0c07443f56dfc6f7d3fd65dcf971b777d128401be10fb75b2bd160db78f269e57a6268c0b57994baa6c6073442b98304053fe19047883af1bcff4438742ebf681179aad54c78334f93114d28daa14fc141a201b61b3575862039d3258ddedc7f92204d0a7de0eac87e256ec8f7d39ea0728573a62cb747c0e33493d6f1350fc78a1655b505562809e951a3fb6c5810a9fff2f1d051f300cbc33225ae7b6446aca80123d1ceb8b823341a257520f9cd567ed8a1c6800821f4df59dbb78306eab594a6dd49fcf5a9fa20a5a865468ec0729c0c271f9ba6ab28238586a93eacdff4e621fa0e2c332f1e62622e34fed3600d8f502d0146ce238464080a137587a379e75e21ea40ca55d18370a282b07ca11c8be3129df1c32379b8ff7575488948e532dfb7dbbc5f0ec34dc9cb314cfef93cbcb8afa4d185d87116328f2c5ea824210e9ffc3868a3a9eff67e924d752f443e3672dc3dd93730b294aa0592b026151644e8d8942f540b75e7d9322cf56fa406a1b1ee0b673f83e32396f8bac40bbf43a49e0afae158ef1ef80ec57eb918b3a26946992d88acb64b79e8701e23838bf53da2182d9965d648f48c2e8b2cdfdb28de7a9cfa944a117ea0de82debfcd1a197cc2ffaf53c7b769731011d429da11d93cca088bc2e4a821f5370d73f6691d0469b219effb79a8e31520b0af444e5ffc9af08ce9d1bb323b39ddf7b6362d4872cc81aaf5e8bf8ef5a70e67a6f19e7cecd36b103c9bd9e11cfc1f029cfee15d94e70931943d99b6c3bded34f9697e8325b925611501ce9dc749e71b3f13752b44b5f1b51cc5a750b652c20159737d9221ad96875360bea153cfa0635a6d3c04097a1251225230fda12844a777afe4df2c87dec8d4b72d1a9417861cdb0f161797e98303ee07ad2b7bf385760c7179fb73cca29f19bf374fb7fcb0f8a48cd476cab225ae2a0ffb86b71da3c9062917ed079d683cfdaad5892a18deba505d30558807a42814b05f7bdeeca3b3d6fd46d507d964527f45ba334caa7c7ff0a1de02b75b9352db7b4348d08e52516d8a5e9b89e63e2007c6ff7acc531d89adb99b0078c183695abb072e4d5530d25de15c4c0bcdfbe6e14fa4b6b46e4df43b32c24534c0676d62db11c6f87d3a141ceed666ff09198f084bf3ec104ed27a936cd11c0b698104dda34c0ae14fe87cd6c49cc4c1c7a43e3560b4ea3ed8a4c26c0054817855265dcb0d2a375f9c0ecb2c3aab7bb7a25edb9d6322bb725a48a39ae182ee1c11e3d4c12ae8d80d0af5ce3e67f586c81811752d9f0ad612010b740ab37e6d9be1655ac318161ebf75843f7c00a21a9657cb62f21e754cb6f81e25fec7fc69fb007c981d548870d1a564b34a027da0509c27fd018865fb1113b8e22d5321bca2cbb36b2729776fa07217b8ea21fe6817142a7845c02c032529b1908469b8e43a4affcaba5d95964620a8c3abc3754eb2d97e5022f097973d55b63e1d0f028dc73a2f310706281ba69a79bc87fcc1cc5f522cc6a9ff132b9993d8d3df7e3451d643a9957f2aaeb5aa8f2ee641f948d5adefd2e797722c594d832ad4c19d297eeb20b64515a1682176cb753972face7425c3146faa277c49ff6af15cb17bc4480fe5b94cf5c3635a311744fa7b575793a34edf7b69965eb821f2986cf62c585e101c61efddfb23f3acb4e3f344beef5cf2d9a2bf9a316a6165ff0ad771c4317c051d5ba70c3c34a084ffc30a803a04f693b2a70d61adcf320f3d78bfbf0eb10d1911e48dba517d60d692ebcdabfa652b6beab81f851a2368cb25d2d84674436a84a9f59a91ac2aac7a9e37d1ad3e7b9d207ac1528afb812df89728dbf5c845809fd6caffab6cd46a2cf94dd7217e02839fcca460c815dbf391d9ade3b4f6399cee80a357f7290b5c4532acd5d2229e19800eee26cc687e44cf71575c862c69f7450cba55cada34db3a028c66f5bd688badba290b479da8e3e5b30b5fec44bfa2414ecfffc9bcfe76462bbc45b13f203f731872ab4b6ad61443cb7959ac6b45ae145aa144978825a23a6012d5b97a110e0781c49a9b4ce279f9ef33eab1d6b04511c1970f5076218db93822ff9d5ea62fac9a7c529b250353daf90ef13b0cae0b4a8000fb653c641906325d6f4199a3219fd2c224ff8d144076ece20694e81b49368593597817dbef3e2a94ac760f6b51404bff1b1fd19d8f9038c9ae9b138a2f205b0e7255b53f20fc420f79457e93931e057e4a45ce8b9cc16f13d8541e0c1e6410beddbff13662f02b6e99559df7f5a6b781c622116521827b6c79d9581523def558bb24828036f8a453c87001f229411ba1ec1bce9df2d938b90dcbee024ef8d87bd37d043817d6ecbb44ff696c52f144c90930c6ed68c239846f39875d1926a26d398e34af9ea718904a2588fb53cba9bad0685e2562364475185ae137bb5abb06b8219a85d6e1e28358b8ac0671ee6b6963ee6a79a5894026d05bde06e07fbf6e525e7df203deb6a1041b19f52c9e37fc89c031aaf817f4369faf4c685b6b7de39f93fdf0fc130a27b06f658c03444cc45e38908c1852df039796f45e2b1a20fdffe4bb20c0dacb12a3b101fddcc5651db4c7db39f396b1ccc8527973592e5673caaccaf5d9a5df8f018972efb4ea22c5d5202ef9b4bd91f0c2905fdef03e42a5ee9788be9d0b55c4e4820f05c4f5696f449945da84e2d68c35dd25c693b2db548e64029360e5947fd0150613ac3784c8e21235797c575b33d8a2b081a1bb8f9d70d295c6e45fbba2b950040cae47820defcd2a7c644da7a46fdb2a2f0387e29ffd7a2ebd27f1c601700206012d1e99dfb3c1f02bc2524580342f8a7e698381e8e38580ceb88c06921ea70944503c91ebd899a8702d83ae1d1733d363d555c632a4863bc45f4c889647bbfa6ca15b98e793bc141fbf316a70c2d95cc5c0cd9a89c8e52d78f06390f72cf7779074493470240a675f9cd2baecd86e49bde7a2278b1715dc364130d0c01b1da6875912f4ad11c8691a7fe1be41fe432496386e1e7ffffa5d8c57c81d77de17488b6092904f523931e5916962d681ba5a16ec3c9b809fac25f163a4e3c92df0515d9287a32148ac43cd1b6c6fa7f913c284fa38d8739ee8cc678a0611e6d2a142a70dc940bd2b720b060606ddb880af6950b881d2595a3ab5119e5604d5e1206ec94c51a50a41d396449072b6c2b4384f81934f3c262be45d62b50f30be58e4c1a61c6b29358e5eda4b5d0cd54e3fdba87f197680f6ad62a185e01e3a4c73db0304407fb475e778b545c196318d50d1a28b983c2bf3875aaf9ed33a2052a7d2b390630adb934e070e3d54821fb7c3700d8a1e8b4683f74aa622ae83fe3db69f4cc1d781664c6d17df91b4eb023b86b597708b95a4b56e48801fd930519cc8b7c9577a7dad510ce5a16f7bc5666926bfde4d3368621166c099d1b79ce5e3bb41a3138ef2748fee086dce71df7a4b0448614d52b2cacabe4a54c275f126a2bb426c9c58983884c2269b3e47978e1519f81f3a52deb7e5d5e9b38905e67fa9e547bee3b61c6b154c13f8565869fed92573441cc8cfe0637c52fdcd13b31ef730f90cda14e1a3c4850812d26226643847efded3612d7268fd2dd02f6e678d1204d451d8545b36166d917db8a3caa470817b4fdf59ae411865e7699d0e16cc5d22537e899c7a331e0f9877a6cc4e47c64c2896c63dd3a76175af4b4680a60107d390a861654b0cea3504c10f5342242f2fd97c00d6d7d4a8de503b5dcaafc6cdebb643d0c348c82adc5479edabcf99effee6466d7186cf7e88c8ffb5a9d7f592e9352450fffe8fc72f58de963c614d0df0b2a2149056992f454d599d865bde91748351c31e98c2bfc0f7710378312a50f00d1a6ffbd79fa48f9fd044664c060b91b0c824db7bf6a7d3a7019ef7e43d22a6454b26181cbddafc8eff96def0ed4c13e8ea60d296a89f8cfea79e8b5644b2cbbbc92335279ab001ea15969dec9794b78ca5f3dc9a86205e97fd61da21cc3b5c16caf5fe8b10c1ea466f482fe195e0ff80274c7324357bb7960cad41736af1a9f6d141cfda4c35417e6741936627c687bfb513fa5b19e7dfb52077b1cbce5ce21b2e0139c04b0e26a55102141bfa19310689b00853010912f43aab178d2d19caef35aeefbd393f7f45f8ea129743ffb4efcaef0da63932f8e01ffc405253a910740aabfb5883890f1fb22233ecc0eca67c68bd9cfdc9226e69140948a85305ee90c5cb8e6aa27065909b2a61c9a14c0e1857be9e0a2ecd546369370db1e28f0fee9badc77056b8d2f436741e3da218afc4def88c3d5410ce8c814db9bcd3b4acd6de348954ac05f91767f2ce4a5a0577d2ba8f5b7e5ca95e09157e85e9b0d958a1bba0d9a25ed738272979a0a1a2f7d74b4eb8fdf9f52fc169564b403a4b28766d308e3115f06ed907b22223da995a368f154a1bede6c374b2f12320179a05356742a2ebaee435d1b1d37e4c1b3ae2e5e68e3fdc1134fe88bc0f135aab87bd328966eb301b7ff805f489057d6d964cef112fbfa288cc92c350657ff6137ffec6b3c54da3baf6c8deb0987866c62a3af64eec475ce7d8a7cca32672bb465ef1de14576e19145169b64c5e7edd8c568d6a55ad960a8d8acf77e7346a7ee1512a699c106bdc905be87e39b55f46b006d47827e86c0f9abcd1faaa36f9516d4b5be75efff4bc76c31cc913757bfdadcef4570c1636d4580f1973b123bba84cc675332a47a88734b893a927da76afacea91a548bdb1be7eaece198c4d88ba91907bed8387f4648216641b3a20be1f518aad94768b990b968856a2f90ed9882bdfbc0905d29dbde39ff9349ac545822a2e462024d76328bd2bdf9da36e1ba3592dd788fb388449aeb172510d55be3720403e9a6c34e1cd6bb23e61c7531778cb596d3fd5954f00cfb9fef824a2db7569c8dfdef8fe8843d8fd7c835842d0378a5afa3fb0d3d625a7946bcfe9ce7f8a6003a559a246a3db51085209d13232721d794e5858316385fc5389a8afb0c14aca9696efab2b984b9290b2d4d6868c00b388e36b1749ae0c7efe492c2c3746786141daca6c3200e253e86e85265ed11b296f7173353e764fc66f14174cece23f93cf7e92a038f469a2d3e52cbcd97ffef78ec7f1d9c244030aa7a90e33903b67ddc87ccb5f783abbe7903284cd219e72bc1de11f4fc6c4c723da610e471e945817afa52668337982d221a2ddb0b9fd8ac8e73b0389a00813fbe3528b174add32657905918e3c98d9c8e92c895772e0564cca520861956b0a65c814681fc2994e62dea195681615388b0cda353611067be400b932754d48d6543058f0fffa1dcd2014fc2f5db87c7697b499cf9e0604aaea610f044cda4997ec9ba0222d98ea2eff3a5ee25ddb6e205164836bfc91df3c0c23e173f642cca284e791977f87c0b0952d86fdd6f3c3e1119c9312a5648b85805e9299f65faeb0f742d354d3832d1d1d7e1d0d8b6bb971aed4fd3393d1015017a73c1c46cbfe07abdb278cdfd8bf5a1a13583a435b6eb5d0c646c1bc055b366f54c8c8c7c5e1b364041f9c89ab302b86122f09ab7797ef216cfb27e42cbdb4c796f96f4b21eaa2eea6898a3aa4f949576eb6aad2923ff4580354dcc362a6ff1b3c25613d475ef889f42dd7f2156fac2f967f73f1099c7129120ccc0a4b38e9d81abd3cc7129eb0e88e2166877ed644a750a8939f7130483a6495530a817459753ab01403b7dafecbd6e6b3c9197a10933cfbc63f3c4aa47670ba75f0897d0cd77de673aecf8ad7d1634ea32ec071538c2419776d7d65db5813b6b1983e946014a97c6d7c305ceeb9fa5be7fab8a3d3c41e7ff3bc97d511ada3f60ab8158d143d9d22b68e00f3b10bf9685b40039511851d604d5694530222df42952db2e4ad594c61374eb980febc7efac065f1bde6f253d50d806ae8878c94e55490b99add103ca7c71dfd2a20ee70c56ece28d85a64e6b85db7a78bd68eb2829b3558c96265861d02a07dbeb09b9a7a2b6ea783d6d87c88b3853246f0c9b4818315c1975f6078f183c639c51c7a67c15c5b648c6c592dc74fcda8c99346551e291688ea4364f721da7c718791982bc347667b1f206ffaad4ac5ad36ad2458b6bb32f618b34eebb9a0af439fa1b691755fffab74931ddfb326dc9398270c39149ce0932339d88ae5a36642566b0ab4a6b4ec3a0c61cd5263f495e688d5cbc547873b02b8034801d2b28f14dd18e4d8a546ad00a3d04a804ef8a644b258b30d6f09d0dec4b4446cb82dd7be3bf042eab34d69bd6903c1c85c42c3666b9dff9c02ca53255043533f1a51a1e9cfbd3b15af4c7d963f62110717c584193cc91321cf3f647d157159e8f791b8d282efaeca6489f83687281aa2d55033e89bbffca20a0d510b9791becc4018124a188454f3c05d69fe34d5a7f526642c7883cb0517d658f82ea51b798a5676d342439f4a9046fcd71a757fe4a67feeb77a4c2b54c19698f190566a904d3314a179bdade9f49d48fa4a0e80e145e912dcceb008d91f78ba27ee960bb01bccdeab12d367843704221da30e2cf36af4e5ba31423ab35a62d852f0deb0821c935960544d04bb570185f420407073495cca7db4d251815130eebb51ef95586c871fa143c86230b63354914c7fb676c1fe31dc5cacc0c74af0de15a321f5248c51bc102624acde474b0d655ea44db9a4bbfbb2d827251e028d2d6320e6ea0642ebb020a17868ddc6793613fb2987afdea96b622653a2183b973cb7ef3248b78b8f98e939f2aaf60c7c3d307131a7bdceff66f0034fb9e5103d6a0dea500445f9eee8ce70ce30030590408341d57b028ca3c3d09cc0c163a6cb97fb3396be99eb821b1429c13632045dcec3a1a69c97d89ccdb7b44920b2b3f8862d883206260620bdb529348722e94bd795dd6bbdb08230c9f443f98c119360bb4a1f5c99526710f767224f902983f8d61ed1288082d17fb5183a54684161256635b48f7dcb7a995370f0d1cb677bb6243c29d4b2d90fcf41bfec5b1e414648338c0a0a4d8593935578df4c1192caf30a53b4dd5d1fc835a395b53b0f2cbb460e841e569596802d7bb430fed5d76c63bd0c3717eead6dd9a3a809ee41522e1fe80c86da6f6f81d266e303868569d17f3f764fd9def9a95eda7aaad5a714b0cea70bfee31142cf4e309c6ef8cf082c9fbbfebb05c3c23bcf8da6b56d11cfb2a0abb6c4892cd172e9bad8a37a314142416872575846a4aa15dfac4e5d8c9945c19d0521d4378a3a628ee57e9726d5e87ce7a8bdcf7d60b777dccc6607b7a91b1c4ddcd5e09a7a7d10004cd275bd7c4c1fbd53aeb790e3710a655fd8e991443a5594abac93876603d6a3eba55c4cd0c98e8ed0d4eab413b4342f82ed9634f267691f049eaaaed26c62728358d4f649dff82c64993b16ca1eadefdc636c8ba6ba6ee425fc65b2a851df6107ee1a4f879a2567f3dc8c6ba52331005c95973d4e36e43a1f04aee49a07152d5d9e449c8bbc87896b4d5cb5c26b8ca9bb79f69af62caf95d57523544ca461c2fc84e30fd3699ddc931dae0cb9b4a9c980c38d97d0bbed0cd367632509c9344fabfff01a54dac1ccdb79bf51bd6c1000482a8380a2316e9d21623f09a2b66fb83e519e0cd9287da23714e96e3b75bb9c0067d5089b8d2c3f3109c6ef716e724520168fd876fd4ee95b609401c9a24ab0371f016e65dbcc8911a511196c3bf46a26484b1ec6b30eb4d65609e8f5f578d0f28e6fefe131e5fd1af01a768437a58ca79ad3dd461db4e70160a9fd0275abf2f46891fec6294b8ae02586ff3ef3759faa6062516f1a0336d891c64f6d21e123df23587d396d8f4587a56ab1a008a1252874831a74bf01fa9ec20f58ebe5f62268a642f7abd5c83b4ace3059665c81cd253ed1c9c9b512de22d0a125e8cc5ed57b2bb9b90d043f3924753266bdbed9da9779f123b243856832460d31d3fc503267c3af05888c265606bcc5af92d927f726f5b85dd908e69c43f317a3e927ffaeeae3100fa810672d4a0359538344c21a03103355baf52d885b2ff90db16e1b5b10b618971e313e643bbba1421bdb8f7be6dbd91517770747c1177b2f5956d16aea87d8de5bb33c380ad3c125ff4df9368d8825cd7ac5b82fe9b80c17319945f5a7059efe0c589a09cddb7ba9440ad21de8161cee91f6d617e80f9ea13ae17ac1fc0dfb6dc0c8928bad086d91c3ad475b534a56d12ed95e4681df6f46c5759eba72541ae01eafff884b808a76957647a0b4d24fc29dfb18cc469bf8ea55731b576b15d3aee91db33efd4a5b27b7e18de2f0f60ddf7111836b2eedea4fc3d3a5660ecb1c98bd003e8bd82fc02513a663f8cd40f0a7d71d77d94e8c7ff9f414aea7ac99d983a1e0d2106638c98002a4d04c03c6da123dcaa702d6dfce2be0f5dc94a7d10bfd5d3393da91755a6f5274111e7c3958eff4c6f55a8c30e92d6f26769ddd03e82ef4b305049d36990c414ff0c6a34d2cc53e5b4ff96a872e1067b206421be08f6a32fbd8e37f7a389303d7fbb81f154f14b9788a0df1aa2eab1a63bc8132a62f1db23efee2fe753988c9c328388500d77f81a82455e586af9a08f58f3013fb8b903c95be1154af3de858ede0505ef4d080d0c8060824a02d1d67b6cac1560455db024db78420f6de4f7f79d7d4ad0d7debf966a02eeda9c24a44fb51be37a0a91ed4ecedd000d386dcc81de87f5cbe52c69da3fded8d127039fb8dfea7772efa03b37c4120141485b5c4647a6e4d8d4897f5d2176bc7d93230ed9688082f230e1108bb4b12112e2c86604beb9a58b4675a05934ef2e4b08896c0d32d778b646065cd79dbba64b3bc81c80433d61e6182c243febf7c1f229892bec21664936550f75b08b265806486f2029c8f6eac327e0b9edeeeb40a010c91e03a09db751b743c222cf67873c5fe48741225ae7a0893da713f7db7ad4b7423f0ef92b11d458533257c3535edd064fe68b38770b56ddd0ebc8826254c4957c2f707c77d77675cc25b1e5815b0564f673f4303b5928b91b1d1b3050362bfc59634d396c852b12c4e3075772a040d7c21cd8e20411b5901276607fbf97a060b3e8659ffdd33b661bdbf489075784fd1ec2d2ef0cfb767344e9b44be667e42a4d8d350eb7237c7bd38678d766c4d2015c0e645e0c0e075b892ba0cd6e3bf456e1a7d036857b71c1ee6d5bb03b14a58b1edeb5a197534d3e5d76c7495b8424b2f05daefecd87f5c2a0dc4f45006de357403d6de178cb6e81dc067edac14d0fe699313aec79dc887f7909f2840a9e4e155b7d6b9451a68cf735fada2fe2410e6e8c2009de03db299788b9316644e2a96d3342b6028bee3881e202d7f132b219a1d3da85127a5c3555b7fb613d0ab958b5316dfe696f31883a002096f819899db997b991bf5f1049b2b3216544fa622986b160247172f91d59569fcd2149456bbb392c21a7e2899fa7fd66512568341fc0aa160f8b09dc4af529ef0846c798920589c2f3fb1fe5d180b09b9ea500ee23996d1315d45fedb1668db466f3af8b723e53e785e3a2351033f6f004733e74465e0f34fee5b4950330271142cbd53b081200f03e9cc4bf6c43d529ac6b9361a8226e9cbdb1ca9d27c09dab8db9323818e6ffa967dbcf3675749a0e89e01bfbe1e7df7fc22a290c85e686b0395ae7160d2d1a9eb3c7c0ce31c05f66d735c2150e7c08ead1238de310d18cd0ca9efb48eed2d2a3b3977d6ec6491582dca4acd4a78eaebb10820496fd9fd960d2143e0b92f55f97fc2cda961c668161c1fd4e45eea0a29be1fc143ccce32881779a11e14a0977bf05aa7b8e25a25dd0060740fa45de63aaf60875e6153228c83202539af316c76fed8dab76fda11524961cce784a3f71016a2aa6d08b616c56c43d8276b426f6cfca4ddb1dcd6c98d118998a001cfc253c7932757961533ce0961067c985b5ec5cc3f94414d3565e4794cf63346127b622b9c3040267a80a1514fccb7b11bf256c90a417951eeaa65c2d8d4a208a1400d04b369677147cb45614fc12bdd1538c537bcd374b04b6d87c5606e000d2574620060a7f9c539db53d84bc74ef141d1b13a60a7ebaf4d15ff0b7320790258e7a9174812109388dd8e217b8f0e7f59bf94e8c6f5bd7c73ba072c01062716b9faec4a54499ef3d5eeb43a56cb44197206e261b1ee82b5681195b6967420d4a71d96d660793153d73fe0d5da930f85ec87e3e030ca2150141453c3fb8eeaea3801b0ab92eb3cf3aa47c1a8f26e90afb9e43d4170acaa94fc105650c004504554f3cff90143b4f9dd3ea4b8a2ed374a7580c655f1e721e923a297fd827b9f19820d400cb5f17437ecc81eb7bbb50df687894fd51c655c5992edbb2ec894f0f842a8d299a734767410beeabfc2f4a79ad93a969e372a4ef32d2ad920521a51775434eb70deec82f0e6bc11eabbcfeb1ae6df2c9f90dde87a70d50d277eabbcef85e8796aedac22f6b33e4d6e0054e42d507665f57b20ea18dd21e1de42a4e45ba7e57468b1d35d7b35ea200cc83ae8f87c4c0c46483169ff4f5f942e41bb81e81c4afff88bb1df9e6a91a5df44577ba016f6970dfc2229b89719a08f53026a5fb2f25c63018349b5c33afaf7da1e5a2289f209352f66b8e50af6751c6437ccf2b8d8fa502eab1c6ca760b8f926ea9a95b4592ce3edb39187d97da6d715358acd273aa4d8783ad95f7aa8d664c8a9b50c684b056d907a420eb3a316daacecead49a82b45651a5fb4e41c90b7ab8010feff4e9279df6552a24cb0865e7a5f3e3f00d783384e3654bf9404dd95522f23a1ea012b0833355c410cc6ab5d499d7e5a4d0cd7744befd4caae9ca12411f97b8b62c14f0618804fbf83487341bffb9f3d23e41e2e900d55198ab62e12a6eeab75a569e5f693ba471308dde71489a790554e3e3dcad16101aac191b567d34c7cfc9c6c8455fcbbff1a92ca639e95d54085de625c0a3ebac96db189653b037cc086d3ff3989daaf8e2f3b3e6a91a37a939483be3c53d80e6f9b49d8cdc07fe39d9f145fb086e9848b2a1b2eca822f429a2699117d4a5d94ce2d9440c542f22cdd35f5b07989542cc0f68337ce00c4f19ebfa8ea15f8fd0fb356f2fce59d07748735ff80a437c7928f6d8d821aca5bdab5efaeb03585915f5a6772d7917fcb6f20033672b87f4e820a4179ba017cb8d5aef8397bc9c1d4be273a0cc018aab6ee2678460a397d1315962efa611cd238bd95c27705f5cb40604dc18d303ef7695dd6a2bea4ba94391ed28d5dcac3d17e5925d9e59b7de4ce5ae77a9ae9aeb1b4602a45498b2bf21559f793ee7c5d6019fe13699652e7b9f688f15c1359fd5ac6d32f9fe068d196ca0e07691ff8228334cef737c86c4e584f53042cceb3f57a48aa798c3c01e742d73fedb64cc4da251dc23ff30bffd1cd519ddb036397c16582b6cc049d3e469c871e9f02756cb531c9b4ad36526fdca2b57176f6c7693d4f47dd54d04566dc0f88f3784e7c019c5303cefd192c9b4f4d38da6f6904acb3c644b80deb0ebb62c2dcbcc6c22ecdcca203aa760451f1a781777cf7c047295482cedfd83a40396f8ec425eadac585e2923dc69cb151affadd04f9ce71ec12eb21ec37cc8d06babb5f60082944096401dfaf6c72bd32b0df70714f79fba4c8e676d2e21b263f2e4dcd26a747577ca557c4f89aef2b469130ec694dfc254e3a667c8ffc8fc3ffb8388a49975cf00cc9e68515755413a7630a56f2a05239808b0ca6f61dde6a5e4ff4e117139741b79843c1faea1984b3390e321fb708284a3d09b13b1542163d0156821d1e4f52d6451469bfb84a36b3f8f659a4e1058fda086c21cd020e3c7200c10725ffc6487ef804e7e74be223f8dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
