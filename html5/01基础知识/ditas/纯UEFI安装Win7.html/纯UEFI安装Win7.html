<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c731c2577400863c10fa31d27eb6fd58252edd0a0414709657b392a7108c0e9b09fa379c48b8a8a4af5b0239e5d7339438cef36794fe33956f119dfb8eed6e64fec914204611ecbc437dab7c92c7fe17b0909fa2250dbe040ad58a014509f9b65da8e10edb295e33780a5fc74dfe84b725a48b79985926f32e9a53f1a48291a7c1e634479f1cb341dcb5e36cf6707f78265f78edb1c8c6a03d40f66f0de4ba995affd2b26bd519e4d87eb77bd6a10c3ac6c533c4e15656cd3fa3a2ce3861a415515ead5bb78840a1bd1bc84e1247f6da639e4bfe1168d11b6a2e4bc30daf026ec738609ded7b5f2fc8073ccc29d26a86d2dec3cd48af8a17dcccb2dc6af7ab6ed346094b44f6e9e8bb771022991281bc12d16b86838af764d9c885805009aaf1f76e169d2188ae92341464223dc7141aa2c4c125adfb4f685314759d7fe9e4ec576cac8771d24082717b634ea5ffd987cf2f7a7898dccac3681f4b8bc65933faebe145c25b955bab86d6367f91ed0bfac1ed2e31a6bea60318b495561efe0c276b4257d22fc90c5573d959a791de6e6122e947a21daac66237b5542d7193843695cb3dedcb868cdda9c77f711ff72813172b14880b0207a876b480b2795110d45f678f5e3f3fd5820ccb66fe0382133ec20520a26264e6c4793484c0eb5ec3091db67b46afd09de25c08feafbe36e650ed01f31277d5ba81ed1ed0180cd477db951ca080b6e9ef68039ac66920032c65f28fc95909b6ac3a5ea3c347038de970fc87ec5cb4534cf39fc16b1e3a9898ca0713d5e5dd9649a6ead49fe64e2a22b3f01c10dacb43ca5152e2035ccc294162925deeb4a7f97b4630d450176632f7989bdb8ee9a6ec101e53f04af522acaa98475cd9ee96d6cfa7d138a6ecaef931ac5fd5d1a015cc32b9038b0ec341225cb6177ed9ff7d4f9b8ee7d4521772d3ca4b92d1f6f0d9a44ca0c5f2d740f905dd820dd323143aad6cb9924c1525c0f55ceb0cbc02d68deb6c4a37947e512bfc77c1effe39bb28d437dd017f724247b7dce190238cb2a4b6f8c5dbde16f9e67afe954cbaa2dc5e10e2d629b7ed9d10a411774c0a241bbb4b6cd503f893ca22010ef97b73c1464037e8eea577bc6221609e9149ea7b81b3ee173faf611943cf012e461f3d2798b842b8671d0cf155f0d1a5d2d07bc388c9a3d41c8b627b396f741ec60e426c8d5f8d0292e3a68595670f4b1915f9b0f6a99430f8c2ed529c41b43dd0b8ae90c3b05d63b233bee31ed934f2f64c87978b5643b905dfecf09326594b32d9c7cd07c590930231360d184433a85d59826359252a1363d81eebf502e9b227683b7e860888bba37280fbf0690fb78a8e93a64dd4f340b972f91a3bab7f9edc06a23b21bb918647466f7f795d7e4d6cb258c793ffdc20688d54cfd3c9851abed79b6d401a2c79beb904016e7ca32dd20c4151a6142bac2142b741ef1be9c1e1d3fd0a5d3b0a133c8d3cad07cf88847e400ba53ce88e55856ca85cb13bba4d17ad7aab6992593e345f667919d4b7a8cca922fd8a538abf6177c8f038eca47118e27fe52cbf7e6d8fd419788bef471aa1ae3f969f3a1ec2cdb713d55499478710166191019a210b73865a9ceab1b8d2bd0d65679110b7f7d40653f2ab0a9edf376e28136a96cbe205a55434f0e38b817cd6f9d439fef88aac52866a3b0913ee22d3442bd68ffa7ca6a27cc8ac266472f7c1d5ba1f8d8107f1066e2a15328a568fd4063ccbbce3d393448d243d836f28826eef58b9f03624de7c0b4945248671f452271cf9a13cdd38494465b46a94af887d5c465ac7db5d751fdf532e2a795d78604d98b0acc28ba9034b639e2d7a1e7ff001e07561d942a306eebe4063483da9e731810c0cf8f00b9669c6df914d7b178e9bd0566f199ffe389c2bc9c84c3604b6214e55b7c64d5c9814fd404d87221eaf66bf3e3cb162808d1c6df2264a623b63be57af14539b67ce22735df984c9a7d14d4c657be41120fdd0612e26329884da46de18a17f5371f34546cf7b9397d82a3506938eb37ed7035ccc845bb0b8a41e7521901172a4a5532f21c18756a18b05959610ce80f512ef56be2e4a1c199e8c6444d374deac074d2503755778f1719c91bc093262c34acb61fff451b080f853aa09039b93d073c0db3da7e6d1444ea75610596d19f714b1be4cfeb99359dfafd0a129ef579551c1451b8b8b051c1b776a2bd0ea82c4ceeab21beb3dcd483cad01b6bef025ba76f52c6d6403fbcca8ae1d99a1fda3e8bb8c2ffdec0e70307741c2f3ed55d9e57bfd244ba976a2837936690010c0e97a470d447cf15a420d0768da6d1253a64d305cb6eafdf893aa17e8a367d5c316fc5f011bcef40d0cf62465122b0a9a3472ba5e0285b1b3ee127c9ee6dd28ec9d5441c6178480826358bd891316a12c07bbbb1e394145c4658fb00a3c8d68f024c8cb5812807eb42f914243febca45f5270d67455538e72e146134c6983683922ea5a24aabde3fd20d8d8a844405909350aa6396caf0a41f7f83d38e5d0ec661b01a8f4efea13d91f4d7b8e8caf20b717c0b5b31b4e1ef122b0433ce904046d9bf41835b5a00c4fdeca08d847ed44d8450d4010312c5d6ce7e6bbe448ef9a69d666438abada42ce9101147509ca3e25e2b08d15dd3db54180155f4ec75c3f96fc7049d612daef280004125d02d952fd16f446f97dd37faa300745cf80ad0ff5fd163990c151897a4a765c63f6dee870a7357ed35d629df5bd994f2864567a3e51136d5c14c18a9a9428487396dd9c04739fc69ef6d7890cf7cc44786a6b834d6a197c9faa669f2560b231ebc5e9b6931ab00f216e9bcbd2453b66d8414d43f573a14b92a23177b6aa4b2aa8b7b26ebe2d256b74a14d9c5c4f87743fc3e82ac198eed430d07e6a0038403592446d862d7cbb4b1405d5b94af13665520b4e48e9c862085673d5b3ac270b34a66a1466adf4a2788b3b37dbab2881d434347689dd7ea4e37b542cd24fd02d8827adf684a978c2a569fb5840888ceaf1bb49764b9634fd6960703d786606bbb640b19a8780f03bde6fba5ed1d0e485ca60092cf4b189d356902a6286c55cb6b2f142d83edfc67168e3b759fb0a3ed291b765495bff082e5f1671b4d8b253717ad9680c9ba182c55d6bd3092ec44ed4ccba715dabac68f95a05a2105770555a7a4cd206ca2ca9721e12aa5ed5c4af82daa6e07dcb00e31de7d4f2637d5533f046f3f96abb5348742303408feca7dd934b8be09f070e7e27c590954d0f4e33d210979ae0c193e1beefe369e38d4e296aeccba24ae1eaa82fb78c0f4065907a1f4daeff9ed259fa19bc51af3012d9699c24cb6bb0308e6bca2cb089db20b62d2ddaccffa296970b1f7b41b987c68cacf5bb8203da08545b7ca021e7dbd1488aa9485011f32ec933f1a2c63ccb7207b8de5fc5b57fb9a73737c1b416551832f624025402ddf978ff175bf6004dffe93d69aaae165723953d03e4bfcc46afec5a9a9a305d2d31e9c22f04b63fb8b6827495156fcbdaf2b208534d2375739a2b101268ecd5f77f6329c0896eda89c3afd69f9783b1f829205242c58d85e368a41ceae5b31a2790da503d8d7e8b45bc1b8bcac4f6c61cfa749fd36b003377c4fdbad45644b93bce02b1dfcede401dbb52684851cd037626c8ebcdf6ba8adb49e98488ff0bff63a5b268552efb9774361f19e6427848aacba3fa2f826bb5a2ad55521399ba32aed9905fc5e0fdd0624ab7d7c17140e8d12613fa2f65b247f69c8a84bd1ffa78a36e9c11ea112029a0b0ee4d6039e08ec8d9f62aa346e06a4528a54484a433c6b605feb97a020d446a2cb149b80f1aed7032b338a7cf585a32ecc12e0c8ea2775ce4889316b044a3d198f36eefa7b0df8d78c36e2f9d3d2d695b156547ec3b593f55759e927932d9f0d43248a1b4b0ddb8e03968bce785c467a7554463902087b5eb4030438b19f47eb9a90dcd1f27640be363045c5b0cbd79144032b883d4069bf547c9727ca67b6506f7c8d0841975d5ab44d0132dc81c00352c115184ff94c841f65042f043d3b9bfbbdbdd3516bc2ec81e194a1698cac827cd3251af53e9ebdc04952f6f29348ba62a799156cb72f9d770b1c2618768e06fcd1a1b04d6c95aca4928125dc9e5b1bfca6a344adc7f00eb37d0625b9c6155538b8460d72f22e74dcc3d24762190f050b3df7f698b058a724ef3a322fa1a9896bb56bae14f7f8407a4409ba857a1e3e292eac9cce8c0097d2738c85ce8e859d99cb0d89137bada9ee2948bd76e25ff46cd8bf42ccca7e841c00d07869e7efcaf56321d12c30595f1ad6f2ccf560b537c7e1427b5c47b031101b9f267f4ce7770706d7f59037b5ab42569afd8eeb792c4b996dc956163e7bc3de0d1d7b03f710cf3e6154ba307a5591b72f37454d31a81f5731429540622c264acca88e642afe392b1515dc7599ce6b0be91c34b4334bfa700b39dbcbe5f30a2cfa6519c1d5501274db3fa84d01769ad0d76f7a646d323bc015062bf8e3ec8c4863be43327bf0bef2cfbf1019b8bf3e51e22bb1e0733ebd3fdbff0aecf52c126ae9ff169ba8982c7e15680338c62f09a82ff5d9f70c6033df9ee76be4bf1a3b05fdbd79c8d912a7e22c5929d18454d8de65744d78fc77e153090144297ba82b8ca06992e7b1762a128413931bc4163e29709bc5a1088cb785842156c98b22b2a14d732a0607ffa8be49ea5e186c2b2426fcbc8999a878d94f7163e5a268cd5069a24e821861db61d878f2cdffc3170f03b9fc2cb92bf3d8a6e1a0c142e69e31cc559c0c47f85467b1c15760a1b639b2c0551306cd313d3158c98faa1916f13713ba7fa546077fcaf77fa9215012eff608c41d45b3046caa89269356d7d05e8854f3c5c8de0e60e7b4a4637203c158e5d04ac22170469d8e40be6489d7839fa78f1bf78b656f123f7f6e610c3a13f78050fdc49ca114baee84722390f5785c86ea9ba70cc1a7e5e53f6cfd726f144f48021c6d02e0cfc68ab6b9f848b8a20ff2be25af2a7fd1e0b335a91298e357166a0bb16dffe74666cd050098e2a99ea068314c7580919bbefcce2d76a044fa9b7b9550ee56ad6111b20dcee8b975223ecceb67310f8e39c9a08043f6cb40dcc576a300794475904ecd83bbd1b88b6c4e2bf14b682783b77d66a3ae373a3eda5808555d3e3f4ce263490352fef806c94231cf54f43e19141be9800019a19b8745f133c2180e998223020a7b022b0102b83340b371e64b74354b3482d376e3a7bb947874abd813fa8fbeeee13c0fccbc9acc5eb79024ea69f45f9aa98245c0112f3235ff1c7f350c4070649e380165630efab7a902b9a130e595e75d6d0e76ccab29665601338205ffc2c36126e0c0bf30fa1707a1fa7bc658a795ece735abe593f3910e18d947f35f74b53e1199d1bbcd30b1b646ef4c9c3165bf02e4c7bca107bd4adc710d3db3e8ceab5c07819550a46cad37a280668129ac303d47dc716033d56e0de3ff3da22bdf2a67a339631d5962b46931b7c7dda07db17c708b11d77b4ca83c4f951bb290568762c5050e756baa5acf7b9642539ae0597bdad687829098ac162f33344a0413fa8f4370c175a86402edd74f16a58b92c8c9df18cc523def019823b4133bda40ab92bb6fd4cc72000dcff0bc5a7b55135b32200fa1f4c561765b97919be9a379b8bdc995b78ef84ee43b8411e70f0db5515d37a103a528649c166c3c55c4a62b8f87a67acc741c5cba4ff0a39e8b5af770b2fd219634b7541dcd63023944be574184ce7f60f5431fd7037b9e1ed046372a1a5d118f5faa12b476b41f652629873d594a1208420c6c4018b31c62136f075af0dae80514baf4cd13c055425dc0b2b4bb7949ab65a0f7c21f7688831285ee60f39aa20c6aab6a05f2d5334272f0b06cf06d21d816a86b665acc0ce66bdb66ac57dc4f4cae32da0f83f3f7b0159653dbeb310f6aea1efe325602dc6392c65134d7c365a467f6f843ec368d46bea532f4af2af9f8e6f252dbe2fac9e5aa6e5df31e3de3727f92bcb438709ea5aabb97e40bff0a5b53782e0252de821d4a79c7493d80d3d5d13ac694c96b36337a10bbfbf5839b8c2c5ed9a0c19c87994a1a5c327cd0f83062e7aff24255006a2788a28511fcef3d1263a67f2913b2c6026fa1c6e389fda65fcb07f68e2449f6c5a2e930d98b7269d6fead4607808757841e86eccef0db70176aefdeb4ae0ecefcc39eacba1bb818f8005a19ab278e3b0c36d5152bb66a88eb2a2c14280167a5ba743a4817e0848265cadba34a6685955920d78a931e0d6f88a49a72aa5699572082468044eae478b4f647e0ec7a8030ef37640e61b1614c1573c7ec90a9413ba91ada8037f29c8542c6ef42e6b0d765229c5ae231cbe129ea84f417bc63ba7c8e53563bab1a2a53c04e2ee7dde8e1f28eb0cbbcbb1641d54e6b11b5820be87c7961e7c21f7cb3b67c326cf5ad0ca6004edf76d4b8f4d2405b8fb6bbce205ebaac792ec3c3b6be5d4efff03775d1cdc92b0e8f1c12ef323b48e66c90c854501087fc0127cb5339f5ef03c02a4b5efb3c5ae3fd2d1f652ab81f1be925d3536a6c76f29431951eefd004b7e401212ec2e3e2fb7a638f73b6132b185a5e21a730e85c7a75ee5071e30841af2c1dc2e6f3173de5200e86cd7854983337b5d0f2370a1fb42f19bda3f0d78c844c922fc4b191a0b7b35f8cae891d817f9b5e8708b2b3e57c9dcff73ce37cebde27a2b2b926208f241589f1262e888683c2429f7d1fc19becc7a1db2f0a6c1e0c1201bb7250f5d78da7506d719678c54b4deb1882c2ce43eb1a319e5daa3bc2af797a28acd688815da122ec214bfebc7bbe6e3c3e99a94477219165bd1e5cb96c68a0926adf4b6adabbe100c56dd8dc9510dc26ee14f705797d5fc4387f67b933be77044871035602ea1391bc523565a1e662a52b556f798be8593682695676201da87a0b6dfeb8eb30c841464e2ce70d1d1a126351a3b2e2f59cf9e406def4d23c7969d5f59ee43cb9ed0d3b51594f525c7ef4ac6e021d52163c8fd19ce35939633862aa45376d7bf223aff0d8dfb3628211479c6c355f28220ced595d9ecd58fb2c309d656eec01741b32652e1ea157ad9e9c1c80fd70301dac79dfb5838f1727a3071cd16a6034c565d6eb0b20a024db044b05485c4e9e70715c6d85d1fec5ba629f961727291601551292e96a9795a929959a3f1b8a1a4432e8adeec0a04cfd94620315dc6a43c169c2b00bd21916f7e702cb99976cf75b6ebe87912cf388b8fde0b1c288d44cccdd3de0b11b273c3103ed089a1a28376c351913f025ef3dffb6e7a4be1c448e78aba806bcc268bfa2ad6b52d4a99bca6ac0e054596adbbc63136ed1797489708fa7ef3977389ed5a9dbd72a07d33c9994b73947339e36e0e133dec963b105f86334a3734b28716f89cfb595fe6899fafff22bacea2304ac5696c624decc3ceb68a1e7567a335cb0288e7857cb70c60fa1fa751bcc59b6a9ca22552ec49cc29eec6e3046d944b006de39196ef2f45e72a381dd58fba89adcf9a47f7f0af27fe999a349e75a146a17c2da0aece83fa2734450a536364b0b5d5bf43ececf84d270b8abb38e681634f593af88f5f3668e4bdfbd518decea57048a92826c15ba50f40d3b98109739886c6b66fd2888f45ba9f17f93cf28ea0ec7263c1a03c8591f80ab0384c62376e801cd6dd73a014192e9148672ce0a80995b5353f20331e3041386dd7f2f6baeaf6cd48e66fdfc1da69a573fc73705f255ce77917c5139542e57f415bc046aa4a535525709e4371820f697f2d8f752f5eef7a977ef2e4378e97f6b9fc7323872f25475f30ca0f18e370bbf4da5943b37324cb9c94a85ce48359435cc136139ab6738df58b06c4cb7a2fd60784c1e15fcdeb1f609f3dd1730103781086576cec766303fb1d4c49953dfbad5a053a65110b101417acab82bfd37dcfe6d9f201b6d37bc39f9504c26bc0e18a53c3ad3229ef16f0b0cff9815b8025a8ae25d8c4a18562710eb461cbd5262780df7b4c72f8653ff7e078c74f0e62da9921aa663f2041eea12067e581e4829ec1fe5e48229b37a48720c16f85b7029bcb6fb71f416a8bfd8cc061eff204cc26d32528ee46daeec7c3da8f24130699cdbd6b3595a63f8db31df334a9a937f9cd5199c1b789346db3fc58702b9f2cf53b2d4a4dd47b99c6f5654345804f5a4605f3533b99b86f5f0ae8a6fa70d6d33920143651e779a22f5c87ac96adddef3def07e11e769b3531d89d6caee2ad5dee25f70ea7503bd4626d93c63cf01e7ff1706baafbb478826072ec08035ecb5bacd0d8caf3c33918e72560baf1fdf5a5cb21680c23e048b3704127e17988247ba1313c93eb39d7bfd27d1bc0d47994b5e23a5ccec4b57f1532ab51aa7a4fef3c957f46568867e1fbb4abbd4dc369894d71b9c52bcbddbd409d66859723a13567fe631c00e743d7c8e8299f4d86b805a6d8fa999f8b222b88d71894837d30a2d21f64d7b735132cd7274b02543334fd06298e916808a3a365d84b73676592b6feb44a58835f1038f54d2a8b2917eb910e4b6fe6c6e2ebb22aa06c97244bddf549e9f1f882f61aded5a25083ad87c7397bede630cb25f0198b9b8678eac28e466aa64b4d0b07d1c29abec0131541ac92e04ad025ffc6e31d1270266bde6d801d8f5b8e0d000073a4711f263fe65654541ddf0d3a1e960284a6010432b2e29bd0a7b8b4f0f7fc4290f59e42eef89b6abfefab793cb864287da55f79c5d126515ce139b80d4e403fc3da735f1fcc4f49cae0f8eb5616ab6423ddcdf93ad8715f3013d1afd5b0400ea0de292c9e28d45701399d5c103a50cccb9a39374725a553388d0db9b6e39f26f6c5c284563cfecb0df30ae51dc78acf7405bc4d9c724b89f7582dfcd04823bf21fc257e17131d2667119189239c1d70b1bd461ebdbe30b658ea47a703474e9c2fb563635259c9e7259a023af75bf1644fb3bff74a974a1efe77a540d4c664927a864f7e66e458dcf0365cc6ecb70afdad91100c34cdb0f19b1683fa59129602bcb376bbad309de5e3eeffbc6429bea9f02df80000a0ae3c0db68fd6e024f73fe0210126a416c4185b1213815ef7ca294256e580fa243fbd663ffe4ae1f63aefc94d752838f7196de3f72c258500a273abe23e7edeaf709eb9740d606af3d8b41cd449f7e32186429034a86141944fbb98ffae59cffba272baffb0caf58a000facbf9d79893df6b655af6ba143c48b7413b633d95e0a0d1b8691094efdb7a36f6a1d6f5f8036e77471f48b6f958ddcc818b3ed65d6361c09704af3ad48487211efc93a69236117a899946a3954e4d3754d2648de84f78156654e5377f419fd3055a710a3667450777c66f43c14ba3d119d037bd56570a29ab65f5b79b8661ae0f0bfec9015068028b9c2e5314c2cfdd014299f490f647db083358765e7c8c76895ec5ef6017726b591bb2f8d7ffe645465ba98e41da84dea3597a2ddce76aed853fe7c8be339ac662bd3b9c68383bd947b7ab909ad6a361d60982c70af8dc7a2d195c25528bb2567a91613ea8e591ac6b20068d8546c5ebb65498b064c754528b194a3f86cd369b570400e30c6fb31e2108ec9e7e313efa3734d1cb0b17537f9c6d32345a68f2dd92fdba451d133d62fdfff8e679b11f2d68b1693d9054d46c4c077850d9f674e9589e39cce58b9852128311572f04d61a042ad12182d9d8d1c1f050716568b912354bb90aaa1391d4568cc9ec47547180b806efc4821ca55faf6c8ca0e4c39ef3d43ec7a48b337f6365d6610c548c064a534f27bb533a18ef7057fb684f8a881506247165f2331facca2b1e1ab5fb46686adec3b20387fbb7ba6735ae97fb07f72606951ddfe09c93ea4a1367126672057b5b527ca421a0439be909f9f57af8e79a9699c1b55156b144adbcf46c841b9ada4e53af2c2a026cf84bd1e9d0cfbb66282c193d42009271ad49c2ee93aacd1aabf7f242ff84178fbea242242f5899495375f9d768b9aa11e38a04d8858ba5b2726abe3fa4bb517423dac2408672eed570640f6eff72ecf72de43c5f232bf966474a3aa025fdad152d8aa433de6fa36af2e437d82fdb5801a997485ff000f16ff3b9e81d3a6d933667aa014654b4091938e08ce3aa1f6684c56e631fd047bc772b2ded617b52ae5aa0220f5ab5c6f4844b25ad439f16f9890ec0450805821e2d952940eaf3a87dd608858a0177736ded444aa108bee6a03ccbaba8bafe58920d5f7e475e49ee3232abe568078896624687d5f92e485ece822d50b2cb91b0eefdfb0ae241fb61279e45c62ac6e2ad17d4c636d3bd452a0b2d76c06b2d6990fe65ab2813239f8389963336a3b79f43a902a5bd1601143330114f35d44d225c31557d0aa4fd10e94ea0f2bedbc814a3b555bf04d3f5b3a7f9147eca1ff054d71d4fe0cd24241d224bca222ecb4b5ba3831cd7905b7cb76b59805f002ae16e20c718b304dc94a6a701b3e3a3d923f3144db2f09cfef7328f527f1a882ca6b2ab24533afe6d1e161671c956f1af3275fce9bcdd6abf6abcdf9103c8fca39b7f8547f84833862cf942ef726aaf943cacff8b18e3f87349b12647631e3e09bdd37ec988fc6e396ab9bbff98d94167e4f883d476675783067a6d984b8c783e244b7513881d9f0adc3a3e4aeb4d0797d7a9fdb03a651b7332662fee610a1722e21f3ec069c66fba1808a54a9d6ac5940f356522d9a91749a6b6e10f45ab4780668f56a7edf52a7e4f7e138b5aba481e9eda7ca15212997f680accd1b1b13d5f190a8820d943c4ce889c9f5cd5875274a040d9751b6fb3225b4334ca0420780703f99c1a4d006b7232761896849d6d2f16151f479db6cf23dfa1ecbeb9b7e8b886f55c3471771f8488cdb6dcd9e886906e7ab8d0512c265347820415fc02187ab8ee35e8862c66acdcaba32fb41de7a4c114224b83df67dbb0b8cd7b272d02697ff8df227845056557dbcbdda60087785a6619d02b8f034bc14755d6f80436bc70d6ab48ee9dcd9fa29aaabf1de2c276eb1dde0fc25dcd260ee6db44ec8a620dfae6fcd3b06b8643f771a4fbe8b262789fb006d12f4eba0bf80eaca4375c9c4934934a2e2b4636ef3547b7cee53ad59cc019be3a330b5d8f13e90c296d9389e8eca667ca0a3a7c982ec9424f2e9a0b6f391d19f155be721b271378c92d5f91d2eac43312b6738b36a4e4e306b757f920670b17cf52a29384948e6423a5b042a54426e2baf7ff78d58a11ad070619530df4e611ec3af1c6ffb7653d69e58ca70a99cade3073946462294a2bdaea9e008562ae7732f565cc491b5c54d0e454ea0dd22545da7f03f366eef89f89a2dfd14dc1afbd356e2dfd918beb4acaf3e4e76a0bb94f19d21d80cf35c0c1fb51f39ac960c11afd04fcdd1989e7e6feac735171fd1178e1c9539ad1f2f91a2c935d11a42d938fa0d28e59002b3a1e60209ad90b5d484036bb9b50ee7baa69b4a3d91e0ffe2f5ad281ca1b0a52752c08943d8507677a908d33f0ea65f7baa7e4d4d9e0bea816a9235da55b19bb3292cfc0c264ca83512e1f962effb76902c526812ca4bb2e620b481fb5351a2e953478d68680acd38fc1e3e9ec1861aae90981d66993f18f45a8c5ad5da9bbbe310d929e7be1e394967f9675d23cda5713fd3cc69141bfe4fd61d533791bfde8ac11ee4b21f09142ff07281878aa3b37c03cc97acec8b08ad33018c4d527e500239f1ebcee9701588c85837ed52cdcd498ade0b5e942ea5dcd1f1b75c23cffd726383b61580cbd50490c0951d104c0020c254a7f5dbacf039d69f90dac5d987061549c3f0f581200ea155cf5912d254cdc09b05ab37145294ae7b307a1fdaacfff08a7f0ebb85f777d36ef69379bb0695f36ac09fd99797a8416a4cb2bb5f0068e46b11e7d16e4cf8e8934e931fd18215143bb660c4f1f0341a9bd52f486f815e526d197d0494945f4189b0effd60dc68c2b20243a8aa7284ce03b9b50d5b31ba904197bf365aec83e72d07f16dd3d5cff7d6ba0ba6b6830b195e05fd45410a122fdb4a647e528907ce706e982f7486f765838053266739fafb11d83cb93445d4989dc2c3d81c2fab2bd6626736a7760934954b7187e70412f600dc29712dcd0fa6e0d69be5cb851bbc037889f8f18b274ddd2c631c7ab31ebd7be5c9bbca37d81e333559519dd3d6727b795a6b1901d87796044e8a0c7e0e2c028968661f80499dfb1e70ec21bedfaeb5d0ddffec3dc8d9e72a164db7323eee787daacfebc67f5c430fc4b17c2bd60698c3b6a13e025c250f944c51def36957ac847336c448f25d8a5ea3edfad1bcc8f567309557123bdfdd86545cb2760c0b46959a5523beb533d8879e63c81a92d7bb98ae33a74123ec11187916e977178f53d6b018a4d79a200dacee2fcc6674c0edc32f43edce6f8837e35dc7243e135ae60333c788604c83309ed93ca2990ef02508cc750546d61e7ae3fb41cd5d3f6575809b13d6409c0556e0056b0669abcd92985cdad875ae9ad32ddcc0157c5bdb06f5efae178da1a4ab9457eb913aa1b094424722d943532b3ad85381dc61d4054ac81cb4c7e7d262408f4abebd04862ddc753096bee694a4a85b99872aac27f253b132811eb65dcff8fb3186726a2aba2c233b9aa531d6b45e2ab4b39c72bf527831d885a7bcc829ec78be6a91256303ffae4d986a6ef689b90ba76a61f057655611dbd03a514c64ad4812eec39fa65fe65e29c079e918ca65feb964f630a3dd8d333c0c0e7a523dd573dd04fe06748d72fd5d1ce41ba05a319c94e1b1d0dfb0fba801102ee7793513dbb7f91d3849f1f59b46594f07c470bfb329e1589025563705bd5535bac9e26625f12fbe2c1f7ee527f872de85730745fb6864f08939ce4e69eb1ddb1c447b472fea8ecf755dc878da4485b489cdd956d8b0dba4d206f2a0d570ccce48039cad2d19f5fd9e80cf27f4098844969bb48ee7322fdf8e9782ee46a58fa917ffb7ff47810d77df6aa46117ed73fdc651eaa770c9c0c96e2e0f954a6f7d696300035dd6daf64af4dd8f4eb229c47644eb63905f249f9f3bac8516c86c459ad821bf6f87f9129bfccdfc16f515fe576062d7fbaae7fc8322ea65068c1022f4b7f33d5ee4941302c1864dbfc678c2f22a5682d13dabcb812268091b12961738c12dbb4301b958b7f9bd7ed9c689c331b14e974937a0a728f2202782ff4dce889e6cf97ff67ae995bcb20348c7fb94e9d424a390d828751532a4512f0ee718805177523f3978e672ce2e4705d2dab10f2ffbdd6f6a15cf8f7981c43f092b4b0c1cb51f93b358549da9b22a6a7f442fce92eabba9993c1bca8ddedefe1f1df6774dcadcd24782e6d6437bc3cb73d37fe5df3d6fce450881a236131c5bcd61cd1cc3f2195bb424e98d9575de3150f5569439e7aa142cc8fa1fdc715049380705a9e0b60fa70961b654a56b39fc26d568cccda65f23b09df71f92afcb3f102bef88f837c39f081cf0034cfdbff9d1ea4f46c9523a762d2ec548e8c87d4748b9e73c760b174d4485179e9228e1f834dd6c777823009965e61caa0374448292b6cb5fbf02d8b63ec918c99f3acc4066cee55ce1ff2fb50146193a50003cf3a88d8bb3a87a780ec8a3676ac83e12b0d84dc9b9eb01b84eb37586943fd420a012e658eb402f847a6dfe76e620c0281322cbdf3905a89c58b36bf9139a3d1d43f0684d1bb1490c38a25a791052c6524d8b8ed3037df9e211881ce3c34df85c4274e33bbaa62883178faaa11db5a77a57cac912a896f53959f963c5c5132d79e45724d1acb00f5268c09ad4ced0f1cc00ff8292a33a9a30cd0475a05276b99b14b28c1a3da290d23dd33e6c43826c53b7438f9deb78b7a94c56b76e79a11baad0388af4f3069019456ecb829f0064f0148b7f5698b1ef8a2f97758368d563c993fdc68d2c6f83770e7b5e26227105f929296c5a0c2ed8d8e3eef10fc3ca1b45b543ee393984e82101c78c357a4ce2cfe8aa108b80edd1c588efb1467f2fa7a14ff0a97170d813c9d56321b90cd8d4a75af5bbe28d89ea4d79bde426653d261c3ba349810728c91b7fcb9f0508eb94b8aba5d73b8d057db3b2773166cbac44bb16c8dac651aea67e9edd861d17834bf7186db7777c75b94fcbe0b62aed62ec8803957015640299d04349e6db3e3fe9876347f71559bfbd65b440bc4a65264f911e1bf040f86d6ea13312fe0345772f6c91db75d0555a71316887a4ef763bf53972dfad2c25e7e956e8d6e439b78417b41ec9ce2d537f433c417923815cb624e41c3b54a8b7070018c8b6fe0fd335f8c96f6543fd8b9ddd173db0c364c190d65dfba6590e344c8dd9ba60febfad9757003ce5af43177cdf6331d36240748403829900f8ea9d520bbf40f26f66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
