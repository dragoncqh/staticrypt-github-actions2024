<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9236e7ba8a2a521e685adbcd01ee852edd64fc3b4482c112b5b7ed7c62a99dd99c3c03ba64fdd07dcc787aa4178cd9747707a98bcd7530f14202219babea5bcd5cbf4f9c371eec5713033723dbf7f9fbda9faf9012576a73805f9bf693f4f79b943d1a766da187d80f5ca19ecde8a877a3d932a4285d68ad2cebded0cbc1ef05c8e30400a6cdf3bd6ccbf91223a9c1e780650c163314d5dab79d8702b1704e92e616b98ec0ae005bddfd93914df40921792742812e9b6d674fc66df95a521e2b1646b00d2d0c055085969efaa9907d64189f6cdf947bf0db0c2858d32e2ef6d56e2160644fc07f02b09f8a4bfbc4058f07663ca5f902ccc34de49cb1d305779f6529f29492a717b8d2892a29624a4f1ba9e42bb4c53388a14e569750cd51e5f4b2fd0c7097afb9fd30cfc219883328d7b9a26682be0eea88f79a0f62828f5039766070c5e95c43b0a7336762a2d63c05fe255021af9b2aecc135ec6e3a93eea67f8f1bf937bb470cea3f29e539849c7f503ccf02765f57b230ceb44d91928ab9067c95ff6d83f7124d63632d673e494fcf1fd0d2537b873610b96a57f6ff8d56f9c5bff138213c1f6f5c44d90550344315595a32b8961b91e2fbff725c2e206428dd94589a43a9288a3d4b74f3299d410a29b71e2ddbc2b92235706dd3bb36ae958fd7f9e28d337cb5a7aead26fb15acf8e53a10dc5596784e35c183230ead06aaabcc404e8c35828d015ea64d4a45a00d9bcf105e7ac7837e25025db52d092762cd74c1ea99a623bad0740767000530fed1ad409a2ad253f2ea6be57965d65d53afa4f18c1afb68b1ce24efba8b441ac6050408fa5bfacf57a7454f7356abfc4c78f8eab398392a4b4ce37d82c834b96d7eefaceb69198b5e6739d31ffa5246c1e07aa0b420c438d48c11e012f9dcb283e152f32a78b8915f8a19b8ef0b9d74314213b77e8985094c75422a57586dd6a45ee2acd08cff0054b2acbfd0047be97b14a1f340e57643d9e03520cb2f5deb5d24c93456ba9cf6d57484390cf9985f8652282c2bc8d9917cbe38b3f13accf3fc3793d6d7a6a7e78213786ea6d90f0d9cd40e98f296bcea10709004f43dcfcb4336b2d73e7167c5838fa47e427f504bf1ef76aee71dcb284ec287406a36886eb526ab6b896c6d44576d5bfcc073661b3b94dfc3523881834b19d48822cbb1241f0d62e38dd27add5eb66b86e558fb8f35e0380c0d3d2acb358732e3243d010498adb93c531fe40726a2e3e28f679cbb8a3cd63a65020f3d5c48744d5f50af8b0ba845e5b9dcd54e45372ade9c973468b72872eba97d242e161a2ba6c198d6cd79790465cb6776492e8385330fc6fcaf07d784232281729f4d645c56df4fe55c8c25937e006d5fab9a9561d034da18d38ea3bc990855e3c6b798f794421738cc2eceda4424a11534e9d062b9935403869e5427178842ec203b897e35f44b7d7077eb432b42fe65643d932f59d0f489ce9466aed6c5ac0c30d9ad430671c0128ae5730b222fc60f2b8349191629253d95843b33052d14d5f7275ab3742f2e52401d2563844ef5e5136ab871368cc6cee4068572156af2ba58ea197b0ad8daa00a37376a98b23b7884c6d7737cb92166633faf10860c80a749a5b4cb3ce787717193af895c2b135d09615109fbcbd560279c739c12959d909a52977d4dcbefdbf0ceba92a59a7dcf44f4942bc52102bfe43d68595deeba25f24bb737ddbb537c25fbdd0f181406faa740d627f36fc219d1744ae126ba4758511b97c007a83a8d77e267d6445c2e7a0888543ecd32f0ce2859dd603f5c90af56fb2ce38b1d37565ecf333f497db4337c4ed9901e4fe2d69844476427d1a9a0911f139b9a97a992cef810b0c9f0028bd0b613185075939faaefad89b629ae21c0d6ba80e725d0ee113158ce3cdeff6a7963d0908fb91fd63290e6e5d376a05749b1023899c9a12f836c66cffd1f229d04cd9254c19a62bd16c8c16c38223bf8cb5d0a4d2b7e48129c8facf8c75781e6321a005c60ac9cf00fde5fe98276909721f822d7ce06f80f9fef48bbae6fdffebc7ce26dbc0915bc65d81a62df65766770159bf5be92f669970a1422741c3013186fe17c9aeacf1e1df6416f4d7b083d2bf576fe70c9d00f7e3d70b51fc9d19fc8482a51957bb70edc08668f1ff8694a79108d6a54a01844eb23947ffc43bddd28ebcdcd9f63bb7db516dbcb539ca6a6713334128ab6438e7c36989dd9d206271ed261fb23804a9bf3d7338b608277e9911bc8ccbbaead44e3851a62dc1a2d084211d2420448ec6cab68fad77a9a9c91a946d728a672cc6c27d7cfcde55e16fbc5946026d359ba9dd6e3ee74cf9383c254632f63fdb06b81d499523621bf59c274755c6b1a98c107ac6dbc89ddec47a26628390950975654789c94f6704cfdb6b5df091fc0132df66ed5b414e343af8ddfe95a8de0d4180a2c1c6b7492aeede7b10151fcb41572e300242632276c050e5aca0fc18d477b289df7726be7869f74fc2bc540e36f64c68bc1a7220a0d7466b3d5618514bbe8f0537e72a4db585114d5297ef910a2411ef2df1d48dac1843e57365b044759afe1ddea6ae07ec4ea8e7975f32a459c150c06189d58e8862fd45745285b41c1dc17dc3c39ac0862020ac033c573d77889b2905d416cb237d5842ebd0d86cc0eb7d436b07668136c3237ae1d8f465a773881999ec4e3e74e53d9d82600c2bbefadb289e5c7e9aefb6c1f56568e3af8cba3afb1244440ea391eedee6e1267645f1f22c4b9afb0e152bf98b46429632f1aca3009b08e08879e567a954d70487092b55172c4c823d31c69bd0b467040445cf253f43c910f8dab6353ac5e2e8b1a4f9f2f892279c6b2134a2643c95fd940ad011cdd3d143283bcb1afaf8a30d105b1fc2662376da33baacc09449c7431b2d2a0287d9c42337c7886b036e632faf02fe1628d4d2be2af98c737c00e237df9f3f097e3e080d95f6a183f03df914ba67703bca37b96195ca7a3138ed9d817faf5f6c8dd16544846feac17478051076632a614dd6623edfa3b0deaf84f86158efeee87b517c1e26d2fbbfa8566f068211e82a06aa2110def9edf1a8911bc72f414f5199b80e25761bc7dd49727055ed6be1821fc3cb40470c1cc27d5a325893e01deb103c617c496aeaddc8e8ee9e3afff9b474ea613e1a15342c24256efc6fe9588b943bc70f0976f693def75ade32e0962fbc6b9df005ed06fe475857835c5197f50aed6a69af12296b893e60d9ac1521b63c4aa0fbf74e3306b4c92818f6f62ba64a1938d2d5e9584a9ad41d216b8eecec128a9a73ff4912f03b02a5ace6df3eac373e19833b678d3f818290bd5e4ba9ad675d784701635dd54ec0bb7296be14af80f9e9538452820247bafe02e86294ff73e19264de86c780974057c6c7e997588317b89419cb9c42f4de30e3c27c19f458d3af48f69bdaac4c4276e6b30fc637adc63212d9e78b79b5ab1364e7ab44f9d205ae07d4bf7456f654fb2d394f16a8a0878e08476bfbe5e1b5d562dbaa576c081663a602879eee48becbb1f051b6f0b654310d3b099e640f356e18b31f35aee91d1416b8e8bd9fa82f5bdf093ceba35e2b7ab19d620c1dbfcbb9eb78353a16c4b6d08502029a90e2157785999dd8042f598b8db6bdc47a120c4412a91c70f4d053d646a18517cdad31fc845adee0e745412a4888b69d5dcb98a4873bdf9928cff5effad5067eae2fbddf54bcdfaef8ad7cc256d5664298dc77de04c27c1fafe7c72918d35d9e4ba7d7f18564e8719b14a34bc23b3988ee467e89536c8d915c25e00a28309da134d08ca774436fcdb4a8d13aba58015cdfc0e5d56fedc7629e100a8f77412c7930a363cb13f77b32e9cebca893da2e18fb68344e3bd0e443d20fa155ae117dc3d32e88b2b97b7d434409f263379195cc8ba24a54ad46c1294cf9d223881e032ebebaa270e4e34f6f495505694ce361f0938b4c47efdd5e500549def178e1b9a3b75441a01ba1b16ab8b1f01e331c6c7a17edd80e0f911c8ecee2f87af32c8f8d79403a024ea2777fbf15f415d463b1caaae25f3928b0a38aef91fb18f55cf6949d3409ec1b3f08f6cae14c839b097157cdfa1201bd55527cfd2312530fce1022822654f6a6d5595a7b53341737923e89aa5e1c888f19cf40c5f98dbd4c1874a97f00bb11685ba31cd4e103a7f715fff9344894ec858a0ff8e226b80598b4ac71cc14d392b7fae245d2dfb23a118d3b2b720eea7d601c08b0d339e7a6000ad49be1dc5a16356cbad155b691afde42446043bf0542ecdee174b5a34144a0c8c63126dbcc5c2d190631532990f9ab38572fc8443261530d9524ed739a0feca99f268377162b1844a0dd8099f7f8c13063d2c0b21a2fe81922f94e56a7e4a3086b45d9655f339813a7e4d3dba5a805b82988784a232478483afab8868051ba819da932954494773c0f7c16e469ae36921ad2f6f9901a35c4d5d87a53c0baa5af36dc368bec48f7252bbb32f9aecc8b9eafb1bf089cca58af752608e5edb54810d4672e8792f14ec1f446a50e1f3f39867497b93bacc0fcd153886f2690c1252e5b9d6ef6aef73df4cdd93e764e458e92374633384c1f8afa98b3b353cb78cc1d2dd1bf5439ba73124099721ed87622330e98b80ea5010f6555f0882742d24b09b8a0e897b1454bd60684b69c5fb529af12195b337ab2429c47b6ba127a045c9d9ae31c9f6a2f6dd48c095ce03aa898d6c563b2ab003515a2c607fd9289c2fddf5b84d7920fae8f26be48f9f89192f346d1b1edd3933a2a402607046bf5f352657bdb6e2c082109ed46d4ed8121e5aa344eff266f13ddcdd52380afb886806f5d1d19ed7f4f6a42726a03ec6f619e13ec345cd3222d23740f867e71a3e0e2d9c9884e9a4a9ccd923bc2ab7e763b848bc239d598358a2a662fe185140d24aaa2da6cfbe63a05ba57178a2a83c85d2f267da3bdcc05ed6215b8453829594ac9cb547235d4476179c87deffbb0219bcf5e038fb03e54373589e08316320e5ab310bc0d102e93c3cec0e8a6bd73734097fb616c805e809838840c6897e99d4f74231e3a4c65cb269b599d5c47af5aefcc4148319db786de23fb1e02a0371594f8b92913792482db54b059db5f4abe4cd55cc5c362b0bc3fff1cba0ab6874d1b6d956cba379f84106bc807abbb823398f5821e34de77005e9f6ee46dbb0ded43c4f27f0990d2cbd580b0ea670e8fb00dcf77f014969663c94462f955258c71df39136b3eb83a9699d6339856eb230657ce661108827b8e972b300121e0726966fb9e0de24933805bbcaa19e4a1ddbec410d36b0c6e2c28628de937edd539f20f9d4801c0c97bd3b2602e73d1d07d0800065368113c3e778df2dd087dadceeb932d7a00338580da9c8da628e85ff876854e0b1d1e62c2525456120aa4423bdbc81f72c3d4e57451ac4c5dfea965590216aef3f8a3779de6291e15903a5e0c26381bb1eda8f2b874f2f786eef4bfb30cbf37fdeb97174aa33100c3ce01b50a55474316180c080cd1fc14cdc5570048915d0312b6b3e352cc27f0c4ff770ebe4f4dc6e6a00620b6192f8b4d9504e50443dbdcfc856f3a28db3ce7c72219e35c4b4ddb1a6cef2633fb98c84295ad1d877d1ae116793a90ff9d7fae9cf51a3ca5363b2ec0827fe5fed6fb0c177b41c4371a295cf14ff3f451a75fa3cf5b9bf18f7245981bb7dd30f0bd4711d3733ab910a640f5c53cee41fcafd5138fc10846c247641e4769ecb9fb0eba0cd4cd5dfac0d64193801223f8ef8e28e353bc476f9d14a360ca6f34ac6a97e85d00854edd4a6a5f5fce98b6497c7e355fb6a9f727333ae07672413fa29e677825ab8f6b424a5f01a348d0f675546816586fed0530455ecfd7638c6a001fb4d24b21f9b7a552c384adec06438200a05d3d0ebbf51e6f3df9303f266e6b3c6a02e67fb74dc0c1bb8f70ae5b655749e5849d6b75a2676c25b1b2cad893c7765307e24eae1013f51bc657c9abebaadba24443884554fe9559a934d11bec30d68e994d0a5609183eb90b21bf41fc951df34767fce5de514ec771da78c3d189b6d84067a79124f9ef708ff58aa8ca05af44dff9362f4c26a4a81b57a183642a0e00267a769a4f934de9c0734dc3c78201ac703e4bd65f2889da1fe9b75c46595b315f2e7d45c128db9cfea3b6fb327bbd6c2477dcd77ab4407cd11a179c3a10b815017535e176d263a9bb90240d116cd6ed13dc4f7ff7a8d39d6029f29da94c256a4c36d42a5ae21403ad97d1c7f385b52d47f405f73f5fcf7d832b6e57a17b940345a0f92d3b2e208a558549f1542d05511e55ee6caa8df828d04762402d1c4294a00c82fe7babd329d18fe234a70e6ca59a2f1b130998236e3bc7644f99ad9fb89d511628a670abf73f7d3a70a992ec65b566fc9e2c0cd3371cf6eed18fe996c5bd812fc35e81a03eee96428caf11a38e4ed5099bec420ea8f28de0b576a8309496a38d6b37ea2dc9463eccb877435feb5351668aab01c3c13e71275ed8dc9a2b27dddd666d6cd636f2fee34ce58fc4e43c444b5aee06cab7d422800eb88aab77bc43e4740a0ad1eaf12f978cba2c578a2a245b43288b2c1f9c937bc6444f558fab2cbd235bfe29d296eeddd29435c44845bb215f10a7c534150444d00b570bda93e426a4baa55c4a1a0fee00bda3c5dcf29dbd9eb9bce91bb19e4341b3637b1119e75da98685bf33d1b44c25a4973670871405fda998865616bec0d52af1f2322bfe261630babe3b93bd5c788707c4d8c5f05f62ea32fb68145d9af45e7a9142e7cb25f13e0fddba635c497c870746533c2e54379a590467b9b2c465a71d4ccc60bd6a10aa3427da54b5ff9e14bd9c4b24b6d51841297fea354e2bc897a3bffc365b80966c2ee72d6f908b98249cfd96a1b474fad50b75623b4ef258a4b7a9a09209a2593c00cd42ca89dcf1e8154d779f81b24982d4eb68f1e01f55af68ec8875f066d3fc2c1ab7e85c35f34c77b693514f1caa1c2986606798c2b2f1065b6a8778d8c98d3733e095f64b3e8825aa40d2f306a19470637b7559151189f0eca1cf7f885fbbea8e596911aaeef9299f87f634944c6bfa7ce58ace4e3c77f15fc260a050a14f7253383a6a1c65b500211d75ceda5f9206203e9addaf80f70d6674947903e45de24e77140a9e1c36d704e61115929fec9ba5f6de0333d3bd4a72811336a29fa20789366aaf51d969829a6008f4d01239a9f069c1996ac9a7531e9aa98e757039101482b7a765f23853dab21d21c60d099b39df86b7099879af3dabddeda6dcc930cebdfe16652fed4f3aec6485494399cd2a0091de7c8b08c4a4570f665bc8284d282f746683a8e3e8a14ddfb7c2bd1934710418c443ef8a9ef0a6f2bf616c792cd3caee799cf89cb7009c8e143da58a6db20a39dfa4b11a0bb9ae545d7c02466265866344c113b8901bc8f443a7887d50abf9fd717f020082126100c62f980a47d982a5ea48682921e4263086ce471643652a8a76c743f9754f6c10c3389ff8de266c3831d486a232215a4f123f4028f8dd0a60424361b7ce87bdea38b16638ff128f1882ddb6dcf904b5ca219f05af2364a397d2c0c0b738b2b9d09d8b468ada64c803bbb2e776e84e64e3250e8782f33579e28285c4409aae25b17eaa0cea5b9137a71bbc27b57b22628825ae23e9c601db5f3afff36898f84b0eb78d7ea35437b72705952b17cbf5d04b7043837fb033ee98b124260b9f849ba8cf28ece372c27a8accaf92630c659fb88a2011e9c10cb69f575cb05778734b5c36b642dbd193d374446cc56c178f519f25453f4f928b312b8b89e73f25996c19a5d746b806a047cfb592456d7e6385eb13c508ea15895bd5bc77001730c6345bccbd8296f8a2a853f89dce0c93ba820930ab09d69d9873bcf5093adfe91c1a33fa9e7bc030ebc04535cdb8330373d9cd276aa81d27549d46cc1221a515c386a5d0741aac85e7d932ea0a33c3fbd68ba01ee7dc95917c3b10ec831d57947795d42fc2325678f0f75f8f9caa9c1a958a6bb88338bba2e946f5cc205b17b4e5fd9735f1854716e12e36bc7393135901aa7e5754ff8c232323a11b57745d6f443b84144dd3c14ae335ee9ba7425d74ce356cb87be006abdc66113c8be568690d8f8c2d2b32962b06e45d5435d86e21c9356221582a9d8fbdc12068962670234a789430a6eb02cc4c6266c78b66cbf9a3792f470521c38bb492d1ba4e34832e316acb07db857d8ec544c72359ce275ea17a3952e87cc634e4062cd0a870d8e27452c86637e1a5a269960e2ac9ac5cbb5b2284ce5fc1e2f23ae63859ab8b53ab5dc372582f70a9556b9e9d5af6f6dd4879383004d712e5ef9a97bacf5f9162d905c664efcc60dad81bd25fea537ed420decaa377a32a53d2173402b1647d37e190d99dcce21942f99b9613cc90fdff08c0489bf64d5dee2cb483c6218e39429072fbdeb1a09c39773e37d39f8c92604f71c4a87b7d28d1bc5fa83089b1564056a4e05d6c882249167173ba6606a8347cc429358ef6c7f7acfbe8fe169a2d4c5614e77b27d6ae6da215246334865712e52e09bf753362149403c47c5d6442087a8a70f4304dc83260897031ad1be18077b78e9fe01e9f5e16ddba69f593af5a3816008a47a7bea96cec2767a4b10b51b9d2c51e845a934ee13a413aa1e995047d4f628963cf33b495564a9fad672dc7da34e3794561b6ee66835668ebf6dd917016f106e1b28d3f7ee43af2caa3c442e1d06eb7767facf16c1b3acd6b478032f418d69e89a179340c45fcb7954d38542407be7a0cf88aae6c20b89373189936a4b1a32644bcb63f5148442498fd05762018072f857ee7d147fc8019500486346f7f578c21c05ac4617adcdd8db72fddf11d74f6fcfd293fa2e0bbfb64840f9914c72185e567abb3ea7ff977771077b48e93aecd55325d3adb310eb24d617012043916f6b276c52f98d8fac18e0d4c37b27e5bedb0a90e94e84d7e79861e943d48ce4bb1b381a532bcb72a723c5e6d7a84ff3f8fe8cb88db0d7c72615e61977d627b20f24eb3310c028e018105fdea7de0989accd828636a17548b193e3f00f67c9a6d8a9ddca7dc600b352be22dd1ed520d3b1db23aa9112531b9bf44adfce423ab4dab8be3f5576d6958f3c6a0cacc7de06c29e33881734a797522c09ffd24cf6e158e4b0bc5f1bd10680114797e83891a28805806d06779f62b6f70ba227c72a02c5f6dd93a056ea70b4ee57c716cb4c4e1b6b3d90f45146f5e80889f5cca6598d4e54c389ce4a88b9128b9a0ead46c7fdea0cb8a0529746a04900e88b1334a6e1f6b775d184acd0b7ca8220e14b75826d5468c3c997740d59d41a685c8cdb58bc211bb10bbac36e812fd2b69bf41ac6ed99f226c852965208b7d5736bfafe1a7aea33d42c7c05f22918ba029d88587fb7da9e8493302724120d7c3a698be5cfac70730e488f7a3e576ccb41fe436d23d3098b1b90315580da1b2c30c9872cb9afadd33819e1f8fa77ccb14881557791c4666601022a477e6f5e018d3d6f9697bcb32d638955df71b29f63407e53c9fd55846ab587b8e60d8f4249c606b30596e24700088c8cca11c4ce4d57c8c8332d708717e49882816e565af11f9019a6e227283369d223308ac192dc216e938cdb51b13f08e92eba6aa85430b60cd9bf8f772d56958d10d5924ee5a96311af414d70d28dc347ab8d2b4dc40f4ea5888a6ccdc0ee0233c96c5497ffdb2b87ebeab160b8a443cc927fe96059b7fa28ba4fc152639f745ce9997ecf7a45f0d832a938a3ab39b66c24d798f8ffe7d33a94e5f0f0dd270bc965cb1fd00edfa82ddcd784029ac1ca7c8796bc450f22007b0bbcc9acfdefe6886b4dec749bb688a017ec65b9530e48d3769859a64cdb2bebd72bf4ea3abe45ab968a4bd88f3901b7f8a8e5a371415b206ef28165694442eab24818b652227753493089b06de2064aebf84d1b052b21570b31b5d3f6cb2122a5be38329986571892a2bb6fb1d30570d488fe66f9164e047bc5282a146b9b57d8e090bf2aa893a26e46a4cc8d29f700b1cf46ad685f4862959993f5415a686e8484c18fc36b73d54f9c099b6b83a5a388a58b0a3a062ef2e389a626093cc03fb41d3d466cb5bd65a4e8a46e991f4bc79cb7edb3252d89a0323ffc79a3b31820351ab7ae1cb5c13a09981952aaf6cb194fba984c7062081d9396f4a299ff23cf00d4a7cd6bbea5af77ac4881017bf3362a7663b9c6f7d1e843e7857d2160503be3e05d22cc3331f8481636c22e10033b4c6cd205a6cc8490fb9d83f3ae203d4ca976a08fb5febcd685d0e16bc3de91b18a4bc008787707a4aa81b19a1aaca002862efea31e0ec0f30cdd1311f6fd10c5b24a75d8238dd3fd365f67807dc37948f6b211134d75da31758d685c2ddda05543090dd211f1d37c858791f530b4fbb486fcd3d825131b22156ecd319dd4fd6ad38898a68a450880ab69232ecf6133e096f58cccfd60b0f7cde50c4a11a9c706cd10f938e750b8f29d21f883a1a0d1368bc759abe2466f9bf2cf43fe0abce6268eee50f01ed6510cf9d2dce5f5b7cfd4bc1eef57a540af85e003082de9e39511ee0f295239703414281ced63cbc4eaee663bb0d17847405f78fe5941d0e883079f37108d9f2b262b2850c3ef0287a458eeedae88a2e0d66cc1ec58e07e041068bd5023e834503e9f281dd92fbba1679583f6e73f6a5e2de6a57d7f0459406dc321a12bece7359268a62d995158a1f12662a59add48273eb35a6cceb507cf1c08d027073dd0c31cf0b1cff7da201650273a3ccd93d94b2c33b70558c312f00ee312371c9d58201146a1dc1677e21663efeaa65b14e50944d379b90ebdf0cdbb2c54117fcb97f208089fa76267399ea04110b94848afa52885205f8a65469668ff6e916213ae76284c91a4a0cd3ff8c5655d4244dd6baf2ada86f41961830418fab42f88a80e202e90eadf90824923f96df30deaa89ea0d747878cb2fe3092d3448f7b2d4466a010f8f769b0e46e81e7c1164b0d44d2a524d0913b9f408129dbc52dc266bb45afae6f5e0814ba024018533a587fd1eed2c782a78b44d0804466b8e4172d8c4caafa14f1297e44fe8ace61ab2aa3fff7ef41256d79e44e6e2851d8e932be12cd6a8c1ed3789eae01570b57befbd99185386e8b32726c8a9ee3b48e94781ee7c08c501e83fd8cb9873cdbc11922b6ab7609fc5f73f17ad13525dffa332e1d683f9b28fd6cb4c3ca34077fdb87f61b7ed773e1ce33bb693167c8c28cba8c80d9c3a8d96e74677e63235835296e26fb2ad1ab23357e519231f4679a8f88a8bdd6111908cebd9ed600518adc379bd376cdfd05c25d1d9991066a864433a545b2d76a3c73897c4a9587ab7087d171f337b6f46ca3107d3df96be833c834b4d3bfe2875951cdcc2175ed55267a2962bab4eaee0852b1b40991017b09162949350aebb2b76c14ae9e4afc62c729259d67102377d4a94f0d08910268a9083fd459b9125daada9e37701f3a1f451a1e5a4332eff66ed06b16fff94d5125e9a4cd85d7917254be481a0c75c188ed082c8bcd369b166806f0daaae1a6b554bb28f8583b9ac89c2065e3c42b28475587f66329b43cce0b551f96527efe98e165bfc89637e5cc9f026ee8418374e468cf7e61185b1e248ed02f1248ba10ddd655495a21ae61c9a8b7b045db0ea857d1202ec20cb51969cd59e7607bf996497470f2ff7b471692a3d475c334090e2542c9b931596abac26a87487552427a2dc512e773e37c769a91498f612d7a7019add422c3d670d5e14b1cb1f84516cc5868cdf92531ef0e475b3348c266496d024d228c583ce321fa67df581bed509bff0959c16fd1ae065a4fe03b493761a15e8b2412a16388818fce8afec0e21176436224dba51f2b3907813fac76230c30a8548526724f5aab768c7724eb1a5b386e4eff893696e2bc14176214ad196e606b757ee14b41df1f2082073d44b827677daba19f2d3bb756f1475c4a1d9568fef58347b74e40f102c2d25b8110032529e4ee49e317a3c38b2f5403f69e5d4ba491a44b75d20c9bfd4516f4d447e2b0602ebd5169c91fe1bbc62ab91cd417b766d21ba257fc72c69cea3d5dce362a3c55675d4ddf18669c1ebdd067e02d1bdf95eb482e6fedfbf35d4157e257c86e210fd5dfa5bfef46f9f9b16da402ee11db704ee8c9c4d41fb1f5922883e236899ba1c76da63d7d1753dc0160dd4e91c8a94073434589eaeec7aa82d6b473b60ace1c9ddf35d43f9c32c9e9e15e54cb3d8c9501697dc15191eea594990e666da30bbc696747c15e6d99ddd0d0d466c7570949535f8b7797b68bbc9909db69d62a0e6434b17e6bbeac93949264a2a0882e9c7cf897a7634bcdebb656a281dce17a2ca1484d6b05a9ab967ddc17e4d94f69908b43c26a7fa1ae5dfc44f908a6b1b463adbe6fbeeda959a0247992359253ed001ddebf669f48e62707f01fe1f3004d51c681d5dce4ded4692eae41fe99f4d2a954456550375eed25f665085e8fbdaa63b6a013b6b7b8bbe62b37a01c955a466922a0ac02fcdff85290739d3f968ff855de072cce50665c5eee9175da4171d8b51d489260a5a30d4a735ad361cf4845a84695a937481695da6f5ffd200883f1d6391a455b19f94a2820ca1fa0f4328928a36c46d92172fe7d45ade9da2e4c30381d063f6a6d35e3627626a10f335d7f9453a3055f46961a7c9d10171be3878685f6a5502edbe4dabb0967dc80f9cbeed9096eba5beeac5e9bbbb3f0fdbdb6c76643430c005bb8f1b65134f825583e2f41d35b792fd764147a70f8d70b392e0d5788d7874a6eeaaeac8a01f4fc07a7882c47126dfe5781926c38e2561b07f86d7690da935329c97ad8e57127ecb470e824ee60c83e26582164af5ef40ca7641959f8a415abc57491900fdb406b9aebd32cc43df9a2a919c98a66324e63c5a26b58207bc92e4f2aa675903d2834b6054322b963e018821f470ceaa95bd45415b5cc94b822a527da3559266b1e9bd22d4738e209105cff9ca7b4ee835db3a5a1020a9d76ff946614c748a1fa721b5d3457987cd97f0e7d6dc782bba72accbcb1cefc0407946324666dec22e28c4888e02a022c791d6a1cb471e8922df2b4239df8b1de94ea74a30b51e79b06144758da329c88839e0bf70a2c1dd1edbb160e17bd01a3c02b84952e70e2728c67735602059c4641a5e6d669c2faa7cc3d0b600455c353cfd8e1f2a3c4926cda89fd5af9839ad63e1f4f986eac885333dbc49de2e9dc2c63782a3f00002e7cff1ecafdd880174d84a861b7da5080e30c6494341f87b5379ce36da899e4f7c9f6572b7ce2a930d4c7d23e38fff2e49e65710c3361f4453aff99069dcc08441e2df19c822ea81d77c22ffc165752ff179e8379279a454706846c6dc92f32def95fbbbe05ceaf85e106ad791c46bbbf11ce921b3398e49ffba25d7ced5bf9e17ab7a35f2640831f40a85a14dff3409743fb950ca07cb58aef88f9eadeb8ff39b7daa36352c5f48c6bd2ffd3f899ec1927b8ca125e5594b02cb4fd45c50cfb108e05cb77381aeab50da284322d07289fb6a7cdc67395a39ae18a66196e13e197df0a73038a62532a45b99ac656dff752ce4e18c7bd754122ba8bb15e172877e984be2d915fd7efe0f141a5bbdf6f935da6c4105d428c4dbce1c6cd7bf9e158b7ab583d01202740d63ee0e68be47d4e7f46be1e28ef9e68acf35facad5c41a495e6938db30d447855f8be0e76660326a27b3c5d4bdcb7f5454c38e97d40c8cb2b8a85790f267a4407d9d95f4865e3a286095f30e651d065873305a0d4dcc3e88e8c227fe5054cc0f0c811c8661db3eb54b719ce323770c9a84bc049f11f471e55b15af06e548ce58cef3e08553cac06fbf93adf9c29d573c39ebbd39556658674d813d58b10196dcb8698caf7b34e22ade86b8e0ce9615d25179b02c3c5f4ccb8c49b0079ac63f0f84f836fd38c5e0748596e56acf9970d5a607ab4b3ca4c51ae2f33fee5385a1d9a9309ad56ad74e19289885aba8e8bb9452c3d91c77e6374b339c4057268de2616e63bff7b23cb531023e55cb1810226e60f596cd1309dc8bf7d13d362832671aeec6176738e91fbe50d2ba976669725e7ae9072ca8e92a4cffebf9a0aeadeea494eb8a3336eb03b04b38f6ba268bfe0c532909d8f0b64bdfb2a5ce2b59b833cefe4f9ca254539b8382d3b3407d809c9922ede513820b261d8b80155b3a587c3d46a7f6ba7dfc3b7eb97c4412f5dc6be27a9c33380c5612a9132fc1552db1d22fa525f86e2530a083b4109f3a76df9d7282bcb55a304775a6f7db23184b5168fee4b92586da4a4e06729a3dba71332fc380873629bb7147f66dc14bd1ab0870562cfc9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
