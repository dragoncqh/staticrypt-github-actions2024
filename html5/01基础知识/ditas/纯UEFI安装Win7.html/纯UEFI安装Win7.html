<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f220a06988124316c67205218d1b752353a1966ff99186439cde5a3260ec33b8e2c4e6120989334da4f1d459fb49c819433eaf5ae33335573c01bbc96d99232069af7e42df5dd8213b21b42e50875234774b29f04210c0f925a7173f7d038d04d6d57e60cbe45d510d0cd7a12636f00f196e0e1add0ad1191d1c331ac787da08339fe3e7a493b4b9661e0c43c650256b9b36804fafc63a2570d641e2c94df72c68f4cc763a2ba717a5d9b14e306c5487fc7cc28c606bb961c5f81b11a925e6d85559564aa82305704171d79ea6869fa8921e176563118a66a4f5d964b6eb5d83ae997ac3d0b056f44985dd138bd384af771f64d98143927ef0c5e91c1725e86f3dca4c96612c5e578d36033e62fd5cc18efa1793792670b22e898fb6528aba85ecd718bf43c6cc69a508b9046af95bd73bf054ced15382f7a63417329735fb7028c88f12c03c352350b5d36fc6a3d84c03f94423eae7c1b4dba90212cfb96a0e66aa5ab7cf419f45e65a7f1e7fd5a63be778b94a134661d2f2c1bc34d490b5c50d414f954987f6572ba89cb482d9e886cb5946f2fef914d711e67389b19c84d3d2558f89876690b75ecc69da71ec46f63c3cce4674c9f7ea5807e6ef8902073bec8b9ba98ace8de5ec638f758474660245aff6bfaf6509ca7aa8a6dc930aabc920d48bf7e91814aa4db1b5baf32027c1fc96e016f0b346eec1dd36b1c4e3e2b402522168d1cb0875092ee9782429652fa0651e674d55ea0e006d2b5e6f915e6a9e049cbb66472f10bff00ab823dc393d7d824f42a779bda267ba8385ea58bf626897ac9a47eca4e290f3cacad23c6926872d522a465b67d0298ab597c4ae0b1236d2ccd30bc279cb1a5769768f8cb6d9e36de90118a30bb06dfe143ccc6131323e9c18356aaf07f9432aa16527c0af97fbb712c01fe6ebebd663e87c0ab31335a130a2209a67b5db45b3962e9fbfa12fbff4030a6009c71f7a7f0e939f70e9127603f83135fea4e183e25ae6495feb298a834884771583acccb2461b6deaf8752a67428b6303bcf10a57f63a4543647eca036e017f1347e4b05b6950612fd71834b211210d57c97b9fb532e0a6c08626e16e5f01ac417b85c682bb5f2fc2ebc285c487d170bed39193a82a22810240627fd610a155778e40bb90a9cc9dfdcff99b775513ab1e36a6210ff7dfe4152b571a3a69489576fd133c05c28e41a28795c47202477b173caa37d246f5f975de4dbb084f5fda4c350b5dfbd4e2f7964e4ac2d28362d1ca2df36b5f5781c9db7a85a3616e73506066d155acb0b2fc18b9ca299e74a6f64cf14eda2e2f89f9ab5a82a9bffda0489fc48d14e47533252eeffe8d2df1ea82d36f0cf12005cd71f1cce3b025e8491689977d467cd40631b0f0cf5d0a1caefab60174b1746252785266c5414c681498c75f68dca4e1478f22c93e523ed0e33377db868bc1b372bf3735b5ca07ed46408d76c83e71bf29640007bfe95ff5bdbf28b8370910a3cc7ee1dbc60df95ad207bdcb6f01621857c5f12ffe09464734cfe17fcfb3f60d1a33ea1bf88e8388d141b7f864dd60dec7998fff28fad92d94b20076be52d9fa198d1da0e198fdbce0ff055366b96e0630360e79d32c203a3dba6b976fd1207ffcea4024b42b691875735cd6667c1726e5a97a1cc402fc7d7437a762a956df5831695661706c3ccd7d90550faa29a13f29cc9499fbb67523cd0bf3ee6951b93f1eda4c2b660b409e1792909e10a3c9fe99d96d3599ee50c6d443799ae15d3460384d4cfa7c7e4589d88c87cd6f630b1e7d8178aaaf741f7643ca693e9fff96904d5535b01a1c965baf53bad4489ec1ebe8441ee920723d6504b0c843bbb7ac1f2b5efe8f0497d9a0fb2d8f42b177b9b90a3e07a7b7392f817820154fcf114758e18ed9b2ad0add1f3dcc8fb54eb0b820fb436d58be066b0e94977be575a605b684b454d1ad728e45d80d65f3964276fd09dc13e8f4a4ef549fd530d395887ff3726eff30a6d4952193d8cd74ecd9de2e6dc5c1387df071bf132edf0d36069f54c46b4a941305ee775e7254e78f779bf0270ad9c6602e6ef428771a7e834ba2acfea8f700d40a147be7d65ccc725dd03f4c3be977cf49f1fc967989f2ade1c37b94faf4b1a2ef4ff5c48b061a914817c704f40ec7ea111b348715bf4c9ae0f5f585236ca31c77fcfbb374b29800db2151147e077860da6d282208e4ff5b073f44dd4ea25c01deaf4da4ef8fb628fe69ad868c13a1c296f1d3e0febce1597d63de1ed42c5956e9f909b837e2571bc4ee96c25513eaf10fa45c63619aaa49b5c8766add80dbf7c2f11d6c2a3811653d2d0fbd410ba9f36eb995fa753105b55ad4d0ebabaa98c18991137f97dd2f59b072ff3eb226a86efdaac6ea2c875732f84bee5f420127bf67c5c188307d4fc9bb6d67ce31b20dab0df2544b7baab0f3b2161699c340500e32ee38d4279c6a8413a3f7e73e4d52ae71f17a54f84e3547b852c0d8a86e8376fd58c6d8d0883330f43771dbed49ff9798ac2b70223200f79c36c852b6ea574b487310db7c645daeb1fabb5b87838828c561c84b2597f1d761fbd712297f103ab31d34ffe26f3d7969384f4fcac4deb454aa5574176138aed0f76744a8ec053136c82ded28a79663b81f758f6c4d41c25d1f6eccbe1477fc593daccf16ed9cc0c1ac9781c5888f900fe4e9ee12c98c3ce0d71bb4e4dded768c12f5b7f1f2ed6a03a8a3616251dbcfc4154ef1a529a0b5b774172779ff0f9b2b2637ec5d494f34345d41f1656e832ed2908e83c7f3ffd7a76d00d07fde276aedefce547c806620580c8c5a8dfbda6d0527c7a21681d71223aaf42efc7ebe3119f59a5edb29cf8ed167029d636966d5d1a49a723b7ba04b765c797989b46b27b76d3577f009325d9328eff2d6b1b8d5713e885c7a72ee8a360751bbbc8410e0f489afff569083df05e9102aa57c7e48da58e8c092bda752e2a4c43d2e99a14c63119a137a156324b4e54f92fde9ad3ceb93393f56aed2656ef563e7e3d37646cc1c658760d6806045f8450094b720e04aa7b1be8ec7e8ffba85d40868602797425b05743aab89d1da90055df34ab5c15798992b155ef74d8e5956018617c6d5ae27abcab0d793a6ef389ab7a93e4f18d4ab1492a9ad4a945d0ceb5f37218323b4804eab784e6d8fd901e60dca6131e931bd1f261d491e30f056df1847a52426d0f4cd4db14eebf86d08a5bad05d4a001ac8a81390b0dbd54bb59380f84f8fd668f7cf08a30d96aaf2d3f67488bb7a059e406654874b9c8ada87cb9b954497300e6f6555e9fc70248680fac4a4bbc580ae62c3f3210a6169471ee3bd5a5f18fae30fce910e47f2b6499eb36b51f2e2c34cab0904a87cc8b640fdefd752c83c71e076a89863997fffc85cf7d9c5660e42cbc87ceaf1ba2b22697c89d28b0723a5e378b39af230a375021571a2453547f88ea223c8d81af8c30ad9ea43b88620b2f18bed75fba9252c15138cd9fca86a84a148eb6172f2d3bc1519909f296ad494abbe88b7e51807bbca3dc3287a5a034eb07d8bfd49c8cbf534c19ef67b7559148c1c024f1b35404156c37b97bd1c04d7abd36aab8515285ba91250f445ae242d610dfcb653f2b88e40019414e06988c4d60b59f24d93db604bdc3f8d2f2b96d14ad21f664276125d77f5aa943a692766e07437cac484c256a805da299d093a9543b0d28836626aeab4e8364d197620baa774215747c7f15bd1b6cd31dc1f9d1c10a931664851fe068e20b7694fdd183b33299d35d1a8f93e9bcc3e077bbfe7d37a64ad24c0d693be070fa74e732bdcd329884c62ff131c8d4dc24f68837719b4dec32122f838866c8e9d87f77eaa78f823f690ea07c9cf691c6d582d69615f61160e623a4452bab9ca2dadadda6278bd96c69f7e28bc8f89f0da920a13953d5752ab4712d359c9ba7b6b0af31ce2c4997b733abdb6cca27cc66822607f270628e1168c106e4f187d750f0a0684a4418a5208a27bf5eef1a955335165f56afdb415eb07794c965239507bbb116659f69327456be749439deb63974eb3136028a55875a1a9a8ee21acf72018130f02dc20dc34d6f3e01523693584fcb67163b1acf11233b804e984f19518a658f0935f46e1ca926bf17620c7f50679fe4ba510f2331a672a4c119e5b121e6fe47a35b531263a233123fbc992f659c0322300b58278721015c1f9bf5c4a214e8b18cb3c7b96d53131bf50f01a41df4f8e8a4ea50574164dda6d6fb7cb63e734e96e578ced17d6da12fdae948e182fded112183699e78cb932d828201c87b2feaa86b3fda8ceba66bf14474ba77e391d29a125d13b9e6e01eb367837646925452469e7e3431aef0574ab842ad04bd3a1508649a6ad055cda147160df96d9cb1d89a89d34822a07acae838fa5a6b415408e2fb2a943dd585a14aa18db715f6beaa8097bef5c133fb687acded8079a47249ad0ca935a5b5e017e5263fcd4013569e365895f85387e439e7991c8f87268e6cddc71fd74c49efe36f7ff6ac371079f541d1fffa935d85c333bec6e708a7d3a959323b578c4a10279914bd0d532f4ffbd22960084232aa0429262843364a437fb059f1b894688c9523872ad43af2447208b0db003db5844de4b71a5a44001528c3a9680eb6f6353a243cbd9ac61133d6c28d9db1ccb9dabb6fffca1184ba10bed9b1b3197f46c45e1f658d6a63a7b3b74d9219ecac6358bb5d94bff3d1cf4f86e7c61dfaf6879e617d38c691050ad0444cc680a0d7e743bf383ac9c2531e69303c358097dad996fcf1c792804e2af5a9a90833cb432e299b3904a2156a397443ce5612cfe14c5f768bd3c4f7763e036188dd48ed1c0cbd8cee683e218f9ef1efaa7e58fe866a13b668835e59514bf514745a32b53e9db6ed43031ce12285d793cf0a165ff282b2bf1625c99fd843866e52467090d726f55aae04204db4122c600214f9d084263a6f1ada5f6267f5435a191847fcab0970da473ff5f6e8bf04a42298b66109d1c0c8903c8503ab5991114d23a40d512c64b94112d6a3a8f585706551f06098717e6eb7f74953522e5c98be43856b84876cfda74f51aad78edd8058674eeae793cad10585185a53680af4ed66596ae97214d4913cbdf8c275ca1a80d4d51b52bd298b12ef3e968796a61c1258dab4f95a810a7ea12c1977882fb3482e4919b1520db07f69510ef500a713f4e8aa7c1a4d0a7a0c58089480fe36570389be0e7a30c31367d39a608e35af4471a5188b75ad54fe04bbbd3f208a0c92d8148162698f69bd484cb139a9cdf57df133be44265de3861618ce36449262b4e71f2efc691c91fcde2c12fcf879d8e4193a95b26ff2fc30b87d7c183d143983feb8806298c5dfc9e77107995e14322941e0aa20d4a8b4969c04c856b4a4f87e317ace98c939268a8c045a2051e194b541affb540efca8170a266258b36d43dca7388139bb89bd8e9a88185d280c200ffc2953440753b27bde2897606c0c63361b8c35a61e17c873d1b9356f2f1a50b1b6a3115e974db684648a42b14fc322e9eca409a9805b65b04aea34a80caafc620cdf8f2da573c636213f9897e953428602e82226b3165803b9378bf4a6e64aff4fce5275d60c2c7e39c69f3f31523a16067f5ec14866e871080d70bf7d3a68eeb06cf7535ccf6a213127dbc6e763f87b309c56f10e8fc1461c4c8d70d33b4d30e66e70f39b5acc32e4289f36c87746b3284dacb1ca88e873ad2d6d09c85e0bffabbdb933394c28bf7fb672f56a16dde15c1a9abf31c0a9f17af1d17717b4a22bdd65b456c12ec86b8d84e3c8e20631cf1916ef2abc703db02634735bba1f09ea258d00d32e0a34958259d63ae443fe504ee181a7f8a494746e8a3a2139592abfb2433c73e317c67dce6fe71f8493783f76189ddaab6188bdf30b69de390f68727f318b8b5faa8857dc9593bc68933fca9176f75c090a8cc91282cbfb803f274965dda7641d2bf90693b3bc254a8927483caa37c1069b282c664f156bb3fdad3f151eeb26dd480878eed89beee561b0ed2b2d1f01f42aa41529f1a3fbf9150c565befb3a9e9a98c82ae67fdb594797f2f7d0492f5d21f4b669929853530f0f6f467327fc7782e0e01705135ac82e3a58e19e0f89cb53e626cd1abef9e6fbe7bc0b31947770f9f53aa4ac75a2dcafae26f93f214347b1ce82095398ec4000e33b660ed2d0481778ac94547b23ba4b765aa1b6198af17830c12c7aed43fb90d38134497fba993a154ade58cb106a05724ccfda632a1f06f2ab1705c45895755535fbe21cf752e69e7642bf1e583416d511f71bbd2cc8b89fa0a6638c69f20799c9d71c4446a5d45959e63b43645208f837b38ed73d03a969aac6f84be1852f9e909629da7c0dff7de52a909b8a791956ab9d8bfcf6c2540382fdd6e89f023126a8131c67926a607bdf625daee15f315b6d7c24a631e8846d010be54b232309cd9c26419d42caf3fe5d49d440695ff81cf2a18277141a0f305e148add37d75c4a1bec16d2b0b6ef0a1a7f98b2ab1d202aa9d6730bf955fe8fe742bd8bd7f6a00a3f94e9279ad94b8dff21ad5d6205fef9e3e49dc0ca65c5607fb572a6802f9ccfe9a5524e38820d77729909b085098ccc3a312158fda4c02c7c15baa4c5d1cf4a7b4c4807df41d1b36e8a0deaae021c372241bacf04e8ce644c1ab35676caeccfd6c8480c8b3c222037ae740ff4299e598ec1649649f21e92f942d003a1bc363bd2327c75a14aaea54379df43d8e167fdfee2506eb60d1d50bfc41639bab0d9f94201a54dd1f0e0e0d2f9186d137be4b90f4a3dddf2335317242bcb0843dfb0123e68d6fa4b5e9b28ed29d86c1eda0f2f8c74b545f9ff1036386cfb3532f8441d87b30c0eecd332dcc4567a6e2954d60f9eba24a8d9993cefff3937385ae0c4bc4e2cef6f293657221cc910bddd4a669f351f28d97c44ac1d548b12fcdd29525a15fd5661fa9743f3a27baf13c664845059923659be04172cbccbbc6c8a16de457ecbe43419cd574dee660e27601adbc3d632c60b997e04a4f57e99f56bbb5d2cfb1187e4c6d5b61b169c818ec9495c235dc9a8dd2d7a09d04196f110fa3086bd7409fedd7bf9ea52b87144ee9ab1f66bc74341cdaaa4966f875f038f0891ec2515820b75434b9a6c6302c5e26e6b3b255baf9137b91c443224ca330728b6ae834647c84ce71232bd17b36e52ceebdfb97ce7e0d5e2b729a1a887ce6cff5fda9a20bc105749d6b0875b92206c8b9400ffd1534e76e9c96f05746141c4ef6b3f7980aba5af8b2d24e6038e5f6884440b3cb69558ae3fe498f19070ee0ca606cc355fca19c089c53a0c3de5894d8f8495c3459ee3f4e9d1c79c7558718d1d4ab740952a95e4d4d6cba70f19e59a6c8d6142b39f47ff02aba3389adfdccb500a88cbc72909e9e93b8efe074d0161496f973fe360e77a9c3aa3759a41531a401bdd2f390347478a37e942b9c0a7de4440306ebb87fc06163e5b3f9dfd647ce22a9e9f997d319fca8520b3380c6f1e2034507d0753e3475db2f8f452c87c7115d549760de4b3d0af2091553abc13c2691d8f7030dd86bcf2c2f5921cd63bd1ec40710894df0647814662103663a7ca703e702ea5d0e867984a6cf2918f7612939c481043d72eeb8a4cd4ac5ddf1bda1252f1a74d25a66cafed87c1caa7d34009c944ef8d2ab7f6a7db2a29c10c6c3fb93eb3ae5bdfe9ce890126c93b8b664043074524feb07cfe6bc60dba2bed1ede8ddaa36eb168eee4f769c5f20be4613759d9466e122d955aadd3ce3591d5e1d70fa314bfbd69056977290ab018e4bb744994af875787c827627d7f7566b496953af0ed4f94a729ac729d989eb2323426bc84798da48740b8363b7a54cf1d72265b9feed067927bf30c351a75f907794acceaf26c84e22812cd30cd1f9566b6356416b39f3c52fbbb858064faa35b49201450d1be11d20a44d3268df46df49c0e91b2c7cc853233a081b123319653ae5e3ce551db67a4ac38b97ef5c992b4f636034a6be12734863d80c60ca0a90a0bc256c01032873806f85d6f2832b51e402f77041c402adb97aa5b7b59e0f79ec19868ba54d3a9ce34c498c542e26a66b1d1de04eb587e7de5750afab994b04f194bbd23762e5bf60a1f1768faf4d8dc8837d61ade39ff9978b36ea81369ab3ec1c5b564f68ed92bbd4d7a30ee9bb2a25ece874272771dcb2c333e73212950babe56924a6d99d160c3161b382ce6171d046146c337ed131b7ef1e7cf233b6576b99006d579520d200cb9fbe386f59063f0b718814ab7af2bd68601506bd8fb303c1f10e6fbb250fa29167e6e1bb60f96fa786f5e364aac633bb2c7fb45f2c08f4ae902a8e97f5887f172b40f16c9ff01e157bbbb824d3dd9ed9ff406c822b95c974b562326cdaef272fa10a9a5354a17dca18fbc903a6b95f1fc3995c3b9cf8b8d04867d3ed5bc76882c883c3a5181d287575b597d89cd936a1f343ee6c07d7af4d050a8af9be247d27f79259f1d17c0c044edde82b9d5decfaaa4c66b7f20789ceb9961c9ec6c0026b62993a4853771406de43ec5a50ea867a0cfbfdff6a9ce90c51d7663e21d05fef589fcc2f9ce24e01023c1206278aef9ec1df82e71beb5cc33603030cb28a6fef8257437533d786d64bc46b54722ba6bbd9eccab99f279bf83956896650b5091720cf7dbb02afd0543e76d7230aa54444800dc3c5e6ef915306d012a26ebd7a00a81625a592e26fd122ae5f3b858512b92e056c7fe3c3aed099bac830226a181d808b7cd949b4d516d1d087caa98992e486e541d529b9f12e8cd2a2193e0548920365a065babb91c1a8a33b03a6d7ddf35ed5d1c41d21ea3fc70d914fb126e8d64380d71589a514742f1c755e535fdc2a847dea71cdcbd520d1cada4ad8210fe06a80d9ab9bc66058ec8493b39119017515592c72952d341a4bb875f18a4e5bb948b1028631ab9ebbb5984014c0554975117d4e3488993be84db38af6391e3b2dc60716d330ca210285f55a3529b3e1cc47a3842fcb27f78e04b8f573512dd67167feb544354281c575993aa80df7e385ec442915996a0567df24e2bac3c9f1e569f63f62319fc100279c20b157151c7b5a4f32dc23acb283c46e7483a0f9f056c5331388955f0043e49d6bc4dd4e686cfea8c82871d24a8bd476d7a12eb6827feaacb7fc73d77d9e32b1669bd7ec898e749bf04f704bb388eaa4785f6789c3fccb21e394dd89e2a1ab3332bbc2a4b4ee47084849e0990076c77abe035b9d2edad03e98663ac2037bef85f92d46ce1cdc105868f7a27c97b26aacd6a757c7137d049ddaa7d38f4c3f8ed09a4a5f743578e8828c5b8231d19ce4da1f7794c56c8ef5733ef5f53bca126129d1b7d73a8f28e60e7cd946bc01091a6dfe4fe182f70eb4e4e5f5653e39fd7e6c03b7f8bb9ffc3447407b7e4f893a59a29706f6229aa7f9d23a9496b94b1865e981ddac8b15cf22daad5d2b90b90794e0aeab441999560c726794375f15e29e1df5b966b36e49b4cc1f0a11261d4cf32e94016f630294a726bbcb9424bcfcc4190d2b5d7771eedf234d2e3f40f63c445a754d57ec89e8044679494f0a437d1a321e3b7329703028120dab663ff66397d9f40263166a860aefdda23d0066f039465fff74906ad2a6e2059934a428b38f6cda00c02a5fc81ea7d5606af7de0b413a4ead9f55d1cb5fafeba32baad45ee3f6c3ac1d88f3be2145874f2ba058f876bbcc1ed55b413c3c6b67b006d4be4873f708d36d7cea435d6fcde7cf45d5a263d5ea9d31a6178ec7fb13dc5f13b5704a82f10ee1fe8562bb7ad78aa31931b68104e93c218a862a044875c69046fb3b0458e3b3800359add2513f7d692928225d80a04c90dd2a831b0c9e6e3b3f57f9e2dcdc9cba31a34c18a9f158ae31ba462976edce59d6d4fe8f9ec3e809968492c469e560d5e0fbced672080aae5e0e1a0d3276aeb070111298e83a3543cd8ab32c3bff93141e8496dc2a59e8d2c5367a204dfbae8da079953d47e8de0192767ff995957bb6ed674cdefeccada217ec999423b07580a697b81903a9a7c52c7fa2e47283be86f2432f49f1f137ba296ef38b28531efa58ef4c640e72921ae4de26eba32280b259c1887fceecae477c106c1015516d0a03208ce55e887bb2189bfe413ec5808b40c590d5ffe7f470447e807dce1aa2703b2dc7e24f43c6b30a25fcb99d2222e8e19b3f4c4e1d4b99f3633975da79ee4558edf6b8756f2fc59ac38d3b14edc8bd6fbfd465ee699416320325c163933b0a23a0e665e5552b1c7292a460ffc0ad30d8ad715f86b0d5c9ad634a4b622c31a8b341a6b84563750bfb78224e17ad89edb91aa49006d1c8d27c1082972d02aa843972b74f7ce644dd5b404402a9225c75a9d0979ef2253a4ab44c0cb65de63d25c5654d7688b107188d80a6e448072b02728692036fddc4e752ed69682aa8fce28fd06b674f5c8793129ff4af24bb7bd396af7b28977e926d9ff3e5701a9de896db79d3486533cc2b8317519e1d1efa377ea23a57c163571ee2d8722a5f49e85e41d58e5ddea60a829af1acc2d347e05c9b64bfae4c0565e5d8193187bde6e254ef9428b3b543fcfc845f918d3731d40f476610f5a5b8df511254a8d920af61fcf2edcc2fef11af27e0a00ba128d437746ac6f6a5c605d0746d39e4d15a2dbb3f0908d3e7b25313bb8cbf38662b26f61bbe42b785f44a91679e1aaac6b9d14e5fedeba9d0505fbd58ccdceb5c0cdb5a11e63dfa91345bdd3b28fdb15657492add59d5dc9794e6c776c871c62e44f8818fd0abf68b98841ad7172578db6b000119e65bea20780cc092bc443599a7318ef3e3bc29bb7b9d022450edc837a61a810e29d9523191f86070376ecadcc85f772415b204567fcde8067cf4afd4cbb4123825e6888a3f2073e91a7a37a980f78bb5416d0c9d535a1ccb65489eea05dd08040d1bca4868fed2453b0d5a8507e12c63a28907cc36f885b11d248afc3457e9c59c38a69f7e7f924c70b6d3a2724c7028baa661d58c821edf199cef964249e37226b7bcf90f677248aac8a9a910939b663629c4839650d156935997833530930bb95db3a2965152655e8ef2065cc0b53b86de06f13396a3da290dace83bfbe6d89e13511363ae7066e9e5d87288ef4c9ad47d9e7f232e314cf8c7cbdf4560c3ebbd117c7355ea4f25246c5cb0f3f9b9d18ade55e9c3d25dee75b56e994780a21c03b7cae5d48b68693aeebab834b56544c79af5784fed9eae8bc4ef79dbfd321ebbcf0ceb2d97c2ce00657d5a9efb48253963bd1140653893a842df6eaf4841a57d42494a01c74c7ce9998b91edc43c7785de1108b77c3329f2c8a3e1c83e8e138925cdeca46b2d53e95162b9a8e25fe7597ae11e4e4e45c7e68ebfb53e41b3b06b52631c95fa5e446888ed6dba28e24d5de1361c575aa53d1f5d5e5d0a5ed717ac650bf85616cf62e6b4cea36e7036b9581000b7ca9a7b1951c00ee67845dc6fe8a8d78f29d684d9e1787e6047455656620c0092485bcb38cf73a2b339b366a784a7da2ea9b1b9be446c15b57afef404292216bb8daf2e7183f127281150a5c3b9188f3b0f08983a2300b7c6eaff97f1c97d2378a3b894e0d2b74aacf23b6a044a7cc7ed9b946e35e38031b782951df5fbcf94d2642b08e65dab1cd3c8544af4f932cc9e1b54570bcce22e6c9787e523186337770672322a2ca2a848c888d3d1e7672f706678f2321fcc629790ddb0be3f83eb9c4f10ccc49931a73adb219d659b51e0d9d402821dbce6f9fe23c026ede7fb785639e15bab10be71993319ad91a33a50b78467395b7389e643561acafc2333818b6c959e56e16771f2f16b6822d302216f6cf0cb67e219fe5d3d6503afc2cbb92d8b8ec33fe520b0c7e586b67c42f704d0fe586b283972183435837aa613784675e0512813419fe5c7f58936360f7601b683b771e3350768a2bbd0e1fc88739e2ecdc59bab40ffa19fa270a228178502c8eab5af83b0bb0ee188dd200fa250be8d938593266fecc8161ffd08859c2aa381a146c96614092585acd1b36caa0089114b22d0e14a53b03c23b8a8c71b069eca655d19702961b38d374a715a9b4b9a07ba47e54d76a28a4817c2fcd2feddd5d70d895b880c887553a6c9c10dcde1c22ed7ea6b69626a324e44398377e37eac64c3a337b73f2cfd4a60161e41b5b0461c3c6f5b0d213cb768b105ccc8439bb61d14a824fbfd9a677ca338b85cdf7c27e4e2a19299eb64c635f46b76330c4eb0aaefeaf586ee4c6b3b4a2c5020a0f95cc3613512382b7cc7e49c126142197dab8bed4fe97ae54c10c141aee975ba6057b117867209413eacc4df62a6fdf83e3dca11d88879f4f47740b1ab5031fb4ebf45534f8ff2a6c299d1fb1ef5e61e8fb0e9ec4e93764befd3143945f814a7049f6328d70aeac16f8311cbb2c910fba62dcbb72b3fbed902282ec4a7c6f518c19ba2aad158336fcce4f495832fc20616f9ba630b36219514cafb6f95e63dbd6a8f3060d6f99be18c60d54a4cc034d88076f05745280f572f7713bb1c64e14caad2c9274bee291f56a4b4a7cc3ffdf6174d3dfec40fe5709dcd3c41270e89e7a234dd8d8e34e26cc8bf6ed5352f1153381e09024c40dda7849df18b8d27b67334030dfba45199f7561e44ec25a409fb0f0eac2b25222403925bf5e2ddadad422ee634450c9e70a153428d58112dbbd127a01365933f3d2d8b629f79174d6581a337bf53010d1a3259a53792795278d39151f1878616113d5a533bc3cd475024320b457037ec28b074b2b23e9a7dbfcd50a3d3f9d5a5eca6893ace95606deb68a76e135d32dd8febbd5fbdebd2f83aec69731c4fd4c548146729a887d35ba76fb05521a6f1b2cace931732cefa8160a5f3c6ef7587d8133e90f18aa650f7a342b757ddace3ab0dd9ebcabddc56a497922c96f59b497b99399e1ddd53b2719f265245c33f11c89400174d5ee04d744b36bddfa620ff4ab85b8bed604bee7dd60666505db00f95dab81970b6ffa56c6eb63e8946d3efb717da1a8d8fbc0e5a0e448fe975ca957c26bc28acf679a3a4f63661eeeff251fa0b3931c5aee820a6a8d206836b6b8f18b909bdb05392f25c61730643e2f01a5a48d505f054285d22fe497e473572c03f7503c7dcc196ec10ed682039cb05211a6afa47dc8b1cafbef129a42ce4674480191f99b8aad7a9ec6b73cf4b1cb011153040e4df737cc748181e517e53c058dac58d29150f9b53fb5c5f17c727c0f5c96f1c68bc5a793dcafe6ba531158357b4863f165f9d2e1c29deb6666d5c3c3bc41179e5846a6b392c6290e441dbfaff60cf46372cda79499fe1d0e8bfc1c2a6ec976ffcc6bf5f702b60a240a8df8eee3a8a467a09f543b59d8931097006181cb91a5c9f0e5ed5084dbaaf1aae2d92ed5b7c7b1c8ee3356fab71b964f5a71193b7dd914072904a022e6853058d5adf99914921f45520bdb31e07d394b4e931c8fd7994c3013839c342a703b0e7025528526d5ef0cc4f95f70f72d6bc47a0422d6efa8effe3bc907476b251be7359be924fd54fe2e5a83e77a1fd768f0a183430cf5cc626864102cd50d508da2415799b615a59e16009a239eeda3658ff3f681c203f3fb7f60411c311e2578c355b068b93c16eed8420211358591de7462afede135d5d2201eac61b1e853b8d40a1d18daa29343674e1bc71ee58bd68e3d58c1a752304ade09b60298af08046135ff994d986c3f47bb6d8e460124bc08bd2c78f80eb421f91e9d87f317d872d317926810737d5aaa064919e519e920fa53ea28a1add5733bd7ceb44d6bd6a7cf14ceb93270a00d0cd1a9686eda573eb9697c310a4e1675b3579fb35a1a19f0b1b37d49e0d3e90595a379c4d7d04cc391cd3c5079372a2658867e3074cb822aad828e2de29f701a588df2ff937e89c09f4b0c64cb4705edf4e8477c25ddf1920f5cac507f3e10506f3d5b320d1799ac3f362528c51a2bbde8e12f6976e8f26f700c419257521f0032a0aca472396c6814e2489e88b99facdd452bc3046a3e8bcb46f96364eb69eb7ed3f57fd937f6bd09d07509260bcca52010e8fa0b07b24264e0661449f8b93d6cd2053b01a941e66c466a75006d0384e57fe4b7c67b7f0932d08d2bce0f59eedef1ae678badf333f10b39953456fbe377715bd1c3d4c35886f3b4de9dae62e402f87ba18f72483cd82a829d6b74ce6b2817366e26503fce5e38c79fc1403b6e3076436e871bd97f2363e12f787bdbdcf6bf9d9481c412a11aa953984b8b0547e8232c6a808dcc54bfc8416fb7ee0d5640af27264c6badf722d8174242700fdc59da78ac71d3687287281d61a87c0324c55006abfbc58f50dfa46625249b76595b8c720","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
