<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b89860ae830843ef4ca2fbec9196743993ad66fb627e53de2a011694b9e8ac2f3fabee4971bd09433710e78f1d5ee2a70710419d4ae51267e6203cb6cd1940e2fdaf8b0616f8b00c4f47a5511f6230d5de4a68bbf7ce5b8345d21a52a79313299eada4a2fa0326cb3ee9b75b3a6af560a173a98fa93dea1156e97cbe4764cf0a43a9bf21cc6df0783aad804399ff6f17b0bb78b37a39667ffafb7135992f6f0e5c7d57e5601e2bfd4380f464fe3c5f39a20b1feca825570070ba0a83f130699011af78d50618166a12b430c5c7e836d379962b7d9966d2ebd8ed7f906367e59e9b9175b396ff6a4073158f7bfe53930eba29278e81fc5143373346156ab896b6ea302bc5caab74f87f5241f1fa81135aa469bc99663fabf5847b49aab0fd87be1f8922519fd9e7a10dc6f4721f4765bb32206933c4a18ae2eaeea161c894dd246c44a7236b910e567fbc9d5eea72778530c321ea2814d31c044d8ec493bf2fc5beadb879330d3109334c192c4be5de49e0f205698774a3c50111839a78d566c24c9f1136abb2971967f1b0e941eaccdae35112902af86b3732fab462bb4443e3ef2229bcad580747ce47efc3c6eb7b0c9dc97c3b666380b6e97f189de8984d63fe776d1d6d4aa5c6c36c46c99c383cbd55de34db94262616387ea23e11617bf30995c1f129fe0d11f8a46f49cf9aa348bec870f1019f9f60861759e0d5071ecc7f917191420cfe1bf9e581360b9f5d3d7a7ebdb42a2d9976b200e874f0b814aeda95ac8bd7b51970250a5f9d1262e384f514352e71d80ac9629e9aa9a82e5f6a20c8c8146a0ec869872a6d162a74d251f7e79eb59b0a44378a9484af127ba32a16ac450d763db418a3e21caddcd3b1faec6b4a403f92edfcf439a9acd343454fe2151f072a8ac80e37be658f58fd54c8e335634f6fc8962e22d0cc6d267007852c9e8e6485b6ec0ba3ca0738b21cc9226d24942b6bfd2571439bc9bc04d2fc9f5ebfb9946a4d85dafd741981d5cbe6a2a8a625925c4471e6bc933410e04d23b95b34ec5763a68d64bb3f81fa80e58148ca5a6a46e77fcbfd735f98c35db4bd9644ae1b037b3318d12c73002de16106161f667eea7b35ae2f2b7e3cf9e2e3c4cff929c03358e2820355adb71a1f63633dfdb36c297104175cb7b51c74a17da855054a91fb9f595b5091666ce3aabb6a4b20bb35429c3995aab5d12a89aaf3360f310a2ba2f249132c1faf3c35fc0265c8ad84e712b325f8b0ed66df922c5064c13132ef5a879546e494cd080a273879c6ad1bffd6f1e7222d4af3e8877773ffc520447abbadc84dd3c4ff7114607558c0b9452cb0bc447d443ac57d08c6d9dd83bfeb98b4649037813b7b261ce2bdeb634dda14d6e4db088f9582ba2971f11d59caa5dfe7d57eff9077c1b19c97d5624c82f0ddf2e16287e82379ba57d60092271e61a27c7946e60387ca5ad62461bb6b579d290bab67aaf6253104abf98eb2b9e77365c81a7dd06df165ffd10f8e0cf48d1d545769e25b52cf7e6b500857fc53c2df50f428155b6b1c3a4c07ba3436bb7ee7eca86de3577d0e93c98106d088b37d61779ac3f4d4d4bf7537eb080b4753a3b50d457199c1a2606f6d7ef4090d80315c598dfcef6af3b780e89e8af6a2b3d3ee3215e77e2cd6a8a6561a41c9b9014fa708c09f44c5ceab5db62e2b396ba696735418a25a8e6656a1a1c4621c4ac481501b09afbf146d2a3446ad6d7bd7debb5de8e74fbd9246208dd97ca37b5cf08ccf797be9306d5a6b3989d89c415d264796374d41f6c565b009804cd04abbb4a5cf00293a706cc96dbb4fbe2935e7401635d8dd3b199c32fc456c8bc093c97a325b8b7e885ac8db7f9b3da2b000d9fe01831143028daf0b9d46940202c0bc8c648ef3dda858290044b4b77736645eef3b550ea746005cf803b88d3ed59ec48055539760e12a92e97ddd683bbba9a20305581261b3a9b4316ee88c643007093256a2f0f7eff5fdc30512c574808ea8eca49bb2af9b4dff3986830ab2ffe38efe738d14f43bf075401287ea8d9d49e2dd8fee4c282c09a2cf9957e6130e83d682a5de0afdf981d8c5a44343e19d6a52780839bc6e43d49ef3e213115e0f6338638f6a66a5a4c8a4d0dc88b341dd3de4eeaf2d19bc081d59ae170a2e256f85ed0e4460531707683ea75fc066e1b2dc0992a39422fb1cb2d788453b3253f5922b79c33622bbc2f2f981cec3e7dc005b9ada553a5a3dfdd54cfed01ac5dcbf3e050bcfd9bf46e760c6af03fd67ee03b0c3028226d5e1f92180fc5e77af13d7a3c90b9b025f246721dc6e06af814a1f435167a537d7478ba4b46ccb5a3e7ab8fd3cc556d2d6bcb6ae98e7e86063823d6acc514a972c773dee2c5e29e963859636b707c04c8c6f69d5f4fd0a5a46c4689b6b2138af9f1291eaae06a5bff389ed961e2d213f0f5cfe9da4175c667f5c266782bc44e750d93b90e8d53a99446b532466fa4a837d91d43ce99ed7caca3144f223b00bfd452737cad9965a534b567327f43e0736513bb055cfc1501c0c61eaa1ef28398b2696b634b12c567843cab0ad66fe2b4c26b939b814ce80507a48a82a9aa1e5a4f83d3bad72b3a2da5dd0acb4d11f43022466d429dd66d63a1e0cb0b2cb70c18fff54b7c61fbf27693c048d596a05dfea60e1fbcbc5825aad035c517544c990a8f9fc61e8cf1440ec9dcdaac8d0d70cd8a5effd56cf2a012cc1c66bf0e8513c8c95b364d4e0183c422f75eb038a8d7f2d75391c05ca894179d697d0bd36dd932e438c9f6317a2f782901786054c3c5fec4783e9d94d72a02b583a54fd0b4cf38fe2f2eaffadc36a8a14d282813ae29a6ce51f9796b589776d757ab914d9483bf59858c7b64b3bae6b8af53576bfd546aa00d4cf65f3a426c25f39747ec1e25f31f860a242d95844d17291f389ea390348a4e1bfab4ba463d7416c2fc2e0e5e8683c1403346d7f9589ee15dafa3f13c47b337e65c003bfc7690c5afddfee7aaf4088ec8d761ca86c81df73d1de7619002ed7bbab939611d9eb6cb0c2f6eb9fcc1e8dce6a63a472e3ab4f4c454a6dcd79390c1b0d00f5bd83fb4d9c64cb286876b2c49bcd1962c34f6959b72038356604f5d816540a28ff123739898ccad5b08f4d1289934c21c549c4f6a0c0ab8724629c98fc66beb904521a648526ba2273d07f50bf5c680ed3bad3e1e65d462d463cf66742042f65b3e39c3ecd77e9669abd9b807d592ee25b0ca6294f5212ba1105e7e415d3965798a324c7b5844efbd76ab41dc05c4b5a92921d5dad80ff6f29ad2d52c3b4f1a36fa398d9148aeccba41c146fada82e5c7c8140ed4b6301f692165e216334787251e08152784e26f6dff058f44541345401cab467eadeb00d15752c0ac887b94f189b84ca1bbff016adfecda86d53351066c3c47668cf0c32425a859bf56da5172f5c5c3bacedceeca98fdf88b95e737edd34b3e411f62ccbadcf7b56bef90993e39c393e2c2d108f2344c18fa6aaccb755070f5474736a43d451723334563e0ce4177eb0e719be0220c5b42690a1361b12d4e0db2384a960546ae8919031ba32919acaa81787583a19e526ac33cd823e3df06cfb69206ebfd23efdfa1d88c1605874d441926c84f51a07fc1317186fdacc90b9d22a1935f5d9d5eecd4be00282915fee2a3b617e4fd641e6f41e9fc2f1b981a22f96fcf8d5d9f2da83d2f05870a835af8fd7f80aaca66c52fbd59a679e99a2749a3f71df3d22a8802959d9166790d388a403980c86d0d59c6b02f6ea9bb654fdfe57962baefdd199eabe5dfa3de68c4ab6040e924057ace104eefbf4d8beff81b38b33f694b47724fbc185400ed0a4341e39a8153731daf3242e54c72f1df828f1ae8a7bac3fdfe10340c6e97a2e8a5ed2e6e4030ff9f225a75ea9f1c26493bf8a088f5a4b2e452ac0d64745bd3d9941216a9eabe51662b47551d76ef2f2d48067e0ffdcacbe10709e3073a9a82d64c531de551de6e9784ffdcd2e697886009d5c1b8810e0b36b6d3fb33ec76f2883113b5299f722f62d8b9011c7643da098ef43001a33cf774acdafbda35f8b17e7851e25a5ba8c9d733d2b700234e6660a401fb4ce6f3c5f27290ac76b0add8eb8e115fa2d4900d905aabc9fa7279999c96341e6a66befee68ac8bbcf94658625dcc05af52de7092313342175cd000468fbb65d943898125c4ec42850ffa41f257d3614d0bbabefeb868f88127dfb137c1b21217dac6d5c0da3905357fe164f5fb4ed13dec258fb952892ad609987a7e5bf14ba2410a04f8c0325623de7863b92a01d6ea2440a2b3755443a11521fb3fd2272799469c0b5171aac6dd2bc0db967ba8c583b210a2f15c9105dc93b66e1491e67f51f04015c278832bce8ca35d3d4a6d235bd8ebe44a4e1e62dd11c8d29c347b7b74d4f63068736bc7275be648338a14078fdee275957a15c665e93f9176d494a85ccc26fbdc7a882ff833133fa961375139a219b223e72c18f076335e26b4634e3658134d95701169654c0d0301c86908396317d25dd49155bb94ff1222c61135334246f024ee225bb35e908e97a832dcca9d83fbac895a27a000fcd60c868ba6c22d2dd9509f75c0ccf95429f43604e513ab58ad870c568f26a03390b817034b8d7602b7d7030a255f100b48c95818b6116c1982a216bc141c8f454b383e949a5eef93ea9b34a816c61763a034a5d3cefb235e07025e9f16e80ad247fc4985940683df6df21021765f3b76192ea5fcde596d5fcb9d9c9310384429d6281c47298b75f076aa1d469ae646379733d018fdd4461c200b1b8b630ebdb791d4206aee5bd83e8b94e27ee71ad9dfd7291ff9c147997f6972daa150f37fe37d2d4be529ea04cdafd2aee4d2fbfeaf3d08327baf5af1cf3aa3b61373c7ab22654059a83e2b2565dbf6216cedcce93adfb05696327542d08ff3b08fd5c9a3c25f977171d6ce70c3b6f0b6ccc5e6e35c4bcddfe61ef8ead3742bca2b816b41ab00577885172a52d05e25d0239c1ce4175f24d96ac1df505b92f0b4e209b79b26383c7266dc333bae607c55a78d15fc7f4aa17935222bd536c863bf3716d181288a5db9704a4c9790a1718e4c099b2bded8be03015292499395c30d5916de9fb91af664c46b0f7342525797bcda684d75799ef8031bca2aef5af0db47e354525650c93fe47f903c4847871ab2010fd0f5259e388fe2d54aafddaa0fa4392030394d247118faeb4ebbfda83c91ec151e963c08b574d4d4aea28b78275912a1e0b7276c7ae3c3d1a1c79d34e957e3ee65b6be77a188c5f32360e5a13f86a6b2bf608a40ffc2355f745885b1b09a0e59f0725f85bc136c68104c5cd066e9b940ee19660c9b52b2a68a5555758ecfe0bdf1e01847c8177289fd6b6019f81bc8f902c77d69b07a3b7a162423e75f68e3bfc26b540bb2a8bb25d29ba9a5de5009fefd3fad1482e77e979f047929fc540e7198c3c9c702d1145b7481284248b70f50a2deca22bf5772a8a4059abf4c03653fb4b8f5feadddef95d9f0c7934810bfaf635144f7466ff049fdad720a4187835c7d9da5b3524d39e81b22baea0f8ac12d25f4943fd97fa3fe3f2bf9dc6ad2472196eb24ea211f76168ad90ccb23b553c4084c241e9dc9176043e4a1398c66962d1eff032da29dffe7ef20eeac579d7ca0d7315f6f6b59e688b66764ccee838c2feafa49ff74a615913f6ed05145c2ebd6c8f7f8426f5c77e3d264eeb5e41e75b80e86418555b31f1e2ee1a21e15478391f919a34a165fae6c7c34cd93ec4dee4e0dc28c2a88f45c7f65a7cdfa45e6ebf95d819dfbfe21be1fa6050e6049a40abc56520c17ff5f234e908f6715b74e3176d48e7f7f186c2dcc57108bddd703534b92684408abffc7afcfa33356b15631616620ad1ec27449e31950903f15e7c5955b53c3b1e78e3c5de514fd74d9119cbe754cad794b2e765dc23d2bb13be72f094e5c9005fdc347c80d3d5414a953181b60fca58dc5f1e7efba7966025d2908cbc5c1a66fca730cb80b173c20e64819ee079edba9ef037ce842a56665be3aed6d43bbcc5d9566b8eab77ec88c2ce88401938a397e87658ac88d5181bcf34e84b45118292711036b57f42d9c70a7efb4e022b7836a1d01f2864636a418f60752ce8281e432496c94ea8ee0264383b689185c4346fc8d1cea2812b0a1954b6f2dd1198029066b764d7781f90d10621afa5cb7c296314d779795bbfa172219f63895a27cf253dd22d9f5e8997decc9a45b7e56db8137fef7577b24cc31350574229678a71c4984e87fac9509e49636041b8be17fdbe8f8dff95cef8080cc3ad94f4076790b0b2b2f83c80edcb340a7e3406bf39b73c8c026d6e68d10a58dfa932ac7010622c2ccfd909521e5cecc12a22586d53c556be620be469fa7c5cb8489850e256365c2f490458eae18facb39b7cf85a8adcfb309c326cb5cbe445200af0a960a1f9b4bb5c8ff15901654280e4f7b1f610d5147562740b8518d29cb068908b711c29cbbcb21cdd1a731b09bb287807bf149470bb9cde5264a50f717ec184d036663c101d7f9d26618eec50d48824d071192822a4aa5b59125e73ac19918753c13e350f68af7396c4879ec8daf80dccc20c2e454ea5f4bbf917f9f971106a10f6cd9209630d34e54038d1d3c7ab2a6030f7115f3458ffe3f0e8ed71ff6f3756b34c817b0a8f60f6c4ad4eb9282a5cc226a5a3223adf165a293a172637057da76b6761bae243a32e1a6ee56fb6bcad24848ad7a887e77de4a3eaa8b85d7dfc1834237087ceb157e310e5de7f2fec440f205e3c5209ccd361968e7d94cbf6d8407d575c585eeeaa0cf8e459525f13c4cf007dc07f81e1ca427042115003e6fd48a6939a4402cbf68f5e2ec77c6504528c67259333e00d58f99fe142d0e50bf22d2aad052ceb54125fcb1d4c8079f465ce7537f0f02faa35ba83e2ae701790275bb4f35c1025a904ae4802440bbf118e10176168748e4da7172b7666d1242c964985a2700d4aa7e9956a4d9686c92d16d34d08ae86b5edec3a558dc3a732ed99597d8ca087948c22742e4c5edf5a33891d9500598efe1cf5d9759ee2ca71052adf6c63160d0445bbd5cf06f10ce6ce2737642aa16d79c8ec092cd64dce417fb4e4f82ef73acd9b6dc262304b0d27fbf64ca6e36e8f156914032d710c0b6dacd12145eeca404888427fd09f7bdcf5cb4353b694592edfc26db4d2952828015793cf288967e85f96fc32c346281a7ba2c77e9aa44c6991d9c14a4fcf8c24b74007d2296fb50286fba905eae5f070fd06481e8f6822649d80e0f793626b72c60f62063417a850239ff0c444bee21a48b848b70d0cdbff7e2ce0e49dbf185a6fe7db0cc95d070dcddf5bd0ad19ac4c656874f9ae7abfa60833f9aa3f3d0ca41bfc1d1455935619d843495dd1ec9c305027dc40e5471259dd2a0d3413c9e277438b7c3979572575440d08c12b570dc2ad631d83c9a96fc128e3f2700a7d0a8b14b53a9cc5d9dd397e31c29187187ec0962a85ea0d903726c5bd24a976fd40a2b1e4cfb87a146d0ece56e3968cf7734336f38a1d23eb0fd765e767edb44508fc317447aaed1058c0605560ecf612ecaa5d68a9c097793ded4abd944c74b908ff0abe1889ed361b62e24813bc17b68c14acbc06b1ae15430af5c2d6fee6cee3e932950e071f66f8dec5da198467dcbc403e005e1678e47953ae42a4d0d5fed71124e0437d02b1566365f965e36d05fb614546ea2dd99cc762fa2568c855365c13b1af48a1fc0d5a517e06a5e1cb4a5dbc588eec5870ec8766be8d1a92dd86a1b89758b4ee27de3b1d19a698e390ecf190395d659192d26b37ec1f203021ce6d32ea1ed6c0e8a053c7d824bc9c70aa04ea8e9cd8b030da3ee2c43257bbb0f4005bc89119b143c835662385d2ea58a1eb7e159bab2cd68554941a0701470ed7aeae6bc07391bf363c46fea5155f991d789ad9495750cefec38d4bcfa46a220a73072be013d5f240014160966ec1ec0374de3fb43b3ababe9c7ecab2673216b5995f3f8772bf8e875a05342e1dabdc29645a6a7eee7f3424d275aab2dc7a325c94ca3929cbe7fc2746b960a1922a3f6075600565de52aacbb356d575fea767155919d3798fb2f7bc1b2a6216320b19f6ddd5a63b99b0759bfcde1687cf42ab07d8e54f4b72235698b8fb80e2f0f124ece06cf7a8e1623ff2caf1ffdbfa8b22569948cb796d48eae54c2fc29fcfa721740b6366c30f47b4993d878c81fd1264ece4ade3256926a86d14c10087e009d765653ef42d40ae3ab10def8055ec5005abd5eb54514651a212b90a91c2d4bc9341026c801d32af8f21e7b8b234ad5f375d117986a037cf6717fa902332629cb2d4dd2fe6f1c65e6f4131a4eb40a3dad034f75cdb0ca249adceaceaef3549f6defb69da7eec0aeb5eb0751a71f8a63fb8e5d6c617d7caa9a774f513f0a1aa2244e1f622e0746254fb6c0b95730c635a4ba0ea70ec720f00b2da2f859ade986c80f555711dbc41a78c5154468b27afc81c1089cdd9c26efaa944f63d5607408632a34ba603e0cf729beb97e8adb64b95b356ae4eb278a4bc836bda063135080441fe1adffbb2f55d04478657f204ffa2217b486e470c63a9a7a754b48a9bab0912143477e6a2811e8b53a62562f65231509a6b51e6caff968fc3b405f13e208c407b065bf9d5bd91d3b269729577033bd6a4d0c870759069eb5368820f1250865a5163944d0286d0550673cc477226ea9fe75fb343eb65042a2cd00636a8a205e00e0941c9b7a75e858dda0341da19d44e58e4e78cb3856ecbaa696218ded55d91e7514f1bacd027f3543e3737d973b857148bb50885d579a2d99dd829d75c6e1de9598902715e9821b4cc0d8281d7f986a5aa1fe02d203ca05e63c78f16c9eb4249234a07a6bd21a19b296a7cfe425e403e3db5d1eb39066b2148a797fa5d47d397ebc56a56b29ae5e111fb6f7be9e340d91f54478da1cbb3c2d8e219e6271ab3326f70997183f70eeb41f3df8584892cf7083803fe0e537bb575e091b4adf5386cb3927f757c3aba4d44ce6310a1e49bcdd4738b6733f1c166e6530496dd32bc70474fc39a1d822ec1a0792aff7196f28146f43600c58baa9dd21920534d6268bdaa8186acdf6b32aa042136ccf2d468bca9b53bd884602560683eead45d147af9ab77a9e91c8ae757345cf39cac5429d57233037a09fd01dd5efcffe93c3c2d2d15498a167d5391ee145842ee924216b651878361a321fdf62d8487311111927c15055508051d9171e84c275d978f6fe190a64b05f94c250317a696a21c004f9af014587e98d7608faa825b9ab70de55f8058bd60a6e8690d5fb8763d0538f4e80564561bfc478fbdf82305a512c4c87b38c067c46b8323a94acd83507296d34f1b5fbedc63d583cfb0fabc806f7db3145dee19809db23d0eb1e15bbc373fc839f0734299fb21e0486a5a5d82165334828e90360a682ea1ad4af43742e024a6922e0a05d07468865758ecf1a7df99b051905c6a5b1a250ae227f83d4701cbac18546151c08f5131cf9da6b3bfc62e52324d679d960228777f19b5d08598e01469709f852b5bc5e2664d3ae2d99853342505f9326c07a22e92f48c50e07f3e2b2aa3fd9dd3d68cba81efc3dfee02d375c275eb2bca229ca050a270d44e8a645b3a34c02d1a687d39f384243b1e6cc28bfea6d175901153d517eda867b52a5fbf97f798a1efb514f87ff1a672c515b5dc63fda7c7b436086182d0a685bcbde8032d77fa84099e9987e910bba10002a9550de71e6f7ba43c8f19be1507f75d2d66743d6058617d2fd333b31e1bf3c72ef7cd9042dea71fd5143d68ebf728ee633fbaa45d758fbfd382f18caca19fe1be0a0bbf6bd0ba8894048713a7ae11848576788748d256ef2954c7db3ad49e5250e34381d81e3d4ec8ad628085231e88a37d7f00d21efb39682b5a19507b61fa8030885e734768ff19a0efc42699c89c88b05bdbbd9638d6c825623f9b868fcc4030b90dfe4ab70029cecb50bdb45cdd7255fcb751df09ddfcfe18d7b477c654440b74c20fa69dec7e6c327b5ac7f8fcf413b29f86288a442f99285884971155e8aa6821fc03cd581fbfa2c6792ca2734ef6a992e67cbf08c8b23f5fdeebb6764ad6ae1c4c85d5bf1d9d206274a6ed4aec3c2e7a46765a1e269950c6fcb04cf7a1b92dd7a3c9c2a494b8614f0354cba69c9e686ceb675e150f78cc0a47c37350907c54f4dfa44ed679eac268603822f01039c6048d3dd865b02faedd34081a7978c96e3e2e6db5fef4bd18b64b55cc1d5aa862c2742dff668a25acd8090edb64081613acfe672aeddb46767493e18feead7ab344956243c87f3012b8ca395d5cada3f49e9bba05b2577db521ea1f050ddfaf581f4526c452ac15ae1ae5407113c3b4d1e5bfcd569f20ea12aec735d5774b423d8ebd9d09e8dab8f1a080340ce9a758a9a2a0ec66ea4dbf42870980478132fc3fc860c20629f5116f4774e435ae534c9387533428e2d772d5b5d112221e179b0d04b360a368ab7999dc15d6a215f51d69655e66261b7d849c3afa82d8c888fa1b118c72309d8375f0b8067337bf784d0f506e27c1fa82ec1ed4c0178934ef209553ddbf6f406d7159d7e172e5c28ad3f1629a73d0c994b89105b69b582580af317fada38d82e8622c98176f083784ff30fa0be5cd1756d58eefb170e1176bc3ba7fe017fff88f062ee87781b0edcbcd5bff1b32c14b8a3acaf208395ce5b0442b1059dd13da431f737cd497b70f52e5568f7a2a3a9e6ddd456895f303ff9f09a627b0109e1b2b549dd2ab84c703bbddf8df34018507d91d0cb19d75fcc21dfa75be0d33a4787c93a94f9104f2dbb3d6c08e71a246954a05f63b454c87777c909e4d001642a062b0d191aba87a78e776352e292928c5b3c1668492b30ed60e0603cae35dd6d4a474de8e4c226afc9257888bc7985f8ebc6deeb8c804a4783f5a6127458b553db8b70349521830e9a3999791b07082bf684fb4a1544a535d13c4f1f42ff9031ae0581b25fcf186a9a39037d6f64f4ea09be26dff6817ab6c9893f0641b3c10601a7d370d32d5b10c2bde385f5a3031411c6576e84c2ca8bcc603581eb8fe139fab13ad489cc5cf16a8645943955c5785f5db549656f7565bbfd87f6700de89d46e1472659572c70f694fa05ade6b85086789dd38496bb11276df05c2113183494247100a6bf70e09e5dd73cda14e811ecb01ab7d8c0252898a118a98672fea2a550153b8ea10396f09559a087f06aa3da25482cb3541c4fa68327b0a52d8f71ccb0137737f23d408ed0cf1ff4ebd91f7d78c6c60336918eb87d58552753e0f7e4d4b7ee2c3ccd61f0e222bbf7322cd9ca9ac40d1c0149e3dcf747d53387cbb02071954b85bcb1ea69110fd789804f9223bdd073270a0f80bc32fd62cbc5aa591cf57ef09d0a055baa7d9d093f88a5e5f949cdf63c37e3cfad02b40a8355afe523e587737cbce10b11cbadc12adebf613ea40b33892970720d6c7b5ac5d5eb69939da8b5c05bb366a98834516da4993dc81f899d19e0538c69682ea08ec72d687ef4a271ad3d75d2f5d1e5be6aa87ae0bf8d5b60a9b5cf48b327be70211dec7be53d95461c22f09c2f54f2ccff11f3d6e03977e85db7a0beee30de29091886f5c11b06a804dab72985dbb123567f7ec69e1fe165750b0a38973f72261d87345c4ab3af3869e146fa4ed10e4efd94113c09a7c5b76579abcadcd809b07ee26335b6435f3f1bdc52183708c10957b4d364a02df946c54d2b4f1d9b2138a0ee9a888d2764c5ed07131fbed7e312fff6147e39114d4f22ef7a1318f1d398d92a1ee9c7b8fe26d5f0e5007c645f80651e2a20be2ab7a616ddfa01163e88aa0a4032a30739b72a09e6a58092fe28bdc2219f2263b9ba873690894569fbd711723920f601c0d2c4e6584aaed2debcee692ac17ff95063564b140099b6fc09729c9380551559c79d38a5d8975cacb88edab22cba0919244b920bf65076aa8ab4891cf567760a28d9797006da48f411cf69d76d994d649d0b5330e6e63871bac26ba87e6049a52345fcbcf2b57d0c8cf46e526cffc579c01604a0d3a0a175816d45cc29eaf5f3dcee2f7d7b02270d1e064940830861ec17caf41e6e6dc686abd788b1b455e16ef973976d6d5cf411af10f8c79d04f47733cea8398e07ad35281722f8dc8e7cd9f6ceff64f73b8277bf5c100b714d94b209645ac905ed73dada1db4eb709bef6688cf6032ef3f2e9df3bc11e7998f931dbda82a3a1a3625b3801047e7f74bf4702c6c19271f3716e65fd4310b08c2af90161ffc1363302bdf8f1767ee02772a867fbe92165bb40790eeb822be1ddc8136b7a871a2266a7a9f6d0bc20ba2d75df2fba8cf9f7aae910229cde6c7999aa613249a54003aa353db2e6927832e43e3500217b6cd28d82401bce740cc0b8b82c3dc8c44c6263868411d8c3c8a74c66740f042430703e81ee9bd941b885616b6e567b1934c5be14a6b1105314e00ad7eff99b37cb67e351ca717c949830d105626d282a4a057ef631d6da1ad8f7d27a9bc969d5916c13f50f90937e2e6a10160f1e8c9a0db3a0511b9e70893790f62259103e7f494bbd4e6ed9c75cf60bdfdb0c8f951929b3c1d48465849a79620104cd53f00c830b7df12c8b17614f82d0e45f7b8b21c81ea5f49a0ceda406c32edeb1d5c43f299be027d770111727cefb1bb3c9778e05d040b37f0e73a6495a4591b8df548e1b9329d8dc1b501edffe97d3c2fd32c27dcea6d531d79213e81e725e8926eddfb7891b1d6dd1aa4fdff88c9320281dbfacec0a4f1644b141182b0935744982774d788f47c1057eab23804cf10a514c3bdc066b9e6e991a1a6e1d40cb9a87a041c2c7e0577b83b1317933bb459ae3a143aeaea532b83b2ad880f7dd016373c7f4ebe493e575d0ce48fa71d32b15deeea251431518a78e6bcaeb50ea424083b443cdfa7bb8046d02edd2642dce217237d1bb9a722d016801456659cf1038c9d668f2c0f41b76c2e02729b8cd68a20a80ef4d4ff9769e4dfc78f87799ebff05e1ace91d5c748452d19dcf54159bc8d804294b18a47968f97a12c56d08cb5fa30c059164abb8c2a0da40626b0a503d4fcbfccbb6e1be03f77649a61e5fabb2cbec7480004862f117ba593f16c6cae9346a116e9ae7a06ddfd1122762ceac82265bcc484e6d0d773b5fcf12885a60ae44820c0a1dc2eda434f8ce0bd540f6ef1e41af11916c357107b193797020f9f95a844de7e453ecd3a9e13aa3d3342feedf59f6a82f8c3c808c0a6dc635ba0a486d403516e79fe701b19672f523ecee4d31b19301a74552608245fd8ed91c9832e4e73104c2720446cc501a0955829a536661a6863abf0135c9ce705493d5130e0f3d6a08a51e085e21d2d1d3bf36da0b531bc240c61efef7dadae292d3eac5696e4057d4b7b44e9d14c8f3787a575abde1c1de44eb16a0e1b613b3ceaaeca26f34ad5de2b46456c39b774fa22239ed1ac92b706626193060e3b61cb4f6b5ebc82696ccbffc653f813d6c159031d4cfee5a05b63f1fe4fbfc3228663a49bb149083b4143d9ce4bc2da9eedcfb0a3d9cffeac98992c384d61851d3be5abcfe2759cc33f1a13d90970541fae40e5aa792d0f33eebe72a72ccac43974a1c251c6c6df6d483f76c4a03c9d3a359e27633588140f7fb398c94e5722366222357e54cb187ec9cc152d4b98b5e01e51c29807a72f4d5e56d2ad39102f20e8528e2cbfc7dac1e4917d67131f805ee8a1389af7748610551265f5a212e3c928b70edc91ffe1177a2e0c75cce82b406e4579406ae7eb064d7a441b2b9288f7115a4a409fca199a61f284081b48a2a3b0d76c59a992b7115633cd8456bcf574aba2f6b124f52ef9c536fc36b8e388f65980957dad6a13cb24cc47e0a5403f1a0d5ce1704db182d179a3b0e6b94aa12c1c8947ddba3719a36c16a268430f19dda6f77dce7396ef902f650af51b20a7be17505633b50d881cd66be0e7ae6e4d46a2b8121dcce8c304f6998830535e17759ca59746ae6c7fa34826131a8267d6a0498d447316b87a5d9aedd767ee21ec422039e8450620a5e6e049cecf4ac167f5ffcd253c33344d917536b410b7520a11173dc9b6aad6f16a4831550049b6d0be91cf356b78496ba2c71c2687fed851048104ebc6ce06a35923629fb56f0a5a17a8327070850af448377fe5dc2f2b2c686c5fd796d5e9c0a29fc0eace7b5163a9d3e1ed1930408c5f4ed408c766cc5a6350d83b6583ae96822a985fe7aad212a10e2cb79d0b1326a940752ecf9e29ea4e9fbc6f8103c7328a0c4f493e1c1744345f067cefcc7924ed81daa338b1d35732ba0a237087712d6122d89e95032fd432bd0846","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
