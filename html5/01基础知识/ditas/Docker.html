<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9ffea364aa889c2564606d506b89b12c66be3661392f3196db2b2bd873cd44f6935bbf4cf671ed4a479cffad161b93ff4fd81702b31e2ea23199d9b3dcd50e785179550330bdbfc2aa7e2da02161acdcd34688ab81c63f1466f765dfba64942beab428d28c6309779a897b498102f1d6b2cd18e09b4e3854c7437d434e2bcbd64bf8fd77e3a770e2348f6748eb710ecc0b8cda984a97564379f33ae0b0710264fc2916a7907d932ebc2c9f049b921421231189f4583a3ec6c682e5687983d17eac2ec817ae0bad4af371259dcdc10c9f346a5fbf5d03d90075f25ba9aeece73af2c88f257e58ec6aa236d024efa9a322a5271958dcc9fbfa62ef074bec2ce240e7c74dabca4ad46d991ee19a29764ae5e82db247a83ccd43bc2c8328bc2248d3846a387b47a8ee174d7bda680be85f365b6d20a92fc579432aa3f00e80bc198a9a01b70c2f4e6da6f52badd8731fd61f238477509cd49884d2ec7090b11cddf78ca7957a7299937047bc896ede1f38b606d830dad859e0ce4ca059858814d2751657a1f52ae3767e9128f8b35d9284763cbc20d32af527b73d7d9a65374a0ec3999c6994b7ebbcbecfebc7fe325e1302af177856a4ae236bb09fc534c586424b6a3dcb4cb868a6e8f995de1b71dc8ffc47a0e142db4c2aa02914af35263031314d4119fa8f75794865cfee1f78e23f2e8f8fb7912ed4f13f8cf51ff8210bf8de0f2d86dc5839bd8c2c98710de41c7ab391570d2a8e72eff916d9daaf952b098b4b40138572e7ea5bec766658ffc5a07016c9e9e97cdc6bad541c153945c75dd18a495692a96d1ddb73aa91cd1634555521dade0ba59fb42396e326199e4c5ce97b43cc979b77354610e9bce92f30098de66b7e57967fb185fea897dfca986e5006d20e04167914a283fad275c565cc127935c83dfb281c393eedee3fdbce807653fddcba2584d067715350163083144613d9b79347d00738bcd4e25ee828715e7de6a6db78129e80cb9f85e9934cd5522b3b02384a5a9d4e7a6394e5d2117fc7868c2d126ddde931cc436411990bc73002aeacf8f7fb0049f1ef45f1b8ef8ce617fda015d937b6afa82c8874f9add97a4bf0d0014f4be348ff794d5bf7f4288ed45f8a85734a83397ffe970b784825d2fdd8872e6379ccaa3307e5ca56d06288c84f3d26e993d910bae4c10085f231cb8ab8eb431fb036a9f82bef0b5aa1b8a5672d4e77f718280f9c33ebdcb4ba88847fb14f6199531cd166187486bd1bde20bc2bb2145018b353b157b8d528e3dd228efdc916ec54fe07bfd2577323d6eaff0d1dc9bc60034a2f8705c4eb36acae4bca8c36360ab0a7eba91d8949584bbdeb4c6c2bf3a44d0edb1cda5599f5fa4df4a62ab271934b782478a1a29eb7f670ee611f12568a1e4a18ef2148aa1e3a3470b3e2f0759cf3353dc9c154e764a2e4f3aa4e860567ef0f3a315932bc04e1efc16761a32576d4c6ea088dd340c36f609bbb3e231e7b30e99d907989fb3f263ca6ffc83d0893cfced958a97196c1a6f7f7769caeab1b2a26e9423bc8a6f58db7aa2652739cbf920354b54a9b577f8aeb39d9c090b7893999af15b2d96d6221c72d481b7a7f363b3c1cd26c013abe59da91d009fee88906f3144328ab37a784ad9b7c8072a8b86b2035b7d8a71dd3f3949157cb5f5d9c686c79deda2018a172da8d6808a21738e4f5157d1b9bbb02eac78bb114592cfb6399b5221a4067896f6e68c7d61be1ac127c87d7cc01d9ecc93a9fbc02b295892549abfd7d72b01946939b44a2f133f869ae6d6eace150e9fc8c0ab1a9efe8d4c010662193a21b5af95fe21e993b83713a9c8c9046bd00a3b89ff029d6517cadb11e6a8227f1eae68d651cad14a6d430c2e0e184b15940f6bb38a4c5b54d2db16587263c19a01ed43a8629466cbe02e3a47c329944883fb2176ac4cdfac36c98b86306a1dc20ae420d336043510f2ff1c2f8676f12560ec5bbc07d1742c1563009c91d4dc3aeb8c6dbaf7e87753d11c2d66aa4062716894dbc5abbe634f8b296026ae66cbc0ef5ec1c58c73f6a473a7630fb5803612a2bec3e93dd6d377b9f7f2cc65d15271bb00db32b38280a60133522da154c254cb4817cd2e2ae0a783c70b2295f899f20d24bc598195c7f85544d3bf551c1e5303c63da34ec120ac634eb4f0d9d608009c5db3c064100206cc162f4344d60f96a0dccbba2db1d063c01694d44855fcfac63b9b8bcb5a875ea33be58a1f70ec0456e8492d5f4769122f2e2beba52ab6f0161e2d5d48e07235dc66da6445763d8008c9c1b0ef6404b9ded64edfec5b6be4dbe3fbb77fa271bafb9747b73c291f77984ba8f7a42a5842534e1855361977c9de43ac9f705319b12170f0df40280cbf244c8079e7ff00756b3e9480b26e1c018c9b47e51edf8dd685dee0c4043a3ac7dce20d9c94356702deb943c6c25fc7ba686062f20ad59cd1b4f2b2d84c2c2999edd588c94af27cadefca013a5313a1064f195db2d5b64271d32ef55b3584e3ccefc0e7315a1c083389fcb42dbf980ff042037cd8bc1ee2e3bef771f3036b9e2b2d16abd680f503d86f4d7d6bf09d4eedd5c350c6265861a84d591d962741b599b8ef229404e12a383bb50c0be7bef6f0d9f4c80cad6ff05062b719f706051d4863798f5da650fc0216d4a988fa47a84234b26e244e7a34d7239feb6930a627e9ad53e5be4e31ea2da05f5bdcde5c0c696f6556c34f818e4034eb9ebcb00440af3c0e0ffd0d37153d2dbb9407575fa6c6a2a9be742255e3310b35a0b6a6e6daa0f309a1d7aee219f22c9dae34fc6b4fef64f1e68713722ce51d2a397f60fd1bd276da51ae9d6db3c02ae4b678cedba768618e6d842ee3edbec7002aae8fefcb8d75b013a9530bfa507f142caac3f751468b87134f1cf8b577a46139c534d6f1c38ec8cd1b2d59a0a727e1ab6aff975fc109260973c25bb9a9fec82a08572b1a0c75667d2d5216d39f5826eb2bb490b175a185b85e132e8402ea762862ffed3a18fee589512083c8ea1b0575db30d43d5596bca5d68bb9f2d9a787558a14eb425c926bbd84b203b08e060e56715ad24395c9d01cd6f9ac00b5b2509567a2ebb98e45fb782a21c17244818d9ba48dbe3d80dd2334d4bec36e743cc75511b44f05e2941be9c784c983a1636284cdd18236e56ae0447deb88c3abaa760fc9ffaac90a3f91c07e445518edb0209d1d489a5b6e5592bbc2ecd8098d8f79370557869d898183ab5756367eba5b32e52efdc8df5917e6afa55ba7d08f1af072c3828f6f5dc3c373f4983a58024cc1a0feed06a05e06d2a52ad35feb2791cb39ee1e5bb1e2844263e52e3667596ad4ea559d544b9aeffad9f5ecc9316e9a9991e249fbd8abe587c91e855cbf77d264bd4fa3d7fe0da87f6210e3fb77d49c5d32beccd8c9e9ba44fbf7a6d0c002c2ed66067dc80938cbae1fd567a5190308d080c7dd7d44e8d48b47790d9faa215cac96f5fda3f1011748710dffd5812909a0c84337e87aabfd363c84f57f112ffa1af2b83ae8865f1c75d36e801bcabb4a024f659bd9cad4cf635cdebb2fe6b3549aa7e304a98639f3ba6a65061563ef07fb6e1bf202e4469fdee9fbafba8c48f9b63ef1f59b7e33d79c4325309a60a069157b7dc26a7d3fec2216ab51fc36793fa84b44d2b4e035867593075f07c8b12f5cb8eb227040066d8e09e0fbeb25acfa54208cc3aefec02ea86b57409ff2fae7085191e7977d42c5fe75cfb91ad788d554d897cfa39ec838c6f2fab3191c3fa88cb1770ec3d8bbd17c71b62eab1d64fee8a270e8bb256c112e26f858c9de183a942748a25105b7535b641b306e3120036ff56cc0f84dd1fe2fdec7599d9ddbe2941d183b743ce06cc311acec0713918d526e7524788f7239b7c41d184e82635e46a47c06e765254339d485b5168754f44e448d1fff870604f74ca25368ba49e83c784ae10ee0e033c62761ce91163c6bd73d3e47bf66d3f6e49e0f02868ed7b974f52bac7c3d96b2c5545375607b4fdcf5394a8516f5ed7096cd53ad77015708dc37b58e03448bbfee5fe2697876bb9b6109419465bbea3e473cf81c8a0482b8a6a5d59f65bb3549db248b8b657f8d11aaa38f61489148bd6fe4d890e2145d89a7deecf5169d1965f4cfabfcd63aeade3a4cb1f4a3f0c2cd55f55f246b0bf6ca2f2126bc1269c9fecd4cd4e4ac2daf8ca038d6cf0049a08bbfe4b15cff0b1c2d8efe3edca78c47d9a79b89fc8f7f7216d839d42d855b4b39c9c9ccc199c7c4ebd2d9adf716f0e6d8ce26f20cbca21afc8c5ea0c7a43c00c4286808ea7056c95b26b8cc0135a77f2ea15bfed8681fb534cd5f6dd4a7848d09a1fea65b83f6b3f1d874bc657195bb98c0ea3c8c5aaa02673c2e49cb6f7bee94806f09aaddbbcf4f65aa2efde5f89df0d91e81544a9c11ca108badb383f3a3e84924a2045567f539c427bb036dbe5e4f3f4d4a73fd979363c2737a5abee87739253311d601349a7ea6d26d749919d79d3ec37ed45991ee9518126811c8bc4315bad2574fa618a04302b7edd59c72232a936c19e5af9ee00c172d33d0e5e1f93294f2412c6c51f6a51353c23e855a105961f59904956a54f565e915417b335b01c5f3a00e890a4f760bf2497fed20f25efd053d0fe23c799630725c279e58d2cbf546eb115c209fa19288d8b2b028755420190d164ab4b4b5a306dacded12db57c1ba8f0f84733ecaddab5b09f758c70ef4d76fa62fc780eeef03a0b2431393a5daac5077e7dc657b663c6f7cf0f7efe52536c2af48e5dd7aee599bd00a851f6c9bb9311e8816cfc536af4a8a8ec457202650e2400d2a275bdc8b938d6f18ea2cb416655795348ab47d7837e38c48f38e1e9cb84e6fad33ef3c875131cecaf7f6af9e5c739a48c2b5de8a70395b9242db233ad00427bd781b537ea49aa9bda43bd4eaf4fe69429a7cc81e2dbd1afef83e7d47a7d3fc18e43563462469112717b83ec5dc79c58e8b6b058cbe53d34b20e2dbf6c8476fdc49bb46f0275f83817733750d1d3c1269ee494a753c099f567c859243a96c89942290a461714efe3a1bf05a27c021ee942bf42897d910f853a80d50aac4ae116962a7c7baa7f21bc3d75d31070a609ba495dffbd50ba8a511eeb306fbe25f03e66edfbdf44585af46ad678319c494d897a3e2e6c2415598233941a3c4f3a2d3e48d2288cdb19755db9c128164379ebbfccaf48ca80d42090e4be9fdba6caa0d39e33cd28d1ff5e49eec39eaa3c2c51fefe50ee7474048c2c66f86699e48c7cd11626a57ce8847606670f65199e45c72a611f1f8f92df98ddcc5fb95730bbd6060a0a0ce998373ec1aba5d3417c943ae0f61b55cad4ab5a66e50205f9d32ab6b9d93372755e6e0703ff92b7c6bd16b8e73de7c22e3223651ff434bdb42d82169ffc45d6cba587ca9b78b0f05dcc369e68a740250be45ca351af95d2a2558d3a3d777f4925b40857125b77cc96d36f987d31e6385a81cb07c3d2f3c81c4e023169493d63bc762d4b5b35de0045e357585ae12d80acd4769c23db467a9f92423cda66a2a8e20b1c77c3ca8c4890fd5a80e8e3a89ef533c8da13362dee5119a16cffdd5d2fa328a3a23738eb009495a77c418575642c2040ba7ea3bd4d835c4db8395cd91436c63c144c2aa567af94c329752287bf833b1bf05c519b4f2d989ca84a0080e5bee7a3ce6c7bc52d6c1819367c4680846675a43498335d12c6739aa3ccde600bf6a7442170a0f417f175fb468a56faa2baf173dfcece65009fb4256b560382ca542ea56aae8a78be643514bc20c1ee78ee2a1d34f52e8f1ab4bb6237e245870b5460b09524d7e7b40487a6b6bc1e7e6e4c27bb9f12056d37f078f310694c7dcdae88468f08c4d6fe24845b22f8124aa3965a869b7a0ce154dfe305e97e9d274b52f0167a27c27c2f14695b7e5799a248f676086784bfe19bd6fa31a4053ad648ca2832a262ea5c55e41b3d2f74aa14c3aa9bf6a32caf7997cffd98b72b2c4dd0e8155a7a4cb5c3c5169a0f544e3f2c12a317690bf87e378641ae63a8b871ff72e7086b6885c65876d3f227ae1f453c4bd42ba65be85ead4b80f5520bdb0fbed41eab29342052866c20d864a9fd83a073475d16c67957e9fe1c5b908f6c1ea16bdeecafb7eb67c83e227cff8d7f8ff235c3c99d6e7d5db5bd3e326a6a905155d2c69af594ba138b8823bab778bbe70652377d2f5cc7004d18ca608d082108ed6c56c89e7a5c9e985dc8ddec47f05dcfe12cdd0b8f96050e26b0c9cefd8522510aa49c40831afdb5a9dbea46a7f35baded8011073c5982f46d1668bb62384a8c8245eb0ca3f18d66c809a4780dc3da16763f450c0d875c16f9172f35d7f70fac45cb0282bc9c51593d468311de042ecf1f3f32be8b3cd60cf2edbf5c8ff9d57c41f04723e2443eaf515a4abec7137f13f7f1cc773249cd95e81a5050bbbdface41d7590930956f85468ed5a2f867986ce1e7cf863ba2b2fedd5a92b8a2e113abd7c690a89a86ac6a11ad1f692aefe72035e9b2d086e5943280a6297c8f2c26d7ed9899ab2a09808397220d90c7cd6e7622cd50522b1b2c518cbd4764c4561341bb4cdd4a0c907eb72ff50199becef1d8629c281b8398bcf57fdf4ad7314fa7cc0ed7072878a0de809a6c515fdc40a4ffb9b93129e23794dda53f5e8d96a91f0cd06c81d7d119e3d60c9706ac5ecfd97a98462b5665d0b2a6d2c9b9d219afccad0928b5bcbc45f34f750fe1e983d10f8f464b74d6b7fffd40740f75d660e0c2702fc51e5e3fcda763827d0ea2b4b6d8e4da355a4f614eda8133d6440777eb8fd9245b14f34e11502a16977fd49d1ccbb09f54243695b9ac2a735948f0e219d420c194f102e8e6d62d54b7a03dcf6f93766c823e4fc79b64078e6165a56fe5fe1269eb260461be21939284e8a4642e624288c9293ecec2c94e04e7af143aa1e1d74ad950f3dedf55f753ce624c9daa670546c05350edfedb51a3c7adc3f47df9552f5b8e7dee3c5ccf4a29549408f413dda53c8d9ac28f33c8480c5a031b44e0937821f7b12ff0cf9c3a593da4bb9af98b32eb8ed451bb7e9a832167a26258289247c3f3d75bc4247606997781bab61e728bcf0abce6e6ca5301604f558ba438b7ee37f57c8f5ee261e20e3fede29a3efc894077488298c2a38e66e53f1d373a687ea6cd3f120602b50be2c49e60cbc8742a8a02b96973be68ddaf9c869f269792375b6649f3cef32d6e0f4368c19e4d8c3e2d7331fa0d156fb17daa1de5ad6aad0351b2e529f85c83aeb7f5a5465056cfc7e71d958a932a85aaa5a74bc04cae270dd793caf375d6646f58fa3c3c3734e240cb058245d3ed630b55693407f0f7ec02db235dad013bf1595bc84585217b66fc6d948659c12c0208e75c4e9dc083f57e7d44fb8f011984b6653941a61ab0c74a57bc8ee69bc3d1c230dad51cbfe54408ec8111b18c9855707a5b8c7b7167f840adf60f3a679cdc7da7e08088cdebbd81d2da7de69c7f10fc4c859f5bf410f406853fdc4891782266d031355513a4eaa6daf60fbf7eb47764d013b7b2fcf4191efb190ca553ea2834542ae39448518955d3c230954e1998934487953b47d24b706c06a870ffb19d50e1bf15a11ece61ad93f992671f8872c5ec8b90163fb5a11053198adcddb44f6d7baeb298105cb0d2153c0918eb676b4acc136ff086eb8aed1c91e51d706c1ebae201a7802b44ef15da4498f296ff0d115925d17c45badb2db07804e9f8c5ae49f4b3120e2c0c12c4573d57c4f938b640d6220bd11b9fc9da0d20aee6aa1b23ab578b68b9eb5eb67d56c1986eb78993df6847a465fef48efdb046bc3641d91fb9b1cca01a47faef361b1e325127109adb34d5c95ed1a195522b6ca0cd0b1b876b9d9868e17d3f62bb88535cb741179a1faca6b5c2a6f60da0119b854679151b71a99be37cb70e24475290adbb6f65ab93775902e32f765d13b0ee7951e78b0bf49997bbdb6133f87437914234336a70acacdf7990eb983ba4c480e394b85d41f36a977c2539cf4ef29125bfe2bfd1241d03beb8e340773f6425e45cc17cbbacf7e1a6eba73d4b8e8f25b0c95bde76decd8a000053864afb9036650c5e6e04e91502c739ee5cb920668391b41f3aa98127748616f6ed88c6bd8ba2bccad274eb0bc1bdc86f9a73bfd7b3c1ed5fcef8a24bc76c03c5032c7087f56fbd4d94ea767d31db31c1f265ffe2c9d43f8ee2d5b9d925a20bf1eea0da06181e271e12a8d75c0175343c7b9d738e7a2ddb6eb683c18cab92e23434fbd8af882b11f0db00e5fdffe1573becc872fce06a47a9430c7c09810a21680dcf2c3a796f0da6a7d9870d3c0ccefb20ed1f6247bf05613199aef986d2ff8ce1596e97ff6b7d521e08738a6826f453d2d6b0309664502b56bef466affa3f135de11104c883253ef62d3da77712f9854697c5e5d864c8101cae40737697dbfa16a47ac6b02b3aed77083af0e0b056eb3883f6e9b0ace6f8714d072cc721bfd4f658f9804e0699be9da19eec01b9f60f4ab5359a32a4eb51540e4c601758acb92c929db49fb3984de742e4ae54b8405e6087c0a5f682f02103aa9a9ba83aa7feff51de3041b4ddf74d1f81c5acd1388ea1e61457ccf728d8743f42ec88e0eab7cb1c076b514b156c2e5ba08d3857301749bed51ea71b12cce140b58c7c472a639b159533183cf480bb182a9b23107b00db98be466290ceb3766a41d240bd0aaa0534d62b10b67d93db61533850877a11275564a1ac5ae4d665d23cd80116da61d2eb1d71a3b307a198df8673effa572083a859bbc2aa17dc2635f717ef94df4f93c75d32f8883c82a60107c6af654f23fce7153dee9ce02c312727e2b789a7427b95a2f5faa76e5f49cd1ef8d96aade1f6d3e3d406df060a56e5271920d66ef6af7639333c4a8c600d6f948c817c1faf7cb74f03bbdb2a0483fd4c4a3a52004dde2a7a86980c7a90c6ba79d34217aa42f358a8febfb8830ec1e169e2eda54d2ee65e9bd528941a66906b00a6fa5c9c5b9a44347c7e605f3621e1138a0b227c5ba135f42f912129cdaccca2e88fa5d1536da14595d3d9ee6f13fa6c760c370e988f905d4e89a9bfdc2be62abaa9014296bb7cbb7f689460759c82d3ec6550ff7a980683dbc10baf3ebc0ad236bd93d0523e3e1bf190d33580ac20b58177ea48f336bbb70e370d64807c0ea9c73e2ff99b6cc07868b1655f2acac26a8443480c53fc1921e92cdf0ab8061ef52b0c3cfb790339fbf74c1f472b96b04e576820c8fc428687de5003f03b1e8f8fceb47ef4727cc0cf3f845311a25aa866afab5f6889be6c74489f04ee5ada66ca8e0a0bfa3fca7a033fb0c95b07896db91ee3d2d98c63065702bc5b2317c1ea00136f773749a763c5cc7e697566199b2ef1a60882f15c66bc9faf2940b468f4cb0884709f7ea00bb7452c286ae9a9399ecd95cc03a91e5deee22e7792b58d6d9731022f75bace044e26ed849f65b993dc9415db6e71abb8f7234e6cf6fe5bdd65390a88f0e2529b07eecfed16af1b2673aa328aa036006ff10ddce801bd51af52dffb870c04bcde5f667111591850ebd96891150feaaf0a329aa1b8595894ef5482a173202d4c9e4ee245f714fa67ac1da478a07dbb8bf5ad825e43229d1369843b786816cb5776695ebf7121d3bab787790d30ac8424239967c51022192e1775ef8f7168254a37d67d3c62a7bb390258732a2431558c8ebc2ccc2e4dc9ea9e1e58ff9b882513aa0965169c9fc50b831c371101c454228a71a30309a9db3c8fd788e90dc74673faef83b78018e77140012a029c3110cef2bad28c93e9918cd0061d8c972fc2685f71da50623fecef0529b8f1993126b9f50226668ebebb1e37100e1f506899032d0b38ffa675f762d1f8bdd8b98af95449f8e0b62603c3ae4dc3af45608dcad7de9e2aac4039e1db0d4d6d0ac918ab99425110626900c69794df7ab18323b12ed06070eed7ef4882621aeefff9010354a7a40de69ba6d89c4e5bb111d07fb1f13ce372e5a91c6e450d4bae2f6f11eaf797f941ad77495db9c0f81ba15a071a105a95e01ddf1f5df5328ed11064813819327706fdbfe6b12a7251c9d91ca4ba4f9df504c95d445a4e63ce96c9b116b3cf790c257d7b3afa1197d912a39f0923d9c31530c9c151f3987db5ac6fcd83fe4d09a1ab30e44c546137bded60381c34aa0a1af84a433c0fb8f9f9993ec4a63fb85564622a1e799c27470556f2a07fd704e901adb05c4bbd27b35c18e98cbbb853282ae24ec1f09e0c17ad4a79381b7ce2cbc12dae45624dd3c66f4e7af8401e9b8863c9d2efc694be21dd6d8c1cb253dd1439536a2e2c50eba864366bbd02c0061bdb488ebd60efa72bd2a6eedbe04f655e55064bcf11b605e2f3abdc3b11b36a50d01d9384391bb3c34900c915985e03685b4029d1a4f572bf73bb616be76df3c6575cb5717425504f428c169f5096ac59857e0083e2c5d51db0901e614310bbdd7cd47c509440d96b93d3e65252d0c70296af11b5d3e8ae022c1eba3b0ac9d1094a8f7b8c9872381a219aab0d9442dccef92f15dd1d2e505cc6c06aa05c86ceb93c7cd590d8a513378267650ba24c769498588e2e8ef2f9ab60eddfc599868a25b84aea58313eab2d21449651f268a3165cb6ca4587c3ebf1c691f226714b5ad8b3a86a5451514a5ff9bcdddb95e7023ef9872d8e823d99760b2214933e2b954b085b54b14ae0ef2ad540a95bc05e4e4b949377e1d9a1a45acd2dd41040699ac07a433f3214a10b15ecf0ee2cb2048c55ef35346bd4e48a19038d53727c205927391cada0a5df99ab810a535c862fb861dc7474b1fb622ea9789349cb7aef5d5afade9cd67eb2379014b388cbcc4255bb6f1f9c810d21620655ad48e8dd129085e4053c78074a9cf798b80844708273149edb0bcb45c7f591b2d01fdd75d1f3df80c48d66ad2a1854dd296530933894486c6b84583872527ca511853ce50c586e768b08e8214ce1eb38ef273e42190a351925418df7f6525908e5e0210ec7b4b002fc9eb451cffb9436acf050c939b3b9fe07e8b932adce3d0129cc0305f0ae52e236b2d1b729a649e5b5a2630169ce1bd58a335bd62786ff07034fd53ede352141481535831d1327c05a0d1c4d5e3dfa62d452d146044fdf3bc4ea4c0172fd7bc54ad6760d9372030b46fd95552bd788085fa2a407a96cd1272083bc6718798443779f9b6e2421f9dde4d0df9cbf22f2d1926aaf23c37305c606cddae6175c481893797abab4d4812ecfb68a1a3bd70ac5f85034686425b835aafd70a7a10fd8bcf61e3402b14fdcadb6f5f4bdca81534e6329d0605395bc3f1bfc319f38257b8a1aa5a18d94fc628fc711c5656844ea78e23f432dfef1f57772e1ad0e8366c72e0c3dfb1ffc2f9ee079d57d58ba86a327f8f6aa2b834ba20f4f975066e2eca2f148c5c15ca2047c309eca059bce66bbddd9f56999319a9baee39470f05b597867465189ad77c6fcd8c9aba27a98c37071a07f43eeb963724f442a87c81edaebf18c16e126503a13127de6acc5f4d5bf182d67189322363d7e66c4a4a20018414902e71a0431313497863f522252cc817cb344bbd0088df80731bd8014a261097254c91ddcd6f38dcded6591dd2a776cbf4330923c3090d98e66c7da0b909bfad15ae93ab98b6f3c48586f11554c5d6c4e6de53fefb45091764c66c8479992123fb12508a1cf193762921641131d5f5d4dea6ed9ce7094880a70a03d2954f5fef5154fd7f344e4d5a888460963a3a9c9ea73c1d9b85b5ff3a1841d528a1ecc93d77be921e82d488a8d586d8832d84bc10b194e72af12b60074ab2e39c591090217e657c2c98e5746401dfb649d272821ed62efbe53ac9b69ee83efcf1005973c131f6806d4e8dc1f263e72c134497ad8103f7b88b38387a668910a2b8bc03f3ca30d3adf28ea12e11a450c054c7ce126e3a9ed1388d03e9bff116c5737f7112c79ea504beed9afba0b0ffe29a8f71e5965bcdc194cbd931cf768fd26b2f7d7122fc2889d61807c9ee91a4ac92fd86ab427dc6884021cf65cec817f4377137b16c872f8c9dc24ec00a8ef81974cdd5a67596558e0ae3cf2915eb429d514cffebdb000ed003bfb3ec53c733bc75a273972b3f73c8bc4e1e9af69b43b4db7a91715939245af631eb2af11e4b6c1f987cfcc87c0cd4a0997ba573e54472c4caeb65e6a48e56a7659da985eeff08fa418310ed24cd0eb9b74b87078f7a64d79e149b227a4fc98d26b4601cb8cc48546dba245290363413c3749d6f41c34b87c32271ad297176e4948101885852754ad301b1ff7c918cc1934c1ec5349cd4c1d79fca154a1ba25952b54f4a52e9f47747285cde908dfea142a67ec1911e9413f71608cb763af09ff6cb9d4ea707030bef5e76559da6f6202e172d0dfe8b8bd5eb83092338a690138336fc3b262daeeade8e862f93cf6a28501a0159918bb5ba126ca630c0380a4f674712a5c4069816c2763d16ec4187970c170fdcc6c326a1ca085aab52200ab2497c8b760e2b7f7e84970331c3cce5cbb16ab2807950bd365c047c36fdbb57cf99198c2637c127a2792e219fdd27f36a297e14b154c4fc129c296703ae2876efe26610ecb22fc469bd35b158f18ae4117b56b9c9264c31fc4367c4ed18fadfa42346136f5ad3f78af23324ae56b10e8e704b43e238663f1128f23682cc2e54b044812f73f693d369758899a3c7d565cf089b3f5ed9fce265191a412bc409d5bb49b178e174b939c5dc9d58ca40391a04ae2cd41e4f20451b573653e275781dc20096b9905155e6fb06c524953ea6dbe9dca6e2d49162ad25b69c9b14b14af03f63f4b3e458a961023df1fc181199a660729e154d931cdb0816a1bffaa12a3937e98c55ef0119399f499df1b18fe448c4760c06e6073a3a2191f64aeee0392a70545d91b350c69b5c9427f8bf7872cfc46448eacd10ae0fa99ae6b0e9e07a6c63174221bf03602a0e82fb6cff9efca9e6918bcb8944d02ce9d7791ce0cba4d536445cfc45506a09d5c3780b7545bee5722c1d1f98570693639c1275bd2198685e5c61ac97cde035955c943575b7ab713ee5bca464f867e2286eec6d5841f63d67334c451b62f52cb571a1d930749a53b324b237e9f840542466bd456bfcc95b0880ed4f05582684f365dd6fbcf94b2fed112c1994cf6a51595f8edced8d2af410f330a26121840db47ba8c7f4608c802c72019f3d186e97f2ca35f7849e8780b3fbc975dca71b96e9291ad33340e56b4de7a22a3af636d80e1a22bc758a3dbd9114a0289b6d995aa0d1d12744af6a648f6baafa422312867f407f103466864170792dc94c29690666b1e1e329ca20cb665ffd5340841b893babf9af12f7ccddceddadaee081aa17e8431b469d86692045d671e2298e74d2e79eb95b17284fa852bd3ae548874db9a75b00c82c3570eb4c7996b2f019619e2befc3b3f06e15a728af6ae3f59fdb107f8d41e7dac1e5b4d76ed4950875ef8795b24d3026be5abc71b6a99215cbf5dc881547e0f8cc46c6c0de87853b75c63bae68588a3d9a82a9d1704e503babc384cd3b0f07dc82e7292fb2cb1fc0f5d599f32c627242e952a99782bdca3c57010fd9521cb518edd6b3a1eca568eaa8c344b16984deffecc96dcade7822a3f9ba494b626d8eeb0dfb70170bf9e7a7bd1c75ed1e1ea94dd220df11fee8587e10d9dfd6d6ea22a0c8550addf72c8c89ae0b45c097afb6f662c1cda9df38d91c2cf8be578944a3dfcfd06e9fd7d995392973da83cd54dd3182a28ec68357fcc2d69c97cb10f03f7dee78795a1a0e31109f1d930880153af066086fd5eedc319bea6402e85d9546478eebc2f300e4452eb6a1f758edb9a7d9b29fd116a8f8e59846a47267d0533bcf1f7de0277fcc0eddfdbae8073d422477422a08cc7489604cda64c3d83ded7f55f23605ac04587e8991393f4214b65e417863c9f17c347752babaedbe30864b6df6eb64bece34e6abb81a9404979051a321abbd769ab3265e0df15ba14b24f75c1a2f09881cf73fabdd342d21a66eacf2401ab814e75752daae674cf855b52054ad58596d502af6279ee0c702431a7a2a6bd34d0779e419bf44545accdd18b34cb44b890431ac54df2324b42a15747f6ecf62a0069ab408fabc46094cfeef51c9ae4ac15422b58b24b1982610ae58716c2da1400116aacedecd07876db90dac7c5660908ba3a3f6a7f7b6bb12f67076796cbfffd3bdff1213e90438850cd314372e3c317cb9c6bed78dae047f03bf06278527f43043fd988a62dd14b0ee0fce7d61b56d79a01635e3e54e97eee6f55fcd1be58645f8dba66e328027780d838b1e6b34b7c8cf04234cbf0723fcc7b265c0d7bba29ec0119118a09ee3c4cd182295838671a5f1b0016160b0ed09023b46e23d07deb10045c62993c286ee83b35efe535beb8d383a7d78ca392c4ad08fdc862f42febe0d38ed4154c13007863b4b4f5267a8c44caa373d23d781fa925fa671ad4b2a05b47289b15e71eebaa2eb036716d38eb5b9b043209cfe20a50c02f4862e11cd84c7c45719cce21c455fae5d590ba3079a1e57c5b518c44227b749cb10c8f22787579f992f724b91044e59b440f4a8b173433f2e30c4edbb50ce65fa555131b7ec2adf0a05990c02dd2ce60b12e25d28b105921ee4e5f68e21aca074677a37487e1a9b6f99decec2dd5fbf9f42c12e32402e9dbe936de55e3cf3e92ba2f594918e93900fb3d64c94a84a0c04d228ac9740d00073a41b69c44e83a9d325efa9a25d76452cd6a281f73cfe227e66437b2bbe829be63cac3ee2a1ddefbfe9c2adcd78d536f5c24c0f5edf938cac66eafe48bd40f774ec7049d1474b7d173634d0c0ce9400f48b4a32c340bf508bc05a5a27615799fab508ef45f03d7ec9396513abf43d9bbc0f2e94a808cbbbf828f4869215f7e9cf9016191345539b8159fedbf92e8870334feedab60bd183c0edd06d34739a5c0e7d91cfdcdbc7cd5dacdd1e91896304b8c5738ab0fd6e453d12c440b0d47552f9f1d268667550c53df2ae49d6e221bec9c479505ea048573dc8dc38c807c8054358b506901b8a4e3bf09bde9100b955ef873e84fb9d2d0674eadc8ca6d31dca00ab3693dea471ae58ab4b05c4996bc26de06974ded2e2e7e560aeee0c4dd0553ae7ab2efaa73254b016be39e0bc45b4b2cd1612fa2fe0052024f22d97d059934b6984091d5952545c48deb7eff922f417a516c5da1ac2d408e4ef8b410270296d71f86ad2881fe2f3801c8e1a943049adc6b0bb33c572a7a592e23cb5386c8c44f3646ead2b38009b5bdcf0162cd7cf469d2ec9d8468db4886742183dee35ff91d90020be577f5ff44a7c1c9c36b3421bf715e9e9f4a3cd6fa4c3462f767b256d2cbe10284ae8c2d2af3571c45226cbb718a7ddc44f6262f596e03747b3182cac8d9820a7638f363cd8c201bc2412e070228e486b97195e1e4f3ee17612c3108d9cdb6d43ae572cb9b57dfeb1a00cd6555ee00a68bcd27255a32edcfa37275ff004a42b7fe1b931d40565a89e7e28ad5102596d5ddf0ff5bdd866415df1fd5fcdb137d17b44758ab5ba2cdfa1b9ba05eba975193165c3044b941c0d73c4fde2d0219c283a1cd438ad3b0d456f99e0f8eb06ef96355e4551c0e24d2faaf42353080d210d23de4ba5dd249ebc7ad7aa51a4f7e52febf4cec4d6ee954c4b05f6f4818c38743f7def7e9c7ee422f4778b3196fe530457bc9a48834bac424ef98f2397a5289ede6d51f2349aad63e3139ac5dd1d6edbd10b66ca65265cff4aab2cbcb651b79ed51bdd3bde36600a5ec1e22b932784c8f7a27d99deab1c89617ac4c38b298dd64629ea1f5a143a10d8b0a345b721291cde570bbdf32a31c5f24ed160156f5b35e4a083336299bb281dc27935ca3cedd1c67a3d076edd747389b7be106c658be310bb5397d37b887824dcde3a1688b66bede080aecf5b91936521c48be347b9e2d4d1b46ac458e2cc6d9341ffe5d20ff4e6eb33c7c030a5362f7388bca3bec6b2fb66c73ac1bd7e53e9af7e606bb45db10ab27621aa428d69f3c7af8f575f5684ada0cd0ccc4e7c527bebf2870fa263df34b3ab208fbe2e7f66bb62ec30052c17970fdb7c941b137133e6484abf8a16be5785c212185a9f0d3b6e63f99172a6185273da80a7bf46aa1199386f71bc08fe2ca71b7859014799b669c54e17bcbeddf3d42d239becb8abff548a97f5c994eea11a48919ec67d68b704327240afdc2ece0d0cce7c65ab2ff9dcebb166a0f1d7208e13abfa3bb4719f87d744231465a9ef63ca1551efce9304d4d4e65ee7ce2aa4a3a5abd63981c29a90062f9a99113cc38e5fe82223fe7300af7c512657287703fde8754f52d79a195a647366219b5a944898281e52a40520daa931117146fb6b2788b8be1956ded52c52cb09212c49b80f72c8db2c2d1135844f656691c7ab96fb268ae3fb0040a412251b241c907e60db2824a99916e70d9b056963596f21d777d905bcb6557b3b2d60815a2a9f4df7470e4ea278f518a76bdb9bbd2e40e60c0b598f3eacafe9e756a0e5f75a55fc5a9a7b50ad75c8659d52cbde4cf208adfba2fc19339f60e50ab14c3cf7da26d4dbba9abd27a6f696fd1f35fef2e96c124cfa2e31396cc9344903858d3317b99e85bbacf190c4eb8c6090b1bed873d8f0a9924f6538a777cb0c34cfeb526f3a41aa2de3992cf8e35ac61ab97e3698cff74ee09362baf0a34167a9d766fc442262786d2a30699378b7fca23be37c5d3b9c24732e348a04e2c05b4b7d83fde446356cb0a895d97990b17d8796263bfac56f348553f91446499cb4a28237c69b22b700a90d2c8220181b6914b3489596a36748380b14762eed98fb66569044048ae959439849da93a3201d8b71cfebaa3d9c68850bd3058e1a77b95296374a844d8c201800e72d6e30e5cc5e6887e867daaadbeeeb100e6a764895297b51f2d2f6a31ace1d3ff05c2ab47cf24c920ee311be3fb65cc47cc7f2ac86221f4bbd19ce192596536925a0d0739ffb3e7e08cefd40541d3705590a12a63cc000ace25d0d658891eb284c32999099b2acb1b0239c86437b0b57e28febd34f49c21d48a8296e4a677b10604720d6f9575bfe93f2f9721a1be0c7dc95ffad1e3fdd17cea73c7af68f525de4a503e71275097792992a19a6ce282c4783d9ff943dff5c99c1d14ffad095dde13a802f0271ba4937094845700750af750af0156970941cafa85adb036f061b42c85329ba1ab6a7897e4e6700559cfb55f55f620778305f8b65d3e05c4db9de2c1de936a73261dbb96121eaafe3fa4adae2791d891404c0251e07077673497b6813ff39d52c856bdd134dfd18f0b26a82696455747bf0f70821180924bd29bfede586894fc39f62e1faf7d97176411b7a8f2cfe1aa7809b3f1001e0b57d531231a34f02291a075d899f9d175e1e51ba25de11885bde93ae408d4c23d4324494dd082cd8ec92bafae4b98d9a61f334945bcd65575ed13b686b9d52fb5cf586b57c2e46fa3311c04f744b3662f6552269719d6339a7c09a6d3fbe6cb4e59dc1fa92d359efeb1e925375559abdf1262e074134f216e40f67830f3c6c420f9c13bf759098c9998e967028bfc7c93357858aeb634ed83ec86ff7a1acd36bf0b16426699c45aa78900f575df7c62ea6d1006ef318ff71f13b0d1e8400024a5c5c19e2c9878d4b69f05fa05fa0dcd8aa1750dec572f0645098b6b1a9468737d3c06fcbc80a4b3ceeb2ca9519dcdb839063b698079f00cb548fbc220e68de4374d6be8707820c5c5ea2460218b46a1df5d9948e4002e63e4c6875b249ea26a14d21fe212e496fe36ece06d28943bce0843567f6a4b8d9673b618a9e83c67b1e732c1fdceb0bc3bda80ddcfe5c17141f67e0ec3f76ab763bf2079b03c0e2c1068a6b153e743ffda699bfbd570441539253f7e3d71bcd7d81697a4bf5dbcb126432546c6b8d70e157124716d83acabce612816af414b02c084159a27dc067d94d1d2c8b396ff2a4650da754052b462d03c8f6d1eb742982249c90476cf239adf019df8e0d97adb9ed7da0f3db46e2c2ee8943e70cc48b0558f5c24e895d214bd75e03e46c642a2258516849fc16d5d6e766c06b91513b9aa0319f5f70c8aeafd9ef56cbae02b0108188d73c9706d206f2c3650fb5e9143619167430aca995b92e443ba92ee0820f18738c6a0cf294907cb76a5c54bf68bfad44752fdc03f3a91ee29195d8e0a2dc5e9065e2e754f9ad049b63f41a557c5266bdd254a68f611a563645fb874944cb2967ed51be4dc1c86f740cbd72d7451ee4e77824f5caa611d9bcae9246aab170f8d7fde15883fd87e745ebade1d6c89e1dd556f48c3191072699aa3eb65d228601bd7646aa4f17571c16e135ed88321be598512d805fc8c644b494023cca5a86437e3dab053b721666ad78c8bd9ac91600b4c122c94a5467efe11d65b2b5327a93235cc95862c48b668b1314482cc3c03868ab562757c1950698ba7096025af722b98cce27bb9b539b37c1ad73efc80a4cba0acc32f00c6914c8dc45c0fb703a71cfbfd357d176b065fae5401c9261f99c04d9946dd5ebbd5876a552994f9c362ebae0da633b6c20f2f5083b5b519fb329a7af86fdd9790a78e46a447e5d5524ebe22ab12ab00a8205e9a4adb4215fc2ba94e6ffd36a5a30670b6081a0ecc0a0292c83511f06e62f4f351ada243b7c594be431491bcfa149379239bc512eb88ce9444e56beb4416a335d1e07ae616813e873af8b40efbbd8f924cacc27e1c107b57cc78c42c1536211e9a01076bb77e501e9a20348790912f2a26eac87f42c3b9b62eaba4a980afd507b6fb22261e6a760d9d2d024719775e5abae6fb6592459e504dc8b6b241740178b4d276db40390b2ea2d6f3abcef2460334d3855797ae5c6f1da179c2b20804fabc09564c1ae768344f7642c55657373c73a41069b9a804cd855df57bb84d6e90cc366f06a3c84f5192405ca5a73707bbe8525ef42ee0db881bf6d3d63a7ddef595a7a80b0959ac2d63cff52a1c115c12b0551d8400023c5a73ff3af45bbb4e48cb6d75f239632a008c3d92f94df2494655f8b4bf204238715e0586cd0481070ded5ed347251b8f9465a31ba4b8abf000858ccf2dabd062d9f549519956134006e8ab62f9954f5032f916ef372b1dad9cf41895492e91e956504a10f5aaa28786f3fe71a50083b2bea3aab6eb9bc6273ea4b8c951c92345bf316ddfcd02efa56cf27e4fbce885d71ee7dc9f6ec67911d5c952965348826af51619d16c28746ce6829a161b3ac73d5b8f7ee01729ace71a379f197cdec45e344924705d92f5affe24977119fef634a1df71b58118e91b9c08efce3fb8eccaa665b284011a8659c5d8d6fa3cb5753d696d47688b2c5710de21ad38f7e01820761c327f3f7c79f90bfc484b590328b94eb5aee05bd3c3d4134753a1ee85ea6dc8f3b21cc75381b34a565b40e82b357176ec6ed23c1393e61cab4cb09f296649d4a1e2470cc68dfadc6bd5ef5552dd17c2546a977e82de9447f3a869618ba3d0587218302c08c3f75de8ac3404598932c1d96072352dfe381959c300973610728a417fdae97b582551c6275e3191420ef70382ad84d1d893b5392635ebaa97ced7b198d16c5407d24194c64d1edce518e658396c780a3b9c8cbbd32fbcb1e070c56a7601f0843c80120045af82992e3c1457b36456a82316db1e75758d17145208d9d28de8fa1533239951c3686b8c54a54cc8ba01386bd20df8b7e2e5e2919f623f43b80ce19a5eaff4dcdafdb76b943fb476bb5436086957da34160689b6cbec7b89e486e90304f8928303549b78d77ada4dca14530a5424eccae8fae33eceded2d08af65fe10b9aadcff2836f1423d970263e75080450acff5d18b2366a81edb4b6e9d43a716775c8a79805803950915026185dd8350b074128376df40c6a47ce906c447121478a12b7ec078a712d35e18647872ec75b505617ada0ce039fc3b2b8c2af55c2145b6fcdf646c16db82d8188cbaaf6263882bc8460c30732738bb39e26f624dfa951f9e7facbec7cbeb6e22a5b4d66d1c9515790d5554141636f5e7d651c26f3376713f1dff7fa86ef1c02485a37ca0dd694df4161c0434d492c02dd6c212a941fec732d6568138e2d12aa0be99d79e6aac5aa4040672ebbb84667c59ac01450a39d9e56d02999c77470da3016566659e063d7a2dd655ada07cf27c64ec7e4e13f87eee65754a63b923d33a663dfcd64b192e7fe727da8247826d8ee419724e3d9a8168d453e58e74a7f62d71c128e1344a8354164855df9a1c4344f6cf17e15e9785cbcc39bd65a7a177be762d81dac664d106bd4ad1fe605a53fd532a8a6866e33a99f2e632e55cce6f35e2ffb4c90ebcc6b76595db990a00ea5141010fc7326ca48b365925509de85ed4b009b5186d9818ea45b387ce6c9e70286ea00d333b5a48fb15e7d8dc29a72b031fd036ef535548870f924e31606992c2c3a7d2ca7ef59d9312da367c423d316295bed422ac73710f34fa87d32457ebdefabd7e10f667fb86fd504e271fac3529637fd0f6e03310e77b16db1f31691f011ad9143fe16a8d0101a4c5bb53df2aa28d5aba3a55491826330a8bf2b8703fa3bf5f2fb953b61e0c49922edb59be56e77052c1e7de0575202169974184ec4070b1a834d0d050b31d3a33ccf3bc2222e46b341e3423cd1e0746c46e159841b82146d8571f90b11b0b6d5937a16e1f0a921ff61dd581aa26accc770e24b9d43fd31fb61301f4736e320f4d917a038656d4df1d6631ef48f182f739ea5d48b9e6dbd437240f0c8785a31e763b9151120be191aa8d34060395a608790058a1198cbc04481d8b0e8ca9e716555e8b530c23b6505896609c6c8752dff68077e36dcafa8849eb8862416cb5509801073728a979fc9e2fd5736e947fbc4271d6f429ff2e113008bf55366302ad362b77f0efb0f2cbf9f890d35b54c07ddfee5b730f11cc372225fcee5480f82aed43a9c64480ddef552b750c41475f8715a962952642830648b3af1b259800c8935ddbdd4cf42f6e1fa66cdc073214e288ffececbcab68201812586202f499d6fe18d6f7cbd0c6c69c29fb8f5c0aa5b00843268714d988e0285cd581b1e308f08f9eb10019a53d66baf252e6665fc73dfad5b23fedb2e0f33085803230fdb006422b176f7409f61204c06ebcc0cd44a07922eda6bce9e8a1259caa48b54ec7d3d536de1f4a6c1f1be43471767ce0e22556407f8e8ca13193a24b356a7ed7949ef233bb3241c4970cf3616ef7f388e30459ef1316030830446e6c5350fbadf7d1547f64f6ff4f3deb9e65d838edc1c1c8b247064d83a5944f9fbf6ef0a728394374d2ea771d0c53a3b56ca2e32975f4bba29f7e8672d6ff3d85fb742b2e41f2b786fc8e91f496ea8da6a9c4f25c7d0b5077097edda65cfbf66e034aa4a253723d4eab2732f02c74021f61921a2a775a74201fa4bd06b2b6db779cbaf1272151eb339f1f42830a2ea4a5607ad62aa8da4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
