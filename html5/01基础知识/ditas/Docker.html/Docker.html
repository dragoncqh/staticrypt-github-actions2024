<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"662843b5af3cb67072d6aa0ce0968fecd6e6ea2fbb26eecd6436f1178289ea20893620bf11fd9d952b885c258febfbffea898bc7ff62c61f0eef4dcda3d94feb839eb0b073a879b240869c82ad2e966d1b3c56d825ffd378078325e639d44a6f1d28b4fc80f2d1ef194df766c49963115f84f775ed6f901ec935673f58fd5c7b1bfbd1eeef176d2c2cf1a2f921e1f8c001bbea015561305de6dc803ac93db2ffa67a8877df903d5697d3ae97e0d27157fa3ca5e1bf6a4a1767bed66657627cbb8172f941a94cc1725bbe700f53f9dbd708c0fb981d310b03afe48806f3a2171e159b85db802cc7796edfdd11c91b1b9e7518ce627acba02bb45b8a71e81ec2484a5fa7fa5e9fc692a6450fd186edf5227b53065bccd14c9ea4e0cafb033b48765eeef61399d2ed839c1156918ffe13f0a5d0b04d626094fdf41912b1af3e93e766f22bb3a06d80e5550fcdaa29e43107e9f10e4fc12abe772e96ce28b026ce7583d8493fd8707d6326201397b3f98ef241d1cbe19c2f78fa884e24bbfef289741fc5a5bb9e1155979f39e0cc12e0bd604187fd4bb5712024a194633c36672b38751f55f6a5357dd0ae040fce9aa7f79aff4832f67d948648de6b3185146429a9bb14922ffd4b86f48e7521675754d462df7fcc5ea505c05929519b8ec9fa15283b125e88a4c4a587e3b5980a610a5de11299b53a7ee615c2e387bc2a1dfc671881f8c956b7e7274f948434af692de75497435c9f69c63d40374893739a7824892cabb229dcc4a8fb8f920816a75246757151c1c9a8537bad08c98b76ff3e14c5e3aeddef771fc47ecc0587fdaac6b074d03f603d2ac3276952d4c0654a4f68acb42fa4a83eb008f28236a98aec95f2c9ca967a6b345c9f31e700958ea826f7ddf0006f256846c1005300e8251e0e7ea887c849fb71353dd4ba6f862201231ecbdca49b034bde05d389fe6439ccab43072da0cd9ef91443102d68d626ee9e26f2173ad5214de9426343c477fc182dae3c846580cbb4488300441ee250d2411ef75ab90d6ab1db1fb25fc5523081c42cf6b507d79b38ea02376011f5da9c9ca5ac4494b21a01996ba526a195330771ef8a1edf9152d287e2912ce139560b72187a70227a60982e54b1bcec969decf9ece4c4c2cfb6a641c9bd467ec3bffc25584cee4d766bddcd372b31b473ce9e6c77d51183322f0515ec36e79b25031a9875b70dd770b1c82f65480ddeebd1ffe695bfbed9e4ecdb4b3fa68461dc39426ddf8ecad7af49918217e0f1a61cbac86295173650d083d53137bfd70df2c7faf1346319fad48fd48baec426406789ec0524835072be7c56e6935dea532b783de06debfa9933f6942162152c8d27a8efda9707352387f20196c6765aa6457a59dd269761d18c8be462922410d878b72367e327b718b1647cd91e829084625880a0d1a3f968d13a77b1d6126f5d9825d5cbe36b0352d74a4ccbace0b9433a66f3cc6f8e8f6a59c388cfc9e3731ca8d4353f0f878134200b9734cbb949a398cbcbafca24682fe6fc417849e25000bf6ddb75af50e1af84e2e107e55eb1325963873b7d87a911e59c354d84dbd94f76cea512ad70879b37c4ec8eb8756954c6d7c9f898e1439b838a1a483c09949e1541740fc7d875541d3b861f661d4890b9b3ed8dbf4aa73b408ef5f96eecd171930b9fd06cd874ac0834f08409756202edc6b6c721d044020dee7b3fa943c69a23a0048671b904aec30217137a6887ac03ad758d580406c518c12cbd11e6edef51396e6858a2c4c2088fcd13eeeb1c1708ece41726eccf164fbcc7422049605a79fa3527485999bda39dc2e1c1df08a9c2714de7f2be5bf9f06b898f9d270fd49ae02059b74530a1fa9548f41467e48a9e684d4a557c601e33eccd095e955e4550a5908b0b47210b77ba037c169abf4c78ec84032ee8a199b41122b1bbada3d721b9098cc9073008b43866071a8a4c9834224d921a1356ec4786ed13d0044e74b05915361c719914ff29d8f987d77c005619fa42062bd739b67c95b01e58cf640cd1180489bb88f3403423e502d223455b15e93c41ef5a5c8c46440c3dbbee04a9b96d9c7812ea1db6173a6c1527d7fef91da001dd239237753b256817146bb5b54f4348463ca792d7417036312e0de49f12a89a71afbfff75eb2506b4cab51f0a7b2657baa3d5bbd272e3fbed863246b8f5fb7f15980e5770bc9ad8fd0e6406a86c26b39158ebb129f08619781912c3fb39dd1e1f8dea8fb5b3203b5649c9c16207583e6b3353e99fe415f7b5e6cbca7b73eb05f59053c0804ef14637f18cff15a434f13a09ed607ef936b80626f139b1486720b1e1d77a992dd005e720d0b7711d96563b4d2cf8c234674c3463797a316c72b68f49f4504b83e06af27b7ec2bda1026c9c16335447e101fb3bb4201c10e87478280c71388648ec17a187ad77cd0b3a2996556989cbd8047333280d48c5ffb01aab933259424c7b726313ca912699a927daf40792d58b0b7f1ecd57532bcab51037bc02350b06e51eabad1b613e75fa07b826e9f271f979e10b72f8338e7060ccce9e17c9fabe40398abface802b69d3df4f91ef4a9d2ef5f68ad55963ca89ee965664e16434c6dde2784b5833c65ae2a4d690f6a45b54e11fe40dec1f20610c1944019243acbe282b543a7a11d11ea4bdebf65062919396122f520fd1d9f095adc9b0294e1cf6a296b96ce0fdc61ab6178a509a66b7b17dfb7bec351c8ea6834673ee27321e372c0a22af50657fb3dfa7aeb760c44b1b2345888570cebd00b50f0ba36f112802ad9ed4bcf2dfc0e017f4db9b1445e97846f57dd63ca6062978559a6a8da3c21be6ac7e7b9dd64ab2fc4fdec2c836dbb9c9b887dbcdb90adfd0f8484ef93cfae7a0ac80b3c848cb9a98163d7193614cf05b11012f222a2ef3bf540ac7dc27eb59fd105ea21a71be03c81ecfa6f72705e5086feac42e36ffa9617d3532c07b74f548d4c9f9d78cf2c6cf1dc008410d9f607103954ba6669caf55501c29adc1cdf9769faaea68314134809b3d1991b79b0b8b6e0b50030976b11f63572e0dbe80e429169f876e6d86d452ca6d56de022c6d22b90f8dcf7b87c41f780b4338aab7ed62056240e154bd6eb339aa415fd7b95f64cc25f5a2e9d2e1d2a0ca211d9f584b3733297ea061542231f2147b8db8a2ae165eccbe4a562c8abf7c0199aae7b6fd5d20d5eeb93e8deb4aa1cf2142fad3b04cf0b26e10e76d2e29513fb665ab2101a487be29c904556f104bc3031cedeec0e5ea8aecf45e28c70fc4c3f245adefac2e0ee52028c0c87ea61cb476a29bb1b8e7db07ac15284d6bad7a4e119f92be45b65d77d7a60cd1c0e6323508485ad1e472b4b082349180c82244f6ad10f7c9c992675f173ecd51a9470ee9f50e57d7aa814a08e25e31f00ef735f149d93ff46d065c10bd07db9bc0ad1527792ee388f22c44db5ec7ed0168c074eab257764aa4aa1cadaa3d8e6afcc376e964b40ba68963549d04ccc47488e79db99a960c76e1fb66ab824939cf769b3753d6179802af560c0f410b0ff989cb4944ee4b6321faf351fe21b0d73a278dec829b074712f45022e978a8c22c1033caa3ffeff59bf276726be029866959aec1498ceb328060ea8e3985d47c86af9390e0f7e7ee02076285b9f5c052554a0a99a590506ed4c9011574398396853ea49273235e653d93d5dce48806e3dd4abcc144f7e301761c20ce96c2b31509aab8b3d976ee077d368a05bbd9bd2e465e6280a0f02865784f2b69991b569934728cf6547f66aef20c7fce8d3ce2ec4c3f366a6551ae93f4868ceb7e3db7660c70fb5365229dcc93fddccdddac69ec4d99fc6245dd678fdff11fcb5da5c0bb63cad77cd2b3f1dc3465477b347925dfefc51e4dd7fda6fce64e2b8e4e59602fe071a3d3de250cd56f1dc51fd5fb227cdf2e9fdc3ee3586ebec1258eb4a60e38d41deca3ec129f88a8c123ac60138cf39c2ff3791609d14b754853518c366b975f1bd668bf7cd8c0c619e9c698f9c7cd90c39ec2f2d3d9710e2869b6de4625319abb6dcd6aaa0a1a8f27ab8a682ce2cfa43354ca3d281268d74bd2c93636ca280c30a8885f36b25fe01909ef9fd66255587939cbd521a4cfb477827ec6af166ea96683de5ff4aee7057bac8c444a9242f46c9a3879bbd03872f7c51286f7eeea9013f088c64c872de9dead67f462adbf8146b5b2e87d7d045fbcee880f85655a3298e2341480e723948cdf9e0f3eea68428d5213d26f20dd4d46193e9211b04d5cfc232402f4439d0c61d91e92ca03328d6dd2960e8065b3bd6568e3e9da5f83f98981957c609af4854c5e442a945b6114310fd7c8ae88a023ace3831315904b0b3b0c3a7f5ff55600df7dbe1a676644402f3ba6848a7cdc85c97528c7ef6308367e6880093236ec2e914e7b293e408504cff476a7839946b92c2313e8000a66ea01225f51a4693fb01f6c48a90da15fd85bbe0cb90f382f5eff1d1629f92ab839c94bc732437f881dc50840a8c394fe47c5eabfceb964124b33a6d376e55b1c6245683c570b1e8e415945a6910218ffc055c656cebc246f68732ec0cc8dab5023571f2f1bf71852342e670cbf0802197fe0cc335306ff90e3cbd506ab2c97cb6ace044415c1762a4c6ab0067ff1f6f3b40c58d97d9611c603a311f45d55ce6fa265a427a7f22bcb9df0874208b95668aaadb8c4ffe753771e3e024a834a5f6f39ce39742a9e87eb4eaccac81df66814100a0441196216723059dbc1019edfe5b0c29ae7f87107f81e4590b7970a75e074497662cc7c99a0a692def709cdaf5362ea04f80969c3a89623e20883a576d2e03b6dd02921bc4c53c8e56f510411c2662274da51f6bc549e7354abdf785ece7149f85336331a5ea7fc77a64eed0068da2787774ad9d4bb9bf1eeb48da98ceebd19eeddd1a1a833fa266c66212342d9136d51ce7152eb507c52eab348c6628e07514a01fcb972488889dbcb7e74f380333c65c03163392527bf8e4867e750595a102b4d522c6fe6ba264c13ebbab7e4838583734c0c614ddc8132e7795cf426348822b83da10d532eb9832a16346ccffb07a54621abfd07e36a54679f7c255c9783e0547dedf5ea83667a3eeb097d5056d907b56ddf4341d2f31d1aa0af542f62a178e9838f5531888f4856626086639000b1d4f8107161375ae2bb1563cbdb439b4a2a6de72262c48309b92913e9e0d0ae2e5dd94e43baece68e25e186c58aa982d35ef2f455f33390de5dd34b3ba73785169125ccc1421d3f3d82380cb020fdcf552d98cb88ad00b68fcc8daa424b223d4bfa961232f578e3b674477d1e8948c44a0494a2270f1f8c8ca6db4389e5f5c49171a7544946246cf37d94e6961806f803a669194f74840fba627770af54f90ea872644324229909bf8052ca0295bc4813f1d7d1b9ce9553232a05ce0a510b53ea642efade1f37de582d33a0e749ce121c4044c6bf7b57c437b97f683b5414f1327c8cb88137cc1ac38998340992ee62bd6d2a0ff66c465e0395614e8916576f6e7f646df6cd8e5c6413dcd2cef7a076bbd99b713bf81e83d980b07536e8ef6ad48335c07805188b4ffcf3844302bb92105805b5a528706ae00daa845f122ea6d121ef24f7775fd845901822c2b81665b9ddc8bdaa12867d75319c6ad7fbb06cb9097fd671389de980cd2c811ead27c0f6a6b30b105caa8e149546d70e8169c0bbf1f39da1c2825330d2ca5313cff175fa525a6edf1f87264b83a58f462e2f2ab2369b6e77c6ab9963e8dab6fdf6d251a7bb0eebcd027f09b4e76d13a416dd72df0159748d39922722d6dfb76f70b19828b39e6c1016b08e2a2b127f89f97d071b2d6baf342b075c58f6457e0250cb2257df00b2d91662f0a87c63700feaf74c224e1183a3c7d22ddb494ec65bfb2f48fd31ac88e6093b0d692191d9b8dceb389882eebb0e9b7e4c2d404d212dc89c3ad9117be08f07ca1e882f131934eb18b04e8ad7d6c9535fe3623b830f93c7306e28063b0df153e5a2ab84c7c8dd2381e2c9188dbd24a8dbaef7619d9a0f95d1728b30a09ab225621622a6742f06017792c4f1055d3c5187d44a32ceae5fbe5da194b51eddcee98c5019f20c2fdf43d718ed309f65a32c11db76a25e6faa2dc1b7d4e47a1c18b0f11113a26972305707d464806f77288358e0fe04788c5c138e14de9e6ed19e40ac06dcbbace84febeff3484d637bf69318022d494cf016aee8b71345badf52ed1fb83a99b690f93ad7cb857cc25102d83cbfc68f3a8fabac0a49bd4711daa2f065d4cafaf7e4d68792d7ee1da9a7ff5c8c482b98bd37ad3b794ee7d135b10a100186155cec02239790eff8b088e893942e01ae6652eee8b3faec1ad762c7cc308bf0542297560f524901411a8de4cf262a7dc9dc471ec922516dc974baefb33e465ace724569c7711ae7f6ce0cd8ba870b01a423414cdeaef641f5c32b6e860e59454954db36b86b628d06d6a8299f84d3ee4aab505d2ac5e9f7711464ffb8b664816249b822d708a0c0876b94ac0e5c95a74a232f8570b60b3c991481e92878b877d5a83e57fcca6a018bba59cf47961819fd62461149aa89f27fae8dfa8c44672577de437d3a6ddc12da65d771e8b10684fe8d9a784e5137cb8ed94704ddb75c676a9b137a99a53880640cdd5756619aaa3d0a9c69c1606dd427d2783b5c3a017705c7b8ca7baee809186f151154fdc3c0756156dce738aa2501f53585c042e23df6a6d362f91369a2ac3c92e7ada0575c6b82ca230a8a273b2400fa4871b229160c7942455104bed68243f9cb6c4e6413b225d40b989d3f1fb2c0873addf48c8a040d6bdc773750cd24fc23aad4e7aa7f561463fe7f41310aa7858b84512867b57f0c2be06861d1d04a08143c569b6592d169305d8b6bb7c697a660cfd930e521c1e24e498821b46a10d36ec4581b57a7f9a1f3f7478b68d5301bd846960a7ce183d2c8348ff46c916425289bcbd884770d041b619bfcac915237049e7a6493e0c9357000347bb3bac71c4def1cd0cabd91ed0ed4603f1f348b679803692fb3cf8396cd215ea3a015cdfac4f7737b71874bbf5468177cc5e1e32ff69f248ca910d3ab8345c87c448fbe6b38e0f40782e1d03b89ac42feb14c2faa0df2b14d7e8c473ce0dbfee720a319939a7187bdf20320d7b2c3fd7f41e68ddf057c1777f4abe9365c5bae137d427ff3ed0455e9f7b32781a33dda42ba55069c3f267e8a75f11a34f7db55ed6442a1334f89c5b04c68e6d727c2cb8408e8162598cde71c9c7df8e8ae3892d9a72a29ccb72f4ebe8ff6b26726f13dbf4786d863659224c93feb514234684bba26cf96cda0da950bd318e8e3544d817d14149fa265fb163ae5cb2d6ffb3c695a74888e45ed0af207c842ea03f5fcc6ced66d02ebabba48535c977b8072f9ff016ddee56cf126543a6af2a04009da232b9ed379e9d8495026c52ee6144c130b0f9ac5c6554836177f1be29330e2a428cebc43feba7144240d1eece254f0e509d39b523ebee892a1b96fdcdc726ae719ffa53e33d160718d3c769773a7e450d817dafe082d834f6b6f121fcebee7b4e02d87a16ae58b88d5dba72367a9237db9af2a166d0082b92b39d1b49a091a40631d76b7c74179d14b336ead4ea010a4a73f4f60b9d4677aacc3b5e926f77d29d2ff7fa219bb347a5fa49aa39a01d5c3f3bd433350a6351c112c5a119f82347fdfacf3a0c017e6a827ba94d09277f8d31365a149d505f470d79f5322b4201d600f3c0732e4497ec64e52560d2f0fa9be5a0513cde718821ae9d9da7ee0cc8f40f53672e768eb71aee95e20b13223c299777621d9092a054604e9f7ef554740b5ccd2771fd61486687ba02d1b7f5617700d887c70b2db95247d957dbd145e9d608b59e2cfddc7682d63dd608f6f598bed88d08153e18268797eb79acda5b1591cbe6b1cb101a12e62f378f779a5ba22401c6e384c077e14500fc9a74837cf72557bdfc18d9c2af11d147c1e2176692484cf2037547a12f5744f2f3568c38b2cd9dee3585c7517563e4d947d274eef805340a11a1e4efdda36718c01ca10ec8c527f126030383660cae4a23bf0a509f2e12b7b30ca95b75270f159f3d6b82d1c325f6ba2a8567c72ee7c9efbc0e454f35bc80feeac7d8a5c329d42df78c5f3c5402451c441466ed0c52578c43bb7ee34567374b871ce9025e7756eb553e69b98ae525491845c4a0b37358d663a2396a7bc8742ef70caddcef411864955c6c538b6b168984561629272435968cf59371aa0cfbb877d7947056adc99ec48f4c57797dcc9d71ef608821bb9825cf4998e7ef6595a190d15f02f1c6dd764545665692ab7d5a27be336f91de29082e838a86e4d292b4b26c1f41c4d8b14844637143723474b951f83ccd191287cb3a77d332fd288955f18d5b61427306382dba0554d3fc0606cdc20806f392a3d03827dca9153115959deee3edd08bdbee73e104fa9352f6aaad507595fc244c72e93b0e7bc0d5a2723aeb9f2e6bba1c4a85fcbf1218b3f30c281a0e537f42eeba07863959e00224f1e94ca410f5893016c63f339ebc97fc254bbc0245e1c27831847591ac1d596d6b8fddbcd45da6e8b3bb412858414257bbcdea5d416496f213e7a102653fc260f80e6f5d7457823c4fa667a2d649eca5b34fce84782992eeb4fc7dd047dbd5447ee42948da6ecbc4e571dcb745ce8ab94f785e7cab1d8e6fa08b78fc063dcf6e4c1214a3a72806e3fbb51087e95ab99919376514f62b0256f7923f0bdda126b6cdedd97e24e67abf18e0ef7c6e41e29bcf54e0db8b00c89d243a46e2f45e894c765bb34c01495550693983a1843b2275fd81a1e6343706be667143bf0e5b067f3d363af4f79fe7f1654337639753198ef6e20c7f8c34d0d7c982426e3dc86ed53a3536c8588d8d28dad8d2763da34629ed69d208a9604e2b0e15fefa0a20661968268b106119f170f27ed50b142b79ec2ad5d72ebb451446431bf65aadc3bc86806cecf39e1aa0bfec38b851a63b89487c13e488b3c1dae5561bd29afe60ffe7a1d0c19242b0533bf2db49547253c395a9a1cee1df5c5930e731cbfdb4ac7142f8d24a796c23def294c7888cee84e7f191bbee65e2ad37ad50769b6ea4df8c74d73865407563e4aeaed28e220c18340d9fcbf9ed6d48d98a5408c4e8ef36e741456ef0ed143fdacb6549d4ceaaf064975184ba80df9a232236d588bef58c66420ebcf1d9423c074348037ff6e38791f9c1acac4b6853123c0702a3af7118b8913d9c953046d67cadf8ffcee182edac210c58b82242f2be6f7c4f3794e9b36297244c3e08ff65d4381c3ab223b30f91eaf530c54cc3e6c315baac7a9151e1f48f5b36530eb7cc8c198070aab832639ecabe7b0f53740548c9b35642ffdcd7b31ced7dea5785d084773a4a52ca8128c6770abb502bc472dd45009945d628ebea84b0b7cb07875a80d9d56a9874df91e9d95ff723124821576349693b094fa846d48c378707dafb760da3dfe2364e813052516ce3d91b010a40cd142b20bdaba276a26630d2ee3a5e464bb92dc03bb219e9017b3caefee716158cee8fd846503e0cbb6a81f8f38208b35fbc22c7e0aac1a0bf1c792c1da0387aca956b1d9ae5e0447783f7f89f172c242270426231fd785ac9094944b36daaa23fc351554055e479d1b27d43b49dc3b909f47d1637f441974d6cf50c221fe870238546bcd4eb56bb714679771c334d2f030755de09680942c170b34e43e4cde206d5183ea61a2e818af5e1fbcf941d08aefd7ac75aaa57b4c22e93aaf9cca93c0c5290e4fe5eb8ba664767fed812b656c8e1e109244b304d72608c109a50e6766dabd3da05bc581303a84067796791b449647cea43e51585ae1b801faf5eac52c835007653c2f5ca381d8505516f1fab569695250523183bb8d980160ef1d72466d1e7e8a0a094ff6a3d1423374ecc645c34e1621384ca801564f27a0c2c941e66b2cf8e9ab6c013f224312865e6e928d458562c0cd22edd784d144d2b491681d7eb1d0d61de94e91c01b07a5ead91eab3e96402e62bf18255274a93eaa9592a0b092ac52aca16dec59458f277648fa09f8335be93fd7772a85d558a017dc37e3543f850a29dae763ffb52031991ea5854ad81f4b8429a08512289e75224efd8bfa7d27aa4612bc4d626d1dec1069ca01eb2bd4d0c0954f8da5045b10c206bf94b713e344408bc9555896ef1b489657aa1ea969dffd7f7fef321c51862f64e6736cbec1e5d5d7e8ef520217309a03b9ecd0f02cf302e4bac5c3dee47994460f94c97194423e3fc85541cd5309c3ca5c1da21ba36091cda8420ab02285993b0e63fc1c205568d25131c1210ee0826f666f88e1fa6411d83573aa34cc7fdf98bf6414423386019de06ac938ff74883a208d863cf0f41a9582b7c0b935aaa6eee6301c961d639a49f37f7ab9f561e164f5d59a75a23227dbeca1780e5fd6b9589f0f0a44509a2801732123fc897dff71c3efe97bc48fbc21ad07c2d6072ddc00a1962d624000ad3edd38f52035e76457a86f51e75f915b8e30d3caa1ccbfb9c8b90e714a911fdc511089c13abaf67f1cc8bfa020db64b5d3ff634ce441785dc6cf6d7983eb0143fef99b384472a7ee894047a38d0cda497ea4ecf37a31b8b36b6c0fa7658300cfdf3bbb5f42e63e6ac61ad1f241b1924cac2f9d1ce7931e0537a83ef1319283bec3c8042cff354cf7bec96952177553625373bb6d4d5baf710444c7983f6fc922a145f62a1675e52b3e7ef4126f53fcd3cf31bdc2ec0e005d9c24a05d80f57d5b7086c005551cb9c90c2ba8c79b73ff5069962d0b7207efcd19dd8fd5697dc5ffefda9f5c19d4d800cb8fd4e3678ac5d1ed922996eadf652ca4c171a7808fd01b81bc94a9dfb6f0ab6993acc92f8e76a241461cfde7c03d72fc5813693172205f164db322c79f69fbf5ec9a75e36db1e2f6ee6adc96c399dc6724261f4ad2b5ffe2aa812691af8fd5b2ebbf2cfe20025cba5fd6c9b09267ce298986d30c16ce05c758742b3fa544823fabd6fde7752925d3cbab160e0f4c57deb7b1cadff792e7f922fb6dcdde3f1ea1c0d32f2cdd1498262de5149c83f5a11ea395e56fb43177bcbe7895c5b8c12165824eb1863b7a21bfa043fb64528c6207175c3b41f63d62024020eb7161e3e94d62a8d665f8dc68f9b486c350896df91908f7f476effbf4bbff742e1e064cca7c45033c22e7d551780d666504cd03a39e00d330f648ff970c75a067118ede0b5d7a7becce0f1b9f22fc23e2a075dd7890e246041060e2bd94792224f647d4e4cd9591ad5aae96dd78f81b9455e2499df16c3baf66f08fcf3a4d8585f2d659e1aeed0ccd3e7298dfd41afc638b5265e4fedba8571c77809c331ea55a964e7a0917787b85b0da12c44dde1218b51f610d83b5f4a223de5c9ee24822943df6c9abf0499d219eb867f262014995caeeba223ad9a4f55492f4999ffd94a3ebeb9d67384bcd12dd224a56c38ab2b6ba43d0c56ce474b0c0db638f7a6151defa431069d9f7652ec6a4d0455dda0f5be6cb06053081685054d30749750747f664763af9d645d99623e3153e29a234b11ae323e0270da576e77fa229518acf55693e429390404b5093f7066c41bb52b314d84338650904519690ef85dfb6b672860c3b5215c32a6dd50fc5495491b40e764bd8db36dc70a2058e00aa60e1319ccc2f790696ddaedbdc0d1cae639c09e683bbc27182655d0910a69c07c2f438008c413a1851e187cc757b61f84121c588f967ed0af718b5771e780bc3079ee3affe5bd5329e7991fc7073aa75d73738f58dae24a13ffc5bfdb4f1d48efa8d655ade273d037d3e1231a8cfb2442a84505ac0da7565c575cbe3205ca47c514d27c363aa6cd0c864e138eff8379b45617332bf9d08293df1d893751d4d2573093617734a70c9b57c78f1db45a7d8bda7793235af26116c095566005476d0e4305060650ae24cfc37f76e1aac7edce29d6da58038f6c764bfea7a21d3485b9c841ca2a9fdf4f9b102dabf3f8fb3ee73aae07cd8c82fd0901bbea0c93f9e130e94069be235cca3c1e1ff1e30078d70dd129644fc32c1fd2e72e0a12e829d3afd51aecb270543d5df71b34ee97c7d34b6bcce1e86cf6997b4f03552ddc3c83348d39758f1c4e33b65b163d0da6e60c4b7a00a387928944e145e0cd873611395ca2d800b5cb6c5fc3aa5e3ad0acfb70f41bdd0a09adfe37955762a2169de4f1fbc92d19b602ca791c44955f1b7e17fa8e0211ec4333a8f29813b7901e6e0aa222b2224c18b4c9873eb2d23eb9e49ff65b92acc30196f5eb8290845a486fcadfa053f1d27431a2b8644905d67d5c3924bb565f103384d07c083a53f36efb00504e19fc7450f549d6da155763bd6618a7c8e64975d612351c484e3fe1ad0f3191d81aa51b6763f7ef8c846fe81029fcc6c7a7c22774763b021cb900844389d7c25db5c506ab4fd12d742be8579d16f7f592f761a1a32f243337c3d1ea50654e669fcdc1f1dbfe1503e63f4367ae34456dd5e3100a654ef0de50ec408157b0ab00619397861d95aa95b5766c77226d845985cff7bab954a824187e3ddf650ed0ea5eb655aec206154cd70c9703a314d0508d0f4943a9443801274d8d30957eec39416738736380bcef539baafb06ad2659412d071e280f08acfa604d68fb78891c315b3adfe4cca7d29c4a052a3db19ba66b08a18814706ebd412ebfc540bb062bebdf170c441872f7f005df65c89a6fb0aea3ee791855b303abbfd8e3c4baf106586e5a779f9d03de050cadf960f57ae5209dd5954d255f687b84f9659e882e278ad92b13600de2ff008cad10877b0da84d54734e08265a186352bcb02904ba1625cda5c455cfb368946b431d7e801de0b8cfe112966372ef8fe69c1c026720140cfba390cdb256ff4585461669890303246d5219d16c4c6578f69c1834b4ca1356d38b8c04f5cbd9f00fefb21e6995dcba5315fc39e2e58000ed52026e9a8c650453fd82670d4c02b2aa72dca1fa24585ebabbf4b299732dae95a745f24591b4103097eb9df4e7079e8b9c92dab5260398ef4dafd26a4677075f871f7f35e6b80aa18994860565393a662eb03efc52dcc7f6a44bfcd63ca3d5df74d0a70a961e83205ee631cb05ddb15ab1d0340af3a468b1adf807d0aea2116adb17ae458f216f98fe0f28ba72e28c8db8070d36e05a5ee5f2d65bf00120ce6c76b436ef577975ed6eb85205e31f63c21d5a2f6e48c7ed6d29156ac91cccd0f5e92403da5d52b68fbe7b0a85bf6e8c102f43a492a567b30f5a491340a76ce690de936d1a8cee186bb9eb167a94945b3bb29b3f9b4fe009140a6d6fc678d3145f10036c653ab5edc356e3932ee7034699a0c5d9bc9af94c38f90b452fceda559e3885639053345d46bb7d8a12a41f9af6c8d6ebd3eb0e2cfa547755cea950c785cd00303f264ed3e2ee29f381533f4d58c82ef1905ab9688d4d157ffa8c27438ec0d1c55c32364cb49450a355c0b99e732d2fe595777cea2b4f104c6a9faa4d93b144d1ff4493a985ee2f9bc4cbaee37806b88812223dc8286c015935b4be249006175997ac2997403090c3963c759c4e24750dc8df366b24a8d10d504b79ec7dbadea072f018ec310e4696f57145db1347bc8666984219a410925cb0308ab6351ddc300cce30d2c16520e34e4674edf3af3984a8535aca367bb8284fc72189d8d56d83937dfa803c22d73a1b4c0e2cdd1220ac7299001c01d356cb29856379ae24277d3013c91960d2fb006d9d89e0bd5a6d1cdfad1c4c942385a23b90b18d782dd0932d09ff5d45f797263ff974d9c048e7ff3420334dbe446ad9e766cb77c81b6d0d6b5b0558711bcaa6f53f4e118962aa45070feeb9c31f14b5f3e46280bf8d04e96214adf1cc7a5c8baea003f23ca28343807aed023432e9c459eba248eeddaddaeb574ed5b332631debe7c741055164bed2a160144fc44572214c88c69cfcc4bebe4eb40a63d354b2d7704651a4829b302cdab63fe7c0b972ea405412adc951c7844a101624431bc1950f5bbb501f369d086121fe4df392cb792ba45649bb2dec4e7d76a879c525b2125a9a1ea9a4e0dbe1bc3cfff50a1ca165fb59405bd9b5ca4542363d8b6e1a9fcf48e2051e72ed8f6635eac40aa6e78d0f391481b9cd27ec4a25ad201246b8fe9cfe3fe4927ea2a570e577be56dcfeb621a3ea49d075e994c034cd469f722b5f82d925bd275ca6c6fcf2473e9614dc09f1c15ea0cffff67dfb3145f5d15f64d1f6dc601d684b8b94310fc8da97c6dd449656c922e3f09d9f22ace4763896bfd0eadf75ed25097ef1fd07716fd8715e0f434907c3d3aef2673a0aef60cddca01197df5e6208cacba3e60066b5dd47d0eb6c3ce6b13161b832ca006dd4c81ea9c274104ec9e6c11f4943a91b2d917fb88ca4635fdb3c3e0f8fecbe0986e5339165df2eeaa793bb53481addab1dcf68b38eb31adda2c2f9bd4cfb60b8497c845524b4d10249f689631595b27cab2f2482189ae935fd10124c42824ff7e20314f44e08a67d53cebbe34646011b8195b0b3f10015af27220cae0495a134d0e7c875dec383d3ae242e750b93f7e7588aa189551975b3a1ce4da93ca12f34d79ea2384930678e72507cdb2751705d9806c8d5faac1250021b31ce6a66faad9c149c8dd6480a495ea2a8c5c6f05b8d93d93f1baeafb7a8d8f60d66e01c8f7a62f46e433dc917fd126032683d999d7d73f436f0eb8e5dc797c275263727e2d4ed9acec969938705544e1a798a2af97f655d11b7dc04bc6891bc739a21181643169a4a9b847e65d4af4eb36788b57e92c2c6434e99afc2ba7382f3873c630e5e95a92a1eee11e45fe92ff7badf62af20fe12449ee45dbf150b92d5cab84036abb9c05ed2165d9217135d7d290447f681d86b20a0fd755ab57796ff5999c61912f83cf966127fabf47ada53eb65f3d26e121c69b3adca4a576f1545551fdab22d0a276acbdb34d3b03618fa12a849456072c4d21ba89f3f5e780a80b935b6f5f0232008108a722cd50d9beaab9661c17b8847c569722f3c9f06282ab08d19401ef981e85c5ffa3897e3d5d4e3f26c5feb6ac8012d036c2c6466a3597f095c36c1517e5c0d4172212fc9df6819a54f085356d0bd6ced2da45b233770a947356fb0f5d6f58d89fe595845f2142a68577bf423f134abcfe101a4296f26dcfbf16483a671cb5128c469713d3b898c6d1120b48f92a6060c9f8264d0f9bf3d82269599dc634e4278675f84fd5a3ce35edc4b35ae2a33c6de787ba4de4fa70868964d4389dcf443754b03ac3f042d335decae3a53680356e8d7468c47e45c8118d56f4936636df05180ed031b16db836659b6db568b80c5b515985a78495e9f860ffb52f7e3df2e88b2630cc3643d749bd4b70d85aca17e845d02a1dd75978236312d43a8519e4308d2d7f6771a7c2ff34d455f637f3b2467888c32f5823e8434c8d72ad7bab059f00900fac4fcb1594a6a7abbb2e035adaa8343b748bff80ccce00d7ed59221cc489570b6ff0dcfc792e1b9045e1980367bd89d4d26cdc1a6acfeca760d4756dfb04962af9b8c6b9143fba99010e0c2906250dcb29cc1c1776d7781dc422b104a9c849e553e14d329c3ded3a0ddd83a9f918221d427159e55bd3b2e60efe7457dd77bc0ba30da376bbe944874e8f20e37cc30230da252430381330ba0cae7e356b10a9eb2906a583feb7147de75bb9a1c402be18869d85c9049943b6c097e3e54d26b28d0016303fb4b9294a1a18b75a0ffb6e0154de105f4d4c3fae3c3f7f1262fb79c8ddd3d57d09088db0df4075706cb22839a80beba76ac48262e37065c4901af545cbfdc22f796664e4af4af08c53832f9a464fa202e973f9e8633668ce7966cdfe50922616c6e1106b7ff7006e952e4707fac8cb619bbd3d4a435841bba56d87b776b1f96fc3fe3ceadf495b9688c177a2b7c599ebb49752433b0f1fb0ef7b3f9731ba52048d02186b8ccfa23b1cc73615cdbe668a604fc9cb4219b1edd669426b3f6ef692b99ee37d31e774b244b7b5f212bc70740f005879144166e04830790034ee8a8f32f724285ebc9de468207a2912b49d1bd9be78a4dceb585b6184cd4154a02cd9471a1888c5aa831d12dee8609670a6fc419c31a6a4fd497f52b95ad26dbdda0deb5d331e0d3cefc91c5ff4767e30550e3ad51bf2505a5dafc66016657b5e4aea49c8212809cf119ecd2f4a13b6aedc7ef6d7bdb8966646f6b22d094cd8c085615b49203b575a75dea8d33386df9de4f400879b8ed81b456e066a06c97d8b1ae51b8b476411b78aa1062386e9d07c8cc99c3e36fe57ffbbd5e05a1b0ed9ee61bf7ccb3de53790c709b1a1617856ec3cca1f5ab0b40c8ccf8d75711c754de511399645734c1bf7d0ec638ef4b424ae9192804762e981ebf3050b7041228eac411e19711e6f4b50ee2712b0b23c7056496b44573b720f673b01abc8713a53a79c403183d90e56cb394fb433c6f61d26957f70659fc2eb7d423928eca5386118175d9126890a8e72ea364593d4ee444c95536eea6f3b789955c1a5b71fb5ac360967ee3d5973b7b63b3010a18c92ce7050a7aeb387085f9a857f62b7283a304883fe26156f4523c4339abeba8e942ce6a2ce0f25a2d708628e19b962eab62491ce02c6d9107048e5bc94681c57028abe51641d1eecd2217aa7c1b88ddf64040c482f4886c01d5702b05794fdf5757469e4e87a4242edf58ccecde6b28d5841f78cc1e81ecf26e716e91729a51c0fc2312a248c74caf23a1b3f0de04e8970eb0b657dd20bfc0b8b702ba576c515a865167801d00ee0273081d0e62509d5126e9b0b60e9fe1226bc6a7005b8337bf6210656fe9148c2634b20fd85a2e01f408024235becdacfd59c4a82277db2626aef284c8e6a62e32186451f5e3199932a24b36d8aab6f1d2db584e1f4ee0e7edf4a229359560f9145dc2292c2fa562c5a677a5ac64acbbda66bc0a802e42b7c681b3b54e98a64a55537a5e676316ff38971ca4f019cdaa7f686c57f9998ae2b99223a8832b42d574a39cf8e03c7639928c9fcd49c1957621d0caa20226cf3e8b55d2fc737d4a9f8da95c1a341bd58d45a7d60faf1accef72d031505fe5323ee3483d75f7662a18329d972718663cc502aa787fb0d4a4d931961d4c9c405d701beb5bc394e0d7867d0ca057242b0184ded8dedc66900e99722807e4bb5b011840fe0b0f0fc2f30ba0e26794afff002a5a42dc45ca1ada46d3d687a0bb122248b5b4646cfe0899c24a45c2e074f33ee80a2f4f87656d32cd5bf9131532dfa03f90dd7c6f31928cf67aad15a6f9aa2502ddb79bc4c09ed7013aa48d6985b29ec990ff3a4372bb024b65f78c0699f3dd4a9785f567718ad15c510e7f34b26f4ecdf3c654ac02cb2902dacf20c7f1eecf93d70e028b0a8d5d532fa2bb35f04d46e55db4badf30b897e8f5fea482d3b8a8f48fe4fd1ed42a86c9c6ef506fbbf4d3432ffefdcc756cb4995ce9e855a69392131c37ef1caa95dbe4b67d02b944d6053706f02f00a1716a822a970733b364f9ed9115094897fc8d2d4d03138760c9db82839b4a042f164a6b3f52b6ec1c73809d8133699cb84f4d2e90e0b4db54bcf9c67a10459fec407ab0e6cfd7a0ab5a27c8b36937b91a54b582daf2db2a37c961459e2793b264cadae872dc447ff8fe1064cb26336a78c129631159b8d34606a4f4335cb54cddfb240d7d70859cb524d96e5e1462895426d42482d848892c6fd071abb788c5cdf8aa16b418b9356395c3b389501bbd1f88387bad028f1062040781ee444e3cb7befd3b3d75806665e1d9abb853dbdfaa420c2e2689238135130093b7a340cb77e1a2796b1ce9d7fbde05f008257ad14d7a3e2cd99e516814ccec316179ffba2b86c7b5a08b25d89a3452f1ed3411b9d3184886a9fc7ab49308ebcab5ca63759c8b97da87ebdc578a8f43632de849a196a58f0545a49823c21ba8a4dc31306a85a858b6768b23a2352c419ff0258796bd917a6645d05a1c4f1635c33ba28c215e54610ddb6ad2d8b75e0df66b98b0adf2313f53808e23891816861670c7f3f7330a231980ff6e835ac852c6fceb3d00eafd944c7af0b124b379e8d6cc7ebca0f846eae436034e2b2c4b09fe763f00e8315cc6eb4b620c9e42793653f37281ca7db75faedfd764a8f0049302ec8f9048f11d0e42803ea7f0478271e8dc8c51ed0b86af463e3ab4624744f83fd9776f6f3af7e7085f5aaa31d97386bd7e7483d1a043bf3c7cf2fd0d6780625175771495c5a99c554fea399ef91da647cc63087dd25ee7790b84321aff902351ce632b86566ff134986fa5cda537d5e44aa516f835f733debca3fa250b73d2be5e5c2139d465edac6a794f0aae5257f8c5de11bb93c7d5c25b1d6392b58cec2013392309bee9344dd4e9019e40ecd8efe9284854d2c27ca15485d4a144986fe90abcba78d187ea9231f41938f27e3ec612e335269e2239360ccf0194d23af6683b135bbefa6cedd895a680bc6ba3b3d31cfc4f973a456952befe40f4eb7a5323973d23cb32687cb9525952ef61ff2d7b139268374fca0fc7e6edeae9f65fb881313866adcb07500e3694170a291df5e6ec8af2a0312dae3b0d532d6057e9dd18b3ff30c6d0252c4bada495cc24a9ab40df337ffd804502869a5ce31a09367eb26d9b4e484769c0462d4ee31effe5267863a2db056647ae08b8e39057a380225327a27926c3a0b5ad34666446dffbe86c438e9473f4259895f7fe5074a93d54ea37bcaa83fbb32fd6c3dcd85590ace7aae8ab9398bca9363974d3159965b0991fa434543260823aceb3b2eaa53436e421bdcfd949d5051498e46a5d35f83fbe3c284f5b451d65718aaefbe8daec53f92c787db8d7ab60266258d86c3a1a5e1b3ae925bdb1b7008693dd29e1f8be7ba91d1f45e1d6ffb9267362817ea0560efb57cbeca67fd6320bdb82eb305f9334cffda08462d998594291ba4249ce37cbd29bd2658ab0ea2dde2061607c83ba8c0e92efab63e998270f0bd0aa29e215b354680c33e04fa1fc73d797e8b7b31d8b3c020b8d7126d5f25af37a5d174620f5e289190180d18074c9c01bb52a75eb024882b3798ef73ffd786b0f95fb8fade5331d2c17abf0fc1686d904f6432f44bb7a5b667eda7bba499943647c515cd222872b4999e4ea8cde7f37572730bfea1ae1c2c440ee7aecea0674497f86bd8a158262c52f3e0f342333fc2055a40fba6aeccb35d866443550e28cf6cfdc8791f9b7473199899d47b1cb26f44f15d943cdaf7e98d00a13c3ae15708e7a4ed5c5ae0cee3db8450b5a84bc100e7c81359aa343faf0d38b261a44870990671eba794a500f842dfac0026a877af47c316e8f37349f6aa8f07d23b1e70c9ab82d8ed6e35ede7d004d95129d6b1cf14321485b4b9caf995ce643ae074fcac6e5a665e8d9101a2ba93027be84e9be31029f7e320b7de631c6707f8d3c4050db5b01859906ee9e1470675147986e6f25dc6e890877233808cbe5da8ef39978b0aa35e358526f2ea4f834a92595400a7aa684d75b371b41313f785017fdbfe3beebd1740e982af452a89c0ad65d7d604423cfa1ef625b7026bf29fbc5ea084bd43d98fb6146a45e96cf3786614a34fb84aaaf16b444b046a154aee44e6822480a2ac429ac3a5877a72a1a89cc786a62fc440b235f0ebb11883e8b963b50fbf0e1d8fbb4adb28f4276bf4cb203ffad7678f0639e1506183a2bb19c70a8f0f4333f48fc0b9a322c2a08c6a91850851493f24fb4d07498f7a495e1eadc0f907d2f2d837c358056de198d8b513746b3b8a50060fd4db3e6be797b07671a9ae435aa26c9b709c7baa2a3dc579278ae02442d618ae089481b38fda0b74f65afad5a0b862d39b376f788c701de5e76f842768eab123102f95df1581849e74d1cfdefe8261e3c9f83f9bb3acce8f1a0ba05ba24fa921fe84f0186402ddfbadbf162cda94112d0125d20404fa11196c60c46921fe07f12b45671b35be79fdae9f4b32e258f53216cd5789746dffe5c11fdda94a67015862bbf93bb6982379933124bc7decda8a7c3267af55f2486b17b30f403d5b3fbcacefa15bd8a73c15ef320d710e3c8d88d406777dd12c923618999303a67d008fc88e2fb2164e9d1ca1cfc40276506c6663e57839297ad6dad0caf29611b84c5b93fa045113cd53e3f838b386535177e5e5d7f651cdb46f039814dde45aec0065e0790a5b2f87ea2b0f51b850c248d58b46b6c5264d206fcc737de3aac9ab85fb30607ce46d1df7e2f7bd96ebc2b6bd86ce8e2034ffab2a965f087b2547e7ac16562686986f685e45a685665a49c1ba08260eaf7841be4fdd292cb3ced86cdb37564d5dcd83aed4a2f274b96201f2082a56b8d4a37de2ad37e10b7498e7a539ebbdf4a6fc631b7b8f8e7542bb766c97ff43a4466ad53f22344ef074a04eb7e16a303493970a34b10b71cd1443265d54726af6752996664bb20b57a8e72fbbcb8e1333aab99285695cbe02967e2f9c0aa81e94b0e8194a14da38c549f9fb3dea9d8d71348cc9dd5eb4b35a4b62fe7d16c8d694f9b9c8ae6e2f2a3d2b3f9bd78eabb5ee93e0437a0ccbff0ed8db0870ebf4f608689485a7fdbed0f43a18a5d952f4a53fad05688bb0bb31b8fa1713b4f10bfc5430d2763511ded8a5c2756a10837873020064411b2f37115aff466924dca8ec13b9f3b40724262ba86e37d791970c5c807a7969f3596fe41897d0d715ac877cf0ea712ab058fdd4eb6f4f6ffef0bea12b48387f224f7891f5c74907fc7db5465fe8857a16d669e073fc656ec8e5bcfb4f2e17944f3a7c471b8a12fd5f9e76283a792da4ba78974d832eaa986ae0b1fac37e41914c6643754fe57d9bdda72b79868f4bc8c9fa0c140d5c0605e792ac12146ddd9bb9ffe133baa8cf861c6402fe86f5fc4c4d3c7b48a7d197c88abce27f458ce12931bfe8489dd13cf8e2fb378dde98c0d4cd820dd2fd78670cb677d93bb3a82652cffc4dbe518af34e2cc38334178dcf51a03e130b848b437e1ae27e8a99fc7794f0a7f9378ccf707eee62e5d2fd0b416813b4c93f941d89479a89c7884095d0ebc0343d9ace562c5f7375fcad436fe3c0d153ec2581964ad1d9ce188b96a6fa61c45c297a541e013604d3d9de4d222ef5c5001aa949630d86c2240a6b5531d1cf9be168d0f530c3fb695ca40c3d563b71a4bec4c2e58dac6315fb7e7604ee32800bb33aadccc9ecbfd59762ed989ca0fc5ec15038bd1b5acda580a32939384c76f8ca4f042e883e19fd5c5a50fda78640a4179372deb519b91a927a626202e795fbc544366863c330bafb6612dfe81f15e3d6686d2511209d75d56b3c6c00294120d6a61e32c17315633876d60e1e75cba7905a702fc0753233d2f04e8ea3ad058f6b1a723304889135183b047bccb4941f2d99df058dccaa691d3d204124b254573fae218c98435bbeb8f45df83623bf2204994ab3d6c8c0d16a98f803ba62960091312","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
