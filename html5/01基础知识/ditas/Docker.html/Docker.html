<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e98dc1d3a6ddd4aa381ecb3e71433a7f1d86759b6caedcccabb0db8529a0b97b6a054dd3477ae852772701cc6b75061c4b50e3b23c71501223aac9f53a24ce661b806174df6c227f8f11a70301c173b6344a35dbcf7de254edbd2daaa63dba0a430b616b5434fe259a1e181834a458d56ca56e9a8dcab818d92ed52e54ccd4043cb3e2ddbd44ccd7e62ac09a79c8bb335e444ac19de86234709d9ea16a0af201fa6919cda4d14f0d14c7ad773bb517a158524342ca893dd47f2773454d4e4816e9ff4d739d526e68b48f6b0495cc9f52744f20509127b83827173df0c4c8d80734bd050136cdc4c81639dd46cf042a0cf18928cb34bcecc71764d330f8e96b08caa83023137b3a81f334d2153cafd47cd31160bc26a5041b9f6b49af8b0cf8df750a413602241594183a0e04a5257174ab92f94a499642f27e8005714ebc47fad20f05590b8c346ddb7ee86bbe54cce0b00bb3e1098e3e01a285ba804abb704d7c72398e7b7b900ae938e0deb2db3cc072f7efee8217305753217cd757ff4cee443630d0ed55393ab6547a584101f417d7dab903962ea3af64f88be279c1392342ef018e526a060aef3e05ec3ac3937c23876c8d14c652c4adec1ad43f2a0b000572e4a1ccbc54e3357f90fbcaf827eaf844f2e272dcd4d8079cd63ea19d917987581753778f92ea61679e72228e658bff996e928c8f33614c257f5685d4d634bf7bdf846b263c2040754d973090a6344ed26ebbb1ab8fc657ac208a0e6e01cd0b54bd707d825e0eda94e53069e2c477c0118f8159ab0cc796c5ceed0a9b421ce7f3d6aa168eb0c87ac5baad58246e0cb4d52ac7e586cc7ee6b551b8473f94aff1da7df59c11255ea4ac5a04ead9fa342571ea5436e3406d40ca1f9672a63d85681ca74883ce6f7dea3236088eee84ee15d27a25d9d63c9a8ecb872c0f29fef5cf3db109ddbdf76af68bee772e169e7269f26de4475d625b2e680b4cf821870361584dce1515bda5d4988fc01fe66b870b0b4e9f0833b53fae6fbc34df767f14a706fac95256018b4f130f10d8324b1384e43efce0e964a8d2e7bb23bbddd8c4348dfa70cd305b25d49ee4499ff34584b1e74a5d4b89d4e6538d82a708a9d7ff95a46cf8010bf6b765d549560a6b0dfeb0a90e3d91dc16b7b4488b71aaf5a59b6ccb59aa659d03f127acaf5c89f37f8c93e862e25e2cce9d95649589a6a032e94cd01d6b85d7a3efa4b139d21d031dab70cfd18eead5948244954676cea73b2fff71c979e113c6555c67675f1ad1da1720819f7ceacfead6108c2831a583a55876c72ba6ff080d113a02955950c1b9bbb9e5ff43bca54323f31b491240a63029b13c60fa90bc62ab4eb57c2553eb0cb000e76c3874ca788e8c1f9ef3a8e34a09800b962e614ddbf264458083b05d43f65b04f421f8249aacf4aa20272bde03ded096d727a0a93e3cb3dcc67a6a7377425f24dfaa45d86c06836af0405ce488754940cda4597e8fea47a954cf3e77716035c212b38579178b4f7ad6d0ca5dde68d35c1c95022860d73d1667b878ff35065b841bb4fb57f3e61424e189b0a2a40a0078893d09831fe26fe47feeb1321097104f26dbb333e1795c1dcd46fb3e9c44b0fb02f49f62a998e8166fb4a497196d8612d2e46abb4ed3d3df417e6e280e167f4c97dbc78377a1c96761239fd917bd72d8735a16279135b4382b922185e39c96ec2f0c694b5e31a0a94e1225100f983b8411e70c4df5da77b48d3ef11d0c7affd0926622e5a8093554466f3735df4ca4cddb0806ebb37c6a989bc59b2d8d4be738c3dfd7c6bd159fa4d7f784a6b1152832b03c6c84d7c010017bffeeeb22f8449fe1bb2166204911ffd6076e6745b848799653820d92e3f41e708e5fbbd9195edc39ab587761925776160c2b933c10655528e4e06bb75191896a23ae6b920ffef2fb9d0aa76e3ec53d694524cf3f3bbbc049d8eb7a8fb7e3e5c4097bc620a2a8217f00b74dfb4e5e81c14bf32eeb31bf3431a7e5f1897aca6f76548db4ca93c430d6e612a47d66471e9991dd36241268b3fd6d5ad3654a8141a91a6517f7c1156818f20c12c6aa223ac84ae34e7bd3f626c7e1ab8f0edf2e5381e35a389ddf1c05986cc45e605c71fd3dd1e6827300504c589adee7f7a72b6f7413a57f0d96691f2e9e7d5da2bed75b9c92a27e0ca82f4b14eb6c1620876d7989e4e4ea650044e6b21966a55b7fd9e10767efde37ec66cedbba4ae4d2755be9c26ac2f92feb22909b3639cc5f6a459859c7f4da0454cfbfcb37196b629bdd33388d0d5284df49a645063bbb62cf97dec1264a9b8db5757fa2ff487b5fb63720b56ea530fe29749f89e3a96d04ae542123d384322a9f271c48b8c7a893a584b92b53e84e8c864663d3e46f21e5b9930c09b6037da9cb3c38161070f95733a205457a0b1e790cc4d406938bff498ced6d73758719714ef4c1c5ae89ffeecf31e731c286faeb7eb03f0a86501c43c23a8e96f32268f307373bb5350ce546676a3a1812bd80be035dba9e81ed61a3b693807f659f1aa391259a303b2c2a07e6b27b62660880f4ef424dd8fa9a9a6698de4997c7787e0ecf3915a527842571b1e8be7377563c33a3b192407ddf15810543b862a052dfb214c0bdc11741c466a42c6352f2e4c760b9f387e20273254e369634d9b798516ed81ff648027d22d1b4db47938746b018cc7515aa3028801269693eaecae7b0fa42bd4f51d3a3c22ed57de81574bf7ac514ee32228add54e740c22df385972c1768daf13eac014d718e16e0c3b480a65434920591e76a189ebaabac5db42c855401035ce6852557cdbb868e5ff71dba9f8746642b9f1d1971224b56b384e901031bda9172d34cebf659098fb29881955f3f0ab97228740adf9cbd745f8c7820048959f9707044935d3a474c5cb2a7a8cb59d0930f0def8bcfde9e4e1ac1802080eb8f4e902a78f12e337e229217c5554a75c5850a24f602a65f3791545614a7a3b917e20ddcdfdf387ffec8a00b2580faa7ac2aac419d8e2ea6d2176aab1c2ca756d5c2f339b96ec0c9fceea20463f962a887d2a9365eeac1d14eeddd00abfbccf75430f52a882a794fb460f46cb3ef8879856647c5b2b2bbefa9f9c0ef60356a134944893d5da738b10ec99c981e31ec1ee759a3faa9264e4e2f954d2fee69d0e1480ca0ac9158c3ffa9ec0f85db23962ddc06ef4c988da75487e4db6d079645dc95df45625ab4e458e6be218fcd4f9c728d940b15efed8a6dbc10b72ca381702641cf676b428484c89cab1b2c6a1c22695ed5d5af9c5a3b675ab998d5790c5357eb1480ab445c0fef7a26318a7601ebdf68d2620b91bc25c8eddb709b11d58d955e0a0aa1a9ed2d21579cfe87bc536161185f9deaef05484d1005d73f1d4ed5473debf0d6dd69aab59ca84ed3da417504365876b5ad8eed0f0c8cf4a54b03f848cad6ac6b36d8637d109b8e1a856bae27541dfca9c5ffb7bbfdd3b96324eb3e41a519489ad3fbc8f770fd82978e840d7c5f0f34246409eff6a1f71a1cddcdb93b5c58de11f2b9b53b8f7ee984a3d203e89e8f75076ce29de3bb33804122fe3e3771b25acf77b384759ede93f5cd63c46e22e0c53023019f02787b5d6160d0d46e36698b60a4c7422f58a15cd3ca33767d9dbc4ee417b4b48a83ad180cd7c42f933e0b5fd2e8e113741231012cc293207892d5dea59d7dfef6881d777acaf0bb4bf7a19a95eb1a1e41274cefb42976b8d6f1b21ac1bb02e6fd05afff942292b4891aaf25fea0cf948e80d3b5802347af286b51cde1a88c215d4dd54130c50ed4382414af21a94959b28dc14f63ff4543cb60920984cf5ee5a485b0022ee4d42b337fd61e945b07cce703da9ec2421b3b7a6972ec83228ce83b14a2793697f88ac2cc354029c01caf5188e8f22960d16f0f6f3a087c958cff151ef19303f6146679e81c752a405f1062ca5bf0e6b6b3ffa14ba64a64b07d40ea500f5e3d04a240cdb425386659a1db3aa5485513e5378b56868d1d4e89e193bae48974fbcc651d6cc560634531574138d1a5a042e39e9a3c3247e683b50433f271060ee7a420b825d9a79df6d11e5dfa770c522869c6b433ff183ee03dce5a65b82922482e5161104db7ca2ab975873825dfcbcd4e96bc409160da8e937951f7761fd7dc28adff291c5846bded2726778195be3a06149360c1b151f81d443c32195af64d5ec14f01d5f3429eb9e23e686606822eeefe29a8acbdae7df76d095b37dca4ac63a43946f52da5a8a2bf9b5aaa17d4c1d2f7c71491fe75242110ee06fef20fb4d00bef99cf1a47d87d016dd14c5818a57e7c3c26dcc6fb3c836541324f5edc2a19b40e32a041e6499194a49f1b626bc232e9c8484b273f41e6326ce27f5339288e29b46af1835853adabea479ba4de317e6ad3bd3e3959ae2d6c772daaacc2471c0936871ac3be85f47330e678136d82a0e4fa5da33dbea39d7b2eca6aa149eab0a3df9f25f1889305b47683e567970d86a8d89abc576ab4d44eb3463bb3d0684a617c43823088a319cc272c3ee18cbc45a75aa6177f8c0b729a2c8fe37543602c3515dae05f2a3c36cb946c0a2eeaaf4131f01339793c1c6282fea57bcd18b193291a03019de3c7ab83b9c3d0b4877c46ce296202fda4424a90c66323ebac61462df754e745bdb915a807f2f40b9d8a3cc38255ee3347cdc945606863790fc6b355b7ab968ddc2cac0178c758898dae071b88be82a7ab9c31bb81d7d26a76de76b6f25f371ac2afc21037b452952fbb26bff879aedbc7aa695b9c4d863d85d3dae585d1139a52f5b09518bbaa87ce7bb12f51b74fb69f087656fadcc82d554d26a6644d8135210c990202537992a39aa2a7c3c8751cce3263be990bf6f35983914f021cacabb8cf47d99c47c48ba2fe8655b2d758ced3d5cec371edff1fcc6bfc7f033406df97056b4111d1b03fbed5c7a58c650cbb8999f15d1ced3ddf0d37e0175bcdf3b38466655d6f660a885a859779defb134a9de76743474cc59467b74fab2b25c7e0f41c99f42185624e859ffd4d1af27bff8e6ea86f750fda5ae5f9dc0908471a535c56fc1f7c9bdc60a8fc1fc8e0ce020f866134a6949bb2c24fc022301b639efd31e02040d6073ccfe595f0204abd97ffef9be6a4761fc6834a08bd92d0fa7500e6dc591be5865a8896bb1b20b477eb783d677dd1330ff7c54cdf84acbbaceea1a2edc87173cead275013c643289bad01edeb251baa324f616fbadef96b8907d02284d32e63f6658ab936e8716f9d22c3afd159eb2d9ee72a6c43f84494d12caf253437d10b91adc87c083edaf0087fc2013294df15f3841c6664d27d30dbc9b7cbd20c2714505c60d545af5a817b5bfdcdb834783c61aa5efd2d6745749a89a4cb4f473f1d574431bb657ebf941ffab8e02c396fdae75def28bce197897fd758d6d49d51cb8f9461ae04dfad91185d2e118c3c3cc9ded94f89c35bd2f67062e2a5f4a68f392bd8947f7876be8a44a132e4b030963f58ca059d06b14eeb2e6e7067347681af138e2871655d3c7635946122c014a89a125199a4300776483e1d83b2469c7e63f752aa6f3adda2f0f426a31da804f1d6389969e7cd7dc19be42e56ff7d39c11c9236e3c4b02afa98afb23af82591bffcf45fb029d5139eb730b4d2b797f95b4c766ebf42e8901757efd1b1551fd1bba452bc7fcd6d863d02faa8737d90529c971fed3f5cf4d2e1a422002cc95165da9e7c1088a1652f273831297851697091986c941201716e5b25d65dd4f05b8840e71385198e56102273c5be284e496ad7a4bae06b152086d489b00c4a2817553e2669bc008211dddeb6838108df8723d10991392b78a13fc0797c72ea9977a905343ed3864c1d2fb7521fa25983558ba8ce04e7d9c94029fbc3ed97f8c8b2118f3683cb0dccaf4645173254975062f3e3f0e876f323f56d2d59a79d95354dd43d03fff6042505aef3f687f8cf42241db1e371a97f0b9c59b656cdf92ac7caa9a45920dd25b5a278cab26d50614dd90e5fb0689edc27476036a4e55ec96cce2df9c48666bec392d7b1482ee000bf387a2cdd6aef163cbcbd16220b872a6dfa367e6b7f6548842934fb4db0ce6df3a54c345ad4804465ba64e0109c443c09d820e14fee8918163d303c5a6325cb1a8638c60ab98c76f2b6c323d276645bb92eaa109aa5b6b9c53d3a5ed2afb80f75eeb8cac05b35fe245020c1ebfe853294f9e3657fc2d3e49513f9330719769244cf76fe581d1b4613b9bfe3397ebe6a7df3ee86b1667692d4c45d7db37a9e0e276c89b609f6c9201e3cadbd2cfad70ff7914ad18868a522e2c27cd445b288ab02e62a7ac96feeb65407a9b18e2c679e9425bbd7b17d9a68385f2236231ca8ce48dcebad02eca600c4d17b663313296bd3dff012c37fc6540be2f46dbf0c267d2db4fe5bea08727a9bbdd2a2fbf90d9c4ce192d5a0445acbbb5ce84def1391cbac456a70def7ac1b4a6124eedbc8b785e635bf66414953921ce30b5900ac1d15b3d264b728b6338ac9582fab78f4b7c2647a31da5b4456542ef8aba948f27170e2f85550045094b7dd535c80bb897d1fca606972c23be0c59388363aa8af9de76692985bd11baf9e2be39b1fe8e0cd0abb164274226adbe4a8d1dbc8b5422b643b5784231d4f32d0522c298f9c16a13fa3d3c199d78936e1b303217376a78963f5a43abf939ffd24ae163c2dbe8ea1da2693ec9de58ec27ad22d0f9d9d15776bc379637c6a2d7d62f0e30be067b57e9a495f2528ad2c7d39e190079aec13f20197033a1a372c376dbd446cffd71aff598e14c57ba70836f4242ea0494fb21b7d30028268ae0ea7e511c3a3edcb8164011438431be82665b46228d377ecac7e79e183de19f62e78861207f76dff5e225bc9fbca8460d44dd8e22e779501623a630d631bacd4e308602e88f1a78f29d6e27a7a4ed9985d4916803d7cd04d79d56b1e55ba5a13ae4e57cf8d56056485ff1055103d5dd74051faecbec405921bd823ca27a51bcf4bd56da76c58666fb291c5166d0bd4dc8b0e783659357fcab83759e7cc5ea511d7617ceb126319334be091e5e620ff06feeebac2f7b1e6e4840dafcee09461b827b9298a475d6ecd12eabc2aad84efd500f4066156dc28672c86f1dea477c8ca7a3d1da6ef117e1455b1b4df44a4bcf5131f88d764874a7bc269c39101ffe944001d185bc98789d0c2faaabd1109f9cb3cd47dc7e8dcbcd92a402ae517aa49548b221adda6c54b48b53703e46ff8e65cb8e664e3fc31d5478b9ee8270d69733f7330a5a49343cab2f8e2dd2f6b7d997d5d51fd3c5777e710ff08c7e78d1fff6a1e772d0f47b9074c666a4efacb750fd8a792aaeeab2ac7edd0ca1a22eeb2f4f6cdc70c18a80fdda36cb402aa6d7c6b07990746a8a1c126747203f0119f422f4b116090d1590db2b9497fcfa1e2a361b62db96c055228f08796c40d91228230654d2f6a604a49d7f6f3ae1cd73475a759a7d0fdea476b6000341128863ccdeedfd4f4883bbade86c5269603291fe47b7fc9b224a4b41970f6edbd5341e3295fe5b2f66ea807388978095e14a4015595e41fd6807329758590b92b41cb4c6918e9a97969467f4f2de8414a924104744949467ec3172537c31033a990ec7962619354f26773848aa08637e755774e79ca9d0e17c40efb052c0831597ebe3fd66081f8bb2daf3a681ca30079c35e693e28cb4878cb71cc2716962c839f830d81a09dc82c8c8e34fe745c98a3b280d9252939c869b06e3cf74b2a6caddc294829d95da3b696c1313b683250d49bcd0e39329c2f15df7531cb7801678fb52cad13106d78765d9554293e9ca323a3f1bf6b77bff706630317bf73bf679f24b43f6706823b349cc8b819678de4062e1bc96b907537e0c0c2f0782ae018bf9c4c7c2ac1f136d642003b7777fc6b9d1b755a5d6114f56c7bb18739ab9aeb1c13fb832ed21a7b550958e258b3d93a0faca35052baf42d95cc7696993e0bd498f1156960ba514d4a071a3dea35bf1d34d70589b3d7df203d2784c1b4e16d94cd762a0e8ad5ddf598062be56ff39fefb825a2e9a6fa70cd6d7db9605066499cc1b98600a09102943469cdadd1d6f2e6b69d337abf4f6ee84b568a94c73c37ab493b4a0f0fd1b1d2849c8d3c36fde6179dacf615d0d444d32432f6c614b900b5fa0440ea30243ef2d294ec34143527919883e34ecb5a7bde1b43f663e46b7944971076569338d815a13466c36f6c3f5e365d20423d7d9cb652d516b445a31725806f38f3455e6ac42372e93ab4b4e7fd04e31ea1c1a369f8e7ecbdf61a573be99676c97ddfc18cececba6796268ccd9992685d306ff9e14d67906d02577e13d1fe0a3f9ca5e4f0b0feacd3a02f89ebf437b41e7e94a77fced7e0b12e1427ce82d56df7d55c9a78388510bccd836ff8ceb64dde06503394dc9a967f9ab30728e3ab2331f4a569f953adfa5c3404676230a908fc31f2afb6942ede04198712de42e02eeddf48675d61dc0791a5b7b8a5b67caf1374cd940aa1e1ff6bfe509661dc2bb5d16309112c97ac8f7e8bae2ec80c01a4d11c85c1ef5ea5d27b8bdc526fa67d4c4e1bc0c77d7bd91af610462ce353cb131590de45788f4df6074521e0a4a8542c20aee8609eec21aba7ba31617788092aeebb247fcf5265a6db848184929404783e7df918304e67f2705e098138815a6fab4edb0f63af2ec45ce2a0d8433cda64884e487fafaeb7d9eb21be47d4dc464a1d6e0cfafe495e628a5011178913a108f392e8cead8870fd7df934c06980a6c610272fd91af07394f1b3f80e3666ef2ad07f81be7f3302d3a440c7e4f6e88412e502a1fa4078e2215870b38a08547d3dc6ded01c46bcb29d09e78c041e6d1e1dcbba807476561f1e35d5dd0833b90fecf9ce6a5e1670acfdcb16849186206a1b352fd53e670c81b1b95c900d617625c6f1f03231396d3c243efebfd39c7c9da1a873ee49671b61f9bad9854477dea7347c551aa882a673e35da7c8119f664f6dbaf232f7633a6a6f684edbc23ee989cab7f704480f0709b64aac40a1b2215c50d5036b9ef0ece2d659c430b39844422fdf92971308dd04a025c515ece8676a7aea3cabbb2b219f23406a60e9455beabf0b9206a0526f32277bccaacb23f44638d93e3ad6de672df07e756701f9b6a9d92d2a7d9fec88d85fbc5d29a7a1f616d3cee2dec98ce8e14c85b5c93897fbc167f70a9816d64bc9bd60174f84cde2b22ce4361df988147cd5310868782e84cb474e5c25956d682642eacff076cd85547648bf250e41eb9589a98ea47cc980dd44bbdf2b5ae39220e1950552a4374939cbe3cc5ace75b9c16789b4e96f08930e78b9487b48cb29cefdac23d7361db40c4b01d9f639e295827a71748737ce122c2714e7da06d48bed2258a5cd8a012672aa7a247a759649c219e33094bc1f994d0208fdad52a004c28826583a4350424fd192ff2330f3eda0493a23bca87ec15a394e98a261093713e62c55db3f9de51bca26b56485ee82a38276d76d3f81393709df40c7911193afb53729d3f7de6eaf43fedba5e88ee7f744f2422d6b4f76d48f30e0392d13c9b9a0f9e9688e621afe82b8d44522fc4dd29941f3a4f353f4b529ea903fe0d73ca83a2f0688aae73f878b9112203ea4145e7185c09fc40f508b11f63a3087a8861c0e49bc5eb979948f38687b718f28fb437c49d179e6e5e5f09b87df2112201add7e63bd989a6a30513f2504376f311e493fecf3c7583e827635d5ad30b1b15958e38db6784bbe542f82903af0832368354f2d9f9ae3f10008d2e97b7fa51dc034a67507c48a6f76f5168f5a1ce445c64cc251e80c5cadcbb6a85f413bbfe6dee308d25a956043f9920c175df4a29346c10d543d4b6cf15a289cdd922aa8dc3f0f36e6c45d61d0b864ba110546cd0a95a0b0d014d478926c66d3372c0baa375062973fe8e7fc738ddcba3b5774ea976ea0d8f629e11e6aa7428a6d9da1b49c7e8a5a9de9eb1ba28e07222ede1b1641de33361af909ec5886f7a28a9afc98be8c12ca1eaa2ec646b049a39ae90681f5b1e04a5b60fcfc5ff236abe42db02b22aae90ba21202d65b6dd417de9484d8da8be7238425760ce85482a592305805a6bdd901b4e13f3357d300e701710ee8ec096f0ace2d690f760e153a229e7fcf514a8f6ec7f7d78fcf4805b7966951088eeb532949c29689135e4eaf3c0f4dadef8af5abee186fb116a3b8ae35e88b277b8567f142a05c29bdcf27eb9a6c45d68a8fbbd71a888f53d6bfea078e62cda0148a3feacc14cc3d588d3949c92f41d43f62a94fbdcc910bbaecc28e48b16d01f0be9735537a81986b873ac8f8312edc87826b899db115f9be8fa9b335b87d53ffdce3a116cb2fe9e6e14214b19b5c803dd9044f3ccddd515134e41332ccf7dfdf02ad7a8734d21b0b8d72cbf6ce2a1d3ba82975019e89fcb7001a7b5156312bfbccdd7ff0117f25cf6a41621bd7f77b2b92bda22bef7e5c8815262776ee17036925650b102ad9d0fcac16343591b304f53bcde429a6dd696b00910791739781ec68be3a91ad633b48f74d0671b7c5787a2422251b4ac264278aceb7ac418dea122ac223d173d3981fa4a65fc7f9c362884105183bbd7d2d1517dc4dee5f07aed738fa40a50c162ce839ba12d65b44c627fd22ac02759a23b15150235fd8828729e465977be14c196ee8954fdb1c9a778edf53a65a8f1f496db045b5785054a4840cc0e0792e915e3d1d84cdcc8b8b62cc8ce73330bb14a40195c9288768326ea25978d5374e1d392e6c318ca7b68d308a18a099134800258ad79d18ff3714d123c4952390c76de12a563bcdbbd837b2542b5ada34cc5ef593abe376e397ac18c7a5757630c3583942abc424e7bc8a1a0c01e6b6e09fcfe01a491e61cb13522462773829390917209c4c82cb9aabd9f7e1fb65aa7464d132785e046ea133cc0a893028edeec7c95c753fd4e188d75a08fb53606d9e8363a6605c1c0cb6074b4143248860824b8ae2179fc02f08474bc6d8e2e314a79ae39c117580b04d48b83ee26fc76eba5b9bbe4097fdf57d6c34871ddc6d0b65d3d9ee4e6658035433986952ea171bdd628f989a6ab551734b1c2397c9eafba73ff610ebd05f1825c14a652f59d49305a5045d4fdbf53633d0208bb1b034ecb6805d26ed0dfc8fc27156d4ead93428f5d885fc6996437255e51e7e92ece77a29afcfb72d3f702120362775446b83b0e684b780c08ffcd2ea8260d652f2f9a6508d7a1d79b6e4db03349abee19dfba4378de6001a77df5ca6afbfcdc07bd7e112928919d314e99ded6a35ccd989c888fdccd93f8214ba945d223f0ac01a25269787dbb0aef7bdde5a23e86c1f0624ee93a6a047d7b62b219fe81bef29651dd5c350ca928f263202cb949ec69f40a381a93a0f435ceb62f86f2dd399556323ed589493e316d7ba2dc4e4728bfff9d8274b0857418e6276eabec112fd043d8301aba9b23a416baaa5a192a31709ffba8c93854074feed7119414d5be2d38ca847613cbb120e189b2abb90d52461da6ca0a4ba6b58e1c250d5c34dcddcd0a2a8b0a6757bc2588fac7f314dda1af014d47033fbd469532a64ac876c46ec0990b447542a5ded90498dd7a436be2eed8e2488299a74d471ddadf1ea87e4f7098de2ef1e95f1318260ae19c01c3f42ab60104e9e031df9891c9734b70fa6fc5c09149258eee47fca8ecf23c56a70e4ee0907b7b9cb25eeccc8274a84212ca66b122d467c27b3b91b8c67e5dc0650e66f692907ce45dc4ee26dd23631b252d9813f84777a085cfe49836e2b9431e3372df6071768595d186d559dc0a18686efba7833fdaabd0f6f9c3aa528457ada89d0d70b58dce01b12aeab85049c3cd52e6efe39459b752d5c65d1b873af2d122a998380effabab83d1ac8185bc5eb171c2ee51310fd81d931e93c043bb2f516e2f3827b64e66a47d5d0161141f971707e351c9dfca41d3b96776960fa09c2d28391fc27f2e91525b39eff56ae0136d71c4457415c0b846e264176b20eee561de6490635f25f22bb95e0b956d6bf17173c6469570c57dc0d7c0ddd99e71a14cb88364a7501d0aed2a03364906c9d797b18ef8b76fe1f11f68eda0e474477138e9a13986455101ae4a53b7e76f83371402b4197a4bbc88f4f3f9b80d5a626b6bfca97dbeb8bb41f904bd3eda93a610f36a0719ded93aead729ebb2a302dc043a3c4efa605aa301c239c424ec7c5fb3a22c5d6e9f0a8319a2982ca0a49c91b5962acfd3b81fe41a2316ee8ccbb223666e11abfdd15f077d9087510d2c2750d94a8f97f058bc0cccdd4b77f2f9b1740e28855bfc51d64555b77faf08ab2555a20d55c348efded8adfe9034305efe097b89640d56fc1ae455a308a7e30d0e3edd0590b55788d8ef69bee4e4b383a78c2e55fe4e7eeedb177547740798ca5809a45025b774c247b38957d2046edb49dd983d1799c4d9e18735d5d0f1c277dcfa8d333f8762f758bec7e2c776641e5fccf276db3a7a76c6d9439ed9bd6b71fa58feb450de326df8e6ed78ec81839ed499f787c50e21a2cc111f55e32affb2b3aa14f81ae0e6549fc0e050eaca1d0cc9595170c505890c446a2cfc3810fce870c58e209d9238c36dcce55941eec770774f42b5917b36f489e44325d4a3a248d411717b33b9b575a70574af86e6e2c320f1fe005fb9589875a02afee1d107d7c229b689b597eb77d45c1d41d1619df31e095fa4d4bf68e66ca222bc559664dbce7c7391d523d399f30fd96346c5202b4b346167a7104cf6db5ac211920df03dd7018742ef54f110d230c9207c42bc9ff4c77d5d3b4874f1b46d9f1bd67d05128003faf19e08a18897040861ae7de5fa54c6ef231c8cab33c5d240952a0ce5035cd02a7032fdf5499daa1b1da4b1609a3739b3e48b024a1fb20f75d8528cdcc348fe07537838acd16ffd5e47749fc007e6f545196201cc9694231a9a2efe6ae996ebbec687c3fcc3d23e4c1fa9bae72e9f5b57398cafe702bb1595cc73bf551bb95c9f2bdb6f5dfcaad90e20e01f0a40f4e176ce8a5210a2869b67cf294d8b516fa2ff4a7bf5055cf749a3b59784391bc36afd254ccecb6710a68ee1b4cbb482c5b101ce33c91018ddc5a1892fe817771f6fade56f4213467802dc85068fe1318e6fe73d862f239841ac0e9702ec7b265a967bce872bccf02f46e549f446ebfdab705394795720932d0f7d3fd4410c99368abff23aab5953d8dba5809ad4e21a20aabf9e8d986597acbaa32e4c581529f68389028f558108ffae5da8a875bf901ee8fd5e4949e9a4554d45d6574683fefbd85ad6ce3a75ecbd926fdb84cd93144d285f4f8abea75eaba5c78973b0a9282e2485fbd1335d7b4e63cf4b4afca0842a9277454ae85a10f9f7e40d32d778c0d6b5c326e4d655ca627f9486e9579fb130a33383f5cf84fc7040874d4eb5c436a66c6426ded006da947b1b59ac1765a449d60bb8d25944d996433f98773688d5226bfcc1fa91c9222254e266d2d2746f415da40d550aca24d4f796bd63f1956cb0498b03b19e5277c6cfecab54c45fa398a09c3d7cac95866285ffdca50790e41ccb0a655db720f2cb03e4cfc3ce29f57c1cf24e8ed650eae69409d664e304a5f7599060bd268a9e57a7955b397d5d060af3825920314aac42db50c409b79b100bf3fde08efbfbc9e43d41e024465e92c16ff51688ec9b20aad54f75b8b1a88d982540c629b4508f43978065751365b6ca38e84be4ec893ec0ce481a5e4fa396aab788b517696bb6cc5f74b55d239421013e2a082f5a9ba8ebf22583a91b980edbd4ba47a77d44fa7e52621def5007de27ea9efa8cf12af8ba0e207cfd3bf136d1afd6457b7dedccd4132828f5e94bf6a7c6af2a0b77b5350f06112c40fc3dd25cbf44da90e48394b1f7aa5581ed79ec137d54d823e8d6bbc8d727ef91557146112613535225b4b2b572bff79fe7ae34b52803a28258b9e1ae43302d6d0ccc07ef744816ae15a7e70bbdfcdefff7308d05b66fa9b9a33d77b4df9d163fefde6c24c7c057407c9956a7eaacbc4c49a7c00f7e576bc6cfe1aef9f80b9a20295f08a04c35c9928766650afaef97a4c93bc1598b7c7bf545d2ed0e986099d6c44e5d8d6457ce943edd771308d5cae00691c452ecc184a99b342d6f3150580176902116c51b869fd9a978bf199f99bcb53e7ddd07b0cd8262bfe1fb81ee1cea587773d98a9cc853e2018a7c4f718a77891b468dc87576d4e87a0a7090c6b087c071124ba6af4ae710e6f67f5ebd20a4bb19d93130549de1eff8a43e388ca51dcdacb3630946508edb3ce14696073d9911336223c2d506caf90ee8eb6f29731cec0ddd2f09a5f13bb9d7ed3975d65cb360ea540a6f06606e14d169ac73fb5cde87765ecb54913bac0e71a18ed1ebc4670cb05be52c5747a760bc91368b981ea8f5e885318b983f07efec691c862b0bde9898a2a6953497f679c5c45a0c7f5fe478b56d58ff93e7e1491a215b7f9436b6615e6499360b50a05b771782700ce5a0f2444230cbe2bf6f47b6a8692dd049c6e0946f7e29b93d2ecfcba1b1ccdd29e07bcc3feb297a0ac3d445435fd4c87b7f342e33d49bf2d538ce432b30c7b4f09a21d9d847263906d54bc861f53a82cd301eacd33e10756356b20819d561bbe33d4b3e5b7b6a93ee484382e30bcc4ea7f5bede4d27625c08742de9e88576bf239bfe0113764950f477da33d416b8386c3e01126dd81ee414627e82a21d5842a04e738f2ad23274ca91d1f99f8199c0e5639c74b09a6d528c3a477b16b04ba61cdaa22ee44f0dde2515646051b8d49f02c49bad112d1d582a4f111f41e6dd68b4e6fb7efb624a3720fea317f5bacf22f3499fb49b89f40a0b4f53d1f1839d75f6b5e95d1d34dd2d0f00acc50e63c237ccb85d037037e753d86fedb61ec5e8b40560ea8e15207f216f30523da86bfc4883f87fe5b51ef331a1a7fee7c0581051d70bb3038e228075ef380aea8333f5b08e23081c1533b9ee58d501538739d02e676e9d846510e057abb714e5ad6d195d3798c0bf8a8f21f6a5cfdff16565b6c4efa2846c3f56b27b786e7444f78280aec529290887c76c7873fff72c0643de4279e2bbc9623846631df786f0a6a61b258bb49852f81331e216dfdfd6f14ea40a15842ace836bcb672007429313aba631f8c13f7b7b6b7532708a4173d29604c7c0441fa0b34d1aae235f43827588fc0f19cbf0f00ea84a263386bd0fd41f09323a9f13624d2b98e0bcdb553c3fdada3bd6244b54d09d2b3bc93aac1195c21a83e214c870882c493df137b306b97585cb1beede405b5ce4f758ebae6746989f9d0136b09cd1aec76505f424031a7d59c8594155ace0c378fa5824ac9005154d51033f5ad159a0262e49bdd67846468993c475939c5dcb971221b65b1f992ff42b76b7600a232908d14a97632bf96ac2728cd21a8be77dd3091932a08325f522c9abf6bb5f7c2ef5c00adee22a93f4b73813711e40ca318f18c791a2420a7c4e97424f9af243d0baba9b50c689249c1b1b1e551d713a8ee5035a3f7519a7faaefc5ac26736aafa7a698ee295cf586e907709320bef5a014b98dd9466ea9ac607fe3c172d006b8d57a2df85b75a5a2c74f06f7f4eaf895b8dd9979b74cafecf7bb3bcfa9716e0bd60c65197a683e0ae3c4ea1dd4ed7b7f25afed91fca6eae9bc658c633a5e91e9616a09602f1e8f12f2b85b09fcc84561cbf45d61de33247ec242f1b531c3c9de89eec0cd5e1168b86ca4d1aea5aca49eb3c33acbb11a59df104c65f27cb38e6068aff8e7a5d117a19abfa7eccba87a3986981b11c7bdffcea7e456037c39eae767d708671a8530b053273346f1190b27958292f2803bea7edc8c75035113768335a9092891fa83bd8679a2f66202a7187284e1ab89f8fe12bbe33adf61ace08078d4ee799d2f8a5ddafee9f3eb34cfb3943faea71b7f3c2637b45b19b29e78879ae29660c24268712c76acb067032650deb9c54cfd20135cfbf8afa170bba008770d9fe9bf6df6328963bc906e65b5acb566a565c95793bf20b2afb8c867dd3361230a04a639aa9fb6931af0614ffabf3aaffb96dd38fde42b873035a262df8c6695bc2ac1e8fdb6d873dd55c2376710bbc651ddd00709a926fad0abc3397ccd1e7fbcf003de3a777e20ed29f09aae3a9af84e25541d7e48763dc684af66c1da640ce07318f80385b5aafb811ace478d5d98f8f8fbfaf81951857b725f683d6667ce479b7478fa5bf08e3c36bbe5b4100a5544f2848705dc6bb26749b9a92fdec030fc6fa3b96e20a0f677de0aaf18d2d080ed7d06682709ef8fffe0fdde908eeeab3fbef2d3a75e7c9073d979c678105f6c363918223138217269d5ce8aaa24e5d88a2991507752125ee04da1e29b40e08885fb75ee721986907d6f7a07c7bc4de197bdfe54d929d293be8bb3eb0950ad4ff7705c41411166887b341c0a40729a9ff7310b625301201b1e504fff8c3a7d9a21f7fdfa2c55ed5c84310e947c91a6fbac043d0cb0df760fcb6be33342774e02e56e962106cff786984da080c048486988a38c1adeeba8eff3a8ee07a5917f0b791598b6bef33950ad6b47922f7596bf2ed3ec01614fd52419e31a852aa75079811a41b5cafaca727f8df82cc13a9f1b0200f0a8538211a5874d80c15143786021f1b54b5783decc180e5fb2530b6336e11b172245381a1d733d63198ed1ed7a51648758bd634d10b0caa78128edeff5545e7794181c7d62fab1e6cd0117d1eb101cac726e8b88fe5d3c65ee80bd82b7a2e627e74ce20f8962200efd5b6ccec4bb01bcce877a5341240e9b87ecb4b0727b6007d9fe92020fb81e784336c66d0d44579d80d22e8710c0629db97dc8643fe7a6bb75a9fbe03a8c4b2446c3697e79ff4a81dd97cc84bbd9e4d1f22cab3c1b9e0b6e23bb903771edd6858990f9b28008219e07ee8094f945c7992752bb5dd567bc54a78718ea3219ab611ec1a06be7917dba5ebab089596b9054ae3efd7ceb192c140b118a5d4c7213720b8e4b0439fc1c6e391d667339465ffc3a7625987f00592be9dd6cb1313b67f01604f4b205fbf3e92565d0a0bf875469dd07f36752e479bf98849781eb56d7dcc7897e91968ad911545aa488d913f027ce97c4d64ad8311b7536adfa220794191733b79722b3caca50fab06fced946917f894b475a412499a8b4fe206ea4ba96abf51c0eac4d88878704d1b32b84cf38d2d4d43e0e507c5278c9085d5e32bf625a55fb9feef3d8e48731c535981b936036bdd59304848eb8b72539e8fd50b757f6508135b4dc80cda453db599df3840694081d8c74c3fc63eccc3d0e6ee5db1da60510977347a63368abb389c2342d3f0ec433d5d70e7259ff3e0e248192619716c8e2fa1797232481b0b3a3a40200d5aad9219988c9f40335ddeb5cd151f2dc67f349cb7d6f7701a6239e5439d3cd37ce657a3f2a6b18213febb02103df5bb075246f85301e6a3819053caf7876ca77960807b6b39cee59a3c89dc8eceb5aaf6b77f72dd40d47109c266dd7dc24746c5ff55fa875c7d93fe9e7d24edd420c881b9c5bac4b6f1d747a5527df35efd0a78289da90fff7fca9feb7f969b7058c4ff26dda95c2e00834b0c75c4e0fb3cbcff13486a386c39a5edbbddad0155428843d31e074523b96cd66040e63cfaa828d1f92d2f35459f10d31138c81b7b55b0d014be76b1e7c97f2dbf050db5305b1121d9abfb88901495a2be1c3e2dd9d9f46e9da147d70919f62670f5f997b870055cad6cdf0ddf5ee012e6921e81e9e5cda4ad7c03e098c6bee7b84f246c426e677a9f57e038734148f4053e1755272f7da8d2ab77a03cd93b8aa96504fddf456218216b08511510702cb882ab8a19ab16784b2c560b9e79acfcf5cbbab672955d231d27a6b471c0eab67a82e8edf21c499cf8e5f5173274051679d93d3bca95ca6446062e2fbb4d7ec2841b797e8dce0f43112ad6b2c89f1cedcc8de3d442f0e50389c455d68618538fbbdf00bcf976e4dd6727133cb3521478563cca5f8880facf0bed047800016dc59700569078bb3a1a434629beadb63812079c8e844b3fc7053d44b63b2ef8b381a21a678c6ad9e08723248edd1f0e42c7b17307ca1f312d110a5065ef7b0fa10a748cf831e7c5637111f851df57dc90e405ae99414fabd634272f36648d09a55f33f9ea538cbb1802dc6494be32b660e9d9988779e2acfe3b21a8f6e2f7d3423834b5b0a4b062a961e5ee643d09576213f78e2d9148319bc0d7a6c3cf67eef57e3cd2a164e81309fa7ca2c884112793a18925a207ae03c52c9f5a9e3b3a0499942b48292561f339a0805e8d2a71e542754d6c27ffa739643e805ea092dfa64ced014d17c4553e915b869184f6ed71849e19efb735eed340a595de320deb98573e3c2a9e90168d6c19240cef232fd828d4e6809e31aba8e38393cf86ae4786833626843a614fd192ef0b94a7d36b57886360a2dd501581c1235212edd3b0a6ad9c91f34f25969fd0db936096b20809ce52da92e350a87695bc258c49ab8f3297f7c369ec21d69c3bf5a785790e0db16bb561f3557d9e14e3f4a452e50b36fced1b5b17010cb8f8fb23ffb7ebf0a78ac1344a4970052213879bef8732ab69f1172378e9b6bd94e5136fb652e6634e09ab26429afe7156b8a7315bbef4031f2e6ed1f4f91030821a72b1243d29459e05a35771430e160cda8438b8ef1fb826b214fae1afb62e9422fc5d6536cca456263916007da448766eea0e2609db1fb616582707bc75221c6bf096642f44f45e8dde563e2aabc3b05e7d955f7f4ccdda1780c41053ca44b09cf034b755c30545de9c91d134caa2253d8fe9fb6b169e9d98a611dea5cd1cb7e2d8036c9463b85f198df9e0a01bba2d5728e32c492280331947fb87dff25610cded40f36c58400646365506470fd8729a0cf6e49f58888c7e149470540d6bf3bb91e776ad8b11c633fcb52f2de34dd06a36af09d601b326523b72d875728cc4e79fdafed4b7a9b229225f72fdfa7b046e3d7893fa93c3bbe798f6ac8463aac0a942269ac69c7d68cf2f305f596cb93a227f16f544a1d80024027a24d4b552921a73d811bcf4d645dfd4f94c3c5a41feceff29ce2f104ccb402de1648be82f2c9e974b49450eb4bdcd2f515d1da30ccf7dc64a11d4d1edd336e5fcafb79d18c3b9751c6cd2a11f39dbb1cf0694f1c9ca1f2ae05a4ead6cd8e1d64c265fa5efce7abdae31fcea41d3201486d16640d0e98cb8586379ed61e6ee33f62bf3617a66d62835769fc0a3b0a5276ebf8e42cc21f949761eca2f8ea0bc39f9c2746960ae8152f7cc0eb2ca4b3f78322027127f30c90ef968789be18114bfcab190cc9a26de0835c215fccdd84d8a60e53aa8cd737024a896777776aedd5a442cc90c07747ca6adfd991bb184876a433003356b00ea0a4b60b4a970938ee8ec5495c437b89ad1790db658629f7f6da03437d45de505337115cec08c4cb1876418e6de4a58dd3b90c5372a8f4b0a2cc9288da4ee6378fc3276fadf867134eed0dbaa22e1cfb0f9b5f1b6d381bb6fbab8c799bd245c1cc74e7b374fffac356e18e65de3d6541e6467524be83f9f768dab641f2a6f6ad313ba4eca9c23bc014a9f6cf95386daaa0a34443f0e3b3f7545e897a4db7b5fc43500c7c6bcd4411af40872569b9e787b218e822c73a61d1fdff561efa8193c02ef3c753a612f2fccfe35e87b4f1ba942a65f99b0c248a41bd00a66d3235de11d897174567304352f748c394edb7a57e4334ca0e929c96586fa1be0d040ca1bfaa2da5489282fb55a343ed1d8a24ecaf01908bc704a89fd498c0ac59ff43ddc708bb4b60ffd54c69a9ac457ff0641b0e107b431c2d94f4f169106c6ca18aa4aec37a7bf98e6a185aeec506e6f3cf31577ac1d1a382b6af19a4d3d6b56015c8ac1953ff4bee901dedc6732c9d6368008000a7ebc6e5495ce455090d800ffdb7af9c77a6cae7844ef7531bb1061ee6140df0824dbb5f7c35a6da23b3ebf648730e0c578c7abf90a3d42c8678d86fb1631c03b9df1e0cf131054ea227bf198cd1d8f35ed481e3052a99f2eafd3b7659ca1e27465ed7447d564496191142c65617594f8d0e529dd568d98a6a1dba841f10afbaa646cd687f77b662de4b857172c368fc4beb87183fb1a1aa55ac29fee48a238d763090a80220bf9e3fe8e8f83f735dd2b9e5fd94cadbbda47eee70d564d61bd20341c12483c8a2919bff9420592e19bb02b81b99fccc6eaa74a57173366798513dfd81933022b73a04ed0b52d792baba15fafa77e259ef42e192f0fbca1b5bb230fddb948c9aeeef764092b989142b5b6d2ecefae1bb5fc03403d32fe622c25c3cab8471a3a2e6b7a0d3e1698883c699910d338491036b5fa6e090eaeaf5768ab9b243504c74cb4dec9242dedc1315bbe0b70122cee685b4b5ab733a94920813fab36b018fc11dcd4e8eaeda5071134bbce302dc448e7bd2603f26cd0b5fe2d31dc19dcceab9a0eed2d1c0635a6f076f5ce6fc54371a72779244a07398ae86e7b74bc1fbc744b47d6f115264df94e1766b6c231ffca500a0f07e1b70443f2f5808665878ba7c9406d2d738d2c4d75671ba063defd905a5ab6f1b8dc760ea08e7d8848f95c32915ae467c21bd55bd728ad16c33a884070d4b64e1d55a23c6b1bacb75133812f1bfbeb7caf60510ed4991c9da50bdb124cb2bfefa763a0c955fc0971b9c8b7f33eacb2680b0807459fdeca45c1211d0d443943c7cd43ba5fc5509aa10ebcd14116f121718a1038c8c59d5456e966d2fbfc6654ebcb6698338f861c78a4ff2509abf743d1cee3df717a8ca20b021d5d9c7d3d9c648252a0d40417e7a73998afd7d32b00e07ba978abce71e509322f969f266be03d88d11effc8a78dc6a8936319ab3d86202e6a60b87d2f00ecc4b4b4decd69b8b95e8f32e8fbe3c4a82a4c1d906c7b5c891479caacd2f99ea786b37f89e1d1ad9f75900c805982ef2c6119ad2402cb360fc22cd224b5f23a2c51649652b4b9012fd9f170ec963f5820d30f668436a0fa10401d05cb0cdb26aa24821b5b5eee9c4602fa25b3aa16f84fa7a01d369453b011305b58f25bd2bddf45dda3a6a449ae1b10790d5ea8b9b67fe8069d8db04f2fc276ed3da6838c5f97f19201cd801e88de925250745952753393bccad88136e8cb41f50c267fa9ed793d670ec11029925a996375ccb5e2ca48410575e5b90996bf04a63b44554957d775ce5f3aaabbae3b260c2f3a5ab3f45dff55771cf1017c9d3bd7c4650720dd49c017b21a1f70c1f548c2533666e79ee2f27497c28d09bb8b4f93157d31996db1dd80527f5bba916414de763d1e9b07eee6a10dbc131f4758101d665efd1f9a4998868138b488480108c3d384e57b60286e315127e05f76506d076a90cb6ea951bc050e10c2ecabfa440c4348ff22260ffb8dd5071ac10736db1f664e39643874fa37654573611fbdfca57bdf529638ae336ede7d33220a09624763cff013512ca14","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
