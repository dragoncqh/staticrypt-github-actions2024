<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ef0fe392b2829c3eedcd618a6478d130a993db2e01d4a15b5ff4fb7f22e77ea43c24e0d83ac62dedd58466ac0ef5d09e0f503777d9d63c7903d9722b0b01680963a24b92fec721b646f9bdfc1907313ab46d001ac8565c5ffb9ecef1a2ab05b7db237f55ae1f750f75686f6aa75a2e4564f630b2f2c9a69293a516f9d102dd520dca92b45a4faa27b72151ec81c61db256c49dccdf0dcb769041143126e3b07e1e70b7df55b6a1dd96fff62ed62f122a76ba0ef52644ad5c3a0ff581e6b211891b58571ca8cdbdca996aaa71d37ac5c03dba45011102c2985883e7b3baaa90cd6b640656472fb73d83cb6f2f0c2926417a30a244fb3632b1bb896f188c72f76fc7e9dddf69c7a386b12993d570769151e6c10d5874b32cc7b14913c44de3a7de2e050ae1b0e0ab0c810bdd5c674cf97f68d8b06aa92a5c831d3e6ecfff7c5f083e5ccc65c3de52e545a92f1226a0340af16dfca117d4f73de0f9476174c1532b70270c55102f34348f32d25eb67f8a47e97a074f287e20398a64fec40bff4592d30e3337db66eb9035e1ca432dedc1ff0998c27f67dd8f7c01fed7e85f01853180f9265556ab7256babec03045d38fee1902c984ca6b45106a60eeaf9ed8a494856d6125e8d09039d1ac416d0c4746f7505708007ae28a187846990da9b56f62f590410ca51960937f25f48e08af6467c07343f86f2b09f9ef4b2e3a2aecd4ee2cda5b619dad9241deb54d97e76ebcbf70e0d6b7213a33955970fc5623b09b05ac0ff193092ff192f1d7d5d061c9cda3cab58c4cba8d405e65ba9571aeba05b03f17fd188fc55405f213662988e60e2813461957c97cdc2af96a18f945e05856e5e3b93f774b21c873265f12cd3c00568dad43264cdd614c9c94323d3358dce41034acf975040e5b794747ffbe10feb247991c9e34e57a64cc2689834c870868735b8a5c3dd14cd77f3aa1e63d331ee47be65f708282b04191f8ef4880313989dbb2915b087066ba60c50953f8fa5f1c7db72e2f4e235aa10cb62af4d2bb23c91622d1587dce446521c79ac2ad02ab8cc35d7b3fd89af40c718bada5ab61f0433c0974de924ece8120f1a80e4434fa82317798cfbc3f024266221351e226fd421acff4c0379d8e3c429466216f8f9c111d2574c3dd578f86dc0ab06e3ebe8a4b752e8a54bbfd4aa4b17679c4da7c561eab11caa3704a562e7a5a09cc7d523c6097747b34bafc780e056f06beeb5c17921a7ce5129e48bdcf77e5de571fbbde65cee17ed9b44ba57959c6a05937a2e6289efa70474e9d19c4a10b9aae78b96529be1bd4f7215cff88345368dd0c812d84a3648e8a90fcfb187172102522059dbebef6533267bf3079d5542eb59768586ae6661c00a72a74c11842a65a20baa0b7a1dcb581a473332e793628237073858ef2fcb8865ef08513e8cf8c174457f454f7f20851cf3a77cc30cdd4a5cf2512f5dcc3394f66f10bf9c713b9b3ff4c3ad05602bc7650267ded47ce2d15735e1eb6975ac7ca1832c04b675b5f286c2e3a9e5e63a31d408f8fc55814c70a767725cd667233c800d21492ae4a90925cac23942dc3132295eb6ffd0f31cf79f85f3192716c98aa811ee3ceb8b18608b5797dfadf1a8eaa064cc7b3ae6f563e36fa45b486778d9fecdd8cfeb18c454021fd8cd97a2958c3e33de1bd6d78284d2ea8024f0b532c6313cdcde9ac87a3489c836e4762021645fa0b996c1935914ff6a010684e39d152e05f782c4b9d551026026ca5474ab207a0cfe72f2a96f89a16ce4cf1f10d441365ab3963aaf527cdbdffd19686001b128822bf4155e600876518e931e029787beb6183912218bb8f6051e0cc380d3620177f710b55a0e0c59722742d8e730a8e2a9f397ce637ad89e13e41b02b8ad44c40019fe3683d9724e1338fba51ade992100183945a60d67baaf29b058dc44396d84e85d90ea29c7b258eb623f9c099d83b38b735bf8eabb2c0905c5de4de11746a4c288adbd26859cc849a5f5fa4af6276f5e7bf07c3fda682c7448769cdbca461c496c58e797cb1d10e683bacb349d1eb9290aaa027e0ebb41b57d91d213e416707dca9fecafd65aa193022d5e9e7ef06c0d3b51759b1e23a78499f9934714e9b4637dfa4df06a9798d8cd077cd029dd0e4bf5a25197119566fbecd914d4c15f12e6478788ff790da3154ece45e5917d9ab9b9ea3619c1827a9e26a805dd83af2ae738100886f3c48d7b61f10c495d80687cb7903ec65b11101864dc84a5100f77ec79cff296293c9da164681962cab1c09c40bd1c0add819f764489530bd062ee9f80718642be9c9011ed2b71bd142f188deb605c01c89790ce5f117836cae7f676ee36463012a27d70ed992794ddf94af6729d684a112fdbbd30e0f1896ee6b403c7b323171a35c33fb78553d2e7f6033eb4bbea858fd6140aa09ac552d542f3dac52c43671349d9c2b3e2700be9bbd5e2f1287db9871943cdc466b10be1b25b81c1e68c8b6c928cd9e3199ce26d96757fecec23c0b7cf2e6f10f26f4a055b605b7042a2a3108e58e85de858c4c4324ab25d6c1ae0e2744c85ccfc9d203dfc56cc3902e43fc8efe5a30a5c64777e9ccfc5c8a85eb83e3954c9c87699f9d70258ca13a2d80293f534ceb95e5f8047f568fefcc93bb898365a7b99e880db833387789749224b8b60ad8b80054e1351cd539e40d62af5614d34334dd496a26baaf4e84fb67cb076bb4ca1e4493536537a35b3b6b784839b2e477c602dd96a0b74ad2a722a15073bf25a7402fa78f162e0812372618337ef8b3a7a75a251a670f344a0c776899d8079d3e24b75d8388c02663bee85a8cbe19eb1765187e942621549df4cb914c6aab4aba7714325e4c1be6c6602f3336cd1121d5c613d9dc2aac05ef90824fe129de9d79fbca8289ef9b329e7269f63e7980084e0a5aa18ce091e97465fbd814967f15323ec1b65933321832c5d49e60405218a5ea1a8081df7bed47f3c867393c451ec02d11da53c8e6b03c7fbf3d44236024a044ca8b3fa2cbf33e50af3125d57f9f81949a0b8ffde7d63068f49ce980b9591e8ab02fcaf8dd98554af92d95f6b94e7d99731a2b51aed7676b15ed8292d17c4d1165b049365cc4f50305e135c6fc368f1dd88946ed8837905274189b812e4efeca9ada7cbbf723eb3de80d71e12aff2e6363329f3963bf1b2d65962df2947bece1cb0d8f55cc9918fd3cdd9ccc16f02037130fe91d16976a8b33c70fd89bec5c01de7c1dcef0bae3a0a99956618b4767e64b8a4a33f3233606f695b86c4d1876a7dee0fcd1f1c4221b853d835fbc28242dd97d38359f5fe76ccc536408c6b83dd2c536c42d2376dc2a682ba75a709a6402590e28d1d5e6da179eb826469fdbab3112562e072826c752612bafc12b248fe6d1f721334e55220bdc23c7daa205c204ddf0004f5afd368f43e9935c88ed5ea2e4b3199f7d22879115a575af7f5e65a11d84c90c8a10a983b74d0f3a2d46a637cda3e6144f0774a969ecb45aaad8d17da69f66649a0de6e030796cecd1394b0c6a2c7c8246227dea10d971450cbfdd6edd40c5aaf1166d24e052abbcb4371d339b75d59a469e643a883f0ddc634272bc963bed1186b70b4939a0b1b3f5376ff8639e4b9f900095a33a7ec4875f3022e1e95ace2a666a28e0920f0788b912c0007c9d1d3b2f18eb855f1f4166a304c6ddd69d297e6e0a4e82ebf95c829a481c30cdf3949f3085e196600e3737bf94ce99a5fae5d25d13bd79f2a8ff0c0022afb442429ad8db27dfd7382951059058b4f88d37300faca53d2d83f64b3bf56f669b8d4b971197e550614592f8b33de146e60dcb37d3146dbcecdadede4ad3663079c3df7218b8278b6e978eb51616cba0632e63cbd06250517bfd45d03b03bc8953f47ae7d29d9cf6caa46511833fb0cd5f66bffdabbdc42abbc8ae757161787f1ee87e13041fd920a0a78f31928f70edc48682704370b91b4f87cf8649d20a12f68a1dce48e8146763f39631bacd3a5608590c2945f07b1f0dc4599861d25913fb4fee3aa53431f8a1fd700ea484db56d3809a04c6a16c57ef56f02057c95f3888c08dbacb52a0b1b6585c8cb3c038a0a1922fe93278fa00e1e6b870754a48155c90a19221569328b0d017dbd12bc75b8830e0d6544db1dfb794f698254507071123e2e35d0a9f81b36e10c9a4bdf17975fe1a83141a3fc0077d0d79b0b365c27a4578a28286b18a072f0969a5fcdf09d886124bce07bf6604dba21413719c28eec7647525c21adc70dddbaaae255d1d38a2879e1bea0915e22c2ed6f3c71813e1b355403d0a5540846353cc65b34a83fa80b73e5db2e53835b0a49314826c27c1573644af900747cfcd2d1dc755c52f3b0a22f396a9169e013c2574ad780b8ea56ea39bc65ca49379ea51f123f36f1e8133d518d8094ce66ee604426e278bed77d0045bdfdc09074147db1ed5f7bbfb5f465e1379488ca216795be6058ce10562966fa6c212caccf1ab12f954824bf92f47a9173c23e5dda93405d0630f94ec8666be74ae869af8ddde6ae18c95b77dc22941f963fca5d7a859ab737a2066b8de0096c2fb25bb8b81e070ccdfafe2d2e2defc4fd251fda145a06a89017b5e8da5a2027384becf47b9607d4308ecd413f7e3473a9f40389deab9cbf50ee48e33d3a5cbda365e42d6101cdb52eb66fdfe8f46f3800590d5ce26689e769e9024508e7944a91ceb5b7ac6602ab17f2cb8f1e40493fa6403052e7a391fe4787e1df4680c42b3a94d9e581cadd37cd1dabf586a67d19719d1e45f6fda6304b34e69926cc0e131c4e815a2ab5bd0623cb41805630d3c707fee1f2f40d63ca682d99b3690ebb4c8d1b45ab8a04ef417bbdefeb7d773d44194e86ae05f84616006ad7dde3e2f0fd5ec91455004eb686ae702a0bd36108852cebe96aeae434378421f0bc0d588bb1b5eb24a301c1453c1e29f716e03ac93f9117d4bbf440a6cbf04b50bc023fd2def279b41871cebf1ab2050fbefed9d1ee9a13c54b4014a547c9a23bd8dc930d4c30f8dad0969cd384eac4443fd43380dc20c26b394078536670f3724284c35da444c82da5dba3083a707c28ee9d30a39b9fd42f1a9f82ee64dfe347f7007e14fe1cf69270f960f2ad49cf1c38cdc1e2eb75f51fc84512974cd1d3797795e1dc10ca40c581eca811461bc19cb1bd91e588ab94f4286051a6634aa64cb9f9c4e6873a6536468b459b0693376e221f444c75637cdd9c6cd2b95d10b50dd388f7fd9dcc21fd40e657c45809afd761b654801d04cac32e41ad1880ee2f5fb4a9474d8f6149fdc23dec64a6d60d3c56c9f595c82216240425b66f59dfeafd6ff9065930407cf8b5f7e7da511f6c562eebc630ad2aa45f503eb0f07473cddddd2183a4b1ab8286e910c449d16518cced5a4395d354932f4e855817affaabfe2d1979eb8ce0615aa3dbbd3e8fcdac9e48f048ee9500aa6c3a72432429518c9e40323b2cdf1d384d3e98611b86877d817aa49a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
