<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c931ca7c2d1c57677c18ef3e01285b69708a98f514505901fabf77ecdbdc0ac6314ac1ed028412b97b57d75b5ed4fc984c464db904a5c4201283c0c52976a9429a6305900ba964a4c485a801156425a4fe0681b1b7d0f2172167417c1e304525decc99bd8bf60caefa5d5e75033b85b38df3f769573960906b39d2164a61e2ead773307f0a45a0b664e470eb84c3bfe9a5220c4793bb047f548505294a9500d01a16360474803b74c1d3bef84c5b9183927bec09ce09c4b1bc64effd47bf6ec7dc01d3e6107298e220016c1919ef09b7feaacea3b683e35c0672c4e34a20ed4f5f4705eaa3baad1bf3ec96dc3f42da0f8c609d14db2c82754ae9c57683c441d0e62efa78f43a885f15baecac1365354d5e463cdf488241bbf337a12f8a70ae1f3ef4769bc94c183e860b26e04832ed3ddeedc6004939f683097da1fb4437892afa6c60a5827242d37ad1f5a397d483dfa56d98b9b54b604b96de960257dac7163de057263e1ef0b8e1e6f0f4a055a31f93ca8010d045d5c7fe6505242e5f233ee0080b02eced0fe46b7fa69cd4998f78a65946fe82e4979c24d697ff4cbe2ced6e55c99c64e48fc87cf2c3846966469f57a36adac9ee2a6b949370a04acba87fc41c8b250481d1d1cd30b2a010f5a16ef63e118d1abde19e5e1efd10c6fc10171be517c8a3c572b1745bf34fb04a4f491153e0d0cb236304036d28d7aaa89944717813dd45cd0b7df1aea9af3dd16a7396955a62b1fe62c3bc6c3c3cdc2655270e381b1aad338a001dbb7558e74a459e38e47144b3a347a3575231aba58f18e7992cf74c11427cacc552c43bdcb09d467191a55259cff6b2e7dd279b0fe474b3b7922c1ba245e0bc8957345b581c4460103cf37e43eac6017f141cf76c2241d5f8bbe62672b6360d80601a2de6058060c9268fd89525e84be3d85c3372bebf74418a0b5d654f45673b0fdf198d34ac5a0d25a14d897c2fbcc6fc5c26efed09c4b5ad68bceab714da302d51e1a0db6d55e19014d6d94ff94e38538859a59152d01d8f847235cee264a50b7c5b9e794b97028dd4af1ba2437656f6ebbb2053fa288700104b2c2648ca7529d8f27fa89ef35e4acdb59d048f4b96d479636afdefd006e6ffa77bcfe5abf181bfa16be50f6f69e733ef940412934e260fdaa43c11731ed6e9de3a5dbfcdecdd13d36f6176a1ac1b3afb6fb1e4eb79cedfaba0a9fe6a466bbae5f2b207779a280a61b30d107b5efb789d82ab0af3f8f2fc27c40ec92e438b4e2bd35355346ae828b387151fe17e620d5fd7c5e1c6a23a06b856144a8cabf72c2a2bb97afe3944ce05dbd121949a9d1ec46ccc525884e8f39a6ebbaba90badd03dc3be956c3c12ff5f7efad248326ac18152d2ba6bb511b409e06b9d0ee84b398f4d9dd00eb25e54e334837bcab961bea31c4879e4af7ecff52f9b4c9c61d8b85af270ee6cdc8541029177b32959a878969045c004813d97f281753f90212d92d42fffb34cf0878f748a5205e93469bcae8353cc38f5b361fa3661de240b139146a902e921f30995cad64c2d15a83ce31093e55c4f88a11f5fe53ee62254deb75434b6dbed11c47389cdc1249600468e24067b8d2c8a7892a672185e78893e8e1a07b1b25920a8020c687ef3a28f7a72723823c0840309161bca48ff73f2263c38451cb1247a0e475659fdc2c9f9533a463af3e11e70da060e04ae94e51bfa4bc1f429db0924a08520f1d5c113ad01e684afa31fa7adb9b3b7b08d2b069a19eb3f8bc362817469241fb12a90704949657cad9993df8cb057af01d023f94fb913f7aba594a0ea04c8f6054b8499ca0a3f36e1942d5832c0c5439322561cc13a9e88bed2c74c338789791e6e5212e5d3524eb932a19e7935c9f7bbeb5d590ec0cdc062d4b5a835e4c7d4f56b98ea8876cf104f2a3c64e676396112a1d0f9b1a68606ef13aaae82bb540f6779106f4576e15686c447eaa3592647d994571b613b6b7222b32f39251963a74595f842b56e379432c5f0356bcb4a920a4f0994d8a3565418f071be5b5103fc83d7121f797b7092d00bd56d0085ba1776a591ecec7221624564343e50a78ad4922db97dc6a3fe2d013f711743cc4058bf2f35d96f1f9faa5448061a35458d670b620104531b67fc72e789a957b6dbc2ddd4c88e8f6b41bda8fc8d183ab5fb66076d7fc99f79dd65941d6c28528c14c8e519e622744edc76765bcc509d7fca0ce4e2785366f74588eb633e3e48a8679ed8235f30cbd2025ef84a42982e46948ca9142f3486f783713fcd65732d139004dc156451750b4eca618d982bad07ce39969771645a25e123defcfc557acd287111aefb91f12e1ffcf9b8bca3a42caca69fcf3f83916178ee9d1efd86f751c0a70c9b833e6b8a32ffadc3a28bfb4c1206432d59a4af3129b2de50187e13ab1e0e0ab4cef01b05a33fa4d28535516a0d6c29771a0d56a5a6b81cf62a1a7ce61356a7b22bd9c9269f7af0aae9425f31f78517b6e0cd2685535b8e7c6502cf974b7ff6fc1f6cf9087775b2f4370037ddea7698b857117d41fbfe1148640443a1fb0601d9f920cb04e3372a1220a559fb8f5e86031de72abc8d6faa47329f34703cc87e28e3b617dafcb6d11989ab7f6502595207eee38bd6b116e816252fc675391b24dd19f3e9001a6b0d1b953bb69d2158de694454cbb7b7f1d6791c801205910e9df7bee9f515fdd7c622846e988d577974b5137b360a490b4f7f632e4a74cb5635a3fa8055e4625f4983195855e25355f8d1aae75ccfc93d3080aa182b063deec3a2c959a06f64bac301dff934783d02567cf9721902080efa3550b0eb1f3d3f5d460185aa276488bd449259b4de94e4016784e0ca53cec8fda9955e6e878018bec509a4b2eceba8b6c58c4eff4f96ff502a42963308e960776b64344a07f17804fa688563443d24f8830534f2cae853a567052b34879b807245b1a47b3efdec9369094d5c46252c4a91c44264784b3e6aeab8b62344d0c17bda730129a208ed106f7cbcec4d17cc87a826a7af72b9588a005ef89daf7bd59f1aec7152079a473598d9bc5be5f34a5a57db87f7e713689848f83506586c7f3bb30c77f915d85a1e44fe8db0a78320cd2428aa986618e76dd1041e6aa12d33ba2dee524f15ba6633a075aee1386df14d1a599a98fe30a514e77d389e6dcaed24b743588882e46eb317e0850a93060fb756f4d11b81bd2ebeea74ad33a5704b0a34c82afadbf7a79d6f8f564ffe8aec2d63f08765993b0b96062a56150b41c8682c526c0bc0fe633a16314dfeb793eed480eaa0cb6aeb1abbf9a4425a6e82fc1c7d5be51b7d1350a3b34faca30afb9499da4b0414450399b3698d4ab66dae88e128fec85d43664d6ecc1051f101c077347fce77031b7f522f29ba01b17d3763ccbe196b6c27b751a1b7134e7e5829d0c6f26de972a74f919aa75338eee2ceb4a68cd20b4cfb6f9e5224dfeaf138db1a5ad5d5da9f6844f6aad7de8c5b400f0b4cce672b0f4281a0fddebfa5add260ae3db7b95c6c0890fc30b2b61da434cc3ed4a73b1ed218c328423a805bfcf06fa480cf3d15d1eacfe0485fca8112c6deec5304ce335fe2d4fdae46ea1704e4af6aaef60d1e425607075e102a7dd99d78b0e82f86989a43f8342a08370527d17f32cff5e37704d59e19d108bd918d2c293260f05413ec9c7c66324aa9f2642ea5f44a599983cfb4b2e93b47b2440c02785edea679f30e9ebe6b7f2835ea0e83aad70c2914d09bac3d02f425913268b67b4cef243110febffb336b81caa566e561a785e6fc1dedac38eebf0dc2e6458e21928f85d7986e98fc4cf88a87157632c7ff44745b69d0ab43a4aff779aaeac0c374792f0ea1baf3d6e9349165fb54692f7beb976846303e1378321afb0d998bf2639f9e9476b19cf1e4b821248918e90091f03624d4e0d35507ea1437fd29d6366939be2efe39cb04c847779755b72b2ddd1f4ebd8896ff99f417fd2be11676293cba904e1a28ba7c6c3626e3b06732631cf6a1c7ebc68f21f38b5445afeb8e8461e06ab4cd445b53a8ef6b6ede847ee3e755b9f87921e2b93799ff69a058ace4d7f2d0c8f90275b87bcde5df856e52a374962163e61fc8d4a92a1acd59d423bcc58336c26e7646dbac24d1ed6553ab4b4055cac60ac1a48740e576e4cbb6ea551626d7752bc1ac483df82917613d210e2629021cdcfb06ee41991159674c288ee0873b847bae38257833c1ec1eb04a9fa003c467b3a1e4b446cfba43efc281591203a610d32693cfd37371ecceb8da3c0d22a891d83b57bcdf082b05849ba6243505f16e08038b77b2bbda3e842889baf8ed1768adc34af2528bfdf80fd515fe04d9b98cd6744dc588008b47039e58d6259c265c062830402bb184059ed4a7f50cf113f8092e942d7dfb47a53c32c6de2391819436f28ec93c8407f5c0beb937410960fd756250a2b3f849bb2e9e845309ba8587e16ce84b30d709b11b2bb5d23a2ac8c6405d5add0ceefeae7c78eb999cab37b4fb68981c431eb72fd2e990d108ac2d46e84db2670da4d1f9eef28cf81dcafd795de1bac9e287749cd7aac1fe9b9d584e26a1b05005ea8d2ae53239eb729206a6bc600ffaef0dcca8a70916af01a619f3ba7c433b725a6cfbb3d3d1078d02ff6b157176ae65c3634936d57bd3f4a930dac509d7579b114a409b314846b1c6060e2303a9135769d44b85514a89c9e9d888aff90288f586e14866a52283d2b4ad93b2d35971ba59eb7e86aaa9bf76d241409b1881e6fc7aa81cf65abf89596e5bff1c9189c203c16de266619a6ed2c9f8a07153633178e8299125e48ddfef34ef9c72578b73adf368e601ab380c9e3e55ffd8fcc63441e14ee0ea143eb59abc19a2fa97cefc2677ce93e87d864e8316b4e7f7ab30042bcb2b36428c3c9191eebf8aaa71a0b098535ecac498fe06c5d1cb43df323f0cf2356aa017e08fb10d171b994225200005b81a213a3f929a2db4c3c58f13d8d8f67e04bf73d5d2efa03a2887842a969e588804c93a32a706de6867e5dad6f78f886866d219ed6b51900c74b2c61bb154a914b63edca2261e1c0c89e9157311375fc1f40f444c452620038ed08713ca52f220b1e78501809904bc4076bf7c878feed1145bf58e6d8ad76190a334eee0708366626ea04e0fb97732d6d0a63eede40c963a903d828309728670fb51134f5bb61005f90057ae180cd5681465633d751a4415c6f457323942aa4d1fa1e9088b3d724d6676e4cbd5f88fec6253a7d927ebf3f5113133c361f1115e9c399d1555f7faa1243d3bcf7fd258044fcdfbc638bf3e6dcda6c6a4193f4b482cc9af3ac9e7c5d5c7fdc29a9e332cb2526de34486dd8c3af8603e6b43ac1c301630de1e6c2a6b1cdce5dc4ccc2e6d21b84868b69df691ae0f33656bb58f9499b05359cf41c0496370c1ec281577f39cd1e8777e062550d162e48c884af6985c4e3ac6a8419f4648928684abcf37f6b26b88d7cfd2b073ffd3512b158b0ffa7de9c39fb42cfee5249dbb7d865696c245b6b4a807c52abde0ba81aef5358f69b58edaa5f3b50e59314974554e036b553d4ff3f3b2b849752badd8debc2295a652add416e823dcd5aab7345e2e4e4ab01e75f4ef222b28d54cb74ce281d4a011abb75ad75caac76545e2ce1698514a7b7939f077aaaf790c46662d0767e4b0b3973b814f0acfc26be742a6aa6c26f6d0ad81b0096cf1f2699f5a492af4e9594762febcc2d00a87393e5074d95cccde7bbab304b5a2ff1051404e65f892ab25f3a3436b060c6d79242aca306d7ef2d1a68052d7afdaf44178ca3b610cde16b60f835c95de9e4be893d5d73f67b8be2bd2452709f1ef5048d2ec6a49f29cf5705fc21d5e9f11fec35add2eb39826373dc5d2a54a11f698337b8fc593ccbf0088763a6a764a978a745d04f83f70bfbdce7139a98143eb8526703e257339d04dc87ac6c0409315acb2d11cd92c6fb61b68d5596f674a292d12a728bcb501b9cf915ee152e033115739f4af4243f1833e2291e61f379d6c8cda05f661255fa5f586fe3d4c0c39dac7f18af5424508502f7c761ba5d1c59ddd4048e3374d6f3b70e84dac49391731c59db3b0868c5466c6c577cc0f019aef9aa71e0798d9e22dac9f100fa8fd7637d4ab42dde389311cd557d8674c553370b92d8215138b51e366fc75bd3d6b95ccd4747556471214d400b1dfe74173075983e274ce49a785d97c1f9e5887925ffa7b537f2e24a6f1c4e85746e514ce2950f6e87c1c2745bcf41aaf0358d68ffd0e2476913859c983ad509db6feb86defd5cbbbe19cd12b7ed20ce098d0ef106f931e6c90405be0451ddf0ac954716f234485ba314f311cf573eb64dcad96c2bb035f0083876cc0739c3def90560781fdf89403871c95861eef1e976f244949d0533ea71af0b5cf3329e175934c8e3d16decdada3a6dbc7e60fdac72436533db07555eec2de1add5832f1cc2add9e1611b1bafbe01d16fab4288235c88620d994a2546ad85ab563b215bfe70108e8396acc3145f136a5005c66f0bbdfbb9a8deba7442bd1c15bc38fa7283cd660f2cce54b94dcdff1316f3b1f902456034993704bec2bf7cbf7c2a09090d7200edcda16787edceb03a7438403a06d31afa3302248c01d284aa3ab971c456f2edb12d31127f5ba50d92e8e528929832fee6b098fd2606c693ce061225e5b0a0a4eb451991e7ab4b17b93ebbd0c1bfabdbbb4173a9901eac01abb7bc25e52918b5953d5ecffafdf825811920fcb06cf9d361b18dfab819e5957abb3908d1c0247471f9060c0ed621013fdeb77c288a1148b8f1b5388b2a06185cbe5694c062806ac847b763b3f591bbe65b273ca7ba4de72e475cefa1182bd14d0c0da90ba3144feb24d0c5a54d7cfd178d638034c1d1356077c46f66653aeb7032a83bf4dcbe13efc3269d15d0922464c600302eb0cd63488ae6d3a586d76f3905660082ea593dc64fa37d452bd38b3915952e77634ae9828da8c53ec22017b8cb471c210760f1501fed2ba9d1c7a15532650d4882b3a729f31d444fe483d2716dc76fbc3c802fec65c8ce5961bfa11354b1a240580740ef1f93bf27ba3ba68048fe49bf901bef430164dfd101691fadc9eb90c2c1cd700f81cf0242416b5ca91e42d998fbb48f3eadabd3f0c8538c157117077e5176448da72e8a41ae3c5a141437e1b51353e7447fc24d1dcab4138194ba6e7cfc08b09a90aa4d9b87633d949e3c7aa271014044adc9ffa211998bec79011dc0a8b2f4b40ac5e299f36a9872072a12f5afaa127afa6a34a65f09975d4fa2bdb05e6cac7d58917a0e5906709775c65cf2904049571f4b48582565a3c525a6c25418c0b56d8051eed02ef480b85433dc170053cb75c7fafad921a48d8f5b312102dc0bec484aea0d46c37f7c457cb035034a8c4667b53a8421c2d2e94a33723b62b74aa3695e1ad59af8ff26cf5c474ee69c3dceb64123853020a5153386b1d81e540c1b7316bfb84608a48d24098baef3ad4c736873d9505e1c3a480ad4edf8c1a59b76050dde408ad822fc88df285658ddbf60411ef69e1219814cdc9a1ada202b1627269b7db04f67878a5b30313e631041af67ca93960db14586de8db39f6e91aa75610fc64ee2aa12786cc88326d0bb35cd77b3ff65b58e66b932e0d03491aa0777360e91cc1471dea8d3a90d01473cc6617047640bba9508257d33cc330878624d9e5e5d22809a6f23d121d842ac4c1c3fce9417c1325c916f5b5daa3e352dd0fb463c1825b2e3271c16b26af82a2a3ad7a18cab75fd0a9e30a5316beb0232443b6a9068f4b2e4b8222c78312578bdbfa862597d81ef3991d4ef72b4ebfc820d6a87e234ca48feaaad0fb9d3de2defb03772e3af9e67231e9cb639fb378b7e6dd02c3202f7057f319c01d6f37dedfec78db4fe06c4c635aeb98b6f93e3395aa1939fae1967800ed96bec7f871b3b1f7851eecd7fc08873921ec564ba1b0d7fc496f9135dd4ab7812cd32fc32dc1aa15dc73dff2c2997e0aa9b1c3df13b23fe7324c09eacd25622852ad7a2783804d86f60a374698902295c3deda3cb3763f08d15b0ebacaae09beca9e2eed33d6ec16443c4c7e83f346d5c33686618da909901a00d2e65ccd0875b7ce61145987d6736207ddcd498c79a4ef12f135b18d669555ccd9d12857fe4854bdce64e8d6129425ffc14b992da912bae8819b5a652eed7d7333dd73fda52953eee88e51e6881d2815b56fc151f698d44655aea4559fc908c0baf96596674294ffeec7e32f311bfd5c32441b3fce93e7371e7b09d23b24284c1df8f52d0abc0875d9b63d1a023603e04d56317b4cfdbea14162f8990198ba1bdc6c7b95e7c0a7ead57f641befd8ec879adabbb44d9ca030eac88cc45fcc394f426a89eac2ee0089cef1a205cc86615a219808d79508d3e9a16416b17f8c0a6bc5fd0b7220fd97fd7ca8e963dc71219d4f67f2d132c98a2d966c2ddabbbdd248dc19bbe1b7844a7972428d062f9374578a6185a23fbae63c7cd66c36c408c1ed2746000a6ff5d75e54d732177e5c2e47f3f09387049f27a4e273ad7387623710491fce1de297fe17d36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
