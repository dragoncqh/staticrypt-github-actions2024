<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa66dc7f96dd6456ae41b843069a00b86a496e6d088938d42e3c29043884c8472138512cf14212efbb8b18142120489e99a13d29636f09496100b7a41ee51ecd91b2a077bd694a64ab8bf7375b8ed798433a05a6f81a29e93fdc412afc0dfff6c2cfe1b44ccee80bebe8f7c319d7c060e62bd537c1c83d2addaf1144f16df9c34a9a925ef669483d63befdcb49c685abb20cb91953c6db44301f8d702a94da85748752870b56df94e3d8edc31e41bc059a82f154d8246aeb924f14cc6219230eaeb6746d1872e08d27a239dfb20f446d081af455d10b8ce6d4f8e20a22772ac8d705c327ef9fe5471b3e90d62e8697d1be35609aee9f5f389272b0bbf80edb356aa70de5fb12c5149e9b70594b615fe72e839b5c1dcdcb6d6bac26938e9b35d4d726346e92dd1d914fdbe250d02260e2d563994dd09da945fedb7d11007d1c514d93b1a20033f5d62ebf8ea7451d2612d26c3afce218484082780c49dd6864e530dd85721cd63f33cc22fe7e5194e0798104d45cd5e9ae362baffe64333df16caa4749f6dd71af4a68a8c6ae972300d90143a0f840b8dd970e69da3ca6acd2a05e6744e2c64f57a4edf92502651e78fa61e56b6af27f317a92edcc258790e592f1874777c689ff5ecb5d0e1df66e2191152313284a3c3f40c64d9d01a8dc813928eaf439d09bb933ef67e84752de118ce187de18492d4f173526ad3931db692691c56d22bf7d6a4f7100b75435278a5b614c424fe53d48c7fa3ba45751d6c3e3da57fb23a93d9329caa318888cbe66ff51b2bcd4ce0dacdcb37f15c3d3d1314ec15feaef57d443a75d35ac8c32b341dc47bac14e3b2bc72ce69c16ecc7c82b942a282ff529b36ae2e5e16dfd163662a450992c17830a5e5d7b48ebc5c01c1a47202bd98887805af65661cfcb9e67be8c4ae6a54feda711fe132f5952d375524c89e762931e7c61b775a65217b3245127e4dcf26007cdd3864b451e2c262c91fdf90421fc8d507bee4bb22f33d23133300e709112677f76cbc9c24b02b3bc4bff2250c18913e0e06e968124b161bd370190a3382ec3af593a706557cb7c0c75e3a6955923b745bce92059ef0d4162901dd089537c818694bdf1b61a415fc7f38546af0d89afd227e1a868273905f919c17e052cd8ce2363e4f8a5f1d549b782fb1b0dbe9b76b07917af900c2b9089e9a03a0ad43901bfc4447639348b0eaf312760db4cb5a5c076cd3baad58bbe4031b20fd6c051be56722c7d0b504e55baee62fcb3291570aa01f4bb6d705c7e48c2357876bbc95dc831f03857d165b663ff2dfddb010d65417f2130147f4c2b6001630519601ae4958646d2c87b2433e1ad486216512d9e6f24e4ee41a7ba33de548d6f21dce84d929b7443d8beba6bb343615dac0aac4bbf3ac2e2f158eb3314a65dd1b180b2a29261c3fbcd4cbc83d64dfec2d2c0447225f38ddd7d5c589402f3c0906eecbbb9dea1cbad1b90a37cf8d807b425d29fbf37da8de51afb158eeae9812ec6b7d8011d752f10562bd3f28c006959dfd77932b0c8149108edfb618970556f09523fb5b756a370067fb45765679fe3bfd012d9e44ade3853c87029bcb1b3230a9347b05886d318f1fbfd3d5302f91a4c089452290bd9dc0ddd28fca4f99cf388d74f75b6b529763d115e7f8a3d26fadda15cc5a9138f1e6c9dff5b8b55bdf7ba2146701f3f5c4fedbfa2389c703a72c47d306caec369b26db3616e926017eb326ed72ecb2a7ce7c6e1fe0f02cf13bf29e78e2129add5fc8c24abb4e2f651e6485ec43a11234a44c055a08d4480847e0db0ca819b33cfe8fa62a3ffe16476c69998138011ee2892bd944e2cee5ef102094f9922f806615ab9029b20d5d4c4d9594b622a7aeacafa67fd44873f2d09fd933856909d10e506c452caa418120c8a4229efe980f628662b05596ec354ec39f91fdcd30973df265048104c04c1d2de07d2a0e0704f4cf1c7e6f72bd86b88ee647d13353d2f4d6c2577209573aff77d062b069cc4d1466db9de671c1846b42b3f3022a6d28ffeda6efbb317832811eded8455d39ca50e846f4f29f376fe5cfb80e317d93e61a94638c41904b0ad0d9c1634686a5503ac04df93dea57c975d156e9689ad0d9dc45a95a0b67382d0257601d0459a3600e7d1eef1ad4e7b9bacc459fcd121ab0f5e3a7849149812a190b0ffead73bd31768d8e38e64a58e4eabb1cabdbcb3647617a58af4bdc3017fb7f0daec74bb46f4f64a374342138dfa81276348352b9e7aad6d60ca6de8a504241fa1853e899783d57d5bf372b82167194a7bd8e330f9dfafe598a6554128911e8143423daf254df1d384f1c2cdb506cc31cb407de90d77f004dd765f2c8578aa511d1e925e17c3b1af8ea5afffac721035aeab414b4e541523443e003058897d278c7aa3822651dc125243c849a3334208ce14d1df69018e8cc59463a440f6f95f823a1379a93406f577d01108becd69e97c69811c0e6e9bf91b05860478791cfb179bf3ed42fe1abb45e71f5450355fd7eff13c7e1f805453e6ad12e956fd90595674e5e03869b79b1cdab902f81738479c1a00e055be66d8a10cbd3ddcbe9980aa223d06a4b3b30d7b9e397e20e9370645a36faa8d01dcee5bf624846dbbac0cea8f60a8eb35194ddcf06a72bd1b0ed8e09ccf932d9c342c15e2ef066cc1c50c6db3c8abd5cf3a85ec19676152cd010e13bdf2cd399542441cab0cffcf0f9dc43527611c5c20b6f022975a18a89b9fe453a8105492abfb5a24558930ff76255c45d1be8fff266b3b52613ffb82862c8f8dfd5af9e92f2f51c1e49eb2b9cf17b48702811892ed8c3eaf3d4257a86d35b6322411687acc20b0d34a258d1eb8775c275a38211f686c29491a10eadda3f054b4fd2d21c57f47ff958a5c95b25439133ad91e5caa79ddedc28ce40d69ab04419dee5f53e7081568186bb81ad2fee78d87faad97ca1e416a760b823688b8656958bb9f6c68cb6f05ee397103b8ff84a5f3950002aa307b8b8a161dcdf8b52f67e2f2390f2dfa54cc0569634557aa8e2a89c758fdd61df62a92739b75a6274ad4aa5c54c8ec713b075ab512a96a2bf35f4a768849e85769873f0fc96daedefe4e5cf8326078e7c3e19dc9ea54ae5eb8168799c149befc661b0ad307e29260a1fd38acdcf22c60769f512716be82b1a0c7fab9c67f52d3148ae2acc52b6f67911da838f10d347c22eb2b468618dc75d4e510fdc2a7ecd9c2f05e16d955dd05ebf2c30d34b80234e1b59341dd18b6a5e079218b523c2955b783bbefd9772a162705a9e0a3c53f2e1ee14dbc2e54a91a7e099e5373c8c6d298d60976a49e015fd68c0708bbe33d3938d0de6ec3499875dc3579252ec017dc59a75230e163adddeafc66d8650ff047f93e6e30b743403cb3659a8b203109cced3a59c9222d35b2ee53f727eb94d2207a5f04308f2f6ae3e7dca6f2050ca4bf7a37dd19c61730b6e0fa38e0ab57f50eb1e7f043a39222688173f7d4c5093fe877414b05a48d242617a1959c8a00fd6d7192fc94241fd5df259d64b8cde11a7c6c9d6f5088835f56ce156f25aaef74e78de2325be0a863d7bae2b6d1cd84815d06dd1806563e8dd68fda1406b0edb69c43e32ae75b0444c36e241f36ec050c4b6362790adc6eaed456fbd0da0f9d07ec9d23f4d8869206d2bbc33a1b2674b2343d8d8f2f2d280036f80d88c63deadd0b039638e11992701c63821aa42ddf669bf21aabef4d0586984eae7a7b5be1b043fe875302ea8fc034997a37ef22ab4f500e926d003eacbfaa97a372e82c71508b856f0045f0af4b7fb0541afc133e3497c3007b50335c13eb42d0dbd6058beb4e6136fe031e6f3735d939c64bcd12d0e86be624e4b599bfdf6464836a13add1c93ca030b5448991df20843072b79713503047b7e07cc0f902b6908d0784a90e41a57fa0dee0fe7c1aaef7c853e5fd32ec2304d90597676d804b53a4812b509cfb8aa4fa19b3e9b7461e33de58d15e44e04c34375469a7ec09d7f94b7fc059a1ea5dcbe233f45ae6586945d5336ac41d1af0552f3d50a534ace948c4f9d8765871ac3f28b71d76f1c85750d0ff74d1597c36305b155603aa63055330991c35ef51e6eebc955031ec4f1f25e1c5a4beef91a2b24426cd967613bcbf24fa63f268e5407aa145c8bca72f8aa414b6e1a2421c3e398f84b76bd1b7143f2c9b016aca21eb2330fd8d97383454cc99f82f8f0218a20e7dd4e3e593317e9516340a8bd69cc8125a39692a600c8ae56b1da56396ad7d507250691fa4eb7d2b97924957c0f0fe03f1f4ac913acd14c9cdc2f1c22ea53b3cb7b013b1873ef8b1e176f0ce3bb43e4103319b6f100fb6c2a338cad56ed748fb82c8883ee0cb3a6b28adf07b09a71eb9e5c1267af161ec4e42fc1bfddc7bc1f820e2b877970291c3d5dda06773fa4cba53ea43672715b932fb26d81af6fa195905bf03bbcbbc22241e7d94aeb88edc3b5ea4168d96bced13cf07cf90807749212a8874e9db342320ef1d4b39aa9272df9fcc3bb5acfb21b1497c99c65d7b9bd37fc112b052c9339855104a26ee149a7002aa10bf29801c5107acd10736914e0e3509abc1011992e40d71e6db4a64350e25e935012374d1842d31bd157af2cbf82c1559acc5c90c78c7a92703ebd4b66458410c4ba9b9ff9fbfce7ad3b1c9ecca2be27ceff73f22d6ae17f602509d33cbc5bbaa8a08cef3658f7c1ac5a3541b54c951391f48dfc2ecee86f859d2e50c44404a723c3b730b157d5a06e665b03a80169e8e5bcfe2975caf167f4b196d27954a4c26f2e5ff6588997d5da730607c3d79df5bc7eb38f15c5a6359252699835b6c552d9839dd181cf76e66e7379d61ac53d031d28fdd91c9f6f1896db09593e65b8f2596c3dfc5f4cc58328f670cea71551412b37806f5406fbca73a771cae5fd3a43c29e2bfd245cc913d1ceb095c41edd4087b3bf1c42d67bde080862d8b9b6c085223cfffae57f3a33e4d9f43aafd986b24792018f78b2a135d83d9a6e1069782350b7843b3bb4eca7a047aa5d868f9109fa3bdab5c34593341e1e7422d88c23dac65235d6307bff4bb282da563262f80774494eed8b7e054905b35031a57703110fb9edba08c9bb25368881d6aff49eaeee964df91ad9bf75d05553a0cbcaf87e5a3a8c569d91102db524558a648e324816159409966a9fbd7784ea1722414c6f615285597c1774856a93667e2635dc847f6ae4391d72586020858dfd49da4f075bdda32ce862d38c596968ddc7d01513cb99b893dbf541dffbba81f5eb6cceebe95c3e15df38decc8cfd6b7b21b567c96ed41a9ac4832e2b7e5ee640fd5c6eda274a921bba7c8efa07adbcf3bfc6e50356e6af2fe9a20e8f15608d67bdf088080237eb818de2e5c6a24dd895e857584c17b3f024dc81339d8d5b2da0ed1139818f30f7aa4210776fbaef2d62cd7042cd628b0282cd7df8781849f0eb8c9984a55f8fa4e59bc099739b7748db88daf5cb71e9758c0cb96f148b32afce7bf2bb1333e770e4718ae4663b5eacf916cf9aeee762dbacbf85a9a936e5f49802a63244c7500425181adef6ad42489f7a5184ffa3e5779c61e308188caabedf87adeb0d7e3c7502d53f18542ee0e7ff66bf6165bac53a6ba417a1f5862c03e05ae5ff40dab7ced40b663629a2863ef7fee0a92e8c4e7fda74932a155050dd38b9da056ad680facd9e9e08d9ee97007399362e247918ce672281160e0dbc8327988d04a2ce3c82288eac02635a6dcfa6a502042c7552fc92ab393ba3fbcd0ad0050916629412819faea7d942e5d7f5df23412f97369d5fc72a487f6bb53648624c382f0673510da385b0dfe907499e981ab5a8d2d1d4a48eaa807bed229c62ba63647bca3231ae43bbbd2b36d1faa26a6008c4855c509e34197ba0f2c1547edfdf0890f7145aebcc72ce5d0462f6d29a627c72feee6582c95a53b2ec61634e48e59aaec54e4ec9da57ee86fd59c2f95c6efa67b677bb8ae074ad07a603d07b7f7edad451ea1b1246e7378c554f620e842997364a70444e09969ddd6614e64874f564148aab19fb3768aa74e437e980f3cba1fce14d4d03b4667f7bcd76f47b9857cdeb7c3d50649663ad4d10a9a36808ce93588accde57150a2be0f21d84d2b596c08a2f72b112453609decbbb62c13a3ac4d72271d2b36d68fc67e4517683c5c5e4b4817011355613ba924fef47a9966c0378f565ea312d0f5af15911163d7dba7e6a4c30358cceb43fe2b49d03bec2a4c65907cd75e471e7fc17562b43825507734562498d4262f357747393e339934ec7ce9b0df62f89f9470a79332f3fcb56f753220e1ae2dafa99c6ac8c43fb3bae903211f734c63c1892f126c9bd2cabbb2facd4759ce93a5873cce8478455a8b767f5ccfbb3af07189778846a7360a70a30a17b1b41aba7843376586ef7115dc94e0d0ed393a0a1b476e75d96298e4fc298135071b86fea028fa85a3308a342df5c77e19951c0e7c0d6cf7715f9a1a267cdee8dc6e919c9f40bc2be2eaa53b374ce36fcec053dccd7600b1efcfa1c1b1e2898544e4fd5b33709525ed564abbfc4df1b17f0c2a60c0b47406ad99d0cd6adfc9f4f33bd075fe354f9f277a33ab32bb13bd87af5dba251ca8742fdf1be95b907b4b5be377b756ad45a34732af61c7338a43243f477555b55f67167ede1c8281fe65ed504d858aca66a84efd2a27edcb26068009ce6f417e81723d30506721637d0195fa93b852bbae934f856dd11cf32e9ae957bf311e52d6371c5089e8c837b5edf7149b0e820499f122b4c9ddb6b5b47781a078748325eea5757f145967771ee0620db8db2f73431533c786403a9fb6a23a6a6f80a84d4b93e3f65f9a679a17e48e114dde70239fa49da8934ad526bc52b0d3f0fbac668b4893915d5802967e81a2b97eed270f28d52d9ed69d201654dff9d7c0dc1271b96a65079aaf3fc1ed67caad21fbe6b3fc9af0de937bae4a24fd0950e40f51d6f3b259db2bc6670970fce4779db26e3435b411dc523444d7b895c389fd43b7ac88414b2cf293889e379deeb71aa00932b4e2969e103be27d89950641dd20937d1c31052d56202d3a7c04baf741ed5178d4851467f82402633a58196233f44189979668e18ac3b9d52dbc465348ea8f720578e5e3d4314a35199b6c1a747fa87d81a9ace20cbaae13c7c693c177edb7a1e0c4853aa063273044bb4292a1ef787d9e056cd1fa0dbc2cfbfea7e133a6268eeb1454e88a218982e3c5be9b039ef76c78dea5aff56ca2e78cd45616a8b85fac96a9de7b8b1c8a9e424fb1b84d01b1b955bd89996a11e995bac0b4b48545f4cedd208e54751bac7e208c57aaaf5b17d577ba956e5826eb2fb4bbdab260acd599eb234d0b1ecbb1e382993b16e76e8883f66a0aaf7f3eb6fb2824790e8121fc0927bb08f7227bd3ec2e7635117646f57817556b7ba24800b65dc04c8b26dd8f3a3f6209bb040297efa75cb09a4c5dee36b602969205e7f49d60db89fd7300fe984ac76e29c934389c27b18ae5042bf94af8355afe3629163c4f940d51958f8bf46232208bfbc332edc57bd0739ab27591df7dea6d00bf4c9c174f3db1db2973f7a2a2967af147c9f080c63f4a480d91872bc29fe955f991fa1a0f2a235ace064071132159a782c2a9fee9957fb1da35cc31576a588715084e7ddfaf6af10ca03b7ac07921b3988f3ef08aa75661c5affd4b96fd35c2fcd00a11c6703375b5b4f33bc7277cde512e058a91e2a496c365040e691f8d85a83a4b1284528a075f9bf4974dae83cbf3578bbcfe38cf4e08377a9add17f77b812074b8e2c4d0e5d6ad206d13f3d3e28ca5de1f9a9acafb30c9a4b922dd3f91d352b3f9181a2f26451beb4bcbab27fff2c869dadfabe7ac6ee8aee557db6e63dcd97cd76c0949c1a90116d9b170fde6ee075987305697588b71b91d7a1ba8de666810d29210b72bb470aaf18d0c8b558983e453f2d82c73df2127b94e297494b13744495dc8306878e118bd06fd9c3d22a4db0fc477852010d533aade7dbf2f3191982a87aef45002bf0270f16b61c8acc6914a6cce4ad68b5ca17388daf6946ac8dcafa14a0d1cf053c4db25e38a4c5427aa9ac0c1687bb04bf97dc804cd6d26754dae079c98055efd028a8c405579a5d15f0760df5e76df55e2f90fcf427eff3de879c2591593cd18a7ab42a587bc2a02cd4d8bb2cef59b0374545b6d0cc8098a34f1e0033523b5ddcb8aad186f6f65eb1c1589c9a15b5a2ac079462606eea9a7cb2445f4e214810f669c8b3f321606dfa9f13c16b3ba9e7fcdfec0a6ac8f054619e36bab7a9a8ee86065ff6369317e86a4dca3d059072a3f9a441372046c82752228ad7ae95ea2d2d8b3956bad042f9820afe718cec446b94245278f79932f1749d5d1e9bbf69963448fba3b3f824b26d0e15900d4c112d6893bea2caccbf4a1edaf67da79b018a74bc74cbdebeba7ff4bf4622b0abe1eead57ba5cb10a747c1f7615e7dee562033b860a4be43447985ba1eb93806410c689359aa271cf68cbd7fcde6008af55fbd16109b2d2ed77530fcb7ad47c957e165f52da5baa16ac3e64a4f38501c076d19","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
