<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b1f062b87426e6d2eff7367edd323e51c61c027aaf443756bdbc284cca6677816a1b300858ac7bfee1bdba984b6d1f3c27a3e25336d076839aff69e28abb66336a5402594505bc88374606e8e14cdf7f4bf979101dc523e1451287f846577e73bc9e3b12af7a6766abeb095dde25b52f1e2f71217eb07ef391210d7a980de62749683c84dc96229c5e4dcc0a3a2d5e7a5d356aa4dacf60fef2de772bd0ded66e46f0b840f0b12263514f642d4ecadf5651e7b15410a0a3a28e1e1ded651b47deebe9f5d79b50fabdeaf1819e8771e09790bd724fe8614510dcebf4e332ccb094698d0ec593b454a58f08f186af1cca9e137a6260a8b8ad0645c2b6e0428c0e8d9e3da1c4d4fc0f49e822722de58ae6779f617b722d0c4bba7583bb559c841534da8388ef4232f479c2d14e68a4b7701846d410e2955cf0cfb66ae1163d26669eb469c0c34dd6c9134a1f2942cdceefc1f644bc1d19036e496d0719338e0421825e7ad1b9d94947ac7598a2179d0eea56ced52b2e4788c4ef780e47a1675116b7488c217806e6585b5bab597869fd44706d08db9ec2bcae77653a44313bf1cf849a6fe443daf8fc287c403876b63cde107507f03c413a618ef8eb441ba6cc4239e8f4f7d9a79c6ba7722bd47902d2a479583edd84caf163d457a384744d12f85b0d1073f6b6c765cedeec01a28482d2b248a577ee8c0e98520e68d1fd5f4e096bc3e12b47b7fde3f6489b3b2c2353cb1ac91e373bf26fdd6245c38af0ab35bcb2f419788d2bb4b776b3cdac502b052fe4c3c2e2bbe8f624769c21f1b33e36a4c57e7cc6cf3d41410bbcf12b5300d1b159021b6a6da76ab3923dd85d3bc368a008d036520acdb51f22d19e97d3c8c1ffa5b8889ce122bc98381eb1bda422238d8543896711b8de00828f28c6551ca1ed1bed8e8ccf868ff2c74285242b9e184ce0f4482307ba13f526f0bf62a2e38c2d340d0b04bdf451ccf3b17a2b1ce36c478d552646063e9461ea37c82c2fc9b608f9cc1aa47ab5fabea21a5b1ffd3061a7260d99e305081d8ffe73cbebe32033cdea436e50e5637d5151483e6eec7a34babca1bbea697c3fd39b3d93a67ab582a81f15394e27f3bb706f0525d498321c21b019f6aa4aa946108838eff4962015e39dca7c75d0e214e551df4b90ecf689c3ed9762f86add4c294d8b404662e5caa70051d27e378433014abaf5a2b6f2c7fe0c643d676660aa4f0042d8610f29dd18690a61def765df5f5f0cc5c230e3f2948fb21afce16feb760d007b06a847f01191b524a1076e4183ffd0beabf515a1aa46a0845e97e17aac811e409eb6966e76b3a1a4b068227e36ce1725901174d2d2651f23a2b9472240c606a74b5c88c370f0dc76d3fd77aa44e98faf2a5d6ec1d08d0abcdc321edbdcc996b98215201aadc49a0ac27b18aebef1143657eab2558eab7de8089ed0f74edda7ebcb33253830580882917b4ea92d14acb68278ec50ac7c887662277139edabcd1013905dbcb34739fcb3fcf0c8cd32daa3c10883533b86f5eff9d9292792f5d51968fe2edf0396b15c363730f62da73b8dfa2843623b3e1a4d80b774621b305fbae616275d2e1593aa8c6ef256e78d5b912e879c4b8b94ebf968222f8e851528ccdfdd4f27943a08065af1b8ee0673e89a857aa4034e9c679283a4a4617b83c559a0439e9f09b39dc5bd76788eac80938375331cf5931fa3488e5a66b56cf407c5c12f6c70d5e991d4d5a4df7c270d5acf76073f3b1462c6e4c73991e0adefc283a26c4c74f3606d90b1bd6fe6e4ea5cbf509bf844165819414f034b38e26b21e4e5c1217f51ae6d011bddca4096a9576f484678dabf1eab628e65e35d796aa425bee887568f6a04efb7a600206a8dbcd193ac76ca4a8a79e63f16dc5f49c2ef2e63357c10b52c6f747ffe6f3235104cfccc9e13edfdd4d4c4b9ad93865096f36c2177e9d5b75c045e59588bd19faff541f24415efb4fdaa903bcc4aed29e7775781b5b5b8dac8c14362e04d1cd6fae5fec59e9b648b7d62c016b57a9995cfc45f05e9a0afaf273b2e2b53973535d9efdf94279d422e968d9b55cdd8144e28a828be3538bede3495fea0daf613401f02a4322578bfb0a21708e028e08fc299f954050e88ea03a39f72598b33099c16d378903d602b560b1e35324c236c232cb0af676bfa43dedd69e3eaf111e2dd7782359f4e8b53891216ee831c6345a193731c5af624ba377ba91639525b9803fc3100f80d8cb831e96aded30336be1970deb62b2aad7fa6fba4757dea6d8d2b73c6ea9de99a83fe26080db731f503c3e3c375e7d3270e6e15f293df1fa6c6bbf620ab081fa8cd3182e1398e2d487d00695376dbb5110f5f8e0736525faf0a5cea8111d8f11a9fbbb3e60b1b3345d570484accce6459a565e7b491315f6909aafc5abdfdc82dd7fcba15cf127788539a5675b6bb1b0d80c640088480142b298e88ff0535cb7597c7bccaa0992067668a54294d1becf7f9513975c5c676a5d40d9c8e26bc266d56e3dd93c91c24e0bb8071b0aea406b1c153efd5f72f6c529f928448d9403e06b264b9492e278a401abc10854e0ab9cf2071cedc2983ba44f3cb3fb5a3edba10e35c845cbf1e5e043456f210109835a14117755cb51cf38ccb8f3a0e5e3b446861054155ad0f3c7b1892eb43a88bf11ccc1c976c9ea1b575247484e2602766f8b488891e9f5804e0b35aeb11e624563b9837c5475442124233d116fc37ba2641e5e99f017fc8c380480005c32b2a978bc4fff3953d5d268e3fca3082e408b99edada4644ba360a43fe51ff1f726ca47953850e1e9d6afcf3307205066d16028a6ac8f34714551008253334e8ee13d073bad63a3213e2dbaed6d41cc0fb854a4b00fc3d71c34a84a4dc2f1377849aacd07665bf9574dfe826a5e0ec50e6d6374a33909bf3be23e59454054f8cfd72db4ed764c0d9b53af125c36769954816e25911b71a637ab4029ce5b73d73ec5b0753e976884935b899ce2e11cbb85511f18ad1eb1d88d3254ff0f843a111207dfa01091a94ebc8ee71fede97975b6b880fa90143e00489a288b04f6526077c6fe8b482214d6a65e9a1d71a1ab1bcc5c97d1fa8539d1a0781417d61cc56c6147ff1e529cdaee730ceb54a959703c197de58d6e31f8b131b52a97638a0d9391ab4e82d5613f1e22e9454639aefee7d149422e27f8e14dc4ba92fa63a966cca118c927f785d9e5fb03fab6a05315cb5ed59724aac819704605668c2db79399922653bb1c526e8498fda1df16b9c3b30f5d2193680c0e4d6b6a97505230720b1eca9524bcba0ea649f197b3a98af6b292b67fd494a8b42ab065681273c4ab35c0992211aec7b73fc18705601be7354804b29ca229bed364da6f33dab4c925ed766dd5a870da811eac3287c1d44f5c4c0eb3f172790aadc9928c25525173a19d03f45284030e4363d1ccaa2a043ac79de22bfd1f7f54a61d56abc3cf43c3bfe14a9a65524f5b9ac7764cc5a6b0575d3ef27a43b921a750d71111151082cc1ff3313e2646ea5bf76a90d1301dc6eef84ef5304d45c7c6df92d5734a5de1fc5f12b910d35befc1daa45038a6e7adf276358fa08a0dc417cc11d50258fd312f6c8af4818f88ebedab2ec2f6133504b0a05329869c4904498c6196ccd7772586d7d0a15dc7efb03756aa12be0d0febd432a1dc47a30aac811de3e019fe24ee9a9f79fa01c4bbbc78fb139806a91e29b9902ca9ac04dfd04287f383ecf81ae26ca5ffca46e8657b33c00b847348cff20666c5a9943b92a66546769573f322f9c77c01c361425b034d28b9222b9c5f8069e337716b329abcd7a409fa1f061cc6caa056b9067e9c6de442c2ae5dcaa7dbd037d3aa37105f340104429e58400ca420d101de78c71620ac2bc4afc8ec42d9551b6795a41b98ade5d89c26b8f75c04ca5d4f34fa8f09ad8ff24b7f5931808a431a8be86ebab1a4851ad7903209b56213ba4f9774ec26be7f0bd8dfeb19ca4458f5e56836b362fb66366ad3850d52848d952d6018b58f1aca9a35397c3a37dc9b6932538c90b5a1241e2c40b3d26026e098b071d6330950f3063058396f5e3f543a4622db90a90d7732a95d845f6438aab94cd3822bf8f176f8cc5ca1f26abd6d28e32adae86424f774f97800ae1e87b369ff1ef31cfb6722238d4922ce94592f04d12e83cd9db5f06e396283e94fa2c0c58b87d89c8a1dc8d5f83464d0a09cac36ffc24da66ef18ea4ece78102c9962beef9558540400303f468ddc51183096affa8e39c1c9cdec001185f9b2e9151b4b089be92ca51d6e087df01adfae221f547a670cbb60bf52124e3f5d84d58ed0b96bba5236e3ae44336b1b41ccb1556efc52945ec161ca8d7c1b28be561264f9f29718e79bd889d1e354647c4fc5276bf1a8d563d8f2d5811f4844239f3ad40deba959a7ba247699e095a633891f8fb89522826d3f0a04bf94fbb65f3442ce753f901c8c8d3b405c93c36855a680a447792a766ebda6c53fb36626cec3f6e86be7fe8df21dc30f8e4150575da24e43837ee8a72bf82caaf7c067c3d1e32cb30b0ec0fbd19bc6afdbd10fe7ae944cd33a1334e0c3587f356aa96b101b280624a82ad412a36ea786cde918b7bf93f5b91a0b6e6ccc83afde60ed82a3c24bba7b7a8b8bf558813fe16c02b8d8414ef53ca961b1c5abe3a355cdd27c88f269996cb7f99c7aaa7e59b883c64dc196981c4974d6648855a0816ee297ef9e40745c6ee3cc06d60a496adc0af8338c2e21841a3146aa1976379b6619f33b6c1c5063070ccd49d1a40c22b6b84100761b5ec382ace939013eec71f292fccb3a2d2c2011e5cf0fdbb346e7b19cd3bd7b37931c74bae5d5eb8d4e469629e927c2261835e2c42bb9c25c6bfefcbd6b5fff4a7592cb4ff76d9ae710983ccd332ebcaa8e79ca383048b1d349f1d1844be3d9fbb7a2c390f7610b59767c6b291b2033d7b68133d8fb59822bc10bc32756a4b861b097379d19616e78ae51fb645438a32fce20036ba5c80acfd229526e6ae708fcd1d5f98903d9cfe824b319d88a985bf25563a3b17b040c84ecd0ae2fec200a2b42babdb1176b6fed63233be9dd052a6500fb5274c7ef3abd7378e52d6507eb19ce46f5a948df9b302b67fd84d53d4eedc81ee5899ca2ddb14b1b0bc1f2bfb02363614baab2c8ef2ab0b893a6c90328d19785d8e6c4fcf17b8eef713b97e28169475967005cb84d1c923ca59cea1f829b4778224d659b423b332abab94d1da4eb5a123e01da47ae4cf72725c943ab281e708aa8d568b5428bfe2fb30f0339a02127e2473f190da36d10d2f287271168641ae9053cc9dc093cde0f8dfb9ec9156340ea0d07a75cd82c3eb9c3106eabe0cdce5f3dd94709b9fa4fe05068b1bcc04d47541e1e01d160431b686379e97435dabf38bff0942baba787aa60a2e1ba101fb031650cad798589a5d297ed56578b6d977088200a10385bbd5211620d734818d688937e19c75ac8690b3ae331e68cb4b7c1ebb3c1e8a54a92d9e69f798c4146f591cce855099d1cfb9ac59bfe6bee6299bd84f35d2624bcabbf2f3c3041414a691dfc53faef9727986bf2b761edae43d56ce886b6196577b24e60b6f352f8b164926f42ee81c11faa11d5c35b5ad9d4eaea34f064bc9a0a3d438aef0212a7cb644aab28cf971dbb5b7d0ab42dc72b540bf85bec5e885761335e132c6413d1c51d735ae94f0cd3a2095eece1bbe151d36eadc2a7cb48e3ab028ca0cfb3d646d17a02364744d4745f6183c1a654ff07bd6c9695685a5e2a62dc45fc3c858db4ff45affd989eb5261ee691530a4e779ebc2ff72f994cdb3858a191b52d8a699a35fe81df06b6dad0cb701c48060d9e52e78554c26db9cbcc72477ebcefd91620b41ab19822d962dd42ee22c872b8b15d0cd21cf327d0c96e9cae89a96c13b2abc18047fe52b00f8b71af3e0c9c2ba0f46aea965e033dbe5ceb71770795a04389c02794dc8f6e29df05bc6eec83f83a003be13dbe583b8bffd9c305bae996450cb495daa454159402662c34870c08b53149642dd6fe54cbc85744da614484185c29513d8399c93b40a0070c6b522e14b0cc79a8a8ea0ea2d5654cfbdb976f376e8522661bd6b6e70e6408b712ff04f33da4ea439f4971ad834051c95726f2726cd3e6726f33201f58c9c2c0470d5fe8ae8721fe8903191d1f1cf7bc4d1b6ea9ac785ef3af241968a99cdc6423b7aea177502f04e564c6428b54f2765ec040796c2d0c52c6b1fe4c815314bd11b35a623b085c7cdac986d9a780a68f5892fbac961d8a658059b703450006f2e731fddf1086f1c5b88857faaf213fccfbbac62568e1668a3fe44e7917a5ebb8eddb758e23fbbb84b302a93bfcc7cc7dd874728a2867a371595a24755fd5bb9a8654ff5bb44b4da8ef0edb8f16e791d4148ffd7b48d8bf124b315d9e4de08bbdd6eaf3e97b4cec2bae5c64e5dc1110d692c3ca9e52dc065d4c546b3d622670776104b48e49625d1fda54db81895e80e1018268ba13131f262b29c1db47280c6377873ca8998bdf25538d4c890539daf4e865e1779ff067c96f2d1e3efcdb8c7ca66931f753f013c8da5439783e3200ce362ef03eb9e74fd52878ce637e8dd8db42bbc14bf807cb80369dcfd0ecedcd099d39c9541308b736a433aee3d42e58f663b074c53b972846f32a40b786287c5714450434b3c70bbc88e95708dbd5be731c76941583c80b07e147d3c4811eba359a0daf41da6122a8b632865550a11aa815b6bbb7ca9406f91048fe08f26cc0193c3618849ef633115026a24a888c5edbfb704a65375fdea877009115bcdde2d501018640cd6e023d423c8548bb9119d0721952f37e7ff6b138758ecb129cad42ccf205669c9256e4db39661375fcc2296bc84171388c432ffbc7113ea55967dce50e6d4e63cdf8b0797a6a6d4558d64a3e0c49be4a0bde7cf85af57bb298f0237df5544132b59f5f5b9891264b7c2c120d806bcde9196c00dcd003dfd8e7f7ca7bc7eaa7672b938c1813efb1d09fa7096b664615a4d14643c1148db0ab24df7a3ab7eb87229351c1040d2f0a936185e5ecec8ebccd47bbf86cee71193aef15bda90c480278f8cd25bb5f0365459a8d4cb9ca935997cee47725c6d9865d075a0a77f83b572f23245082d38a55e9d51723d4e0bb0d280fb4451209d1fbbfef7f2b8440bf1110d641f50fc53c55e3cf5d037db008bf858e513bd44fb0aa2e2f3677cfed6959d95f8404844df9c35f0d731c4a9a5a67ed7e0545ecb1eb89a6bc708dbb49ff3d3a88098b2ecd54387833e9da2640e54779d9b95f1cd2277481f8b62f10ffb7ff914b30886828881b759fe0496c05e1c530a79cf32d9ccda987eb6e2de7d2cb80cdae5f5d855166f20270eff001cfcab5bcd83ea47802c236af5a0bcb199fcc5bc1ccef2ebd7836818773a8dbcd0ccc923160f2cfb3ea109c72a0df579d21f3c690b8e52cd98c97b7b11d9ac5b65661ca6fd30fe67bdfe72e3089db9ab6ed74eec471763c8d78ea5bf4515a58544abfc92caeb0eee2db0bd32886818b1acc00fabbf0a57b7863cc7e4fdf825cec08ac05c6618497d3a00f946981a4686a43c81819e1aaff4bd723ca8c4ae90a0ba7fd64d052fc881d2d0b7d90db0ff0b2518f2f1a5150dde46504c75c80efe0273b326ba2b89152243260516f15761ca586e287af44ea983eb36c37120e6b2c968e8a1ec38bdc6d39cca515b52a9c04732cc4388141110f8970e8ff32568da74578814592d2e0f40e6de6cea5865d7f35c8c8d338cbb9f8d0178761adbe91beeffc4c8ec0ec4c3f2eaed2ee51cc4add853d3f592aeefa82f7d9261e7400d734f1ea21b04b30f7b260ffe1459ef342dd27633b97e24b85f0438283370bd32d9d6f1795b5363338cba301f09a1d5dc2377b8f026960f75f8865c586eb05c07f4649ae65c094e02389eba10dbfe1906aefc6d7625855e38f0f1b72d6d175eb8c493f82936feae8636da9ab1d5ba974bcdcd7c82ec70133fea6830f4a883afee4545002302a0cb08d90b28844aa67a7b906e9ecb8a9aca3b41ddf3ae0543e266d0df90a202ca7dd2a67604a3f01108b34a24edfe9a346924797851f9e6c26b4bcd0a76bba904c6786e11ffbf7b7522c93adb90b853d60da544159c0341eefe55064f575ef24ef13080d544e91c6e846633ef792e5474680c453304894c1f10d17ed632cd96399dd4f1e54e0d1c5f2ac91208d52dbffb929336d399b1ee40729b853f61271188e6c3f76c6aed313f0c8ed11ffbebacbf01162c951f6486f3a682762df2a0eba628af9088f0955e4b240f72afca4ca5714f8779180ecbd4fe61eb63a929d0eb3ab73c66e90cd4c6d36f34b34739b8594442aab3ad75ac1d27902eb9a4dc5ec00acbe5abdc55b6c34d50c298f102c29e952028f95a9dd237b9a0923a7c9b84c2301bb185a4a71479454c70573e0bcbcf75a51b58c6b539eb31122b8a5ef6bc1bd2740ab267e4fc8dc7087f11b12779083e5cd1346313546c0b900059612555facdab9416d676abed0802d944051be38f8c18dbd6f8855bbf9f007aa9544fec53eb0c310ba6e89f594d3bc5aec8dbad03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
