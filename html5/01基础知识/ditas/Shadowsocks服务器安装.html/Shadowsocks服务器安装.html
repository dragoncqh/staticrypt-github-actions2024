<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21c84f0f3a929375ae258a779546afad40700a609992d6621d5e42a0675afe8926943c7a1026dcee16ece9b7a417a8b30d8c94b4f6e4ec421a960fed638f3f8623fad5041fb456ab636638c6258e8c09049783e7344492ec9778ee2240c1053c36d0533b211005ae6759b9ad1dadd7a7b09f175c4b2f33d77c8659d5c8b8d7d7cfb7af91d7be04ecb2461b04af1c33e4c88239e4bee441f04ec0c5eadcc31e926069c7b2d13de233c7dbe57734ca6a5755e37022809686360e6ebf787afbf6c9de023efe9f6959cc0ca736e1430cc8e2eca59aa29336087c49767a9b27012bd2d3886dcf8c54639a6c43e009f3f416974f647e55cc5c76fa6fc1972a0a48ca59f7ca6fca0aa1befaff78e6d03b183414344c9b8fbd8c29503084454e68ecde1ce591bfac1b9be8a8b3285dd45fefef90e26822fcf9f811952f0b03a3c274cd5cc011312aca2f80f6f265d3bf6dccc1aa5fe48075e00aa8e933ae2880f959c29a27902b1f0969b45c6cf22a1ff4a28a511c51c7876c6d0021638352cf96f1658e6ebbfc5153ffd031643620c186d61004d06e110ecf0a1b8a7262f88483cb2e33c2f928d2399bc1740294ad8c600a34f664d5b4d45099001640207655c36a8d1608f4f743ae7649eb7bc3a6fb1b2e4f379eaac51d6135c9e30aeff99c8cc3af501b50f60a2705851c1acb8cd42d9050ff0c5712b79b15b55fb4f17acf0aee0e720c1a0e37a0586367068958e1ed3d53ea9aaa63b495923dc0a4aaf5582e2b883eb8ce4126f155176bfce9d0453a0797e36a0582225a885b8ef5810e285fa62571c6a82163902d2c3dc7a5fe5670877fd1bd45d22e59988fe69c5cc24e9c09e2c230a05b002652a59f2a997ed5660b180b5e6608d184c3555dae0e05788e50354a0a185986d9553d40d5a3b4c2658edf07a6bfd244a6599774989e2a89924224901cd1fa626579dae72c78955ce14d4d653dac0a3817c2da3da84b5e6726fabcf11112499637395e6d6deac663d965284c2474cd41a111dc9fb59a7861c19cd372c599ece7ab04d8ba2ed5e2985506fc1858e46cb2678614242a231b4accd3ea3109830687ba80153858552f57e43ad08f2e7540dd5e6860a5efc15ee715529456e36b5a3c2218c5de2d92feaca0978113b81d7a6bec8db2e2d16e56a53d481252f7b85fbb35e38f77e470c6e91b8dbbf0c9f4add6c1a59d4fe5a6b2516d0c94fddb4c91b004d114e1b049fa5eb527571d51df83061ae10c18d3ab8bdda67a0cc91fb2fd48707f328cc303459eae7d88a447e1b2b3774f27db5d93a86e1e20245a2bea1cefa38eb82778b2e559db652a53a1f0d23bfe9ee048762366dade440e043fa9b01343fc44c432d9f8a75b03200566789841f3173c58a4b70586dadcb5bc2d82e51818a8c95ba371bf04adbdd007804db5d85ff0e9427c0f7577ee22887fd3f84f87082d2cf4af6af1123ac4dc98edd6f5b266577ef0b83294ffdefa6389bb93118176a1a087d60c7a1a10fc88ef7a8c40b0562b6b685d05d7d5e1b9edd557fa6fe0c4d68cae55e6bf9c9f413a4e88440619a184face7d318c5a957bb6a8b8e8acdfb656c0ab0a1a9aaf83119ddf8b58238cf7ce1af51136af91aa3b5a1e21ef873d5f9fdcf65066620376aef6090dce73dd41ab0bccaf25e0ff6390771b3fc69fda06ff9626181ff2a3cb5826b3bc43fabd2f3fa290faa0406f84ddd5bb093780289ebc2ae2153687848968541be718353419ce6667636cb7eec45950397daf71bd7d772705786355108353f5930e2ab0d9b4bf0adbe60836f88a53506c3794d4f783a8092f99c809a2adefe9b6c4d66304bf1aad506e321c9379663b25d1afb2ec6f3b72f2a4d4a0a20a94bd86a64edf076caee43fdaba1141452bf3780bb888be77540ce7ae213b9be6e1866d1ebdb87c8a6648aa3a72481faf175e84fd868950edc8322aa49aeafd0708568852f483d20c68d9d7c90fdff47780cbbefffb94559813ef400c55a6b55e004d4ebe88949ced4441871eccb96b2c30736e04f3fc8b619d5813c7a1d2cd1d2b7aa452135e6ae00bbaf44fadf4802d3a1f219ddcba6910450b186958799b7b4b1b03fefd4bc13f728e4a17b21d4e8f0cbb16d6dfa668581bf1bab56f2759cc1f5da8edcc39996239a29be482feabcb62444f7781ffd25f897a2d89b0939fd63e79be1702d6c64dac7a45bfe1d5b80c19601593a5fd17e067fb0f4e6c024cc304d16ae85768221ba16fae067db79cf01850936a54b979d32ac77ec0bfef04e80b6d87ab851504657cdd874adae600f4f8d3755d114d99a074d9e3bdb4cebd16069362568b04e051d3c737fc8dfcba1e5030b076ca9b0c4ca3f5323c7b4dacc4fc3834a9b155c017faae3d9f3ba4fb8abb52cbf74c6c2a6bfe818293d1de129f7fc93e75c6dffc015a84f9c658e8448b1ef6f07506b5a825cd6d53268d795356fa75c08d9d5c2c63293ab95b90bc1e4d545f49c7fa34ac2b3c0fd41558dd1044838484b1ab0c0370321cea449360ccfe751e974434d292392e32467768db7cd2e0fd8748f5431928e92926212901177801cb2808327bfa2841a35d1730fee0be3c5a1e2c74969181f975d504cb84cae26a3e7cd0a4248c0f563d5e906303b26e1644cb3458500dc3831e9c4feb0d63883d39de4c1c418eca4e0879f4941c81cb952b67b7b348a1362ac90b57016b02513e441a881aae5507fc486578bb67a1a3d6836524e6bfc7e03fda8ecb73a618009971ebb857086b15905f6d73a976fa1eebe514a3c678dbdd677f9f03af880089b6c0b7a224247c249a4c8bb5ad1686d71a0ca06bab5e2f5f5701dd322e0466d52db651170f8edf1f230dc349e5fe5f8adbd391d90c44c3bfa5d53ba3cbf3f4c5f31f7089de94fe28b2573b9dc05352b340599145615c24ee51e3de669bf27c9079cd73536767de05bd47368f4d737c63f217c1e96c16042733f806b52d31d45f067dbbe4bb45e48e9b62c3dbb8690c28f4de683f4ed102bd2c01e66d70ca4d2da6967551989f9ca0da480ed1ac066fb4abb65271891ae5cfaa885862a7670c6738dc4f2aa85fa6719f44e1346030aa13f6306d633dcb0579388df85f1803a6a9276e9b83d84abad9d3944d6c991effbb4b97abac7952576aff9b6d92b1bf834dd8a581d9ec8cbe9ead5dd56014b2fd8a0db5f25cff1cc9df59bfae7b6624457e7da060b24a7c0b23cc1960510d51f0c4b24cc15cfa3a678ba6cbf435b96aa55f3c16526acf4bfd012acbdcb71d10188e1d3736760cb790ff1c72e06792ca3b200a7b4d2b0b42f819e10e186ac293772d3a65b182aa3827216ecdcc2b3d2c390a60561c41a9e6ed3df03dbffa265d3d09845e6a5d97240a6bc5b6258944b08f554bf75a51299fb6f341909c4a36d45b535be5048081ddd6dbd71eac38e597a4c5f21111da1bb26227679c0001f307618cece7993e448040465e84cff18bd135e090e5147d6c6506dcac155e227f6dff8c3dcbb9fe598622e91956d5bd1e9f61d66d077bb5b7eb3bc2eaf463fc3af0f09a0229acb5b7e19da5a4edd43ac18937a9f67510fbc500d1a4ad69c11dee7439ff42a62063769a951731b4ef36e24853b1ffd1b5ee6f501da8b52c4a2ab34b7d64fc6b3df51068eadd8cdc47c160949532ce97b145ef59c8416c5deea5c3918409f786151cbce87dd13846fa80f4acda6d6a13b779a79da31448e0d7fc7c0e1cc13777f879d045b949100d7dcbbbe3d67c97f6b86fec797015807b2292693fba2ccb0bb0a105d540acc76deafc59cb5d023b02141ed9d5979466e9d71c83f5db5e9aea12e2fbcefc1f32cae41348e6e1bf57899152fdb5815a6e9d6f476d4b31517f7f3ab822480c5aa3aa075eec0d60cb29ddcbd501f34e26029d1a8223149a242121b325b3fa89e230be4f23c8e26a8082dddcb128845ee927ead8d0ba036bda4920db46f50f100d05d6dfc287381bfcbe163ce795eb30e0c351b3afd09df27d1e22db9737d7492b605a69d6ab7620f04c43702ee45de5d0a48c25deebb1effd3bfe2c6f05d06379a0f1b1894f71f72bfa83a585d928cfe74a8a1debb919f05865b00f1eb5eeba0107d5676e141f0de65369ce2af09e35d268d4e35caacc69097d12717a85b72dde15ce42ee0c80182b424812942d9fbd50983624c190cb92c5e24dbbccf39f404db684fdef02ead831fcec485a00cc935fd7723725437e78db1b3e41654ae183169eea4f3f21f12e366344395bd14ca340979d4fe2ffaf3506bc7f1466dce4a794c2d9ddb957c8dddbe58f21f47b990c89dc6a8829f7acb7692d5172fa3ab3ec1c0cd91dd25890ba1b626b3751208eab5e3eb2d25faf58b29b472dfcd6221cf6456552a0dfed268b638ee4826d97827adb499d83067b63b3e4b0dcf99cbd495d7d77022110fb43e7df3638d9281ff8d4d4dbde91680952c2de008c8f125635803243f3caf0943bd9640b2a63335ca49dd3970bf967eea4300d6a39d6507f13612a3fc16203394579ce6599a112f09b33ff1969ec1e506cce9722c0c4426086322fac35727b4bbec440a5ad10aafea15650a90264c17b7231da66b8ef1c175d712b0b1efd36ea046977015f70c3cb54d7c9e3cd7b9db4b21d47e8b9d7cacde2151d2b3c9cfb4fb55a8683fa7a764b56e49246b0015ea96bff91d56f4891aa8f2ead68b67ad7854163bf39fb2e3e5469d4d7f32f93bb48dc5fc57dab65054b18e12b061fcb7a591514f9103b3db55a01d29058b84f2559f7d505fd026437f6d50ede904839beb734162112ca6fe3f2a64757287bea663596bf2247063c6aebaf67b715928649504f41ab039f05f8625248f6883509df23e93951a710909a28334aceb2e97af59bfa3530932d1e9a034addd14a1ba8e6b85d039ee5c0601e7253d61afb47c9dfa4b64d7fa578afdff357779a9d663d44cf1256f251d207c22a795c739238f118f9068ac59c77c01e138393c40559674ef85226d5e571ece8110f9d5424d524bf8561b6fa8577bb82eb771865b5dfd940a5e34868f1d60f9c6449766ac80bc1793d4851deed01cdd058cd211a497446569cc7d4f25f7e474276bcbecacaf5d8f4e8e8e3dd53c339d40cb4d29a9d04e33fe56a2f66fd0563527f31dcf0c8f183023e647993a673ab80e2ac841a4a61cf5ec59a7be5f9c33656cc6224d973cc845c4a7c4106f0902b3ff7af88fd814d5bb030a6394125c1d2bdd52bbdda5014ddc4af1643c2e4a88137f564e49eb7eb909f0f1de70b807a7856e3f45375be1d46f59cf51e21c5f667c5a049b4133e9333e76e015c639e6a1d686f8d9d3f666c87eb11deb8e91fe7f9f3da7508fb311425d702b9996737845076bcf192c8e8f14ee518eb56e06525d9c4cc3ebf199d0738a026e00a9a7d4b279ec2076f1f1d7f71a3c779354b470335441521493ce6a3798f3cee7ab571ed55b53b9b821b92c8d62363c4bc5ba429b139701b3741d32f7ab8b22e50a9a0a2b117cf62bacfdecefffaa602d391932fe6fefd41e53083623ef4fad11383dacba40eb5d18263e18924acd71e46335d5184c21704ac5bcc9f37ebc5718808009d7e1b3061c4ca9a0ecd058a8d2d0c165eab126407235a64e55b330cbbb09c4af973923e8bf9574e111e5fc5e55ec3a7636d13c02fddcac8962ba332652d4a31bba3a14479a697dcb01ec247350e2c4c1bfd0550c8f05110174268ad2d89c85edcf5c282a72df7c96f92cba6de1967a61bd15d521113b00fe0906819a55c4ffb93f48256aeda16e9365be2bf308d2b57f7edb8db4ec95deb4faed013c3da6383430e3cb1aa2eccf8e693dd027967820f336c1142973e6fe8711acc055bc5fcd6324045cd410f0045ea3b5276363e1acbf4ec7b566f477fbba1b695ef0d0d383f11f92003de914d52c5fd940bd303e18b95777897596b5e35966121bba32cab25db3b27887b4a2c5405260c0d1ea4329391e57574f8ca8962ab66bf5ccfca288b69bb861b1cff315e7654a085e1020d7ef37cb1f4a1fe11cc883d72250cf655c5d5c8e34dbae920b5cf9ee4502c929cbb02652e1bbe6eca0f25b617bf0f986418c28b3f0179f130e15444473709906c8bd05630f468624911d59ddfd31d7ef59b594abb556c01325bc42987814b1cfab4f4d438db0f66066ce89668104838f834dd4a87fce53c8555b986b8988b8f7c5b38dbba6c7e7cbbfe5137bc3e633f823b0a8bde8087e8d30b7fbe5fe68a06b7dd7540ba7474c45bc5294a58676419f6cd1bda29ced8c62dbbcb6f23fae37df7c05dcfd296ef68c9bc5bcbb53d362ce147962a605d0151ff2188530cf55d90bdbcfab4caefdd4c55171459d6d170afb97a4b82c73ee80fe65549dfcce54db0852bbaa38fe7d58c8f7bf6fde43ec4d80923c12dcbe64deb04d2d1121c792f4ca54c6699b2cf73c79bab1b4b92e17b08b2e34f7eb60d2c5efaae368a6dc39cc304a72eaf304cac363e658741c23f89aaa766f3c2434f6cdfbb4ac7486d5dc22b4eaf6909dfb6538736101323ea1db3297c0c5fd74cb5f54a1280ae110678e4798608fe9985641a6c6c224b8dd7590a7ffeea33a1688bba405152d093779302c86d50a289926455ba47df6973bc5fdda83d321202d7e4e0b9c705638ecf8032ba1616adc3b96180b55139db6fb1f314fd3368c8d8f75e550c6f556886d93f959efdb55f024cad8806ef04bc9dba94b4200a6e8ba9dd00fdfa5f04d10018ae2301fe5f00f564e5d6a54208ffe9de9b0e6afad88434fabac51fb1d4a27e06e17dc1a164aee5d8666003c286ce2c1b323b3bebac31bd220d037b487a5b4314d2213c271f8d4416f3a921faf801237026e3bfb4a8b038a682e5995a53880ab47df4a56ef9b99d83788f05e4164f6e07d31e573cbdb8ddfa3d1b7628aa3cd025a6e7622081b320796a415474eba6740c1e66d7290dd563868c147370aca20aa03c51e5448a66085364ed3cb5747f58e920d2c48cfe9c4a7d20ea174f2d84a1fc48b34f8fa79d165041fbbd2027c0f5df1b0af9d3c532595d72166d60d2ba2f35a614e86e8f89c6c577c37d95b3b969fac3d9d806dfa196b1b971f171ffc95cdc1e2559cfe0a998d5aec4a2048c34c47f0afa68892a44bc77213c66508074fd3778e6f3e3ba8a606b83536b18d758126ea9585c00361a6a41f13e2003698f4dda0c4a2b295d6d87bcad86aecee24ce01bef896494a7f07094d06a6dd2072bb51e9e2c0b499f8e2d695d81ccb2fe950f50e74ebe4cad22af6e092ad88317b77cef42a2ebe9634509c3c663bc5d4d2bd27dd9047e898523b9e655e8bfbdc53a620d8a56fd6bd143fa04be15952819b048623066e651c7bcf2b95cc6a0a92db1742d6d75d9bb2e84770e1ade3d4022bd37dbcf4e164317efcd1c78332640cc972baa4221134b61e1cc7ef2651c32facf404a7d8c71779caa15b0a0a986da9fce85d6dcefa0a502460c2f832280c9c8a2eb5ca32b78a7d1aa1c628ae07c937e64b2a5ab88b187f0cd6a5485638f4388b37dbc76ac319ef84b46b13058428a06724a42c94bdf5af3611a3280e9e2c74f1114ed97f29de24e08e899927bee2157a65937ee3f9603fc6c161c4feeb5b625d93dad15317a01b2d9bf5052a892a145de0655a0a3657453b1d0cd249f39b3c85b069adce17e1e4972dbc90a34cdd21641c891389d5f1e5bb0d2ecfd2ba646144571d5cbe6cfc82dd13654b34f291ecd0f25833d3aab79a4b403b202da57a8e586a9894fe04f602b7a3571825c9bba6df08431e409f2914c71a835116d8a54af84d16a2398a37772c983092ac0c8895cb04dbafbbab33583985032b02a838038ac76990ac7a7d2733c91e0f9599451be1a62fb382a6f49e4ec8d5ccda4d1b684366622b79119f8ceedd16f7c5f2ffb7a1ee7bf95d14cafe87b8af212076baed25aaa55bb9c4445d9d3f7bf3741db083ed37aa96fb0e11d171d8e58277f8108271c275e34f7b548c0c0ed5a82430eec55e383c0f6af485f35794b79353ae0dedfe15d768bbf0804c588ea2854dea769b273add4ba011affbff275dba83b254b7307ed4bed8718a510e0c9bb966fda2d16881fb7062d728764ca54e7d8f08464cb002a8d495c799eb6aba6687b9a9ea4c421ef7e5ca466a43d232e889b62a24d6fa4c342ede8b0966d927affaa38c856353d99ffcc1fc064d417f5461508211c0b0fcef84f834435bce193c8e3167b7cdfd19d1160ea685f549f52014c5521b04751aa9391f7c5b08e87e2dc9be32bb7dec49b65160a2f4d94292357237f32e4969096b666ea9a26bb40a06853ef4ae8a6d273161633e5e271e5261845c049e0439603c7055b2a98019abf5a79145b25bb26032b0b50b88ed5fed6b3e3f485439a76a684722b786e41f13634565b4093d6e56cfdacf96e885dcd2f075e5834fea266b60d4f63b1f2756837c5be28adac4f70d7fab456526c6f4f8417bedb44ebeff1649724c98aff1a214f08f0036b697db7dec4220f365b26031a0e702b7813ff428fe1432b8638372015f3ba1e5da0722b17ab73d473fdd2345b7abb9a67b3cca90d90d3db40188a6cc61a0c3bdac707458cf4df9cf59fa6506059f8aef64f162eac506ccf566be75cc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
