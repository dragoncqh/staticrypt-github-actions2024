<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"574a9de5288db6130566ba1bf5ad02dfcc3e12525b24b77439306ebc8fa30f3c493fbd03b0bf600d0e210b6f0f25ee7fe5dcdb64ef3a8e8dc2725f69400eec0c51ff0b90a8062463cb4e34570ee0e41cc2c3f60a0d281f676c206e2f83b9e52ebf565d9d876b324e0416f34e74c7ef01d4eef3a9155461448e57e170e7428fb798f89648ebebd5b0e8a4101f2073ad28856478fd75f58adc9eb13524f3dfd56c88e6d3d787e3650ecf209cdb1989d595b2c402bbc6719b42a5ef7f38c228da10ab67ffbcb61aeffded07455b4eff9df075bd3bf67949554e5dd53fc52ad19737826ba98188755931bfd4c1b69e75bbe6c882627d561a6888bc4c35faec9b20caf014acfdfd3941e3973fac4c3db4e78ac60fedbd946393cd9729adec63d6041422cc09736e48e298472dcef5f6b298ec2e72945f86ca88a87bead671d151c9231115bc3dd9d2453cb41e24c5ccf87bbd7846826285aedfc34b9befdd3c37051f7da12ea2196d3d8758fb038ccb6ec6af0363746dcbed2c15f0c6517bc49cfce8c1dc2e2dd787e86bb899b72f1a0152f4506b0eecf770914d378a03754b9378c49653c33b9530c89e8154d8b9a8c8b46f8e15a50d0db566fc8505626aa6c2e537176f3754bc223b7733fdf272c1b386dd40a6ff78c7c17872878396ecfbeda424372d9da1db4dfe8a57d4805f2fea1bb7493009e4763782c01ee2777a47fb0de9e89cfd2b4563828beecb3b2a036d53d2a88e69726223252d83c1108facc050421c9b1613c34d63d27f36f046c3eb1ce42499f0612726e47349bb4c710c07ea73fe639d02f3830146b3ca23c545372577ba0ea139580972b82b4cfb12bab8a2519b5367a48197a41744ddbebf0e098228b4bd4c9a19dc072c769c866757ac4fe84c4281ee589661ba7772a1e1c61c39e6240df99a8c9b482cee9bad8f3e3d2610d818025c252d8c1b71dacec7b51a92324be9236831a3acd30048ca29adf7f09817593b0d8501419c48e7108c13e0fc0749bb31579dfbb79181488fa783eb549e1976af27b2db40000b4259e4a23d458251207479e6e07a83e475583687084480bc5fe774a3eba5dae7dffc214fc019d424becf42952f2cfe362615182b3bcf5b77eb40439f35525db9efa00ccfa0f37f01ed8e76d25d8d8fc8a6c0827ea63e23c09e865b56622e9a3411d9c4f756ecf412bcff058cf594a115b696d6a3761139b073ee30be6f02c4c5eacfd2db15b01669800edb00faf9487af2c7248baacb28fccfd698b7b98f331f35327f4030482a5e08c485ddc1f832161b5a74aa5fe9e38c3b7be313019c184aac852afba3d4711eabf6784a0d8caeb278aaa7e644d91faaf93b1004226946c11facba824ec59166f4efb60c150dba6b78b5bb3205acfffd96290635b707ba0fa761492c0c3da03ed773e49fc78934a52cf934f0d28927ae0ada466708ef3fe423caeed22d07cdb34f94cb202553ead713e3a4200cc4532db44c2e93618457932432a13b3b0eb5457183e7680340a7dd06030f69a7b2ad69533ab77c06e8c97dc82fd63f7bc19cdd5f68837837f1083f007b728c551b68ede48147c64669d0d9e3af1e59772a3e3b12a1eca3c0c92bb19cc9621bee89ca8171ed17a44f02c5ecf158c99ecebaa12e9ef9d7d7efd2d5cbd92091ab94de8fd494f94ff894d4889d0b34327324481111b79428fad514aa87369198348877b3562e2cdcfa532e9ae82c280e8a11def14756db5b44bccfbff060d15e0a435c16f8ecf09831f2e0f7638dfb20ab085fe9ec4f023c7eb01c84ff9c6398b343c06f51d6a10f5e237b7a2287236def11fd0db17222c22dde124430440a03457eb674173452dcd3e5dcd0600e402cd372e836a9042fff512c38600a0e3912e6ef971a8ca6716bc952d71ab04a4d5671e08fd75acedc8f2251e66b4bc670fa11291ecd88b8071bf237e087dde659c393387641a28c1f6fa59ec7d9fe8989fb59e5d9ae827c5d211d7a437d75e9f4809cb636adb695f8ff5514057caa923c3885df48dd4e744bc42b8ac8031895467577a6ae51eff59c2eaa4cff9c8c1cd6c6766d087ec4a8d43f5600a641abfde1f1c854fcb81abad0eeba1dbbd893ce6ffd2c486a49b855448cdd8585d4075865e0898d74fe3259de2931d17142e1b41cfa5e85537fa8b3d30a94f6d86f328fdf4f7d2ebf486c6cc9fc8710981289da567c4deff9989dfcdf214a829adb491ad3d9746d18cf99ad69f15f15cb89e30ea1221be37de57d310308ad5feafa33f53fe8e81f9fe5aef275e65a013c1bed838834e703a79ebec07a47097b539e8695d3c8935e782d10b7ce5c61d22cb45abfd6f8252b8a98d5ee31aa2e7c0bf84bc30dd646bbfde9b290eef86d03521bc77975179d5529b10de757bdaac96e0b414cb451bcac877d1143b8d81a4d6c2bfb15f8697020f8ca11cfbf4ec25a0c22359d13c589ac638e078b7314e3645e085cb68c088189bce40bd63989c14b806f2d42873e7b748afa52d53d5b5c9cb88d352635ce0fb1f49fd0ff0c72597b02a2f73f94e24fbd7c188cebe5de254b3ffea996e13d0c729cf7076ca58044ff6ad1f4d0b8f76afa67abed78cd1eae7b5b80c585caab5f84046b3326ff309a9035c802b7a4a24ffdd5a95567ff31594ddb9d9fec995fb497d2d8f5a564b319c453c9589d41343990a0dcf0f032425317218b29738bf6c91a4b0da056e5093121e8c381ea3849920f8fe6aaee608ea9cf31d6f602a0395dce19c4dbde91897e0fbc76c57887edd7d6bb7291abde8dbc231c1e30c47c41fbd46d42bfc7ea169dfc112ea637f55b4252ecf364d2434c4e537a6adc403ecbfb6a8009ee4e8dfa4845256ae8696258166a872df83672b40a34ebc043d08ef40a5a72a3f471e379107aeca665d0d9b83bc2519198687d93a91ccceb201298ce060c23f2762f29fd6da3efb29936675ed03caa928f3014278006007b79f758bb06b4d10e5afa2c5a125ca84cd7a7fbdb1149fb96e561441fbfe936058052c191077912542a2bdf5d991bf2eabac8321db596f26fbd778228f51a6177bcdc3bdd8cf78317c44b6b4971b81f589f7a84ea3a492fd5e4cb561722304e7f1a029c7a85c9ac25ece792fd03fc381d624b022eb23b4ff676c7837d641e5dbdb389c341c75316884914a8d829e586c6fa5bf0376e99aa036895582f915f098d1bb6928a12a1d70d217ff6a261f5a4b8c29638570f6921ca8a2cdb2ff981b1e666efaa89912615785d44248ff3eacf44df42f8f894c146db66dfedd3927483347d532e47101bf46552ad196805ce3029f081b871837c3f6a6e53ae1db8a3bb5756e09bc2b9028ccf71c0f331c8471fc2d79adb8c55a9195d51b81112d9162346a77eec9cabed30ce795e1812bb45dcc9e499e049e0900c18c35ae88d43cb684cab3e1ec6018304d31c09a1e27304a4ad506db2bd7e8d69ce236f6a145d46f516174e194c1bc4ef5c86b2d1da41a741c6c41b45da0af3aa3c6a4825c7d0422ddfd86f4e161d0430850cff09d5c0a9494d8a17dca2681610ade30d41cd886245dc598fdfb7d8887e5b5e3eb70978cc541bafedcedb3ed240aa6b6d305ddf64a39421a289709b77c857bf4367bf2f5c16251253f06295cbd0f105920379661fe492f08aac920bac4f8e4ada49548efac26105c1cd98a844be666e0b75e3417fe260019ff6d4a10b4301564d83e88f5fbee9930ebdcda7bd044e426f7fa01e5dbd24cb257466355da3f623cd79dc20caaf0c4d9177b155568384f6ddc51434fdac011805a27c08400fc4b1c6c4e23835e47911a792bea1b39b4a4d04edf6343dee29cefa7cda5c5942cd732e05d802d56078815c710fe0a0521b722bac981a7691dee57a0d03d65210a682c5e7cc350efa46229c21cf3059ea9eb422987fe6680881a9cd2656aa9b988587b58b9756dd2fe4acd7eb342b957164407cc290631fe880e542f99fadebdebf430c5615142604192edbdfa5402b7ca5fca3c51a09bc9c02b9a34a7c149dd8ea57c0dc29f8db7127a6dd9ff64617eda4882cdf0c188137b21ab74e876858704ceeaf223b98b73fe29078e19627f43f3044289dfeb448e65b04ce7bde4d48555f6d09fd8caba58048df9bf12991185e838f26bd2547b7d8be573a0eaff2e5064eba3292741ac44d1037d8c356bc90f8c050c42d84e4965933ce3656a57ff59ba06b0da13661b65ed60302e0ad2cff71c0730e8f1f9949e26ff5286cbec779fdf1915de824dad02a6fbac853bd545a3979d6cd5840ad7c71c3f1325f2f9a04663a9bd45f79725954e0d927d314fb4bf4cb88565b9cfea7a51719367eef38e472b8399b4cb83d54d7b2f0ecf28edc8fefc591e0ede0f1b65f216d23c21acd56d64c51732b3d47626ec9ae6754d137e90981526df6548453ffcc82e189bc915e2040942993f5d2d0974c0bbd533cdf328db0e11c85d1ffca81f9091d49f4e06bfa6e247f5785f31ad5c86c8e0ef87b1bba2bd8b4b70379a7a3cddb28e859f3ab2f9055a0eb0649c10aa5e02923be129ac7f9220cf6676ddf1af1ec2893eb313637f9578627355af87f73413c28d061212c6c5dd9bfcd5f7e07c3a68d1a300ede3946e1e794762e9e001b10d9c628bcb24819ffb252f138f0f8cd283d5ac9f22a4db7d917f2294c644e3c5ebed429556f871e71cb3961bd032ac71af4ebb6472e93702adec70517483be19b9253383918072605d0ba03ec72840a825b7ab686cfaae5456cf81cc6048811d6501f5a16642a6cb0a9c5d00ec5de7a25db3801c12d4537f203e9e4735626b2b2de422252dd9c500d8b796acf662e51e9b64210721f01fefe52a188402596ff570ec377050678be20997e721261680f2f50c4b850c910c4c9794bf792d9d7d7f607c79df346faabde419ecb0231a71842f31bd87ae39d7923733574f16ebcbd85e6f7b0091343634f65d3ac3019d4bef7948f2f6a7f3d63809e67fbdb4e87540ee4f8e58e3f62af1faff376cabe7f1c6c75309e914e6a4369e66ba0ee6ca4637a3a75d3e94124004f6d2a78f7f416387d9e4a1af1257288a727bdcc3077f77eea1017b763192fbc5e92ff5333923de9f1175b7ab1e74c33cd602a81625cd93ad0171885b4fee37b9a8fd5f32f3cde04de13123451fbe1ab8566ba1662c76fe87b8fc8224e511778d4c6570a009d98853bacf8cfe9db38016c3cedabe489881ba4b2d26430874f8bb090643cfbe0b56952123f7976e6284e4c74785e3c04576e4d37b3117e077c2ef8d5d68a2f00d77d8d863ca97cad04d93ece7af06170117ad89d3dcc4ef05c3bafb2c77ac4768de0bd30a38d8c6f5b41c6874c31286a08b96ab46f572a9d2416b14fd25b5a60dc4f4a74cea93953a5ec644ac4a2de3be9c21c431e3fc53cabc8692620cf66d3d31b50c3e3ca617e86cd7f0bd1e6ed393923dd1f0551e7b0687aab772b3d4cb6d4ff6f9fd5f015bfd31bedcbc14a8fc7d42a5c6a8fa9752ac492d5d4888c2dc8d0d85d83e5adca7428126ef4cdabaa6a92e880a420187c9a3da816cd9bfd4196c87bb0096c70c75e195cd669963d3e4104253624df2bc4d352e43858a03a8d949d80a6d1049297ff4cd0337c1ea320b025aa6ee70611d98cba83cac59ce8412a5ffca9742a342e9e06f2ff92a979ae43668f3f5d411419b6111d6fcc8ae030b493dd4c7315a93341cd196de14c19a2371f3763702809ad14236e41641f66784d0022944b8b0b1cf81361e5d2677fa2ae916821abf07f9d0eefb0bdf46aa2633833cffdd89dbf3b17d296acf35a98b463b9994d2323a406610a9e2def08a0bcc0ec7fba0da5d6247c28a1851e2afe1155dd9aa255674d44d92ab274bd03ad308bace91045e3ec0ecab9abd50dfd28ee0c91e1395e2219f08f15bff209283873c267de4c49d205fc3f16778d8b8aa20ef4d811ea2fd4d2c400504b164d747dc4f5b7dec99469051c2487706f620e2e9d3d2e9a80f8b2caaff770ec780b3e896852cd50417b82d8a00bf39dd1b07f80354ed1e638da59ed8d6ada63a7323b624cca65d3ed22e933eaa3c95ea161f12b350dd6312b5ec1209f3cac2606f738322d859ca02c927dda29dc856893233c4a2f87f0c9c9f39b1970bd591709cbf847f523f596519ee6d41be931f74a5783149f2811a9f522429685e461ac26ebfe2cd18592343c25aa3f8292da58b796dabe3e1a8a1b05b2feeeef814a16971d1bca69f188ae7f7bff821ab78d9336f5ba8f7e53116e1d95ba5c5c94478b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
