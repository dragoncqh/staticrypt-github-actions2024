<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e511578d1a68bebb1b111719adfd1a73ef810f50cb6b324a49b2d050ea9ab3542db7ef029fe3fb2f6e00bb7ecb002a6fee25b730732af934c94e4110480a425a20ddafb6e2a3bbdcc886d4c6e876c63ab381568a663535ff5e46098c11394aa8665da29b0d31e9b3da791b4224a0e1ef2a499204f845124b0c34adad46f1a8885658a89e462af47ca3433be9e023673332ce4270a3292315ba6b28b59143979f017c7950b0acff5bdf721c0dad5cb99338017829dadb0c723054a393ca1360d81547234aa81d8393b38e0b41733ea653072ac4450cfdbf64d6b9eda7d6e252fef49d5fce4cbde22f8ed2991e7fe664fdaee3be5eb4ef2979b872fbc59654854f27a2135b4f5bf26911095b1e7ff5bc83b91303c1834fe218e92e3d5175b8bdb77370cb744bfbbd0ea0164696cda99ba426afdb66e376b8a211556ba1ca0490f67acc632582203150e3c440d41143fe801c1444a2851e0a12395ac122942262094c7229051b7ec81544d601d43675ea01d090509b909d2e70b8a024aaadce4fbbcd8805a57ed7551d368a59b1185e5c79838300372de5593df6598d5d229bfe4ee8c156ea1fa40aa165356e64db6199874e9d1a062f561c3f11fcbed9213f972e0d368bdf85d5192403ecf26186b2d61b759946588d7055046f41419b7b58a1609d24044238b4428b7a6de7c52d9c56bf7ed38d7d44f0b51a99e23a6e1a44bffe66529b3e79861b36a2c277fed64e0f280c17d64385e51059d8a104bc3b5bc41c76b99d09586133a3feb7fdbc7a00df09b93f9a1b59546d1494bb4239bf3ece6276a044a3e40f6c3a2e6bd458a40ffa5fb9e1983fe86a66461df70a55411f890bd8cfe4cb2031fedf3a6c1c4c55bd9777e375ec24bd737415616ebbe193db3733e75d23aeb3890dbe447a3b728b940571fb7a343feb2fb48dc9477b50c7a82eca64f7d375b8ace3d4fe23951d875c51d07fed73b289b29f52f1dd67bfcd840e2aeebaf8d780d123a692d8e5dc0f7b337f3bfd6ead41656b05d8fd0a30ec7192a59030a3d589d99b125e13c0661d084b7b1eab3330f529a95f587a34b6f1ea2982544f5db8aef1ff396ea70b17c5ab4b571e59de1577e5ebbcae0c915d57216026df2af6511221941251fba523012346b2e3dce3326d7e8944cf648030e6e06ac3ce5e91ba87c026d3ebbca7dd20bd4ebe28fa82822bdef6a7fce0be984cc706f5d4a05bf5ac0c7d96ae1e8ab22724687ff5eff138ecfe55da67056dfe77b098d683915eb6fb2b775206f13a3e69ba4118fc8ca23cf41ef3131cd7729b6d1b2d661ff8b727cade27ee3012e7ff51ca262f1be002a5587aad540fead0a5974ec04a1436b94619bd254db410f588700b1e2ab765103a7a8f6a6498965a956c0c672138a5da04ac7b01aafbf19ab9945286254190244e3f996e8d68269a527fe96a6d4ce114b69f19562e2dfe73f4028c7668dad44a8c1e9b0eef549ea76dda7bf4816050114bf432e6c2936581c6e8c8142f64d64c63cbca81aaf128e4c030191533ce95e35c56e6c7c1c0431f727266438de167d8ab4b94854eed63ef770ff9847c5ad8962927e6439e0e6c9ca51478eff3089c38cde35f319cf7260cfc36df290d361f3cb593b944016dd34a2cec0139f44aa5b5da9c92321082939681faa88be8cdc9dabd4954299b13a182d2aaeaf83fe73553ed0ea0e70e79c57fa4c3e9f30c279f7971dbfe81f0a5b9dd2f6e1a936864986d1d92627779a386bb61bf93acd63ae22335fb476c5439390f3b66759a129d8cbbec3e3e4b5f3ba32a7c2fed3ce26dd0233e15b5e9506b416acee65cff520968a2503f9f51159dc1f0bbdf06b28009c41352220aeef77ad7c7e7d7cddb2f73e935c3950bb0a2f5c1546299d6be57bb7b6c89276337da82179ee2174d78680aa437de39093e5957275622bf8ae419d5e9e32b51175102fb6998398e8731100a28765894f195ff2a3d26952a1cafbb574c87df8e6e3105947c2063d60a4e60195be7e4a1c8a4b6f0feeaf0bbc20821db527fe6ea02e8006d43bdcf21eac22d34b00e3bc3d3b5d31ff957442180bd77b7f21c1490b05111e9a357c3a66df4938ea8cf8052c0c8676dc4da0e6f119bc3ecbca9e4c960ce2791f7890c852f7b9a053513f4668f97b439006f237c15c48c27c0b95e5e4473439e6e18ebd0d172c6ec5d9a8152ee3ac17cc4b79898c5df6ca62b9502eaa3f6e330acf0d9e4fcdbc3592a424b0eb54915cc77f991b2f6e4bfe864b9c545867d538f401053779c220f36e8ed7aff9a544127c6aef60722bcc7bfbcd227befb7b740e888b613b406495f401ce1b86b95cd32225f6ce91f16e9387ffb50bf573170ab15b28d3ed5aeb55bc8fdb5c46f9aba034c303fd5a97d175f75e36edcbcc3bf93592cd5502b8f40068399e5bcd6781df2ab8d8b314800d29907c931456518bd3730df5cd3322a0fd57df9bcd8fc2218e7f6b81de80cca14c04a7eeb2bf453dbd65b38f2f1fd36f9bafe1ace2c76c5ce1853016cbb5bae0cbcf7c18b86da2a8215278cbad3f666a6985fa0443c99f291bf57ee28c279c230cdc99f4c01630cfdb8a1eef8979884abe471e60f733be4d9f17dd3173e45c8cef243b0b76b2aeee000369c076141e76c2a742d28a87877c708e45ef14c4f6ed2fd7031e1f138c3bc636603e44a20b5dc5aaf02aa3b69929bb1118c4eef9020ee647105226e019ff40b2145dbb8e1c534378fedde3f3540f58ac3be224dfd04cfa92556442d3618eb480bc8affd073d19c7e05f9d86fa57de17ccb5039781f054dd5754c81f4cac0b3fbf2dc6756158659f90a3ba4e214fc2d9298de949ea3877f478fdc989a2d364cfb847b777c696cb1853329706f947a581918d64fa386bbe54e1751ef89611a513159518a39a41e8361a715593980ff370c7cfcca18394fcdbef0bd5cd9bcd95d686f002433d54f632f3316683f8334aac918ae65e044a2c3ac0e347b04a65b25f0aad484eab1525033cf9720ba37a6b1b96d2c2d27263aa0a6e1c2932d8629b34d5c91d490cf0f3c7ebab7112e6cbf9672889d77deda8a88ec3d72f259eb91a98c8270d6f9a24fbf6087efbfce39706eac6b97180bf1cd1ea04fbc2fd0cc8b47902d7d47a7574d3e8594203130ed55be9865135a1ccc0ed7ef749a4d131d99f7f0f268ac736894ead815a6d3ee2159232e775816139b6274f3ae355ba1cfd4e5b97ad38a9f5db95be40840b451c2f9d4a8f3c2ad8072996b356ed88d4281663e6a2f262de058c1471845c804ee4c36c76214d3ee1a87cd8c496237d208c06248945a164c3e53de5c0e471b338714538c504806f86f6c39bea64feb32bf99882b618093f016a2d38f7d85ac0f692eb025396c99f5b2a201cd8decef2bad66b589b7bcfedb10516e584c85a27de0deb661e65abdd079b188a532271c0b2e906c0093b95075bd6de1a25161cee7bf07b5325ea8dd69861137e854f7fe8a63dbf9bc12470d8a936c3bc79d93f5c2d89d595104b894155b9ed29cc278c93018f82252699ea5ef74a24d6ecc6a317918a32c59bfead6c5eba55edad03bac58bbd5bd2d5978c078410ae348814f1e964b2c4ab6815d72ae2ae1d6bce211c5a03409ee0c8fca074b369f39a2d460fe528d6e1b1fbe2bac86e198dd288a4c75ae1f13cba85aa12dafca6aaa1d425b118bf46d0937fa6e248afc5b6a4b3312b03987f61f50afbea6465f43e5872b3c92148044ca8b1b4c03c96e12b0941a24ef78fd3361cd835442d230ee6f582e5da5bc5eeead1bf29d75c9dbe1484aacb91ad3ec4ac56ac52912f1ed505b63485dc080a87cc173abb446ec3474a56515618b5a8d44f2a4d63ca3661273987e3b7c7251459586a206d8e9d86337c3b445d7533a14db975e287d068c8545f6dc316a89ab20a3c8081447ba2b76c84ff677da2e6de13ce45d4a0ad456c91f13da531d1a9482cf64938098ba03353c3af7f215f5bcd253ff3c70f36c73fed2482da823f95d7f417c5c07a5c0292bf635baccf3538a4d20196a136c0dd7052a5769322be9dfde274e8e30eb28c0e8f2c8def476a3ca1435979e931036700cc7c21b5273f9fb827be7641ba4b2493d14ede1a6fe2265d14baddc789bdac93c4dde50ab4c3158d92b621573aeefaaddc53e8628162f58b9c1b49a1ec013cda5772953e67aefde39a3d502e0491d6fd740c87f064bedbaf41739d849f89462d0a59f0b3acb21690da1b29cd8bdfa8b9ed239e7b78a10c5172baf6e722cd5ddbb005b15a1893ef4b4f6749d0e518d72b494d1032c3f8d67cad3155169b1bd297a0a2b17cec21f9071a48a551ddeef508b3989caeaf8db3f79426eb77f7ea1b7a07bb7ebf5a34dae8951c407a19edaa56bdee64c2a9fe692a09d93a3915e7737af57ccb24aebefa168d0950e2beb7e66c3dc999a5a786cf8737a1a4511265cf704c87e04638fb662474e1622df4b463a03c658509b9d294140ca7ab91c6dd41ba875a838d75446bdd9e249ee47e05490ed908f05fca16f7fb38367f0af2a9b71313252e9cbd543edc506538099705833a868f7dcb61f6038918dae9d7212f779a108c1e278e839e6675f81d0ef525549bc979786918c0f16aca41d86f4102edf02339e2bbe5e1212850c980abb781ee62da91c2b49931cd68305f0be19eb25a9707e545155eba7b4167d206b2e5e6c754517921c906ad841f2829884a57804b593f757284c3b1efe894afe121b5d8e9a655fa1a6f84c3e183624b3f2e2556156049cd3ef1ae3090029678dfca6f5838520e40723c1a72071b2998d7c257452894f1174883d8cfaea7ad02cdc3c1fa32d7a2343d1a8e319ea7dcc16678257a611b4d0d461ddfea05a5fce9e9f4d15313f1033b804b2154ea7d42a87ac5038bdc19ac2e127d5c007b494bd74cad8425836673f555ef60056c1f6f3d1d519b4e4af8c06410c7e432ece05b029fda6dbd3cb62272680218487897563d57192b890158e2e49cb5bfcf4b804b4f20bcc21b494d008ecae66dd5bb0f368fcbed7f0f6436523f78739e0fe3cc2ff3436df75d848f6cb6f4287ea5b9863972a41beb9cfb2330caa386a73e27722e43cfafb53b6e443c98956fdea4e31af87a004ba7ca4a89b3a11859d568e4fbe1a9269d54adba9c3a3c9f0f7677c494ced6048d1fb47b2bbfcebd6c9c01e6a1abce15dd316057aa11fd9f0d478f30d11766eca24621bafdf3fbecfe473838beb8f7db3201d1800c42dea4509fa85f68e66100ba60df98b9f6ce5b6916657689332ca8533e458a2ea5a61ac44f86eb3d52feccde34254b39a946d1b1a0bb3050a67e73d0a2e9ea279cae9e871deafb5bd6244a4dd3dda8114285b38156732e45053006eeb87306c43a9732b5969c15efb5bb5333f31a78de826435f6de195934de2d8e776cf93db4d1dec2dbd01573563f4c01848dea7f8af1af1a89457e44259cf1bee457ef68a8d39205d63582dbc3c7dcb00e4f3439794fb77bf463d68338e21767243baf5d5a69ebd423b327f89a809193ed77f4b5c018d8f144eef01db1ff047240b67a41c6ddcd7883ef2f54b42b9ed0ae7a3a51d44ea90bf60d96f7ecad1b99cf3891580b2fd3d48053f9d68e0f8ba1fb6a2d32681f0aa250514800728b1997f934d897172708a85ed6f891969fa1ae4434527e5acdaadf1b6928e62b9d8112a6c2edccf36fe4627a5de4a04f673e778c146a2038a1d17d4f6cedeb0de103824546dcbc8f532496b89085b62e95ffeaca157ed2a837928214740f8c1108ee1f9b8495a73b80d0c551de00cb45f6fdc64a10f2d476794eaefaf533a097fc23309dcab38803330a6ecc297f87f89daabed1430dccef5fdfd600a50886c65846373bc93115eec53021f5d6d31ffadd449fbceb67303b0f23ddc5bcb01beb1cf732bbf54b03652a74f74b5e58d57a9fb9eb81ca3c6f23ca47f794064ecb09953a485ab191f464d0f26deadcb0d28aee66c03e2b3a68a8232b6cb4c0b67022ff1e468b07de5b6a17ffe3bf3456e7644d65afcbdd6b63176da72689add41bb24c844b302faece07ffb328d964dc22c8631b767632b5c28c31709bbf4b494af771d27f593ad85b967c7ec4fd32106a0f4363d00d638d791944e3ef943b144a0f9e452c0399e7c32f8b10d2ce11fa7f973a2bdb69825d81eacd09ab507471487e98048f0777dc9d9a092ec5b163eed34d582d3cc7e272edf792da8635fc4d1be58c10a691c31ed99d2d811d26d19fb761e31d92c62afc96d7ac75c3e7832d76d3d5242bd397ac90dc0f0f94185c336f5f2be683b8d6bcb41ddc7178dc44b20a027d5106e341c04abc186bcf90a4b583b4dfa735889bde54dcac574e6a9996559adba0d4c41cc77538c368d79351d61efbd828222aa7ad17ee8ecb41050d24819f9c98c393acd40393e21a89be09451bacbd7c9c456616e8efaf0ef8be884b76f0a0d3a8dbd8e0edba4478cb28472437e31f738fd8c87aa02e9d5a0c2943c638f37c4701f6f14bbb8f7d2174352b9a0da397e1e53f73da91c7ecc9370d3e9ffcc6dc3c8d1e8e4496840bdb85688e619c32b3a2e63cf486eb9c3672c0beb4cee4d9c46735fb610bc7f5a2d77118685391a49ebb4c328571faf88d2c1e8b5291cbf06544d64833c13cc8455574997726065619ff9c9c7821b08bb6eb84c9dd545fcc5a13ac5f40d359df3badb52eaf2de3d3d66b579a3cf0a1623957147c251e20f504c43177328793a15b2ed272148018a41fa7ce623bb03e237faa3d493fe331f440ed54fee08d41363f0a284a88f0c06eb1801834a11cc58a51a5385d050e0b6397a85143c084e535374802af1935406f083cd50c590cf1741ce4661bf32c4074ddad834c13aa1efb546816a8b2eaa6616058808595e0b7fd7cfb5c75af9c020805f1ca1578538978879d65a0cf068fc20120f16bcb85e16d3ea1b3b7eeb857bfa34d242a9656e41213a6b270ca294b7ab07c330fd2dbacc75331e02b3948dde5c679f707acdcd25eafc4e9b9895289b61ec2bc59c158cc70a2b7872986687d9baae0356ceae1b5a64fe8a924264e1f5006d0c77633ce267aad013df83841451db5e5f4896105d8375f931c8f6e1ccc934edda653b6b94baf8ab18fde52d5dce3d72b7ae18f2e8ae580642a2f03d287be1a21e657f5fa74f99b140e7ec358c631d9d7ada22d6c0e4447eda3416689d59e2c92d14f5b70d9c4709749a92987bd1b68002237b641df290fb6c0fb67df56dd9f547d39d5ae8d5c330f0d27c45c8b8f17d8ea595953410a9b527fc1f4b75246b4ccc10a8a154966f18ec7e7e0668a9a313bb50fe71abdd7fa54f4337af00d9bd4f0fb07a412f8c95091644f7cb62a740667e035580107deef18c9bc71fe3af2d96751a5d59779c3bca96fd7197482b83d5d9627c1e0b4f31e92310e37fe2ba15a706e179d5bc41f8e6750b0f50a2d21bc4bea4e6c3f1b5cabcd8081254c737768cbed945034d1ce2ec6a19204b29c11bdfe795a467b9c2377cf6b240a3435f628145d48b24ecad3fbb9e67d6de9614ecb0b365c63e45da20692c9a91fd2286e9702c52ae3df434992d68f27d2edce02855e217c97747cae06b1e7e53c36d22721b5b4a59c2979d524485ac70b1f18082fb6cf5b7f0780293541c47707c07548704fe3b563c4d1644a0fa1b3afb8e0f09aeb56a03e36c53d49c7065492fe5b1eabefe62d8d474f16e2da5e5c7cbf2a362b1a393ec152db36df8e25cd57d4ecb5cf3197cb5d5cc3af77f0c8996038baca30b17bfcd9aa1ccaadb6cedac03a4d19843923b98a704fbf7989509921da48e1c29189597ffe36b6bbd29b46a27e7c4469de320afb8b41523c4f171f5c333a003a439e223d66f20994ee0e91daed41a06893a382bf7bcc124f8067de31c5b676fb2a2367f559019f8aa5c5d9fe4e0c3126633e8893fb38eb7090d29fd5b902db29e1d3ffa608ae0be67b2edf42497bd2cd5613c74f649dfc3ed47d487a3350118c9ad66e74a83bdecf78fecdab932e7d1071f07d7237fc0bb0023d90b03cf7dd4141697015398b3f4b72e6f4cac0ebfbb0e9ddef49416c4ca94706fdf121a8e62d68362fed1470175f3172796d3a21fe09d24168836713665ed9de2f782d1cd0d0f19bccfdced8db371098aed48f2aa12e45d3537525cfa204490dcb7279f6ea489391e87d1138543f8fe61c9ae5f53f9589ab8c92e9a102a9a7dfdd6541cc48e84a8152771e79bc89c25a2834b7b69d30d40b46c08f39cc94aa50b8ce729370d186ab1ee454f01466ccdbe94887a0360a231c77920e2d404a4903da9e9bccca43729abf6fcc73e28f55e9887b851220230ea68e70ff85376e3e6056a6e8c7eada3c7de91e76b3fac80b4dd15d1d65fdc72db6252538e4c08a2df17c682f6b30068e96f3c00b4e78608fc8ff1576021ed2fa284c84ad1359559eeb0ef9a5c376cb2cd61d1ac212ee02861d35e5e5ea72b48166aed618c333e060f9589243db2c0f15db1d0891e52042119301743e1a27e00a6447b4dee9bfd88783a3d3c00712f985ce5d04cc6c1486a56cf59b615dbf2d73df50a6cb2c13ec914b69e41ad5ca1bc5ddc6b359f5182e85d743c974315975fe1518ef153aec149b839d5044047d94c56af9b8a1a58293ab393a2faa39848ab14ad9d4a3dceb9873501e4c9d4e037fe75fe08f01c92e1d77e6deb603c089befa88948441eeb47de36f64690d5656f88ecf28fba733e4856eb7d5258db50ec3db4f4d3c25b7967362380357a60a6e376deeb9f999e35565e07f4f115a5a86978531d9304edff08ce6e46e3aa578a846985d5a83d839b06672214fba25c2ee0c16d888d195eaa305e3a6e464ecee01c5f961a839b6eb6b96ff276df26ca34d62fc25a26db64e4ba98ede83a48348054b211a49fcaca8bd84cd96ec0a44f2a80e3e50707a0ded482b31affa4f8d995a91636900a84ace99468f228ab9fb39a3dfbaf623ddcec34b700a3bae8938688d5ca6faab6086ded32e02d5495635e631c6420ec0f395b10123fdbc314a74db4a2322d40182945ae5c6e7bde3596eec6bbbf4ed996eec721ae2ab5017aab6df610172ac6afa86047580ec196cfd336cc4ebd37e13462ca21d8ace37a63990a5564a6d93b6cf43f53fb65f8c321fce43b1643d4d51b8a814bf591247f14e79d32d2f5878d5af6290267a7b971d6fec91840f9cb4336cc6ffe36abc7325b531a3612b6b86a2c07679616cbbe0c71557436f1026b30e15faad5e362b22e02497df3604539f36a172db9891136c54874a583fc1feb27de1523cd2168571381db7058a75220e0aafe2785709dd18c8331dac949d69e85a68827542d26d86e443ecc2a7c08959ad31261086be9f6fa2d426259e45a29e65655606d3bf89e7b76db392a9ad1c8783bc3b7a43a22cae0c85733ac22cb45a0ad2a5c6a099e23c0f5f3629cd1cf0d5fee2df89d56f069d471d3905419d00c446501f3d8944942476a0aa915197e3910f67f16576542ffeafedf75c19bb8f75a0c18d1f2913f0794b1f07bf828faab9ad2779b5d3eda71da310b7dd886662cc17c77d84a2a31f14","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
