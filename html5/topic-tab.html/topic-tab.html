<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12ef2d8831120454c10cce7d0ac96af65f251fdd1fe8ea92bc0fdcf73d810969fdf0e38f6215af2b1ef0ceabe658335d9bf44cfae894c9eed100f33240cab62b737c18148054c856f6d87e46503d893125061a7a761d8a26ac31cd8524cac4ef54406632ab0e93961d90f5c370bb9913827d085fe4848663a19787b43b26cf28850864c737993a9b9846ac17ec442bd6c6d53896a68ace5faa6a900925d9d625dc8f9e36e4a175ecf49627bb81e943cecd07b672820319ac6824b192c3b01a1a82ec4c099a269993d1696b2ca986f86e9e9718d526048210473a38e4df9db228c92ccd46686802b92030a17293f8dcd74dfbada5176de468f2c8cb04dd91f04faf74879940976805facf48e401ee9f91f1d0e7c19b61100d9a61ae4d8e5ac724444e35c9cc14f51cab226d76a51ec949268be4798cc81cce22cf767edfea6dfeaae3e0233694dd88914f8ab4338f2570461980d62a43304eda62cde30a5252427f40c5ebc479cac3bf2e70c2dbec0336f7691d7a854d842c2ec44c521870f8b81c3e5f9e95c40ceaba3ae2b39fa7fc7d600b900e28d5f4ecc8837f26f86266e3f176cfa294a17290959f17db21f26158302f3f151db9678ace4a109b724262cc83efedc98732da5879cd1494753e22056789988d30fc33dbea31bd2c4a5fa014a349a70077f70b300d767f9a4c47c86cfd28238e572091c42dee561030fdd7520ecc3bfa4ded38f1ce3bb4d2a776a10a613d5f0b837a76fd80a7a49452ff86e2ca60778d10d8c1e5f44ff78929920e363fb3e62ebebcf780e89093d3021f83494ff5e54d83c32ceaac1a276d0e95c3f8f26e5f69bebee3ee68417ff849a6ad9905a4da25c0cdf43f5ab66620ac870a6c153aedb936d49755e6ef9297ceec8e6fdf2377a762d12db0a5fb72c526efcb385671c9106a04b8451a51beabe8dba09832d50b23dd0265eaa39047d7dc203f09d47a523acabc0cc9cc9d4dc9be60df1715f03efcd6363b4db2d8a0b524186a5b07f6b4b4a26e43f61997af0d058749d1f1ae620a69465cef3868e0fb9acbd2f7f7403139e6e325697598ef6ef1ec53ce5ddc0a91b61bd946184fb0d0fc4852693d97e781545d444c0be1c5466750e3dc5346704ce44cc0818d9dc99bddcef6ce0df440ab79dca9565f6eefb0b5c08a06faf40288fedba801e692b0b851814e304132e8ef4431f49c3adc3eb404e2c125d7f5de147770a5d30761ba0fdc41f35854ced569821e7695d1d3e4a9449f6be79d97154af061930b2797e94c00b5869845376af81eeb96baaa835cef5853258b29568ce0c1d87b9dc74ef9f0f3d1741747cec548345a52b255baa9e671a4a8bd4ff9c93f15be59cb69cbdc9b012e1bd91d8d6059af6854935ce123ea8fd311d273663ed57553fa403e264c6311262174cdc4f8e987ef81fea73cc50b84314b2b077eca300e41fd1e1300b44f78e92fdbf36159d262241cdd809b71f684aeda18883b90c2b7a2723877fa0654de21458ced810494a197c712fded911fb7bd237102ccd26dd022e0ea32881c16ce2761734432b55e25c8986b2f1955267f781da1f0be5055fa69507c0846fb0f1e0e50170c7b3890c78b1b0a1ba3cc8b19734d8c5cca1657c73cc666a4b6c6a27266a9c18a1f33bb8e6b46bc6f5ad78de519a607c8295e81b84f0f568c0f8cf7b71a439f3255a016af7b5f8b2a794343794a833df27b9204a31a6ce5822130d94c7962d2e44c48917bdcf525f94d626a084fe758d43864edd8ba97793ccdd4bd8a0a812546e676b1f84cc8b1a1e2cdae4d0cc77c64418dfedbbfa641b05f1062e00d1417b8645adf14d6499aeb934ad13f07f9a48bdcac8ec3c266d311b06f0d4adb06c4e32bb4f655aefdf764c2942ff3d218949878e79d43577e9e97b05b54724af48f055e30b9809211a1a75d3df22f6e9613f14a8f66e9a46c73e33b0552f361aadbbd69d163e932f19882e3341db8b8446dbb3722c4dd7432756ba7888918f7468e5b81e0e933dab82e3b6e509c4d59092d3502baef93363479bab1aba7856d9e1bac0afe3ce4f5d0f58f4011745b20926b76f5f257e067d2424fb2450f7f2e1347884b47573fe034f6a67ea8f46d173fac843c2cef2feb38ef5037f0c0e49a6ce7e7733840620d60395641409a12a2783e3757ba5e69b8102adaec6edede898f777b35db5b915bd3948d44525457c5e9ee445ebf2d25af6f2c94e22384fab09b08b85b49b2e519ba6d3b168ef9810da5d914d2b80be4e12802df2009c4159ef43183ad12c24f15216867e4319490cf10d5b94e700006a748a5be2683eba9e07392737d6b55966821f81c105dbe358af07ca1676dce535496d6e820cdddee1beae9590c3f55177160822dffa93b88971e6844fdd3b8fe70ea2336ed806d605fee25611dbcbea9b7b50f794e66a8926dc54767f2b57201143ca2dda52419f9ad0d857a054e7a41b4b731b633b97718d0a5857140aa864f477e90df5d280906ad5fffc2599bf5c5864cd9ffee65a420b9702128bdf1b6ae4e80628908b84db149966b3e8be73447b3ba2c0e80dc280ca0daf2251d1e9a2711d33da364ba5fb235953fe576f54001124c48ecc9b4ab15dceb771da336d7b69014be60d5a6e2c5de1c83639b0b9b250fd09a189f6e86898c982273a8ef23097787de1433bd6e8416b08b872a1fcbe72d0737a44706b78bbba7f4ea9a69f1f4288b035e3dbe555af38ed68360f955ef19a8ae81369432e6ac2a1bb0f578221f5079e8f714a6e7505990b5f05c260db13e1f6c6223f82e57c355d8f74173fa6e910f352275dd3f766b35d54e8d1f11d2ec8e560425aee1e09fe9151d99145db42d168789e4b7d299b5ae504b44af588cd761119b9398bb5dd7573fa14824c2fe63a5cdc2f7b16c0f3def7bc430396af46b7b340f8b85c0e6e6a320320bc6b63f48db8fa4de99d0efcb4536684e23bd4a9e4155fd288ac53984f594832b55744448ec3e6c9c77adf666326cbc6b9c00e1ff4a8f2fddc0c381b66301be437683d4272057cc3eaf9612866ba35889e3b45aa70f6b5398b9c0f407e7aeba976055070da8b98c4aec5fef8151bc8c465a700292f7d4d66629ec64e4eb164514a8ee303c71406a166c2cddad765d482fc87d73bb74b123761d2a70a410a52e0db20951b9c065428d096cacc52cc4748271542c9c9775e4c59337e88bdc268fcfd71721cbd0682dbad7f5185357a28223cd1b75d9af91b2e0ffb11adfcb5e6626d82a328d908c65b18a83fa501739f7463f53ad684b709a5952f2512b7b3f2d8d289e99311b8cb3a7355469eb3146da47141a7b54b5042923a6e34b59237e62196439c93512b21682e69c2443a758cf07e6299faabcb5480070aa1e8fb79bd573fb13b65524c8efaba48f56b01ec8669c35b44a8a477a0fa4780b9ad57811e4d05f9997eddf4350107d052bc79d17562551eb2cea0f38002616cc4ab4e7c2bdd1e5d305a50bfe4dd84d0c373556c9b08fed20a04f9a429d0313e77300fadc69b54bb249679b5995c37d49b144ae1f1eac43b8679c4bb8cd7da88235279d1f0e0feef01278bc350fbd16b9ff44b9222630a1700c1ce94fa1d17d20e21b5c8568c187c438f655cfa8c1c0cad2886536ff429ff63917752a6a374fbe334f33c93956c8706ac8324c40f55a8437ec19792d40437654343dac9dc63fda7e22c4828a44229c576c578ebbdd704031d1ccc9b275ba70e7372a2a7fe0fe1c8272583222484723574b6a1f635802fb72fbf0f4deca4370e5cf28c4cee1aef17c7cf064a22b0855f051fb1d65ac6688440fedfa32616216f189bdfbb45b028a35e3f6605a04e40547b1b7c7d65dbc9fdf988264b242ce249d59deb3690be010e889cc0301affcde78f2d8f5f2a12c11a18ede0159084d1000ce0ee22a4315cb6d4824933bd8a80b584d00e1bb176be930bad0892a47726f9b3079a3a115c8e07c50ea1abab6223d44d87f7cbce246b2653e21c106d717e81a34929eff5d926fa7c410581481f72b78b52ba9f6566cfa937cd79ffc5f65ae38ac5a4d361c0229d051edb352134bbdf6b13598833b8824ce37132c522c12838c98c06dcc4aa62971730e971e97ccd75aec42e71f6975bbfc8ccdd644c8b54d392028b662c0f8a224dd0d08c1e84d824dfa92519703dba039d6f11835e18903d5af084292e29ad5a87a0b5287d65ed702612e6f2a9f5fd5fc8ed99e1c0fbe4e24f464c91be5f82eeee7324c8ccff6435984ffac12a90fed8a1041187e681d83742d56f1faa7bef5c203550fccc3aec8845b1dc888eff015a9f221069454ec5345ddae124fcc27305798d3b6c0ff579fe1d8d1429b953b0219e4c414c0e6ba953077e70ce3bc37fec3bb52b72972678aa886ec855acf516e95914d20b7184e3bf78c53191aa43cf0dba33fe0d9ff584e2019d6174efee443e54e55ef35649d253921f065782da7936fb60c207a0312de5fc54753cbbd8aacfcd0e35c0734524fbc0ae65e3fd201c42b5f58f1c50e436e2544c9c9fe05f1283506e0242efbbe8def508a1c29639fa4f839e03f67382d3560efde7b664cc0bfa258541b85967ab2e77bc22511f8c168ca8acb05146e23d5ef50b0af0ab965d4a749e49ab68b6b6748c396969269f406a79c2ec401042a36fa8ee71fff86de0f77757204c191a51776e534e8e1771cdea805e7f33f0a81e4bb078514eacaf09def5b30b2ac3ec59ad08e89f638d288c16df020e26dc5d1a2b06f65136805337b53651efcfc9721c1f0d586872a6ed9339d5a055c7a1c31cd408b87c284d215fc2363c271699be8941a9d00cdb3436c3b86d64598a176d317afb5283651fcca2a32cd50a3d9f599220786f1732aa5c621b96298b8615ad480f63d83f4fe49082dd546919bed261634ed0c677f86aee8a1c27b7c8f5bed41b4bf66c9ee79be88be38da84c2d42b9e3b4dbda9b3d4091debbde879c6310b5246e57b1cdd99e4eed936547450d05f844f526dea6c2b74cd440f7ed74ad559318c64ec5adf79d0fe17522a94e3bcf5c96d1df633fd0ff19c25c291879958063ded304b69b58eb43d9bab480335f9dbccc2e3c9c655e60f579aacdd57d3bfa542278586d17e796848ff4037642224fbe92aba812349d03dc2743853b1c02b630fac4240f3f35d86a332e269984cf1ca4ab53677ff77671cb466a6550821a77b4629b2d35ce758799a06f3e359065e32c6e13706c47e143fa77f01e57ab189cd76f2d9cf628ce763a33301ba9e0a1ddaa348ac990e245329ced645412a0f313ba82cabd85b3b1a7845dcdf8ea86fb04bfa87c376601a5e501ab337d2a2a6d9dfe921ba4420a600976fda99893844a2f6462d7b7562876f1003ae7a7c9f5ba38eb6c72d4204245e54d481cde64e36193373effefeca1ac35ef19023af510981f6760c64e4f940da7d63603f8710debf4be7616f8dbe399d3b4762a422e5315cdc9f3f9ef028813a6f2119bb492c04641463711f535a02ee83c787096aab1a4c12a786624a05ee5509272c58c972f5b3ca6bac990bbde2971babddf6f8494d5f8e43853c759d68fe3bd020918161a55af87924e2136e3873a8ff63338031f934787d8c4dfd50f53b2f0d9763c7d6bf71fa842bf4669aefb9118134d64e41480fd9eadb17bd8608b19fc6723b19dc5a21fb16d9d5886c018adf48e058e439e24146d3c45da029567da2cdf6759b1a1d7f957ac54b3f8bd9f744cfc110728517309792c3a237955605139611112c2ebc1600e505c9def7c62df3bc42d91118125c4b595b8d896cec4db8630da876ee515e1f83b00f4a31abe63224806b1d972045aed5f235109f5a437f8e05fff306dddd70870199a0207ba68fb23f19f04c2763589604c943e2417d279f52f59213c94650eee7286ee58c72f294591e576408ab36c62fe3c9849eac5fcc500a95865859e725fb319c04dfd8fd55c082377901f47ea256558cecde2f57bfef9d7487aa1a5007ba06209bb5320ec7c251c5e356db9a8fe1df1433765706fd64c2e5a99f3c6734740b25931a30a203bb77d8c77de9c1bcb44a7559fa7bba5b45315a7131bb26e8b3eed70a205c3808afb683dbe5cff7857baa9e3171748fb857fa81755e7ac245ba495314acb5442c5ce9e90baf5453a2e85cc4a1d031c74678b7bc985f695a100a534dfdf0e76a549593d9a909abaa95a5b592f7c842bd99252203a91841b3c286c9e880bf7218623c77d545cf43dca2cc5f64d189c5620f701f5d560c47c0dd8601e28a6947b6a05ab08dffd6874c6abfb8950a5ea8d44b260a2a2315a86757ad8bb0461a18c2f956572e1569fc76353ab2c50bb007a01c306c4ae79a46766b3478bd3672fa91d3a9b346b443fea7502e9a754e693ab54167f4aad1a36fa94c075ed333195c7fad9f143143718986d6dd5e93b0b8f8b6651e22a1829228185ae4ddea47dbdd78d907aeeaa77f1c58ea7148ebcb007e9466d253b7eb0b1bd85e18f7eaa74a59c93b436af00785687268ef7549d6bc09e403573996c10fd48f1d6e275a07964907c10b910ccd1ac202366655f092df1fa3524feef66c9cc3b416f929087d174e1a7a348345a14ca8bcad0eb0f0fa6c68ed4491f764e5fa434cc7dddecb0f1e9efb33b972d63deada0540dc75756234d6c3a1e0030e6f60cb47b19fff6abd2035429d7cc6bc8e439d27fb10c2100e7facb3b44db7800f0a9cfb73f21e2e2928fa8709a84af2c1ce4558f7ca54263e9a03e3fdabb6edd6762e6a2bb113af9053ea50f494e14ad88c244cad085bbee6c42deaa31ef499e7c148cb1f72f2ed5bbb30ecaf03d165e5c2599fbdaa8d05e63314e44afb498d0a52dff8b30671dfdfd30f997e28164c68f0e7b95da7e7815a10e7c483031497a69b4bac23326ccd4558bfd764cde5c94e49293818dac9eea7bcc07229fd69b663ecfbd286f503487b19dce56b4484f621946a828d0d524757906dac5c7ea97a341c2eefeba46d251fd6b7000a06923465766954f3d3532207426fa681936a9493ca1b668d58fad4128d2edc72f9d25f3e766c72f55634fa2d6135e0fbc96bef97ec25dfdba382e67b1f0a5555dd24fe9d52ade0796de59bc6878d6ee0e770413843343823e425f1fa275e08365fbfebb43a3e71634b4feb3825f3e66f47dc78fbc98c6dae49a67f2fb668bb2305fe43318cb92a789e04b61bf2ee7e539317b529be36c0ab52f16b293b4a24d555b04dcfa5b5f8d918bb0fecf3a46e553a8bab5f78cad229137827e2e0c33018af019932edf31e758a8c49debcef7bbb2628f9cafa06fc5ed8ac51d0b079db4a8efb05ff44f9d368d4af741b9e349268389a8fb49061dde51437c52c1ea731adf363a464c1cf2feaba3c5b987828a3436861eb9912adb94789961b19121c48cc4688e5301f377594048f04f9993ebae989b70fcff8d866937270e61053c3b0cee8a650cbb8842953a268823b42b33753e6715509faa0c765eba4cfc14f8144fb2c90e727da4aa3c3f5a76125a2baddc8b56dbd0ec321c696e79e4efd9647cbf2eabbe932d5504938bb123e792c2fccdeb924df4f7c2f79621c7d6f101233500a3ad5710f35a37d394a22d0ac0ca3c7ba5a54e0244aed454a8b551ac75064495a98b70261fe38966e93b3e338d319e7ad7d89ab432cb070e04b9feb25fa919f7cbc230e8fba02cfcf36731403e6338a49d4f099eecf5c0c37c1daf1f3736a736952eef29a543d0df5825ed2b854f1c5e70f4ceeb5c89e81fa67a7ece7eb99952b24023e93c40d3358f96ec61ef52a9857d8c979576e32c1d1bb321fbd140dda618939ee806f7519a9cc46aaf8aff94e287d4edfc5c42493fdcd874d7c0dc3904d387252521016730de07f816a9033443ba1e4acc32cea66026d9cd6638091a7c38e334408a3e143597b6c2e85dcf5087dcaf015517393f533cede5539a1ea25f56d7ef2110a5067c77822857d3233392b024280dbbf992e8729b8add0b1ff343f0a66a5bd8f010c1dee5555448b7cb52a8bdaaf00fa4cca7825ccfd2897a9a82312a3076ec01218622a625ae393d62f9e4055b540435b9791dcfc6b9da25f9c3d5031ff0106e0f074fcb33a59a3e81621b0789fc58c64d0006074486eb35c93ac25a1d62086c1cfe6185e01724986263002e3a420d9bcf6576f640abee6e4b51135455c6f60174efde218dd6c9bd8356276cf60fc67a79b0649f8f5436245959a313571ae3a417f42a1123f75afaeaef63f19ac8694d7a7d7f29856e621c1532ea9492be3b6b8177a0c76705d6cc2a0903fd3487cffd7342ba452005cf1126795fc3d80234441f26b2bf7c8d47d1851a7905262c170d79a2dc2401ba51eb5bc9fb0e8ea92adb7cce389c41b19d3b68577ad499b90fd2a48d9e47c91d08bf8537232087f551a7d1424ebad3d6a7e1c9f043910050fb7431e709776a0c067859196800e81ed778b369879eec671c0b9a042a5ed7d2d974f97b4f28ea05362aa5b83a599395318c070861c07b5162c19b4cb811ef3d47e6b3e857d3ab5f09cfbfc0ee647d6f4fb86a5e5d2fe83b175d32de058a479cbf376b1bf348e6ae1dc266b5eab3eba946acc9dafee2b07e5e2846349c3b8690c88e6710d4d2d1a45287dc119e4b48f339585a1b303e4e4e3d31db30d81ff2fdbea3ab9f58fd59e0daf4f72981fd119ba13831c5ad907c895cd00269b6b65f2d28d6b1a9e8420496a958add3335adc14a3ddab979c1c67cc5dcdaa2881b1c14ae6a148c0a43b5a8953c081c2453789fed5ed6e11d39716609ec9e1a4c3f5554329517109752f0607249e6d18d61c535756e83d0ad62a9dad49031faebeecfde2ed41a25e8c464441d20a3ecdeed9a68f5c7bddfb2c8675624bc2ad6b16c10ccf68b6d94e7cff651e5d26b474340a88633003fa159337b807445c7caec26ba639978505866f54e8f31876e19356fb4293b5294a6aa094b2cc14c9a657d615900b81680dc15640308b5440dc096da321a126155cf0be34ef74a478e840400b3a6ef2a0f29c66e3566fa98390621e60ace7020360061930ad60075ec4713d192ee23c6c899b1c3407ca496afe5344c1dae76badf5feff7c08e3f135cd1c26e7a2036a5e218d305f77dc68e2947e0009dc04e62ef97973cb5016b51a99f716f9cc32c5364262d7de41d622e636f414d3899fcc334d6e5ae4257a436e6af3d24e6aecd1f3e6b14ddcfb0dab193d0dd2d55d3cfec236406ac05e803fdeb9cc3897b5769ac9d1ea66cb8ed70c8c00e43217cc133e3921be860e2ea0f9459834307439e8b7f6885919e64aa10dc1961358bee66e8719447322c1a3c4c363de9a9fdc9c529bce3e914f613e4ffb0c27bd1a32dfec116037e9f92bfd56ba2feba28fb1081f924aebbe8046c655769b23eb8396c23667ef8f879423d3b2919d609a2d3e4a7484dbb76e6dafdcbf6ba14dcc6591f56675edb62d7736798e4e032c9d54c0baa86bc1bccb5df82fefb940829de99f2c5b395035ff5a9b17ad03805ebca0803978eee9a107caf2beebc1118a1dcaaa2559af40f1d14b17806fddd579245c3a24825ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
