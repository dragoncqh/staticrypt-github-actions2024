<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff8de7f770c210e26a339499f185d7615f7e0bcc0f2852b7cfa90dffa306a0974d0e5601e0e7ec12957e7cf3a1c7c4b55108403e42bf779e38e61aa4e26ee03811f293f64aba2b2f21eb7acec760101567122c8d54af7b6359ea39eeac66ec41d6cc62e9096c6b23705412156a0c964520b11da89da8be5796b72a26f6e83eb138582482c16eddbc51b683b1115e9431549fcb4afec2d82face64f83849ac2d0ac54e2f989c357f5949eaeace0d24160f0c2ac48ea24927a671803047e72ee7f17fc9ac198fc89d28ea9628a5828bf85228947a21c266b3ed5af9ef17c56a6a3e07d88fd306a194fb5d07ada2596f0102a7ac226f5c42c091d38a6d4b521fc2ae6233728a43d5728d22de94c2acb6c17951c83377211d16123d403c548199652bafcd3399302040eafe0c3255f17fca8cb812dba96086977440a8a23cab3159b545d99ccfb310bab2420d9fd0ee5b451844408842078f616d091ab51abb6b32a6bda176c9ec5b0528e6cc83b378df95e4370c53b5b518c8273c613245d4a61c109534f0725b5a9eb946709308a98c7656e2f4f981c17bdf964b77e88270cd3d0231a3c5ac78626e8be01d89cf62890e6c82020dcd4fe9a564ada9a046f0d095dc4decf0b6a84d2c50cc650e7d1958b055db29c11fa1f99017c0906170b6a8edfa8fee89ba74f94589d2ba0549bb75fa8886da3e0333d3697e2eba8605c1c92239eed8643739d3bb3c598552e2f7f3c5fc60a9c1887c57e3ff886069f6323a414d75fc77cc5fb61b005120c212e648f2a3c92fdbcc26e992ba95103b7df3bf4b3e9c43fe19a626302d3eeaba82fe104ac24013e352526b312cd50776cab8c5f681954120d87ff6e66ad21c35e7e7bec93bb8fdb18fb5cc335ee9c31f10da5b7f4e1867ed1a6e589f358bc27599123533243a5c4555e5ece7001c69c28f8236302bd6f5522e21d0abca422ecae6ff296d25fb35d692684f001f65dbca0bad903b86cd481b7feb44d33799012ae5f7902977a707de4c0ea6de5c2c0bbb03a2e600bdbe4448d86638d31a6f0f75969f16d97f28e32b679df45706c09b1669cde639f20b24a460b0466fcdfe57dbda78718a1c1bc5a8df2add92c6dfdf86e552757dec4dd2972be02c3430bccd296ad8d325db347ad92cf8cee333033e2c28d676861dbbe55f6cbf0d5c30d59275660f581781486180e9fd8a5094895ac31938a85373e21a2dbde1b6ae5ff44a8e97f9bda598589e2d6432073f29a2faf8028dc56665129865014bda5a4272a8bb997b617dbd22299f2cf47b3b55aa15cf6082cccc1c2504d51d40c66bde6093102a6cc6e82efcaf69ed61715e85b5e315f16dfa7d1cbafae7d899b7bf82206416840f7a04919aca9110991e92c379439a2a8d24c38b78ecb21f70adb8cc7fac44f990774dde7736579213ed50500706f6b61829eef13b5852b4afcb5a9aff0d1ed7a74d2bcbd790f79263396385e4bcfc3646fdff396eccf0cbf329b929b93e945d7a0706cae2a8e0ef063130d377a97d2e2804ec7c940ae6a33e0d16a431199d71307b7669aa23654aca73ad06b42f19e00ea6abc492cb138676ebc15b2a2a738f96d6b7fdf1dee2a6255232f61251e9f57f4c5eedd08a068af9710bf4f4d51e38d5b16a623c35a974f9a8887dc3252646bec1cb1d3fe1f61146cdd22a643ca84c8e9de9146cc60ec6d2ac135fcceda92435ab64a8c1a2104bd6692ac2eeda15a8adecbfbc01e8cb3051b5d7fb386c904ccf2519e73bfe153e7e5febf052af6c40b8daf37deb03d766d31792432edf7953b41a1f88cbe8d01bd0d62074c74e7a603263df2defa096570dd77845a33f0ef6e9fe88b3be40413974b8f22327c98879bbfb3c5ec64842602a3fbf41479680df5e4592a7a8e8c20e83ace29fa24138bc266ebdf816c614ae8fbdd3aa03995927090dfa27415d73ba585c0a31aa540f88c294fb0e407cd660c4564cf39b3444fe79fb9d56f8c643414353fdd451563ad89568350ac39246e9a6a0b6e4af5a9ade35b3ad341ac00d99011f4883e1d727c98c806e5a8fe2bd7044f76742aaa57319126c3cf739e3f4f9ef48f6346fa22876c472ec149c663728b897586398b8ef1c27bbe68a92f3cda1597b9ec46ede7192d5e80b6f72b8d8e10a7d365add1180a2c03c392d0af3909eb7563abd9f5759cb4e0ddf6df5472f2fc66d5ef059228173322451d76f818d0055bda70bffcb3401943818ebc55291f221eb7e17fe188bf2c8038bcd705a3a70ae365ad9bc20529c5e0e29108b22985ee586b1dbad768c6d637c703e47eb29fefdec5341ff48b79ba07cd0b6520f42b635696be6d8d173bf29509dc622b8f52f8a108189c1443d1d8761d1ecb674581f6e48a508edb5a7b3cd5f730ff9ffb9ce117ebad443b863d1c023fae4dde85e8a144bd55daa5373f62f3383661a074e9983c7135247364b0f34b76c23be410805bd8ccf839e5c9bf9b97a1d349cdcc8fae4e57b37d43e5b8b91bef0056bdc8c29c0d0f0d206b5fe6fac235568c4c59e98d43643b9160e24341422350a8560dad15f0956734fc84bee3d6d186a75966b64a5a2c84528969d232c55dff5159a1cf6f8aa020283bf3ffc7c3f83a3f588de5074f9940a24204f0819bb68538c47e81c46e2689b51f1a667c9038d367e730b1ac374e03ee452d98036f23ffdbd434882e67f076652b4fb4bf54e37e8a796d3762ff921dad3fb0392b9b6ccd0d28d7593946a41f948bb351e3dd33c911cbb613f3dbf6a75f2e57ded9690384eaef681d52137afb5662cd2f4c5341a1127197e18848e6ed781078087f32df946ebde5038bf5917384de7bfa3261070db92754a76a1d76f536f8c7f067987322ec7b8c7ba0eb1f9b6175d10934a10925c8a52cf4cb42d8439b6ac968ad208a353af7760fdf5b64f0fe2dbc578a2fcce2f2a7ddd796cd1cc048cdadbfc138172e67fd3dd00b05879b8bd3e1f23a841a6577f821569afa5dfb7d9d91608fd6518e5221792107c48cb47a76bdbe59f964ac26d3b3cb0c561128de464d2313217d29bfb54856c0f0b4a4782982041071882f0619d3518bac4d5f28792a328c7f90a5250dcd6139380ddf0dda14951e5238b9b88f8dc817711a57dba04ebb380fc984283b9f2e892ffca7d7ce11a47a4fad54deed6625935372488288396e5c546bad9967c7f2b594bda0a5cc26fd8f275185937803a3c31b82144cdff2f0fec5da1c3e68ee6d5ee92fb0ec309097bb3cae8da2c96bb025f048354c67f59c9cc3dc5400041a7770422f6c74c60f303bfc3ea7af28d9690708d659a1c627eec8600e60f03a1a337c4e4162660d3927248eb72836088da92a0004002d9f73000eaa16a14babf5624af247b6a08626b188e350bcbc799943f916125e28ef867ef3613d848505e3046bed269287eaa139b45d77050e5704b5d34b0b4f0fab3d1d69a1695e38c95fb3ff2b1b3e507f58d1256b2ab06d82af91e2c275829ca227aeaa1e0c8bfffa33bacbae0c388bb7afbe73a2df7784e203314432f53546841d7a593ee088d2b1bbe130c50a9fd15c2e48d38825fbc3d342a7c227c427acb18d7b04d76d409e61568d5545c79802fbbfeabd65699eb543853c3fa01c1c2fe1e7e945f551d23a3d92adb884e6cc1e09e9defe4929d9b48f9a3fbcf9394a47827090678c6097ac97002b8ec6a16d913ea620e60c9ef5dc448a118e1feaac463e75ea0f96615cb698bc73f4b6a9a08a26af69d605448ac991749f7836f2af4f301b8552688b0e4ab6725f6225c677fa90629b0cdf2942b0f1f59d7928ecb8f37a12e89aa725c9d274faa94a9efdbfa2f07bf20cade748b87fd7ade8e4b4578e68a7ac5c3b1288d1849e26c89922ed71b8b8a3e2ab0541d53b0f01dcb1eee4d8dfe003e6f9cb0b5f390a936c04df919fd02461fb74cd3aa268ff1f3cbf462cd59dd9970d4b20f7fdbc01dd4911b90b7ed0a3e3adc6ec3782e5b9f1e7eafbfbd8ea4537e029443b04485a897396509718c132bd131d35e07d0a6c1a3d97e389943083bd9467cff652b016876145c9e8fe97eec399ad1b77d8f87452e28331d4fdcf61f6182283dbdd984c80593b5bdea1abaf4e0344f6260bf84c55ea2b9baaa0825a85a576033d0dabcf49e397fc23fba3703f9c610d5b1b97cfac5abc253d882cb1b036dd4b4e771923a351a465fcd3e57a8461307580a052f60d1fd1a925f82dda90788957b3c6e20dde8d3454ecc747bf954859909c048f3cc3bfa3512a2cdbeb61924ddff0e6f71980ac1fd38c0e02f916f43e98354cb106705d0bf011c9c4039319f0cc21afe4136a2a9091fbf7469ea26b065bbb885ad61848a424bf768158012b476cc96f81e40d3fe437a873376d738a9e06d6337a47d86275bd03d777c938acd7a9bb93a172b92fce82b0f786af0634ac8a27a7877e0422807d62d9c6b6b1ef53ae9311205ce5beb1e95ee31ce874800c6eaa1e56fce62ecb74ee0bdd09bf9a095c01513ccef811e485ee03c77858ffb05307b31836fa09642761341b49dd5309e0d0006b4abd77e2ae9d7e6aa71b6d7466cc92b0a911fda6532cc2516be6697e7acbe366584c0b53ab2189361827ed7499201af3af05b85289e2e52b466bcaa7187df5f3592946b64c000ca0eb3f7688cba13d50ac870eda8503b8f05721c846bc4b577a383a66dd8ed436fa403878609652a8633343bf5820e92f2122c31c7a4eb65dcd036521d3163e0224175c9fa13cbea467b776e6c205452257fc6b51bee1edf12a446a9cd73c1c702cf7d61141bc8b34e43cd61e13975bf9b5b730b67fab1092b0b67c29f8c4cd24f1324e23960841fd3b7602ae911d88588245314231f7cdfe660e227f5698fbc922f1847bf4e4a1ab8ba143aa2091795f3c2bc7ebc9b86058cd3e59b8d2da7379e5657466e3a2194d084fe5ba136ce04699bfab8ab5e715cbde6d9dcf0ec15fce471d11e4cdcfb2fb98974b4e7694c71e173fc62abf5893e95c1509df18758e8e7d047dabf43c27cdc61cd9dfd87f102574906da6554996c5b3f6cec4799974365a7679df1334723b6aeb0ddb00a93a272acec1484434aa36b706453adce1ede01a31b782e43ad7de83e5f4f2563d58055a36e9fe8e7ae40ea3a4f05810137fca8c59082900a7e129ae7ebc66d37f4c97f6a09c54cf031d75f42b85612b43044b8684feabcd322d4130b97c59a951fb1f4a7eedc6f71d08a94ff3a8f624cfa0d0b466aa93cb062a57aaf920d157da847ec98905cc961c983f4c3734304bdb1cc603776fbd1f76d9a02577bd6d84dc5199650e48251b23c4122275568b3017d9a68395ca22560f95841071561faf3a4b6efb61b53aeff3c38b07236f6a2f1d76aa88790a1d02cfc207d42ce855b28449f9d84f749c15d12e3452a32b6353d320eee0755de258ee036f6e2b19d18f068b2b9ffd704ad95fb0d28c1bb18210b2c9d1500dcc5ba08aafe65de11d911609817b200f6207e0076aecf0646d79f6dfdb41cc69c71b405d939f822574d09b5e23a0decbb59f449590cedf4e938ff7675a0c3dd1590e871fd9eef77d9cf84a1773d7eef4c068fe63f492273eb4c387714551de87dc4c3724ac8fb542117834ea889ed1ac64dd477258c0df24af4bc8b3823a19fa558876715c397b13f2a3951fec8450f1543e45a804ad0cc96178f5b8c5dabcfa453f878a58893898e566c5a2f023c1d8c4fbe9ea56b577a6caab0676733c000dd27d372afcc9c5119fb6fdec69c91a12a1c7c91dc6ec41dc4ec325ba5605f9a837b8d406c7eb58f7b02ca3bce00ecfd7324d05e8826abef4be6bdb4d31afd85cc80c570cada75644281388d850cea75e03217d213c08b57849b175ca9b04e2b520d65cafca7e01c0a4617ab1c1eb663c8acab56479234863d8063219050b4878fd6a684060f6da85b669351d078fcd5de9ffe91ccc586e6175e26313ebe55976db4a0bd02899b47e5c8aea89af3f6b002c658fd2feb3fac2e25cb69be588ccc07ef72afda063c71d4f570ee5d31d22cbfc092ef98bc8300acd694f3b0be841a4fed4b809f5f4506f2a32e3dad0365e18639968868a20c40168df436f5dd6e65db0ca7c1f6062d87dc6cee199e9f21cd80128d86cc0ce289a0703a46f8ac5ff06f32b06ba724b275e2488999eb5387b682cb91ed3e498cdd05184c008da4fc2db33fd349e71e446f80203c14797d82df34fe757d549fdc3747d280428e46db78a06b2ec6ec43e31ad5c18da75c85344299fb43dfc19f4523df813256ddc9d01a9adcb432798f635da37f15dc9f4171b3f9c7830ce42c034deada8865e9f4e3943ea12e5012cadb4e8460b05e1c04453bec90a268707e8303b56d0f4a1bf4a71c02616e14a1be69e0a5e4b805cd3e01bebab7a23995282b3346e1fa3edcf11bf4b2c35271e1be16ab9de96457fbe0733f9f4dbc0767ebd756f0c2ed4bfcab3a725c8bd6f4e61a32dbca646078e82f0ea4cbfbabf6746ae0b30810312208273305726bd683f11476be2b9afa0ecb76db6b5c3a5dc48470f66f9d083d5caed73af9407664a443c52843a66c2af7cd88a67a5978c33690693d890c18a821a6dbfdbd31ed7418f2953e3a9410c1ca25b4498acf6e6a6de8933fe6d26399433489c2c5bb430efc4b31210ca43bd608263f8ae6f9a98f8a5c418137a4af7e43a60f178852dccaca40c2702d5eec7fcaf794cec68096fff32353d8da86cee269cbb4b081bd7796109713b6dd07be16bec2c60abc2c0034228680adf8c1aba0d424d8a4e1e649beecf2b2979ec498f193c0d98faac38c1125a3fd1dc4a7ef8d02c63376938e107f0950a1c7bbeef5a677e67fe7e29e14d676986b9a0e7305a70c679d06403441a3f27800d01d43ac3107727d646c160f9f3dd82abe348280abf63e96b4b6fe1466968a34dc41712817507695d9131e3fb86daec7552c51e0fb192e2f5940b3574c85fcb1c52a14ba6e8dc8f4b599fcf4b7560d7e334a2655fb6db54a2d16bec9b0da564c353ac948e30acdda2c222736c14f03f9baef6f48148c4b63ec7587253c17b824bda25c5f99b487eda23e15d44f3ab237df3ea18e9d24a4bd0733f0d0c4169b132d9c506452b9bf998d5f733ec610000a40f33e134ee825424c1884a70b82ec93ebd3f227e6fc97e49c967ab6201b422761b747820b182b861f3e4f478a5a087ff27305cdadc31c457a7c337652a9d50accaade21343d96c09043193a60505e4bc02e887b9d0414b000c4a59bf6f01690fb29f9cbe9f1f1bbe6bf1608922b301b07b1afd93340f10944a4d1a5df58b593328b8aca4de4fdac649d072909271cc832696f676335e590e18bc7abc88b6c1f824505c13933904ea71feb6fc61d152b8d4c9eee99ec04f459ef020a72048f2503ab4a80b502ed921a7b492bc27fc1b55109eab5a9eff6067270ef4d7757cf2a8107626998b1d6198c992fbad5b5a5d55ae60d30a68bb4a127dbc51ce34e408de33cfee25d81d1f10bc9c9157d5af5796b8168bcc07052075f360f98f30a75af8779364f7716a708acdb8147364ef55f5db7a1afb3ca722b20cfb5a321e96711eac97440f95e39bba844c49b60bf87bbdba6caefdaa9529e1b316e7b19b92d45bc4a079c5f80279ec1fae753188cf9778d44e46a118eecbd1fa9a6a43f5ee1bf5a0ddab949766a958d030d344a59516b5fd305cd7656bfaae775268953d2abe576c51e7d2aa1c528ab793cb0c47fbf1b9fc95929417bbb86bed6c2376402958b9777f600047a4c908729a9615cdb6587beea4d597a9f63ef26a04e96380dd70194e3397a0a3f9647868ed30047c2ad33c798ef4db0cbbfab7a7445d904d6da8d914662a1a92e0120fe8633e9160a2d8719770af341c6a6ae658bd7b9e897dc131cd560cc978cf7792f00d3ed36ba2b612ce9d184686d9ef6da5d67de6f99476379962500ef399cea37845f47035baeccda9432bbfe2ab480765cc62814518cb2c550df6c272f4d673fd545ebb52bbe9b0c83406d9e6be698ae9629f4bb15b019bb633d60c6b196cbbdee9621aafe31374fc69afe927b330a9fadb37b794c2ce7b547e398f2138a6c3ae986c37ed97c089247a5e6efb9cf6faa16b7255122043ad76c4250a83d59c0ccc79fbfed1b173756efa9372f4eabb5be6e069ff138e00de1f602c4fe1da8ac5335622bd4c2b9debee07173052cab127bc6df12e7f06dd01f871a629978b8d70de35f296ba8bb8f420900c55b4cdce39d76ac192acb8d05b478c388b86ac0fc4424f5c101a943d33da080e6c9626e1cc803ec61bd5402b010d4bb8d93744b42eae4915163fd384bf8a935583b1b98f69a6143aedf75a9e9d32acfc0ebc2de522de8bebd5f4f2400553b98646029b7222d2eec2c1ae10b691982b28d123478054b7a253589ddbdf6074c8c9d2352e5b8cc804e0f24cc71b407ce3aa183e979c34a318662913613d942ffe9dd5f81c3f5a33ec91be14a9c558c531faa9424ea5a0f5ff272b01008be32a9894653bf271535f3a2496d6c0dd3795bdc09456659b48856c056649b7fa92b5f3dbd5af55375e37a6c0b1063125684b16fc9cbd2249571995baa31477d6a3d79eece0e3e6229dd7528478ae2c4879fb812c9e7ceefd1e768f5d9f0f540f4d5956369a1f5257f07be421b14ca53e65f7d00322c17bdf5c8ccfcd2d0e0e6ff6aa354e0f23453bc053ccbfab91533a500ee9e61c473f37f4dd1bc549e5adda81c84bd393c52a0457d05d86a9bfb2ea35bbe957c24aec72a634d73ba0a55769c470543ee02408ff53287ea04c562027dcc6a77c4d75958de531dd44b295f75782c0ce74f315006962fe2ab7435d75b00f83a0c1229081b89080bb63ee95a5eb0c3210c1ccc923aa39b27a3162976f2d84c57f1ab876d59593d9b870a169490d989e84c78ce3118267f513a44f1578ce31b18efda4832dd6aa9a358909f30aa5eee9f670b3fdb2a0374b602ec7c4a034bf11f6236b6458851e5206fb542bfdb49c413c36583aca2b79954ed535f156a3f29c27894ab6426fa3b57c26ea77c0de2f211bd20f6a7981b7287d87bbb10657548ad48b8a6585bff9812fea08b23a6ed78b60bf8f680bf991ef4d7226361a552b159572b6c6cac757b0d2a837b55b09d7b666a6d3562def18623cc59ad84c2f66f734cd600f6dffd840c4759c45eb430fc7d7265bdbe43b2d4ed9a48a7420f4499897b728a7424cd6220ef3927fa9cce96f5d0873dd968a7354200a76ff655e60c573461d401f1d27024aa6a0773465a9e84692accd77993925dd18e9b1e5e5616670c92592a66be899181d4257ca2322f5bbe85ce7e1e67ff1962baa7f59ef3061fba936e4e716dba406d69a184d5993742201545f7f0282c4590296d7883aeae0a65165d25cac7b2b31b3b0699688e8093955847b5b47686913b974bbbea0b3a7e03a2ce3d39a8c7b27292e0b6109b66e5a54017a309c5539a608053518fdb78184e1c35cbe4287557110264b5e00bfa55aa6c1d9d8e9e5c46ae1cf0643373ad5667d733546fbe0262e07442a8e5b0664eb8564901288a7ccc6686e96776549a43ac0c296784f2ca8ba53393700e815463030cc20f35cf106a9f6f93c11d45b625e8ae766aa20d11831e13114f28aa76c76893026315201522a5fa98e782f9e2539a9e5a5c400ceca1d104412c830e6c9b10352d8c7067fa337517b14d762df776a11a56dd35e09b7c15a8dbf21ff729179d66467581a35195acd548e776da8a30ef335f76d95b536687154e954cc27ea890b6b037faadf0a527977c36c2e3eb02c38761df7b0ce68fd8c8c8dbcb610f4388dfcbe707e62925933e5cdf38f79d14736a15416c3305e2503da517140b595aefee5143fee5eff6bcfc5520950c99c0822ab913efd01ed6628e14c41372d39fbe925a041c6a1f677197208029d4aad4b2c6e9da2e63ba9b1f3ca3a3c93d2d1300d1f0ccb8b8ede56309d28758986c35a788b83552877c5c00e3b71a14256e1b58b605e2026cd19faaf97e2d3316fce28f8940053d4c400f0a76f22bbe430c80461827958b1cc4aa58319dcbff3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
