<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b62d8a8e5c3c19f042162a7f46cc76f9402c8fd018698c6246b2a5245eebbfd0f184e6b70b8dc6339508362ccbfc5d3c5f98af34a02ab13e438ccd4c921ef9be8c5b95d819a7f7a42d62144be2849da45f76a234d07c2a4dfa569560b40a52c81a9e8fb13ffbeae542f5115642e49df6ab64880be4898eac254e4bbd3c90dd185f3e96966e8eede771e88b47e16948a49c717aefcd7a81e5f06d82b1bd5264d7502970317e87762a79c782aa9ca25d0a74c0975e47f3c7b742340dbdc95e1496028b9dd76f1d511b6cba463920c709d4ea5cb4d3e984ed2aa5b71a88b3e4b1803f475142d1c72eff75a241aa132b3898807080b18dfdee982bf54e2d7668bc23b084b5501c5a7c9ec65314c6edab9c205a83b0513aaf88c48524d0d39dc9eaf409759d25748d07eec27d3b21190d099110aa02dbafc27dff53bee19f04b38f1aeb0ec1d702ec5605e2657306ed9dfb98515549887177c189d824f8d71714ac5b6df2471ef3b3e5cdaf46776ed99d63bd97f822e3ee930520654da74d47ed107eed88c501f679450c4eb0ea4d276b231ca5aaa00e70bef27461c1518ec29f727c772fb0832889a7cdf2fc90823f468777be398e2245fc540d939a2d315e37c192654cf3753e2072cafe13364e47c3dab0b77a614cbe6e14dcda7cb429ba3798e6acd1d00455d796d48478abfc32e10425afc588a769d297a8fc40ede81fcdbe556565330d54e9892948f767cd4258ea4bd6db08debee3d7e7b4403d550ce96f6e3110d7347d8b5fd116b018658291e704eae75731bf1683644c920dc8339b5c2d12521eff6f939b1088f857899b2504c2cfe9efaa348d85f54bd5fc83ac6dbb65380cb4ae57fcd18143d885f74ec82e2b2f218995e76133a172b1a0dc8e2bf0c02659fbb3dbc1d6b6863ec561573a24db83f1a8878d0bef3daf180a0dc8a441a9a3ef3156e4d000397ddcfcf2a1c00adb09046c48d8a4cf326e0a0ed9c22489be7fc8bf41a4536104ae4fe0828c29825b81d0b7192c7698270d727a98af8fe287b14f563cbf316e0fb42213d26a864e6efda74d0c37943408f8f10d5bd2d96f937cfc7d750cd6cc17d2a9d120cd0eb6db79745ecc3749e33c86afbf3304b713cccfcc16963046e2157b00cf412e75a3f80bfcee7e45f24adbdc58686c3551d6876a68c82a4b930f3adf6f035573d5592b938c7ea9001cdb70e7c581d240292e6d541c66f9bb96fc2b17ea8730b932ee1606c5166ab794b13543e7e9657a10114c4ebbcfa589aa56c84b3cb3b24391cf56fde64fb375e4a970e2e24f6b10ad29506022b2bd84d551787be7a5455b377f9d295529fa930d4a59b22734ec5048338ed45a37e8a314c2fbdacc198eb3caabfb15b3099a168a04853d06d66bb9519974f0335943035c9da6ddd91cdd2987c534e36ffb2c3e745525c114112a239c92031fc4a440d02fecdb855d5c0ff280bb49a2914aa66256f7c9d9b519990f4adfe66adf4a8711b5b5324eb996a11f88a37628bfe85daa8e4665283e2a87cbb3cbae7130965a8c8d3cdecdb37feface172044f59d0cbac6b05bbcb6a2308c8ad4ed82e2a6df0885fe851cacee28db69643aeef63192d569ad847b4a2f3d457012d34f56a63c5a8bd96762ac00ef917772fb01d6a61bb5c2575e49ef9738fd1a890de05dd2d535d19afc1a8c4415583962cda5e77056ee84244e4eab7b16a8bde3020041c41a5739af2f9f1118bb3ecfbebfa401d324e5c7a18055ffa69e35d16e1f70678493050f8096cbffa77eaadf88ed86c7277d3c6c86cd69413524318efaecfe5cd163e929390802c9352faa951b4c2e4966c1e1dc3c1e21afcbb5fc758576232f81f149c75ec3a8b548de5c71a923d5534f6887e507009d580ce396bfa7338fa4de324ce94ae18735be31d42de39aab4040488eef2dc684e9ff229470ff15b734cf67a4ccfd9d0e65995b03488e6d6e6bf82dcf7175fbee29b22edd0a88e3a08524c4d527629f98830b3270c8183a964d9849c91404d15364881244ad5042487fa5889271a11e8db8851fdbe173a0146d29331dd8d8dc2dc99a5bc88b461a999b43a2b19c09ea7c9fcd4ee57023559f75691e049461da6a16b78d8af6965a873167f192721552acc0f238bfe14d0f029b5036508216a078584ce738be87759000b717e772dd6cc178255305ff75b8470d264f001ea34fb186fca59b2d739301ceb2824dfb3e35d41df3fc3d21c071a348411a586c84bb91989c121841e5ee2a79d6f9ba26ebfe7814c324704a0ad5f27469df3c5c78c731e3c0d732ed31d1a02a28155c7d1e52ad4b60feb3a8274d70b98836a7821632e5707b399a51fd5c9b62016cccd0b461a4124cf33ea431b471ead0043b8d65c6023ba360a6204335181483851beb626eee8fc2882fd67728553b3e200764c577bacd469bd1b35165969747e6784591439bb6d4d66cbe0fffe2090d84d08b4eafd7d7078bd5e2e791a9501f0c28f0da4b9e4da6867a88f3c361bb2ee12766dafdfe8ba0d992f4ad6e3faef2f1dd7f0607f80f72af7122ceb9ff671e5caa70a517d36bd92121cbd0278faccb26ba25fab27281850794d3786846708645c426a11b6a1269b2707737b3cc70346e89a8564b17b174414aa0c1c87a7739a514b862383f126459cb338c46cfa4273b7f402fe15791326cb4112ad4b06707908391e26a89c815443b36266b27ab87a8c8a521c8ba31b591c2694ca20f76a7ad17cbb7ea1633df2e1ff9f3924a1b86155a61472fb5b18b33f4380235f00256e05be16247bd658085dfb5f8486827060cc436025afce5ae423ab03bcd52056a2c6e3aa2ce3440efa0fd6b26c96efa6415d816b458a1d7fc190426393fe5b231952b7f33041bf06170f9cccc47edeb1ca8e3d4ccdaba8b5e0bce36f100e6279f5b3d18a1d2abd1413353c7061266df30b3e7e6ab98650526acaf1fc2859a7e73e130ff096f9a6d1ecb7ff1d078635dd01c346f5b54e2479c4f324ea777c3a3545144bc4681748b40c934f27dfc6030dd5d5439bfc027c6395fa99eb223876e9ff3ac45ab15c37d5d91d8e8e2f9533086a030f3522f8b59c665f626daf24b33d4126676ed0608232f749532795771dfdc95485fb6284279a2bc3eae6a41467412370ee64aa76ae79ce39332b103319bb0dccd10cb01a4db0bd00b0ce8acf1a50e1f3e30c03d12901d818e3ac04a7bf0fcaca6dd5d64e93e4cf1d0860614bae0906159b5b455e2879177961436d7da4f7b1d621ee041bb3c721bd4eb308c19aa233216b25da5a37cfaf4207a0628dcbe614e2399fffd7dcaa2359bc0a8b1410d248002934e5181f0d1960eb5c395389d81483fa3b918345117964aaa6a98cedf7bb80b5f24df901cf97517fe52e5d6d0881f358df2adf3e05e87f424c885abf3bd260d96c76fcce181f415e3f348f20328b41c5d00ec2e066b0bcdd13811cb3d390d675c7adbd8e8283c05886eab264e1ad9f433a5b65142fa1cb6636b5214d4e8a781501f452c88cc18ca0ccf9e529c06febc99efc9b52fc1adc91881ed4442a3c79c0951cfa17ab1c0a50bb55810cf14eba061e408e46d93c0b6e5bff2b9265e1df7a73e455c75da134153e06f36b3e1e68f02559f12d9731ef1204b5bfebeefb522b380733268331afab46ce1f0d09f5fb4f3f3d2983c08a73a31464c0b3fafb5c6a40e688298d185efe9693be88c3aa03f435505c08f09c003a1aaced2b5102553a9c93bcca88b2b976295c057924ac182ad2f364d413c654563f7744ab2a265a3a77b65e9878ccbd7cda73b6a9738c6281b62cc587f17b7a2b5d9b74ca7941fe39ac88a31a537e0745c1d09eee5a3e77c6f33733e69be836bb6dbde3e437dda7daa9eb8aec6e903411b40ae8b1e28638d1c180a9d1cba2f42caf3172ac21a99aa4216cf1434032eb86c6788be2109fe7f58cfd755032c2bd76f657dfc29fc739b31dfc93d9448fb7153d4b18e2fb8820f8c74f47a444d69782af7b420e98b0d3367e01fda89138430e23e4afa291e884dcda5dd592de3e2827de98850f77c8922f58722ef3604268038b0d33846cfc84948289e9de8ee7cbe9a7d002b6366c416410f36fd85692e980bef6100ba8c0b54a73972c1c673603fa660d552532e1761a9102da3848dc37194b247d05ca8e2c61c728808841ed12636bb75fb494a5edecb126bd30585ee33a5d1b0aa00792cfaa9ca9a0cc7a5d393a299cb384a06d48a3147f9446eff2407819772586b7d8f91777313ae5455c1fc558dafe9f7e032534a156576d35d8a0815fc124e7c85314ec61c443fcbd39c65cd8e40a2d717d8433897b21dd60538bd47ed6152e3a1c5a94f8569e445e310f0b8e34b5eb1fa275ac6ae1de32129aac9534487e4bc5febdbec88c663cae8cfa642708cc31eb9acb248ebc98e9ad8210fe66e0a4de150d608613928285d27a2df5afb0f172f6a4eab28275ac939ad385aab72d2e3a727c119b19d523595ce0c3d41aacc8e1ffb2094846d3b75a5218e0a37682917b81b5ab5776cc93a4a1fd7698d9140da7be9979f1b3335adfd9536806da77bbdb51c2e61a64b34aadb29192247eac6309c1ad4752efdd2488a3a6f13744396f19d358d49b39e18811e9abb9877445e1dd44477a7fcc2a71b4aea773aced1e87a3e8c414adb5550c515608839b8a71ca953c61b54aedb239bd93625175287fdaceea3875178907089212d70784b57b4c63f00ca93498b90d35df072f8c15632a2120d5a57f4aac45bfc3b376aab8f485e1d008cc1b7690ddcf99646cb0b635aa6cefdf6b5949c4d99c972ffbce905e9adc8c8062edafdf4c6bb17289e3805c2ed8bc96dfcda3a3cb9273bd85f36db0c7b6837358e9a707c86b382d28a43d847db36d3c151e60f873e43098f2388f16244940915a154c50984cf9220b13685e7a9ed27bc0f716814033f61daa2e285d9b1edbd0cead29d611b0d097fcf319561654b1b18b68ff898062bc1413b6c145dfa9be6a5b82f16752362bfe976aab408214318c9caef64936abd3d7d6cb5a1338b8d808112425efde2bb53c612650aeaab88ee6d74e525b8686d4b0a98e5c2ac7e4d2cc3be537e00fb1337887063bf935a558d5b8c700e460fc1007812fe5fd3ac4365a0c51c72ebb937129f13df2879fb64b4f49e5668e2ba14c564930034e6022a5a57a9647db2c5a36dd99f09cf8eac84e0c99f764f6feec5476136853cf7c6af0e9b05ea67449ec5d92495c4ecc77a5a7ace589aa6d94eeac15376fd9ac99308ebc998479fbb92633cdaec1442124af3220cfc1f5c7fd75c75bf92703223884df1b3049b3a784e8f93ada5927e78b3cddae991a637c3409b8a644d697e53f9f276dd31bfb11db7657a298626700a54d6ee1f17d63c1e6f9a51b1a6d03503813ac471dd30840fa8542925f6e70cd6c67922e693ac336eb88f4f6425855704116004fa937dd3b8c44a6c0928d533992938ef719dae903028bae1a75a2681b26ff005fef036f9e7451eb67cccd2845a87824cd9eecbbb0bcd0cdc94879db286be746289a038b9a04d488015467ebc8c714fb601e1b0ebcf3d9bc7fceb06e8966e5080e89ac7bd756d435df62bdaf63b39eebbcc181843902f9975cec587bb3079239a7ad646f9890015b678d64694e3c20de87c3e21bf7161ba4ce188f16a3a5d9461a5ab8ef95dc5b2779ddb9960bb9a3ceb6fa025cd935949ba5a502ad11fc38c3432da1b6746809d089ef29f13b842f2de39001f9a0d7ca065f6e7b1173f9d2df27f609e4cc622291e343fb4286c558bfd8ae701339a214c2194f8055641998e045dc433335b9c2a86362c1dc717d4f54a9bcea9713c975a4d02835c80d31cc8fb7ecca1bde5231bdc2e6d134aede4ea17d36ee43e3d442fca52f6e6956b276b9b2a429bdfa2bef1a0320a69cd396bfe0c567bcde3540b0ea25fada9f78c9936a7210883fd71122c09d726c870cddfa5e7842d4e48e4d9dc8a2e225ab309aff175c0ce2c2455c40ba1a744c78ce01bdcb8b68a63f218618a73b26dd8fe8a2cc0b5472389c09b0fad95f886d195ef47c61feeba6cfd60b63643984572e22de3ad48384049ddd91dc1678cbbb9bf412c88aad68d0e36c7be7708b2409cb321c812fa1742af308342f89429ea0d1250a11281831f6f529d1252a6ad3cd43c7b66a0e6bb70bce4516f7830437950dcc8d285051b400826916a2b7f9faed898161394a161b70d6e9c8b994184ea95ec79e0600ac6cc172cd021cbb887b9ed3f500e6ee408ffef7efe88c07d4304052625dc9bbc25bc5f5d2a23f7bdeb441776c079e7eeb9b3d8a1b8fbd64193539c637310b5bc38521bcdf15a89feac3498462fd14ea785e22547ceff424a858e420c6b306d02dd2ada220733983312c15504ee645b9a24681cfcb1f230e5bdb76c0b4129b886e327bc54525b7fe8ab53f35786c1849ff71f2ce3198ce899116a74d3bdaba5d2691ded0a53cfaf2af63d2fc787b1b0f080bbc439fa6679785d4b1eb61bc1efc05fb8527eada5a49f0163aba9ccc0693756b6a9f21e4732dc095486bac56816fba6263cf3387763f44b344bbeaf7a7318b444c88aaa216dbe64df9302187ac1699fd2e09d82a7a4db4e825311fce88f31673110c9a191355f0364e1ae2b829628d83e948b547fe3720970f35af343135faa1c9a02010588cf187fd1bea5f84250fd3690ac952d1dd9b463050b616774f8aa1e369e1ff6337cb6f4c534a5e7bfeaffc92bc88510955f38ace3d3829bf623406d45ee77f6f9ccf47a8b5633fabf2be0c3c20bc0d04ce5198f66102559efeb689200b012d659f9bbc1ced81595a8e6c6881db524ae44f8b75d141f723b433e1b3ec9ef7b0650ca10d772da80ed591e334ab7bd82c3c25869ed7dfbc21e37b3bdf5703ec4cc53d9ec3996d7bd28b74c1ee079358bb7a105c43f3d1add23382a10b9483c1d0446027f52734eae3e6ff195f6301fb2ce15464e8c8ae5ec3b9e94eff007ad829004b131fb3e6fb792b2572a8bccffdb13247b89c1129e66419760aca732d52307d4120d1e47bbcef975ff195191ebd16f5abd6ac6d90d768c957fc16e5eaac2a6e9713e4e27f2f0f3f1d10f7b9c0e5bafe0b18ba131200ee93907edba69bc7035ffb2b7bb2b02c11fbb1ee8959a989e3b53054f53d9417b1b0c7cd60a97b68f322a9be1cf8a7c5f6a15d7c3caa015f701a3fdbc188b59db8898e46f5e1f3023418169cc87c09d6d82e9944010a8f694e8dffdb675c425d3b2093dbbef8f824ff20bb962237bff58498c557a6252994e8d0e7d835a1c8e46d61d52fcbc0451313f9c2ff30e7965ad9416a19057d33eb1756a4fce908aed640a88ab67461cffcb916f91e7916b5d2ef57147e18023fca4feb5be3d4a61324c3019a4495edd00f6d2b3b29b595ea47ec45bfe094ed4a12e6265b2fb1da2e4fb8df4b83d03e96c8029519615ea398c094526481ab7dcdcbfdc2cc39fc9b8fd6f13b8a803ed7a072001804a58099f590dd2df91b72bb1b65c734e2cb60d3882b8a659cc4bbc690ee5d95a4c4a49f2ab6b2cf1879486cedd8718701109c1afa9944301633a6362f0f17c6545536d49409e3565ca7809ab45b434107cd729bbd3e0380fd9d7494e6271242e74281825f253581dd18bab8e56bc21381862c42cb29a1e506123b0dcb90edd48d3c96cb0cd586737350fb88ec7395d10a0700b6da06037e82e5b92c2f61e1e279ccfb09eeef576e819d99dbb3aeae21cd0bd1626afcc18335f5f567d4be42abc9363e52aa151bd4cdc6f3013d0fe20e6c76cb01106bcc8cecda35f3cddba944be6cfc2278dc9837f3c3b2c586643c6684fca91fad7d4210b623dc981e01750b4bf8ffe3481a6b633084c7a1f02538afe8c8689c337780b4b683fd6e9b8c0de64eefa295f45432664d962b6b59b0905a305f06671a321dc37828a51514565f042cad85a9f1fb47000baf674f943032a5f4da36c00b7eeb84dab3ffb91dc8650bed6f9e0b30c1faca380146359a673363f56ce554124f4b20494e11b2242b3d7799b7f8b461b117ae91c813109d5ef30a65ebf420b38ef57cdef5027fdc772213ca01b6afa61c1bce1a75bae5f9ed73044bb2ca87ba3cd68c878d348ec3c6ea902738ecec1baebd2ca0d972f23a660a82ca151bb53333995f5745b4a94a77dbc5a103fa180d56fc6c304f713c14a531c38e39f639fb967a4e08bad35028afa28ee5bb0fc59b8797731ba1e0e6fbf1905b21b0a7eb972b3ab5b581e46898f9409d5a3bb4facf9adbe8e4b3ccedb78c7cb2c909345f844f29f0de476c8f7102fc3ea50f3739d5cbb24bf9fba447ac7467efa0ba656f8e46fffbde86b909f6e8f2d7e3c3d3a528f74c20893f08520a9f0a12e1fb62bfe02e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
