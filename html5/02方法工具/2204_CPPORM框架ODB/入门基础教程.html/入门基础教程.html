<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d621c3da97fd4151dfdd25adb73a5f201f6c2aeb5f0502d6f8669edb64911e28a834f47bbb14086486821e3c264e85d8d7218397e7352ab1cb837bea7f453adbd09ef63fdf894946084fb778993ac4667d92a8b0b403b73fbe85e46421ccd93b4ad10c572934a296b3dfb37805601926039ad78a2b60c1e41328763ec0c6e8ada28535bbe9b0a799db1692c38f26a8ed1f073e0cabafeb0ffba600698927db815b36a118d99f787683ea5e56d5ab0366cd144bebbb2c737692eeac5dc33da43796c258b21364c1b208536d053b3383e6c088904789ed1faa3887d0648ae107f66f5bf8d420c6c2e11bc68459918e2c1ac6815a3aef62897cb42a80a39f882f049861ddc052bfe9226e7ac12c6155f0a4bcba0b1f279453058c7280c079f0cd57c3669f282e93745390c07908c36739b30aea88bb8394c2775a9621a8d970edea644261ee619951f7e5f6da1910c1e81e93ddda62cab2453d5c2ab2d0c71eefe22b79fc202e49ce9bc9682a39595f13bdd549d6eb54f91ff46018043a482d3433769425ca3e1c0f94c3aec0316b18c809a9a6d7ecc153f8696b90a8dbdb9f699193e4d12b9606415d78ea0bf01fd0099571d872e99eed401ee5f07815c1c0cd5bd3a5faacae1173c5235e14ca226ae897c88a08c4ba63035974de047614624a4b749f1ce58d26a991ab4cacb3c5470be77e3e5094e2628e142dc09731aff046e7a275ccebd991cf2780c6e0ad1d38fcf71e48864f162189f2cb07a6bcac850f4d8df5f6249934c52d11335fbca3f40891eb78c9bb4e11b4ea9779bacabee83217464c9da5c38c757813781585c071645be04314b81f42ccc71782be88d3e0508d131d85dd15fbbcef48f9d7b081d1b26746265912a95873b1147ae5dcbc3ce91b119664bac37f11405b3579b70ac30b2f537b961c247c59895497ed7d8fffe9267f7f1480e664ce3e9e3d1293f1be8663ebb8f58b6f62512c7d19d3f2b24abef616b4ef6ddaaffb19c42a477b580e08a28e5afa7314601746fb7817c734e27a5500a826b0a542f9ec6964df37070d1193dbd1597f549454b1a98d2f2b78b5a9fdcbf3db62cd4e260a8d476f1396d4865947c0e2771b6d82ab04be62c669fe9a68681547e7ec94a43b14548cdea84ab115a23e45335ec704d5f23e51ce3c646772056cf362e7ccd6d31ea9566e010cc43c62b16752daaaf804a86d1b5c697a21c6727ba8d2b9ca073b0da004f3e63f5823176cb069382b6bb83883c6bdfcb673ddb4b7cb77b5b0250c9888a61505c3a9772df70c4de43e927ee68e07378137b7ae4981864597a22f28d29eb42691886984bc858efc07c85f801462bcb47e0f2661103ca4feac90dab85577d5f611cdf8805fa946c57389ae93f042e04fd0a2b465e03081446ed9ac532df3e1ee650a68929a0b172aebb066369214fd8d177cce8c908f1bfab96a3ed4f06c1480185693ae899b256dc40d26c0f44778c689e3616220e96ce7f1390fbcb5ac147dd1716935233776f621ae157ab32bbc67073d3e8cc963abf6f97f4b0a0271856352548021e4171f3755aec244bbc8fdf7295d1f025928f29fd9711b398072744f2b317bc62b0068709705ebd73a8ffe93eb786f7b9be434beadea0e0d1fa6418ca238f46913e68303e36d3345e95304bf28a2222942b9f7a56109b7124d766cd4237a5197c8fb5f325356f9a5c7682a6198338337f623becfdf2b1304d942f4c3f458c86aefcf108e7006f68dfa11fb662e0a343c6b7108c17f396bf78617eca2c9004433d088daa5b1f9d4a07cbddf36a13769beee3c590e86b85e2649cf0ad176ffcebae262b371fac03845309e2da59f1349523e6ff8596f2bfea1210b8ed579c78122883c0a7b21b16cc3f041a1f71b9d779ffc5c869ad83472b0d8b9e4f64a5554c347934df3fe57ee10251336c5902443901cacdba7b7267d7564de877206be5722c32cb58d00e010d456cbb3061d36db5ffd066aecf515b7cd1116c2d346d822387eae1d26da729c5ec65aaaaf1e37d725ed99c475b1d267ad49009fc8846377648d2c02aa329e77f4d036e8ba90ba4a3d05b0328347ea23b545947263b0ebc99968d7e308de4288296faaaf6c97819c18ee2c7ec9a34cbb308fdcdc37d382ed19e18990aa13ed2ed4b5ab78dd864fce1c5976838b8976c79773d12a284947bd8b9c94ebddffc031d199324a9ad632954320a2df2c4012f58eff4ecb501524235acc68d6ff49de1eca262abbd1cb3f09e535b01ac3995d40aac20e77f8ee1a0be21eed0b82fe8c85c90bb5ed280591bc4378967dcbe4b91c254fb53ccfd59c6298d76b0712587ed51754aa316eb36feb621634010a06999b042407fe428a39cb9e553f8513187711ec7314a128c1726e685b479c45214b0a0c8b752909d8ef772ca6c53f915b6fe4d68598b550cbd65125521b086b9c0b9499c5ea3cc40f7ca75192287ed793e37159bbf11758f4cd0e87b0ea7d148e12e8a129a7a070a2d7eea9a7319a84b0dc042d9370b60f5e8975956f397a027638b044cde4046fada4123053d5aa436eb2aaea2f9f6d34f01eeaef75284c5ee8d757c602c7bcab563af0869aa7c1aaa9f943a2db40b5084247c86dee31c28d020d6acf9ee9d00e0188d5e9cacb40a316e25063c109be2415176197df81c759830c1cf99ba4d7918531161f77c192fbe7a17ea7fce61bea937758213860daa3cba4d8b8d944600c19d0de9fec8f4feee1cf869a5a175251170cba37bc06d50cfc172c2948f62a2d6b7eb6635f1f896bf7f28b030a5fa65930474fba7501051400a9656ef429860d402a61112d864ec6cbbbbe954c374d202926a10fb3e971ca069d03b44a64eea7ecea84d103884b75f3e0659c24c666990190e0c46445ff670b190ba5a174bc7ab8c73ea0dbb6206d437fadf978e6180ad32c8f0e6446cbdce0d244df425f037e11aa307cebc5bc8a9cf70753f8d402927b106f13e0d93e8221990433084ed6a19aa325a171f976151a54b7de53ef29ea628f21600b3170d92b3aad333ea72f5d22feb4c7432a48917587b03a043300012bf9e410e423598af2431813c28e15adf9e7534e4e0c01cd713e74a462dfb7927eab638404ec06af08efa3ef124625824b3af592ae95cd671f76cae6ee8bca0017fb121a3aa8c1b686ebcaed7e590cb2b251e08bbfea30edccd4511b90bba660dbe52b95be6983d83163bc9fac7a83151d3426f61ecdcb2c93e1a418098b104b4956985c3bc36ed1bf0cf2b7ee638766bd49423189aeed5a49d296452e8b45c88df442a3752acfd8e91d9c140071d59145aa14d6c32e690912c45dfdc2e5a0b5c27354e5be39066acbbabb29c626539cecf86831301cd08fbdcef3c0e36a629866c0b9ac8c52e2a7baab4d25686d7da7150fb39f7dea01885635b34dee8abe482b505d1a4ad3d07dacbd3eee2a70fb99cdc49ce0cd7c90a66c87d707d0c801c76425c9ffa0ad25bddb09f111472442efbbcf503b07ba4b7e8c46daabc999f6a67b9f1b2e2e832d366a27b396f449438f8ff6fa8d408a9bdf4c304af00bcfda6ca83d39845c8db2a44f1a3e6d33165ab99c9c4356ecdcae0c527637361944668e9d88382cf8518dade31cd189b4aff1e6a6d90c7f07cd45547833603cf5b46509830ed0ca55a4cb2ef494002fc5bdf423a6fe52ecfe90e66b05e87e262b0353d1a7e5c16f343cab9ffc01e736bb58aeb57c822bda1ac39c9d7d239647530b056cd06ce0f1a8aebe498c1d5e477fa1376e95ac6d3249fa37f4a0041933ca9dcd8f771b1f81a3596af499a0af8cea61ab32cc387b79338c76ee6bed848ffb075177686db54572b3310906fd19d9ae6deb77591a41c944d2aa7af19a9534836b0ce392c9a106f342f7423b60e215921676274496f6bbd3955eef9396132cee2506effb25dc78e9cbb4907d324ed020101523bde732ff4266f2fcab61501c196e6a99c77eb5be620758ac1862ac5b55ab7568039a320032aefbc374a657a48014b75cd414e6ad4b5b4957e06aca2fba4a898f9fc9f0873c6b48ebb9e6d694ca374a2a6194c59c64a02b61fe9250fba1988f4e7230146e0662511fc6ab5f28419410a33c31cfa502950794cff81f46bd22c8adad48278c512c145aba5b5264a10e2820b468ca3707cb506faf9654e274e4e57f1aead6c404f2091f43d7c1a77b56e910a7c63320a8a9285cc413889f12b831ccbcffd6f2d4595d9582351394db188d2e488d267846d22c7299a61647a8729f47b651edc56be00d595a0bf890e942aeeebaae53048ffc932b54b1f7717577d6fa6b6fa97725cf7a9c3100fb08b5c3ee2dbd073af4c27ad58d2d41672c34cf5571fe7da8dae9a5e7b11213f849b07b54afb1c4b966346ced04ff12002f73babb4dc1c666bdc5f13e23691675fbf388d02d85b7273c944cc89369530ab0594ef2185afc1da88a4dd4175e3f5322a4eed469a750ffab04f4f4beabde27cbdd2e7b9a1ab611e5323e910895bf1c71ff5bdbc78116bc6a47ad521f0b64ff22c79dae98c626eb1dede427bc43fd9cfff0981646cad78bd3ea90ad8c3a200809bd97258e92c0dfe512a9e6d0d829f06b331f5a6d66637d8354eb5e4ad5866612f2d4b29db337175ea1dd3f987c27aa1faa87fd3bd939f0ead83f5f3f498b27d0415c549c3c7fc8e5acd0e1682ccc80e5b4b1f8eb01c134d6d2bb3bf04ccfebf81200486271bb2e33b1ebe50863103346ef360d929d2fff06913d147e1f79a7fcedc9a92581ede9dcc4d03dafef4cae09298f1e06d497235964f1329f5f683d58ced7cfc37372011e0115844ad4ffceb848fe0f19e21311cf08bf17c4b35ec210bd0c9815b2dc4f55c5f471bac8ec2fca8340c8de2f02f1f6a1a469abb50af2504bb6963cbfc6a5f14e646f34b8af708995272d5cd0dff3c6933c9960da631461d5bb4b4c3864e3175006229db60528355bf368c751a32e759834fe9368ec4a1d808f49a73ae524de4a82204690c652586bd51fd2550ecdbe4cd8cf089de7100814e2bf5d64a6b21026837828897cd19e211df3527b97151920996cbf3c4e3ef8941fb3fa8c6775af144173b902a5da9cd472ba874d6b1221163b0e9888e2949990f7be4ed9484f37016ba01f3fa83dcbfac7a67cd7c16e5953fa86a04cb130d638e1214c90c047358c201acfa95e6a91b46729b6e0f2fc85a1016f25b81896022449c51f1da5fc253b297fe22bba004a4926e4a8c46c632095529441460a30f6a5791f29b07ea384015c1701101da8215b62bfacdb148546347308607301baf6962687b511f1adcfe4106aaec40b704a360fa1059e2af22fd580940bc57e36f44a29dde1a285939214fcb5ea652e403b98608195778563317bc32a31aade79e32141dbf59f2b221ba2a20e411b05d56d0868c2cce888b35ab61693e0e1ced240475d76eadff5f6514a2488f4952d5a08fcba3d170661e81cdf0aa6a93188faa585a8b123db4401270b5d994470107b226a584b88fc1d66c749cded0d1cfd03658e30ecc96935963244ee67386c69daf3db695534814fa68cbfcdbae203916887b631db8df73eb8bdbe741fee385357567e006bdacd57765067d250dbcd24f754981f445674ef32c525b988dcc90d6d332ba8c78093ab3259c6eeb1b08085522ab9496e924bc878a46f34ca469f7ebc5462e1edc3f7c9ef225b448d9af3576630e79a883006cc86a33b557d840382451151e7c00ce60edf7604ad12a308d4210b2435a8991a8b7a5417bf8fc2355103c36878a96578c015354a78e1d49508582854ae9740dd4257aea98eca8caae7bbb3053a82030fd75be31aaf04bb36ba4bc62b92f0a7efb77d61a56ba5e37968d3d0fd39d236cb0e9727ccccdf9fa5e554852fa08f751e364bd6f630ef18db2da4153ae78a14aace50fff87407555a62d382b102c5b8c19cf14ae997af8056a3b4f93ffbfa60fe3e8e8e073cf189820211efc3407a4b5ba47c35a01f90a330a752f9f997019f2ed9e6c059711bfabb2bc1302574992f5a8f0089643b2e52134f0b3af4b8444f999a6897cc0e4d7a11535053bddddea304fd53810b4de07cd055977a2000c4f72d268eb8abc33a7f37ddda13074608d603dbbaa71427bb35c7201ed3a70103a74bedec94ae4315bdaac03f423836e95039b7afa6d642dad7ba8a62845762e7eb09301aeeac33072e1c1b87f5cc1b8fa7ffdb7eafb5807b72fe754d9a61cf681890d0d933baa9e6b4a20d7c2af28e49f26c1a49ea212df42f59e221a0e235256e1bae8e67faaea525c24a4d66822cdb2765743658d82e890254972ea4699dff8d609a2cc259180102d19f53c813b78a52eb614bd4fb4ce50c6421d102b05e169b9f17497d6cdaa9bc43baee721605217f0f6a2b4f05863d680296126781828db9629988e5cd4cd36f2186bb8ab729171e27d574bbca106d5b283d0c98f8b067efdb8deb2c13e7268851847b17428fb88b4afdcf9443764ccabf8e7d68177cb159a5b942a4f844835cb6fa0ed71fd45d622479d92d39918b92016d4a26f7bd9569ac32072f27823291d48c4efbd0c49549f3f94a4c79db3a5d3c34869fc355563cc4b61d97827690cbf7e211d2c5afc27b00668d66b9924aed71631da96e7d5e444e389cdfea2f55278d323fde47f2073325b57f5489184d9eb920adca155ce4c789e2f00165716257b778b42823c9e387874e3259849c5d2ffd3fbf4c0952c407c2e07726e5152d9f9da43e075273c2bdadc7c5b7f3111c92afaa208377003d3eb2db75679b51fcf8ba4db697ee6aae31024a174183d136f494b59ab0d8c84ca609ba8005e6030c51e9a05b7552968cd74288b231e916aa36a22d806e56a90adbe537ab101c848429b89d4821adf3105e535e26fc2f26348093b7688692b2a4509de8d4308b32375c456e3febd92e71ba2ae10b1887aece6177add03d24a88ce8f39b982da830053e6e4f1c98afc42b2a972acb8748a090700cdb2facae0c170447c16fdfd72ec9df29b4ca993645c640a636e3290a7dc4861c1e8602aa821850b905d8f9603071f114a70a20e898687aa3605f8abb626e02f92e95840b0cda1dba48398c153ba18f469183143c7d848a47d8f43aeb41342081d6da0f5152068a88c1117560f607de0ff932233cf67155a07d55c40fc413387005c0b18f95907a1adeea5e1a9a0ee424904cc17c76b65392d104a3a25c65059b19553b214c9225c3513cb124a9eb9d47001ce978e56e9648f3fc88c4d969f25a0b2fcc953297043f4f453bb5be6ab4ae8df5e3c3d161f74da37e040d54209578caf96608f3db10d7c0d5e0885bd71837b705784e75b4d02e4baa54ac3612d2320452d9c713ed39ee7bd7015e0772d210ea36d5cce541f39829667e9623a84568550775ba8bc4bb6403a3943e1fdb0db1c63df129929336f630ff2d383b5d2078584c1da49fe5b4e7285d5032a360cc2472dae809c351bf60d8c93ca7eb8d06079dd7b39b778e7780659599e9b0d3a2d1de46edc98100f67103f94f01a2fa67162f4374592cfd3ec9c3af99d6dfdea44ef31ff3eca8f961935956e22fe1b7a88126dec04b174c76de60107e1d68ac2e2032a613564b308eba023f4430266bb1d66b05608a3c9480f211465310df68d8da0981cb524eaab9c5ca35472ef8c9b9ab63b778b055a94fa80c7eb266d9034fbab88b61979fbab7e328426c1dafca6e39ecdc3c5cdd0d866ec3620910924b1003e3c80e0e575ab8c239c1b6c33fd62a8b84574c92d968f1918d8a3461f11a4581e8e5ae49eb46b47aa2b66aeac6f9348004ff6351c8f79a30152308f5cc7b9c4dbf9c6be56eb608205849667980a200990e8ab47c5f4fe24e9e769f4708fa3952f17d8c95a30e1992d2887692d2771098bb3cc217ff35583d0b152a776704649a6b90ce0a73b82810ea18a4f8e3999815c85761e3e279a100be914efb49a6b1ed18e84d7524aaa673d6b5f290bf5496d0b6106d43b2d0880dcd15ff870c3370419e5eb8a327d4e8afa9a6484e528e1001224a9105a3a5a73299104dc2cde39ab9225aae803808fc1af8888e3586b7600b77f77d3948b6748587abd66469a001d5c09cfa019f61eda2377a29c0b35f6927ae042b3a7e65f7844bdee7bd6cca7f6be12412ae8546e8698e6cd0109c6aeb94eb2d224c202e6c0ba08ecde1f8fc0c359effdb9e40b965871cd8533c5c1b161d596064704a77a2cc0459ea12b4861c2f76037f9d63eb9070bd16bf3b29946b75f76448d047858b73a21c02beed358bbc40f9326ee6e0b2de1e7b37aa654c8c3befb93513ff8b5be93af2e5cc394f3b7cfa47c875fa3ea26d584d2d80d9029f7dc8577ff12c7d0b25d971a0d5ba4f1d93286990b00097d0d53d85ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
