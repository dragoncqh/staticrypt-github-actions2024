<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"251f3c7e819736b358b79243cbb07658cf9df8351c90f2ae893b15541e5081594243cd37b5191d865cf7a1a62f8af0810e15563003d1174ca5086614b5f4026d634d97590d6c8ac015a7f7afcd7417b42264c6d18402945c6318e1aea9db9f034b4ab93db7fe78274b7860241163cfc4afe2c0390f4d348e0ad7834729062ca788dc2152593f781692de038e9e3bd4c27d93dc3a1c79103a44443c8a23b741b14c8c472dbac555693a7f59cf52c00eb26672b83b5d1cbac7532fce3796a99b9e495a7481503d0ddcbe77fb9b40b60ad85821458977c155036464c50e78ab2f98166ea21b6e9438be07eee864a75cae8e1cb57b6ebb0f4ced02537c7682e80f4cd78bddecb062053eff058d78508de610741ede4b76eadd134a515001ba79e0b3cd66f02716d41ab43946c31d67f743e9612bf97e67bf260a8798ae5c19b23764a357ec3585b521bef1ddfccc9ae553a2cd4670f8d20915a50af1962a7a3216d893574eab39813dd339a7e6d3151eca2bd9f27491982413ffef6813256a443ca05a724ebf52885b0377a34d81e40772fadff4cc7b3a6cb8ec1bad16f50ab1781813a7ee87350fa945ab597d1e5f8ccb088136f02184b7969dbca92e6f34f9ab1f3b83e727fdacaca657d86e4710e3ac72e1e821758135637a336a3d59101d8555540ae184be5306a004a2d58e1ab23d6c12365edc8e91fb4053af7291ebf4165f93ce3bdadcb76e16711e081dafe16e6ea7148f99ec4d320e2d6c46ee0c89135ec923cc627f76be998412b3cf8aa75d093255b2fa123be12089222f1830d57e98fcd0118e6207f64a05d0ac39ba1b00461314a7b7c7769020787bdeb78a37d5d1d13557eaab60fc1925034b573ded37735b95f2347f54f443b4acaeab017985a33599f39ca9d0f0ad2a171cdf018c4b03fd4a25600f8979f87da1b637c5ffa85d9bb77a70da1bc66bc68aa99e4120e6f4388dcbb4d0a4c716bc0dc6cee4b03d14bc40c0de588b3e0b67d77d8a67bc59f4410096f3ecc5281ab3157c8d4cf3630e96dfe4680782898406a75dc3af58ba722e2e15d21b9b79a25bf25607cec6351d9c3eecf52e984b4e38de119ea592f4abd207ee7ca9d799b640e00681b87d1e807ec9ab8fa7d50d5cb1372eb2f6ffe5cedb4641c5151ffc782e144ebd87167fb37e3858908daa3368f166caaf8f714826f2282fb349e5ebabb717c2212aec3e664e5bdbbef053973f5347993521889d49e52b7d1b220133a377ff13c97e80cddcc4e657a9343ccb4c02b1f612251537647de59d90fbd594d32393d88d3df72ccc7c7de4854034cdd2e1302e56bf2c7401d951831b8916002a161bb2af036a34ffc5d89fae9671888cfc3497e3604d7328eb5b5c33108bb38e176024054a78faf150bcebbe6a5475db76b484d0b034bae6c492450ccc396b38569440866a27277d138e5c114abf0b7416caabe347b4c8d2f4c515446ac327cf0ce1a2b04c3e6080b0f94ebe44ddd625f1c89f7105985bbc13c2190c9de28e1b57366529f78356597a4b34b26fb84aa6961e119d5c51fd69146edd6a316feed5cb761e4cf8046b5ba95f46a0ff43e1f383ef2c6d19fd463a29ea6f53575a5f2c8c9756694762609cc8c372c13b1782d9b4b7bcd76c7d28c6c763409fe8178804c4a39b13532ae946c6752b13183941d161f971d633400ed3e17c9f61418d6242956ddebb06cbe145290728b9f21d09468a771cdacbf0718bc3e6cba2c5447b4bb12f798e6af61264463ee3241d8b806974f044e9b2fd9846345f62619a6cb34fe44d95ae379dce1772244cd2c1fbd599f4709670a95ced11375e3824dfbf3e580a5ffff955ade86b6f589ae5c922f8d78c0a125bec69003c1475139da50969da3a0dcd66399c4de612a9236fad622d82f329dbcc59222ab50fc2fb5307d54fe96d3b7293200cadd0f5b68264fe4c1c55bd5e7fd2373c91080e01a0a7934de925e3ce90eba2ba8b410dbe37dda86ed4bb7c7937f41f334953effb45a59c17b1082933d42e44b43524e1950daa1c75b06f0cb0766bdf837894d4ad1fc34257cb4a033f5191e922e719079fc237206c468a7369751f1664e14506d7390a2879b3e6ea65a0754ff0e9f759bf43152dc9bf2bc794d8f7149178c20694fc63fbd77f062343b87015dd687476aea39055a1c52520da2b584024e7abb86edebc39d4bdb10a5b7eef4da9851abfea2eba5918cfa5254f703caa1d295e95becbd6aabf20ca0c41527f6002871cd746f49ad132e4f5213d666281269f03ba05747bc98db1f90d52242a1bb9a3e8fd6e88abaa845ca6a19d2c43e8197467459ced4aba57c5cf920c10edb982942ebb186787bcdb8b4b5ac0471c078146402673962a6f670ce774b3fe985f7a5a2d01b73db935394a63951303dd07eab697d6cc82e48efa0092296baf4e8e564576e0a83b0e3f009dcf46432b7cb0c7243fdc4f3084d3ea1abfa696ac425a6f2df55794ad3739206df7bc7f58a4dd560b84960e5e6a344554993c981ac05a88b05c8f7ae3b7feb1c8e6d1369264d0af563d6e3d36dc6017761557b5a818e501cccf90e1fe56fb76303886fb53dffa6df861de17dc2d7c8345c96486d134b877f7a80872e53321b75da7b0edd9b81b8052ec3c8c03eed79546d5aa3c6b435fb4ea5b061f3ab1c15869c87b883772f7cccdabddfc396f80638d3ae77ba4bfecea43c587a3dc7fa18ae95b7c8a341bccb1965ec6306d73a861f73d5330200fc7259bff1d768023e0b0316c7031b2515c645ed524c9737943605b0986ecaaf4e2e18b450961734f3d6a8e391cd8cd906903449351042ff3666700f76c76c464bad914b782742dca56d68fba568b3164302d909ab8a10e201a2bc0727e400ea008c2c151bb65e8f0e9c4abeff03415158452610982e1ab05e636107d6cd0fa1bdc8f95e58f070377be2d23ddcb7faa77f9f2b8aaa98753cd88960a7533b413b9ded520b630da668c8093366ec08dbe90301bd6ed23cc0f1622101f75d6ba979b8425816b5d4f8c1a321c08a731c725e33456ebc897d58e32e0d3436ad2873f9adde6beec84b19cce3944b5e11e887df5192bb15e94193eecf8ce644d295095baa7b69bab27617d7ded1fc6432de0bdac3fc834495b1bc444971c45042ec37ccc20a716abf4b173913e223f0f53647f11e136a8892711857ec055e0b1401bddda2b1bed6dd53521058d55520cdf73c2756e7ae16542d629aab7fe9d878d60b16e6479438e3eace8b2ce1be7c057f1c66b38f6d56cba0f377f1f74fb3adef0d760fc8d0269a28d2e93013292222ea6a24b36627ba66a56397350590e96468635e1e7a443a4a32b55051a1866ecd3a38b29cc3fd340f28ff7217e60635aedd3c3698a07c0b00feab9d56372c94c24820c95ad9cbb2364092607c88c6a75865175579a166218b1dfe90ae0df1894897081beb5b96795c01f204520439b52c68e41cb19086c1e84bfcd634594d175c75123291ac34b30af071d0f2870435d50d765dd75803161ef350bcfe291b9ab77631cf02cd8349162c152566a9fc41787aa17973f6f9bd2a288aa130ebf42958185a693ba686e44c74e2d1014357759b20f373a964a8ca282c7a84858374ae99875372816448690fbb3b3a448b711af9f595e34dd95295b3eddda0b27f2f24a7f20fe137165b68ca299866ba88d4044a1e84480361c9573c50fd7aefa871c8de8ecadcef5ef366ece711d3b1a9726f30679a3980797a350cfb405cc350556de58a4d8ba17c2b59c0ffadeec782fff085d79f2c489e5f67861da454fdf92f94e6d8754d9628cb60b9b966b9dc4dd11b4b768c769347be58257c65b2a37afce7c1cb0566260da15fcfe405e0b38b2199bd9362055b9d92f930aecd5f81bdcecb58de2856e0e42bef0f7944ae71fa172d89e833c90c4845bdb3c4c2b7ecb0acc5cb02ee46782b2a874afabc2cda4c9fd5fd5975377284749f48057d192d82ca86f5f12aa6318d38e93847c73b2802bb6c2c13aa587e353158d072e5c3ace90eb2c2fd417b130979fe1fa465d45e5e798493d82198a970887d2323ed082a02bb2bedfa123225ae34c2a319a9caeb6213f97d315b3f7fbcbb6febf99eb49f1d07df30818d5d1ca2b9130e9d015d07868338d8ede95673e52ef955b22d651c8d0c45edf71996d4fe8be05f383c2f84c2677aa6ea5da9ebcea8ee15bc1d7830b2ecfe3c159e966e08b5801bbed485f90e47d5d88b1fe5ab972f5fa1c14422cca39f17c6073ad72433e74954e753fa4c1870015374e0c06de33f20258231c1389270b1a11b3c9b7d213524a92550637c043dd0284102f5ad214ac5c7abd0b1e8ed9786e5969142b84e2912c10fef0187215236d5571bcd861354e3116ff280700f14469cd157c08c3dc4fed97ce7a0c96a45ad1559128ea9abf0f11a4d8d8d2c16bc49aa887e053d49204d0b9400672bd315fa2f1daaaae2c45560693be6d634fc493280fe37c65d71db9c0e5c79c901689857d349bcfed61969bfb692096d78cafe9009c0ff68d23407d1d66c0fae2e1755861f1b231d173f62ac206da4d24cf7b4900a0b20efc6cf9f2a4c5ed057519d1e997a51de23942975d45893d82db2eb0b33fe33ea97f27ae831ef00f886291c0621cfa75afe783a49e3d5e14626a3cf5cf063c6cec30a8f4c01364a2f49c062bb05388e5b089a73a2c04a8302ec97a1ddf79ec3cfb711ba7f56ca504ac487c2012e66d20c75068ead2f84a70d6df8d7942e7fa0423757e87fffd56b833f1fad02ea65125be47a38a75c28a1eb14ce450b498903905da2f6d0244b67a323ed8381ec80296eacd0188c16ff88611d11c1355aef0ad84962259be5582a8584eaecd75545f01072ad3e752368eefa0679d6a1dc6cd3f0f03957750ab40e88a76a5ad78c269294a8eb85b62d7d5221c1e63bc30b11bab7dfc67f6243e79cfc92ad96c60c6485419adb3077efb7f5fdc5c804bf5bab34fec5721a7608b3adfb66010215dc4ef89c9a9fb69f6618d1ea0d098f66adf5756f410f974b57c8a38ad05adefb86ecfe6d1f084b2a6c4dc440c1ccf8d6b49a1791611ec81ac45a7a7ee9c54d5ae2c01f06fbb033c2c2918b61770a3f430b58ac70603f115091b0abfc3f90b0c9a8cb7d23bfcb3a5afcc15f91af3b4c3a6e3ee09423391f4bae459842b9607e720e44c94f1e762908365df8ea95d6af3debf014c65b38f3e668fafc09d7e37ed4e330cb947388951b5f8496da7c52bf6dc0bc348129444563a138ffc3203708c79129feadfcb5566ce1dcd7c5c8a78d4cd5dcf14372817c3cb3b534e96cd892c817f4f439f54d5448e5d305c24936fb4e81c6cd9d282e1f4c977bef1f1375394e4d5f412ec17bf4b36af3f4af803cf95a8ae54635825d28f040c8ee7224069129187369f2c9304a24eca000b0e4d5f72efe04b2092ba524f42dde67df804181cf94e6b4e72176fe892dfde14a9b3c18a942c1974bc8c3c04f644dd9e5da37a7985acebd535b655e5b19bed32184d13d44121173def523ae023603d9505456212d02b81caacf57938cba128ceb838db90f839709e4ea738265af20cd834fa1345e4ecaa773aa4950d8962cb7ddae64671069cd3ed1c984309ac271503a2d4a8390a535dbb2cbc9bd7b4aa0815a1d7ca13325b3f00e84c899deaaa72fea09ee683893834452cb7cebaa2e3e1487a94d46841baa1a11e635aceaa0f42e28eaf4171c71b8f88abf34da3ece77df43ed4a87182a97d5cff8b98a9e830807d166df9969338a03f285acac3d23f46fa3e39d6cb9927a1134ebc8b7405b87979cd5ef64bf2fcccd312e1ee9f55add2f1f7732dbf32ecc93eab93605de4120efc927f71078d6e8bf07f4e874c531832734c2dd003626431ff96f5df83ddd1db8377d2ebdba4262fc21bf71367100af10f6d854443c976df0a3355665e721e2c9cd7a06943917c818f98960d0c8e18076ce88e1212b38316f71c2f5e660575d189d51410f407ea6236b5886b664d2acc80424b40df353bc4cc9515bb7859f74bb9c0031bb9c712cd485629c080e1819a6f5a4375302775e64d01aae4c032df2d609813efbf61652f255008f50c25a52fc26db4644ed50d916aff4d13dbba2e7a4a41a17eb34a93374521b2487b5d1016a6bf98611a4de60d3c865fc16da601b87b79f068b2b2345ff10534c1f36dbeb6b588c13d5db9bc95df1426b7748021bce02d185f73c9cc0cf94502e335fb36a559babdb8ed9f5918ee20c1126e3327d0dcab5f2e767b4fa5c3a1682f41de37906442a5115a2d2fef2abf2466be418c0af7cfebc4b54e91d1d321919d6b48e41d0bcdc60d24c1e2b8e0e2f5f464dbc8cd65d4a0abd4ab3405d73bac260df6c2d5c266b68947ee332d65897c9d1731ca241286fdc7f1f89c1fed90cf52cecdc89e2920b350b96dd2a0f02da3aa262bacb4bec82dfaaef8bcf518533c531c32e24e612f0772eca9b5769f335a934fdd1a946063db286eaf10dcb4908af9d80f1d61e68140c1006a5bd191d510373966e6400c1d0195486a7eb35ee6deef23a2c141b3c348f58cd353a492a1bd04af4ff2df2fe03770df6045b65b2b7e074a3a6cd6e96b536e76427cfa648057958cb85f3f34c24b8d4559d542d80c97d97f20b955df34c9e1baa16d9a0a49fac818bb3f5e6efa42ff5b377435f880864995d2f0f04c6291810aa5ce76f15d6720262f7f9646956ca0df60bb7aae9d51e88597d517e0dda209faedefbb25e8a6358353db159e4e10fbc93f79766a67ba003afbbd5c17a47a85d8f2673c8612810d713f34dd26726772d8092b9536e6b2c49eca508b27d40812f3e8660f3b4b15b7d00880b7efae0fec5621a5b195a2f6870796ae2fe2b3e220ef01fdef373256fd7e6b5448d934d7714458c70d1ca32dc9c69dab28c4a148228753018e522f11b413899e3f7fa62de458bee9e269506ab33de9889822318f7680ac3ed2bf9f94092611139c8054aaf2ef1029ab76ceb00c7ff80ac128f7b841dde811c864d38158dd90fb70054b9dbd1520ccee54807f970a6a40e2b81f4cee8352398d67b3e7c7c04735908c289c0c2fbcb00ed82808570bc12463b08471ab4ec1e687ddf303b71f5db991712f6b1d21c1621e1f47d21b6ab71ae7a1f78c2831a2679d81826ceb45c083b470f42f564ad71605af24d03adfc381a13cd20ea0277caae2be4df1ee7bda6c6157da495c24dcd328e2efdeaa7284137db34e9ab35057938733665ab28351218c648218e31675c2f82a22320c1abf27858c40834ad46689271cafcb225bc60a5ca9da264ab7ef1b9a2c936a89a21e331d8471d59469c6b2334847c9639e18c435a77cb5d0a93e952b635bc1d6e525c8a86d89fa5455c7ba4fdff4607b50cdc345e6d760ab00fa75c6a66af4dc58d40a73f65d55451fce063aea0ee32f7f81d53bbd88e27a32fdf7058c36cbd3c7e6244c5b99ac1ff14d9fd8b3516598fbb9eeb9e84cb1d376252409263e19d2f6c5035a4d251764c1ccafabb2b62d531ae8c8b83078e630f5efc8a08697c9c3f55f7fcec630d8c0604a1e20fdf9ab47eb89a108f929f58aac06003743c95066b46e96cf35309b11cdaa7ff928bfb5681bc43219dff83d59cab6c179b580bbb8b1dec1b929f72f2f14adfe3047a6fa586d318f54fae631269e98e32d37c80a4320ebad528b753b89ab3b20c2fd102e2ec89a1567536199fd086a1856787becad949bf5793e635d8da0c6514771788d67d63797ed99bf78afe966cdea0931be3b56aaca271999e6280f54ad4a8c63a0b9f448a0b7860cb064ecbd4e72be9ceccd1a36f1ef805afc74eb74593b08b2317898c12e0a9103f22f0fbed8ea82446af57163e197f6490c3743c6ebc7d5d9e62c6bed6bddd595f7fb0179e61e323169a7a25186b7e0432988bfb2a8d7582aafb7f930c219ae8712fb7e75cd5494435caff04f7f625e00949ea384520dc6b9bf2e347be5788fca91155a3385dbc3cb54c7c5b295bc3a05aec25308f934274ffcf585d3154130ed517393cef79f7399da1f4be6ba8315426518c2a68f26ff18531b51d536f4780fb246419b40e043ff62c3d40fc029fbd827385d79f3e3ffec15079ba40bc4dabc4ee103058d7a7ec834649885004b0f89d5005bc26061549c406422e85759197e44bcaec95c0424eb1fa1b0acdab2661658f34bb4d8aa8c2603db25e6efcb074dacf46d915ef0cc1875ab416513899445d55d0c896406a931cb8ac6bdd9432019d4b133a7f48c60b96a09ec1a3d312b7b6b8ec9e31871df05761144a488b664fe8f0a9f3ffba1b7affe8eb5ea7bd15916e84a1e95982050b2f19f55e60cd6be5e06c3e0dbc5c09937ebb26a2d346445cc242036c55548d0035afdc73cb0d249203d649f11cae318efa0218e44136ef33704a9887f9027b6829587a782085b48e2cdc603a111c016b53645a2444dea5a8de589d791c732131d5c955ac455edc0ec2803010f815f46c90ffce16e721bb9c61cfccb4b6a384ac998c6d10d88104f7582e3cae83418da991bea8e37ce1fe786498e0051530916cc0084483042c24bc7111c5a24260cc6843f1ca8797709fbe282cc67779b020f570bab4dc464a78a23d6e9a07193446aad6b36a13e1f4e2faf667f8f7d88649484ca5960b1a3599089d67ed31223eeb24ff1b1d2d7b71b93b30242aac8093a8e346c54a61ac3ea89c2ee37006c3066b83f764379587d21c8734260ad845a3c80ec1760a904c8e82d55356e2fe88bf5c6771e082cd543df86f5948636184ba1bf925d3f2668199241fc226baac6e70d4b6155906f3e01c2871d8761a06e315cd916f4836b8a9c29bbf0ffe9fcbec6084c92172ce7daae16c2730c544a748b5e0999af8df442eaa63429282efeb9197bb2c1026e5b5c59a8f5a781ac95922b120fe7216427b59db21415f766ede35e1c7895d5d1260886497d861e6e729f614bce809c6ee1483dcd0ecf4491356ed2ded67ef63c2a6722d7dc14ce32308df4c6dcc2559ff8dd5f1e4048399c9926f0f749bc9657fde78f281358f556027620b117f3c17d8ad66d1f59911157ec1da894fead555cfd9d567649943d8e44094868e78fa2190236b342b5bc3e104109cd9f79d690bd8057d5839108e682a7967bdc0c4d907bc0af28dd6c241c6a8de823a82fc6ea0111b346aafd5427cbed4d06df64592e8150658b653daef7b2d614ce6c137f7d052943c6d2233117287ea7f5a8a810ab1b215e0875ddac55bf2d99c81b651d57e18f9945ea17193891ae409469e48c2458a9536ff3b20f2da6f3997b2051730f8c47510f5942cb325dca6e01f3d9f2d270d4955c09c1a7069f13ecf4a8c3f072b2f09f81b8ac07de476ba3beff67ce7c9afe7ad6b2b72a0d17ac1e51d4a306020abeb565fa2618a6933ed55c77596ba0fee9aa476f6705b667cbc48bbf68bd51b9a928ea9e132e7cafd1365e7ae94c109875ba6d9499b770b78c14d554a042cd34895b782b7d9568d99678082e953061aa5392808d725df9830f6f00376665e2eea1274f73e6b6c83a8d8087f9c359d20806608b347e389b16961b024265c1c97eab5cf6672bfe0cbcfcaf63e29ae7a810e125d193f969000d14f2362877bafa27d29167455da724e7bfb73b5907bce38775b0a5143696e79283fa3e308e82d9a2987846d2f5b3c84f9abe84f8bb2e7c624b24544ce43b61ab915edb52646ff38b5780b451b34e1d825afd673e8928c8f323574f2569d79e93dc69a01874ee1c5f4e5b7ecd75d8f263d2b1b60a14813313c3e45590956f13247f033546cc80390b6669851b8f38e1f1a082faa89002cb907c08dac0bed678fd40e4462cae0208d07c41b124100959d277bc5b095a1eacae3e072c9631818c3354d90e4c447ef3521575b09d203c9577a75c213628582bec31ef68434fb5ab303549071561bcf05752ed1779ba592adf11833945331b77110327be08118128bbd457e30d53db5d0a4ec1a971af32e070ea477ac682473182fdccf57da6a3ed537cd7e1e06cc13ec84d5d500bb6a49adaca32d32b462b0c208566232a1f3b582a3f24a3d1dcc62c6721b0729a2d988220ceefe857511f169a22e2f461153aeaddd0900c001eb84695ea4b77def79521c68173386e488f392dcb1badd87a2e5be87d737342c1740bc77e0237df82789964af577923b706c920264f5d0c4daf9ae96451e17680885d34cd0751d240cec2c601961603d3be2fc2b33a55c7ac7d02382776a7ddc14d0979b3b01a500cfba21e46413ebf9cad52971c5ed327c6d6eb333e26b7197a4d33b1a47bd24857d25d0a1873a939033212b7347e7868765563d53076576a89fbc9c6d51d460d0f5b665df5160013ae0a0c217aa4c0316ee4cc71288561f7e10bcceb5041edbb41ea3426148c136e80df2e161d2cd28d2620d7ee4cb5047600d443f360a7a88bb585d1a9059c75bdaf5b03c3cfafb266329bfa6ef0ded64398678b108feb9537d224167cbd0b30cda66e75c4465c1a1a0f01d02cb7d64eb13acf1dc948835701b38927f75764b10cab89f7da5ff82431ef3f3ee57ac417023a0b9677bc8cfd10821302368b735cda74edbfd6fbc76b039028c23d04e3137cf69bcdb8ac9b36010bb91e3ba318681a70ef7cd997f8da345b1adef784b4b277c529335fca247a1df99f8936c8611d8f1750b2fec30afdfcebfb25026cfa69e4e17172835c07d11f12a125961a4b64a22461ee7b733253a09389f36ffe7beb7547b55f53a3b4835c302e177f225eb1d09de8171d74394f7b1c347b311d167f8f7674d51df5c4592f750a1f6da3ceff218c6431ef581676c600502075bce03decc05482a140490f91534118c5099f6a7bceded5f837a03f542cf3e42985ffdb48b58513d15accd6089e25ca530f0a5a83c558be83fa2a2d711173dca914e23d3f99bec561cd9449c2f40bd92140acd83fdfd4a9ad0c5abfa4654f3f8a26f82df983f68999024a8ff04197c5212884aee455ddba3a623ea38acb4b7e547035daef204459ff586a21a88a55cc0a5b295035c12ff7dee21f4c67c9b7f7f4dafd9d58021ad315cb9f6e92bf29b54b1cf55d60cdd2b708105104c93dfccefb6ad8296d7a7724a409240f7cbf026f7146289847f6cbb38729e545505549ae6119587efcc6c0e89a0081ac80b8804ec7d583b5c485b4a036e188d32d5364dcf2983ed9d292ea45c73ad707b26a47c9720f602c8d1962df4fd7271016c8138bb22d36090c1dd9d449e1b9c18c582969747858f40aad70941dbe70974e99af7ed74e6679ffba1501a00dd42092c257ff5e6fe3df0abde9d87e5492a2b93e9bea1a70834709cb08a85432213312e65d5357a188ea3ed2d578287ebdc6ee8cd43b99bb7c63f6c32702aa5471651767a0e06591c79c9206b1353e9b760dcda5307cef92c3ec6c0b999559f9ded93436570bf6e881f700f3e47d4dfa5b9df74ebee94b3b2e2a71c1cb96fcf7a7e973ef04c4d759a962f825ee26b9999427dac710d57c28e6e2403d374532b443efe32e505aae0464327cbfde5115a940cd3a6f5df6cef8f594c02d850120858f5511fe990a5893150e80fb2665c76ea7c913a61c907d379ced16d183c6da49f260a3e75989fee3425182f774065493cc45e29143fb5a095b431beba5d2756a33d73608fcce445f3ea9f3157c92fb382a1615f9ad8fe37271644b350f8f27fa5cb2852ee0da2e2f5763d0963f147119f946be7ecc1f16d76eecb15258cf89f5188ab758f679853610ca729de26ee13c5883d71724b1ae0052734a9f33b2fde1a80a43e622871e0d352d0be44818230f8e221a7bcabab73f95dfd5be46565e3339b74afa3b6f04795dffe98558af158535d6d31debf571b9651d70acde30813ea2a99982e14c48edb6c5ed75aff85f8ea12765952dfbba1667523dbc2ac64fd912d848747fe5edfa65f17771778e97816bdfe7aa3e7e0f5168ac901d751b84629b7798b40757d2cee67379e936d61251bfe087a366ed41c1a6e9dbf8ddd5f16de000198ce086eb228961e44494a8be99434e23ad2fc54ef796738741721baba61fadd906c33dc68938f25cb6a7dbbc6d869a2bab4c2324ebeac42067cf266833c6f41be58610d167f96a7cd0a04d38f4af2b811f9a23c65d20763594fd2ea6ec4dd19c506b3b0b2740922ec090e9a80b15e633c99957a39fd3108101651e3a4ea01c860df86f01f8102a2b3c7b18996eb2964e05755f5482e9d00738ba7857f529d26e7a127f99a8d840fb643959451a5c1d154d60ead2af16d8a5a44169e5f9a73fd404436382e91a28a1b7dfceb3ed8895828112c28d41d76b95dce1573fd4b1374d539cc31db5254188c7df890ad1da7d4e45a76663144d919af7962bcd3516ed7a7869d27e5efd82394a418b9b6090e9fee45e9adda9fe45e631230c2a82aa7ba2ac79accf1b09815e6b2b574d09ae4c461175c59561275cf1e3f0f84ee511afb49ac4909df130adbb8c3e48c0fba8f3c2ac9dcf86b1a8ed1cb486657c28b755e7a08d26a8f3c29bcedd0c3e291fb0d768b4e328cc2dbed202d0b1809bc9d83e2f9f53943e1e487d7dee108c0b0d61df98e16404a4c7df92c3c74fcb62d84799c428306b96fa4f408d29cb521558b0df6d5d8ca2a84194f3fb28f83095d9407b32d5e74ed96ff4540ed5f2811ea07b325bb23dbe735581ed2a18a904dd30b9870bbcea2053c4aa60c4dd93ea92c8c1d9fcd2c2bd806da42948d83fcda6c97c2588f2d980590c7eb842c3d550d7724e5ac92597707cf201f0e99f0f0415e2500d5aa3f7eccb537e48abef7cb44f868d7ec233c22a78568db76d84e3806948c41117a4734e9e02ead9050b364ee1744998c653b9e4a0a83a8ffc4aacf3e2ae0b03150fe7bb579d7d16772c28000db55997ec0f99cfa1df78c361d606c96e33138cde19d9b67f812c400382accab95cd9e2f5d779a21bc41ffabb695c914c61d8ba512c25601cef55f3fc2309799a025763d78a75c76e032753b007a00510804027323073f98b6060bd4ac5c64356db77457632be265cc2bedeb20d0c46c7b73f2dae34a634790dd143e9bd162376e66dbc163badb9e06f24740a832d6fdbdd6c57bcdf0dae5a3edec3c6cafa1a04b29c2cc320406e29e6c67da67d63106268ef23f7930b89d83c42df82144610f5ed25b0f2ffa46948e73c15ea15363612e68e766d8f535f3ac1810b65feae5cfb23dfa7ac70d22adbfff189d05ecf17bc81a96550e3ff471c338e2ed9f7836001e7b05a2cc4c73a597d9bb9428224c86badbcb4ac17da82d1c8b37bb24acbcf09c37a7f534e0e8bb0320a765d878ed232f293473b99f4ffac50b3a1ce9d3a27654f76d1940666e33a468ad969e6575242cff03408c04a710aa2d7569bf3b498cb35cb0fc6a22845e8efc3a9abd9b983553c55c46c81503048a28298e3600d2e38bc587cab2fec4616c0fcdeece6a36dd9a385308120c1dc10f6f8c4c421905afdc75a6f63a5208ec10d55eab93211296d97cdc704351a633cd6315c80a36dbc34317182d391692a995ff78eb84daa21a46c4a7ffac0861aa5ca575d88db9b3cd113b6035cf6a4ce89ddfe616d93637856c0afa28e56757f89579dba1c8cadc5b1f7110c12ec377bddb2a2aa4ddc0ebe9c8b6d85e16e4d658b131ee5e0fc7cf9833d5f4c5c5d6580084b543c2ca838c104a4b3e3d582cbc4f8a759cf793fbd8f3daa0826571a95fa776bdd11e35b80da6b5650052e2550fd9b6a854198f5aa4ede1fe89dd3c5a32e5e3bee948e56a830c114382859e423585046021229a2d9c569a69fe0768ce5428daaff9d9395cc77492231030ecfb05ab15eb09b1cbe6fbbe25d308590feb6d5eb7ac5f1217c5ef60ca612173ab9e89d0a05e0ac0be7d1202126dd223cee52b4f0d44c4174a12e483cce3c39b8ab1cfc238d9d67aabf5f7682ae04d78830193c36e54f422b28fce9d38aba9d3271ba269ecfbd4be8ffed8457264be627a4e8ce3b845f01e0409ab9e8eac92e815cc17227c004076ba786643d98cf9b1c57e31a6413ff310ac68b4e3570c6d8bca2785777a96dad2431c8fa3301e604aec687789c82adf41cc15070743d94ca3069dbdd5cb937faf32ca066249bf673bfa837cea82c98061ba4c0852ebdb8e4e059824deb3dae52d9119d190f0cd1195a6fc5bed642c4fe5fa368fbde59de7588afb212c306470bb9fa5e982a16454daf855bfbe21671b4527eb05d90b93164d5bc1fd1f51e2043cccf35f9986e660d65fc11461232bfa074935873b141cfebd28481f5da674cf76e7d59f832638e6b96dde1104729f7d4252544dcff5ba52cb07cfdf73ac52a784d0ca4cc788e1364c9c0a8a02edee6c5b136b4455df432ff0cd6fda7d8a18bbf5951f80e235912ec9596c31b81077ec32c35fe70bb90775218500ddec5b0968266e641985c0ff812881806da5cd7a532444d85f13b549196a269a294e14b658d990e8222b311a42a37fddb783b1b060ed4a392cc2b50e5c0d82c75b97b39290f2deeaec9061a634d540f8490d6d668bfc00b22a56d1233710c818dab969bf7194eaf9b313ee00a242c67bfa92f48442210906f436057d7f20b8517a4eb9a2bf57ef44c3b932fabea728c3ffdb18ff2c05e22f25690b2e05e0e0bd497e5f6b7bb7c15769e2de01f2328f4c714c4385bf55679f3c3fac0f3309ced1595634d916cddb34498b0cdf5cc6a03fa92db038e333cf6b1578712028e95ab3cf01975b2707f63c4f03593d59f0b15bc7d960c99d09773f64f7eeb4e8b891e67196da74c3ccf1ac1dd1b4f565d66aa3937aee90d4d7884290a4686667265b4118a71ecbcd624963631e48cb17b10236a7428459c5816c6904c7fec69b1e60d0169df93105d96eaae21560cb257a01478af1d8074866f5e6b70971e7952b15a03eb0b2d801a535cfab25d37278880579a07d3f33d79048a1c17cc22ea2a1c5bcf3d755f2c2a3d2f5d24c125ddd463e2d03fa45aa993e9fe6bcbc1042987a652b76bff923caf7e50aa6d6255e2f42a22977277fe2f990b230c24f66c9ce0f78ba2d83c809d44da819099389e77b0c1df5b406d9ad66399bc536cc6215f5a8e029e20b2685bd5b43fb733a1734f07d9bfefd51e1b4243a35a5670cb0f1cbac9f71182a16382f4a636cf90950ce3138f04134b007cf41bbae6e6501f1ffbd462119b9b3838f8105e4b050a1bcb3eefa916d43fd374eca97649841369fa2f94e1fafd54b863854e256b6605b399668f95686452dab21aef810c64ed566ce4584995a51773f01f8e991120550cf47f2771bf31dc1c9d31a5e7beef71e098e8b6aa399a1bab7d71a843e85deafa21fc2254b341bb8754434813f0a7339b51f4431bc6a5128d0b2f28b8b753637ec85db2eb7f109fad5a109c05f046ebf0faef5447d3be7f45e5ee22d0766b8322a7579f1d4a9a3b269cab32b5b046b025be65b95d989ba679170873f76c3f41a7562778c42cd7a75ca7bfaff1b8166d789430ea4bd115641b7844542147188ea173f92cded82c0fc3930cfe7eed68f9671703d6d951753da767aefab2c31346d5acb97b874723d7386b0bc8ac7e81bedd3873b5b4b537ef1176b1b6d6c4abaefe27fefbb7293bebe74af884baa22c509ee3de64bea1fd0fd695413d1c3289945b10f52e107eb92668fe074ccffa8c102c71d1e923ba3bba62e268c689477518af5284c75ce576a266327cca38e8fc6fed32a7a3f930f620d662447a06221c428a1f0d837f62c8dc8970d0ae7d4ed242bd870c90b4f35bd7c561eb09a902ef87b12d906cf4344990dc60eb29bc3d8c06a4df7ca70f28d23e0812e87a6a192f205af12bc129927149dda6380d916dd69bffe11c49bd7031d129a31695abb549d8f793d8089b817813e5e41edcec2930d6d2bc7dfb105fef934f6858d05383b65666557074af956deea9abc88275c8a80fc09fa52841262fa2d3b98c293995c5b94060a1a58bff574cc2acfb32ec82a7981ff969e7c9482700475f094a9ad7945feae1dd511a230e6ff98db50945486043aefc4cc62103a37bcd5bb79cc61eb1832d3a06c9a0c6526f5e909d9dba1173dd16dd034720557026f844aa668219c35952dac3c6a088036914d45dc075b4be58cf2a1d840fc0c4b1a46b0a738c2d27b7d076aae411f9d64394678d1c6945f7096018fbfd7b81a0fdb802265c800b25ae8f6362d791ba50ad7dbaa399586d7a67a3f358e658bbe9f39526b25256f222f80b6c5f11f0fc759a4744bf3d0b58150fd44c2bf2782b3e125e046729315dea7f1ef50e228d75a4657cba4ed1193883dec0d3c860da9df85076c192338ba240ba9343bf13d217a4f604c50a37b319b0e4c205811d983e84c49d60e872a605fd525ede66f04b9c39f4c499d54cea3304a5bc38565e0081a0e25e917386c3f604711898041ed7c46a84ef874b3cb118bafaedbda74dad55cd2bf85402c56212f3fd761d6a5a1039779a1e621b5a4f268be95e339ba35ae8eab67edf7d14d65cb40bd34e398a5438a2fd15574be8b560bf8a5686e3d7a0c36b996cb0b1e2ce612faa507ae168c1a88cbb5151cc8f391cb4f4f05670747db2b456fea9a0a588817ee4f892110e728ac09b7e3db4080930ecc06d0a539ba1d62f9eb134aedc69a0e1d7e2aa1081ec1b43190c4d4f5d80f154111d35c56be703a0e86673692271f2573531d84067c5a46c474d7bac128a7fc091ee045bb8dece6e9a4664b3329c33dd4dea62a5ddd5c21832f741cdd6acc75a075778262e2f02d6689277344f2498241569df817c37f8fef2c24919e460af374cf5453d33eeb6f48a0aa4478f0755ea0940ec627b7c3d3613b586fc09632d5d34ce06ff5730c611bf96ecf270ccb794337da5096d32718a2388999d3b3dac93172f514104667cc7a00dd44b416d55c2570a6cca6b623c88b0ad8d522b343566b69c6d5d2ec3d304d0d973f12f6c8ee2805c6428a79a34ca981cb813d35cc70423a3b1b2c5f8ed8d97bc7da5fb37ba4357b0551445974a8f962767d92cf409bf18bbedcaf8909fe588d8ac28318cc1969fc909c9455e731719228192ddbdfb7e372e1b1f2afee808fc83e7ec3dfb7642e733d0e5c3642055b81a05c811e74ddbb9cfd935f07fdcdeafe5a023e8a7e186dd964de22f609e095cd6bc52b16e5e37fcdbd0036c26e3c89d8a03de52dd10a462b900216d647df9220841ce3218c74fb0252f719838e7b27fdb49f617c2b51da6dba88eff9791ef014a79ffece35afd48f6c66906082adb135753becb43175d201797f86c4ee93f5d580147255f376764cf4c1218753ac7e143c5e1279cf1dbe09c4bc4b8d7375cc732a1c452c002b0be7bb6eafb79d3616ad6b74d1a9559bb8fb57f702d88739be8634ac1690816a574370ca83152357f15c5abfba237d2d3b1da70debf0640d105c75e8759785b7544dbff10b74b1a0dc00afb7dc0d9f178c0b66fcd6529acb8f48e00a141649413a95783a8f1768b571894e9e075ff01337122d9c4e688d74b80312ea9735c674262b0322a53c11a096cde903a31f3380361db0ea1f9c7c856fcdf5354d1caecbcb0b72ffcaca601455e71800a4881780ae55404179d92c24045b5f8fd4e79a3e0100be45b54df9af58313c2228a6bcd154701bae5a04bba83d351530d11ba34a05619426677917ed4ce58b6fb56c8ae1b920e4e2f1a8dc129e0436c6ee7eaf1e74084b8187c53fe912b077c4891888254c2ded2b548e785f1fcbb140120ab95779396a3a7e5681cacd6cee6ed3efaffc846a1686e5e3a17fb2b0d79d08665fadfdce9b0148ec469bbfa1026d7a72b9a10b5fd465a6681237dffbecf829004dbfe19bbf06953010d8c57146bd709d4587d834f48eaa9aca715a0361135dfadfd3d3f0e2e6f1f3e490aa9f3b901538c656f200bd901527d9e86c810bd43711f7ef396db893515f41d5b0e08c8a6ec91252bbc978979b5ec8fc3f2b361c1d9b813750d99e23d890dc2000be35c4bc37702f44f642df6465d46d152b057c8db550f34ad34c78577e0eeb13def95d62318c4b4a7f66e58c384f983a69d455f9b6dd37015911f5fd0ef7112e1a97dd849b68e167a14c4e0b9b97ede3f849b8551f5359feefe98d79fa7920651d31ea444476106739166cf6ce55d87b92cc29c29db1368acd3684b5154e76e062f296446e5082e1883bb78739852992965603d5655bc7382eccf69064b28f7ba680ab8b15092599d7fe747d79b8d1a98bd6e1abb4777f858e943f8592ec429b9743b3507d49556bc0ebf46920b551a5f5cd1e9611c1df87d5f58c39a410aa2da14e43a9c7d22da11f39358d1d863643887df63b520d67afe7989cfa482ae00d947b20871f320da19a105ecbdefb81046aedc6a4b7b307649aea8718f7c0038b90e3bd0a1be4f4192f91f9e24685d6c93cd47dd41d6fb9ed3f0e7c12c2cb50b4cfa7360165c4ca9e916a4185dd747792e4d9a59a5efca2474a994712795ec9cea52d1099fb86190738b55b712e7496cd1394b0b570cd96bc71e6ee0fc6365befa4ec2c866077a3fe06a9d5a4f2fd15d523327877f20c13b855d52c7b1d66d8cd2b220654a77d15372bf7faf1fadecf86894c942f894458da2fd08cdb0182645c2a91a87549d8a4c39ea09cd653e99adb3f26512316a2cc71c9cf73b93dfa6e4dde867dd948b2685203aacea09ab5b7a63e0f7355c592c1bb444bf43f086c4173492b48d66f875a59b3f83f31a766fbde6d597bd40a67e4c2602d38ce264bf5fbaa6f8946f16136f133e686d5d075bb524b65b7fc4d8e1b2ea680e30a2e478e65b18c6e56ffa4a249c2238ee1835fa84b7b4a1877515b228fe51bdbe86420aadcc04ec399f83801d8023fbc7388f3ad1ca8ee88cb3683e3b6fff5fd4c23b55938343fdb542815a42c9ede751f12460506afadc0cfb0257c2311d60abdf2e1b4063b359d6bcd2b68671529cca863334f7eed34faf1bfb1c41e391e1652afd64fe84f743afb6139365e5aabb15b9ce92c686170a78d22585fc779f50e274a22dd04e19260be27f55d3e0e590a919c01b3024eabbb27a848c59e161a2a381430952627596f6c5b2242f65c89c09fe192c9182842bd5d11633088adb429d1bb7ecd396aba1c829bbca7f26dffb148daa02b1e8d9c8b2007d8767d20e26a7042e46171c1b0b96195d4f5c66ea88661434af049682c3f79c3b8c819f29607494996feaffb81d2a16fa557300c292965832f985ccfe3b4d83d81b91609054fc774b96200a7c8131ac7b4c7ee9ed02e12ce786c2feda6545a535db3c9b28c8ed6d6029691dd79bb2ad9ee833ab6e405e9113d3fe8a2f12cdae3e1045cc323cc0fe92c6308039dff1cafd80845865eb6893f8bf20dd4b2bfd4bafa604cd7103daafd2e3e3d058765fe5042dec3bf696491398c095ee7fc87bae6d2f208227db16f255bc774897eb9546843c3f960ae9e05be17cb6e7e14183bba8aa31a682b675f7f834e2b7bf1af86fabe83333e08674396c3afe78bd29a5dfa176318772c7687caf61e149d09d3152ebefe2a15ef0f888b83d7f6ba196f85a5cd1ac415ce7fea4c4acc02e8b2d009d7aa1ab1b3e5bf7b1ba5b719ce4f226177ed28e95751eb9bc1fd36550e56262673268008bb645c651ecd3ad0d6ad0f444f9cce906321f58a8299ccd362f40ea37a7a54c4258ca02e2ddd12c754bcb6d9341046abed7bfaf4e03f9da1638e8af19a46699f054ec2217e7c9ee470316156f9f5e4565c6acec35f56aae838ae97cca4f2047aececc9aca8892e7de015829b1b846a6ad1141adf98675771ce79ba429b820a6c7426180f6a8066b0e485e0b0fc717199251eab2ab670a6219a88fe899510e85dc6e5549ab79429d255e0147550cb0adf4c212abae02b758cb54d692ee741c63a4ca6d7fb6e9f668cafbe7ebcd312e7d79d5959a6fcbcea5db5c0e226cb251b771e77ee939e4eb16ed42fdb2050665d2d3e7dde8633f49d959c1e113b7a1bf683096f0cc97f3893c76ccd949900ba7f97fd20c750c2e1d4c47b258cf111b1e29ee8d2a4d400a9ddfc1fb80909457b721667b358c43efd19fa4470f5e8e5b5ae70c9ce574c2bcf2d50ad9911587ce239a1e5f3f0793aabdb2331d17013bea1edb644045252d93d288a7803d201da27c086608ba0ca48077ccefe1221fe1174ba5626f8e26b0a6208894cae3e9551f09ad4a3bc5eb82c98aa0ae47d238d8306e908480f37f4546fbde8f39f930dd825529e88562fe6404ec0c5dbe0892f4a08c4be931f5b02b447adabf64750a0de64d49a092f8ee2d4f735ad33b331ff340392b50b0d104c3f1c8ce4a88f5968512f01625c9c2bade8934e2a3e19119c065a40acf2be3cc173282eb98b33da4e10a3714c69a8c39f4e5b5939009d844a5d4d674dfa4c577e3c7444307271aba51830ed71cf6fbcdd93d3b3214176a6e4e996833ec9f4bb3cbd9f1b5ca6bb68620454800e0d49bfc78a5e5ba0cd187200066186f4452b8fcbdd71dc26ca2944f4e286521f6a1bc42271efbc26cba05042f2190fc26d92a7c686794a8044351be4b36a0ae9dc4ff7045d90acb261fefaff0814eb7bddb3477bbaff87ac541a96fdc784c45c6030be2db06df832946efac97b10e0380abfd86ca3013b1437268e9554c90a1bb2076f2ac0bd21ab6739708ee74771f7ae908120eddb0a53c891be917c6ef7850f72b20bb7f84ab5881eeffe9600df411c44804eee9ff8572cf3e659bf79e6e5dfb33f1124955720477c2edeb7d4a5c93a42b84d50d97d2ebc3e4d3d9d8936add757e8a806f10f0177bf74c553dab0c296d0e5195c5a8c5dac7fedf807b9ca2c308c642cd9c23b876b8ec316492025b73c84a0e61a2d16fe8b4d7eba09bfaf2068c96ef48ae449cfb463ef5423fee993482d38fed1392d97899a7ebe2aad3717470b13d291248fe6e306d297094bd02f0b29799fffb14813235fe917a9f8c888422c27e692fbbba36acc3aa45cfaa1eb15811f69f09d3551f421507f63204008af2ca8e9f166eb083545b9e516a468675bd13cc8a0411086bbf848fb58e723c88e00955e6d1b09221a12333e57b28fbd7c1a3511c40df1571de2cff6147a385b7b5d404d631436d9717823629f03ad9e9ffd67708c6d618511e5adbc664ace1bd0d0d3ae61b3e6cf73045877ea039fbc21f00676c213d33e82fbc08112d2b4a163c922a845cda5fba42ef0ebecb25decd1b9aca7c1c7f8e6efd8d587fa208af17c6ac0746fb3b73fec45b18046a1ffd6483ed52ee7f0cd44425835a89cad7b3a146a8f35d7ffc044caa65087ea5197eff2609febd90d79fb30cfa0253658822435867e4aa6df2b08cfdaa927b23f2707d0a8ae11da07b1f64878afe350e52d03c13c5bdbf9927ae95900b5f68e0d2bd19fd0f4241855518c7c4e60139eed62ce493050cd14b06fd75e8f273016e162058590960395dbe96fb312b16f5cc414145cd2887c3fd5b6560074512859bf117c6cb06d7719b159e7c48ed26c5062858ff8660f57d0b02932d65c2482915cf2d0506c195bac376effa1209471358970126a5c63980bcf08f32dac1565c4156ce895aa5901a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
