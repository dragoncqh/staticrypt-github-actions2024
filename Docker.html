<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e68f8236c685cc21c15fff5e90234f81bf74061bf21d6707aa5a2b970e228604c4a8dca18a22c662e8e2af037f5ea1284e582b6c03ce16764084cd28a8c33a01128dc1f9bd457b79e730637511fd575611d981723bc88748f2431f3db92d3bc7bf27b7d8d015150d725ff75dc90c6f0face6ccded64abf45ce200434674d722e92fe26c23882d3e15c3aeff8bfbd8a616606c318fcb5e5f1f368760979219151731a162c70a13539a07699c21b38ffc58658da7cc8826e7c246250bec5b675c5ec56367abffcfa009602ef98d7acbe197997b3a8202bb85ec889abdb1deea8c7fd46d759aee2c42b716ccb4c77444af07fe54ac8784fc8fd01163756fd794ae00c63961ebc517a1bbc646b4838c8aaf1c2bb5d320b4297e158571298598339987ecbca92ded7f487ed47b06d608f410cfece9c4b1cdbd9c4417093bd9c110a8815060dbc686bd50d4b2a0e8f8c88692f88e83dd49464950c4e7d7a2bdec8cdfc828a6d8ab652dd11d5107676d96195aba75566e3ec20360b3c7218d1d58a61b397f9f2b9db4925f7bf59168568aa3b3863bf3d5a5a03286b58672fbafd30fc37805d6a666107f0643d480439de66cf41db4f54fc72138ea89f628fe23e10e70ceeeee2ef4870ce917d3849fe362e4dc7fc4ccb4ac7f8841c626adcafea3681b7c00badd888088b7a7f6e30f3d99b72fc747779ce3702026f743cd0c0d7b0ae911393f8c708a2e373a6bef8bfbab8d1f43fa8dbcba95122fafe8a2287477127344ec288e5879b7d363d1264f5dbe68ea78dea078906d5dfd163c1b19a4f4006bb839ef6dcb806765756ca0affb17d16ce381da3ecbff630a88fb688be210f3b4b0d96881c6203822c1e733f78166853f4e3ad8c12e75ae5830dfa581591f0088325d3f908762d6bde246bc8ec2a0f8b499319428f37223449b03e8f6e67864ce1c97489433877e516e6f3b17e266f45c62dfe9e8ffe29a4d33181c04567a65a0bb2caa254586dab32fd0bb24dd790d0713eb84c86603450b92942fb178cc5fa6c52b7ae58819f4947d7d6b7ca46c358614735d3a2b1802e974c1202e675360cab6c34a2ba071a00619588d324586c6c8b89fe00f89eddb1fdedc5e84febe68065624e1e14783e39b71f8fd6f46324ba8d2d2065f785cf19486cc6088cdd3cbb83d8404c1918ec084b76fb37d300058d746bef6e7c5721528f7871dcf39d8415b58b14da8c9d7d371bdda15e823ce520b74b9fd386a7f546a193411d5fb963c39f2ee6a5487ed3c30377931ed0d78e98b9b6af6c56dda2d7eacfffe43a4e56595b00decb0a97d60db3bd8883624043f8b17c36eb1e68f8c412d6631e2946c416b95c65e08ff5b887242225444cc66348da8790901a029b24d157d72861c0b3b7355cb7682f4d7d6d2ff075d121af80fcb70253f16319744bee7ef7836ab26be26b39315885ee95d513d4375c4611122302ab2b8f49b354f621d4c075a3b76def613b01846cde6f3f80b3c09441553d31295331c33ce03a8135a3237cfadd6eff581b29aa94755408ef2d6fc2d04cad30d381ead925a32bb0816501aa4c5a6c04a3b9dbc594ec78145deeccd6b108c9f4a3d0bb630a960dabc9cab32746be4a65c6ca58eee2b82cd598d13db2ea601817a566e37f4868d6dcbc2a64e141c69495bf934f4c09123d0987f2f36408434e5618bbd663a3a883e4f747883a814b9412a0c739ef64b483740fdbc0228cde51f17da01db95d3659e6b8b6bf31e0d3aa50d38889415d51ac7692a6bfc6b865679129c330e784706060c0af57f60645daa88082da4e6b450faa8787f924cd0d8864e2f41104f193bb7cf50fa23d7b3dc1f952b7875b794643c5f8139445601024fca11108de044c66abe7f401698cc324ded0ab4dc2861bf379c209fc2e2dd1710c6ec4327d53de534f230c15a2efb3687a5abe3b808e7eec4d7da9606f03943cf7d299bfc803fa9564433d0bbb028d4f901425c95fe12b5cf95a14ed7dd365b7f2b736e9346b70eb8932d70f222ba73dff2f0409655094922c50ed7b0eb8a0180d2676eb05b1fdbd35341550d20faef1608a0cac350bbbeffc1c272f4c9da9320f37c694fec18c5367722503c7256d76a8128d9789eb770e32eb525b36c25e87336cc316495b99596afb7e93551c70008acf31ebdae36f77e2cbc975e422ffa110d20dd3782758b5900a58ceb0094bc1ec9bf73c35af7ddf82c73990efa0623496cb803643b5be804956a64ff8f37f7b2e597c40153b837bc4f9c5b56860ca247a7891c273457017641f38b1c91aac350b443db198a61d18996bb308fc70cd9cb361848ae901807cd4d4ca86086629ce9da5d8b4bcbf0b7b38fd44501f8b36dc7ecd7b44717c765bfe4b3854d8dc2fe7ed744be0bee71fb352f753d770a78e38f92bcee28b045e6d3709ce4f6688c308c6c26a32e20df622bb609d2df99d468bf580e27a50148d631f708a6fa8978585bc77308dd3c549557a22f3e701c1424580d190a3b7d2500aef4e6ade4c999abda84bc5c05f1269ceb46395e9235e345860410d12e967a8bce1f68280d9c3fb6ec7d522bc542273fe5fe528dcbeb266b1dee18bbec605b540c1a932550074cc05342da9c1633b40b8784e81662f23d427bdaea91404d04cab70cad36d60cb0fcdbd5ba2bda3a5a53997bb3320fa11378a8d3a1ed2a8b6fda036a462d58dfdf9fd62984cef0b46af8f94b8bdb6bb318a5f73a7c5dfc9b8a4c3cff7127511656e8aa1f0e6296d47a3be7a69daea8ce1bbae5210763b782a153b1199d9869320c2d4a190bbb4d43068a540b52eed86e73e44cc422a1e1b9c5ed4e5a3cc404efe8063b2257e703358c7a6e9f34c7fca98f3164cc70bbb3493ef9721face797a133cb00f0da5bdbf0baf09b4d6621e93f7d46608b26a13d93cf5d2ae931d98787d8b1087588ad77733a460a1104f9d2b7a4ada52d42a80da86d801b4386029a9eaff98014a4c9729633c754fe5e38e399444f3f8336baa0d7dca9210c98e29c38818661191bdc15f9578bd28de97318f4343ef9976610bbd47cf61e6c3cf3bc351bc5a75b3f0094a4596d3789d30064342eaa48f7278b940af92c57b8d719fccfcff98f9c87e9d2c4b123afc1ce77af6344079b5492a2e70a8eac8cc5356886820a1466bc8d0730f88f0ea248db127e351d6e9cd1a34af419ead409179531d577c70fce73c142e608d5309e0d41aabc85d8fcb4c4a81ccc329228af4f0b2bef0db395ff2ba10d3d64d2a485fad76dd620c79b097e4099e42d5ae19c4496219ea027b281ba689c396ba29f0d1dbe02254eb58ab430f86415ffab7d55f5369c6be3ae6141503c14008c40e77cac47c1d4b6a740d48908727ee07c19bf76bcd95875f0d491076d79d5a11f33aba249f2cbb7fe4b1fa24dc92980d53f1fdca38c4c9f71a36658e5dedbff81552559007199f1f8eedd0bfb374cba64648830930ef69977dc2f08df9151819e0a23f2842115391d40fc07ec4815c2246c7418c3f4793f2f6c0aa9e1f9c0ed052ec6974b7d4c0d750386593b2ea0b9c6e30487a649f72988a005bfad3455bbaaf31c61f86a70f72d8fef9b364db5f675d57fbfbb8710e7b1b14789f1462693b9c4c58b114c3c3c27abbc2588f16d29e89f3fd81abf563de9ce91e9b764f4381973c357bf16d667be9fe3b7eb0692173318bf78e39b03992070fd2102779156d08dc4f3dbaa65173fc7f1db8638aeaf828b4d7546e60a4202e6d8b39f6a964b14ef85bb49400b4127b17087a255cdeee7bbb49c9d397024c3f7e41d2fcb88b06a3a41e2afd7cceaffc8969d611bacc8b65eaeddd153ef62af07319092daabe2716633602d0bb5d4344332feddf4816c0586aa85bab617996cb4a216cd20507ea33b0ffbeb287963483d447d55eeef016bf1ce00dcb9bff51c5a0711058b105ea76471c24c7495f655a2b3fa7045455133a6f2c19818db1116ccc76e227e29a770664b02f457940c6f0b5f9472c5a394489a418c61039f10f09cd8dbbef114f4bf082cce36c7ca3b4278c68e33604e18bcf3aea9b9ec5aada53412ace1c998f5002a2784ccc0919a9ea3cc40026dbc9e42dfa4450ba7a0eacd76932a6f28859a0431b500c370e71a8b93d36aa55877df23b5ecc99f0745929ddf94ee38ba6ef7e364518ea1b21f3b6dfdcb9c1aec9340070c4484e5d20b21c6fade28765db442d71a167611afff3f782f52e273130351b1ee1a174413d193d73ec773d3f79e25e671ba9368c90c51f581db8f3056ff56052ecb1f0df0b8efd3451443436416fe02ed3af4698add68b8714a298c6aa0c878bc6d8908418b079ea49e7906e4aecf399dce9d3d9ae97ddcf71c1733331f108e1437913e7e8983646128a678a9ba47c5b0ed0d88849bad5cd02ed8cf7f3a50d4dd1b5ff25b3faa35a1aec0f8e2e818a5e80ecc0886817d7cd7b9bff6de61e1ed6b2aaa3f575cd9da50788a1d2d0e47865275a910d771ea60577e964ca4311960ecbd4a4a1eeb7f9abbcc049f23e71b95dab934b9f3ee9fc09ceef50a8f44c341eefee91bbc6bcbbac6704930d7da928cdcf1221348bc028b91b3da46670e3d46e1839ed6dda3a7f2e2046f5091fcdcb7b9f2abff8f936cec218015fa9a3c66a8cb006dc85d62e58f372a587c52dc174901e26319717595fb7cdb2dfb54987d3565d37e8ee39686e469beba04e3d2cf1bc56da2d950f3a3b6d1e48e28e7167a035494ae8678135c39a0d29be89b10791b2ee85e3ee70836fd8e42ce8e3283b23c73fc3efafbf680d06557fcbe2bd3baccefd382a3591728b6a6e74572655ac482663d9943f59c017227505da899285bdf1cc39430cae0cbedd5e0405c93256e98bc155a3e0c2463f209dff9206a752e7eaf16b50c14dafcdec78a7072723634a6abdb952fb1a7bdc8e0ece8b06c201b6f3d431fbfd549657742b2c6a67fae5fe8f246a98b0b231c7e7fe155d129e3c1f22a2b95f107e6e740da0682bd3e49573f5b05106c1a0f819ddde749b87cb1e8972d2388deb123fcd187f3f7ae842e1909075ad0106c000856146043eafc6036e83d2f9c018a3a196c2a01326705dc0d09646f352260fd4d54d799ccb2fc92a3dbbc1153464361168c8ae063aa4e293620fed6bab1033b7cd6856c8737f15e0fc0d94ee39d6070aff3232ce76f4a942785a3e52086a39e8e3dd0721c89809878f266ec01cda601f80f08b63f55a6eb74cce99d90ab769b695568977d1eee77e0b132fa2ec9157133dc0805c56d2645cb28d959f011e3770bfb73a56a0871df9b3520d4047b6a0d2197bf20cfaef5ff711577e876f968e666ac0beca8ddc782a9779a9ae216fb9ea374ba8997a5ae227df239179f213deb2d9023ebc4f2d5c672525b39e2ec3ff8919de51f50bbaa633eeabbb1728199c78fae88734581f1303b73bcf5390ad4a3048707ad7db9d019c4f90d3eb56f4614c33882e8d48ef9eb5c1be10579f899b72d8846a8c71bcce30a8eda2c80a78adbd2c65b8622614949aa79be5e7ad89e3f11b1ed0b094be72526299f0210aee6b23127dd8ff1ae1f8baa553b7bb820bbaa70536ccc9ea852b93917cb171b0bae394c0c35bcb18c904467e1c5cf5a0ef746f0aa1c0ab8b4d21f38bb71b779ac179abd041096d5914124fbccab3516112864c5e0e401a8cb33fa6ec95ef19f47ef10010fc98d2c01660221be3abc829d4504ebe55051e7c7c54e285e2025875d0cdf5d8932dbd155eddd15cb3adcbd3719ab7b8c35aaee60f4943490a55382f921e513563be22aefd489ddca6cdef4738ac5331587ed892e3fc7fb7340b9fd8e5297b2cc5c81d30bcdc9d058450cd62a204be38401beed56f0d5c91496b074ecec104d3ef1417ff0eb2231fe9a307284f2337e60716e6cabd371464556e965f6cacf29afaf4ce22ac84fc9f64d2b04b709cb07f96b5670ad728321940f6a645c31ec46a8a6eb85c3a9c7132cbe5336fb53707b2a1dc969122f452cd5a10c906ba2e671bcd1b02e37d353e422d912b5a9f963ecc31a94ad48d304c4fb4065f3cccf3642b0b804f171f60a08805d94fbff84f67cfaaa99e7e2a16d918d4b5bb36fa09848f44a6b27322dde97b0c79ac97e080ecd3bc3ff462304fa80bfffb527e630b03ea93071fa417ee048fb72058c094a1e4ce81b936424138dcb2ef641f197ee963eb5e8c23c71f6e00f42861a48fef49177d2fd8f20563b85d6cdc007d61bedda82c4afe5a56768943b9e80e22c97d2e2824dbd7d7939158379ce7a209342511870e1d2aa61e8846294dc00d23d5b1ac794a40f7e684aa08ba61507ecbfb76c0a39a16e4e2b6603bdcfcf8ef8fc907be5af4d9790284408c668fc0113e4448a2ec516f71c448c3841b57d8ac5de2fe1f90a0bfe0b342a154ba397e1d40c43d43e1bf501f93a2f533db85e68866a4a77a9e12d0a0a4ce1d30ae460832cb867f78615802fe16692e0340fa33f0534df8ec0c1bf94951fdfda1c2507516cd401bc5bb3bc0d8e31c3dffcaeb6db8669c622084269c7900603a4b1685ad7613cc231ccd45e9f747375e349a3890d13452e52db0ee74dde78b03fef9ec0f6f05d620fdbde578cc4c8d3b3fa8a4804748655fe12609c0974e4532cb0d09473bb03c2685da3531e15e8a2b67858bee70c02afd0aa90bc26436640877451332132368fa2f56e5c65d2529eaae476c4034c6da0a816efa61819cf40843978189d915c93892c3cbb059e0438306d9704ff37feaa4cff7d6c2810ae684d7c917de49ced1bf0cc6ca765958872e0c92a94b36534960647dd7175e032ed0f1a5addaa6883a9579340ce24b6b9196c7be4e4a97f3e2cd2932fafcc221b15754fca2f2e24237938cc8797fb8af5ec78f926a63709d17e21e4f1dd59055289688f9281c36202eef48df36391e5a0c700248c27857d93e055352a5cc2fda85981b8deca6a30000469032e0af64e76bca3ea0b3b7fe3158fafd557997e3e3937e2c43f354ca03b85e7fa2915de6e286941d94ff9a0eaf9f3ff71a1973ce350117709ab5b91a54590738eb19fcad6b59a8f21bda9897286131a185bb7e875d1d9c88c918196e67ec1f975444da4a951d34e339cd107182592c8f744d7ea6a87e088499423c2a44e45881a852568864f4f24ae0dd301117e359a4aab948149cd9f4c9bcc91db1c6161e53903be0ee9b12ebafd78bad98dfcf533d3e3f4b954a6459ca358f1f1be2894264e4fb00219f99feaa27ea6c920d74ee867a90df941356e63e09177b2bff6acaccbd34d5a13b58f7f36513abf669424db6ebfe7af482dee9a74cc7770145d81796b79d6ca7b998afc9b07376beee99e939c98e7c060aae95ea664d5603b7b69392c86825a0650ceb30a0d75c19c7d2f8362bf4b7e2c12b37c9478e0b3e766c53a198d917f8a382432c0f5679a532b30d76a56bbb886633a5272bbc24457cd6ba94b00a8e249c414169505f22d8ec62452f97a1eb63ea584cda7741af7d8199b9039a08d0e5b30364f4c6b690ea23bad388951d199c8c59368487f53f357c46bd908bbee02007d8112f740026a6604a52e77ced4245709b9da61084cc8a5a9abea79426c2e5320c52128603d3eb27d68ca2434419b069d96b85a109ffb733e3f1ca2991299ebc45c0883943abfc1530bc910441ef3719b9d14134a5fe7bd0112ce713ed1855325945cc29bb39be9ddd9a8a58c1988d711c13201cdc5f2c45a154fe214d4bd0ddc020f1b4b89c5fc07637c1db737ee5bca22503bb8eb850ca4fd35d095927aa278d83054320a00d0a2de50d3a6d5a96ef8656b9d09fb0874d07880ce1ff1aca0981e3a935e4f60bc0b6d47d22790c0d6752af053c20c3c1567d161119280e6bef91ea9fc2207c609bb77f5ebdba5c8de8e81eeb434421a4d2538c37f6728adb7163b7895d1934e12467635df2bb1adb11a607e0a07e094447e9f196c3bac60a596d82f28426af12ae45c11189313c853dfa89fcc6d8b0d416022bc5e031a1f3ceaad4662e37b31f83b0f8cc84fec867972c5b301c6aad0b9f1295ed1161b5caf5e1c77522021ada24c9efe6b84682a20587062d38ffac1825068a2eb900bfe9513c23ba42e16f16c09eeeea36170aa8f14c3b40b335b37c78ac92e457721a29b1d9f298af710bdbb0459460739ef7644ead5cd177162e7493a39d68cd397234e4e5b9c8a229c9cacaef9864dc6b7173c4a4bd8334350532238abbad0e7418b73e5c4d20b1e229c2db791f8a2d9547cf1446f73a4bc30a2f89c734e9faba4f7c83f85b0d0e2c89b1089af5530425dd7589ce0907e0fa0d93f07e60cf9467abacda5870f8f1710529fa2414fe03aa36dd9164742b4c42d67b7c180333431c4f3d451b86b7be5ec37226d46f425a1604b0fdeff28dd0f3731f267fac4ad661aaaead7d94f46f1ca04f207873ff17b84b7420afcd58cd7c91b27d2d1c381d01b8fa184dc09a9d12a562c019e4a902bdfc01f714f52416f364a1e7f386aab04d6ea088fbe11b22b8391f96e548131d666c7c5862b4c0ea909011e8b40d9d41a7165efdca02043fd7a8acad0bf72665a7c653a8c7a98dee04e9c69b72d1325dd6af5ea045df6ad6a33e162e49710dd744cd1e09b7ccfd4ac79803cdb733f458431c40cade1ad63cb05401a004a166ae221cd2d2a409cfb24f44b99d52b2dc21c601d7a5242aebe425d4fb16372e0ab01dfe8e8d53d575366e6062034ebb95566352dc1088c67bfc5dcfaa6ae8f4dcff83370926fe847eeb20ff2ac6dd758e76291b4b48c06a7aed614c53ebb8ef491171df4d5e7f11337ac0144424afa984c87f2be293cb63bca20ed95b4a5664933216dba16fdec038ee01a88b602f69ffc6ad12798c585b45eac1429f3244e677eb870289c9435879c56b5038be9cd5ea46eb33f6b9e92de81af8a9f0a48a02d24a84138ce3997118f725566dbdac21cd038c2cf468dc3f85b7f7e30fbe8f93e5a6eca12175a38cef5b2275c9f308f25434728af5ea9c373707c11df2c46809521410fc6971077b1c1d575f5c3e059f76c0d5a60a1eeddfb98e7e57acae3ac8eed3a1b4dd19a136403d05d556fdef62923a5ccefc9a5b498384c156b3086020bb4d2316dfa684be98e40377a593886573685ebd1e8d82ffc25d286619923b8a83d0af3d9faaf3b0574d4cbb64a79670db4bce146138eddac2ee6af1ec576a62547bf0c7331c1e135773de026f2b497703468dd9444f275eae7e650cd10d1562f303a0ae8ec7cd46a15f774455ee162671601b07956113092dd4807b3e610f7c6dae544fb1cf254fbaeb59c4e2242620055a78103c6f52e995d79e1afc426ef341e88332ffe8a824006275e09f7a13ca6cf304663f4c3bbf490cc0ff35e92b902a31751e50946d76bd092d258fea6243132cfd30eb44b46ac31f96396a9ecf56b8e57d52e2ca466934208c544a2104efa7126be206c2018065f4916a2fd25a34c85293ac8145456edc9a3afee8a8115a29390acee064f11c58344a19771844d684374785bb78fb17be8dbe0cb3219b212fce0bb012934edfb80ac9a09971b63018b77974291918b875589ab86b7c017bf425f96585247ab57625844a3ba305883fa6b13f9fbb5622fad963b98ac458eb9258a0339bb8312be3a256dcb4c802ce9ec3e2551eb1cc15e41a1b572e5964208d4a2d82a617863d6804de64ab0b63d2a817388a4d057ae575f3d3b2c873e4a036b42cca01e78dca7c16f8368e4d181efbb1cecbbdda7d72903e38950ba1bb84438cecfda69b55cdd3e46e0a6afecbcbadb3c02504fae42a57b7859933c324b052f8b892821e43d57b9d2497d1ad81ecfb33d4156f387a5710173bd5ec3bdab47ea2fffcf81cb50740c69f4c04e66723bb43ab0562adfc9f29714b9e77a815e69502e901cb246fb99971339b2d3a1162eea05521ad53a25c98caf555a6309abdf46ab6a42b1c9aa1398bf1ef1bcd825c9344e54e86d1239a056dc22f36d52014b10c21cd91f396e258babb2f5f1df2c89bf6948499c06ba14754568b95980df1fd4ed4be18e16cf3a2e5118b4b4ac1d0f5fd64b7d91acd15a79bc54f71c44b57f731ed8d3e5ad2d1df05d144380653a82e70a18c83e5221c8921ec4973848760cf6488e5ebebd7608121ac5f061406080887ef0a2c96b80cdb8b90ab472cd1de2f7270156373d37042fa873d02cb4b8ae8f539a21db970125476bcdcc2e7ab17a0f660f1f299f04512a24c0030ba3c42a8b71d7aa6a6045962247780112fa93da08ce7ac8b52c5b7cf177ce948b441c1e77d5f008d4e6bcb349c2f91c6237104d1952b1d7593aa4df3eeaa6fadddba83bf7e08585a70cd6837304cf650b5de675c73107eb245ebb1b7a0f34f2a335f936d8c42467f4282f0dddf3cc4dba433be796c03213982c2fc34ad126c778d6f36c95ea161de61071a77f181b88d3e56f5f5a15a570d6e6262ddfbc16cc935450763a29d94d913774cc57c3b88f5846d96bfbf5d7cc84ff9b9d8ad09a668bff03031d6bcd05f02430b4dfd310a37e5acc14e12c116ae7cfc00a58dbf16988d324ac7961cfc1be60dd75fc26fea0c5648e42f371271741e30851e865115812625c4988c89380d80d42d07083adeee6c027b18d102445261047e14a20df397ee85a1cff25f735963bfdd53bb82e4b94931c9ace1f024f3ba37252084af602097aaf43d157ba4c1c741db3344de37c0b02a65ac4a0ff1b7b00301b7906a8453af3fbba11de995bbb006cd74e632e425ca69762bf547a65ec61119e17781125c4b56eec736706cfcba4e99fa2e9204f26c92be6f109b5f04e8949cf09025c5fcf66ad08630538e311aa0b219b862291914b2dd47e774b6c165a45d009f33eb5f800b0ec952946652fc1121e9a230bec37ab885cfa9df01ab107d35c2283d8e632e6936ce327c52cfc01a353fa77e68a326b48cdff67c2fb7208ef2692d64952a1974ed5144b004c830c5ce7fdcc40ad659ea91576823b91bc0e28b3cac05173e46666e5e0aa3e62e9c0a20e39168ae713d5988174219f9aae1ff3b7422b305caa8a3cb28cd95f53f3197bf8d1f00a31f8435d730029f6749c8bf2025da2d79061d8f9e3773dd2cbe9b910e50ccaceab3c3eb084679c5a27da8131a4ba7cf9cf4aea0943caf310bbe7dd09f908d787fb03791df0dbea0b521e22ada4259c98b5e3fc60ee051718826dfd2e37efe40abd7b9363133ec789263ae67f1b2c15814e0f26766dbecfb3415930f565ed151130be46431ff54bb6d6cfed6385dbf23f053cf58b0b00404647eb30df6526c3becdea68f25507c6c35f23aaa71438802cbc367ee700170a4b523d57609b9385b76fa17c9b332a719d129d3f0757f20ec656008f0ad8fa0b8eef6efd340ab1cfbe6ea537c7abcb00293809b073bb13bc00c40db7e1c6de6ed4fdbfdfe9ff487b2d57b4c2b9f8bac1a7487419f6fd3638fd9712aa555cf14d5dbd4a76df0140e5cb9f2b6ad26be25697fdfd6dcbbf3a2dd80876663599a0759ee80b3f50a2ee84ed7d3ff1cc14b819f0c801baa46e6575de832985e6dddc17d2f1df7679b9b0c8733c2e9157796f6217e3bee09564227c60f010bcf25aa378bea8a5f223052e3b98b0e6049bad2c6fa5c8c3111fb3d6b1350a02f96d276a5fb8bc133787104f69fc3479c1346f3239090d15bc1dce94292b0c9aa64a995b8b62abe55d54cb2f00f49159ec20d1d7e4427be939fe17d7ee72211d22f77701488e40a35c1b5e7a13024666bd9b7fe8cb8ca579ac43486a1e000b0702772f51d9cec4f6bb2349810961c187b3db6842e5501ef108cc59ee5290b803d009255eac5d2acaf3ee5014a7d6519c18bb44d4274f0f57bbb75f9772a185417b5816acb0ab42a8fc6591e880e05d7646c35b9cdeb24a791a85e12a528c2dfaec70f116f80a86c94100db0ca6dfe0de4b2767605ad4b52e73ad4d2bfcd4fc48ea416005c2eaceea88e371181953537f451c284c0d0362edcaba650db1a8223ae96e3c7ebb10266f30bd6ea997d208f31f10829eab9f0af6355ae18ecc99d19cf8f83b027f8efa6052064d9e26598786bdfe8c27ffcc50884ff240ce9489ad342af966c36dc74704c5ccabc723613556581106dcf751cafee8e1a30ebd6dca6c88abee5c9dc061143f1b8dd9dd28740d0927b01760beaa46b5e05c2f7e4b751dc6864b3a5b8ae13e4824873a06b0c24c1d7459358649b2fdfabfb41da6942ca9419206068768a6b14ebbbd671702ecff7466fd887305c6009a73e645622c5ce62e52c48a94be1652bb1c6a70494704a15c3252aa9e99774f3ee2697f8de626d20e54c24f63763504408446f35e4e213c773018e1978e691bd42f906b1fc3e86858e155fd68130c44c0740b5f113edb741262652f31c0034e2333a359c292696354b44bdac9b4f65a0efc853907fcdb33e2b277aa9acc725f724db227c50a1ebc1174ebf3d120eb0de11fa99cd1fdcffcb668a13bd0c24c2bcaeba28518624a24d02a984d22eed44a7876aa9a1aa2838b3730b1d84600b262b6843dc474d6bd8f0b1e6f1a374403250ea87d1b918bfd08573a80654b652909bad3ab216e23320209ef1cbdd2955ce83d175cc18560017f809cfe3cf53a4827c6a34a380cc8170aae58d241eb705c70e1b48ac768369a5b25784fbe53fa64c3309604e3adc574bbee599a86c65df0cb4d26f73ef7f908713836e4fccb9105f1655a0019bda3522075a2e0cabcc47a540ab2c19b34b687a606e77774da3ee054907af3fca2e384f77cc688b79cebeba73c1802bbe607bbd2188cfb3569dc6c2e16bde94bb0010345a0dc5691e06a596efe9385d6c3649cb97a038642e09f068a655c23accb0bf13d79f27ec17bd18800ce356bad599885d4b29ebb611408d859c83b6302640cf47dd8f920925c2617669f9672fc2f9fe2ae0c63e43e111ae728f456f66789bc90eb3fe6fd2527de7654c828faea9e899d2b5c56380ddd00d94b9dbe01b5ee28f3bdb24de444d2a0e68e0aab4c9b336d38be18a3e8e35e311b6428aaf0d75e2735afde88cee07d3489d890722650f9e5660efecce7cf0b7f87634e2e9aa65a59a217c1ab75d3bae3281524bf23651954c059c1f31ab78a1aac4f891a6de8570aca52ab51cfcf057bd147853f0dafaafc52332f8052172c7fcfe692f31fb4348a23f78c0a5d2ec9353c22d52f9cd22ab72f11a59808b54df33287c71132cb68ef4497f5c0cc08680b4eaf681ba4eb7dfe391aa7457ee22c2d106f74ac46346585172b8f41fc0ef6e1f7a4262cb4708b6fbed72f6fc17a979460850101c2ad1ed64666768be74547bf058eff3c563e4b97296a84f60fa2aa4a573212c9ef4ec37cbaddb30b5fdfe945489e0c96f5845bcd826b1990970d64457e2c206798d2651580a239e947b46c100697b3a3e8ec81327a99336163625093ceab8367860d055847667dc36fd74f17aa25ccdb8e502dd5dd8bda14c1dd64e9bd5248a713acaaaf2438c48a94278c18b70bec2647a1a6fdc587cc80cd4c3d007e9bc3bad597dca5b7f27b6d0616b2a23bbee163a2ffeb03d362d35cd06fcd751dd9446a0f40c48d314c6ebe60066cde2284cc277c53358fb83f0bfb4905d66f77f6c763a41b7b3c3150336f6d756755b7e28ba018c6a3cb7cd17eb2714d792fb95fcdb37f36a6aa950cb0928d3a100827b7722a295eaecfde6caf79dbba4903da1405823f6ca667b81255badb1d0ab49d0246d8100c0b1cfb52a5d230f29f1a8e2167b63b8680f3153a22fecc5c037aea42977790bfc9adcce4b54696ed6bd82d1020b8ddcaf1c5a3e2e6b764eeb9cef3368de753ea64d72133c0296b8c3e3da234787423e030494c3584520daf2221c455feb74accffade238127796ffdbdeb6bdd3dbd6bcdef04a1762538dc0d950346b43992657557679b9ea8c06b511bd21b9e1d985d30bfbe060c1d442e147d2c89cc9f6fab2eb12132f5c6d367d0c7e6f024f7af705891d44336ad9b831388ca906a988e6747c976ba8305c4acffaf98f093aac378991af8a28b9279dced8d5cf182614ae70ab285e148153388bfe5337f191e86c2bf8f75c682f474ed2ae8f3ceb6deefed0f85db0c13389513a5caadbccb86b3a830d3b7a6f28b631845a9ba9ecb3db3571883a79e6111b6671d3b2708bf28e6984b4d50aaf9260bc9c69cb570d1bf7ca790ed21b46403afcacfceb535fc86a8a8482cdcba769fddddd7c3aeefb6fc842e657ce6e51380859776b96e3a4ee39d42fc5a44228fd647d558016c7bd9ced144661381df4d19040bc4a52ab092791955d9949e53c9a01d590cc7a73c11e4201a3f8ecef908dfbb91f15bac7eae0b259e9b0b117ab56d30cf700c9dd1754561f78b72d2b2c9128287331616dd590745f8e6964d843bf92577ab3d3f67f5c1bb01f3117766f5238fd0ce41ca01255e665d01a1c57edd4a73d3579a1784aa727a2298b1632340cfe3c34beddc440f126fbb2910b02b37fc435555b5cfd1873258c0d09665c0333ad8fd2761cc1b5ddec3ab744d7edab677a337c5c4d7beb9768a5089d3165800fdc6f63df48c94cf3efc4168d1f2e0dc04aa6774c47bc7d29615ef2d931860343dd0ced5746f82cf2ad5586c8135843788418d77ddabf9fc8b43b72d19695ec68f8f9ad6285d0197aa70f9b1ea74b6af8a2f93388a59fd9cef9d1b2c85694713fbfb06a685cf2ca5721a6e5ea8377ed249939d0c657ba8428cbdd81a0f579cda3462ca69690c614afa6278f7aed815fe212add4f33c99acc43bb80d8e6d1e9403760f886ee4a0c53aa31c32d018a79fb2464da2d43a1a192f154a3bab7031ab60b939e922db65946023d1957139543ac06800ecdcabb1bdd615e7f24fe210874da2a2ef96ded3e19cb26149cd985d2f3bf02bea50d5684cd091a35f9d2c2f9cea657d952bfdea3e2c0d29de0bc0c92191c34d604eaed67985c0f926710382a71b6a54459493a36c14052f297f6fcb17e0937ce2d6a03dd679617fb13a3ab2e5ee204dbd353abf4dd6fee4656f44f1c6eb10b1fd9fa29fa224ce02acad3c617f0326327c386bedab42613ddac8cd336629aadcba37f1d7b9243eb1096b6d9ae1efd23fa74eeea0283215c4b183e02d512b770b836572c8ecac938abbf7b786be5748bca957f1754ed83be15584cfbb4e20e421b67bef990ae202da95872cf844798d3d994e12168ae8986fec9549fbef1c511b28e636457139d35b1ee1b2ee3cd1c79e5b9a7e1f3f7d9839dcdc70f011f8bac54309c96148b4a8d9ce0faa7e1f68ed3f868df5b03dc7b7925ee15ee7314796096a6c73335ae6109ea36dfb0d9f4e6a649e78570a336b4668f4e6da95541db97efb47e07f11f0f6a6bf84e410b43fd0b30d4c9cf85832c6b0f856f50f8400ef841adb96f2ad97205d2ca9bd2fe55b7747bf5703ece2cdf3b056f4e776b1ed931cecf2a6881289c004a62d21463f0e5e8e9f1d156f3195e442ffadbba791e2ba177e2ebe83a42e4a0acfe21d75b9baddaddada25d8d4ca5ad7ab0984e1668a758492474847c24d2a7cfa47ecd58131dcfaf9f9a53d8fb3435b270d1d6c712969ee1ca64433d30a0336dda6c3aee07aecee5f85c6d2fa04e4c7ea0e403b4e863e6912d43a9699185c3fbd91de11a11b19e3e53f010ab49183cdbebc89eaeb29e1cb3ecf9afea588cacb94ffc410c2e3fa020b210f5ffbbf1b1329d576541fe78bd7db0f6751cbf5582a5700051010bc4d3253c90716520880231b7a7a1d3ec1d5a53e83eda11c1c262e69319f483fb1317f80ed64e0c5c90ef1dac95041f501e247c65a6722544d434049cf76653a5dada5d5f6dbaa930faefa23c93fc6a925075c0203d328b01fbf5ddd565e7983ef6eebfe511e87f19a38071e65757941f86a1069b70d93a7f0eb1d878fa1c5e0a871e0e7d7f24ba432f0c283ad230ba428f04461c47425bc49d15145fc46766dc463371d4d370f3f95faa186d0174c2d2dcc76dcc62cf0dc2c9611d32e8456b90daac937f871175e98dedd4a6ed4641ab1d3db1c0dc8f5dee91169c4b313125df514bc606a70f3b287a21f094197546fc7a01c883e6828fed2a4f9217fe04c6a183000e51ee92568378312fa11cf29d1482e8244772f1a2e3fb2d589ce3173de080a57b5747c660979a4e32c753614fc112bca1c061d579d8848e261fcfe43e1867014d5811e4985e30d5a3c6c7ef61a22671bea2a13b77a477dced60091b3308111b70f48d513ca77624e0b27913a6ce633529ef3799fc99ee59f43eb749995f4c9f18ae13fd9ccd6bef82b80ed68aab97be4732106693648fee3a32fe43ae61470f96d4dc3e616b0a1dd5ca1fa7ce07e24a0f11965bcc8a71b7d89de1483564f75a4d9a01d728ce33e1bf97dda72212d65ff9eb274adbf1ab894ab36c592928462711152098be7aec228fd1b7d330282d57fd7b6d2e60bf03b3a93fa472d74da741b0930f7998491467cca1f33d1f721aa6e85523547cd5cd91807d1ce5daf29aba408847a5a46043c5f8bc10a58ae0d89fd35b899dc2cca708c062e9844dc726fc8b7135c24307b6ff8cf2942bfe2cf849dc20d288cdd69a1bdf106cc267635e4a8dc2adfce7728f015e270529fe074057d1b2d47e2ffe678f77bcd95813a1526c7fceccaeaed24f4d71bb8812e66902f40e91b5223aa86e088115f522f98f3153481dd64ecdfd0cdc9b518782dd18c9826053690532ffe45159cbbdf6d22254fb4e6c02aac38ba9f02e40182b414e0ec4f696e23857b129d86bf31be944637c6181455ce7592e38f2fb197c1e680250e84d01503667fe55c36390c70553be3d59e3297fa684ae2772c1db41f397523389885041aaf7b83f3e7d35d633705ac55d0ebee4c44b35ed9bead7f262ee0fb07d27e43a59e6329ec029c4c51f32d97f2de58c96ec2a3b6238d718b8709099406386446778699065f062ee1c98bf288260a1baed24a6f27f0574d0b367d5a24253015120f4817f794c3605fbf78ef04fd8900efab2675ce21f62c9953ffc431b3f871a820ce0110cbf6ec1fec0c45593961ea5cacd93202f46f947531f0992565ecdda3fbddbc6f9b5e6ea6c3c313b838046ecdb7ea1add9c8da2f31161005efd8d0cdc92d66d0af15349871625722ee42b49bdd12840e650ce8c85c4698d76e3076cb9b26992a871500a0f4417d74993693ce2071065050924cb3080bdfb0ddd05aed62342d0555355e86f226da8d82eb69266a08d5fd13f633354bd16cae0947f871bf63894e17ed19f0af91ef7e0c8b6c24ca88fa82fe7494bafed933484f562e834c37c3fec99d1da0b69ebb1656071c7ed27c2a6953cb4cca354671341ede1a1781fff0018f23bb2e07af3c1526af61f0c4695c86128dd1aa30b8b46910e161949f8a0705472a6d67b70de5bbb9af59566e5a769fe4dec7d971734001831d96fb9c1a609924588f6ec3b62924db9cae45db57dc51612ca2b8641b86e2e58924408df07673de6f94135d79ce70478471f28c04158492eb1aa0147185261f94bfbe5a1a10f5e73017d97e310d1f9ccf654f9a6a309a2deade5a9c1d2ebaf961a8fd9bfc4a09380f971a6ef1eddf3e3269970a133bfe51d4a7c9a3025728572f5a79251485b6648df831f59954cf3af2eaf824a012c6e914df6b4d3b179a9d4ebaf3efaf4a120f5d4ea7d6a2adcbecc9dbfb335ded867983caa0efdf68cee3276ab88be4db80d21138145e97a825b1a8ea9b86303d7570acacf4f205c4aeb079414ef09ea20862542eece64f0c643f235cc4c105efdc88ce35a367e6572b253c6b876fbd7f2f50a094abfd9eb5d199b80e1a612d899e2c2db501af9dd3451b332d7d2f968ec387278e97a2cab9412b4c6ef04330956955c5105704fa6729b539f9071acec287aa48db6c3f201740fb08e6c4a5bcf5c34e0a77f830dedf1e021610ae1654140d3d3616fc6757e8f75411392f9178eb7b32cc356295192e71aba326d0adfbacea9ef1d33790fce29714532c787c1e08caa47a46c94b25dadef183eaa80cc374c4f63deaf2c86633929b12226e64dd6c2b3ce1825551e28ca8ac78c92a8083f94d0687855ed10c63575ba85a76b16f9a7da741e621a0b0881c89f3aca31001f83f1630f5034e52b851605c1c6ead5b9cffce1f70733d6cad2cce34a69c3d3efa639dd00461befa5bd03cd6b85f12bcd0fa113abbfad5bcd033fd0721e30909c3fc08bcdb4caa90801bd66dce52dfe30df0146978f5b4e8a42f446c1461d7c7961de1905676fa7c93d267d007b85d8abca00a6b731579954fa6de6b19409f825fb8467a20f533aa64874e8a51496e9bd3c631733c97f79c67f0be3d3e4191ab95c2e5ad804ff0359b3a9fe427544d39df0e0313e20c861ba4aed9840bf7e99c3c08a87d57de8bdfc9a15d891ea8d1ef3f829ee6980dcbac5db18fe43aa3a6997280202ee9be715c522fd236fbf84c96bfe16b9ec582dfc05a26504cc723fcd1c3c445063394eddd1285322f0892dbd5b8a2f3789800bd453a387e63d89aad8b538a1f270093e561f83e90a9a51121359ab74578442f7e2af4511365392016eae19fcee76f347e88b2a4193c4194651447b0c30ec42166b58eef6931a279e92af639a00e29f0af2f6907f6d14c285127b7c9ef0fb8352a037b8e32ed9a07c0767d9434c86c428897af9a6b731f5267622d549140996b70a1eec1a1bb40503e147d711e0bbc776e5048b24560158095b766439ac53e67cb4737ce8d3ec8d84767b0e2659107be48377466fb5ca53c2512540a8a97928a5e3b2f51583ea59cf1494d339e787d7797b5c7b077cdda0a7b728f35ee38f3c2642613385fc26698194fc22fa5fc480ed9eb00f90a5537740291a98b6d841dfcc9c242b863f12c08d6c94303086b4952e0693ca02bdca43d93481a3ab5f15ddeecdc948439a85f4fa02d18edb5a7fedddd9e0e9a41060211ff03690864aca90d541d1e8b24b70ebf17b006e7252c6ed9604fc0cd8b8865fac4ed644cd2f35533eea2bdaae694cd099d0075638d5c6b22314041f69caeb55c7548a96b0c265d80d2dc3ccfd581bdaf889a5b334f170a8f8f86feef8895f225f58470870bfb7617356197fe473163c3c228776f5453de7226e9ea5d761df13c432229c227a346519774ac13182407157e5b6ac63affc2e59a3422fa6db8b3efb41972ae0aae2dd1316c74fd168bc0b7ee74e8bcb193574f10300b54e99ed249523c0ad2c4b6478fa6e40ce498a9271b6f922ce070cd162ebe99ca5bb55d83485091a436b378a81b3f4b0e34a60d2d323bf34eb611041419d460590ba2f3134a1b3b46fb74771e4f0964b00785430669b7a1a8b71f6818196e350fecf6762a9c7268f8fde07272fbcd039128066a1737ff3e5be04b784d8a87f37a8dba04b8d55d8a34823a31dd764c56ff72f30b5af461c0fdf30006cc3e20c4e213edb2d4a375d113ed7f0f1be11e3e9a710030c27372943baf62d83aa85894dae48febd03989960881d6b58cd8aaefa0707ca4d0e6202eaafeddb096c71892ee555f26627c08a2fd57fb37969332046ca08d0e90fcb3b65f443dc299eb800691c42c655a011f0aef13c63b3c95e42565957355ae19422391130ba2a5c51d3821f8b2c5fef7c1a45599e8306609654a202d7a4e6e428f3141c2b94b4b1a1a52aafa7215188c43455f3dda25e9f70d418882f97a2f6679a281d16a5730ea74b8da0e4592d6545efd0c87ee12366b962547c62d7d3ea6d7d8365426c388772f51828bff7a20a1f840acf3b50e3ff736d242bb82ed7098f57fca6dc26d660af524300b1b0f60f2f28556a6bccd98f6bf13fddad88febdf5e5772accab1b27a8ee57187d8ca8b5c17ece331e9204d59e81015024c2c29f6fb614cfcf7ddbd883a081e39a8c55d422c82bfcf9e2242fd5fa0e759b638089b9c68b7927a2489047e2297514db44e7d01aa559798d5ad1ea30ab98525a74c6bb11ae0739223edb0e60cdcfe492da70b604e9bbed3ad601f83f403b31254387f8830c72f17299168a04f0e379b1b88ea9e4c92dd67252cb270e8c0910d2e2acb4c4cb676e4c7f9f957bb1b411cf0752d49e09e0c6f73553aac444a254ea19e8cf540a49a4307e4a6ed2fcd209c6b38822e736c906dc24339cbc65e4d1c51edc964059454919c324155e647bfb9c842baa867520312f79e37a860873f239743af1c6a43acb06199d04f77ca2ea824b4ea15284ed61ba1932b7bd47b5281e8b896874319fb0e52751594289782277b8214fce6e063833ba174ba97164620cdf3a8c3bfafed85100f81a506c02e31b076e6ccd91d7b68654b0d5c42523c5d7e08497622247fe8d17e63683cea3a02aed3de8fb3e1b8814e18ac90edd84ae3b6350143544dbc364848bc53bc7019cc4f8d8669dbec44dffa8bf97a4c28c79a31b8125ef9b62905fc069c41a0757e271493f46a327e5b55b8808a0f53d4e35129b25b081a8343dd9cb144ce15f0aec862f147fc6cb9155a5951d9153bbac464c9b30f55fb3dea61acb1c960ffbd40c60f9c564f51853cb4939d16b8e924a67d881cb2dd305104a57ef4c74ded25d1e1e2a1fdda7d7fccf2d1a5d11c43b0339d066f086c77308b50135707f4a9a13d98d2bf8cc186790719558d81a0923af4d42317c0f5b0a8f3fcd872e96cf69e653f1724d704bbad522cbb0cfa549fe5d3a0b1884e4beca0f0b20c0fbf55c6dddc0ba6708e196b11749d01cf22ea4da9929da07d6918bc3ca6dd8deda37f9567171a04ea91aa98cb4e344d342e679f4d90b006865a8cc21d7b4ee46738dbba8aa0103f2b44bb09e6d605123845aab02b6066e8327b84b62df47747142a8dd00f14c8dc2327b6081b9f20ff3d7a565218fbc59af3e0dd7e7cdab2472d9f225bedb3e804a6e8d01889c4db1bff8006fd20496117a125917a9e7c7211e52d62b36ec79a77021302d0f200d22ee1ff285ab251288c6ae243086328a2923b13199fb01cc443a4c100c6bf897cc4a1e51ae4fbb82c4364871ff25cc355546b6f040f6fbf5b357255f62d2e1cdfa1451edc68c75017195dae274e1050fe49b142708730cf0876ba840b84631ea7b364c6fb426a0308e84b20ac2761b52dbf52078215a76df53793122a07bad9f1e39179bd754616487fe00775ca92569756fbf6f8423df17b990a9dc1632666ff0cd5cf4becd27e75006b012266c02b7bb4e5cdbe39b3d563c7903720730e5e9a81e376a64b36226a8f550c3f9255f13f40bfdee624cfa0a511ec80ebe98404ebcc39817cba6055c6aa951e934fc42d1a3b6d9a402b742ca245b7706f71acbe31b8f10b9c073a752646fde6cf712d6d4a351a9d09a0c4e87a8799dd42499ba19be99acf493989eb491bbb16f90777667d1f079f90c42dde2b5e78429b9fcc3d9850e0dff09c43b5990a85e1f95c105ce32cc8c78128f085fd2c01e2b6fd8a0131d9908b94624760951731cf72993cced834d44f1a844f0250dd9d6d7da2b62a1d1171d8e5b53135db969dd34486c3acef6d22b20a9e3ed87612b42bdc3da010dd8ff4d67fc174a0fe1da79339f8f541719f4fe20fd330b6b93552a26ca63fd79ec035c09300271771c1a02540dde23fbb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
