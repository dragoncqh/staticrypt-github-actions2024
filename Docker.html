<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e8c65e66596a7d56c658132d2b0d086f31da9b2ad8457fa71b6d36a0d9a1e14081990a57bca1bc6faf4c9d0d724e05f465a5c3439dd3d48318731a01d4c58ae4c93bc9888ce47fe19abfdc34004a027ee6fb31ae45c9c3bf8afb87bb5092fc0daf71d4241a50bb74a4c5d08cb0ba6d86db636d510273babe4009b063c03be439f4736394bd85ea593846a641438f2c22dc67700650b1a75eb74e2eb9fcfa0f02dd2d6332564a2af7b2f03e27214fb99f2b1b0638b336762993d1c55766e1b49c0421225ecb40a5d0f3635982f657033aea3008a6e680882fdc30aead8c53a2e728b61eb8960d3db4c861df7a92f60221a635fba1cd3ea63b071e9b1384d541951adb24430e575f26b9a043e89a136199285b321df7c3352d4d3bedc35d5e3c4316c9e39cfc153a31eefab1527a9ba1a81634898b46340182d4ae3997ec59fb6e3ce1dfca1a1c2a82b962ca4d20d541116aecf4518eea655702852dcf59f0ddb7a9fd337f30f2b9ebc26fc2ea72a676119addb47c69ecce001f555ec1c7742e4a090066deb35d7564dac3f0bf216982f6b3389ddee5d858a762480efcba1583dba9959747bac32ae802f2ff063a0a22c31ace5dfc7ee2b44093ca444ba781e4f4e9290efe12f76289d4dcda7e16cc81535018d818d31f0c019d040e5dc3a64443706721b8593d42cf4ccaf223ea138d03f5a523483f4b459904af456ffc1d25859ae9d6ead3c0ac24a5954d490895b8be7c4ef7ef0eb2fba5a916c71fd601371ede2c30b1e0725d4af421d38a3d7a9b428d51249964aee226566d7ca6301b9820bcb06896a74432c45c6cb4355bef764c2d8934539ccc288f92b52936fbba4ab1191b6208b7031881f6807bf4d1f71f2b2af51940836615cb9fbdf7a3257bb1f2f2b1ed311c82ab428d8ecfab4f69774805315d8e20a335cf14085d2e7eb317f9ae70e512baff2f0cf41885827b2dac0e4bdac21d4ad802c8714ae92d467dd4a1aa9bfdc2b47711d2779d6e97f24f7b5396de68623a5a25bb9083bb50de0aeeb0b31e136ad8aff4c58e5ff505d2bf5d0ed116d43be831114c320212eb882cc166d0621543cf77e57f8091a4030aba435ef8abda4063080f0ec89f627e75d03b7eca6937580ccfe6e13a0570d535d2aba8ea6ee3a3c29702b3135c03ead12e0effa0f92b091466efc0e169f54b36a135c35754de6a182c0e32aad95867da2a60edad9555ce78c50d0d8c90943f07e1ee7beba1c88a082669333114b203a95ce1ed498bb34f2b1c81e960f28c4c580aa369e155890a694f2b412cd221a28a5633c4baa696310e5dae1c8a4c349930b406214b010082ad2991ec2c83f9daa5feaabf8a0d0e8c42714368b65989234b7a17ea84bc9a75ae5bb5954f632ab0453d440e0ada7d3646b5400ab7674d4c00a06440846d17b19e8b80dca36b9392b5f5b2e25c3305be02ae79dcdf01a48b137bf75c9a6b1fd706f3fbf4a39aeffedaad95579a07870bb58fb2d0af6a1c580f74e571354fcfefdc474464c6b910e7ff9e89221ee26104862656a02c5f934e1bc0175c5dfbf7b2cc8d4155465319ab7e43f657bc86fd95a5f26e3c9297dc5bc4d405459b4b757c81b273dbad42a021f689131888213d20ea6cbeb9295f9fce2fc276d589d29b9d099ef23f6a1ed8261c8c8e55367f63df09584be5b2e9472ba4b91388c13e32d5bf31329b5fb94d66f617a8c1c1484acf300aea7684051d2e8f47ff16de97960d501143b17cfbfdf0d1b70369af2c147f81633d6da44f2e66dd3b6565bf132073f2a861a9c16212c146c49ef0d2f16e8467e91978746e5e7de8cf807ba0f3e023e3de78f153d8faca138f0086419b7884718c3c552a36e1f5415e5c3c203ca1fbb2f7a1fa23f2f5a5cbf2088cddddfb6839f3c79b4abee741ddfa8e97f4bd2b02939ce9bba245a58237ad0e91ec90e072e90687e93eb5cd6de2732d5609317e9cf57a4735b2a12bc670f09deae7de683632c41f9811fb98c49803235dc153f3192840a228d9c932b4ff2b8cb62b60bdbc8bf6a5865059212a43a3f630e7b33bad87f54d1b1d226e9a8dd8d706f352c983631a71bb720484c76701c253b560811727b095848eda088eb39e5b582af38fb137c38f55451aa5a8ed077f4f3d4263a9c1e62abe0b84eed00f6682418d7e433482c8c2bed1118fbb05dd52ef309e11005b14147476889e8ee0243b567fcbebeee7f8d924a68cae0eeafb1fe9d7c8b95e2d29ca295aba1ca3049b068d9adac086af17906e135d9bf5fb85fe003420ec585735c6f50f40eaf3333fabde0fc66670220a2450e87a2d6a9cebda68b7e6e20040fd77092923204b3a1ae994dbdada69d1168a8272c2d8ff2708130d83dbf51b0d66b45ce7032c3010d9f8d62c1b4bb49b4683eef49d684eba85da46a9ae00a9ea1994eee65f6cf755d766a84bfab62f9034d134288fe1bca46b82cae5e0e9ccfffb5b4e1be979a208c638f949d55a3381b4b8fd1eaa33359b49d33bf852f7ad6d5a4362fe41f81289948fc58111fd96909c76aeced942c19a09001a70fa31ae233c7193efcb6859ed02a8e59041c11988b2df210c7fa0386743fb945b2b76b865000851aef297c3082322b4ae8c076babdbbabfec1d13d628f2b632b5ca784191acf748af1c23e9a92c8a05539e8cd6fe21c82a7102354bb341f5cea018fa6091559fe617735e80d54fb375f6fbd277b12bcc06b917a87579e80ffc27b94cf47794f10e60c3a74a8a2b0bc1f9cfbf0df6a6b0ad93c5aab28045ba1f4d23f7949eebfebb3e06de07c929534b20eeadabace5c5c16aaee060cabc7fbbbb1f661d19b0224cf1041bcf1ffbc7e89e291f4daf94964e8e77f3d4fdc5b57891abe93b383d2996698ace0bf006d93042d88f843aa676f7ce33c72d58205a0d81d4a13b776c26b1ba616bf3ccc7e145900b8910cd037e8db548acb1b2032669e7a032fb4d35f7121192ceb8072ef9ebb0c9442a4934c9fe0cb70bfb45e321e06623fef32638340c23d3d22ae99d65237a2a2c69ab82cc0be4c512828f2e43414182fa802e361a75795bac4bfd28821103c281f95964e79d4bd03d8dde1f35f07165b042fc038949a48cc4d4a10ce4d5ccd59c6081ec33c8592549fffed4c0bd704c82c55bece88bfe98c2f5de8f565f724cf2ea52733c92edfeb88b2bc9d9484a8029d18c49ff01fa616a715e7d98bb701f7d0fad80e96257b8ca354c2f61440ad7869fcab74c3e6970d6bd28ff49e544eb4edab379e49e24b6f8cfa4457add25441efc27a0adc6525f873ef23d00f5688adee7dbd9799b24c5af94bfc40f053674987b7f388e4419d17fc2ec8422cc7e9d6362b44d8d4ed230e9a01a8eddbd8386da4a89533da2a932a20661e60312e3a64bb7d1020ba8d2e4ea5eb91b2380c18c92286a9a2725cbb3c4c8f4654ec06acfc5e295949c502d9e8bf2c0642503569db650474b0fbb90b771c36701f39c8df4efce8479b4eb54542957e18147a550d755d0cd821ae33bcadd9543bbfdd26b4a6ecfb2e59aa9127069c9cedfbc3187b98533caf942298c3a250852e99948210a66bb915a0a30e16a9cc48978f68210dc352dbd678216167f3ebc710049a6c76948447852ca8516e85969bd3cf32041e9c70a23d5f9d73fef1b4acc11904de3d9fd68641ef05ed3b32c78173e34e3ced5eaf26ecbae960573eeaa3c99ca935c8df0459d875078b7bb1aae48b27ad280e7870f8e4e093c43a91dbd653b8f2c4a2dd434bb63c1c5385472fa34afd0bf88421c9fcc329043ae487553b7a669cad85f1d38fe3f04a68802fd8f816a0c89e86d804f8c864ea5ba6ee37af91f09f06c2c3ce25159a2444404e20b290ad7ee7939375ee780c45a8331159254a9fb949c4c2bd9714c66337bd24cdef7b25815ea655de79937d68cb71c7db603f8955c5de27e4ceea94709785471a845abe6a612059d7f63df99f94b660d3e6bf4338b89164c348f9763a14e16b764284b9cddebef44ba0d59774e3944155878c95b0c314faac08d7b57817b3296f0d5dc070b05c4d73765073241810c08c948a80d59649f1bd53884bdee768afd65c2f576bd7c6f9649f88b6ddb0afae3a75c8edabfb47f042dd294cafb9eda2527460a0ec92f7d1699c61d211403139ced06256d91dcdb3d95db76139975202e0aa7e2b364587927b64f085992e3c95e4a6d1978f50988d98bda3ec2dcecd41c1fd35d72a6f7653eb3376c20186124f7940f31fa74631236b252fff0ad32024ac4941e071d7de9ec4e0167592ef3e4ffc19dec8442ee46c33eb79d9f9c655de1a4898ccf47282fcdd55220dddb0be4f3b18cc4034435e6cf6596b39ce09d7dd89c3279a02073557af22ef34f1dacb1d4fcf7faf1162ad20a9ac08c9e6b57e55618408bc3b4f4ae834fb3743708a1a5e36035f7eee7a8118c2fafd9ee6a0a02f860818e7d8a80fa95b07e58bfbd88b46aba831a87f44280cd313d7a1e7aafa467535f41be1204b579ccf09fe5ae1bd53fabc6ecfeb86b24fcc59b1fd685063f1667fc3f3692d5197eb909d8ce289debf49278ce1338296ecc58466ff0588cc811f084d4f7b69033613a6cff9bc6948846fe8624088b9bf7fdfb0a2c6f27dce1f5764bb1772367ff4f80d6efcb579562da7921e21620e2c475fc9b8edf560cbffdd87e46f22b12cdfdbc4c9ca9b90d97f7beea9f3906416e3829b72a2e3a7a544f115e08484a411456857b5e4e1aa7907675d497feba5c9cfede4b0250e777ac65759f9f9be7a8208164acc8184759376e950a3fca2c026ea9b655743ab3e65d0d5ed63f81e98673a9ac4f360daaa7bc3fa85fdecff64f8d1910df681c228c1a3ae19ee807fcc6225e0488c68826421509429c0117657840ee8311402292dfb3d6dd05455133f5fdfb4e67b7aa3c3f30f9c11f2c30444bc70888e56e83bc1fe7e372dccf2f8b9ecb2ee155bd3aa3a05d3986db1e92544bf02eb08eae41a95f9b9a4722e27caa8c14a15dcfd3e7de2321763e341647085f90baa9c5492f41150d110df983b83410555143965eaf4cc7372210c036f25b0d24a68a030a11d9952a19ac6db1bf7ab2156c7577e72c6ecc0c24f7a38a048938927ecd9f5291aed3e4276114e3464b3e134becc4dd89659e6bc51b22c4772dc0436035ec932bf969861cebeaacfd0ec5724038f8e7c129eb4c6b40563b96ae0aa845abc349406b813f43565d2277981a3cf28b264944311b9f9c59e94aea3cf4e158530f16b37af9158f0ef3cd44525ff8425f4e1a4cadced8bc93f6a5c8f0f390569b907aa980906b23fb449fb4c3b45c6e94116c0f35f638483df355a0186c19e3e208dd919f8b6dc10e8cdb37b603b48d0a8c614bb4e0f33169e2cba726385b1ee86556f12f6ae612c23c40131ad899fa1f9d3f76448e22b17106da1f184a8b5f3936855ac9a30f10dee3e411d6d1fe347de8b92b68419e1d266661f47c3f1e576ef2f9cb765e75ebbbd47bace64f8491ddc3d3b5ba513cbd91d44cafccbd60c1214f7359461f8d71aad742b403383720f3e8c9d6c9c8b1eca77a9c6efd57468d3a139227a1e1528af4509f92cb75987e6c0e6c909585a230828ca13371e74610b885fb9d1c29073230a5b17f9a3ac29972a99f696aa07b30c44d998da310c93b8f8d9cc6b26f22e536acc46146450f3a8f98039d01233bc3afbd367bc5241f38705a2fa8e2c04e76234a862579cdb4db7970e5c08b5405f08e00276521cf6646fdc3b5d6ae10b00e7415d9c007fdda976f9772bef0401d8a3cf3376ff09c39858901d08f1039684548b5ffc393614c7e8c362bcff36b287fd94511b40e463d5c0bf5396c72e09e526bb58c2e04c2874b59de80054181ad721b6ef6093adabdfb32f4faaf3d13f9ee93794f750a605826467619b34190e3ebfb7a9695c9b766ce743f1a8da8e3f2d6c3b7483a77d9f6f6c63f887a5032e70410b2be5f714b76e457247c590484b390788b444c555559dc51ac0e04a3033094c463c5289fe0e59fff1e391bbd297b9f068774079c0804824bcfbe27e1aa1826dc633038debbdbff70c24cbffd75d30330dc4a8d796ccb1cb5f4ad79c909e1756a57e94f2223dbf1a5bc573ab600959b0b4bfd431d66c7669655b763a21d44514db4a93032ec74d8f1bdeaf7c9b79112d3dcc9f8b70ec55c75333b60190084a0a22e589b96da5511b2b45dabaef67969f60c8872cbe9bb0f21f417a1773caa0179d64d0a9f963e2e40b6ea4b304c6bf07930ac0a7d33acf765de0e852e5a1edef5db62fa0ba619f02a67ff2222fd4daf4f8f63b124136164f10394bb6d83c90bf30718b7adad5e08eaff7f2b4ec48499b54206ff61dd8654650c62abc27555c5b8397718686372a9b01a58c8a32e7d13aba8753d1acbeb0bd1e6a159b07c5998a9014799b03dae40e5f5489bf2967c0c1d88b72f931384f499ee91f832d313a56c79f3fb01d7f3f38172ad33cf224523abda66248ae51e6992568b5c1d81d472e7b41a20752a61d6636a19e183361d0c3f333c5a884cd928f8d0bacbbf09bb1798f9f6f44765ff77db70d38e85709baf9f04f6de30def0125a80d04199d5aa044d317f5e8bb479dd9d1c3ec0bc49a9683c70fa9a0cd7ecfeb08a8a6e99d071ae01644bc0202b3272c9a7f71fb75a4bf97b5e618640b0a02b0fe35492e4686e92b0912252612c1dfa45502ef05569f8f8c373631a280a9df2ee7efeb86373e4cd68bf08c8d53636ad7439273d47d06ce7f8dcbdea01798e6ed7f0abd01d0d862f41e4dc0521110c712d0b04c9cf2eb0bb6b018672e81dc1753fc7a46f8bedd0123a606c0609ed9c788111202de1cf77714f0419ac2c5476c3fa0da65d7307e521e9477fbf2dba547056baf49b997d2c074cc48985ce4c9d03087907add1c955eab1e783c5d75d60826841e88314dccb1918a1a72dde25565e89ae7bf27ea8bcf38310e451af84341fac14e00164c70eb68493987174a3395f2528525ce9c30f48302cb93ffa30d69203716c04e135d3fbf434a606ca474671fba01e8901477a53e9f7deb83f03706a7606948c8667f28c4fb764ed7976efdb01fb91b937e73aaf6614447f2b9f7874066349faf474bf3d98c0d7cf9d99e63cc683be0a15b6716c427dd6371ccde72d15826ab95fd1282fcae4600f2238807e66c448634500dd19d59b31d4a88cfaec45b65f01d34ad6aaab8940b9217ff769ba86b9bcebf84d052ca5a7eef522221b0c4c0cb7774845632b0fd97eed93ce289a5285bf637b49c6e7e5b6e18dff069249b7a81b9660d4c7c7efa785613b882be068bef5f8762fb29aabd65ab0c16be9ef55db646634c9d9fe0a169e3424c740ab1e02d78d0eb375e57208b70c1961302d413b418425aa8ddcb9f353eee5305c5d748418293370fad633679a32dfd3ec6ab48ffb437213a56e515a49a8516f1230583c355a044f8d0f2e585946c6504ca95b888c46fba3a1e0d80136e392aa7dda4925a56e96344187d93e7214534a7f4351696623ee52d38425f3ff487cf811bb1bffa0b39dbea0b08b960501e09e9e2ff9b0de1c238f80094407fa8ba4050e04d4db56081e13b9f3eb7026310e42baa0f86befa305ecfc2e046d8fdc1143b1bec86ec420d03e42609252949d9fd793df5bc9e2c72579b72b912cf393f8f34ca7322e5a6107a796640e9afa8b6478ee9691a59f8712fe394e6bc0192a52299d6620b9e156dad9e42995c1b153301b31a2dbad5dedce3dc0463e381c75204b4caa6ad81f7d37c30ec23e2f43a00126057ded203e82e3100091c0328ca755c3f0c784f83e7484d9864407448794da5dbde7e4c7326f4c1a7261a3172c2aca3c3d9f477118bfa11b19bace560c54cb676545c101192a587923317c571523bc2d17e653a9500ea72ccead6990c89cfa6286188194da803c02a654ff17da872f76371e9455f4a035368e0b7125480b5804a1c9fc5211107a7a2bfa82285b560f7da9c035f1b237a8f499516873eda2f39a88b352abf9bd9001b951bf63bbcf012b2d259b507b4d8eee437f87d1a23c1b995931390b5922beb8a3333a7e57fb6894a51f2fbfc43df32e06b7f3190693e1b61f735467784ec908fd36c6708bb88dc26e2e482cc77261afe39a81d132ba3deb9a979bda67a557b8ededbdbedca5c7476c41aea7c2aa4c314ef1557406c9392cb9ec5e330799b3fac03c6a1dd56c80c66f9d68d852bfff4c188f300b774f773c80c578713eebd416e62d8b124256cf372db515693f91a6711fe4050143e4b24ee319f8a09cd758c19a511a12f533b2124dd26dfed87a627e9d7257746d4e9da849e84ddc7a2ee06e50f1e47a2abbfa86eb13577566f7713f7cfddbab392d2f19b68d2be4f465b5567a656a1c806eba19530f3dea9ae0266df3e8c5256ea45cccc626c92a85d4b038b85684728454dfdac04144ee3db9cc16e34038ee57dcb85e6d584157c3608d3f9b1d9dc59b30913e5778034ac0f53dd015cd80707c44ba485849599efefcf88d0b8456a3207bcad532376b7d14e77ece0d03d2d6f0663f8ff9804a0b9e8403019319514ec4bcbcddc772f9ec9fc4221ec64de9916a5623ccd4e1655e36a91ec20fd992846e7a31a2eb0b23a2bd7756c773c70c5a2c2de94734c523a2225822a83f64019d2f94404503db2a9513a0f8189e73f22d2a4bfdda89e58e2c83259d8a268587e2d2cc0f0f250104aee1b30b21eae951831fb82876d4e20b6d45d4fa2186944451efc9f3b2f31ad49063c163c8fa9407147314386934091bbed942588c6b60ee20773673dee4ca2a7f639b6f59f8f1a0155bf1d462ab07732b515a7a404b5ce3b7f2f9ea90699a3161c0751f4e6f15a284c7fae02deed2c00bec37f4ada68cb3b14dbbab4ad67f66dfc90d0f5058edceec2739f988b2df087acb8cbe21381391a00bdb78e47e89180060e0944a09c70e43e9f5d4d9b0a27233b6ba78203675d0c2749683987f4c7aede9207c8581c1e0ebbe868dc1dd27602dc400f2254a877c7702fe8bba6625f43318310c743447fcdab94e1e56435956b6f1bddc3a9b24c0ccc411cfb7717a86bc0b57174c34082a8d2f5af6371763c4d084077985f8fe8bc0dd9e4270175e27268151527d8a36a51a29724dc9de3a5581737c9a9ee25e3f8e6ac5b6cb8ecba36c3dcb8c0e3273fe667aba6e5b241a3a4fc1ae8afb5269da3006f82e3e6da26f9961608af87ca90ee1e49b6c08a68fca7f78d3463b601efb1913062773f50ba924bcd8fdc4da21a26e753913fe3bb87a6d9249a6982d10618607c6b89420e4be9a0bc02957e0a247a470e37e077a618d4eaf1788f5397fac28477268333cf55339fb7a14e891704a1dd7284be1acf58d20c7250bd41116550fcbf56783f05b6cb711f2092e59c53b9fa82627f86472e5aaef21e20d8fd1c96a857730cd5908ed080efa7fe424f93b6af270b4260fa07b75f6e58b4997725c63b6c14b02c4f454da5a40d26719bd3fe181a21fe7498c0f6aca10ebce21515b6f1d4ff41f29ff9783e3ed80e01e6dafb4a561e28e713ccc03e968e9501ac07b9dc725e72f2a381e685581c1ed274cc10125e4b952853e8ecbc1d56242f1bc3f0e610bee6b938dd6189f8ded5aa73c888b363ef26d2ada897db9555bd265a51318d90dc5d7fa154dda545ece713856a475694b83ccf6fa5da6eca4223c78c283ba843d14c9220d08198e209eecd5304d6483f551382e5331870c5cc3ab6cb3c3cc43c03d3e2f41bc474b446e86580ff574ed5f5b9e279f52bf4c021cf42b9987a57d290f6fae06ab32331d9c4ad07b21c7f37a25c826cffea72dc47b3c043ad840be08217911e6c619828461855228f753b6bba0432336b8ac5ab0b5f1104f9f145645c36a15abd2aa8a177195c2d230733a4e9245982a3c938f01c8072a27213c06c6370a19b3f325b910b7f45aff03bca62333c9885770f89b855da2b234b48df3c075e04e41ffb79e2a8e740282d2339f9dcca62bf4e7b69c1b737d153cd9e60cb27f14832ef57e85234f081960f1c6c620e74a627673fad6d3eab7041fda7d947f1a5d975cecdd941e68d49f20bc3159de428e0c1ef18e674d12575f930e4f1b211f362276d2dde78864d6e1726a2604af8f63ba3f701d8712f851f6227b3d5c86509a050e0a70e547b212cae77253c833a08420034f90f6e5af9aabfe0c60cbc0c275904bf781616867bea0607382dcc5ba8d0218496f7d810b22d8212d67168a62732fa6f8bda0d841e01c80573eb774c35026e1d0f70b2cc46b647820b5c5e099c71b95c5b6630b9ddc3dbbd84d303f796c4d47789e7548f8702548890c405f9a9a142a34346e37baaee84f0636f88999d6c02c9c4b0a03bed0d40a2e80cda94097cedb18ce46245e24924dd83d3988c23801979d1345f70c1dc87310f947be30751b7d9419d7b06c38fa060679d5325eb1e598530ba01e1b4c0c8aa76cc121f6bb6ca7df5788ebdc0b67eece8208157dd9c99d02c3882e7ad43da4943828c4857667ee659be8d1f3457c34c635a7c977892215676e079d42929dc6304afc1a466a37bc2be52cdefa1df2abe0b16baf7f9b466265e6bb23a9520d1ccc6a80a80ed985d957a46f98b21ca454fce30e26cc23d177116d7bbbeac8fb7e927b8e1ccf3e9cd08d6394b2f93084ddf6bec4a6ec7bb6b94858e25adc6d5b9ff3462dfcc6978c428ec5e070394dd964c4c1d810e12c28affebf9cc11888a0f42314f22ff86c6c424f9485d93c516c9cc67e2d2b7c47d93f6c5641b7444641c00d8f14e4676c87c69c5fc9420398e08bc19f64478168d858b1ea293a8305884280301b6b3a53874850e7cb772c0c1069e65556c1e32f04c64f7412e737524136280b88e5ec9961837d89124304eece2521bb87f48386a30f6e2184eff03c7df69648082df9899915ea4394860df947195c88a723cfde1808392f52b8bc1e2485e8866975748f137cf1e5607441772097244f7251e757a7631800c97bbd34f35b50068f1d7a37e29457e6348aa2eb6f2f869d1cfed3335c568ede54baddb32dc060085c72357e67995bfee59fff59ff94b445b9ef1dc6fbcd1020e22d575a6bff997417d8ed3463f11d15ee2cf05188643fa7fc39fcc0ec1bbd09c1e02cf0a006111aa4d957329e087e0133f6197993c019b943cd0ef23bef93530673a2f0ca2881e882e80f8d2cb6374122aef3a2a1be03178282eeb41a042048ded2baec02262f169ed09d52e11492193b95c456552b5f413c3021fb8a3bf02bdde3835324b71ef5ff11c73d221ab9ca3ac4c6babb010a5e02221039a6c7475d611f0a74cfd6550717ee07f0bbc88d9dc9e02348751bb0f656286e4187a53b90a4dd8c54b22b2d6aa70dc816e85495dee320a43c5e5ec68599054c17c8ca2c1d1b7e5e8276cd6e1d650d4a6720686c81d2a5b0e63542c6ad05463055c3e6389a897bd2db3277ebde67ad868e6d49297279fa3473363a0b728c9708acd97c087608b756335e21112ce0de23220d7b35d4d260f47858aa3e67f131c70d06b033f792b2bdf889a5a43170739abfcc194d0d380ed74d8118a2d9d832a71bd3517fd33f01cdca1bd6b64561b3dceb601e0c97286929628e2b945a242d326890b41bd357a54d3c40078c871ede9800131f623668b1f78ade886b745f65b64200e3c607ce78b5098c8807634dbf8f421240e1025d5d26ae73806bfed42b6a9ebc24ade6eb6d139f095f5ec371e7e8e71617becd8ccac542aa7ddf060afff30315c07058154d72a5c329058f3b74f03874c6138b6a783f03461bace751be951168bca1791229aa39647052689681f07b0d932eb0a2ec30bcd6998242a1e8b775072cf268c2d4137539e024942a3794ad135bba5ec77532cba3939240441eca2cd6f9aec9bd4b37e7f3561758a45afc4cba681664ec9c09b2f6c1430e495d1dbd2905d5fcee54b69c88663d0540236668d89ab0a145aaf1f0f1ab758b0ab6ed3ec3ebbff2b56f2282a6f8c063dc27cd43354a6dc439d4ae8bffbba386a5a4508f7106203131574b2bbb86eed9e0ab3dbb4205d849e32a4ec142f16442303dcc6e9c466e5b5713450809488afedcffbe07e77ed321ef15832c85235ac20f113d1fec2bb8cc228276ff932a924057bef7c39f36a73a6b6cd8213f149ffad1223a02085d5e4e4e6bc13d68a47b2b0f355ca2db38b2b5a0c8456f5f78b6215e42dd87f962fb3e14b9f91d71e68d103f0b3cceb5c96250d1b8570ef5801b87aae2c07ceb4215d1abc6b94a4bfe50b9dcc5a4fbd5813c93a3f5aec9c1f706342010c4d42d1e6127e941223e38174b2cebd777e790c157c522e48d4aa2044cd29bc4f2eeb4020fa388d350f2acb10baa288ff1f4f0240cb1ec6810c415c994b6b866dc281f7695987637bf6685d283b4c905028dcdfb233c0fb0aa727b4dd4aa8e6597083cc4964cab34410ef3c516d562ebb1c6345a27271368b44a83a11f7a11a543fc89b4965c8257c7eaaf5c808385625c0523b9983a4d4326502d5c8bfa79602816bcac9b4ddc723b2323497d437ddd12122e647c1d066ed245937cf4c24a41f4763a9823ccc3dc9558331ff3064e32374efa688da88122eef45f3a5190e365d378ffd1b5de73a5a68b64410494d36cd1894fa2b868b145c56d4be8ec115ab68e4571a22acea47a61c050bdb5863385e9a1a1c038bad88e24a682d8fe20e1105a02dda1b3ae8fa71dad5059e2013bfe0f05e8c8956fd7a7d76a1b6e579e0066958b12306cf0d0bf04c36fb25b617a8b834ea8cc3c9b87cea1e1e9c9db349700e4bb1667c257082eae9e857506d3fad64754ef664b4353cdc2182b7172e62cf867111834226db88eb5aa43dd4e9974d116de9cab5e9d45eb76b07f1c105fb634d9dac1cfd5f342a46ffaf12e330829c8f3073629c53d25bd0563624ad8f9c08585a47df6672263df421041e6d68ce6f6e924fa67ac93fc5ee0abc45c11df6a03fa992df3333f32046f5bb83762415d85349b0a31ab3c0f2b5bc577826388d839d26ac7c1c3ee2205d016585fc54c986a01341a66414af765ddb611939c8b0d85b3f35b1013f5c3c0d2f288f5cd21c9d26b2b8f5a62d9d9c4bd76205fbcbc118b8a5881191c066fb6111c1bbc6d0d6b843ac377e642fd444328725a2ba9b939f6b35fa723ded4b974d57f500421d0cea040029e602807b32c0fd4ad0e09837fcdde35cbbb9b8de54802cc9fe16fa8596028a843c0643b1583116fb6ad36c66efd7291151c89c9de7f3b4c1b09573941d3f8e436ef51b82cb01eefdea352cdc0edf4090eb245af4ba03e17a11fc08638710973617606901956abe186512ab7c3aabd5013440d89cb2224145cd9de80969976119afc54c137279a8959f0ee0b07f3f7fb008ab8cda2f14a32089842d4eb9faea59a28fcdbe62e7ef5ecf24d41401742c377334ac5cb8b2228aa160b26ba867212e2bc0c3d5661ebfea79a83457c644413ac3be4efe90e3c541ec3b651f607b956da39a0d5017ba12214a6bc1be7514e5dc219f9e183d9aa948f39b9134ed38789673e6a5fc79bc432127e99afd5974ea6f8b7ee4e2aa236ba99a9e64c56e8f3f6357021fbc16f4a6e6ae704b2d7e02d7a2b4453f1fcb90267f31267de445053a74c74473b477f68245660f90fcb7c7b91f764483e4c7d16c7b1fd9b50d6f01f4438def0f93bf6a3a586d4e8563bac91ad4e2460739e67875ae2ac76fcf2a92095eed068d6aeac1effa2cafa60814b78680b5c6eb17e411e6c7368c9b78e807d94e4f8db224f87cfa194865275d90b5c6bc87cb9db2aa4144b66e93ff3147dc384cd944abd319df15a167bc2e830920fc155fc873bfca4e198aa03e96672ffda1eec369949cd9df2ee6df30bdfce2adbb0a851be3a9c8adbb98af8d34512d3a6eeb6d5288d258da645edb79692688d592294a2b90b8523fd761ccbcba9d3623448b6ff58988886d25723331c6a272d1987952fbc4aa0d398cf03302a5eac3afd066234bef352da50fbc8b4264378a319a8ff734c007a39d8c47d9ccb338a6f6bfcf8afa3146db5ebb855a0140519c518f1d35ce004d96d1d948ae8fc3603b040ff92103c0e2c6dfbf6e5dca999e0768458fecd5fb845e4e91051d397264056df4e5fd25ea9b29fb2ef62fa1e30c3c0ac3167b89fafb6c12b7cea13d363c17bc603383e22991aa3027b5034ea01edc12f2031b6f0878cda1eab5bfeb678684684c74888c649a17e3718c2912c4f33131fc02f2ac606d054cd005a7ea8081d4b4deb81daf1f9be49708025402280b5faf74e71106fac105879b8b4cd22b72c7895b37a2d3c4fb855252f8d0c3949553dfc1ace175eda68a2fc63d8549fc18f95eea387cf9b2b4b6db0d65568e68d09c422e5aeca3cc5874759ac0aa46047094fed1d80ef4eab85d9cd0891d346dbe50e8913dce1c3c2bee8bb79ed750a0b0a8cc98d2172a743fd78e81b46c8eb949a6d4d8f14fdfdef8c3039a9ac9a90425ed59f4e7220d0f94bc32f3145bfd8897bae2090f99516d4bbfcbb168585c4cff670a30aeaf6d7ba8e4ea7ee96c9d38e5980865e35c85022e755b050ef735c30347b4fa12939a1985eb31234898f0549aa0cab3447d3bf762a0ac0d12ea3be8383039a2d88d30ba8709a2d4f2d628bb1ddbccfba3570f1b3029a307e3afdecfe6f009c5748e5dc1cea7fe40e451978db3b74fa6c7e5005863931445125bd0a522bb06cf74ddd21d7321a210cfa228ef8d0ce895db26b19736ef12bd54749a96002f3ed6e5cb024dc6cbc6e89cef27108e27deaba518ad7d0885d0e1a2b76767fc4427df0c2994b5ad544e111b4b9e04e6de6925833bd6ce26a0529b05097706b02ca28d5637650d42ac907c0a01acfe8370fee10beb7252f0c03d8b4aca2c471b9a4ea596f1b34e14c1703f7272eabf8ec7ca5d2f50c2951d4a69edcd39355b63d3fd74541c1d357ef61862065bf9b044173166458022a34abdb6fca00683d527da62c7385a4faab30a47c1d954b752572cd37e694d1a88735a15d2dfab97f253a681f2730a7ee59db28b5ff83c1dfdae83d030f240f3683383a21ae2b99bbf00ad6608010b9cda467ce3dd8b56d95c86a6380ed8593e7fd9931aeff70e6d39b6262da02c3a1d8628ef258a47edb5cb9e90a19d216f426321d76b94e3e2f744f18f2c7383a63db3d54df7298f21f0cf38268fa2bb9b906ef31810aa2ade169cbe9289fd6785a03735c2cdf1e520a211725df9cf448bfb7526ef831f842c8930bf1dc99c32e4ff9662571058c9ec1d794cac78ed5beb8527210dd5c00fcf6244bf7e54a1229b5b8e277c3688dceaf95ab58ea7946045d80295001ccb56a9973010e741b8640327e9b8c41adfc9d57f494417be64cc4e9b2886532eb160e8599f3809a12308ee5c0934b8fdfda4fe584cced505e155d24fae7774e6d44f06057ffcdfedac1e8527d1b6466a4bc0b449459ec845a2a8e0e7ab3fc88526337db20a4bb167a9858ee329211455582a9a8ec2e5104128a54345bc01a84cf7be1b5ccd582f4ddab904f8d7d19c3057d3db23eaa4fd7b44189fdb1096ac4c631d092e1e344d4abf9a600d6bbfa4f29dbfc2f175d0dcf40e0e4ed7d005f7d4a4503e8ee20a1734041fabe77de5bcc93b936bc68fd4c9bf786848d0840e2fd6d020f5fa0d302158982ef6d1ba26238e0f019cdf4c42665197dd466e0f845c475de5e0ccd3f794ad5ae5952fb977ecc0db0e5c7f41869518a002dbaa4f9f7fbd49c276c0b59d8c60d0895fed6466f5f6621217f811ad2dadcb3064084621cf0edc497b2d10877610c0cc7b4c10f21501f2cc8e74e86da69ffab112920d7b1eac553b9a48fc582dfd66abc1f8d3343974439f0c9459677e52b877a78fdf47446002877ca2029590338fbec3bb7d3a9f49a75c8f702741f9d724b783fe0c95e7de366df73638579ad08e9e27ca85046b53a9371c512733e8417c587c78b1e83a62d9bb3ce201ffdea981564c46010e3ec6cafb9087c4903123bc928569551b3d675b0611a4e6adb2b212857d1183b4f5374d87c679e2056d48a7b50d6c48a58aba16df68dd4fcfcea5de81092bda32faf4e85547749f111ed23f77670cfa6d73dfee6770881035cbc8a9fe68f993bf653c1b173acff0e619ad4561cc3838556a37ed4354b7a2f9438e6e566f66c63375050c8343b6fe3f3b94d290e8b715f8f6444ce6c6dba9d9c1272fd0260537e2d6e27f0d6b19438843530d0e4a79d1432db4be166847f19ed6e4f5d62163f7a34c7936ed9b8551030a69ecb5ac365d4c29758d51fc485094db5f815626341b71010a76d727ae2c64bdb49762c7ba50914efd1a999ef480d5747d18fab9f07c48d03dd15e130af9c34aa4e5e4447ed357aa2ca1408e6ca20c25fb6e18ab1a81e036e6da8721a4ad37eee4b6688d182d1112ff9b71b827664e09628ff66cd1582c06daa71f80f23b308bdcd0cf616e5c28ba547a8151854c6fb55e4cb0880e79e1e4e7ace01899063ef94595d81fdf40fcefb57d06a7e75c2734566e70fbb5b182c522917af9fc96950d7523cfe4a99ee9d04700ecbc8aac559b6474cc33742747a2d9a364b3f57cd637879f5a48e476e6fdd8b63d8c62eda1beb949b753c871402a9ded4c9350683f9a4156ff6d4ff1a002ba7d60ccd92fab26304cb69150eac549d469ead7cf6cc471c1a359cfd65316a0fc5dff62f85306668eae4b8989b104d9c3a5dea4a1b51874964646e0cdf6683ccbca8d495ab3fd4fe26ff2ea01cfc3df0adb813e881e685d3327aeefdfb51d30f5d58be561d3fba1fc0e74448445bd358a33f381b5c01770c07f053fa7a16f59f727c0cdd1691d0f0de18a85a06fd92513dc0c6ad7b79150ccd559298c0116a129bee6d69a6805c4b0da1b9412123e42ccc70f347c77e4d9694e8ed1fbc4592bf106592d8d76798ce8a553f507f7ce719a86454b7f48a699ebaead94730421ed1ec69c0c5b20dbc1a2b4274c12d55248c7333864b3db95bd2e1d5f092369bc552f0ff0315affdc2d3746e316ea524b52a71ff721cee33e4d4657ab9caf7637e639760c3ce84c2718af3e87c798ccdf3a37b7d155f50ec3af0b4f5667873919d4fb460221ccc3078f8a0a1f417766a79537b2623d92588619f4d330dcdca03a7b869c4b9aa717113930e98a938211d6520ffca87627888275057f48e77c2cec106117f629efa1c89daaeb21f8747153e925b4812d5bc0afd652e3be8488199103da22b644b50213f1947148a6db113c8cf41ba242033eb43ef587b57a781b70cd56ed0243b97727040d070e81728f053c867b3dbcb302e045eb5c6111075987129fd65af97528581bb3fb822b11696042e9cb5e9b37e20cca30c9537e71eafac69ecba43f467aa4ac8ea8abf6f9c05bc581d1af56e35c7e4a925f8e4003b39f2d36f03da882750d56c84864e8a1f9b38905cf04d6bb1673577994afaeb8c03d59c54b4cc8c0d8f1f0f195348139768ee12949a89b2e9931c56710f48e87d22ef985af56c8cbc5795067eae9c2c85dea3f852206e8b9bc5d2eee969a4fe9be441ace9b5292b4e40fc35389cfeb21e177e40f1285e6083920b163639cf99aa3b1b7e32ae739cb68ee1b26387bdc78c560c215fa5df4a2e2f66a5f6968bf742f795a542c1b574c4106e45b13896cb278a059a421c771536b497b8ae80d8c6d6a797c22debb88a5b42fa33b87ad1bc64140ff49c01b2697eda66a89a980578f664ed14434a78a21d4ebd7497979f9cb03660a3c410a6232fc7d2a4e437e8b1f210ec3a180e1cc730a992c73d34e49a7627e8cedbd5b3ecfe698e041d07a42436978c4191baa89fc41a7cc0c199aecedc46d2fa544f69af3b0e6f8d868b6ba8be48d2ea4f2a55907ede7b457005314c7479f3d7959b8bae179f70a142f03f2e469f7121f1927fac88f09380fde26a44817d6be7c07ecf7a6bd25d5b4a9457e1753699998536349a7e830fa1a2da1a37331b00902dfaa8fe16dc7987100247343b51fdb99cd49024116fa9568470753af6cb9a108f9ab91714d9b9e452031fb9e7b811f00c34e4ce737186a812dcbb88fc16a344f6738b63c807d33dda3d28c321cadad426eff7bf6598bcd9fd9e2da776f8c8ad66f9c035429e3da665e74a5131cdcc9f13875937b67cd16fea66a9aebeec4ee1d66d6cf12f1f93624f49e77ba2b32cf79e9abeecbebf0a2a5a90e97510c1b7cacbd8ea93465a52d447310c210dd39392503d407b1757b61ff5b704c6640eeab8ee88a996fb12dec7c77187c7486c93ab7044a5d786ea8b4d83d2b8b38adbc2485950424371fad1c4431485542588f576230c24b343cdd44c06256be1ccca46587b01aa3f75109491a9cc7a70683459d63e551a035bbc0d9ec6d2f349797b6fefbc4a5806e3a84b6d2a05f9d3ba7c55fceece3085efa7fc108aa15b0a897cb3d6b3216631a9758aaba2cf452e84f2405b44e3f5b4d10845d26f641931ed774ad82e05ce49e3eebb37f95e937afb6217ec41c1178033385ec790b5a017d6b17f36987cf56766f7d4536813370c006b29a23344df19255d47f427e9da3383c6d350ba97b384f9234a62565c726f48b5e57feb15386c2343325f991aae7b21334c3c2e44d89e666905fd2b39135dc802a4abeb57da823be2006841fa134ecdcaaf9b74cce4ab350731bf0e42549c8dec456cee393cac906a73279125ea4e20b0465c11d0c51387720a0a1621dbf7a6a1a16eddeeaf1deb6049eceabdbd69744473222344505b052c49b64c27a1ad7021869e5d1c53259787fd96b61d2f38c6280acd29cd6bea9a4f276aefe5200fa9f41f70d3e430404d87d59410b46626d7a1651340a87d02ebf7006057a6102ddf79a0ca31c1a552690080ecb6afc595a0e4c4b6d2a70f96403a749a9a721b49b76766a22f8f05d5a1e15b735d71d9e8093edeed645aa0057748524a0385670f180fd00f8a5f6ce4c9935f101253c96ac388e553fbca32b2508b590ef2f4774cf3286677d062cfbedff1f699a191565fd4cd243d8abd673041b757c41ce9d6c08de211cf97efb66f8b64e31c8754519affde121642b268eb8e9e88acbe1283bdac9a57022f993992531e5be5f64a79d7e14cdb7c21c6ad258b1dca2328ca980510add7362c7a453f9c9a0895dc199fdf71de93f9b79366b4709f0ac6a3f4d7fbb0b77280061ef7fffbb32f36449d9bfedb3ddafbd07a6fc45af3b54fae179dd64a3d41b5299da8595fb4c9637dca8e52b975a76a2813f45bb3ea187d632fae4d155c82b0099528334fb5ed903bc617195c244bddae41acce3d0a8bbd53897f2c5909d1b6f59b3c8065e956693e2558dc0761183d20d2e8f92c93d8f03f0a18e649a779312bea17be16e2edc895110adaccc838b773418a7a118fa1369f6886fa42a9853ab5c58cbb411071b9aad0c3332fbfe9865c2fff80d2dd09b692ed5c2e4fe77eabae1b6646948f7037d10ca6a849dd7202a029b4bb56caf1d7fd7e208e896bb1b0baffff0d825388b84f5d835541bb5dbf01269e9ea8bea1bc9c764c34c608c2f36dfe683d2802397472e2919d16a3dbd612b324103fecc8115ef83859f5425eaf6fdc0bbe6c608fba57ed336346e8639780dcad4951d3c14cb93b2a02d8958cb5208c1e154c26c82789d21a9a7bbe100b16189919b26514206118c1b096d969c074d81ab502d5b2a5ef480c9d8d2707f563e8c4db05a5981ebfa027acdfceaa06e4f604de9c9f06f33865d85667564af5cf3dcc3b9ec5b189defd70197a7e9334b2d1b3804538d8d1c4547fe1ad5889cc753705b5bd058109952e524e89b7c40994475cd35f26d6ce352aee57f65fc0078e842996cd91db25ea2965d20d8383fc80b9310183f866ac51764451c447ecf5512ed9aec5eae6162074556afe16f2dd67f1f6501e01178a2ee5e77db1b792c94d1b752b874581632e57ef4a054bbb752a06891438c446c4bc9f54fea8616c5c71287d958eae10a2d527df44c326009d4658dafc1565f8830464092af350e57c345bf819a72ef191c6aa1fd17c94bfa81f57d0ddf2b6bbcc77113d4bb1f2a187b46f46234695698041395781468443c24e15a0ce98b0188b769295e3e19d9c5bb1b60e138e495d879355e9f9c54c42edf9803c66bb64a944c910afc160be1f5c4caa0689d15faaae4ea86d7f804c3409dd368e5d3d68940bb447a46503d222169ce693cf066cb972e127a921a512a1b0c2515f6ce546e5fac90078e42fefaa59cfebf89e2ed595c51ff2b7847031a67c8f310474dbb06c9a2ee415447f98744ead50f94b5ff176465fd12492fff4cf75391c40424d3761443564f3279c240aa5fc16999f7b54f8b9691ff93688e87588c86491e314a12ff40abca6dc20b01a70647aff9376147d4ab260414c0e8c57a3960de90016146aa116c3a26bc4409ab32ef62fe6e2700e22e53ee39aff3fb7744eb47bf974f35344ba841cd3145308f906925c3d3ed71f3e07516b41ea0684442ac63db6278af887703eb74a5c919e7fc1fef9f1c8a513099e75cf06441265764125355f1b9bcd85f613f103243653a36bca59c8931ce3264160d576cc888c90dea64ad57432463239285dbc2941cf0866ce9713fc746e474e22343491b49819068fa5b58360c59487ee284c61cdff5027af0b0add52551224a565c0b8f11a670345ad6e9a2ccd75f1019e7e6aae1958761b1dd1c39bd5554839af3d97c34962c56b7daa6fabeff7dcbecbd9231f25dfd8b57aea5ddd4331b6093cf04e05e3677aed1aef163c305d3e4c5657f1a19e0eef142df531881874f45058e7f7309aecdadfee5bdd99b8e84b3145ae15b713c0c813f6b945cb44c0c411c0d3b5ec66cd560671eebfe4482b0c9a096847e5a4a8d528be27d0e23e4507b59a4c18a395cc55b91ad9389e4ffa647b7400d49a695dd0b52e03cd1c83a1f41cbb6b91420574c63299bd1aa981630c4d9a19c76a883907278ed437261d0d1710363e1694f80bcb998fef69e762ddb610064cfcf43070c6adc00eb0f59f593b0837417006727944b4465fa1c87d96d28cd62c5104c4a86e288cc8014306eb9ee635a800d8fb3098ab6447156e5d55fd251e427cf15814e3a0ba2d1fd03abb54338dea626c97c7a1895e21fa49320401cc56980a2be9f8c10265dfa51323520524a8433275b1ea89d903bd1b7b2d7966af71fab1f6ac5c3601b83d7484a9c3951df30d0915b6cd35ae7e3057898c9ef7ce2c5fca556d70b9ee5f7359cb3acc17e9c744dfaf974b1b3d460b4ac6f79672c3c90f14dec95617da037c8aa37a1b80490e97b9656b9610242a632690e331787a850c171ed4e92bfcc5f9b7523fe6251eba47d7017c008347d6933f703e5a5f683284fc0c965d2d2ec812f03db438bf3cd0129454956aaa040f44b37a0ec8ddff9dae2566ffc9aa652fd3e323815456146ae042ddbd426878a40d43d32b0b16de19bcaf54d6c5ca3865f2ccb7296f989253310ea039d0f739141472715357469b9d4f0d855dcdb6e054ea4b33eaa2b31a22dc27196703c41106e0694b7ab7829391cd4a10799fcd359adeeceaaf66c3d57ea1a8baa39b0de5f2b04a7e9af","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
