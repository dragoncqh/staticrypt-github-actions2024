<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6846d697567407e842b679bfe17edeb7d4406f574926c208a61819f59ffcad1e0a8e89c2049b5fedaf90672f85832c5d9c12a228b678685b6657c0f59f15515a4142f4ef55197add77a1610f540eb808d231d36a7b6a229d6180f45936def1907f63caaaf5cd46a86f99bc9e85d8370d4e5e0d2055bbc49bf5916f48aa02702e389b374aa55d003247dd108f26cf815077c368c6dabde049c9a0b680e921a0badc3502234ff8ace634aaf374c225f346163e08bd4498899238619a891084238fd9fcf705a86314a2c389cb0aa1c062cd3f5bbaf66af657fe4fbdc75b937e805b448c9fd9f2efba4a504b4009ba4382d08513ceaa51f1f0883e37b8af36214fd3ae31fb49ac0d611a42f020829b28ceb3082f5d59eadff14f6e785db7d732dc575984455aa1fb2b24128cbe11c02503fba60abf15bde91820ac394d03f13f287bbace8d33ef4cb9f4d573e5b8f8904e53a94cfdde0df458f8cc04d7f45eeb702f30adf503fdd377ae9b543513228cc7fa5a7a29a6d8d140ccdeaf5a0d803c0852f0ba8acd76de68b8fdddc0f1e72e36bf120e7c50ea02de8934d45505ac33ffdd027f1f1af2d12905f1c1822714e534e7fad9dcc799fae2f170ff063f8c3b195f7be07f675639518b68dbfa69a8920ad4d50e208e87da29e557765c9f236bcbc0c2650da0475c93fed74a44f92a98fdbad4f65df435cea63400ca7dee3768e5f82cbdfadcc4327c8f2eda0308c52ea25b61e80f0dfc406426a9c89718bf6d501a8ae5d566c4a5baa4452cd5c9676bd46bd7146f02feef7f7e1f2c50830db2b730f59bb6ea2c39878751dac0142ca50d1c878bc0b5afd58555f5aa638cd2591121d89914de36dbdd2a094e450fc6ed54eee4211f460e7bb55c352897fc750cd0745d6aed2910b0ee225d910951f1aee181e047e4655f8d49a3e35e698ab0657f20c1afc6b4dfeda6f1f2190bebfdc399cae71a289431bc2fd8b11eb3878191cebc83069eb9f3229589f06bd740b1e2366dfa735fbde99f16a2fc2465ca1441525ac533a2c92f26ffbcefa3636ec30118df38e705a957f06833501bc9c1bb19493c1d786968d44f2110b2899b6cbcf6f198a1dd53c315fbc0b738159e90dd81f6c366ea9f4111b5799acd59ccbd12c6ce935c52cd7fa47ae333f6ed2cf8f66e758af38b4090779c77a5ecd932d4d681b40a650e2dc6e16c5a9c8f6c2fa9fecf67b7d7a019d30a59950a25e43f2ab9d2670801215bbdc3e23ff433adeb0a2df9086af89311b96b51d5fab1942c7b7f776e08b0dbf80905b101cd720af4a4c063655ddb2edd73cf0ed35f95cd4eb78ebe8579cf17acdc60dd4fee9805e3001b68f180f1126ee3f06f8f5b0814ef25048a61acb1b02f30f908d2033e92a8b75d5371341ca27aa5e0c07482fc3c9c84e8f9f164f231c94d59274958268c8168982fe2c31390977da1e894b20491631c48807e43026f0bbc0e505a7613dc8edf827a479095bc15cbddf3c58c6bf136be27e386d5d11e3f8549e03e182f5ca84926c305d40be28a6d44f71593a8093e73de01ee09e16511782983f593e35faedc864dc34abaa1263d835422fd3efca3fa3ecd59e6d7640868a2d51bd6265bb657024df1e7a241a377a4929aa618961f2c563641d9b9c412dc72fa9ee88335a62a9e7db72bf7167c1298d07089357691547efd599960e8877af28aa81e2da6048f3fcbc60f3297ec36cde3cfe727b4f4f198c596880101ee785fb2650e3d2fbae1bd3a01fa8e5a56ca77d41c91c7f12abafe15b6141a9517f4c67a5698cdd35a929bf70c592e1fff6265f92e12385f31e1ab2bb9a7773a50636ade344225cc12c65b9a16e426d1823ba250deef705860f83889527923167668b5c55ecfc7288b9f0aab0aa6a810ee238eb2c9b604033e5ada329c5cce07a235307e25623087eac5b01c62728b16d26fb90e626283b3b34a7a801d4a8361e9f65b13d1884d59f51786ddcec9625bc70fd9525cc21fc17f31cf78a0c9e6a6f1b078a79a7760294dcd264b261d9909687d10d00f63b847fb5d8fac79668559c9f31769a949a13bc4d347f0798de22b0c96baaa49e8cac087d711377dd27135cca989659ec3481bfbd0172ac86b13e989f5c23ff930530c6d1e12d928f5ccb2fa522a2837f23064762530eb169d982bcbde5f3ac24f78be646bdd78bc284ff401deeb0bef514f2a18b96d38a4c0e94ac73a6e12f4966b835272219c01e088341d3f925d26f58b761c3926a62fd08323f368676569f3cf55f8334445dd72812455759b46b92e99b8f2002603183e2dc54c7658f5ddb4cc5d699fa494ff4cc4a6f74f1c59fc9b65413e15255ded3aa0d1a3bf57072608de957ef8a0e76b3f3ee03d6557dc7dc5cde50c420e2d5f26fcddfd36a75f3b0eb448d392a1ae3f88f18821ca89bc80da84c6dccae599dcb8e776c6a9b3f308a18b5e14a07ebe64933bb27e754f3ce1609adab27368f6dc259232df8046075541e9b60f976f79d150b757b24f7c690b25302ca27de246aab1a71f94e649b0f7e33e18834f493b717a1c64a63cd32e3ccd13760b823617f3144aee5f45e9ea460a2dfa841c0aa2dd7395049bbe7501cb93ad62eab2eec99343a281e68864f9cc96dff1c7c778ed7ad43dd7988fb9a672f5719c9aa7b38922ae265e8efa4e9c575582ec426fc3e2d1284ea588e8876e8b1a7c76c747bfeba22e3880a47c117bfb7cc50bd2656f2f2a0c97721bd66bd5ced3205776723f088b09cee99248efbe636be8ec825cbd1c56f9a7f1254878b7192ac845c371652c25ab14ebd9d7337796568d3d1c52f5cf7e78b49ffc352050cd9da9747ee18164f9b6c54d608fe7e26040ea43a14ae16a3dbf0be48abc8448d4a411b81affae610ebd36c71ae04858319de8534233184faad50a10234b9b3c1af900a2c6b76e0243b05d94ae726d2795e0f772a6e7a5fb5eea7e5c2d152e45f29ffcec10669877c609fbe62368de7a6c1087bbfe0c6d54a33b9855b5e6b42e1053133c37f34445c4aad7747f2c2dbe9356e498972bcc74e78e494ee089e999adf9c8abbc7b1b6ae96244c88e5b99e99d59dbbc89b49a49c577763cb53e9afdd64c209668cbe138283a30af6b0b1f476e8126285524536eaad5bdfccb8051bb445f22d22faa2187b3b362747409f0d877ac76d9171be2b0cdd19c04b13bfabe1191fd35002d86a35ab23d7ca01a1e3558b036d02bad2075d5a8ee61cf784fa4b8626244761b715a995e33581190d3dbd7dd7dc5683a92c473d18ffc35c12f49f0408f7903d8f3a8a57e2288a8317402a94d912b77e5aad9a3d707f916ce9abb5b5127b922e7273fc690b73b83e69648dfa292b71fc085121bef5bfa1f5d333fef13de1ffec3e78388e0f552814f45b04a84282c2cf433194d5b1ab03933117f6462efb2264e97cf7ef86fae1f9ea19c569960063b6ad7bcce9afa0674ae88c8bea749d9570a6c6d12fa98cb30614ef4c36ba426f47c8041541a9c2635b1b149ff3a658dccc52ca8ef68ce055c85c195003316dd497b33d6920bc8fa17991789cc5f66b921f034c678c359358019a67bd2d7adcc8a8854307490b428223b80087ecc9a6b77dc310c186d35efd78fc81c56e06153cb820abc0ee1aabc054b884bf587354e9903e248e3e1194949117e78505d5e97a949a8cf156a620182c1c06f2bb137a0ce05d2c844a1ed44205d1c9c1c50f8ab3505040c58243ba1da097b6e1f1142b1ca53be0ee41f8353bb66b1ad3c7cb2413849baeea21d010262effc8b6436195e4fcd4977dc0b024875ba3edffefa3fd105bd2eed5bd18cebceeccd886db46fa6613aa22a5c211fb82422702d5816ca5fdd823960e621aca7ea438075c753ed8a6b2002f9058ed833154e19765637adbc4a32d31e0e43341e7e932d3eba7c22b86b581fc985ffacae95f9440e32dc87eb78d3afac143737325c2bc50b993343ce9a45a85b8b78fb23e42b1025f5281b876ec54abe9fc67a98ef68a9918de5ec776302a11ecb5d0e52b82679caf2eaa53d7e77b4f191a8254dbfae29671c470d273d6b87a89fe1d1048d649df294d37865e4445098c8d77b0af7e00528cefe2527dae9acee68f52e174c4f53c29507ae92f04d48d6d7d65f47390bfcc53d5be429eedd43bcaea22647b54863846c0a1033ae29534487fdf86c3f0b59655a1820867bd59ac2130d3d02a1cba898829f1e55efe92043c453c839258d8c33f8674170c6bc64a030b6774e83ebe3bbbce20c2fe6f34a19d841cef3e296a84052dc1a2837f56a23533880b4fdc0420f65a4dc047d7c54a6c51993769879ba9cde60b8e2d126fc383bc98c52a07165651eb75642a6eb7b2d33c9bdc8156d3ac2b159e630d28f8b916f2e372aa96fd3c1465e8f3ed8f31dc72c3105d595734ba9653d12ea36d17938faa75ff397c407f8eae8d5f98c9e69858f0283cf2f6920ddc9a7032b05810783b49d9766c1b59056927737ead408e408914aa3e0b63fb80eba9722b6dd23a2a70864794af5fe76835fc804d91a80c4df56b339b0fe138b4267b45c938e8979a164b78451dceb3a39f6e5feec0049bb5142561d4a4750c15bf85238b50c68c61f4e99c3150a0aab73badb67bf2cc712e8a418353106cb074e9f8574643e61323403bfbd2f74e805a7f5572b2dd53cfbfe60bd085c832f64bbe115a11bda9faf441aa19bcacaf3a13e75305a9c3550848df0dbc6556ebea5d48605851e7a4d158a11530498c688a1fbcf3d50a94f806408e0cd8e0b1ff1c64dc48a1d211b4ec75aa6cb13f47064e61383394164d60b1882b0c32c22a7bc701d7cde49c2ab61f3f3624c46d9ee17e81f5cd8eb61a4774f7225201b174bedc84f15ace8af6b9f3dcff16e8deb65251c0605ac5ae4a8f0755a79949defbdf1469d4473cac3f2197f0c3f6fe5fedeea7533edab48134551a84134ba192edcda2a699f5840c427828bed711da14b5b8e88347e867e7a2a173a4dd378d6ffc2f06f1e5316c98c2b5f34bf4cbcd81ab618aa617ce654e0d15f6647e514ecd9b7fa346f5b15f8021ea239c32a386a73e7bb9eb4acbfacc32bec0c38af13b5b723d88bf6ad356a8f76e08ba4793e2ad0625dee103bcc16483686a96164986b70a32085b1dbece290e1fc81b62ec8038b31a08f554d51813d3f7a0dce145d23741a08fe8f181538f4cfd4d8791c4b73206ccaa5b81fa7486ade6c7645ed5c8dd62780234cfb32a98c4fd0ef3796ccd7141dbac505584c98bd957878f864e433204cd186a5c9aa48b3f57719abf5eed304245773414284099796a230b14f29b80f040bf5d80580ec61f5cb4af07777851dd9410d229c8f6fcaee176f96e59aed0f0e08ba4c51054d44853d55caee46e473283a0f0adf9d8ac4c8b85351b0732fa67eda879a5c84a23df623161d50f25fb569b36aaae9814c4bd9a13109af6b95d0c2f540f82821b3daa34b45e7000100e144c776fbe95f6da5c5894c3ebdc0ba89b97f2af187fcbd066a949e204aa01e2e75614569c6a2c37b480401d780a9b1d2285b8a46999b69300d6ee8092c36a22dae4ded6a0d5e4d2c343593603d7f241bf1b194c15a5dd6de27c2a14ac1ce997878380fe0a8c6a76fbbaf8940d36db395f1796915fd28892f238ffb3416e1062fc85d316d22f693d48ee7068fb6bf895d64d00c2a5a358335269ab73d3df63ac54fee22533d9a8b99231cbbfc80bed6ca0139cfe57a50f7ad42c9c9ea0298da5972396d90e1dabb74990a289347130ba8004004ed2d1d1477a94267b5b01d60c610a6ad28497f506567803f58575bd52d3c1c4b11b82cc2438b624c89fd25de216e676f96a6d395801e5685c9a1095f67a867de8796d0074a26336d217e6fd84c3f78a95d84ebb1c2bb1b2efac1cf9a786be94b3d4cf254890e4a17fa130cd7617d6fd25956ba05bdc846a70774f0b4cf71a3729a6cfc9b0466c4216e9cc5d27992e4af54aa7ed892ba95c62a92d91b30249ed1ede781816a0f8dc3c72d782790c92a18effc8dc967f4f4d8dfeed54e543014e502abfe86df9faf06fa5a4b598230fa81642d2a55c37e6081f502d08b223aa9f0b35ffb6f5ba282b328553c3ec4f4360ef37440cca4f6505cb167fed46253bd2e680df60a6a686d0de772757a33e9ed2b449cf8c1ef6393d719a0b0022d76b8aaaa91e5d64c42034f465c56a2185cdf39c7feb157b331e5adc4838336b2ee876f7fc60f51e6bf48e20b551c0141ed7d38bf20d4c98cefca271056a5ef27f3050813ba4ceea43fb8ee57c6cddd4ff09f2c0e57a2114a01bd0054542aa8b511ba1444d5c13b46966962a156df4791fc608690e646abea6994feef66d693d7e5c8b82561b5941a961300225b6c58c2c420d02b33fb1827eb21e05c152d2780e9ada8c84e99443e87d24e596175d6bd41dd19955a3d995556b58c428494c203fca200205791aba7fff7b8df3df084e5691b57cb32fff009f4ad343a05039df2c912ad7aa29eadcc202ffe77e6f4d8b42f2b22be56082b545aa9abf7cc4882e4d71b9bf1d7b1dd7142b01aa3b965b189db541983f4ecd496be42d8f339294abc9d3c9ab52820c7979efe845ed653624659e0bdb644a90419d6bf70ef79125f6cb3b784cd08275ebd06840322d77660d6ceccbed29361aeee10314d74417ff99a06cf112012948eb24f9f72f7ac3fe921fe045c1a4817c8ed192e3dfd8af643858d0b49b375b119a59890c425e31da39fec653b51acd9e50bdca207cbfad92cd3a6f9e5bcdf677d5e56d4fc1198b201a02815ee17cb8288b66156fcbe121c42ea9700a030752e2e5058a83b95972224adc5ef229bf8a49a93faed57d996f15c611f4b13d90370232938b290b9f7640108358c761cce38eac1abfc60ebdc276d5d8f700eafa45b2326cb2f9217a197936def6205977720c6220c8639ab678d34d7b7f95682fcd80a492c046061e83f6c417e2d664cd8b6ef95aeff919abd05b1fb457d58f6ce288548a145f4776be46732288533f4d356404b803b802e74198b7d2fefc9276418bc7c9feedb00449470009ba091bdd96d0e058a345d751b933c3a78cf79fa1a38bc5472fb523479957c6189323232a7c402550ec559982c631e5b06b81aef76c995ee45b0c0af1f1d9c7e8c852250169c0fabbf1b558d6fc5e87062f2f2662f118ccd70d1f037b05ef7b90f499481675d6a11102f04a8f4f2f0aff0af699ff6e625c2dfea0b6d49d4bbff006c29445ab569c4fd3ef44ac575cee21dd47ca6b41598666a3a8ef5db2551be3d0053f7d41a0ef2c694893670c369b4690638af2dfbfc401abcdc3cc9e56b8f556d87b8ccf019c7c767f7d24c4e73a4ca5632ca40aff9b476e5f2fc82b3631a9f693bf3a8a936448d2656f0a0297179f13709254b8e83b693f81b32f52ea93e61c3fb1176b729ae5e158fea69a69b422cefb8e16edb710cb477b6ab242a369d75c569cfef4897979e7854a10aa65fe54a379c6d96c0cf593d53afd2a5b4babe09b0c1049c232ba52443020223fc93854a01d8e3a103f4c622592a3061a8248b49b49752b61e7f794c58570d14def6a5204de142cccf12ef6ccad431aee466a5b3326f0951d2a5ba2f33421281d9bb40d7713a320534cda94967eef3e262d4d90f653731a089eb485e1e9eeb418b7f287368b0e882827e3a336e5df6400f15de16f5f30b5de2372e381b29bd8c91c169596a93c4622413f3122abec0b820d150e88c6461dc30221f8ec72f178706c090f25df2b27e816f928c1e2a2080226cde11382a3d814ec6ac3ecff08e3963a38d03c92553e0d19050bd77e43bb1c010ee3945246398c5cc4719cc0a47a40ea35e5b2b69c6b65dd599bac784c69a56ac4958fccca2dc27ad63ae19ca1e977e42540ea7fbba47624eb0bb4ccacd70cf244075ee871ffe7d22e69cb4f553526cca9b7e876f98c822db4ec3cd444a3ed274a3421621876fcf8d2f12486fa2b20b482a95f58c1caed5faf7583451e904b3518848c342020b9e76c13774e5ba1f9c4fc9bd213028c3d47daaaab8fce7238f933b5ee00f29d8a84d77a5c26574db08f71c1a0af2def0b6d89d133f43b2f268877fe5e0f07db23c9b43ce8b846b6312cfb00f8c3bc2bfa7e0679b3314a5caa90a2d2525122bf0d481d600643b30c7d01f52db0d01ed8d3e4865659062955c2c6cdb771706a5d57bbe7edcf61d12ce20b189296ebd08f6acc23f4e5845e0f9f2df8822174c7ffc04116a7c30849ee5ec52622a53c037019db0b0140fec2ea39cfb2782d865c012f3267c8d763875fb744801be0f823b0d376630406d150c72e51be0222c5b405a88960b4a8b56d40f047e6685bafc1a995fa52c14b12e9a50aff786c27e1cf9ac4e855e4cf967af302e0e54078daf9001b260c91765cf880a871888157752df4de05b0c53188e4d7bfe1488db0a5c34d288dd9a020d9b961006645697f691ae237a0b05ed4ffb2e10d3581cf1d9631a434a61178304a87cc739cc7e26a09ab0878825e763794617d37b1037e76cd85e11a89e0c4519d6b7b61f67c55391714e3a0f399cf28b14af1bdac4b5833e1e982008e1673a28a9aa3426e77608bac97d92ee27864fe30efc0e745d8f8d8a6e0e8a9c0a8864f2ab938c28f20bb764fa7ba51788a643a0643b88fa3926de0ee882b7636f69f1f3f6b1504c26fa930ef84b1a9e9e0ede9ee327b4492fac30cf2a8938fe0033489c87b334aaec99de7ad4cad4baf1725d1987dfd3e030881320593b656be7b2a4644495708dc0cda6edb2929b16062f5e6f3e1bff3c1e9eb00ae811adea4bb18585a0396401551745605f5f204731478cf6baf1e6c1dcafa40c8f6de91fdb794b5ffa3c7556a1a4552d45beb8a5c2803d087a89f872274412dd15a7e5261ea1eae3febe6eedfa1344b58fe21439c4177a5efbc9c65fa4c88c5720cdb7a8336d140974ba1f28341c9337ac23596a36241770d37fcbd07aa265401c9f9231ddaf5bbe7570ee0450d16bc903e38cf63ebe104e2b619d41119a77f62ae01eb11a6374d9a09d3c88d07dd59576e3af9a8535383daed7fb37638cb006576377275e42419905673df82883836e399e797f571ba3d6924a8ec7a13e2c01bce4f7513686699d40119200a0aec26fbccc3bdafcfbb4f68401acda178ef8c767c3f63b5a49c0efd85580cd8bf7c7f6633b16427c613ed9c67ad4abcd09b787a80ebc62e1d7dda59e6aba120651bce45c724980597f4c836dedb2874c690dc99610838d7506f2a5299069306ad89b6d6183defc46225aa8a46108270269a1b9f98a8d0a28fe4b7ad0b078691735438ca0db8d825fc052d705f4a07d6357b058ec5648a5bbeaa0cbce6c4112b581bc0424b80f80212c0f0f5488cbf55031989fa23683f4c8b1d80a60043c6d99f446529855c88a287d97c1408648e4e696387f88fa48d2eaa338c9c626880526f21530e6e57e1ff489b41d4ea0d772d0f2cfafc5ce72088bbd94ae67a8e459e708519304e51eab69c27038cb5102cd0b50e1b10954a5519e78bdcd75c20fbb681891747f780a8bed3b77fe7cc5fd3e13f0817145a6a52915a3182c5c27161c4d4b8339ab9327529434e4ed6d339dd6d8bc799bd6576daa81b56c42405dd377a68d0618366fa36cfaa7103aa4ebf219f4f6728022803ab5ec764029a512edbb5e65fedd073ed489a7435f0a92d1b33f4194f74fa64af2788f38b2695c0e5b5e220ebe4f81d7261d299c6270888682bfadd97e67092a23aa3f3282c3cc7cd27acfdb8522c683dc9c455c497ba249c9419a4b761d242eb2c823583327fa940a4c857eef46ac8aa042f7ec6ce9320225e1dae58371aed6493d7e798c3cfc33fb57444f81b4af07a765a25c1ea3a946e85d625bc492e6ca4d3b38b45d56125d4aacdec5b5140e999874068424fa165036e6bdb5e1464d814dfdd201ba13aae9efe03159383259d447d534619ea97639bf8394802d20e17664a4521a04ae2dab53717550dc554a0bc268007265e1ea9190c184fbdb42c2c52db43ac9be167acf4f4cb79540268ea31cf694b673a3fd7ec097515e014fa5be2069b2925b43860853feaf80776fc9cb599ff842df7496d509a1e3d939d8495c03f951d2773833ec5d21e1d3cb4af661d846f8d9015dcdcbf51ca00d8ee2da670dd9f8d16c27d10214835dec0c55a2a0a316879495d8448dd6cf07daf20239f9b29f26716e4e23ccdcb712aa550ac4ef9653391927499ca9beccd26f99259cd63971ade8c509e530b89626fdeaba0453957ddf90db1944f374761f55ea2de1768459b3e576f3482a9cd01b956c39a74db11fc21768b007d00e7fb6e2217f1d4a0aa5c8308e04691c4fe8cf1998bc67515a6fd9e74524d16c88a69f3453e717c7eb0b9ffdf3a8aed6119c7a429ec242d7025dbfdf2812ad256f505063d798268c30903ce53a76a09f640d12b944b5473169a0aaf0ff30a37c954b7d4566f1be76882e8af13edcfe62c8b5befa3258c89a9f8f3a1e03555ff256c373e6831c965afc56f86916642b097bd99c6d5cbbe9647934405af7ebc912f9f6fe0a0c34c346f1c394dc21b30824d5c02313b450d034d429cc413cc80cb52486bf264fdd9877514f1cd3b6211353a9d82c8ba7473cf909b9e28d18dc887c3e8216651e1c49b576017af3260e0d25d2c95445be7a723e8843fde87046c18e84712d07799c967f5bc71c8bc141528184681cc9a399b3a08fe1c260247a932a3e1ba464058196f09ff1fd7f1f353d2b5e1a0a47055d52b8d8b80cb3863b976354c717d79733e8d1869bf79eb412c472895d489cbc1f23366a9fc43c7750dab4c30d08a72a1a60c20c3ae48f743e646756fe5a098be0c96a7ef9ec424e781794f032541091e798a4e1113871ef526f726e5dcccd09a87667aa02c46b6c633ee22c096023dd185ed9224b7062347bb07ff2c26405687dd65aad945a2227eab8c4d074c678f9f398f505d237f268a394f04224d9a46cc1802b236536cbe9248eeab125e5cc24bc016c3a2c49be33823d58ccb7394ba0dc9f285aafe7ad1c09e6339a9594dce7795e8b78d12087a2f11ad222f1455d5f7d03e74c89e5de28950e8a86322a66f1625b78fc641da4ec8b9b159e5088cd4c1215ff8f60cf6fe0a1ae302f206038f25f8ef14b9a29fb1dfd72d7750b1c9942c36fafb6348ddd568ad44d7f37dea8539745ed1c899d720e015a7fd3d6a07190e954b3e30a78305407e8e6ef476c0ed8ead35a3647b60270a4a151fc2c17fc85f3cd87aedfec041333e895274a05ba185be8eefef725b0852c7addcec17c8d58e87a16cf07b22529b755010475553203d91295d47185a2e148c85a808ae27bbbb28474abe76d9d526620bf6c575aa51db561041ea8a2ab2b5574b84a419dd33c5cbfc9bbb19d535064c75844f3d3881c1d975a231a8ab9457a367da7432f3e8b8df26376a8fcd39b26e27fd66b60693526c014046638b81b7dc8efd49e3f6d24cf01033818afb993e14146186655e8ed626cc9bc9a5b22438126c1c505ede25607531fafeb02495a4499bf2bb5eb17ff3ba72640e6f30ecdb260fdf24661aaa161cf088a0d00b87ed86f9881d117787a27250aed9b59ed8b545f506d316e38403e618bfb8adde8f764ae87cf2bc5a8caffbccca9ead011745866c8ac757adeefdb9ddbe78ea4de19c34adcfd384deca30386c25cc09d3e567b4821534f8d8716225f7c62e43ac52a7bf290e70238bafbb7c62dfb84933e8a82573205c6a000370195a840ed87432511fea1408ac037030f231690fa67b00ea2dbda78edf2c9aa0a95c78ae989da52f706820989c56fc46831c8686dce7605ac9b65159b39f2368fd812c09dae798b7ea7bd45c6ce18a5d887d5c1373e5808a3bbe28bd3e65672b61337b0aef09da85f9129b824816d1a6a5604f802c4feb7e4955addfdb2cf6789834b5d638377b6021a1f9bb80879f34de0e1f16f089e4e6e73bd6f76c78696b9645c2fabe93160892abc5f0557bbe41b38d6bbf3d8487c5ad0f2fdc8a784c54203aa1d816f2842c13f4403e734ed4cfc25b8a61a6fc256d57c329b844aa458ed264b1ff3d012209ceb603e701394fa76ccc7c9699684287b9026923f07380a9263963f7eee3406b9899576fea78450e9fa78753984e7f41d1b6d12142df6bd4df43ab570b3e4119cc3ab3c6fe38c4ef8dfc0178bd77a553b929a144cae5f9b23084648b14a7e141b9b65046a3e1012e2c26426ae3c12d7ee72d0f3746233e78800553d369ba898b1df3ca086334077548d25cd7e1e6c63018228547bf5c61150648a7d65c040c4f50deac427752fb330be82922c0df5d6d33fa4d87b60d774e4cceac7695e587f6d19c956ca237d43781cca161cff15f0ddd23bb2569b026eeeed9214663138505849bfbf33c9d24af38ee9cc11f197b752167c57f8904df0bf7f7ea4293d1dda4b52e25512e44413a5ace3c1f95bc8780ec768b2fde4a96c71b3d8ecece438a13246166bcbafefa6a55d6754d5f82d91d7ee885c40af04d4a2398657c0efcf5e2e8e901fdd7bda3765946e9d2cac315339ac39eaca519d80b0783a85e6b995fd21d9a41abb056a7ab6f671fe2c80962d8954015b0edbbc447cadf39a71155e4081ca1be5fb71069fb70c6db9bd4f8c9dc13c183c9c6d9c23646975374ae1de44e94fb8f6e4f08e0a569abeeff350fb4a7b84fda30c1ff031da126199c7c706a028f147539a12462658f3f4f2ab22a2d368922723e06cfcf65454f24c2a2f6d0bd82b4fb761bae66c64f52c4009eace53028e0df063ee6c66b8d6decbf7db662833b199fe3c8a2fef9f60be59de19e3923af6b638b2e5841ec044536cf895e493ebef57da5382b8d2fa0df94957b909107cdbecb904759b1ba0b76eb221b3e40dc51ae8c08fda6a3026100198961ad9a9f671ac13c0d466d852ed48eb5818e3f9ce204f5d6fe3a5cd521a0c7edfd0f3366bd8b0d46d01824cad25fce7e3b53731ad4defab5a8ff9a7c0d169cecff33563a39e2048380c37c56b8f3aac39c698732626766168664ed58517ea75f167ddb024d1a6eb9c94526edbb33dc83c40ffd7a45f5114d32460e79ed25ab65967476c398188107a72251d2836379df824cf7ebea11d2c25d0e46b34006fe8332be60d1f8fd7d94bd6e2f44136d41e39716ef0c91c3a4fa06c3d254440918d22f0d15164ca7d6df0f64d82975f3f4367b9a56b72fb63db1342c713a73d0ee461bf9463a01d2293beb91e77a3a9ef4a4a5450d32c71cdc381bebdc61c4330ee4ff99d46388ac2416ece6ee415037f188ca05806a3d53aca6d44f558b4a0ceba6c6c89ea2035383ea34d21dadaa1a7073e2d547e6ce23b653f6005807abc551c362517d4d7acb1a7565cf1f83f8c1f5197e5b7dc50f1c6215fb4c7b73316d93aceb345460cf3b5aaf4f9b7a6e1ac1e541f1479f1e07d45bb08eca1c72c70e23363026b885899e47f657818ec585d6b65d2798808843851bdacddd871f4f9ee64f3e5782aac40b93d992084dd75a4d83475a627064e03a7702bbde37ee6f201c296a2bd9d4bb15453e1ad0219f627a5522a66ab0a3ca6b67d3fad2d10188c7bd0e9c663e317c82bfa7b6e9500f91a6d4668483dc291f4118c877180596bac206149044f936878e5ceecd0fbd02992bebef4b1a923fd031667bf9d5ab960b459bd7e5b64c34cf313d539efd471d53b0ae7f6f6fb35bdcb7c386465543cd3fafdff7fc4be7c560acfb37984a8540290b87d423bf270aab32967d9e8d886df201a407137c51488845552e77c80055913b078ada7a5169b0d43a0263207da16acdaff3a385237a74a246f5937ae65840a2c944a7e1d8bcda7ed1d9bc38f55b746389b4c856b85f27186676050f5c7b530817425ca2e8ff38ebe879c6c74dee0e82411a0153ac7a1ce4526bbd8114e48b66f21e2d71f0953f8a20df489229ea0101af7f8638fc735fab3f0e4e6c10814be64c3fb55282f4c47e63b6a0450275dc18b59a1b4d100e1f6ed3b5c69518805b807240a50886b136bddd407c395b64b5cd47939f9bb7602cd996e34b82919ca817267d090b045bf38e3520128ccf6042a25ba34077f7442df772d27d0f61e76cbb6ef0d9ee67ecb4aa2bbc1f9779a08e7edcadb14125c22779ce56a6bf2d68228cf5f10364bd12d67e152fd55ba91ffc8c4bac650ca9d9a2d5e9fb90fa6b2ffc58e5ba4ef9784259cac2e7bd9caacd290728089f4f2705b78d3e8ad7335c7b81fc626faf7f52fa7c1a96c27b9005bc5a5edbffbf1c9fd8ecb2a2ee837f93b34dac824df40a77173848c074ec52c879efe2cf38c9132e0010324e9fbcebfa81dd2b77c2ed77bb7feac9b414c52b296356182b0778bc1ade237b34a2a58004886ad928bbb7020d21b316c6ba4214cb751edfbed8db465e56f57befa5d2176a6e76ba6ccbdf931b00b1279a489c443af230326da9946bee8fc684af3b0270a42ece94bd6fa933b688753c4f614fcbc93de2cc5af45dcc3fb566801235be0c5aae6c18cddf095d28e22d29e35507e38f702dd3192ca433c7cf74fa1bee84994c53e3097c5645cd2a34fb21b4bbc662daa3256c6f7b3c5d63807d77c0abecbcc2685c661c008d5ade56d44b2d4a3843a0f59ee6a5640d7d818d351a0f9eaa465a246a21d0802b1ea064cf3b27e5ecb3e8f605e0b1c058c1a17973e318b2ee7bae4ef6916bc49e53140dfac9e5515f1f29610a1f5b2640c72adfe2e599d78a34b4ad54512e94ea585153b780b83e82ba01ebb66ec988097b5eb3f4d8420863f9539fc2a9280397dd5ad444200ebb3494126a2a98f56f962d3251508bf523ab0a6fea2f4a87abe7832ed6ec8ca40cb8bb1e75ad56f733eecc9b03400c3ef55ded835f3d31ae31d1b5cebaf4ef69f6f8d45bcc3bfd8b4c60bc348bd7da771b71f898d1c13329238d8de2ea1c55a49596777636e77b42319b360d737241557437305d9b1f63f16132833d6b8b8d8a12a825692d52b6370708363f802cce03ee515d4dcfcd02c26a257485926620cd50bbd9d3d714f6d450d2d8fc01c91d15c7eeca1d3f6658d197938d487ca778bab9f9f5f981936ff6e3285eee1105b750f0949a955bb80ca9f78f6287f8637f352fb3534341de3227a24102a7218a3df55c7e584c39f5d84d7468b28c3279d2f4346a6c3f0189554ca79dfbe43d021a1050e6106bdef79def271c366a324cfbf967399313af3cc9969620ce66af446aed4ba370a6682c1a23a49e15f642fbea054bc779e1e7b86e7b10dc8fe4edf97cafbaba919cdf58cd67712a48b053e16f9aaf2d6b52840371810701dfb3184437376da20389d93c6318c2df731cb8ddbe2a16887b6f3cee1fc459a215522c152c9a4eed46cd0c2538589b3e1f0beac514fdd1894661708dcc75d5bd4eb125bb78e87a634383f7fc9a6ddbd0700348766f1899cc4ccc41ed7498f7b6d660d37f03d190dd60fc898fd818ee4d98821ec813638ad80955100ee51c7180f14da555e9da2a5c2f593227e07296725c9991c82856f9bc0037d0ac03f54027bd8328bfe5361e195a77ae121535e6defe45217b15bf1578bcaae0f38214a4471d61c79f8823367e0d398658461b707ff2a63f73357189be794ccbe2ea5169193c6c719ea376bd66ae7be4bd5a94e3f9fb2d710a94c8ca399b1311b2e71ffeb8abed800050f7f366ad9738cc70e7ab1f6b9ae8b256b6f78f2fe3bf06e76e16327ac612b0a7f9d5ee0f051db62859c50eea02ba58c8d7494cbd208d77a63c3b02275876c85e7a04b4266774acd5baf110ae4198b8b7cc8dd408fad44d462c1965cc06ead5fecea9992385d94f374ccfbd9f7932cfb9fc93d6318206de8eb4f354e1f94d9d395abd74a0b5dd5dee70cf89e6aae65f2081355bca7d21f70df48eb15c61a89e6b945f77b1f9faf6431e3d081731a9bb3bcaa185c109a4ecba6cab0b488d11913b055e44efa3e5ea2af9d0d7ece7332755cec19fedcd20be7b10234535fcd4e87b296e2720e346a07b2201d63df47b2ca127104","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
