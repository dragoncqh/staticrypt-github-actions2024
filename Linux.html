<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a917dc0eb6752d9fdc0d93bc90fb4c5b52b12f3010447912f2c439bd2d87843b7ef35c93bc0195bbe03961569738acfb7e9cf53f88cc099f784868da5158b00cef3a08417e273af5444ddeab37634d06690e4dcd82f28e59f0ec1956650e7dab389578c3bdf5eb52a33c4a4b90fe8e04091436a57dc5b124aa09d531f9e764cdc134e15ddfa954b183840c748e244f1e51fb6e00f320e43cb63b1d604a636c41b1169a6863bc253991e7ca40a9029f17f8dd6074913bf10c62da1e6b90ddeeedd88ff24bd0b6b57c654fe57ca25f170ae67e9cf55142192852676b2ecf411414f445339ad8b027e1de993acac11f43a57c7bcca0c63823f95dab7568ee8bb9fba79dde00d4520f668439f5f5ddae6894e49a6d46a9311b085b4930c5ed835003e935bd744062a112cb20990434b7f0b9ed72163bd673bdf08ba75ea0fd39d6345e98b5dbbfa49dc35f4e8ce559c22f9702a43dff4c872fa9c1d361606e25455d1d46b34f8de1520963ef7679ccfd033d31738102fe719a41c2bd7c2be486000b57e933f1a4891a40c36305ae635fe3334b3020557af40d4825b404e413a7b343cdeb0c422085ccbc33567f78a7a31d75b158e6a496075f233d5437ac3f15d1d5b4991b82f8f812daab4ea0b028ab4799e61d3ec1a7352cac211fdf24a94f70239a18d634267b0f74f7338976a6ee4efdd80237325e02500a607305cfd07ac60e1ea2927049ed2c53c2449f6bb75f60f2e2835f63ffa5e960cc0b1efa19a16613d7023b34baaa9e5064cb1b03bf55d6214457ff5126fb93b63f365c5f0772c87ac587f184d7384567bab4a1b54f27ea9cc098f664f54d417ae8f9e11992c854aa00e5d65a01f5dbe0713e804db74fcbe88462ac745656a8b3e17b8b4bd14f33fc961398f35b43f311e2cffee4ef72f5cb3d82202247cd00abf4686afb9e3987abae2b91c3483e63770d55241558624d44559df20c89cf8aeae727afa80ee9ec69a6a38bcf3159f1492ae37d9052c3246cd28f3b6749a74745a44266204acc63ac254d30dd7aef5e5f26ce685622ed2f88dc9a6f3405a9c9e8d7fcb39980fd3ced602fc259ac576abe1565f65c6d1ce161288eb9929818d82a273c7fd5ee32b09893d63f385cbac3c1b6d48092ca7492633062eeb86715e12a45c4562e95bd2a499632ff20483d8ff1d40e5ace80bd9b1a26abc6501e5ac3c9018604cccf541942d5062ddb234f2c6b8cda6efb948bc6684a7d580d0549588290e1cf6018ac5bf4db2230476ede41439303fea12e9c7d67dfcd15b9d453517faa3d05fd9f431d970fcbe006dc530d098eea5cc2b20e82d53037df503f8f1d33027243cc28c2e0633afb3289adb7f19e21d99a995ce9e73c30a263f32b49fd855bb2c02bce0c87ba975a4a4cfab484153d6a6312fd527263a84704860818212c773f35db8af813c2742a4cdb594020b6a51726d80d3a11851cc281c730b7d488464625dff6a7dcf138cf1240e0df35b95dab46bf61e59e0f0d6467f13348f12fe16d7f4e25fdb43fdd27882b180eae9b6954d32655111017a643147cd503b23987f0502c7e46f8467e56b2135ccea6297b8f0d8be14519ec44e152d81b41917a1c297b51fbb7f305e7b093f5b114d1e792f02485d1cfdae5b8d47fd686170f959ca757cfa459ade24d794232b388f499d99e27ed0d556cf176571a8e460a312b2efbf1deab0007ce68b9d33faf687d07a9af3956043eb65505fd97c25c4192d4a450453b49227335ad4a83f60944c99a43cdb5a92ec2d90b8068ec5afee61e8d43d72584956739f4a3c9d85a762e96f67e41dee7cf43163d2c0aa64d6c775fc468c4a87ef777d0ed81a45e320e9095640d335fad2ba5e5172537342e72c28359599be739f53a9bb358928c9786c0ea66cd80a8096e39c078942c0daf24ea206acd4ae8a9ccb5decb10b12544be726f7803e0f4c8d0a307b57fb9e022824d9eb4f602a4618315ec3c96a5779a57f626c697fe4ae176ada9ee70c7cb83d2dc696a935c8ebce6fdd7bb92b8f561864a4e83e5be3c4ed41a666b0ed524d3443fee184f9af6070d68af6acff86cfa5d0bb074316d93bb6a05a7cf2031db2418597404bbb255469e8809d8acf4eb2f946a02d1b6412b021f91f5619b90efd442c2e1646b20874cf0435c3d9259391517ad51cad8bf6352bf683f31196e3a1c24996a6d00db57c6cd50ee787c224ea08dd4fc33a297ab2e85f612b6108803b89fccb92ccc241c3dde6586a9602abcf9d31afee9a93188f19a9fba8e4056555cb6dbd0445c2c2e99b66c5c938879230ced8129e958216456649a5e1b58ba6248c95ffdf947a090933249974925a92ef11cfeb8c730a210c232514e6b75b82ad4f447284b62653ab5c84b6febd2aaddfb3253275f731aa8f32955c54d55d556c927f74966362b4b14d8b2d0d5a474eeb1b18bc45f3ce57dffcfee7af692c6dc205c35f705c7e2c85405e05449f7bb86e225287493938d169b3dfa03b7613d6fe0cf7f4931aeebe82b4c2b68372f67a97af6c2a0f66fddbcb7cccef64a7a386498b1aadbcc45734d5b38a301ab5051ccd896249b58aaa9b34541e8a522f2fe3237e3f0de5f047f8db123688d333e92a08c0d8561ef61da62f9105f6c1c07bd756dc576f3ce3b7681fda44ba8423ec7371c89e6b044b604442ea906f30c834d4fe4ad6645e2237b7116876e50d19e32f2f9b4da4579b1e354eddd373253b5b32046df556eab3afa93cd86048caf3e09b475b0e4cf5d8313edea8d0aeff1d5d07df3180afb34c986b84cb84f4fc373b5369bdd29c83cabc7927c0325d2019e053b1699c00553213dd717ca511afb032c8429069fb8c5a35e9278e38a52fb6263fd26e1534a3d2702551daf54aa500331d6e655e05f518ae809de62e6481ae47bb81c242ba427934177b5e90160133b6e175fd3b91cce325d1dcd9be42619b9f70108b719d260ce86fcf9621c2e3bb0919387fc32b5cabf67e1cd3010577799dc2caafb22a497193056e09164f6b76f4b57812ca78245592de57605416203ac16c909e4ecd38d1575a5310cfa39bb5331465a8140e74f681dce651e1287c159239dc2cc8a2882bdf80b360168381329150753165078a56007b53a89745d05fc6675ab1ea6a07dae29b102daee0929fff577b01d28f1260034cb1fedbd7f55f9ef6f303d492e719dc69dd48a8313ed1062a3d76bffa836f1b2f50b2fc34b498ea1f260a5e67667b301e860dd9fa271ce1baceae437963ce0a1685098a0cec06eb6937f719d9e3d99f83a2debc0b4029d341b85cf111913f8ce65c02516b5ab7e4b3b5052b386ad225f80dacdad9929981628667a98d5b3f26d00dddaf77e8eb57275472c72c448ab9b8dccd957975ae06035b195554a13a8e43f8f9994c254838cd1ea18c18ae9630238c163e77a423539c2dcadf7f9534372c92f01be8014c540758848c345db038a980d22b2c4ef2ed724032217a35638a42bf2267279884f0df777f372d5921a23dcbbf2b7eaa01a33bafeb3bb9e2c3f404b5bd08ec84c601fbd28f90d86000acb83b1b4b96f99349e529771720ac81ae76f86ec41d323a2f6bc4e99a2866e0acee88fc93c4f535545845d65c0a6a57d7c72198a0181a28f4e03c98a60e32b9a8a8ee3977b6a33b56148e00b18c177022b90975dd4e3033cc601254f7bab67a4bca5cc01255a276a9a0729525f37e17d95e3f01bed8307892458694372641d19ebca084e03facc92c3ea6ad69342e9202b4132077e06815b2931c918fd08c82f40ae0be6a46a8abbc9b694e0a2ba7f82416cf98653db6c2bb3c356bac1b203e3befb9e1ee867ac113ec3a66b7fb18b13d7ab8c1b640eef79caab23c064a624d70ab0ee5e5029a102c5ea1cff3600da71f62b8bf800557af039a72ffa2215422e929bd3cc94ab05547b758709684acd5b1c1fed748716b4813b47cba1e48f1307ab4070ec31a9c268efbf63b1dcc1c5a93a2633dbf1cca621e6142d69782aeb349e8976a4a6e94a84321d90a403cf55ff688682ba20395ef8b4bcd085e8a2c891808c3f3602e14e0b4d108f47e9d72df1c4e5bd0d7aaec3e18ff8a9fecf72cabee9702d18a116a9cbdef9eb1e2bd2c7bbd3680c5b272a1b3504d1315a3da8ca6dc220e47dad6204ba543d175cd7197aebdd409adcd73dc0e681392a5fec9b848ead2ef282321ef7c03dfeac7c7c2ff2403089f704a6fffc6ea37950fb3cf6981e0e89416e93e1751205f460012ca57bc57a3c12cd4202187bfa7ed31ecd750d52f29112ad7535601cf0bea41ff23d90caba13329db90ae38f7e7e83187254c8e3983863a821f57037aa7c422bde4f2aa480d7f64f3360ca0b33155376445cd82ad10fada0f1b5969a36f113076719fd635ec8610b7c1a12a02fc14fc3f9ffaa9a15af4d7195f963d4590eafc999366ba7b1eaf521aca45c07c4ae7ef333e8ca78b9a14259464731a090eca04a1b2208a62f90ed97ab8f59a7da4b0e851026bc6a2de91226bce75b393f7a678ce0613132bd7e806f0f6d48640323d60418a7330b58ffa2d7dab58693bc50e7023eb658ba0abd1b3e03d0b0ed754ca104c88b4af4bc1a2f3be3de63a604d6edf5486a9e5d2cc2cac283d0b4db02d11b1f83d6e19108883c98ec9297b86ddf7a77c52702d53f52c64afef6fe736888047c82a2d77c17632f19d85200286fb34b8e95d82f08988eee27f4ab388a2b9bc6de6f4441fa5f050efa91cbf3b0b727ca1d07f1e9999eaf0d54d004c5dcfd61de6e6e509ec55ac4aa745cd430c7eb09cab5d1cc7a339974ce85a644f4e1daadc07c2dd19eee124c155aeab32893ed66187df187158b727d2beb7dfb0d1e0590f0dbda299a8adc87fca0137d959137e9297bfaef7c7e53efa117b896f00cb2e2446e72886c9d1f06ff932c1c0ee5107d6e55df1e1a43293575d40e95a4615a3e85d23b1c8dc1f357693b5248890e28b830555d1ce2c447c7b59a4d5fb3d7b925a0149d4d97caedf9efa161beb72e5bab6259878e991d3019d9c1e3948da7531e2a10272fc0f191fce3f307e31ddecf5f4f5d99e2d8aceeb874653125b60600448bb020bf3cd5eac1d9f78384d222ccbf9f78e768b0a5d90407eb9fcd78aa409a58c8b5965bda6cd6cecd1057f256f30fe9110bb926fd8015d560c6efb19648d13b49cdadb3cd06fa0e24b690a4d4d88a820ea5577a94fcddfa24d4ec82628e031c62a2c31716781f5b735c7ffa208c6dd4c06669ec52390a7868bf12625248306beae10de3c30c9eebb2e80676447118b25d3baf5cd7a239302ceec91509ab36645686dda96fa33f1e2bb835ed6adf73e2cb65d1d736927ebbcb8fe313fd0d137750b1513336d7c8dd81e3026f962deed55fd5798466c4af02294c462ada759861c42231f298ab51686b169d950f9a23e4825ce5f12cd75d58e8ec0d9d15d6ebf94bf88a2754e8de2a35fdb28be12c3ef10d0307a1215b148a2c4bba8f618e3694a341dd08d348769971c2d4d1693a784ea83984db4d57d2bedc8e7811481ae9a69bc612c3af3519b3765874ffec4628d2a8b6bd22ef5596b48ec33690eacd175cf5e4684a1388ebcfbef81dddc5b74082dc1478bc8ef8ddc117e12e8ff916222de02957fdebe4bbfc57dc8f6345951a2a1b14ffd17b539250c86c56840bb8e17dc95f29345faa4ce919b2e900bb74384ed3c58139f59e3bfa26f7d3ac3849c0c07d7b59415d171545e0cbc24e1816a342a288d753bed1d7bcac194ba186c7791c66a7cbe245310207e6a7007edc19ab57b4ff844820c68dd7f7832f1ca3de06ef639e8b0129cc2f5d7e96870ab5fc2e76ad2a9c1835f65895bafd63817af622f2430b21255624841dcb5c26e1c7eda23e56420ba8c9a44a1fd37f9c6909a511f3d14f3ba1fba09120591406df423fdd9005468eaae14faff1b6c7f2a42fe14e976ff268e728930b28a2131a4a597066033bb9167ecc9734d69df6a6e8e856264e2742c54fa86d2a34d34d1affdfa8cc713acee9864995629094391429b98603def7c9c31960d039c8340d3e75071784aaa869b91fc0dca53ed96b0e2d4a43d3fad71cd9f6cf9e862fb335af99d4259a7dcd724a4edf196d931e45a6ece08e7ab3d872d1b490b41675c8f3221bd66031b025893dd1317e250919d08f216f175f3633285fbd2326832e373242c3298fa002bb557b346f4ed5b22d7399ad1cdbca10ac0302e55f890074c05e299934e202397ebf9a17fd2799409da7f3dc5119b939a5d613384def05a08797d5c0ea53cd170b2b13eb87f92d31c8217fe31d51ecb69524a4179f036ebbd3ae5cb909588a379bba1e1d9b6c7e16547f194fac248c7f53d11f65a0a542553c5d27dba1810ba6ef64a0a4391af1c7897cb9ed039ca7da7f27a52837027f7667ab9140610ac4a97193cf23103df096033b1e64aeee0b5117695b1762373366ab137e77fe1332f4d49cece795069850d4f8df1a159281beacf5864599d1a2849e7e23660335e6ae99e05a95b4dc7b337d34e391860bc0d0339c13058dd54f76aff6d0b19dd02a2172a6528f386a1486e53b8c23d1cf2f444d0564a82d66421957df97aeceaf6bce5099a7e28b447db776b74d8203b1ff82c76dfe18070327e6d631ba62b02e6d74409db3f3ed9361bbc191a3f7c31ff7f1a971506e9d0fb9e8acfa7193e4ad81876eaeef983309ffd5e0ff870e70c2533f68c935079f4ca27ead5853588aa5f90b1331c84857af9e3ea50c7df3e6321bdda9a9599c673e69b2510948491ff104f7c9783b1084577c8e6e67e2496c3155e4d7fb86e3a057ea38dc085af48ac9f5b552619e5c144d4a4d6c54ceb04d11b717a15fa9e70da4601e07f690a53a676b7f705eb673ec347f62f8efe99cc63469886acdc270ce474421a261258d480d3627ce1f4c2da69462cdeb6534c9ac0f63f49a7cdaa5307133ea577456127f68fc10454a472aebaf3c8e1229f90715f6998a954bb11a90b4d013bbbebb8798b92d291f9164507d8e268b871d07a79b94e93115f8c17bc0c00dccf6229516274125cb5751610f7172c9d33d13b7baadbc38d3a4810f7239d9ffe6c8a814d98de7b34678a1deb931fd32c94ce6aafad3525896ec7ddf8f9a395dc70e91c0fd1e161aa2d7a4a1594b749cba8071d477dfbacd32c795a9a7800a1dfec06235af52d03a8258d8c8470f1961aa0d124e21ce4c4546b7e7f55248aa5c5c66ded90bccaa22f62cfaf16201b65c31975b23b4a0ccdc8d1da453da9d4b22a53b3f25e9f73ef92c67e7cfe1971c7d2d8b86b0385f26399e7669fb732cb5a2362b09890f9682b37efd84b94431ce3abb873857f6442cc7a9c101e4519157df46a29bdebbb7cc8add276fbb17e1991d5ce4b3e0a054076f1a26f59d0017d47da50ae5d08b93251b205270c825ab84aa6aac1ba33e07af8582502a5fc58b4b22700ef64989a082b3f8761ab75e70a604d86e829d75cbbc2d61a368333c6ab1e6826d80adafebaaaf149c67674b778618c322293ac6524ef9464b583a03aa7a26e273640cb20f9a2a39fbc58dfa21cc89ca2417705023e8307b5cf15c92ac165664ade3fcccd7d2892f9305fa11222ea1240202e63e25f94c4d463a5657d02945ecd000a74986430c373c982b8004435c9402226e480da2064c8a5e05d51274886a5d9a7aa938ae0b59501bd7e2ab5727be45858f1a64003d314d15e72df1a170bfef50aa15103404cd3a6651978d90ca24ad39515926b03373da7378dbd250f49fc6e5df3781138430a09d052665b7bba91676e1e47fd8e33b6e04411af742d95c7e7c3d2658696b613774660c453f829981c9ac3185b3443611a5ce096d1565108877bbe41ff4b8271a24d9deaa9cd77cb80766adf2ab249ae3dbdb9104bcb21e8dd730c33df9921ee4bbd7d36a48d30a085ed65eddc60cdce1aa602749f44a60bf41f3347bc1297b99a0c64508871ddcb6d8e7d307d5b95969a526631019244295a79d22c933d7e8d1da59d26601b88e8f169e9378ba4732f139b62b0237dcc1baa93101851c560102b36a8f2b726b006da9842a5275dfccb3ee23b2d937c226ea8af930db795ef617f8c51b2bdb024b2210099412fca16174691aa9f7a1405c37d05153696d78de8fd95dd20cc9817c6bc5ea909162e88410fde51ebbc103078b07457f83240ea175d412fcd2235e40955aa8c2226e6a200abd7e343deeea5eff12eaa0a9c8a19bf77a68d7b620475b7add7f802d6c55892d37d58369301b21c3181ea57f77df725100ec9b6785b347a60db43dd36a4753ee61e2459f2208dee491e45fce85bdcc45b6685ab8cf51b1da671339e203b5b3699ea4b0779b6ae9dd2990d31f882b3267a53db3f692d3d1553358ca1f00bc56dec3dbc4724d4c25899be0e91735847341e51d22a709be93c430cfaad21ffb0f43eaa6d5cd4bf91eea4b1ccdf91a437631aa6c4ffea7bcba77618ad8a54b1ddf0b47b47922487181b151b2b7c8ec2755c1e75a64df27efcaef2a1d232347a9e885cc37ce51abe24286072c1ca96d5254cf6175e1c7f68c195d78cff05d83cf024dfb92bb3d053db7a62d404f4e63ebefdb9362e5aaf0ef3b934736e2a3418e227704a54c8c38b1957c217f41b9c4c2b729f5c61230b7786d1cff0e12be1915c26101f09bfdd0fe59486620c6534ebf7271e3bb036d6a80f079edfd759190d6f90db4374fd09b64975c5cc2268387ea36302a10d5666c1633e61e331d5ba967f0a951308a05043f73cdf2ee2643224f88b9ae2272778fe4fda48959b6176ba4566515ddd2c47f9d10c730d559b05c629a78058baea0342c100e24fb8cf269bd588f211803ada61a18d1752910c90921e4fc9bccc8b17cea314cf55d866b78b5c60bf1201167b1f3c85cbc11dcfd6da10a06640b7025891897ba3d3dfe3f62b0af492edb8c818e6c6265f2962636c1df058b77cf59fe31e6eab5969b3e8506fa28f1c5f8fca16922cbb2f0dc6b937abdab4106200262c184944a631c00e03e7cc00650ab010097fad010ac2ff5db3266c8cc3b833c537b0e28cf044fc9fa951e877c2591236d6458b146f63a97c7e41e74e00f51d091d67debe099248fa56eaa05310c266b9019279a11729509505fdb270e0c16f678fcddb303e3833385a499ee1280ba32f96510799e760f8e6e5f269fb58bf05bb9d8c090f816c2e4ff77b8737bfa7c9934f5539082eda9cd187bd9dfeafda620d51377ff600d0be359899db4a1e4373feafb277c08635df54638dc25ddd060a43e60761d2f461ecbff090767943e26e0e91cefb5bd2455a2b9be1117db1510b43e5e6d062cd00df0801ce2f0f836a0f12196218ee142a37be824be1cd035d9d5a74483640fcb304de6dc56e137ebd32d97cf656d97711c73c8f4b15e4fc6b1b170739b0f3e2e3df6fba7b362f89492b4e3e14cfb14f1a52194bc2e069850e9269f9307835d032d4a0eb4c6562da5f1374d076bc4e3b7a00d61973239986eb8f3fd1ca4e14561a56226d52be800e3d8fb848f3d2af3ced2211626bab5cfe9e30216adfb3f2343b00256cc10d4bfdbcac00d0e117ba1c0713a7043c5606e0f4ee04518018565e86ad4981c664746e63bbc6069d6263808cb5dd05e3518ade642c8a1951a6dab42e3f9ab86b01acd9b31c4d381ac35479cf2e2fdfa84bafca2d819466c4433ce040dc4321cb22bd99b1e4dfbb39ba15115611574a4d48a714c0f1b7f2614eab7004c1963edaaf44e28caafbdbc230e6037c323631c9bd4190363fde79bb51f314ff68d4dd1f3e115525f25d81ec0fcc592755d503dfb3911e380c5dc62ae2061002fd96c7484a1836c93c0978896dc814fffd25e1aad87400b61e18b1ee76c0ff4325416474c756637a1068c58448ef2035fa0c6ba74f531b23f47331c23abdf1c0dc7ac91093acc4c222c3e5af8ef1b5020273df2f11f8ca33db3ad06d0caf1396729e887f8e16653c491c6516acf03ea30e8409988ad90450cafc69f8c83cf8d35dc309d35ebb3e47958c2d11dcd7df7d2926a61b103294d6dfd9fc77474b253bcd31ee7d8e9bb750fd50593ae242fff2cde2883a850ad5775376adc66b9a282e2305c77463de4b17e8e0ae7b523e83c92089ea61a519a2aa4f8f5262d7e5cae3e383796dcf6dc9b5df12d2c22c69d0a840bd52ef59fd8c96d44d40d32d3fba0f7b427a6bbfe7ac721924dad74d2a88992ddafedd7e4b9fcd5278e0ee1fce1fcf24f7f5a8652b6019867101f2bc80559d4f4b2ca6cb03d36e70a86e4f96543782c6748feb66c5a5db6f65c6802b28bdefb279a6705eba96ebdab15716ce908ad197110b11ca48f7e5e9ade2a19afc4e515d471553122f3345faa1f4267e9434993f10fea7c2cb9f4217bc227ed13adcc649eb160a15553fb0ee6c61914bcd40fbb2faf4e6647839cb116046ad961e21488ccb15753953735f1621c2e0daaf127e1685c2d4f9f59fd237aeb1165972b11870fc443990f07e21e34a5da356ff02a53ba64f58e6d273fe4775e97349d4d9f3e8a0ebf428e4148c37821173e5ddb1c98d7e750fe19c21f13dd0c662a13dcb25e0b9758b150387ff7f2cdca6776c87c16bd243b9d34d3b7d439fbb69dc3dbef984feda3f565e27ff17fe8437a1eff946cfb68520272d61fc771218adaf840ca853dd612b4c3c73451bf6e8c95edf4cefeb5da52c52ad38f769a11308a4ffb6e22c4a5d2d53e30262cf3d7884be9bb03109b7f42467e335f7fb3233747fc0e2d5773a3fd42dbcda6de0de08c8fa76d8e25d669cee41019428bb2f62de995d7a980b2446da47515ff3ea4ff742de83655b6493755c13006ec4fb9f551a7cb5693854284443b525842bfbe8c08ca884af06101b2042464cef9f7a75ababd03edfafe81dcf587a86f038e9087067f18b27df2fca86108d1cfff6f8629c0ac1359cd1c7353e8065f0e0a84a26497826d80c670df79a07ac1de2b28e133162c1e0b943a9531f497376908e2a8051d363d82e1e555c992a6a1edf63147f2482c0aab43f0c56360ace2594e5b614da0e1fa54383b344abae195f1e618cbc479fb5d7aed8bd0db30b805b2efe563cb3c85d70e63da8b67d8ed0dd065a0fa2882ebb8f1e8b5c9a09d34ec0185ff99d9ed90266836ef8587be3736dee1ded9228b856964e3b86c5a0e0c7bfbc77b1df2bfdea58d430ab75ed971a4bea24b9641c943dab7d592e8f4ea12fe7763edaec4674be91df0614e2e2b364a45d8bd53ceaa9deb8ebb11af799dbe3d21cbbc8126e43eaa26d05d8c518a14a44af3919b9688294df251c3525852ff8d88afe426ec1c2e46255ebc2a958b8fc17f6fc5a593bdef1d5c2f18240f4a79ee850278e6432127cdee90e31ce3f9d72d4ceca74e3e6ecb4bc7cde04958439df213a751841ee4f2480616643f95a6c6c73a24e28fb9ee207c0297339eababd7c629cfd3a292be86a784d471e207357158a718ad089a17c664375a8cfdba657f6226c62e7bcee2fbe3055fe95163fd7fdcf4fd6f2462567f48abf7fd0b6ce438e27cad50b0a40b9474690f355f948811fc12738924981a1bbce65d77ac22ba90b6771480f7e18660752e4aeb350734f1ab5df6da9807ae8cba49c5e2150e3e31554e854e9b21ef80450a19883054fff7d09afa8f7f6b786e3a16da1f60f4a26e8e8e55e3952c4924bb466fa1eca0c03c0d1aec32b312d6f2b090480fda348b70fa2efddf44653758bdb18c45c9af3b088db0b5eca0e23d17005451b4754cd467dfa7ac6debeb59766472b7cadc9736b3451502772cbbd3e01e4430e055342b9809259daa7af0152f743a82952716e88c853350b4ba68ec17a469dc700e2b9c1afae66c2217573cd8e416bb3a6710d5fe0b1d349add0a3fb3a5e1727601b526861cb063eb6d6dc7ca3364f49aa3b9067dbd7637a6d71c08f2f38d7431d7c1d872c3063b16fff8132f951438c8a8e041e03f3021898fa15ac40327b4364e64acc24a5b350759bc4839372bb066a79924e2d0361f2bdbda7d669c590b2bafbd25f26d4c4adb6e2aecd7f05c1261422bda66560e41df4fb4ac873ec13d613e45d8346f6d311db5427c77663529116d3183b7e3c9049c5734ea6e343cc32a8fd5d917dfc7c0463021c507e72df18b1e105ef44e6abc0d0c03ec567c17028246b7f6d1682105a162ae564dc24a739d286e5a603abb839c0c0f45cd5b6ec3cb2a2f9d68a44c5612ceb68c579e4369df2034bf7808c3fbc813ba873a2a11931052d1dbaac70bbc6f6d3a619dab75ab52809e285df2d1992b46bfde9bb0393346a1f25f09ec508e07cd9bfc22d367d8aa688a166e6515a2208928ba41070d3eab1f724022d7fb785621b7bca9d699b2450c3254fd69a4509b9f8ba423931499bb4d1060241f1c57b68a1a33a4c2dc067747fbd55578410317d4857e018c4a3460ca86d8adf8089a58fcb23b0c4a543a38dd538daf139ee93bd3f9e2d7d1bdbbaee9c25b2640e1801bba9aec5c1ccbe46c15ce4260e103a041cb762a5aeb9e9c0ceafe2612cff06b7932bb6d2f4b4a33b4dca96e31292bca20fc5a3777233ce6cfc8bebc0505cc8b347f58598b0214b03240d1bea7e9fd1e8bea60c60b7fb9df49d973136134e0f92bee2acb9d099e52c47b58bfa6d333de4a3c987caa25461b1d412b77852fee49dc7c78c5841210d1afa4c0a4734d259148bec50a14b5521c11fdfb17600055fe27869d729f7d080d961510f11c32c78d57c5e23989bf4101502b118d83788f2f66062f618d2e787d425a6c079e0f9ee6022e1c917ac5a985682a25a4a217f8f6649528dc9c9ccd7d22b700c64eb680a7fe2dd3af6c1eec10e6643494772fa416149ea76d6499bcc0f0d0d48fe8cf88b915b95ee8f486add7a9169d3920c265b24992d7a7ab7bc99fecdc8ada5ad72c9d14e647f29681571f6e030ff08ecd0ece12e8879f309aef7eb6f1e7a989c1a8945e67bc40bce7ac7f10ad6163a6968b3596ef5f6c9dcbb70ab7e29f6a8b0f4429c88c3f92331fc267216e3ce93ee00b2ddd22aa7c48dcc98abfb84d6bd274ebb414a0ee2fd66d226d95b66ecd96422d603a38ed720791c7eb58cf4fc86ee2191a6129dfc4ec05dc39b3dee5c190fe6d4453ac50fe8d3f7d8d65b20449e0d1d4cb149b1440f6d27130ca95c0e01bfe1c6f26d7b9ad1a8e3acd47a3bcb7cdc0bb0d6c18f977d5cbc6877930caf9141a68fb95aaae1bc998eb83f1c59047224709fa8b02ba76b6611a17ad6f26f86e0ea64a3fbef76a668dc0307476641e8b5e2ea8317eed337a6d721d2e9fc47db39ceef7854d382b95a33722477a717068b6c5a691a9234c8acd4111ca96554ad220ac8612ff5cf9b9a1c7db0d366294ef8411361413ff0c4d226ec6567ee82fccab8bf7eea00ff003dc2b02ec116ee6e103c197aa0be69f29de9daee2699b45b87ea3228fc4efcef4465300cfe05f546fd1df9677b8ae32e3659c69fa66360c95560bbb8d3049941d738fcc6677289c5eea0730c0af302a7fb0377e106d6722e41d48c6f22a40115d4e654e2c1301a1aa8871c11e96ff593322382842993bd48967edbda8e6648ed88c77a428c307b65964d0dff288b49f5364f41f53eded56be598585e36c5b4f123b869909dea0c2e23e8057d5504bf74c6407aa53b2c4cee5c075572a666051e97029fc3c0474482a26a1e6b71054ff35dc12c9a2bcd7a0b39131bd22e1c70c858d068f7d5d86e0e60bf3b676159e28c66618a4da8ad492a47e51ec4185a297231cd2b806ee1e24c26f81b2be55f798f611d3e781c505420574c8d4ee4030f58a60e747c0839c0d4d829117d9b986eeb8e68ae7907d77c2c80559019ffa617e93e638df8fe3cda46a5e9f1fbe87bebcc4323e75a6b15bc319f441c76bf1fd068c1391422212afdf1f72d3689b7b1843bbebbc6365b9b8d5da2732132c54ccf2be8dd49a8a373dce8b02e52d196737162e47964e2d09031f1fc30ddcda07854b1c987e97f8aa367112c2e7d75abb6395851c5181889392a0d620181c008dd9e28f677cdc5179325dff30116743d93cc7b2c37fc5b140811d1420f711a476b3857e4ad7a83f83e7a41d2081a27f13dd3577521cdd923342d3af1568af69b881e75d4c92e7670e3b31fd2f21191ef6d986fcbcaa33d7af0bafc516b87c03bd8bd6fb36258e340edcc99e20cd84a347342a4fef380ef0875507eae4d8995ca727e454cdc5cf643733addc619932e9d97ef5493fd67321eaeaa5b4c905c0a0bc61df4c63b4c16c0e07121a98da585bde393c6424cb5bd3545ac7bf6dd1524d08d40f3f021953a9e2e83fe5d0a3112eed50f615fec32f99887ec62bf8eec7ee2850a7dd1c37b24346797b6ac72bf2d07ab34d2f3d8c3159eff9074f5d36e3df5f1cc120394f097d68c72f80bf2d0d453f4b1088f2cde61ecb6262bef4daa0660a77ff0d6347d97193dfb595ba59b0e9df0589deb1594878fc7505d6033ee66bb9ac87c01b61cfe62a0e4d0e62d7f21c408e2f0ae48d1884f86ba02e15dfb4387f47fe0e31c799e991ba9a26f8a48959b0778db6c54e3a8fe6cbe418bfb45767d6ba342ef9fc6c17ae0b452be0ed5e772df15e5839aae79553acbd6c53f8b82527d01ccac0cd9672983011da321a56399be7a1ee0b633e02c1c52fbec9fe2de581ff6cf1d0692f4231f945f998129b9a3d56862e5180906d1452ce7c264f0a40762e1b8522ac6ade482f5ea816e149d49e2205e0d564dece851e9c3686d149d512d1add1d8347eea14bc82700adc7ac35d47a6bc26f5b13a4c69a2b2b03b29392df45c75658112ecd787ca5220ba4a5ae077f9f351e5a1eb2a4933445b0491ed3009fe1b84accfc509a22c0f5f28bda78096229cc3bfb300e7be5854cd5d7ddb2796bd4bf20c8617d326c728d30bd59d322dc8956484f343961033bc89cf8be5d630900f1bd37b09afddee73de37e25cf35bd88018c589dd002f07bb31c5756dbd4fa3f95f109d73a05f2d3fbdf04eb48eab53621abf3277cbc26f8e0c0be8e6acc2015c342c6da3c6a8767f6e8e26b70e36f86cb20dbdc1540d1d343ceccc0b370cfb36958ca158caf688fecd0a67836df906a4cd149d0aaf56312d43d17582c0bc60cc4334ad6ae580d5cb188ba25875924b2f012025f321d10154f887ba389bf2d18da1308f1815bec1b58dd350f977733aaebe53bc38040b5ee3f242283bc03ccc50294f1cc4d9b796b5bbcae28ea0cc9dd77fc9cb05ebd7c9ffcdf6040375962a1d2108ecb4cf8736fbf52b02419daa4c156ac8f8fd97ac7039f5b3d69becdb1dfca69a64960b468737cb38c72911428482dd163df096e1c73315524db04aee4a2fa45cf1268d72c14dc9105791d8757616e4cefa687ba34f02d4d7a415488faf8671bff53d9079998fc8add7ab2f3b5bfd7d1bd171f43c62a136867b022d506a8d2c3cc3d2b6659e1d40696ce5fba05be46238ed4dd650bb5c828a168cb2f49eca70575b3e04b350df835db27a6c9954bca8ad1387506cbcd0b036e5194e91ac4c4bc85f58c4b2404e1065cd3dfb0cbbd13645e961b7b09e3d1737e5807fab14f34a9dda2687fc5bfdb7e5313e1af7987eb9696f3369262007ef46c7d077539723bc369b18e439cf16df0bffcd5e7ac792433d0cc578d669c3ec917be273bece0343dc7ce95bd0f4759265d587841264a13e4255b3f691d2236abd124cddabffbb11c1eb52a43a1b823491add8f655e9ef518e8477b60b0579d6e049edb9587295ebb185cb9760b55a0de3bdf9c1e37a6d30802359c5e81d211f944768a0312be48cd69c1df90e1d9ab3bb1493618e0c2e0551c8177c6c81acd4f7d9aba4bd86f7b1942824363c207222253a9c47e2b64048f2606b06c206a1d016cf7f85df3a7c57afadc612aef6d836b5578cdb322250dcb77b462d51237f0f92e93e8475d2cabc990aeddcfc586e16c45813fab25dc13f28acf44adcdb611fd65dc414c2c11fc237c365c37aa76b00906a5b2fb6891e16ae23f315e17b6ee9cb78a85343bf1c51f6e810e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
