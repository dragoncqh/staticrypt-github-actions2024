<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bc4e3b2ab6b849ba2d1875dbed4c2e6afc73ae450238ad861f53df2568824e60cb4c42973b16060d611c9bfa9844c69675142a731ec2b7df6c79a7502c60396d05010c6666ff6ac85ce5cd87d238f30b918b13230d1f36e3bce60bfd013761b40ba48c67c826404185c495e107a81cb0a62dae8e90a120be7a442980f26589402cda527ace6d5d3b9ce2da7c1f99e0ed348608e40b163d035d6ce6ffb73720e064dc194da694845f9b456e0df831565ef420f56ee265c92ff0ff4f3241544db6509851fb2347f8664f180bf0dbdb32799348f3ecbaf445f05df0e11d4703af9a42aabcdf526419c50d1896591833d33e379c0894b99977f9a6e7da39b3be25c50906e2b28e92148831866deb2cc28a4cd502bfcc0640f9c2cbececc6798841c3b3c63b97f89b634a5ad3cf488229cf590be9506e4eec3e0bdf8237ea682e21147220236952ee1c9bff46049759e96e566768f266f31d4e0d92787c10eca291b926d0da36c6212e92f570269bad225b2e185238a4f1d3b155c5e0b2b5d8dc9b1dc275e6d4230161906321187bc255273468fd47c696356b22893bcd11e7f0989ce40c501a81d365ceed0861e01debefe00f92629aed04b482218a99467ece4082eed6d0a35164de366772d0af8ca43543485a51fcfa6d7993d75df887b41886a8b0289cf4a751e5c611a104faac0d612fb74af9cfbc2bd90975062d18ec654d02b0c4b0a4a584f83c1ef27442d518e5bec0e96e7e141c7a6ff5560e9c723ce9a72b33cc8124b7f3bcb8e42985c6c8e4b6bb3d75b0994dcec81b9ba83996dd9e882301e49449294201ae0ca50c5c41ef70fb79540098de9097022cdbc909de450be61977ba919b6674a75b7808ff9e954e9759d2db887a6f2600dc521a62bce862d60d679ad1ebbfb455f80e9bfc531d01c3f56fd70273304a182aa1ef2768aab760124fddb8b397251311d2cacc38ae54f4b2dbc4f7f7d1b111427303de376a09771145f9e2ca090417c92ac4193f383f7024760098a5fd9adf93bb535ed8801140020ba821339715b2e35ceb56de5d7f796320855cf743298578b97a5f10fe38d28a10b67d647bba7bf06502a08faf5e0f91d07d3f12a7fb10f3c24dcbe930871ffdf19fc1d365a2f5cd4bedaf9b0dbe96c33749a9ed54b63712eda8995ae16643a1d409d45aeabd6eb44acf9dd8a2ce2672c56af47550f02eb541bbb346cf86d3cbeaa0fe16f4f11b87632c71f785e7f1feafac2d8dc0c2281430ad1593ea4df99ac79ccc287e74740f6707fbf73c30f686b841abee3d98729a71e1d1dd4cdcefe463dbaf5aec43ff57c9e2f1b7dfb348b426dec25f03c169e12274d296bbb958c40d4c51dce46d08841202f8b112cc51d8d11db440366526397578e5b67be54fb43efc142d9932b14a5a74a6deff5f617444ea058b1c43e2d6fd2dfdfb333715fceb528191d5b198f6af2b535b69a55a1bd010fd7eba427e117a9d9a64e88a598779b143628939832e5d5807a5853ff1e61210b98f848a889a2fe68cb95284e59c1ee5961ae3425c56e717ee4e3b5c05d2055f9cdcf605dbba7aa03be16a010a75a4433928244080808962b271e53b193d18743f97f4f02f89aa41e61665a824d5ba53807e082f6ac5a2c596efe84b2a521872f2cf68ac4e57500b24f78ba8fd98530ba0ec74ede69bf7520a4c307101d5bc6d1fcb3126789d6725940a8b219789b7ed4fd40dfb0ad175129c171cd14715a17c60b1f13559fe62dc5f66b66166640a5eae83898053c40d4da0d04eb758dbd6f3f89a0621d6bf1e6728510192997885f7d06c832ba15004312bb3391c6e890bccb3f54ca90dffca089f062d30374c1157c920cc2a1440b457dcf9a4b67807e65da62a3fa9c8cf1e78c8749df60dfa0a6f5ba8f84ddaea9d03d192a9b18afc33ec165fb58c9eece6a97b912837e1a401d26c90d97f3865d45208b9da0a466a03409d077b80e46e3f0f71936b352246dfc52f39fd4767c99c2f2798c2cefd426fa0c669fbd1f1fc16275aefa5453083ce6cdfb50876ae6f6dcfe6d767cff0e1d64b7b560184e6f827926272830b1bd636ab254b8cea51a558d91ebc639780b996ba45182cce3c02e5f095d0ca7023af3d6fd21c0aa56a405097ca0af520f9175edcb510162e81010ad16ef866dcb63bff14bd62e09494900c9a8e2f0f9448e9d2e09b66c37a327577670246814022b5efd53df61d8319c5fcbe47c92edffb1ea431b657babe357ec8c73f234425a5384c861a37d391c5775388befba8df764704fdf2dedd111d41b11c8cde0649bd73d0b83cb10695184fb22298c6a24649bce894e4328ea307e65f1c0f8261445801d9d6e9f255bcde9f09c8c10524727c90309a0e1653b2a9f1799a62464f478ae2a4e1a5b9752b6bca3997909ba9b9306a79b5b0ea1af802eeac5110ca2e421d01319bfb6e3846ee6513732ba6690bae009e8c33f0fcd865eda58d64a075fc528a84245ce2c50f6d55763134915652c425dfc834bf70f622cefd3a1dfd820610bd17ba7a9a67b0eb06a6aa56a875968df8c4bff66f703e542906bfe22e6d17cdd90977dc2ba6865b9f7d901557686e77d1c7da6b3ee3b26a9ae099a085e7afd4e2e14b3ba7e8c31ac973b7831a6fa511c27063c894a4759e9ab52989f429f827d8ab9532f647fa6ececc5652fd74c28088729d2c6a3dc5b7f97e9a4b706c09d3861828eca29e5525540d7528f533b2dbc0c3676419ebe1f3263f71444c074dc72bf314543cef6a7ba6675e05b776478650f6cac805ef47c0e4b06814ee0883bba8900dc8bd1ca3698df1051cdc9b92a8c129c628ae14fc68e970b7fd265918698a5e77cbac7930321032485690de4fed48d02f410819d4b89081923cafba35d1cf19bbe2e0ecb94bc2131ba0ebaaece7f76b9000285cd3c08e920c03807d0df6f78516fe4367b7bac624694dfc8bb9ba3832f619cb7b7a71a4d05a6135424fd343b28af859a3aec7d9baf55b7f661b96217e6c5973839908f724545b7e98e4b28ff857fd50f20ac1455e8522ccf7d8a7539a39e04946043df37ec39bdba2751c59fcca0551ba0d450ecdd9c2a37d3e8792be36338510ad5a246c84d11e2be3b60a58ee422b3975cefbcd045e433f93e09ffe0bd1ea790a52f63c52882de769fa022262c57843424084e9d62748d7ef5434eda89dac7d680c2335e7d6d8afbbb092b9519c0f0efc24a87ef67c65963a52b59c680585cd6072fbe13b62b4e30d5ce676467c1f7345bac4b885d432175379c3ae02588c9d7cb809cb07f5e50be692b3dfcfd1c68e6795853bc6880544d0343aae3d8b7945e5915ba3ed8cffeffa5047890823ba5ef947513a6c9488df7ba4a76c429ad6af4c3e230bc1d9551a57150de9337d82ea96d30c1427a320b709d4909e252a02fab9b6c76599566c7d5b52351d522b298869ddc451f6caabf70c1fa07075e82c34f9ab6cbcfdcde972b7f2a1cee6e367a161abb24dcca58605cbdd315e708953a80e0bcc25c850c904956ef97351288b31f4fe8e120466b5a31a3ee38dff640b97a25b2c99d6a2cf03affcdfe82a0ff03033f1e88c70b2c778546ffb25403e360885f9b689476b5b9096488866f53ec394265965205e8b2da0707ac2ea0722bcf95f32cbbfdbf67a9e2c5abab776c6283d12211dcf1be9f8c45aeb4409a22873d64d8e3156623d5cb3a692cc024ec846c75cedaa164bcfc4e047926da19edf7b65d658f8e12fbf4fe7583cde4a79e471ecf7f83b8a0129404471b13033ccf50743ff94497d5f40a5886fc2a6a74e02b6bb878e620b86a0e0a60d8d7bbb0ca5e805f81acf65a9fe8cd1b5d7089cd2b3f5b7d3732293a4abc0702f7ab47d18c7e52f17b1a3e9f13be332cad1235c91e190d2f20f0fdf57c8b0eec056a5a9d3864d97631fb88c9e8fc450ff59615636328fdc08b3737dea8ba11281f41b13b59e07bd3d249e63afedcae1f34cb204dddaf4b60a1bedb9556c05c55edc7103d9bc4a2f108a4875af37fc9cbdd31a31fffe8f54c4bf7dc2e1b6cce54d1957c2668d13111b11ccfc6b4afe3feef4029234b4b8565c762d4a228761eae5065babc0ae1dd47ee1e51eac19e3d1043d0d3e49abe33bd58481724f5e278527d447af6c32d7f0c3105c9a2cb3841b302560c4d10586b93d57c09a80a781803262f760ea095e94b76806c8e004c9e1c9881d68d6ad7529595321918e78f612ef7f4ffff51d0eae175577f391f2429cd6aa68f0fb304ecd0af6cbffcf03f54b9f220c653a8e2713cddd21c47ee2a9b516a9663e2f1283899e8a2e0161efdde551c0f672c7630ba3a6018cdc63a82f1cc2d0198dfef1dd8b5877725f622c46e8dd14c465205ab33ba23352d8332ada2481d9495988e2349196dfe4165dc6804a39d7ffb43deaa902ad392be18995fd813dde4ca35200e77d2282a9ad03656a6db2f6e1e73353289cfefc78e8c81c07eae1ac5251d7c20ed1518e62e34c2574f9fc7f5970a4e0eab1a2f789770d0e9fa4286c13c4db739e4d4ceef1f7dfc38b4ec9a1fb1974fb19119735f7fe864ea313ec496aac29051cd2b8a2f74922817406f0dc5c07564cf6dc0bbf09bdd7f7cde169ebf015eb7d0db78553aa5be152148fb26ffe60f051e6bb9f2501677079be924de33c367f99f841a89bab2e7bc991511fa21bd95ce3a2971ecd061f50ab780ac007a56439f3032dd4f915a59c554603b68d1ddd2b9d3bf65e75c3ae5d7b9dabd4f3740ac9754d6cbbe01f6ac1ed236cce2a5a5fde86e29e638e1e4fecdadb327b99638f31492369f68225b55e01cb7d31a9ee0cf514724dd4342d380939572073da0ac7c442b55af17614ab1b9d7c2f119f24bbc2c6f6c1138a6e3d0c55235556886746e305bc063e2a355bdfa32a52ee77299e57e2dcc951ed6ca73cc74f027e13ad98d97a256624ee1caa0322c68eafd0c2c71708059915eaf92a1cbc0bb972aa462159210e20a75e4723fea1121a5137aadbbfbc1b3868473d5b5fdc2552a62f7c1fecaa1d28eaeeff43bbf89d1958e73bc560344e16f2a07fb46d4c8335cfdb8690914b164627f2c635689955117f0d8afe4bf7d09b717fa666c4ee5d745040b73cccbb7a73d6bbe3cc754834804f6eac9dd1302b766361015a201ce044c7bcc40cc78644cc56ef9ca47751429785cc20a71af3746a1610214c4b2e0967b5e5252e61e0876bb5a9c85e4a94ffb0e0b4d6efae0c9813cc1406bd2395dd79c1296a4067ba610ab85ffcb12749aa3d8b0357f2c8880d52c8ffaa82e00447c80e5206da6b987b8766ecef15dfab4e56c1a9ce70934c5d13c59ee40ee61e1cb38b53e3fd3a10e3b34c167d70b4a3a30baa60fcc73391d4664d542766d4e5d752bfcb11c3807f488fdb1596c77ca4982cb938d6ba97e4c7ef69d731e618162b594d967ee539743c2045e817f7b93d16dced4350e66064cf5592a2ab4a67b66be42cb49557a4ca775584ab3be9470f0652a342474b8d2e7d089c99d348dda7c69589e194890019a90983aee3f9953fb8bc21eb231f25d2c2a725d7f98246437a3c23b20af9232e1a8e5bafa830e0524a46e7cff5b07f09ec36a3e75140dde11bad42943de407630ea9a68542e7438674198201cd4e6435d3dcd7089041f700390d3d5abcf1588474b4d1c55cb53ba1e27309a24499978832bfc314db71e422d0a43710782ca31b9d30851bc6f486b34d7a40532c85511db3eca847be4b9a151789d1ae5c765d103884a230d48fc7b9744db78bc81e663d8b1638389f78e9d19fa37b8b6812b349a49d825b9380d41050b69e681a3ff7a9a5cd4a9c8779ad3793ee5d0f6cdc7556b0cc6a572f2e0a0137e3bf042479cc4c99c3cc71593fa100998394281fcc2dd4f2873307f3a71a0d4b9b572871677fb785cd9cd6d9c68844e1b793ced86055806bfb6290ece42fd2592c98851c326fa41947ef28168d12011ff079be4ada49ef6b6ead50b1d6bb25fbd7f1346d67fb813b2662be1198303867e58f079614fa6544f38a63c1e3d659c55787dd6bc54bba84a61c9b760c52746fa4838ce3907f4063da2ff028911aaef13d1b3179f31e78266da2b87fbd8e558da3be1e27fd41b7b72d6bbe825140f1cc8211dea83d0e7908f0545063e01ddb6481c23a2029b9e45fbc0fad843e0b6f2089e291d4451c83491ab27ef779256b7e349980b7be24441275c336dbcca06ba2df2d7516bad7a484cc2eba9e9320855039dffe86f036e92cd81600f9ab1a463419e968304daa4791e509c3d6eb1fbf7f1e84294cd1b07379a5ec8a96372cf56990a8cc60942cca9d8ab6a108fcb6062e315635fa1f627aec8188aaeb3d22c827e60b62fade013e5ddd3620334d144a302926d87b2bf4ef2cc721f36651fd36e261d2fde12ff4981c90b4f71714d427d7e70d0fdcba55de5c6a9d74180c8651cb25e34fc3058ccddc290db8e50dd12f948a24554952fb40fee8ee29e4cbf60c48e86c0bd4d1a7b79007161ac1982d46f87711ad5f437194f6536268529bb52dc0f8deced302fe3f7a798df1f98b903ceee6a313dd2058f958c1700325b86e22b2b920afb95b17d8fc5d5a95d0d4926235e98191c36d0d955a134ebcc8506f93c0391b15865d155e1ab41ec792cbf2808e23a9e0cc21c160645573b308fa52d7cdb6ea69f82efcc1af213e61dda93e2c8c9b9c78389f9bbae98db010962f25427c15de95f8c6c727d53cbbfa316b3311dd1c1616802a43b4a864c619f161e78a6bed2015b3b019c473c15ba28626c4e9682fd7e9d5a5815edb7c7b60f31d34b0bae478dd4ac73c33e94b3fddb9e9f711fd5b7d9a007ce079250371df7943c6af353e1c74ab484ef23b27c9c1cf2c3036d32044d6d0067aac79dd186d26ef0841ebe2d2f8cc7dd64d50919e0388c03306f41e0686818e66915c22b0586b271e73e7e45643501bc0122bf2595e7378fb487fc3008ef8da13dba1ef8ef394aa4377b17a234b5c945b86e3db57c6bb9537f710c1986106f2d351294e6fe4e1e784518a148fee0f3647e8a3dc5caab95f0da34ac8c4a0820b8288e03b34b182e6e9f7c2763f6663f7075624728f58cedcc0fcaf3f9d0be7734b3b58d01d87a75f62f4455b9beea2546b261fdf3c559be26d7d44d8db05b638f7654534d32250e01593cb3c08a94b1843ba0c0de47bf3b8bd6d0e620d0f62d3577e72b1c846508718523616219723814d3aa62c32ebae7ddbf47dfef46781145ace741342d503d4c084d81104aa3e5288d10df791d8f1d77ab10db6f9f659a22da7a30a4fa6499b1eb12172b203aa4425053f945bc051f2888d0f3c4777cc814a33c93f3514405008ab1100398ef2605069588e643072590c22a5d6f2119cd4990af1fa19317cc0086729993e1f661d4647325ade0c9c0f68361f8865adc12002264ba602fb5382eb971426d19ed3c0e739ec466b61fcd0b925f1e0bd26e20e3a7dc0149e69077c5af96071842f8517d7473399b98f7292ace55f642df8825192e4eb11b9a7a80694812d3f841b2dc94e9bd525ec1bf6f93c9e66945be94033f9addc4ea5d2d8480310b5a83d05fad545917f7954d69514d04b54ff9a9e59e4e4d2d04ea0f2d964583c6632021956f54aecc78ed2932f7047eb9f30410b20663f1ce1087ec5bcfa9ff32f73ea69977184163afd3a140dafc310c4d607f8fd83e7f72fcc2ee6110389d2e9e3d4754e012b40b239c569fe07f264f9eab8853bbe366b360fa89d06acb3d9f5200e214a8573da480b9934015a015092552fade60741d0450028563d0a9eb3d372285ad5213d458461d41019c3049f9693c720e1cdabc80503e6f60bddd3d6d1fbdd63407722ed50cde441c2ff5cc1cf142002075e176124c9f922a8b2f10d19e2915092566b0d2096bda0b0bde83f1a9a075f8ab28ea97856cac645b19480da81fb98000ccad67a07783404a3483fdb22ee9779e126b0c111fe22d95e1dadcd6677acecfbd3ee2c8edcb9e1d2a557d94ad8f19e859757aa4ea53679f2178b602a5b7299a6657f56073091f2dfecb53d2c56a8e0f529b114cacc4da9ce07e630d87dcbd1b7a0035edcb3c8365ef4e14d00c454af763b0e227f516ffb2866022f9d8a9227f373b2b4541afb24d3e1edf246822096042871989de191c0099d5c090366d692694e7c16cf7d4ed3c2f665db15b4e902ddc289a677f841a194594768ad68fa99cbf42995dedf7280129346153bb282eeadc3c0c859b7e6028e083b16495267c5eb1313dcdb7196323aea7ce6550a9b1199afaadafd618335545a1f954c182575e4cda81758816cd01abc999c0dd31aee10a20807f867a55349fed92630dbefd8ac1d00e9000524987ef72469e0992f89c61970edf2bd39332d86dc64eb1deed6d2bdedfd4ca6f7de7f51b0e85926c520e8ffa2b73131f13edfd9aff93a57dff1582711a8a843a99ed997d30d8b9d85099ade295bd3f9a42b989bc68e9c5258133129ea6a9de692e711a343a48ef536eb05398503c601e643c283e6c0adb836215cfb0e84c991f02f54d06b8100bc2eadf736457423a781e4013474d0b52e9b7389c410cf3eb418b8b88062a6a9dd2f391ddad3099148dd189907e03b3698347a332041d89fec3a37e640c110f0e4afbce7886f8a7df98f70eea44cde113d1f5d5f9abe73e5efd59a06a65301588356b9cc96fee42cdf0a64c5d13c25ae6ce08e9a82b61c1c307721f99fa71770922bb323ab791b457f49bbc9453014498a77338068382a13781f5e2941e6787ab7b5013475e59f1ad6504a48268d67f4de7d442fd1eaddd68a2ffd35900a364cca9752ecf1b510d74b024003d4365ed9d994f9fe6a860658c855606a22d57495719f8c586b7860d8e5b4033db42d3d2ca8b5f0a7a857f635dde9ea5ba5b9fde59b92c810e3b4d0de45ec71cb36627ca17c4b0fabc50f6555d764f30402cd213535789bb4c271bf1d3c12f08c428d68e3b2452afafe64e2eb7d0204c185e4082170453fb15425a05c5892e6046bc48aac2729bacb4f02e963f164cb9e455397b3aa875e0705f6d7d50061bfde3d50b1df33882a9a7e1c38c93862c37a523ae24b5122a1306e1073d0b1c22026ee806087f18a5bae71a30d392d0c19453a54f752d0da0746409c110b31445c6411644d03d7a317e191dd4f819ea0fa2d6c11159c38e0c07141634fcd6c040a622b5acdc81bd385d5625e3915153269d83a9d783cecb18212b1352e4ac61625f5333695d7b580bb69ebe04262db3f8786c01c8f696fa789d0a0bd265c61be869009526246ace8ba03fa607cc6c6cd29e80c6d6f5ad623a04afa26b5b95f5ad0e5f652e2927f85b40c6107ca642eec8d37dd1cdd001cc858745d3db0202d43f9055a9ac1e2734fee5efbfceafe67b09d486b8b2ebb6865eb103da4833c5529c360d356a3a4ffab781505cfe676754958edaf785bd949a181306e821e2e9e0278c6ad92212749229b3d581de75c23b9bc4d7e0a08082fc977d1dddbe0b7089e80273263f70a87c36f4ccf4f3911624fe1bb36a3dd07ce70d0407d062f51ac2b763cd290ff2c5d81ed0b75abe86b0c3bfd15b1533c6e9c3672a97c7e520f292108467359e436935645883ee268971553d59f47d8b84fead0c47cd47e1e8255056f6a31fe47a783f3c74caf1c2b767f8cee62d8b7c7f8067da9e869b37d93d8e36969f0644dc5de926a045117f7596c3f49563cbc9a4afc46eefe550490555f64724f8437a3748d334e704505b29858d283a9a0c4c19314780d4a596e74c0073dd8715d30125dc234caf6759f3792f35dd27c32ea16af371c6ad6618eb2237fc90cbca991adf02fa40da7f2269ba0a10920d4f27bc530cf747cf872da24a97a1990b65633a08c630bc4d3dbc24023f5528d2b8cba3a0c4d4fd24effd17ff28534daeb44adf6d3435a30b7e579348bbe86eed15027013656230be3ed5e45ebd90c1825a4656080f26567896766d1f5c9152452c04ce193853083986c49b42480dbda22e6058f412d5666e4ad3cf3d39537f43dabc5c6e3ef3206a8ab66e1d9a9166742a37a6c7646bd072cf58f104b971ab333a039692ff90a50d19f6a1b11a4e5f87a1d1a5f6336395ebcad1034288ec884f37c56645f68a5653bd5668b1a13c615f9c45268aa939a94749115149adf5770fe06b3f978b22cf4180d32fabc2de43621ddee2044cc5c0d6478da9186376ea6b6a30fde5d88fe151e1d673dfa3a08d6be9fcf4c269e773e0bfe59a608545e7dc77bc50b14f7ac3d7ca5ab5067d2d6297948a745aa98f5b6250bfffe2435c1fa276b2b2ddf82861b026f6dc63d620ce48c0f2b1fb48c0da4538ee12d931ddb43ee9908c9b979be7cf16dcc0d2544738929784e6a151b528ce1a4406e0e555003ed3952a8c331ad1f3e20574334df27e40576aa2b4c6fb07317ad5973c088a7ffeb391cf6ae692bd080c76cd1e3bafd1814e42c345580b9aee70dda357c93719c3d848b0798eb69a9db2f5f8aebbf895704187ae2197b88e349ae2381e67412bb012c984d37b2f700886b86cef55f1c585d98b01c8ba88353c643c21021904518ad41c307f8dcfb7c6bab610652147da6a7c0e2f2ec7a3b9dad7000ae3da41720a761c831504302d3f6f39941da3145d3ada4e8500f4af23c90d968d6a6e485a36b38c1b6a4391d27ace2912019be5902a5ce1caac4bc56f470001f8417919b41bf1ec4ee81c8e85927c530db807c6005d9828d8c34fb6e25a1a3b9f675f53ae31283fdf5e05e2bc88fa559d73b1dd56609c726028266baa2169ac47a8345836c9938f2363ea82b5f9d66174dca2808cf9b6da35a306428575c601368c0bf0ee1ede9bd98b12c08cdc2b4fe5b046747f6212f2efd6d8b70fa31eeb95ee8b8731c5d37338bb56dc628a6edc27e163e5d1cd8b458a80b773f67cb8d96f68839b02d2f20ff77d54a244b93ba29160ab9843068de94a68c764c00aa533b917d7ced8d3395a3b7993eb288a3b2c7e29206fae0518c2e753d383d6f1b4fb5ae6ecc0af5cc693cad9c177ab0222e8bee469ca1c14422056fd858dfe22c2af737365f34cc7290e552633909fa74d1be28dd638c14808408a49c7ce4f47610cfbfba6ab33441ea12f0ad033cc1255235e3bb3707f93a761837f3b14950baeb4cc4b3f238aff3153fce34aa41af252e762f854598ca52b1fb562e03970b77decd9d7b48e870d2e1d54966a3362efe4a3064f7eb29fd22d5daf5a9c3e8f5ded7851cbdbe92709a3bcaaffb8083f4d7efb052a43072d49d5a3e0481711348ad128f97f912dff46e7fd0c563e00b5f74c1fd4b87b38595370daa889f85a7a9f299be0cd988cd06a0330a4dbb9131062b708151f26a43bfd3732acbe0fbb7853d7ff9fea45de7d0df912d5047d5955f1476770855f197dbd8e03e67de28bbc527cb387260f1a58ea40c98c0d213983d334a1a178ac9be8081b4ea37c90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
