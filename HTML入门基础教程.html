<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94924fdf4becffe0cb448b2c8ac7d7a1a81af0e30f326ac76303734340f380d8d5846cf8edb6d54197e358ff6364e962c9bc4ce10b9ce9841be2ba57352bc44bc491187834a3dafccaa14d02524bba988ec5041ac5ce291b37e23a17fc29c3cc83b2d29de216beb756295aa8af15ce4988605ac3d28c801cb187cc1b265bdee2753fac8747134f6149ec7ee3a3c266a1e0d658ded16e788955cc5127d83090e98196820f77dca6e1398cce9e6d1d0a2d3900f0f0329e00c209f903a1f2183a3f539b4b1ec02ffd098ff36af0a2b3bfb44ad8b34a6190a04551bcea239ae92e9fcaedf0663b4b13a2a907cb61db285301c581885d72cebce76d630ed0477d8777315f54f3c1fecd190fd077d73b9d13923f0a78b89e53ef693fd90a988de2cee4f77fc4070c165b4762d436de9fac9e6d48e07428e879b0d08e7e43e10782e01834c20a4faeb37c731be32b3e8359750abfcdbba5f313c7e8c6ff5662a0a973c34e6f52a98179bb8cff2e5d7a522b8313affca1744c5e464a047732aad764374ade777d33c34cfc5f36e7546a23306b40912f05d9dceecc22b341173c13d1632276c1445d9f97231985c5ed2a4b78e6683525454a212c1caaf0b24790c2a8b3d0ec7017d5ee75b478952e153d6352bd4e1726308cbe59d0524fac3711636ba20af4df96d34ec4972b3cd37bec85464b69eff4612b33493235fc9c6332b31e664d26963e956d6de6a1da55e34acbcff0324942fc10d05486f17942455caae9a7bdf6f02c15c8aa577c592ce78b3690b80cf13d14e6c0cab422ecc64819927d9a19a7aeab37a08de5b6b3a65e02136c3431d0f0b0e99546e893f82130486e4c8c97713c68a906bd63cececa048e88e8efcbbcfb682c4daa7b80cd994b32b11e2d5db4a73060fb57f3237a48a3b13a72f7028d6119df1d6126a090957b9ddbf27c306eb571917eac2b83dfa949126cca7da4626d3aa6b957ef672002f47206fdb42cd2cae4b51ba22f2b0746799f803dee42f9093f53a36125d4fff73f25561f70e9610513d4f6abf9496f9f15010c5ae4ec1b02dd41266ff9639d17d2657fff56f57eedcef0b3bd1ac1cbcefc76dfb81c8047d91e0c806708acfada6120ab91cd5655b1b4bff5986822b641ccd660ebe7735de6011f5224e9d0fa3183532da560644d9a8ca27c91c140959708452a854d1ffa28272afa01e59d00742e34be0007976e8abeef38bb487fc20a2f79627471ad5f351a59c39e68162abc5690acd14b771a5d8ae4abdf5e97165cd1de36553a5527cd458ae1ef02c3b94140ac09e45dd1abcea7b6b006223231976263895b0425b44300ef3f3df2eb881d0168f5720b1ef394f54a95b997ce5ce884825a0b1cfa0cc665789599595fda12ed27acebd2b52b73078ee2e182bd67509244822af14b3896e9e3ce7d0b7cc2061fca2d259ae3067d84bc7f1519a9fc822b21044020cc14fc0521aba3212b99ade802675277f463bb798cdc55e084b957632c9505519377447927d2207a44900153403b736f6bc618f0584ba5d138e5a159bc592db66048e79550310fcb5982313fdd5d5bb698fdaf6cf0438cf7c385256b0579fed7c782ce704ddefcb14a9f83e14108b2998745e6850604f01551682a5292cdf2107b41679ae1e0fee29e4f7c5186909b2ff9aeaffc98c9eee921e6d5bc0d628771f7b5e998c1a43f7ad38e3293224b4ba4cdc340e5268e7cfbc400bb62118b0a27b47d7b1c57da0355e7f08157d664bf96e86941605896aa5505b23699b3e2b77b9eb00b1638b043de97d64f67969a3031e18b1253bf5bb8d387007b4adcd0007c80f44f10509924e7016a2e598b7b1d64f664406399bbad32527e37746a3d5912aa7c429631d34fc9ebfb52ffaef0e8283824cf251f037a0b984cebedcdbdbd9b7e3c2027268d96b85525b76cbea3002733814fd5d96cfe6751b20cfa402023acc4943eb1ed21bf67626d832c75088af021d572587b35e3b8119d7f840b98a573a19c260afe1e4a8623cd87fd3c90207833bca2adcb1e661e76700a496a4bf5abaad3a219e410a30ca986505825afa27122ccb2a703511beebf53a4ba9f4d228ca890c049f22d4ea3eb19747e075fa7dd03fb8a694b657fec64d70793e031fd7bbd91c0eace19271a3f9d5b7e5eec305612c4b416350382bd23d1f0528e733804b340b30a603c26f2eb1170f4207ec2ca7f83ab3b73160c2ff699c487125c8c1fbf16bcc9fa77cff57d1036f3a66c7bb321051cb0b626ebc61ead126e5a32f24b444a912c5be0f66d669d1050077cf5fbe61efbdd26dc8bfe11f0454651a4e723389307a5767f3ea05f1d1e3ceb0c5b833eec004969e1fa7b865ca2068feb8800792538537eaab91e6824c6a71bd0115a78b1c624ce015e1470e0b14b847b2c2e5f4219ccd23f4de55c313fd86cc2519dc19694d7466eb2227e569aa01eeddb316b1ebd8c12fa0ef91ed75ac2ddc6a6233406822ec7f7f3e0e6547a9eead077cac69927e4a0125655dad5951497db0bb51aecaacdcb2895718b6f4d5c769d121958b9cdacd3cc41d69ea8fbf80ad6aa8c671b41e415af214e2f20049cc333bbccb20dc423e9b27118bab0ea850b09f6e1f8860c068400b7c25939670a35de09996b77215980ceda54836f1ed8b30364690ccae08e4ce6e25bca138cc320495978c816be4dff7e56e0c6dc81a8b93a11f4c557897f566f9aab2d4aa8b92655a6f4abca33e0bac76f316baeb2600c3fd14b02262c0cdc740656c31e64bd4428f4c43a0b8935affa0b648817ee2fb5be5ae24806d31c522845db45203c82be5d29d4529500730b35ea13c1eaf8578f68bd52dff9147703cf070775f62ef7a5fee41181fee6981c63a632a44b4b0c0fbba625c9125204ee186c11e435d1b80a2feb0af281a434f19bff2e89675925cb2e229541a00827ac6fa48a8327dc7a965459c611ce88a7243313ffa002f5c5102d43ec238969f77ac9c6b37d3d3daafdadda54cca27d0cf24c9683455fd44b1abfc5683a4ee7e516463e40ad80aa2df0a84dc10ad7e27e695e5caabdf1aedf27585d46df0cb920eab1e1e5e6ec7d3f90d278f8572a628ba5f7f828985b0c97d4917803abf3a1d1017ee678d87114c4b26448f2fb052f649e09b8a778a607b0cd1c2da0e0ce95f06ade0046acbe4f3828a7f343ae4a13fe7b652f7acf439cb1d8c247611137b3b55385da2aa30d248f25440f89aee84139670c7c39de8f6a97055e2f8233f96cae0296642737fb816f0974487377acc9c498e643dcbe5b7c24b5a9cb655e224cba68113dc2ac0674c874e0f45787b13d2f80969fba1d66425ab1682de3309212cb324785a200aaa90e4edaa48c0da1e60598105af7ae58bd4f1ed3f7c6c255bda7c0a9b0bef929ff4fe527c985c8ff0e70fcafaadc9e6e12c38280950512e31209d97df7ec82dd219ee725fc7f2fbe9ac398f6cdb01d8705375ea5b46d7c611a691a68bccd6ae80614d32b7b05d9436d96dba9b6f0849df02d961d3b75e117f1532582846feba8ad63492cfb2ffb853fc09f5231688bb208144dd2db4e35c43db625fea2844259918601ed453e361747a8969e64cbc134330a6254fd0a88e6b5e67985e02f8386e022ed5b94207c2edc8ed483e3d46295c52bed5ccb8835f405174fa50eca492bf1778c2998c3c4f24156a7e8a2605a19bd4ea13da1bac4e4031b8270c9cc686957d7eb9a97c48ee66bb30351fb0211343a5ae527de418d971f623d6a43d2c673c8dc4c1a548d2acabc875a4bcb52f729b2ca562df14d55412de23de8fd66537fad1500c00b926dc4c79fb9e89dee406bc20f56fcded35db0d471fa36a529768c311c319afe23a70be1df885e03e77df756027cd3ee8aca8d0aab2d12ba5b9a9648ec1073c31f9a7667f6d872715dbadaeded2b0ca74022e6c1f575d0179e4754adb1f73b7010896b44b74d208440a03f4d0da3a4708ffd529f1ddb6d3744a4a7c5f64c79be5f1ec68748fff366b6e173a02219a85d2980cfd3beaea98ab4e8ffc529ce460f8ab210c35450017834fc34fe40f27ed3a3243db6f03b610980ffda8e25bb99c9f0df62954a72c47f698b95461fb085c8726a53a7e1d26ac00c17599f1ef39a4ffc9f18de137002f983fa529d4b5ffe0e2c59e0ad401dab917a43031154b158ae77fd4877c6659f780612e30d26dc5fd4cccbd79879f13bdce8f31e61c52078ef1ed71a75e9d65e0107203f43127e62d6a80c4e304c8fd71d930a343bbcb471534eb29e0a3b80ac1093dfef0b79f63600df9facc4c1a584f7ea26590add528ef52536512aadb2a1cf29f1127e96a442914464fa180c93b7bb6e505d153a4e030c70579abdceb38472022b5ee150513c806d62639d9ac0ba03d10f9f8540a0bc11f745f453150cbb03a3392829685a513eeafe0411d2a19b5d8d1cb353062b7009e2d684968a9ffd6da53826291203692808b28c78d6654f5cf4d49213c863bc6e1cd00c031145918e3767c6ac8f0ec973b6db8108d9f96449043e29b0ae5a1aeeca6896c2735832159d2dd31bb280334576ce7ddefd57e5a2635f5e7ba1bb715bc2ccc28212c11612e5d85c559adeb5ae0f90678baf256923b0660f4b3de3d425a92a4a178652174f8751c950a55e49840fc2d6ec4a370b10b051f1604cc996a5fdb3f309fbb480c06c747426b9d547897940a29be06ce01fa2c581a43951fc38415b8ab8489f9aa905e62c5c3d1708153fe917d0b009831270d1d9007a10a167745fffb6e1421efd0270b7444f97fb10cffb4a028754c9075d3b94e7f2454fdee9b88a8c2e35767b364848eeab6d854cfe4140c12a1a0e318aac3fcf81a9506f3d0a0d4040740a3b491fbf093371c12712629d70234668d54752241e4dab761bf8a2a6a443c6622a4c87562a96a1bcedae1f2403e34b3e00ba6ec1e9376807335644066fe6495fe3728a14f4243452fcbf0efaf3cc57107a9c0d0271b75c767f08d45a88058c91a5d663e1afcb8a3509d2ed212054b0a60da1049272a96b2182f0ecd4d13572515ba7a9e4118e41d541b5e431417565c66a480125b03ce7936c9c23827f8e2343ff870b73d066b5e7d42cfacd64a3cbc11fd19cf570483baafd031f1d861bc4c79dc5f36e3256aa00fc1dfd9f3faaf55bf2a43de746bd6c04ad2fe5ced0ffb807b3f7fde4800a7a7fb77206bedbb4b6a54b2badb3818784f19a694de1021a93e8e1099b99004ded74414cc75b73d42220b965b3bcfb34687423fbabd65fc8b133b7614baf51dd4409f44a33782d0e2f87aeadc2117ffe1dbd4410777c6ee9c9c15af17e2b258e7e0c175f3c5d9f912c6cadb50bcc5d5029f9862a56b251e063e589396bb11d7f1d3d598c501511eda5a322ecee873eba52312df7d9512268082e992fa35d63aa110a0f23ce953f2f0bf4c9a11b1ebac63ad050b179668972d1b4546f633ad9baae5aec0afc5e87e21cdb378acdcd59b328c323d564371ff02c822e1f7ebda103daf3e252cacb25eda5d695f5a99e92e0d997fb275ddbbc9514246cefea0bfc0038ae814820fe44a5f7795d12b4313e7bb6fffc79d5f170024eea56ec9685d8bf705e28acfa48246c6c8f2994adfa9997cc0f3665cda9122db70553c2b0ffe07444bea67a76f1515dc2629f720785b7e6cb187ffe5af185be38f2e6c157ba48823925cd9c375877051b854d765269c520f2a81202047ec61f48916c7af76f93b165d3d3298aab6a4239bfd1ebcb6d335ee1ba5294ecb0bc8cb8450c0e93194fb59d38bdd9fbd48f1a7b54d416a12c3627838754464c36a36d927984605991a8e34e59adc37e4327c8ee6d5ebec350745c9ce17e2c5105ce26d89ef47b8ad43c56e2c2dd1596a3f775d0c7fd04b33a803863ebd04dd75e086f733000918ec3d99b99211b67f1cac12d3cd7cf1eaca94dc3a63be2830aeedd501a7f6f7f95c5bf4af1594cea595c170e673630946a0a28a4aaef97114dcaa0fe32a8c6372b729f42d2fc65da4651b230d6e46a6010d49078f392b08958bb23c3e423b1b9f6ca53facd6f9adbd48db37fb5cd303dc04d955e0d8e3dd1f6a20699b643a07358c2a4816a737ac63d904b9aaba5c648d30052d6c6a5c2af192d6f1e4a50da8c34195713e52290bcedae66d98a65dbd808f9c3657426e944b40bf140ed86f01d2f143ee6e41eb976a06064cac9d6381b22b6a4e5cfb736f27092135c40ded8fb41e77f84014d0640912aebbb7ab104fff3e356c9fc2810ad9dbaf48fa06961dfd6a3fac3a596965ddb908075806177dd51ca935179b5113f1b5023f942a46adabf24b214c0e0e11f7ec7895de98f83ede65d827a1e854ef544b9e51b88d11bdd3c1e4cd6b90890027fe2dd0e3e9c12edcd211e5efe5882d07b660df68fb406b8ca20c00df0c4778092115f5f2e5b39f0ff48070d2b9d54a2f7d8251748881aeaf1ddd02edc70516ef14aa5f99a1cfe83443b765e32f5619ac088ba2a29b13ccb54b967fb3e8ceaf0fad233fb8f4be2ff5aff6bd2a5b99775c3c21044e638b740a1185cc18777caf2cae8dca1d36d7a255500eb1a2e119db574a2d28a52b9a66807160ecc0de53b15965589176d9c4221f81d2a03cf9e3206dfbdf93458e801b8f954e08cc57a6766a728690365a51b051700887fdae0d0e36375f473e564006604073a34d723fffdfd0ce37d15a01bc2ca95dcb4b15da5c192667f2aa3fcda2cb0502e1e8037f958c4bbbe6d9d73a96b7082cee47a7ad2d16c6b7227aa4839842449aae4fcd27671c75b1d8194c9ce9b2228fadbdac62007cdd432556080bc1296e2c6856c0c4fc55383a8d720e53787333b5912669006ce5fc1ec14aafc38af76bbacba7216fc3431bca81ea60510ef6fd884c12f36ec8f6af555665eae594bbabeab308419ffff76da23d701dbb800146ad0fffa5e5a4bd58120e7d0532fe3e5197b8e403a3a3b12fd3e6bc3e0be5ccd252ca1d38cba307971666187c4d28278bd0e7cd847bdf55ee692b22f60467cb634daec432adaa062b3324a098ea6dba5a7014dada68709ac2ec5f55bcb787e5f11923039e57da4a51df5dfb869416f9ebb9675e091d78a4ab1112233e470fd071192ba387ffe0092084d5638e2e2edf6adc8b2277cddec2667bf30015a6fdca6c44072d557ca50d69527105f0828e2c271e67138ed9ec0efb6d2b938c6f522ed19812779d14db616e648bcf31a4c8a62792b963171cff1f8d84c88b4cb11b0ca178e5f2e3e6a2e003bc1b3c4ef25aa677577b2ef4bcb9c32eab975fc21ed048a493b2e58874024c10c05dba314454b8a012112aaa0006937ab4784b8b0b0fb1c7725f59ea53d38d95aeed3da8d33221a27f9bba3c7993ca1c55e3718fae8be2e1152f79fe656505d32bc35e271516b3b9df072a1db0e67d67a70ff017032ae2c64948a61e826806b3f907e9bf5d6dda303ccfc30ec0ac3a54e650577d7002dda67ff4827f87c932a4d3a7c4be3993253f84bf9a87b8242f5d94bcec34871ab2d6baeaaec7f44f57e35ea04f28752e92022fbaa2b2deb69afde00d7fe369aa79b0b52217a95fa1bc19631639754dfa620a68e1851966ae3319007e2b89f7fe91c1357e66e5ec04fad45c7e9562d2deaec3c572be606dfe2c9efd99260e81b20747af54cdc4b3006319269413eab49ba315d4ec3a459444bafe8d25658e46210d4cc30640947920195cbe7d378578df52cee320f481fef3c04708606a7afc617af1ba0b52ad4a20f04c80cb15ef1887bd7c3af660eae4593f770467e9c2982a14ef885258b090652b186f49a17b39e415366d6c49735efe54b2392caaf495a2143d3f526e4abae0e5781bb10e388c99aec97fee81f22bdbc683e501a11a15c1836ed11be393c90486be737cd993642f3fe6c38a8feefdfc5b01cddce3c5e3ad05dfd41f64aa745cd77b2d073c7fa4d810bbd18795a9d1fbc91369f2bc9a35509d82758b3575d129be9591acb3fd670d4b814c41a21c5e2eae772f650442ad30a7a067084b3b4047752bea9afd907da1f54bd820bf38d6d458596fe7b140f9f91eb3997ef2e3c6d928b1cb314573a5d124a080d56f4f2e5e034ecf7db1018d688e5cc635ffba1944035e685627dedad43d6f622883c99fe7de1c389738815e1bce6595ab26266e6f05ae057551047fd4ede818eeb3ebc12ebe0b695660b54093edcdac242ea0eea84ef29f978dcf2a6f55b7331e952796bdf33a5c2b1d91c028b49d38a88776f1d72273e786daaad7e7c0b3b4c644f26e2010af3b56c6494aa9c2ef0132b758ef336f2744f5b63e69e7a444118469aa966cda6435c78f38708c587739a032661167e0e01dce78819445a772767b1646be00d1bbc50e45af174c496dc6594b3926f4239e6fe8e886d71457c93244c325e02d17de079fc41e436cfbb182329a25b535789a6784d4b3142da3bbd30b839e1e664b091e03eb5a68f52227b166526b6bdee8dcb911bde600090f29f01370f574838ea2ede3237af809410d36fed7fa02c8211df412d075d634b5dd37cb5fafd7c38bccd67298f2b3454a303c14c85c6bd0ce648d1d79f8092040f1f8e145f41f51f5ecd636bbe7ecfc6888af2a5694e3033bdf4fd583b8ceaeab95867cb56bbad3c03504b7aa3622b80a9c8375316055dc85c66a1ee990f3b6c7ec3fff1a34f0e1b5b2ee467c2d1825e9dedd6db18f7b5e1b4709d2ffcd5f8f8a437955aca15a8e9659fba6b35f94b1290cd9e86d10558cb313744c738c8442e893d167c701074ed4a6afcec2889d12e0f22266727c22029be5d1d7d6d503c08f7bc8dbb46926d0416bebc1f5997734fdb7c8bab2e31ca0e418e4f3725eaa7e7cab6f4950c8dc55c81c9ec0c764685e4177a0dd90367a1a05a12cee016b7a910ec007f34c84518ea1442c3031abb5580868b14ebd7b9fdd704161e379c409c169cae4769dcc1fe5aaa082aa18f92d34aadfc9963a5dfe9b4da8d11db13f9bc88acae2dbbb9754dd105ea95cf258f40c1924a5ee6255eb17812f251c3a71810f28df35766eb1789395ffe30c11b5f0feff6cee9a260f6fb3ce0636500379d766905aa24736404086fc995a71b73fc6eb85f7b6ad80b6418b4b1ea259e11035c002218f2b515b68eeb17753164445b9d3c4b36e57223f2f4a4f787bd8bbd2d3a7b81f35db8a99d0530b2929a0ffa443a46b0bdaeed9db926068c7c0f0f63dea928efd07a93027562dfb60e3d5d1280ab38d395a4e8297bd314bbafdc9a7a2a22e633411968ab8dbff3405fa5ff70cccf62a571e0006ecf083059d093e5b4397cf336381ce13882c82dd79d1f323fb5ee3a7112f8281fad6ecabb4fa849f80da2420c0ba3b20624670fb6c7b56ee0c5b78fffa4f6e236ef4427ac764d67636959010f9eaddd03b39b1094aa217c88fdc06b4aa8219f44b6eea7341f092be2e63ab0fda2c8d0a6b37abd3fd46b008ccec8ce66324675d339c333f022171786467dfbca6a6deafe4515c5e4cc119e461109634efce3eeaaef622a7278495a4b0ce43bcb24516a0a58e4926fdeae62526437df053cc8a0361690bf5c913cdd6d13e8279f6f4264abf2422e7e5d20850577020e5c76bab91845a095da86eafb424de065af9931a3f3c13807e52f1c7c37103b93c6b7ac264167002507ff926b0350e0d2fa795df78925d9a577a73026f0e7de33145f8311dce8d5d6a302e474a5602ae48e7d3b2f817291e4d0e9b7194540cebb9af0dd096f00e9d05e8e5c9ceaa1e930e6c3fd02fee872d0b05e9e42db8ac78a4cb34b249c2eb7b016178ae4732f737729b9413876fd4638fbfc8688eae2f3e7abdb72f6726e3176f034583eabef0e2312b6ff462305d1a74ba22663effcf0a7312004b4fddc0e31e3dfbdca8650bdec9ab85837f1a26b52e7b4c385880f484b09e197a04cde036c5e31a2307ecacc6ad06f00ba0e262db452e2579b2f84e0a3592882dda74d1d3ae3debb3a7e8cc234eeb9f3ffea1197d7fd7a5fdc4808f6309038d3ee76a638d646ed3d9f7c322b580fbb1b3646314f7fb5e661f98ea80b3b48362249e8b589dd142bf584e4df5b9e9fc4c08c80a042fe0fde9939480c50c978918e3c472b2325fad76a26be2f5f36e749c0dfa271af38f8ccb4976895751011dcb0b00d7c882246241ab2b12a3653d1f87f167e0f2dcc5f4dac03f9ed3e18e34fed513102bf022f18bce1bef927321c500683f06d5aa439fe592618853f09bbff035d6b6bc89ce6e9ad2cb6fc9552807e4d35b5ba51a32059c68bc271bc5d1f23d37972364a693d308bb05b69f79566164aed3b4bb8db7e6b366cb1a5b5afd65c27321b1ffbe6ea91ec18f9a1ed266aa61d0b63168418b10f93a7cf9aaedb839a077e04f838077320f86ec1a5f4100841798f975f41d538820131f8916e713df29b332735c7bf7c49bf1f7516f1d02788ee6c2a715a6eecfa258c8fa2788939b170f8f57846dcf1978675e6e8d4efe1daa926e3a134ccbf299ab04ab85f76b72347c37757d87404e3cdfe68c154060319432e48075e8fa7c40bed0afde1a146283501c447203f084632661c23028cb2991bcd4e23ad2835171cac84f3dafd55084633e0b5e3a1e69f4609b617280d00ac110a6722c2de35b1ba373b4cd40d1d5c2fa14beb4e92fbe9fac067b299e628c72cd132dc873f0f49fac873129f13b1cc3cfa3125340822a1f627cde188277d327ef44085b9906f5385224567fdb70ed64ee92657b6e1b8fbf513c7b60169f0d629779313ea89eab8f8bc3f664e6175070cba88b293dd75691920f2c4dd2e04610b3d7a3ef05fdab53361fd5c0193658c9f004a4fccbecbca6baefac4aa2dbb3ab8fcb428a67f4da73b17618a2f312b644158952ddf230d597fab755af11b15173d19f476f405d6b0a656475e031aeaa19560710457f08124736084f5254a8087879576f347e0a46b2d928cc50203393d855f38362114f92077f7ab33391a623e0318941bfb22fd8c4d16868718019af8f9f1cf882b89c5bd03cb5149c47bb578ff520ffb0a3709692d61a778e74b9389c7220b09735ef03015323fc7a9381cc8cf58f434de29dfb91b4d79d7616d205829c16aedf7887a73d48f9a2c44b3cbdc8e8320f450b224a4f67c20742dba7996a7a5ae0c78ce3d05cf63b23ce9690f9915d19c4910958a45f961764210b5b4906536e9202908acb207152760f21c578fee0808a640d28973ed81188255a047b5d47e86b7e0d91da7b73fd8c8ad30a2fc773ff403ef35f5fe06e800067c10de7d767cb89d31b3c03757cedaf8049f67d9a1d23aacc59e02e0dfb6633af845313477c83a526f7a1be02d85e8e843f98b0bee98025fa1e0bc3b22090d3606c55c98a3afc9f7e08ff88a73274c8e4a8b6333b2b9e4d0fb8d70e19fef6c956a741f6ba4ba9fce4e6384147523dfe95a159bdefb594151ed6397b7fbf44e70351def79b1590997d83684","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
