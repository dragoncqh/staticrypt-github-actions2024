<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78f568bb1ab6850d32b6a4055f995fd5d47bda9d91f24c4ce25a23463573b026d0b0ca0124e077afd4b2a69aa16c0d2c2605848de29189284533b44fa379ffd528e7430620c49d620118cb3e18060c69e88b9eeeb3f2acfd09b84609295931708081091223435140dbc3537b447b9753fd62eaba0ef89a479d08e79a0c509905a486cc6c6f21e6d72618e91f75a81526c01a5645c32dbcc8140f41690371c9d56c84385645d79d0a3968b68db8f0fda74c9a7f51672fc7016cc53e89ab5fd8e4c651af8099e4547599fd71b7cd444e6f5e215c6aff27677c869f4c04758ac658e894f5a8221b57ddcbaef69fe19c10f45c4e8c7817b21eb52b81b6722f9a25326c04751efe17bb2484ea36fcbedf10a1c45f9c3ab2fcb7ceca862e9b63487ac0372788d481bda7068fb982fec8f7043ce57ab118bbc702eeffed6cc010363036c9097b2b5cfc951fe0de7955ba60c05fc1a44dd695ad7aebf02ebab60705f2fafd7a3fedc8052ecb5cfe79651041d20e953081ce4255ac51a36b450ab509aec346a7f21697c58203e77656ca4ca338ceadc3772db3719591033061f9412e8df79ced563a7afb09c1aee736c7adbfdfa9dfec13bc27b50420c39066bac7e0ae4eb5202b6a3ec6ed071b598ac74f494d14e5dfa6e18a2e1d39d3cbecbef03630939189dc1cd68ce13aa9921df5993bf2ab17fb55cb727c0d0a1d697f993f63d9b3d7d1d1928dcb261194cd7bf8da313ce249c8d1d13069b6a661371b99881274eb15b14a462ae46ff42ac9cde4ae06dcb154208cd4c4a23d0551f68330de1c8c817ed43f09d0b35a04faa79bd96b7c4f1f28e7100c2f5117002241eb16f55e1aaded6f8cd397de055cdeb32ee64cfdf7b9b9e9a6a0850bc8bb02e777bbca98b2dc0a6c9ad92dc6d8f33ddaee0bed65dca1dfd0a651831de1dc511bcbaa1875cbf6817b7bb5fb1956d9572512f10d5e552a0a4dc64bc98fc0c9e378beb896452ad67f478d0014d181f97402eed7decb082c00f35219b65583139310c73ec374c522263acfb903839735489e0cdcda454dae27bdd87dd03ac9beffad60ee8a1f540f711502f1e68ade008a04fa4efef6f0db7c6572380c3c76b1c5e46a85d15fee1ec2883c31be32dc1dc8e0bf6fbe2fcdf35afa4f3c5c76911843b0b3e9566f78e6d990d4691e600e4889cfa0276938f6c27ccd25f54bfb3c4d936a2212bef0f0cf99c71445e17480df620de0aff154cb88ced51792498e86e586e88b29957bbc980ad26e071da14121b1b9afc5ad518893ff96beb2cafce9e1d312af50f691a8aa648430ea1f01839eb36a2a63a8754cf0a7524db9b75891a611712e318108417ec29a88e117190768875b6bf120dcefea3dc511cd99d71e3eef7de29492c6b2e628e83dfc9e58ac89959a7660747b0838dca002156ff2d6dfbec20d6c58b107d1c08a0182a1f99e729e8796cbb2aef78681f078d05bb3fa4fe9f75e8d53f2bb88cf5fa751ecdcc3de88703cc82a0a4e83c8eaca61d7457972f192f7cc66a6debe5083b8ffc63700dae7d4afc71b73e13ddc05be4d2be29af15889e64e8833fde677971a3f1a7f278548d18dce1069f76ad9eec90acfa459025d6925f36ba18396957a3bb53c923842d11d17e9b8b246acd830e9d8d61f1aa83c2137e4c0e58ae49bca4f79cd011bfe4ba72058e5cf94088555c4c0bff9fde070794124f762bb3fe350422744ec8019237d23c642ef75d6544227941c6f91b617f50fa2e1f5c24dabea588e3c258f2aa19d195823170dd7c4aa95762cd50dad89f868994816718ba4d0844c432071cd17df9be3e335487eccfd750188b4b1c3cf61af0abf3e6c005bd9909b437d957d227fa55388afe5990843289d3cb331b7d1d31ab0c7d93a4b7290a41d64ab7ea5d3832dab80b3638c212ce4ce965d57084bf132faf7c6cfd7fed7eca207c52da14a3cf1a72a3bad6324ec7fe6bbb24de3621ba2ad5f0bdba02ba8cff687f29eb8e20f9050936919f1246a8ed7ae207525646ae978fbb75c8e96542a7f57941e5be993d295cf51383cf4942f44ac33f3be836d4538a934d8de9914ca27a32703c11118699cd788407472fc4b5f9537a48b99e583bb99b8e9d3b09cfa2bde75adee35922c2e6ef2094021f2971e4af6a9c8350955ef4adcd0e405cfd72a9d04227c49758f2a34280023f79f5ae83e3ffa1baa9150e2d8ad60a45a429e8ae0be2bb7a35e25d3b5e915bf019ee3bbeaf67a7e015d62096caafa70eacad02a245b0534108e5a19176010017b38d5220383d518d3dc83da486649c130ec76ac092a6f42f27f1603f6d3703776344a13da7115423d92455b755466ef10f480df4598d4d5cb55aeb1a5630729191306f7d30be9ea71f4bb4ab3b6a5e8356b6688969b6f78877e28bcd52b00fae737a0b7d14ba8d52d09e4fe2f0d3e08373078d6b0fd5a4ad0e21153ffeefa5101e726a8b21a088823c1083d7f85055d6cab7c56b5ab5f533f13232d0e1a8765b863850074f82ff4af8d09d0ba7dc3148f86a34229a4d344fa72280bdefb51a934c0e2d2d4484979b02b45cd14c8b0495f3ce4060b8f0ad01e4b4f572dda440822ba1261942085062c98243b6f8c8848573ffd0bb9f093b796ebe48ffce3e7166fb6ca64bf245ceaa5b24381187821023084bb4f83de010bf79e96f33906d0eaa4689bc006c94b74e1954d8685e2fc052dabda673ac5e411602438d38a24df5e72081821904d724f39e4ff6eace540a5ab0b43ac1ded3cc4cb96261f0336d2ad0d9b6681b8f527a9fd0bd2b94098e0cc343b20d7dade397b92c04456ee02515a2e758d70b874bb6a3b4f22cea9aa2bce71341e7db9445af6ded7e1b44fcf6d2e94d8ab55af791dac765925bcadbff2452c110ac09c24df1730cd96d5ad8e1089b63517034bf824683267437be721f53f6ecedf482e1e7521ae7598e5d70accf7d852c17eb17cf5a674f87e6b39e06995c029486403621ae465d627b9ed431e8210ec9b0b8aaacabe74ab7246f0a666af2096c0427ce3ba76becaf9966e8f346cfe13774e3caa8d1a59b0b4b3329d2c0ed573f93d3fd9c1310b0fdd584f90b63aa4ffd31fc016b0684beaeaa77b944803e63723d8254f6dc7c5da0717067c19caa6ea5a25e1a78472b59b030494faecd4d8cac5e075b8f5eea85847a390bb6b7df46c253b2d71c7168ed3f5f544d7b436e0c6279d34c82a9c2800347aa0d773da5f6929bffd848213b6cb189359645288cbd326a704c9f68bf3f1bd8663d67bc53bbae0f99ad4f950c91f3f1785130d28e4f710d3b1db4b8334dbd404e640259ae4f9a6b44470c4b6e14fc4db0301071ab6a46a3b5f8d2d38157fd20b9d1e9ef98a0760da66089e17f53167f707e9145cacd343c213792b7e56c04518012a7182dde6978f880b582b059b5b4885a0221b316203636ea596214b75b46aed9ebe7bf73b8fec705f571c006c567cd2f04ad8e1354183f23a86b923c5fa231fb82a1721d989c2a31c3296c4ed52aadb00a4039c939edc96569d5eb15e6084a624e1507ddde37abc50dcecb2400ceb6dab49f1fe899b667b922cd7fa55c6649b8314533ad1ba24df11b49a0611f90f1e70f29a24f7fe9712f184d698b46ef5650dec16845e82ec796336d2f8f53ab0c99488773af55d92d873a36c82cf6f088486285bf4a8b6188285bd38ce413e1d967477cab5ddd146806c74f88ded96c748d4d1bbab2e075b6efc5d3a530c329bc5b4269f1c26a310b5c6f11dac7a3746baaa23c3bbb3e834dab97907dde8184726bdec215597239331dfee0f626eba424548d31425cdca2587c61a5cc6a00aa77d5fcdcc79a4b45ca9847a2de32edd93bafeac4794b43652c25893909ee5248e30bb4baa12871a534b6d6f3c50b1cdd6f3692b3fefbd5c0464a7ba7d44a09e5a27a1e07b6db91dc624fb57a5adaaf1323d69fdcbbec8091094f8fc4517f8837021283d5762db51e353577e9890e9ca88546180631b3d125d9fbaf30a8deedb492b2e8f697f50014588cb69cdd81254a8f4373dbe9d48527eeca5e0ae522bc4d29083327776cdf7677f5f09b60a3f59addee843ffcdb59255e6e6832a42034c5884919aab6a3d9158c8f199cb260c8714dd8cd1fee582d4cccbfa65f59bb8e046e5d49e912a5e830107cf834e5d8f497cc684787bc23548b213317633ee45dd58e901ca8b894cef4f70bacf19eda405afb7da8454be41cc46aba67a09803ab26824d29bf3282c8a4dfede0353097e84d1292619b68a7eedd3273f02615e3559dbc7259868823f9680f310a9b57f17d6552dfe1f311a40c9ed625798a2144dd4b3888cce759508c347d32bc94a18fd842935b75ac072fb4cf52f9276b39eae7d3c3649c0b1eec9610f91235d6e3cb16f92f0d1d75316300c7beddab6fb308e58a5fa7a4eac003d27567a04b4d205275a03f3f977731032b327cc244f92a5449e81b24cedfeed67a3b63ffc2cb940a13d91e90a8b398513fdd207b05004a6855dd4e3f09835f83552a3cbc089e3169a64f2290168927c486eec7385e5a7a44b9a74b7b548a713b347de0e8f4f19158d545d95c19b7c9d173f3b884f89a38694c2b64cdf647a9275bbe4972bec0293c988d2d5bcb74e7664649b283b587d946af6169fcd063338eb2db4b0850cad7a74fae0ab698526da962d80edffe683672177818c2f043dec66ec083111f480a69ad68c63c478e122b4c12fc8a2ad53bef96178a32c317e168ccc1a292aed7746f2058cbc3964b3b038012ceab4b66ee9c923aa8232b82813d29ae9acdaa8035ee60e661fabb12bbc94930a0430fa39b9f075133602370c0ec34b0ec8bfa545db101ce5aa093ed5e66bde5e60e950dda3c5acfc4409c186ec59e4b4fd096f94cc03a8aed02ac979563ae2f38aff2090b7ae0fb437f2c73304100d6dd0092d9df00a0d52a11028371e5740087942efe322885f932b6ef578d0ade2521b2a5ddacf647956619b3f7fa6a23b181b6afca26333896ed13afcffbbc8c2844f2967cf2f23c116e952e19c413caf57dfda64ecacb21a0bc3035b47c9ddc28becb5062232d548c313f0ac65df1a4908ff7272b7d96775e11bb09c71dec661f3532d28c3477bb46af05c02209ed234ffc9930ac921f43e96053c216ac4c61e0e32e6b315a3d002e8666ee73b8c54813b62944a90a94b334f1f7fca0324b52d8f66b4b4e0d2b9ff9505b2fa10a6dcc174424842f1da1de60404ad39d091f60a9a23917bf9d927e275d9b15da828b39914df5110ac2b582fab3d913a0534b83277db8ed0f9ac4fb89422bf587cf0917a8248fa477a461c28d47e56e5d54b5b0bdaea66ad445ec2f92d5f5f1f8acbb84b79a3af925f6a3ac31abf977f6ca66c1b135264dd564866c66dd1a69c28e0e87343b57904ad29535d6eaf3b0aed993d4c68b2289d6e403935aea8cf3e993c955fa91fe825085f5f51128c1ba9eb06416216d4b53126b23ae6bf12f8299fc86c59218286278586484c1b146d5a55cf99b9eebdab3735d3bddfc392ef9f9d3f2c65651c31b322527638f7b79adae749f645b7920aa0cae8e32e3d1422e600075ad18aaa3a8886079fca85088ebe810a6071c4c4c703a573e6299f69a7f2380a2076bcf1cda38f07bc3ee0cde1d15ee0ff5d29b919200a60319ec35aa1997dfbd60b459e868bccf2df6b81c255e2848cc00d6c2146127ca24b96c65919014225cf81398ce97071f856961df1f91c2b8d01a83bbfbc1ae925fcbf06a674bae9b365c2d678c35bf58da129594cb2cfea3f6b1bcc7d03d0d1ac60c5814100f34a69c987172071bbbb98d13851c690a8014fadc8eb5bd0c5eaa96c1139507230befdbd1af1e77961dca126051610fa1203d753c40cc14fca6c7af23017cf60c29239f14c231ef38c2d51b2646cb393a8859cb4ef5358c7373ccb0fa584ca1782c8d9e82969a4b4a81b9b019bb658167ba1721e9be873c18f4af6faa9eb6c7ead3126b1d54384b0eaaf20423b4139a96a2c0170ce63f5f1a9d34d1e6734855ac6deade411446a6fa9b2335ba320fb446b9bd7c7ac07bc70431f238ba73862d3ff1eff1b653bd2735703b0e298415c778cb73d1dc5498e1a017eef1ef7b3beabb272b0a7b4f80be854d5ebf43a59acb3d3f680db3fab3f0419630f7e47d92d97c002eb4663224ebc2ee1c25ac4325b8f37f0abe50a5857b54b25d389b33bd0a6fcf3a584b2db44aa056c305cf411979f6f82b44c4c3ca265a391e0bd7d024bb707a539518b425a999ec75800aeadb4e455c7486810901467838ac17b5f5e68ce01abc2c0f39087113b9bd8d78e1ed5d1750445ba7bcac923f96b008700a6db411f34f7865e10f7a6834d3aba81265c808496d6f4026591d54b8943e8936b46b675187a1e1b6b48bdb76765e2eb6d4d442c86536e5d039e5531aa0a451a07adc76d3336ba81fcc9ac5304a4979be3c918b9adb19b995ea10cdf710171af0cab96722e548733f4cb5ad512fe2ad17619c9255bb31914ffae4fe88ca1092cdaa5faaec418d934187e22da3cb30aaffe3379c70981c9d0cf2cff0d9df7b62beb1d49641ea43ab077ed3d09387f904d65219f3b286b3edae8456202b4910726ee01a2ca8a8ecaca44cb8feeef9e06a4843c79c94bdf11151b1167e2edf132fd146256505c9359d8303e6d7a0d5d7fca61f1cb3c562246445c8678dc6acbe902e93b57cfda8276a9ca72224def9c666680ff31fb171d8889d8e8672ba2d65e83c4bfc7f55ec0b68c93920dd04152c9f74277e0078068e8ba7c537f4126e335c23851235a30f399ec39d81f0d61f12851f297f5d28d07b5d6b40865a07be6b56142e2bb80cc49a9b4cad1d7763f2bea8c8a159c62e623e74ca8b45a8757e93bc6136dcb9d6309ff03ae47a7575911de40ac3c0441f2cfe70c5ed06b17ac1e7910cbe1fb0662b825745a040bb655e2df7628ec502d4468c561e51f70d7be822287e2d2cea1adca927cd5d495ad129fdd452daf6c1191911d506cdb5a45132568ef5c18f0bcfb9d6a140ab9d154b121cc8ea0fae33f4f390bca4818220f05a1989d23ddf935e1932a23510b0e8568186c58984ea0492e755eecef6d61662613457f9a24b7c0c82ad8b29ccd9bdaf0c614de97d5f70368ae46c450b78e3b3de8ae07996dd5300b30a9b7993e351bf6cf4a16b9f2cf1cd3fe406fc0b55dbc4ef93e8018b7ca5117212bb2c95ee17fe760953581aa22f099cec87a5cae96ab31558b4355b780f72dfe2bbe7d0ca5e0a378ad86315204ccba4ff18d98d29802bba0a9ae65411222acfd59d6cfa96b804d6fac100d0ee15e32b2f50e37722f2c316d9256a93094cd87c6f34c9b80254c6dc1a292bb6817269c4d54d0994710a95abc9473d8220a66cb3ddac42f24b7d38a4dce25f76e38b31086af280718798a4b00b18d2952a54468b200c389eb3e6641f80b7ffa475e78a201d0859265f59fe88917d177020f73895dbb3ad4a3d57b3aca4558335da8c1b84a037d0f7b343e89eaf7f7a45ff53a7da6b6b501245dd4e1ae05ac29d1cde4926a5021695f916b1d767f0a7084843612a769c3df0c88b7c1130f4014b6f1acea4cea406bf6d950ea41bbea355b9c2adda85e5d2aa7e721c7379834a1c4c2d88409850b8c89a3a0304907e9fab7b466b635e0faeddae414ed71ac9a28917e092487bc4c8f26661d420aa695e6c23721115d42a57c6de1457b99ed58d607ad0b01095273e400ac9c949a847d4e012f69a028fe505f1b44ae8bcb3f13afaa51009c1bdf002d7fab0b57bf86e3a47cb97cfeb806d23976cb4a7992064440e3070ff8f1727e22e7623770d2fc8be43dcef795f9e9b8f7107daabd0acaaf27ef6127b3ead12b5bd9a260e2cfba73489a436386d267a224fd4e45a1e1fea28f1225af3452485aad56cadab6ade11ba36263d26f5809506594657422ab27b1f750756feabe090d7d35e06949afd300d97f188a6933b0aed561504c3bbe6767e59c6315a3db183563ebb1622ad3d30e73aac1c7573402a1439554737c4fd2cb8157e1393efe95e6e6602b95fc0c425c872c20f8401018009286736cc4372935de3bed4192d73bc3ead0c0a64b633c3ece91669683a516c0e6a4d2bac964ba72506dab5cc55ec74e5218628b6adf9f8046edc71e34503cbb56e8d5f9915a3dbe76286a13970a3c9ec9adfe5ea211b383c4676b80e155253a0f97fb3960dd6b84b515024d9a29c6fa826923e822a732198ea2d93c4d410e588a03842a6bfa6ef59dedbd2c563be75ade8c15965748f74040a8d48bc29b94ff1f07d27636431063ce7d38fb7456fb7fbd20552903d520aa04a891de64e0b87b404f09f0ad88c4d172045991424a171553fed2a901fed865aa4412550c3cd07c95afdd8798e85900d76e6271a92c23134e1e8b150b32cb9ee736dc2fd1f65cf7f70a388afc9f493d8ad3da4d3b86f8960ed3d9e9cdd6b0ad9ce3f6b4e578f395574d5ad8ec717922ed05240a51128e5427c0edd422b9b740069b98e2130fd2ccf4bd742498eaf9d0e6174ae1d4074cdb801f2d57a013b6fd9f6c4277beaf9351734bc6e2d8e40c1ffd6f7f41f19385df5cd1459a71dd5ad7ef468ab5a193066c63e4f4241129074a3d70ea5e6f279491a449484dffa3ca9834b869c9f85538454088d472937a5865db0e445675ffa842f1a09d776d26ec956b8524628756adec03592984f360e76cb7ec98865c309c7a5ee1d98912a69eebc54eacd907b6280f45ecbb21c2957afc30f8332dbb45a2e5b8e3bcf38871c14d193638b9513252b951d8335d9a530dcf7473fb65f93099c86f28d20c44cea1c3e576a0135f22b629e16700f394eb5224bdaa40df7637fa5294b2bdbf8e9741a6ac810588d51b1de29390750bcf15abeb8a966ecdd8ecb41760da1a918e6241105a54dad4b3681e51ae9e22fe8421b65386bea1f181d631773d373086f66be867f453ce6f1259bae8ecc6cebeae8f0499098653fccdac4cb011957a6b92bdae05edcc3921bf82ba48ae82c28d9ffc4a2ff231fb1967cac13db6ac5ad97947431c148b3c476db47f63ebd93163162f4cb2dba9d29a45d0ea215c2f99b6ba9f1504a7c664153fc5ee720037ec0819c3ac0a03976988a42dbb75987ab4e6db1b4b6a48939d05c4b4cd79e4820d5c0998002afc0b62671758de07cf123c2fc2ce11870d769ffd91511717735e86ff7200d604729de62e83fb0b52a3656e4303aa58bd870280e3ca2cdefe0e2616be01dfeeee80c5e53f37c82079d8d166ae7cb2a02ff8b6e67093656a6858c3087d4ca44a0ac6260c4eaa2f079791d22377dc1821267c4d5520a14426126bde2e901564cef2c453f5b9926ba0d5f5a604637012186675fff47a90cb9e942bf9dcfe3d0f29718de1737ba8bbd3efb57ac76cc98a42c66aee360d486715dbfb1d65470f8f5a576c889bdeb3b27f6dfc1009848f7436733ee205f9c17b979c71ac2cda67f6bc19d9b2da26902831ed0aa74067f04986eb6c7fafbedcc120060f8fba58fe58e69fe53558189903b5caf9fe311555821ab58e2eb67a248ae56bfb5e907984507e632f4270f1ffcb4c0b1a04f3f598cc17025b779462d70fa74201dee337e8730a96826f199441abce8b6ed09592590942912c384c0205406393b5d2cef99429e06d35c127279953febab078f47042994b87d4df368557fec4c5afb52288bf7c06f138faabc347905560995ae48b045152b34a8f399ac8d269aae88ab7fb4ecbe94b2152e00f22d16de3ebabd8dbc683734032925ed04c10aba4c8805bede334dd8cbcc516fe48b6ee0715d03670fb62ca1f3c3901d1deaa7d7a197542dfc1a51f395d34d6291ec714dbd6999b3283025aca5d403a626016b2349c4f11d23a7be3165646e04b903bad7f4952b929cef4e7688a759635e21ffa85cbbe239d0a7558e1ac77140e7b6e5b433d276a66c0d73270579c9538647d6876d81636854bd21f5ff3a0de73ea27fde7536917ac15d60c31c84b14069aef5515d11e231b672d8c93cd6e20717ac030a6100ff70098eb134819eddb6b88366454c562d4738d38be96bc6ae7641f15098168c7d78bda7a554ebdc63da9cd32c35766d56f494a63649879bb8d4e97e2fe112545416ef06a7eec000508f0f254b64bbc12d927fb21aef1ecddb636e6dddcb2f9bf47b7968dbcc4f108611ea610c02c50d503aaae687fa693aa02592df14163f19a5e8e9d06e355e3ac3cd7b6a7107c238597d0d0fd1b48345f779ec1c120be04294960c7ef290b039fc1709044f892ab99411819c2a97d90a19967f7dbf28c16f657d2d062b0652f6c4d493801f19fc9345bbc962624fa135c19f5a6d3fcb64394c422ce8864e1367e66950144df623fde1b5cc1fce63e9016a5aebc1a0a949d2cff09e328c94d1f6de21ee335d6a774b57af3c6fb4a7b7901bb5cc799715083b4cfa9fa497d1661d958383bcf2206d5b5a32f36cd2b310d67aa587178a9d076a3d89825576b6c66d567f58fbd8f17c8a580c7c90ca7a6fb4f5d5fe58003cbec9bada8b3457ddc931b45e1ef659add0d155c1b2c0d6d8c91ababb4d0c7c8fd22fdc70647c1471ff47dd9ca6b7e07600df10b22dec7d4568dd88bdf82c276ff82c68172415f0395207e8deaf3954572b88087bfcd9c057ee2f89c21be4d7177ba2d89891c93cda47e859319bf563b81e5552bd38417726ee0aa62126f2c6d3b26c086cedc7875b637a192bf4ce2590603c471d9f5d7b72b9888d3a86a42ca7b9487d7c4c94d7c4fb8cbe5f2adacc7a54ba014b5d220c28e457f981a2da45b9bdba54f1b745cddcc13986566fe98e3962f4d29457e78c1df673e596b98b129b220d4f611e049f4a274284484c79fbf848c9537322010e2b07770d52be940c1e13f7e4f1ba20691e789bd22ef725168477c24ecf416d8a8e00b429742561594f783f493f053e01d8c26b77ee5f45a3eba43c11d68c833672f75e70409ab1514167007960b46478825b9acbeca12661578fd89de3d0f72ed47d40dac5274691473ffb4887231fb68009d609d9c3f11792f63dc15c30683f21436c4ff51c9a528ffaea1e057e4320368216705da4b8a6f7da20e8212153059528c20bc26e3a1be7e95e21cce3628a3cabe35886b3cac7c27711ff0301dfc08dcbe073838d68ecfe4bd3875d535dd1c6b29a33b9e6b22da5a909dcee5d17dbc6aa9f33486aec5c54b987b5523a09e77c348567c74e527080c27b33732e5ec55cf3cd4c97d51c40f2c26725fc6800de524b5b7b59469c17f9cb6d8b6e13804eb3a70f84023331623a59a84922126b6115a3587523af8a3cebabf03905f7040a7054b12cb42369e87b35a020f326f9b09036a9f29b548f35d73e4f68d97ae07f3c4fda503b89bff32882fc22f979ee964168e4c41d750f9162281ee75e5c967ba5316bb7bc8a4dc76f780fd3255ebfad89dfffec209f1649b9c5d5725262c773cb3ac70790810656dff81603196212b3eb10554b07d0822984aa3d8e281ad53e12989993c68d0f77677cd43823bfd0ea7e9dc4f51c9ccc5ad1091661f8d1cffdd93c8d0b3076288385b27e4578f75e02ae391415618b4227b6f3ea8e09a5fb5cc5a6c0304b19ac0954a449dea6549acdfacdb48fb4a7b9029d2036bddfe68740abc8ac3771aeeb5da5f3e326cb74ebe31929424d46838d1952e882cafaa2bd81f67bd006a43e1f5bf0a892597b43255fa08370e838b02c1ba2e4c5e08b7c3530fdcfeb12c2502987295f32d306a79b9298df543154d1e2cafded89a25e06f7abc8fffa7a04ede905632ff4dab1a2b832bf2a2b3390033133cd7a49df2ed8865de4c06f5a14237401d20d249175d1757a566ea6bc4654d3e42386750cb4c4a2f70ca460029cd86a73a7afb40aff4328f8386be860f92f31657a708fdd8fa1173169e04737b97a9cf38d31a7a376a602834b371bfac0e4dd3fe9ff53c4b3954d761d219aae3ca996217e2e8d5e1b511c11c20ccd94b1cfc9508ff28d71109b353a39a144488e90d1d68dbeb34049d113ec088811abb169a9ac5f6ef95de0d25f7cea05b63234d98509a994077360adbca1fb71e5ea39f6db44e20a623f9e175bb53d6162711656d113c9d4aff1b4e9cdf6b6ac96c5e01beefb31bae112d031ae820d8e613d3a3559e5b5e6ee3e1e6595a31ed58d86ae9d5cecf412b0d9802a3e0881ffa5a9c5f8809d4bbac46963def1b7704d7ed62903a198f40e874b7794bfbf23a9b29bab7c169e822119cc7d2dbfb509ca294a3e014c288d02273c7fd2e461252fca9dfa96b8fa16ca126fc027d6ebce1bcc58110e6ff77def83aca0a547c4937ef684f2b945b50045ad0ad0a0072b4514f3f9df55e65d93c3b09b1cb07efed5001d7a00482bb1d8a9175bbaca57ae764dfbd9dd523d84abb3f6884ce7fdda3f924240340df2883856cbad0a47af03d79c55a0b071fe0e94d60a11f60e517fe7882f740bbba88230cd5695314f299d02cf3172cfe5d777b73d07960861ba9c5624421523e7c288b272d83aefe9bb183b859c9daa2f2bf663c76e466ce5f7926f77a5f692e76dda282b3e9f591b15eca81656ff0140b5083843c0decace53293196567c61c16f30f77030651433351b0059aeafd83e0ab23af46e3e4dbbb32d657a6b1922371ceb4710dc577aec3fbfafb0eefa0a6d5802937ad001d4612c1e2c287fb1505c39c65382501391788af6a48cdb09897e463e0f9ae8015d8fd3755d34406be2835f1e1713fa3f3d8389f9e042a778906c82b3b997b7ece3850f31446f6902c0aa747022d7660afd3aac77e8c51786e6a2efdee0483da7dfa1c0804ca07220fcb12e84e43a819d43882367633af7668ea39b86abad56471ac489dd9fdc99ae410b3763f01f9bc9fe846053bae162718f59aef2b824c677c16b72ecfd6aab984ee5469427a2cc07ece57f9c974f4c46c583e7abae28c9ad6f2580c9584672492eacccd0bc6e7ea666619fbb1834b19149228bd7d052b0140c2a6651cf98366a36b7c4b2c2a15d59a28016ccb677b1b7ac9036173291aafdde58f4b68e7f9f9228c43dd5d81f5b5dfa868e6129192a33b513b762c672ced84b56d27fec12b5be88c04fedc6067c209b3273c79e594858f5bb10a7b059182a79a7ab921962fc545d274ee4fea07c0962f2b1c52975d6f4ff04e8fd21c1e39cd58fdf49e7823d8dd06882287f0a6168f585469dda9b39ab001cb2c46d5b55c8b76bed4f887e6d7f2f2a241ade14e2ca51a19bd10e26cf956865e4a157f86958ea79761e873d2c7cbf9b228a7bf16300ad1b992054310b68ba51ba651f4cb7d4d9817f2ea8392b59fb57d186b40254b615e556b3ceab286e490bf5dc3091514dd235ee8cfbaccf8f0a2173c24902c5c1a3472c36e4e457f151ebe320e8ddead37c6b298155dedc117b24c0fe02a04a7b9b3e69645e79527e468567e408302718d230a579a1e3a32f7a1a83cddef13fd5e01fa98276e61e6197a194f6c8e8d7871b9f7df01cea48ae7a8c7ce912f349e354b35100559c8e2c89650deebd580024f124fd609c11713e411d463883eabd961440621855a2027a178162049247fd0b1bc6a8f4630d0bad1bfa42fd1081a9d28dbe4e4253a733e6d0d8812b04a54ba31d64521a2ae564327c98d5cc2731f5d461667e80c4da249ea729fb8863dc74953d3d5da380ee23f6045713ccaaed724faba9112229df2d5e1818b39d98a0d810327c9310debf25b16c25e5dda4f9cb982ac8806ab58578e052c5fb575fc5c5c0377a9ecc1c3ed2451501cdd51f34c1e53cc1ea533a7c2f86ce8edb0fcf3696d8158e223f8be96d3a4d6ea45289f303ff14e74543e4f9aba184c240c5c6c477b9e37486f3410d8823341f3a491d628228115146a0ecce4a059001cdcff525196ad2b5785b18508d471046cac1166814806ad4d924408b25bdff3b3b3479316d03006b339dbb2c2a16754fcd843fb6b0cf9006e6a010e16b5a18f24b23f22f47b8519d1eeb6fe5fe200745991c1569ba655811524d8155e50b9c87423522bcb070a5be13faab82eceb88c7767a3546925e8e1a04957a065e0b269cca5abed7abf7ab0aa263cb6961627f7e772dd484c9f47b77f9153737f0e255f43ef1779c1254b9e11fe10e1ad0ef0ee004dc6d7646ae82028307f4c128dcd58c835275a7446a03a18b43438a0f2597b7d77d089e933ee428d2adf9671fc5f4d0f5c91f59e08c608072ef5f4773b53a94c65e62b0335451a672e8239b4ccc96d0ab8fd454e3689194b16893bde83cce1e715332e3b12a783ff11a41fe8d82767f6051e30ab7891b93e86dfd7ae864e58faecab212a3e14d4217f9c90b4bae5c52fcedf87891e8a54d22774040768e792012ce1d4786bb17d187e64f59353dd0822efded428e9cbe0d27840f5e5261a5c480632bd6c6d06987894f74e14dc1fdcdf3f1b4deaf9726e2a01f21b0e199b4c69985aee4f03db4626f5a13dccad6ad832477faf9fadf99d19a3f2d134b8197b4aa10affb037740aa148ccb1eb62877d78c3b07d099e15e6675d8a978a5f8650b6e14048bb7ca6ac9fce39b7815d83766a43f7b0112fd0c902829e03e6fce39768b5d9006efdc28a6cbb07aa30d16a679a5c622774020d3f7ee447d1661634b633272c983b1384db29fb33e5aa4c68a6506519c21167b0263896b2b4391f95de3a93077081299bc8ff811723b42dcf57be50980202f13d3580f78bc68ad2eef351220addeed038cd8824841cdd47ef863677c7b21fb4bcab348389317c0b509e513eca676b6475da477f416f988b3fe8f701cbfb9742d328b930fe00561569a6c10f5798d44bc767805de3b170618086be154d5dfbbf820fc24536f07379ca8e5a8dc7df0592f481c6b02e1f79fdd2b6175bee79361dc688bc98223ec9dca66b7446a37494f5cadef690715ee3edc038c5378982ad0b96baef9f8a1fafd3813c579ec3e4b11debc85f7344321102deee7e28d991a0a55f4b74cc4e687c0006534cd736ded4dd53844c67b9c844f86e83cc0f9882392d4f9d3c49fb34cc5d439be131621e43ac6aa8c79dc8b81911adb794d31cb64ea5d5efb00932c2b808612a4504bc291fee5b2423b46e8cffb34e7ff10277bfc0b109ce135c6e6a39b07c5c7b4f84ea952016f6ce073cccd754ddc60ba46967153ebb04b66d0b2ca05695c8f0cba5348d71f03230c0aca55ad31ffd22934f98c9da23f903d7bc488bfa1fd7cfb4b229ff2dcb86c01ac88ad30a1c62b89e0df58a0c9604cdc522bc9e27a4b2be13b9ee5d09c152a21d7ebc18aff9ed464a5858187c71f188e389618498dffc9d9ea0eae15620b1018af45ba5345ca10c62c0a40181401c61025250bfe6a807af3355ab2a886982ab85df8cd7532b7c9b068a179bd7eedcac5520ff81dd8ddc12b165a5ab2f74ec4d775af303c3433b3c1211b0a7093e4f87b9203eb64db0de274f2042f2ce75aebc9ecbdf1f76524cd22f87d4078b0922816aa6926d9effe911e972538e971d6cfd5f732423f9c7c577b880b8ee36303643c3e64e15214ee1a8c1befbea82799e6ecb177fb97c5624ac1f7259ce09ab370b718855d81df998cafd4b8bd6dda67db6ef2d1a3c0f88c9778a5c948193518b12b61a39231af0d4352455d9cb973ced109a31be9fd4edfc22bf53ef78d9d31e0eaa24ccb19a7f5c679a535f2d1682886cf34599654939303f056bde8475ed23bf3dd729c64aed05e9d9fdd9d8936e5dee9ea73f97af35e9a1cde657ff755ae0dddab072e4ceafb482c92f3bc18ae8fa411b29e3b76d6843bbd8241df6fd71067eb0db87c2523051c0e9b86f6c948e2e875168120886cfc98422c01ebb6c5787cb1eb119a6db62c961bdaf98bdfaa0bf6d9d53404e80620e6c83b525bb5da3db23a36762b0def3f5cd52648e2d2ae901bd182c3529f888d0fd9308b1fcbffa13a803c38cde6b00c0e7323bc6cfda7df47dbd4c43a465bbfeaaa57a6b4f6d1c2280b9b7fba5151bd68321beb45e5e8aaac9f553ab5678c45eeacda980b950a3b1ed3cbbcbaaa85a95b5635fab96106f7bbf8cd77928122b72ba02c757379ed9ad8fb149d5081955896dbe6a654baf293743915c6b2060725ab9b0866cc9caa25fb40f176b160804af371998a56d4b3ad57b4217625c4ecca71511a7595aea45a1af4cc0e71d1ea7e426fa2bf63831e571e29b4b981e91e8c39fd8899f13397788f8ec515acb7705495cdc53add5f0c7dd78276b0b0604f8402ece0ff71bb38be39746a8e0b7f51e4d53d6f2460ce91b19f813200eb2301b41247eaefd6c3e5e8ac02ae5dda1a72902e86c0ff72f6d93463fe441d4a4093a23dbacd1054b6711d6f729dab5821d517bfe93fec308a95ade05c9705a78c36afbf6afdf8a14b163b68afe81e99003f1c0ae382f2c7c68670bea22b13decb84e7111f585a5f4e7bf40dc1c56f7625966b9e73ef448a5a795553011f28acc59674ca5f8760d7bc1178d3cbbe27af8b9c94e2353d54361cec2c8a371271e99d359c24c6789aac0af75a3045b31a372b60858d69468d633a1e482bf887dfe83c1ce7dc41575584c42d541a52ce860664eaa9d20495cc6e360a38d02f52c1832a6d34c2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
