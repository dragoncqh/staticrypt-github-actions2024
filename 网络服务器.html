<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5342ce5b77a6d5159273fb1aad58eed3ad2ce1e3fde70a57ab13cdc4e87e8f2e9e344a77629ae93b17fad9e00e57973507abce732d7c7c37be4ccc521f308bd331dba545cec09028d0d6b8474101da2bd779879016685dc0fa43ac93819eef5ecde541b3d6c5c553090c4dc4a0a7e8961984033ae839345d15a10089daae127ef96d3b3ce496c838799fd3c495b1522b5a0f4c9244985f36ddb4587dabda7d83e0664717f8bc7d1de289bb61e17027f7d30055b199940b3be0afb9fa98675c2870399a331d16280b5580506655f5fd949f818ce82c7b73ff88f51a39cc7769b21abb1735bbcb3356894d0d38c325af9bc0e158ce6dfc7a610abe2a8d7e63a9ff74c890dc8f1a875b6278b3169db870eabe922f1ca53192167f134ebf8ec69d1c2e9c96c3a77d5546d286428fda4aaa2d7aefac3354763c140d212dc47bc35813c47acf09afa5f11dc7a24f7fc8429405404091d7ac7eb2c31fa259c5c6186666d63caa5dc29e0ca306639977413e9c1af5a62d56289bdbab91a772555be6d6c0fa095a1c74f59e575e7849b4221a8c33ad71c96b5ba388cfdb4f3d76d17146575c8ebfcf38626d6a4d37309ffb640f9821c299fe47893f8622e5b77e3ef325b636f5e4c22b61ece5b1fbe9870b4924edbe8f8e47c9ee8cedc9baa16f2f2b6c7c79622e05b7dbe1ca5895caba5c4986b367824633d0f7b07bccfe67c1a75dde0bb03f1d26d80d9e47e31f5f2545cea697a6249007f0817b6cc6f432b20517d6918f76ce40ce3421cc252727d22db336fa0ca0254c949aad37f7ffc27a9028ec318ef446af0b1ebbd14f91b718e101612e21283a2ab549cc1e624afd5789c318f1f1ca4f94c406072868e23f4e0f2c320756f7cb03720058d0a6fe4aa128cd73cabbe9bb3d0a7813a5f60fd239e806d345e3f294dfb4ee7be983e36e0f4dc37f9c1027c63de9cfd9113c850bee590964eade1668043e1e2723f47a4234a53bc2a87ac94523b6386d10cba31ded4431c65f088f2e341b915a84d943a09baa5021f7ea216435f2a5fc567d4abced71483d66c464746280ca9078ac796352be7d83f68938f241f7734cfb2e79719e3b18764ad9bdd74f4dc54357881bdaa59a10cc454f384635245c24b58ff870fd0b9f9ded7b20f4012316fd4c5f1a60c908ca76fc3c917ab171742d84c3bfe42d461691f3d493ef30e086ba892741d527629d534f1c28c09a294a71a0c4a3eca3ba3dad2edb7a37bd5957967c5415f8c8c4bc0347211c1a4964091d67ff40ece04bb8d3fdf9543a39268b28a23b8b36ae1e0b5a9337a5acd21c31117e94a4b354b2fb6eb3517d75b8d1a40b5f7bdaf93c5249a8959a68ee85b5472c765460e13bcb43a25dccbf84b63e9495569aad2c6fcfb60c052f8cff622f8c4afe640211f8685f052aa953f4e6db4075ff57d13ff00f5705224a4271c5175e6ead3331ba3d7bf0a44f08256baa237c21044bbfd5ab114eb7091304ca5088014247f7d2035d0de43a06834a23046fb915532a5a17eb618521bec9d55c4226819911e31046ee81ff8e35cc2372ded0a544e8526cd47c27887f9336672b57b3874daa89395b99214e4772211856f75eb19de29189c65dc1e1887abb9e616caea88fae1f6fe00812f423a5a3bdf103781f920198f594925518e7dcad9805e81af024bf9e154763e9da28cc525e247e411e0e293c4f1f97832e60fb6f695c2e32410d3e2b1078945499a557c3d9b0b61906a167e47d521d57094ad59289190d811e5ef37bf50c0878ef98cc6101bbbaf5bf678a3e9b876e9d220e6f3feb12014de6993533719e4c3ad566e8877016d9c09a7a6f30ca1b2bc783b0ec7ff2f9a1e278c101813098f01aa49edfb576fa7bd291bc46b70c1024575a201a4f4824b8c6aec273c8dfdca8dca62a3655846c862c433d9a2e0ed09235ce5f0ac3a815074092d3bb516c804f0ae1b720740b9034208a222fdc8f8a5563e9e5288c3f71c2c0ccf68833b33153a5f9dbefcb1eedf95f432f1ee0cda9b58cef1a3347ae2bf2ac81030fb268e8bbd23f65899dbac90e93cf223c850d448f788dcb52c70ced1546e85f24135890c2f4a5620c79d0d0b2ffef2897aff6e4a04adee717258c696ab8fd4669adc3565d0325ec10235e54968c53c20cf962cafb7e0183559ab64c48e1750a6fdfa99c4ea3d6d1f445742dc91b9876c2195ae60bb39798764d4af6575fc55bd224245c4b9769388fa2ce7ae78735a82b204f80538331d5d3fa8e02e98521d27146a4da1c995797c5f4840a264d6ca0e87bd3215731c301244334263e76c05bfeace4c9188dc25671ea3861487a89fd783f3372df0a5094454477d613ae4b90940cf2893634864af4d0d67a5dd9f2882037ab9ad664fb7a399120ca73816482fee63f98e0fe7ffeee80a5efd8f468cc7e4df5edf0d72e04c8b5287efbf42eafb16a88409c15426ebf4db85cdd031eca347779cf3a2c66c3e46a5c7e190e9a9dec361120579b2f91a3007067ad2438fb810a45668ffd10b387c5edbd26db8355bb40a9fb06470f89594cdfc05f3fcf2644acea972886beb5fbd21c2afbd8ea304ee76c54f34c5a15279b505f0680722e1418d6210e5cefadb5d4a1be5c5e36cdfe9e66c54794b37e95e8c9e79aed78da1eb0528036a05d72cbb05e732ca42de1f40a8f1e679f42da020b181fb81e17b22f3b009142374322f0abfb11b26e763d8507584dbd1a9758ef1c815272452cf68fcf6b120675fa10ac0931c065e80c23a45d1b7e5dcb6d10ceaa53717cef8f4dc80f83d0f7ae6c03be94737e1a54845fe195ccbdfdd2efb625378555cb40159cbc5a421289c85c26999c99da93c0e01b804764663ff3f649b3c2b775196566f88aa9294364d793e9530e99643f192210037c200bc292cc7723bfa79584fbf41245aeb6f4b9bba72a5df8d56d7ec1c19fef2933b011161666eb0cfa8ee8a0114048c47b2a10e7564f3d062f5f19cfc8378de14fd9e893b9ef2e5b33a9bbd42e4a0883d8b3b073a23cbba676779593999b7b34718e41e769fac64cb7a09e8dd49e0d1080359090e1bdf62e575190f6f2c5fd51a6fdb9262c4796d5304724f0ba7c4b1663a439bf718eee3232c3da2f021f4189bc37de8a3daf04d769b214ec602212e3bb2885ed4f739014ad3d03c9b583af013673792eaf227eaec326a1956e58a6db5e609c71136c6412083932fa5a6559c398051873616f79fd9548eb88c1bbd91e1dc9734ec3d14a60bf74d70796d69232501327bda0691f45eef1e2e4ee07b54b1ba9ffad81fea0bf01022fdb3e72714be3701c917a4a313b5163d1b0ee9867f061978f515fdd1bd4c88210ea0a289d5cef4a9c114df057bb2c7537f9ad4d09b3a82874ca0779292ae212bfff6440f367b45d543a1ef23ff4a644c66b132b4654f463ee52d72a5488dbae2e3c33f9a8f82a6bd947576ce86f4ff8ad9065d3b0cfc38b2206b8d59bee383ff65770668a05aad610f7962f69fdbbed326cdb9d70574506ed457944ed028384dd72a90008036317885456eae93df59f58eb33ccbf2bcd4d1d365a40a99f150ebe25e45d3ddc03cc22a7f56204e3becb938efe933c7ff2af954de5cc5368fb8bd9eb327953d538b80970c2adcaa9d10fdd630055ba98d5875644e4e99be3464732bb9d4bb5638c6c396d767863f19148d76857d96b098e2cad36f0f7fd83156e778bf90be8e83187f0d8cad5f0b38ba27f00b2439a91984cb0e4b1b886b33ccf9957d39392aef13b6a5986b5af0ab6a136eca4b389504eec0b154777f55f757dac0f9323eb3111280868cef7a87edc05b107ce74c0e60c0f4f883fb79caf4915382cea95b8e157e3d2953d3fc54cb7cdb6fdaa040e9eee631326348766e49349cae7067b31889a6b04ad50c87fdaf5c09c84602c4620a69e4655953ca4bacb2c641589381244ca13bb30d9c09e456bf8aad9e32aa3d40b67e20fbe1ecc9ca6860b9c554c0b24c9a3b1db70d8bf910434e9f847a9ef9aa43dc51ae8eb9f52d3fda472f6272b1de9628cfaf6e5bbb277d50e7d2cc1530725cb14f0ab447e8166db97a20358e825a43362585ffb4c99549931ce264e377412af89c8884884d686dcd13fb005c0853a50ccc39fefa311066abd7bd6d6a097fa825ae6cf6dfa31aebc911f8ba99dec0706a55860062e884f51909a66257945ebc7fd301c0df6caa52b3d5a3f1b81992845910b9837b93f57a1129bdd4260ab38e61cf806c5f8502c110909ae2d891bdd9b89e7145eac33a19b7d33dc97cf1b5371116e3969c0dd45b63a5647171017c99af20c3818c849af2bfc97564625b9759fbf6856e92c86b7734984328404b85da0576ae3a15c6c6891ff4328756caeeeeef959cdf5feea100f50abd51d4d2ed38459825d0fb7821a30dcb6fd2d96fcd78bb44d9d08a8ca4b1942bf0d70f5daa3b1ca0d34db7e8ae976ab0f4b4eed881a250b0254d9823d95fa386523eb80e5be32d4a1999d7a56df932f51fcf0462ffa5c78c5b8796dcf37c183b5f77e3269a47ab7f7227cfaa41be35bca372a399b685cfe3009aa42577d5d918b9adfa7671d9a8e6fe1a00e627c570be89af2343ecb4fd3194a9cb1525dcaa6e3880728aa913082d8e0d605236468c069f086e6dff0153c4cdb074e8906ebdce2724d5d858b25137f0ba73b0f7962fcf878d84b65a4d3481e3e4c2e97bc967889f021f33be286c33b470415971a4432191ac50d6eba3232c0d05e6979d22b1867b7bf5284f6f8b26b9540e297a410533c11a1ddf7717c4209ad4c2f31350081d1ab3239b223dc1b2232bd2fd285db3fcc8b872cdaa34a3badb9499079047de71a8e5cf34c357627f6de8e782145b238f7bd2215aabda45089e274dd58fc19d6452a64a5335b006047346318b367cd7c49618aec51607734e299618eac98b6d60df4c07e58a0d2a190c39d61628e15ab29772d381e9509a9d77ac0b06978583d9eb4c76ca5cd47a10cbaff401b82faff52fe52b442b0aa5847f6a917d57dc6812bc294b70004ea7cf07b88ecd4d4cf3ea7d4d888c963d5f0ee2dd9c60d8c2cb13d30825c2f79f96d3c12f1fee06eb5d84fabaefdf1dfdd8c8160ef8e2ecd354f95aacce6128b0ae68fbe79dea57f399df1360c34ef22458c0b633cba005955480bf61a6233ce4972b1ef4ee711e2ac2556f279244f8276dcbb70c50b2a6e7d01a0dd6860764e3b4ae464a025a864f9271db33ad9aecf76fc882c80b70e2114978602bb53bd11beb47a33ae3b0648beba439e437832f2b422ad64804c9a014890ef4b696ed4c0ac814a60cc2ffa0587b52e180ec9ee2f93ca3011a88d8492da87818def8fe9dacdf99b8601b69a52f126cab66408d35d65d9da7d1af18fd50f6986ea53800add9c92283320699317397c3e0d6569dfbda05b679f46267d2447b934ef9117d8d4a236cdec22fd2daec9a781f8f11efcf281470fc29bdc9df91047eca99c7ac8214141443df6f232c3fa0d12c695bdd6965ed548b2d614871315383d07130fa8c2c0886d6f60f95cf04962847d0e901149ffb0e0014e521551c53f30d1926f60a8d727d4a91ead4bba2cb6a51fb9f0b875b2acd33c43f6cdb0a10574f6ca5da54b11c900e3118227b15834dbd6663137f56cffc9f0ddb5936e88290d1b9ef64bb2cf7da1c80bdf7a209b6f044604c11a8563dcd548306bdbbf852e9bfa2a4281462a8227f0d76dcea48383cb2dc35814bfecf739e423bca02f060f54899dc99f845c16e5d12064744a9c18a4d5fd6148bcd15c082cceae883725051b8b5d300b0a71bb2c6653ef0952b307f9975b1a0a1543eebcd5222a3ecfb73baaa14edd1d23f3c24ed7aaa16c38be9a2889e347e7ac8b6c9d35d93f4ce4db90504b9025ee5bd0a455a6c6a62a35fa588c42e40b4070b11872373a8d26d95310655badc8e01955608301e6ee4884fc36fb50005ab19aa2393d75e6c77f68b910cc4a9d7944f38895de68c238b5de88e5090c25968025d6e2c094f3f10fe170f01453dedfed6a66385ff1d9d47597573553cb111fb268d361ca661f9bcde15ee2851b487d1a7b398d9539ec81145141045b6d8bd55eab4aa1df834e8e9c2fe15c574970c85bfd12197a35521c1c46c76119c7765e702375826e426b90afdcf33da76d4631d783c305a4848fa6f4f30eb434459ade0fc74714c6844f2093db44616785d052aa05e0f0d9f7f20f2edfc88663a53ff90e9209eebcec6eaa65af4bb6a04c33a845c7d206b1b8d0a22e22ad6d4240d1c01d375df3642079177fc50613b3bdc93c3d8b821e3c8b8f24c51d0972bde6b36ad9b23ee6f2bcfd1c3272874a5a095e4176b53e426152fb1c445acad11d59b6f0f263446ee65924d5e0d1d637a3528c28bd6397a6af2fe869bd1bc0541869f4559bb3b60f7eb87eda3c1ca58e0b58345e495c7582bf74f4fc6c2ce574faa055d36e2e8705a8f2aa3d053d25cd0e4de4a533c5cb6430f1168797439c8b3880920bf6d17205c2d00edb7184e3655c2fe6449e6b03382d5ec20e51815fdc25f3b018b885552c418bbfc4578c62f8b9067f6487624287ebbef439c29ee39bc9d328a0c21156838af451b1ca23a75d51675c7f8d916f26224c1839fe9c5fc2e4047f60cc6460018af4b306477143dd31c7ec8a34a93e9dda14cacdebee88c5c65d5e78f11d0454c7c6ef0c3094705b38fe05924cdb193380d09be6e2d7f8e6ac48e82a8b73153f603b022bd073a53e25a77d3323304b7c3c73b45a404202b2d3d8d5e1bc6a4da0020ae0665ad0e308c5ffac1977e4427f447107bad85f6e19cba3babbbcea17991a26f042b219aa65ba63c5f4d8fb4bfaa9f97960aa1ee45f344b12c1919e0edc7d5e986daaaa4df1847bcbd5bfee445d4457301429d341c83f7f6b0142c42a5050e87e9d94c611285874a4ac9510ce69c550db835b24374cd533a8e49ddd7e59754e039113cc65086561f4c268fd5e28e5fe5d8714cfb1cac251d75909d7e11d779ea2cd1de3e1271bb5acff6c902f3d1421fe178ec87b988ce6c31a05c47d77fc995eeb0ae5f02985c7b8523e8797614542c51eb599f4cbcaa373ec14b0330844f0fa9c730632966231cd26d2a353c6719394f17316556e23ac75e8e4ae31216a338d874d42bd6febddbb3896b77cccf0c2c44679be23904c255e00bca32f1766d5e9799f83d16ef4d529ec30efeedad4f2869d8deb41e4ef8763a81bfc316dd26455d3e527aa03c5d45d725ce731c4785db5e1dc5ab33d53b3dedab1bfff2cefff7f3215aebc7f783ce488f7ba934671320e41db63717f7e3459b2c783c5edfab971f712a67d3559e188f34197b31cd993b251917b77afe78a6a8b3655f5bf345cc2d5cc5219a7864dfd953ed2a129e9b0687fa8092129a48814cb9da13d91797401f4f57407f33e68c2151ee2f7940e9f894dc6a9224acd388452c2071334c8021ecbd953790ae3f5c16cd352432cdf053f8b722f1b2a7666400f71905bcd3c6e26c3e3d30e43c747ebd296f9e94beb228af8d12bfee7e88ed562660f2114790581ad38e216af508bdd9baf160642e6dcfd63df566a49c00367a0e18336c1b96ed1c15af27edd724097d88f1645047e61a3936cbcfa807afa34c265ceda1205cf5f0c80bbf82a20d51d2c837cec87061bb21826d768c30f8084ff9122a5c79d37787e9319f5a29bf54087936efff9c5a568e0eebbf0858acb6becd9ba9b54f771d1044b6c7489de2c936c00d1930cc5bbb0d6cccb04db55f37b1c1d18eb7cf859dd63a7e2562adc176ee420a934f7003cc7a83d4a60c4c3d757da6435b89e692aaba8176af421b5736bdf8ccd69a278a53b8ce1e7d62944df97715b4c922783449fd5c44ce117c1915c647720e585a446392b2f8c428e85c11a03e30f9fdb846ce5e5a6c786d884359d14f04272a43c22c825d6f45b5764ae1bdfa29f6f6586c687f1952e8b2df4607b74dd5ffa67e1485b1f1c15c2324cc7f7836156758677efcd2d6bc6d03620b84558f44099650693a028b013f6542b6c70c3a1904595ae2f7f8d022d8deefeea07eea0a1693fd88ed0260f16d649b52db0250493ae920da56609e5addb8a73864da7ae93f0c64bdf3de37ff8f5acb6ffdc914ebde436f3c9c3193d6733bac71e89b69ec65cb4288e323c677df6399b42da263556a2c3bfcc414777a0346d9d201b6174447202cd1e659d011d095ac75d98ec47d9126504574c79580073f17e6a9d6e0ac8fdc7f553083f78d6544b10cbd18d3bc42a6271017b0d753ffbbba883917b28206405c1e1c7dbab03f6e8a9c8fd762cb190f95b6a9299e0243066a37d69534cda71938f6d7653032857d1dc56186912d3862cb290f3bb29a143676485ca7a46134c66c0c2386e4fada53a91031faec5875c188d1e9a56ddcf13807b6a728926c93ca8b7730041e9d86053f3b1f89afe9aab3743c37e058fd4a7e3acb4e65ec23250062b815083c9afbb108e30d5f39195eedacd293ca8a240812f2b8685fd86add3a51eb9dfaf9c5dfad5a058b97cafa6320b2d916f3774626c61da6f8a47e02a5718420db03cf944e4168e1b0480ae3af0a5ccd1e5e1a8ef56d26633e43273aba3548bab2955f801be93ceccf6d99282895713730babb9f9dc8437a0672d2c8e090c5c07899d1ebec73834868db1807bed083c4f0223f2e39e2f3ac4e58124a358538681820a0c1b31cea75d9c767990c96b17cdb6d0d73e0e19aaa3cb8d75d61addef9bd4ba695e8a9839a71b7b44d5b666ccc5142c9094a7e567cc8c82468b4a88dba0743f76e2893a37e2d66aaa93db5e06fa2b9ecc5f385f5206ea234b1892c5d2e6b954f74ad8e46e1df4ac5923a4974efc3003e34eaf48d7611408d6fc1222b1fd3768c8d0dd70855f878ce3d2ae6be0fc69a5883fd50f9332bb8cfaf5df48f75c3bcdac6e03ac1901699d2c93c94339d0b4ee671d385fcf70f718ef43e5195a8b34c8ed04fdba5e4dcb0e2a4ec95c52f1d8c14c6dd0c0064878d80ad8740d9c0369b1b062ad209f919a2289c731dc646f538ed45e49461dd8e0076757b2aecf10f1e79b550debbb5a1ee61d5b959374b4fdc91482b9691a8fd407d01ac3bf9a98ebe5799298129c3a9d9937e14170a211536d2fa2349802471959bc41023ad314a59329c97b7182a849a6395f622519b0c06958e7505a8a216543e1f4ca6af638dc9f767180d4f131c380de00d4c5290f923fa5569d18e6c761b0477466e5db63e2c5ef50d1b33dbff5ebece4ad2a43b61cc82686ad5229f6d470d5c99299c27ebfcfcd2cb3c5431d2a758d6adc0b5c3a7d8d3c2a595007e35aa2e289e85320842e09e6b51959a9e11cdd488b45fdc3e3f224ce550a7fb93fd887b99362f2a6ec3dc8b5f28d759196f984f669b2a39385ccccb5f3a5b655e19b5b4f4bc551ca43a7f4c7e6f88a713c4baab29efe04972ca450833a209113fa78a05fa58f6c2a87bf42cfe6ab711f8ea1fc337790ee8eac7858afe7ac2f831fdb3b18dc954ad8f0b10b04f68afbad7d42ece12fc9de36b2b36dee6ac626e7d63ac7ea7c0f90cccf4daca452433eee2ced5e282c3e156433517eb8c95a350220e7b11a9825d09670b5bbecf57fefe0e0b58b29ab15dba6782252b8e71f0bbb0a98e14b11519dd2520883c214a2ba243b575c8e3bfd4bd0ad26aa4031c221b0052ef49f13358b86bffd1b90a423c3372dc2a034ccc907cc8eb6e10380324e88589e34131d1dee472e06ea42534ec5fc5e61c8e376fb524c93e519ad520ca3886b83e1be76232be4b58ef0091f24525f05dd9e1a6f20139db275a3410f7b2c7046b836ed9337b4edda4c69859a77d49cf49403e642c0e92839a8563567dd308a2c222abe67198cc6054c6e90332e6167b5b032b0111ec3ba8ac17f97e75fb499c4495e49532852cedd33f869b80521e8d98da95f2b6c99454eb729974aca57f6bc6a77a1a698e41ec5f53637c039dd9ff7fee7d04a84dbcb7df066a20c9fe14f23c2d9f41b35ed3264809e6ca698cced22d3fbc98468c44727faaf103e896664013db883572aafc32d66150878b0a300f24db4f363bf0ec8fb01925cb123430597f124d5de0c4e681ef0b7972e0ceb628615d64d8d5c57a76ee879a16a615d367e0307be84c82ae35aa1e08af4f212498ffa459285ec0fedf28be43173337ff82e1523955e3f6f07f39593f1d93464e3dd3de09519b2f45801072b8aaea2336c1543a503d8a3523566acd50eee8b5e5c57fc03695fe3ef726fc8c56be0888f939ab82f449b8c7e021e1c337f74cf5dda284e9235290d647ba11d1222b51a14fe6a451e77401515f2822a11c73767f04a9fbfcccadd962ee56ec7060328fb4fb20529fc7c9c3f9107f7256522900490e3f47fa4ec50ba5695deba75184c080780c3ddfbd7294709dadfe9b92edab1344fba9f0ea211221c505ed3e84c03b16d1998be8d5ed43d2ad5dc04ca2051562155b7f176591c2be922ce8996d4e4da897691086211a058c8ab4489ab450dc442c7a5f52e1c6d2e9c4257c9b5d6af0e848f50da3b64dffa78188d35c3b2e8e5033ecab5ecbf93b94506fa9e91774e756ffac60343b646cf927d4aea2d26468d3c6597a639dfe7ecafb664d8ea09dcb6b6e841ac5fceb89f139933a4e7938a9563307f81fb83a87e4b1b1b6a813a88d733363ce009f052145f590c1009cc2386b5f10acf386888fe1b2ed0d11d33dfe130bc1ff14e9c44a7a652a5a243ee149992330a8637f1ec69dc3cde3f96433e51e43fd4b05732ae797ed3713d9bfaa6f2514df2fbd80a34a22734674fccaea71a7921e19f61cd07058c313ef9afd0525c7f6c4f15d57fdf21b324bb7cd9b1bb5f96a93f1c9bff9cc2e80dfbc30ba13fcd77be02b49ccf6094ebf2aeb210fad6d825cb5e98713ce40a985cf3b4e67330c63743355631125029f6c0cf9217d000aaa1ac62af006d2a41fe22a93bf6a5355b7afc8f074e22fda88150e5000390d7bb045b12546e75a0192e251767b2829f2c3dbca1824f0646c949261b7401ef269e7907d7cd02365047610f3f6977dd5131c0ef3d402f1d074bd076877d997e5d0e8421810cc52e783d0c45febe7c8e23072ee95aa6485b69cbb1645f94297d44375e5c9fb538b9c111bcce34fd562b87137d229b94285fe35587f8dabb327270d5c87db20c6664ae202027c0e7b29255061ffd23a59c90854cac8a494fe4ab8564fd0b2681f4b59bb54817fd96a756dd5169b314fa531f8ab8ada750bf7e897855eab35d99f23ec53545cc787065325696f76e5d700d037b44dd7e2ff9a28fb0fed01d8ab801d72fbac66962282ede13ac3521db74e8b7c7d60a626eaea07257f96634a53ecdc2ee61d793fce3191692055b6ffbada644e8733e8d5660974fcbbfbdbb192f4def5b6bd95e960404d9fd084e14a208b38e2a7075c3dcea3f298b386f35911d9d689264c0bff95e62f0786450028660595ad588c0fa45fc1d8a9609098976af5141e90a98aaf23fd93126ec15c9d417818a747643f15007c9215d4387e58070840b64f7531198a0fc059379a926b6a0fe37b08e735b6c208ee8564ab04bee5d1adab9e4c1245df1b53d1179bd08fb421546cc4bc0910e0c2bb3c8035eb7f04a6395dd31797268d049c6b8b39bb2f46eef2a519d82e7171129de428e4b11721938155a0aba5db31bfbeab33966ea8619262731a67317e175b62c2ccbe391b2bcd25ac0f9bef4fca70146f3bef925f66cc0e36d5477d7cd2ca90a6b961b91ad6e91072f058c60e375829dc3d0478588f67bcdaca5350a32e5b090525d82c7615dfa1f429b90e4de6600f8ea2a1e8f7dd32d5726851cd08720fdcf5d1cdb434e11e667745dde01630ed25ee34f3b15fd26f9bf366a18984d2266a0184b24eb5c5f38bf10e5673c6962f9b20db73f1f56cf1c9e4d35b0bdc404f9882d9fb67fea0ce7fdc56f63f2aeff11a76033fdf6d1d39058fc92ab21e6c7925ef3434b29070bc3090bca2f251729f5db2c20451fbe428e7c6a3add1413dd1b5ceaea300a4d128350529d3df0b9830ab5ffa52aefec70a03cd25497220bef8ca4821103b4386299056427a0e9cd911de63d52a410fbbc4d0c7195f24950e07d995fd381e96b27211b6063652aceb4e75c2520d46e409efec7dfd71cda85a63c0dbadf3e41037a13fd3ee718646dfcc141fd63fe5d7f746ccd355091293fb82270f85b08d965de1a946d604ce7ae1f06ee120dc57f75e5f4abcc781f2209bbba0fb0f39afa0978147af6c0d0599da95e5ef1d27aa3a01733227c3ef3e114c357def9c4a3eab91f6298349d4ae06b4b553bbfb7d26ce36d4d6f0fd9dd87896433c40ef4e24967194f2bd5bcbee9cf19898dba5564a4701ec568219560a16bc89fe1ea52183ce488f23aa7e0871f9c2debd2a02e81f8918a67bf9551dad319df69c2d7a1665b81f586c0b873a0327f990affc8f80bd7c9ff139acc85a100aa4eed12923a3f2c279d7631c58b075090d2290cff1b261bb9cffbd0b97381750e0ae8704207e300d6df48f1e611b0a931e25df7c1aff4697816c60b8326addc79866460fde39917eafd840889d0e5a42025d6d080924bec4aa75bbd25d05abfbb2516077b08d46f3425b5f5a55be18dbe2f719eb029680672d49017032deb6fe7c60704e45dec995f60a686dd1297563772fda16cfc696fc3af690baaf4d2b0d30b715d9f76c2bb90e946d62a0c38f27b41de79e742ce283b254c7f67fe0901f9b8304a991e34ac143395c02e147538bf5f210191d0925eaa11543806ef6c5e3b708401e4e15f8288f5f032b9385f567d577850ad42d2bc341b8f83113e13ca033aa16773d9ce00e2ed4e399add5da4063fb45718fa91a5912c401318c47d282f948e2b54a50e95e69d0421c8eeae7c2aa2d3847788773d47ac9c83e40d22730569028888e74dd1de0f975cfd54d582fc965dd065f3450e67f5ffd45b6eb2d2641ef3d54b010566bd391ee17511cd4d206f4db8442dab4ea87fc3c4bff644cc5f5ec85fcae8d49dc6732d4e1d9ad19cd5a9a98a894741cb0709f8616e63ae37924f39d586e70517d46d41aa00ffc2f21b6e8fdb3f4de92488f23bef59031eacf514d06071cb845736a3183c38a4668305ba1a7f81736b1eaf0a4d45fc3ce5e2d326a826241547c56693132b0b9d7b8c6ad9e37fe7cd58c61d0a3c57d24a2a7da271df595053976388c34a1b559301cbb8c309626053da169192c011a56924dc91d74b0416d93977347ee2727d353a126dd31da44a9f5e8c7df7c8e468c27c88e8d0812793d6054cbd6056964b60b864074e2cd8bc86a1868337476341d68d274621bde422010246537877a2f1b5b67cb34e4c003af758c7b6bfd0f2d3401f77b3521bf29f24e78d376ebeff37a461acf1cdf09f6d3df77536c3ede76c47857efde27a5c19f16be01266007b05646bfa589933bd9d601e2c4974eea2bd5c5f8b040610193e72c5bc1c50ddf8fda08d2f23e426b532f68474f2595131f06d574418a184b1d24f05156120cd283266d71860e11f1c9946ab930dcda4a490f36f4fef6a01abfa403a9a3c2f8b41607235b4b68951f46cd922c9dc317bf9ed3b7e46a98e8e5359ffccee3c875f182a6bb09d9736cb0d374e4f3dba0605f0e03a3d73063de910a81dc582b6e999871a8c72f000221b24e88644fecb2460c52277058b2e5c28fb6f7a83abafd43b208b7fbbefe1db1d314adad21ce81855f29be51bbde9017238d5af520a8fef9b74b617ddd3ad60ec837381fa77e6bcb1179e3c5fb3b8847b466f99a57e99597aea69c366b273d5a966d13fab222c9d5d1406d0ff78048ea8b93139a29a172974c70911b09d65470af7aab64ec4d592351ca150cd0860382920b7faf1b989f7bed75bcc8fa335d1db7f73951b3e9489611ed725d09a2353e4146b9a49bd04f9d3a4eab65eb3e1d8ae0101b248c40e047e239342d1e931256aed499526d8e87968302020f0338ecac6ae1e2fe90e37b9a4ec9f9e814e375db2b126380d8f4a8b4985a0dadf5d683e20ee6cfa047bf13df91da62d8258663a2d36b4b85f8dfc3916716b44b5879a473fb7eba4ea65280d56063edb2d5012dc4299dee7ec6cf7fd39f84d03fcec6d47cc473044e650448332999e793b43334798858552feedb3bdccdc954b48cb6c3064acc6bdc2f5a9435076752024fe40018916ced9df874c249d28ee8e7868b979fb709c4e73b88c401a08fb295c8403ee59ecea310803bcbf4bfaa1feebea85b1b8f7400d0f0d4cea1bbb3f8884503f65cb408635e2e34cc1b666976538e3970fadcdaab3a8fc7e9aa2c974b4bb2f103acf4581895d0d3b4f3d089b0ed20c297611b368cb5d407ff173fcc2582e665745a943cea36e8335f210eec5db1af24dc14bfc02e7351428465ac6b51e4308a6e1e5d557d358dce86141f4c3f85ccd5b7c55f91247ce463f0c3f636bf5de51f7b4b7535807f16a416dc4174fd559cce2616b8cd47e5d8dd306e484cb8fe915f2a4025302144e523d654a71fc7056ed5111bada7a3199d3260199de4114159f338b763571b82d1b977d4e74f37f4644086c7b7b098ea6cc36748f4225b7c19b9c93d926eef8b4df63b28038529fd768d4ae714129ee19bde22cc0d7cc44688593c1ae5c081533b1934390f4696f36a0932b22b1d9fdb1d980286eaf91bad2de7d16008620cb7c8bbc81ac04ade3a831cf933d262f2e9c175439ae3a8dc4ddbbf55bb2eb89119074cd38df37453e3092fcc52675ade7fc31271e3a65158a62681edc9ff9d89b32fdb7b626736a01679b3e8fa1d464bc0c746aa6c61da778f3cd455e70f3575751de18f890c33a61b4b3bd5ec5c47c642f8cb74e2588dcb3cc742f16472524dc7a70cc089cdb9a716af5191ec0b89b6e7fe9527307917e00738d9ff725fd75f609473e7ca22b91dcbd00df60ca214c7775465faec4ad05cd647552e9430786c23a522932f900e8f908b04255b0355c9d91bbe3aa4acc0d7008e7887a96e77b91979204bd08562d8248d5b40ae575bd92db838a6551bd5026934ee2b1ad39944e1df1495c4ea1167accd25232c5a41506865c6d02aecd980f3c97db1cb3106ba992be85ecdd7c023a331040cbca5062244e2d1cb1fae69f95ab0a5750cb7390290c487a354d659c286eb0b2ffaddd9d861b005ce1e6542650a11777c260457edd21e9bc5cf349f02e86f7e4972f1c6c61433e8b4c3b72aeefa72438c25b24bd77ba299e048002b0c4ca88b0f69c2ffddf30af56f0f7a5a36256d9eb2bf237a2959951be860b721f09d1297dc6800ce3f163ca7e108788f5a42eb3ef37c68d60e66ff59242d680f79ada65b4789e21041bb90e1ffc0cfe2dad3048e22906ff48770874f9436bea337bb2dc333d36ae311df565684155a3f1027bfbf97ddea81a602d39dfc9d4b77a591932d03d6237986f3179d5a9c0fd9f9a8c03d8e0d9c1914fd82e5279e9d89091b59763ce04956a83f4f4923ee04f655cdd145d9be5619f5abf9479f25f73d67cf291d3da06eb7e855def5ef28a813b4ccb593429e214abd8a615ee38be279d06d9f61ae3113fdc21342049a110f0e5df8ef959f9926fb1957bae78ef1488d5ce0aa85cde310a801857256c9981262a71c4a2d07aba38497853b4ce1716aed651c7d8279e96a6c92010dfd9e965519c83a432fc25fa76adc9c73400e68816fe4a9f26f4a5f4d0e06fad3fdb1e70333258d99b63818d247fef5e9efe30a38c6ad067eb2b810c2290ac99947dcd234325a01666134a72b96cf3d710baa76adb5ab1d9cd8bba69747dc9ab6faeac57c2b53cc13fab95c00f0d2b5a15bc6358a4b9b28472083beeab051f3bdb2bcdbe52bb0230720787ab56b1326a50075062d4d7e4ec866330704b24c8b9282f6281225dda6052f35fc1c4faaae017bb9e19c79a5f3fd608824bc4d569cbb524f15afeab0d53cc483abc6a9837b7b4c818baf53ddf3101e7ca41861131e7089df81909bc5a7cf8aceaf1505ad890d2a62b5b9277727b930c7b1efeb30e906fbf7163ab26c64bc2041853c157f9896efb10ba06617b9d520ec3aa57ae9029660d3cc7a47611f23eadbf9df64ef3f91e13fc8a6ebd9a5e79f6b1d05b38e641b8abcfb5079181568ef4a37bbdccd2c840dfc6a41d7479df94704158eea5a2f735dc63ff8067046035c83b1a44a18283c6748df7ce7f4268af9297a66525c96db325e2262994954da04ec17455a6786824bdb44ece1a5e97ad21ddd4bb6596f6df173e79052defb1e9c9cacf813095ba982aa62a4a6162db65e542ed9d78883480d65fed72aa89ef918b6fe21d3163a927bae3b331f773bbae70a29ac1e84fc415e6ce579001e44b62bb62ba4458c45b1a8ba539b6c97c8c49baf4a13beeb89bda950a2808b884b8dd6357a66cb5350b8022df3f191f665b0f78e9b3b819885f254853d88db2a1688630e08f93f5d9cc89b395bac1f8466e87f4a6739d5ce47defadbdfe3a551b8492b019ba9021d0333fb4df00d4313ef617ef2898edc4fc78660e1aab41970af46306c46a27d90ee65b1c54b05688b1c19685b451e22536070e6b93a73e0ccb0a0dbebada7b21b892c9af130293b12a368beabc33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
