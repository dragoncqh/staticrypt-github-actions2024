<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f90d0319cdca65861c50ac597e312167e9c75fb898d3279758c3fb4fa2a8947c0cf9962e4a3db9737682e88d78b56df56a2a48d13074463954bafe0222c61a644e8586d553036e59ef6cc10d9cc7700abe3d4a72526b0ce5a88e365b2513f4171edd9a6ce6093f2f252a8586ffb44f8fca0e2c7554423da0634ddc2e4038c6d6e4d8faad518105713f4843a835bfa42e7bd7e370a0f46e22c97f2efa4d9d49df02057cee4780cf7b553c2334a45971c5b108fcdd1dfc8b20f238a96a510c3e422ae35597a00d75edc20c3dba0e560999095a4b9e3ffcbb4c4694241bdc5c4fa4b29efb82c8d83a535392b778b8cb2381071f102ad80f50fe606aeeb4f463109a124c24992601f735333b879b15611c865385f90b7fc1cea6c38fa77ef344a89be3329f00887550cce1d2de7183760737d35acc626128bd3fe0fbcf708028cf2ea19f189025a4c0058d8ae53b1e04932e457d8df6bf048ac364e3ec33e14041365e1b10fc858f4d629c11f4d3c959652d0df66447e7f78ee99404f32266a2c1c3ed0de726a16d1074de2daed0284368c161b213ba7f1a2014429b52411604d80d988b4a4d994e26ee4f90e3017e3c50fe3b57bb55c46e44455474c010b72eb6350aba4e07b0e06c08f9c8dbbc5402db7ef1e14df540ac5a286dfdb28553fd72baf5ac8ade5573d5ecf0782bd0ebe249384a6591d2d090ec80e054bc317fc9cfaa901e5c609ec7c75914657a1ee689600afc19167315dec6eb4d1bf646c557d12c9892dca02be943e32f46d67799c212658b49dfa6ece582f77dafc9a2e38ebfb3b1a01a0fec80e3bf797277f80114d07323a899c57d1e43dd1735aa5de452371defd0bd4dd343f53854745f4289d8b8327d611392d67ba80e24184258f5308dac584e4e3d6544bb64b63349904d860933e47894fcb94c74751141aeeb85b58ead53252d5b6999c8a57a273b4a3aaf0801c178f8d0d66716267bae51e7e9e4f0276ce08ac3e985855040ae8d93d5e1b45bc19f0a57582439c435a5db9d3c9cf145132ba90d4026f3f44b361f4c1499a7e46e2f3af39a932e5fdd350ffea85957527e7e79539c907d93c33aabfba45f0133c5da68a1cf806ca728a9aa53b4c8f863442185bea322980b62576b1ff89f21108ad8a0936294c804e4820cc5487674489e637efefbde790a57a72603e56dad4601c8bab83e7634bb90b5f324853890f099520caad4c8df60f733322ce17712927f1b5b923fc8ce548f020bfb0eed032bb9026cf1277ad68425dbbe79656c3dc48ce588acd0a969aaadba03341a61a434fd53afd6dfa6bcda1c7d0b04b381cbb427d4d1f15b7f02f9a0de437734e4e7090f928d19044f81fa3055d4fa4bd5f9f7cda9199c2b84e571e09c08efd1c1c095d2abfe981831c5c17924bbcd4b4ebe1c25252bd06d45973adf0029f2008f71ba6fcc058d422534272fb5129a0ff956483fdca38a46b4d3bf3687d78d690d711b11871e8d8356766f48b39aa2422f40fb0de6b836353e08955c4bdab82aea32cef615f80b56da61d792165ce0afae5177d8d923fb3269eabf689867d9cbabc3b45d8c8403cedbcda92bb20f6fa62818b9db1907c9ba6d45eaf1353cd2a59575cf7ffd557b9955e6c8244b74aa6a0a2402db5c6cb3604ace97e820c3fc721d9af5dd9f6ae929785d7ea58a3ce7ba89ce0b7c907eb07a1da2b21a4fb64a8a90a322a27e8712ed6123cbb40763defe59372e26012389f72cc0208b204c4c82f71a3ed9e76d51e428bbd43f91cec540009a90e4c3de3289100a5e2247eeb1f5cbbdbbf4bfabe5d19ce8a193359b9b27fe1b976bfcf06d29620e30ff86e2254551340745bc348162e6c82e2eb4383a4f47fa6ed66c980a2162d7c062089290a764417aa1595d6bb4b0a47f3c06cdf0f1ea622c1e613466807e6d92ae115becd56c1104390c5bce9ad233419e0ae396f3423c2ab1f81980e09c1dd4df56f52177691f41e10ab516bba5506f87b50e04fc7d064934a5794795193448222343d98eb1a255fafc76517993a53d9f94e9ef88d4fc4ea5f1a985646ef3c4e83129d25568f0091a6dc7434ad4f07e3d57925584341998f09597b8bbcc94a5a405c69b461bf2a73a5f3cbe4671b656f9c4cad8899854264536ac9205e5d8b1a18d72646f37afc959ae60a7e955a71724eee92a6dbd491032b188a118c99812d10bcc40746f28f502a9fa65cb091b8aa683079fb13e1377a260dec6193b56f6d5be14e340fd290d298d880036dbf34d9fe2b46db29c149960e6732207fca47aae89e855b951e6ed3d357e1ba922f02a7a502cfd4f0bb208b9eaebe0478d729c9ff81b9bbe7d4c7d0d27188bcf917bbab60fe7115faddfcd58f6b2df8fb474b242673ded58f40ee4ffdb3d0c35afb0de0946462e9309b3803ce01796ecd91c47e3dfd952a6f011afa48be3f012d29fffd587e084ed0f4c8635f5ad4db48b3b96b12dc62e5907b201c3f7f305faf6bb3a2262bf9b68c079696d9374a773f49656710780ba807941f06519c289ff454e2a30bc4b245695725b55df452f041dabaf7cd3cc5032f28d13c82a89fedc8d9e9d0540c0fe9d896900d23d763e1377d0c65a94636ac39c19ce653def91989eb72a89bc87cf64c32eb2a477cdcc6d51a4b81f17658e8424156d01bd2b3d6ce07f27612d81eb6d823799156f91f952f640f710ae589bb9ac1d0502a96a99946631899cf6afce06e6bf5bfbb10b71937ea2497a371dc5d75f2bab109054aa35d67290193a348411f99ba361af05a168bf20da8dfc4b9f885c0a6e2597b9f017589851063ee5edca57662686734d9f6fc932772c1f429750d93d7c237c6bce093c20c6049221039137ce08be358e35dc3b3753e29214d11fc83fd16ae49f37898dce9a28f7631c4e29cf8a2ecc02074b1b1d89a55f882c9efd6ea59bb1ec5ba2e1916871fe325a6c05f1ce393404c37da792c96dcce1e248cfc74d0db1e25e40cc20094bd63ee6fc5f636d76b1bb424a48a92a54f54ed7c2c42c20b768e92681f0c31d5ff6c0468d605b1885c5795c998892e7eba9195fdb10816dd2a8a46a79d1e8233c9b1c45fc628b87f998d6b31bdd1c2836b8997e0d3d3c47c12ac67b5b6de583f4550a8fb9b4545ec2a71d7ea10ab1edb539e53742430c139a254bd34e4de5e436c9b9c4daadb81ba2b8b577e080d1a5a368003d2891f504a6c61ffe3ce9a2e7950ffbf9ef2652557f405bf499aec8753cdb698a0721248d32e205cd1ed712d71297bbb7240d64cc83e007dc91eb5bbb878b1f296a678d1682e5febb3055d5c792da68bba377ab19e28e566bbbd7931cdc5cd2a8f7ed23542960da97d486befdad020d43693b30922d965a4df0e8e99277e2e927ba2afdbfdaf8b066b1fe95a912acbc5d22fb9a2e9ec19bb80bdaa5ca572e54925677520db20690d592353564a202c2a4e010b09efe164a1932511a905f40d877015a7eea887b41b2511595e154bea8ee6d4ba28fc7ef29e233c95858aabdaf384fc26c5ce0a6be2e346998f7ab53b15453e0745e4c61fae910245cc27c79128196df15e3e5b55789dc7dfddb3f573611f657110c9f905c79d6446bbb7c3134bbf7a4b5d37eec61e8fd78a7d811d051d4e152c205fa8e9f3011994436a2b172bc2e9571bc40e0b0cbe734ed1bf4d123703a23cc2fa48ea757632336f7ef6ac70c3a5072d1c0df33ff9b34449001bd67af693f11315da8e785c1c6ac6612f9d6ce7a03396e3da4acb5b0fd3bb69f506bb31628b8d96f24f28f2235ac834d2532940bbe03e5e2ed03f4416d30da6200644b15974f7d5efe3004038e0f43691fdadfb3ce8421c48a69a94f744b125c9278a0cc40a556d00e738b5b036532d3a250b701de470abeb6c0033c99ee55d070b42b38304866939845a7ede4eaad5ac0b4510893fe0e4b08538c97642a7336dcc0ba1ce3dfa7c848a56c63c982408a190600a3b574bc984c80345983fa0bcbe65b34e811c04c5cbfb1dc727de6c6f06bbf6c65089ae9e8e4baabc94367051afd123965efdc4030c423d400fa48ed51ec7c03e0c65c89fd590d71204615a6bbc946843a4097ed3470abd698b75f9620c4d78e2c026f1864bff40c904bcf80257036801209da6e49705fcf8d22fa4b99ba1cc5fa66d5e39a0003873d4b29f3a7f61924a422cc98d9115bf00be82db7698dc6ca32d9da5c90fa9336488a2cbb21e8845d761a51bbda5479ec275c8a7a2dc6e380ec6f9bc1aa64716540ac8dee4f1cbdede5321c5d4c07638f46c11f15937860c6d3c098d6f11edc1de6c5da57772f4cfcd49c903daa6f1b4727ae9e90384c01536a8a193e8964ec62d131eae327d606aeb799f2f77a0e2b6f126aa972ce41c57b5e9103bea29df181a26d5a152e846d8933a84b6e61aae4623a67c077b2f90f8b2b441e455feabb9937203c1a00c0aa23230119057c4e83c23469fca0ec05c3bad6628e2c8b025421874bf139d1d12f37b23090596d8261d5a4ba62050b69869d7b746bf3c86439bd26ef181656d08740e29a9e061f9b46eb0bd9351cbd73982054345e9d1b26af18578518bbbfcee41e6d3aa18394ec1f1e84799b29652792461e152b85f6405d6b6ba6a9221af91daf3069198b623002acd34e605d673907cc84efcf0e5a7e0a09e903d128852b5558179df28264fadd3646ba6b2139652725a0d9bf7c4450963dd9bcef00a3c9feaaec94981e72feb399ce99a6499156a1608973b338ffb5ff1e50be54a91acf358647d0a6e3b3dcee6570116ffe09380b3de8c1d28071d2a716b5c56fec83d3d60b051a6698d45dbecd6ebe9154a2984f6bf6b0f9d8b839fd12bc687a32dababbab8b5f878f2ac5d3a0b6b3a72c87f70bec0098581a0e677d1ea33063c07684df581af06c6cd69aa0691b168f866e323a6540f39b616bb9b36f1bc8d8d18936ecc874f75d0145d233a8ae2ce9f3c2f4fd95eebc0bf9cbae0c6c77735822b4595968b1f64a775cb12ac847c0cc443b2edc76e52885d0da97f1fddc68af91d525c64c4b06c2d2436bb0ea3fa3256cf36388a07ba1379e90cca0a7f928aebe1b1533a52b40844538b6a799fbb22a24013527c9d02c820833824ecfaa9cf8878b0cb37a4d53184927b332caf7408f709a0a669a2b3ca551111a90ce72d5cd57441368b1163c21259099ce6a5a57355892ae3a95d739c3c3675bdd8e3b9d7e9290fb1ff1395834f12d0f56cbb779732e216c4629ef9fd0a35cfab78fbf9c1250cc15f5fa11a835215f1311e105f992fc06ed9b582398def0b6568099e5f6db837569e8cb0bdfe0da720433d089d42c070bf9adeb09d5259e97d3a7e99637d4b7aee3f87358b2f31a28115299d292ba77c753aa9426a5d9fdbc789534aeea55671bb27ee4eca4339a805cc84c234dc70d1ed07233371a82b1bc02e1235addb68d8cae9b62968b2c799eb76dcf2ce4af89a3c7299392f082ed79465d2cefb26cd6afb13f047c1d407cc49cbb7268e13afcd999eda39743113ad6d0d6024cf0836900a26e5364077a2427552490f58c5efa300332c740676470483f864422e69ef3148bf43537b0cf45e7d8c7508683c1e16aa4d4f894b19e2a999ad3caf0537afae749ed54f721815748554433b27c2c7e2cbf8773523ee9d5901f21f7bf6bec917e8cca125ec6fedd34d11eadebd71d31255b1f612fdfb821aba58e2f2476f66e759ff4b037a4b15fa72b1b7cdd8b48b81dc61cfd10d14e8352ce09017f55bbd393cb0433a7c3ec1b18e42fdae0e04992a7a18eec95b8a637d3bf6dadc7a517c5d6cf51ce0abd672d549d6357ef5f072f39e3a65a4596c5d210acec3d2f49be828d48635e9bac142c90f2990a07ead870706f01ce447e693749ff08baf069327938ed90ef01c7c57da728c8e815ade073c613841954662fd443d279f9f1aacb8e951d81065c8173db7892bedb44ff254581398e6e0c9b81682a68d691e932b527e10f83176cdd71d041a6d4963c7e9ac6e8091f2c7c57fccd12948bec4f37d59787cdb280945619cdf7a118797ef2ab9736f6358bf8605f25512b5384aedf1bef3649997cecaf0377fded409cff5d8e68bda2bfb991053aa7c1b93d468552b3cf7d0f6934e3d893731c024d69f919a6d9688fa4005a60ed6752cb3801c4cfa4ad85638852ce0937fb026d14fbb2fc8a0c3297573e26c2c75ce2ddb894776367c94b355f8dd16b60a2132e37af7a21367ec1e223288a0b73cdcb8eaca4746e8f159bec782f2c43de574b8b6565390ed03361c972ddbb766a720821b225a3748e8ccdfe662b51a2705ce6db89f75405f88641f3fb435ed7cfd1135c8ae28f164140cb52f24204ec3e8516d9ff708daa0b1e92dfae6d982a06e54f4ebad47d01e2bc122e6c4af8a6c9fcf237cb388c8d35c5c8647fab54407a8151bce10936c1d7e49dd956b3a0359f26e56e2daf8ac1fdafac94b72f4d0a1537378616745119ac658c94e70163e61534a1b414129128b0328bab4c99b754c99701fd76cc19633beb5785cb2f2fc9e5a94a0cad2feb5df2091140a672e952b99f8811f03179bf72321e9ce8bbd90292f5bc06486c5149907f295f0d2b79bcd4197e0fb9bf0d12ec87067cfda94fdf0e9ecbc96e9832587f3d7ab24b29910e020974493a28541a5dcd4fc89ebb3f422ad6527b1e02f924d542053095b63c7560251e882ff9dd679280ebc36c7c09110b62319d625c9a52b9b7d49b33e70703ca248eadeecf7e6d17f20c50c39bec1003c3c4a5a243576f58b7d5bef3ba705501bc3e149a4f1713532c990bd50db258ff9da2e2a6a620794b92380ba03e1f31bd4e08113b52b52091760fb752efcfaead2176ef206c0c52bdf15a6de896cf062dfb4fa046e47bb90a840e59632b45fa5439b2e7f764f12620d08a3685231c97ad4e0c86b275a90498cf444bc6fbbcee2dc1e44bf0161d02d2e2338faa9add7992760d0159fd23130e9daf83e0336ee8330ed4222df8224db7a38e94e86e3650b02a4b3feaaa223309d549cfe63ab7ea6d14c0bb25c2b8dad6308f92cbd260b37e57855dc55b2f3d233281b4f6e5a4da608d1f5a03eacd6a0e99cf93f2b116d7679ca7e4a7dad3de7fc351b9c7535af15af6da0e285256662d7da0f8e1d80bdf922d9a9a1bb1fb6f3c5ee222f85406229084457e0deea2c904e53d95360daa1a3a01f5efbe9963ebccef9b975b8c6b980c68dcf52e64e0c3131259b0e1ac3fc50c5a1287f53b534df8225cf919117de074859c23a94eb7ea43e63d24d19e363485ef6a6511f8dc53c04fe211e2094352506075da2491412a487f4a7926f8d704e138eae87a1dca280d8e972fe6dec91f6967b2d908fb614b4d6a761a7ed6d8981ea3115fdb32025318475de36aaf77968ba91d3d2131f326bd753d433ff3f729eee58737147569fcc6f3ee1919e564abc451f1a330361714b6db9e76951c36535a905bb4c6d541de95cd7788d02e1d3afa71a0144192e39781dff6c73a03f49257265d13ba1592215b788321cecb6bd92e647e5c189130c90f7cb504b566b0bce4c9709619c89effc5ae6d82711dd1cb0296115d7a096fcf4bcc2b4ba03bef8083592b429539ef2210b961e82c0fb9d4cd5241d8d4ec04b1f84f4443f471085bfcde24bae7be272079d3f2e1fcccdc68d0c3a981e63fd73456006800639f83bd55166a19baf421fbbe9a84f9cce176c195442192dd0790d621eb333cd40f9a9fa393606ac47f1b4a493736c3cc1a361b56de4f883c4360c283f87e2bdb1d66184cd5f0b5d45a904a42ee6d5862399b50df804edabce6d875e6d632e5b89fa6b007cccc909928e153a15075fd43edf8e962266d4c7aa526fadc2bf8790df3bc97f8304a30ab89af3f910fccaa83e998399407b65e981c4f3dec3e980e25b926ad86f85097874d74eb8504cd4c309cfbb72d20392bcacf420a99c68ac411421c855b4246bdfacd2e45b87c5b5991b540324d5f2e25dcd58ccb087aef053fece9060ad85fa81d97ca6776ba5ffe11eb154a36271d661618289dba2defef098a43c63336f494a4709817d009bbc6115f6214f39800130ca5af615122aeba82171cf139a1f5095cedad8115e3283bd80c63fad4ee207c3d6f2148e13e0934eae54399d1ea1fa93488417d193fbd0f639e420e3abac9173da5dcd2da7704537d4b993b56ec034dee490d14eb74c9ecfd4f244b308f017dbe43b3a62ce08ce8b23fde6c032cee15cc48ec8ba1d3bfcf736a7b3584d434b16a41cc77842a34d2f483bba07f17e691d2606d2013a414ba8d5af36b680c77c2d30bd5eb26d82219729cdc98a18c99a47ab012adedfe5206aa4b35f9287755782d39331f0f1c96e0dab635ffa8eef0a81c0b2073c80565ab9f47db466de3823062ce257b31576a22e2b68e1035197ee2d782e3af9b84a9ae3e019d7ad7d929edae3a83ffd4df1f8601c870259c161a42da72f45be710611748511598e524b387839a88597ca2654a86f562686b93adca7d1b42dce144b6359f97e89abc12c8367c273d4afbe78fc7375cdf809f5f52af8bf8e4a13ed77a1317a2340a07cecd594067b0ab3bc44f3efb5ab378247268f03dcdeeae2ca9595862a6fade81cc89ff917ff57f61b19549fd4151d2eaed019ac2b74a4031f705dbe7de96797e6f5fa9a83ee2abc803072a760c877bfae299996edbc766c0f761a9cb3108d08d2e56cbc02a5d0daa42b395d8ca9d7c040a5bd8f82779c2bfe6c58f5c7f0d4699f3bbe28193d26cec4f4ddda8e567e21bb1dc23586c410c4dbc5995df3f95d15d2d278f2ab6eb1a1bbf1c19e65c1c6b36f309a514477477063b13aee9a0c74531c6ab9cd45f9d4cf820c92579de1954a03c675f160cbdf1bee4378b532bb0c4e2f0e223b0aa7de0dd5dc7fc77092692004add574d5ae1cddafeac94af8c690605c85942438beba07361ff93a22b31165f30afae70a93c4e86eca80968e809780d816628a16d4e98359f55c76d5da286b80ffe390d0fa161d8e9421fce4bf32d10502b244bd3aefafdc2e0f34ae03c37b10121e04d7dc2e8bce020c8487325e775e38da8c3c2f9d655e1335d5d762d3ed46066dbb2432eb5a3e683d3cc83d916a3ff4478c493ec30aa1f33787dc92390aae5efe5570d72b171dba8116b8654766e25dfe2b7697b7d15e13855701bc7510f7ad171c505c66674109fafa1115302017633f5ec5ecc255a0a1cf8c33b6fdf427150b55fbf1b2fd3059d5ba015d47e7cc7295b67a113b1edf753085cafc8ca7a8de1f044e054d956c7f6bbf44d5fe91355f064c0a27d697058f202bac7cc25b906dc681356ff04967241ab4d9bc3a80b6a511c2b083d0d8b2156d1c8f8f001218bc6013dba38c5c7175dd03b557c77af9c6d5c64c4b666c2d90bed15d4c1555ef1fce83e0b18b3506bbf7f030685bcbb7466b23b7290fd75b54b100ebf0ee53bd62865407c780ac0ae1fdde87a4119894e98ed9fc70f6212b6ba00c57dff7a025ed23b3f242969962820e3aa4063f1710ad9be7a6e80fee1f918c7f58fd532ee1c9ca4c9bf2e735a2acf9aa4c583fb4ae040371f62af3424a9032df41c592daa68581090d90928e2cdd01992bab7ac8e19276edf3fb50cfb5a7942323fd7c917c6f4b50d3854975466507fa619c70549d16b5f287eb18e5a3fbcf94c6bd6783e3db6752aedf79a84d4b4ec10f9fc01beb8d8046764997dbfef2f77f734f566610f67856a52b7b48a0624a58aeb508a8baf0c5bdefdc540dfc42107f441889644b879db5c9f80002645a659049553106938f3b072793a1e46d0600f064489b73bcd77625295953b2c363e0cdff4f3747a07a2008b6897a849563fb62f2b8c9333ea586b04fc114addcee7cd4da3a0c447b82a9535b1dddcc7ff26dcf7090c24c9ab41be077722c86e37111adc2001bf415dff68eb49863b1d41818d2c1f3ae4c0986fea1c4cfecaedb7bdb1e1cc52f509731bf53fa617f5b712b66f83ba20ed76a8b01f2eccc97610102040fd122bdfa812cd8735b3d321d6205b6ee780a7f391ea090c3180ccf16fbb9854aaff795882e51dc4c54bf09f115c5799e5bf1617974b87d97a618d1b771c9e9f97fb3a1afed7d0eb3ac4ef7efa1733a68b41b1746cae9e0e0942176994d50f78f838775a0674255346b3d221cbbeda9afb43490a3b9de862751df834648c3a53984237422985674cf7b27b239e9f8cc8212b6ce08a99cf38dcf76bc71c087c10a137858b0cd7cf254afdd15f1ba304a4b595879e00eb158c47a1d8cb6748637bf5c75a21bfa3c59e8e326d127a7e720af11ba72ad79607eb56c948f9288ce42c6944f632f5217ef41fc16a3e4d716e6c920ca8f63fd04382749b3a97c7f96a6e4534cdc2f0f9fa184e5cbef3c780528efd28b57c60387cc08968e07a27e6007b61683ba279f39ca700a9ee88cfd32869f3d562342a2e16723fb3751c6c8363a1cba9c019b22c5318c3577529e1a1ef394e7ea25c6df3c09670288af23a22711340c601214b19a0b44ff0146074a0abd8c5ea91df70b56fe66579f875fc3652921070a5a0604c8cd395cec64fe95213fe4d3291616e4b67d81c42062aa40b0d7887d2d6b52359e53071b44f0a2b086af3038908d78125c682ec267b864e4f02c023dbd8c5eac8b8b37f4a510b58d2564f5bec5d63c7e019f49e47f44037f1137daf4a1c704c0355a30716ed90ce33ee32aac8a949c3b874a94400822601877c80cb2f2a817d751282af9c4b520d8c037be4087a3eb456037f5183d5823fb7a0df68a604a4ae15e9367f905a7914be777eb569f191a80aebb51ce68882821affe8a5f4dacaa52a3a3aa2e28b733f86fb6dec818dda9c970d5cfb65cb383ee946d4701e5ef99540dee01806532e81b766eaa34f7b7d3b7526b0e8c33a95c2d3626d2f2d7422297ca92e1be650973a49126fd97c9de2df7d750547830100d69549c96dc6afd181dbcd9c43325958be78a6164469c1b1805b4a9f02864fe3c93af7359e071f4a5d3f356437b4a2b41d5f91c1b8ddb7c07801e0c0805696c514bfbd195f6357768536683f5d4a1eb67656ce87f6933e441d852bfa8db80e746dd2e10177ba699af2fe164d1d4f75b0248050d81e9b5de5003d533893f793f58ca94f2fafd37db9ad8c28e45a7b055aba90a13f728bce4b037e20abeb69f6ed905bca02e77375a265d3d17e003ae6179055df364cf7ddd480313393c77389461876c0dfad4e02df6fd7b4882310281e97af0678dc13787909fd4a0d8f089ccf1a5b20bb486e73b98e592f2107dcc05a0eae246dff18e9168fd7e8982364f65683ee779e6699ce9cc52a13950653fec47f08d0f0c5f6066c30ff391725a136834606146d53fe20b64bda46f46782a53504972d16b27b756bd82f7413923144347698122868d041fec14822aaba450bd06a9a98fa5e1d889943f75a24b294fda37c75d5fedabe92c6804ae33df672f31ba701b22c9e1c7b0568081b99afba75e222ba6501f0495ed1e38cc6673973fc0fa52ad61e17ac83da6cb0c7b1e27c181c1526fb76b3325700d5a5a50f77746a0a311ed67a2364f4b66f2595c0c48b0530ec1f2832bc51ece6dc0d0ce0be9963d660a652c76d5ac089094822c460d9f80ca6153ebced8a9be5f30f9983d23825c03841d542f51c1126572f18e04e9fda97bc361f8d4611d89af72e7e2b6f7892c3fc42f21de155e0a4ccd6ddf4dc332b32324a47d8a17d13f0030e22fb4d788d6e365e7786d033948fcc0030edd2a7bddba2d8f6220aed6c55f4a1cd339967b7c80d6cd0e40aed68862462d930b690f7697ce656b54b43592acd594f81fdb0a345b48a933febd7e1e4a860fc4582b3d72d07c1b9f9fce18101daa12bae4a286d98aa8be1ddbdf10bb9bbb564891e67adfaf578038b35f6cd7906adaf9f65082e26cb6a83c0de2284ba135fb656aa8426e3c44beb3a612a3c04f65b0b4d08c7f4cb3d26f2e2100c4bebd7f10f4d9220efe7723e77d3369ecda78080444f080c9b5e4a7fd1548993179625102076d788636bdd1bfc2a57ed76531a0f5d1020868c969053c0eef68136741d03d81d73f3a42ff116ee756bc1ca5ed4b9d8bb35f10560c207be82f6609c782aa5c156489473e70918285b065327a35d616213c61a89b875ffce12a87a22d1748fdbaf54cd77e790b3650e99b83bde540fc3e8bd55bb817f8ed195bfc2f159d4a065d2adfc16f05591518ab693874f0e50caa951a8c65a575980f162db54074a8cb7f89b688b2b1f11dad835b135bc1b6ae8b17716c4ad49264df02e88c8a3045b252e65160df6a5f0d0a4e21e27314de90ea56186dcede1c2df912e1c29e4b8cd6ea6ca3d6383894000d410fdc674865f141c9545ad0def297be2e75459fef8df67cf5c97ac7f1e583a47fd1f8faca8fc02c7967fc9677707d64d6e66797da5141e9fe286d7458b37820bb9d5adf0a66d0bcad08964eb0d942ed6a31dcdb3898b85658edb3ccc15fa2cc1c6a3817fbb7b4209a341c5a9f916dde54ac05fcb9b39f5858122edb73aafe32539961d7756715029997e7611ed8d9d09927a9189650530f8974551622e65579bf8afbaa7678677a98d86c5a027a51b60c8eab4727818fc00af2a3c5acc39ecc2c282828f50567656741b97afb64b62359aee5d8448951bbc9035e868a146b245b87b48eff742446e96f12b0183ed60bdca319a81148582d8ffc786c0bf8e4e1808fbe993f90a8d49b97df39964e3772b6ec9cc38386c24dbc06b272ffcf36a20b611da029b9778c97641cd301c7f9bba3205b070ed7474110bccb934cdc8da46280f2c93f168b218ecca8ebd7c74ec55a8c76e0c256687d7d45b55547f1b657b82b8f8efec652c613bfa9f899260c0d3f6cb3500f7cdab774a0ef4a9ef479d606c059de015052383defa53160f18a93aadeae92c32061b561013945f87072b693981b115fd35beab2f4cefde2be495db6c785a5db0b0a0a38920d0966d6ddafe91e11d783f6e8c96e6da16850f4e966d7903dca0120da375434c1dc0dea57b69c21002a91d9f6878cb836717f481346de78942c5a78241103dc00a39bbdd7e827423d48133c16f4e494aafc385cd882e90bc0949fad37838ef0540433b93e1d267050ec8f844ec3f92470fd2c056e887bf83588592ea1e0b77219eb4a06029b3654a9c668f21777660fa86715b5c70b11697f597a82651eff2352b40adbcd3c724addb4bc388ba01c80f75617edaf064c5e79c37ed90b2c4f643bd2cf04a8167ce6e66cbd7f91ce81f2f90f856f2c4b272b0512b30aa38cf4363d60cb434811b10f3f80fa0b7164e3e424cade18a22ab5e8c69191b276f807309c30c9ebc66494c25206c58d865d107add2fb346e3ee84693c90b5e39c6ffd541300ce86f5f693d16dafab594b280a46da01dff7825aff757f18a03157739574e1e897c620473d03bc9ff4b0bc8531e5876430161a8a44fc6fb6979ea0ffeb6e638a3c1530b7cff34ae8bd222f693eb36a3012895bb06b76ca4434f9819b9ffc4f339aafe34c1a173119cb90d0b6393b0579d61932b13a3df57f8e11dacc67c6b600bc44d0d7334760ff3b365798aaf1aead76c8a46b1f0d4ad9375b41f6260a470e304caeeb233ca12cdc35405fc8963807ea3d92549fd53d496c4bcf8ef839e977c393d164e1bbbe4bfaa0b3dbbe552c6dfdac7688917307abcad129d0c9980a2be136bd389c48b9f491503d884eb0efe60d9300226670975c9f3d70888f0168a1b5043d4d3b030c38c094805bb142c0e4cdb53925002e6b1546df3df09bd1fc179372e50d311e2a5c7103dd2cf650f0392f4758e6c62e25bdd6a87710ed4c9074170975bf331ad0e52a8ed902007478ab3ce078300d24ec892278dcc963c375e2de7a0c9ebac6acc55db7ac4f6bcaad60ed28fac8ff314dbd745d91f9527ae7a8ba9db770a126063c154ecba804aaf1a29e33cd266bc4b8fe8cf1a4e7852827b274d4944de298581a6b49fd419012bfe9a1dd88a31058bacec499c273fd4aa4052814ce36265549a9542f1977ca4f2187167f22c75431145d3c089344003dd47350c1668b7b30af07906583189930b342fb186e8b8e20ab11c8a5199561418902aa9e6544124f9895bf82c4aba0d5f17db161b5940a2aced7986c56971b02fede7e45e9a5953560458d55fd6f8817fd58f1118bbd828ec0d773d45e3dcf8cd2280e55281a4c898cb06506eee8a6c50c23e6cd6155c2683a592dd54b00bf6cd636e0fcf4d454b33c5831e227d27b348c9a388ca3d8cc3a1efa15be8fddba7ced9440755766d0b8bbeb9ec79f018b9363b14b0d2cbba8ae6e3c9049f94762524e5becbc5089adcf19e74a16218a15f35423ebe9ba6f4659d2505c4c14e9c66beb6df65482d374a89bb6b1839f6a67567b03cc414cf25060ac0176566d5aba829bc39e6cd134eff3c7008e415799b99bcf10c14cf1f17506ddd0f48f9dca44af5af34a01166f9be4d822d15cdb381a9d21fe35ed4b4b1fa30a9511c1b1f7f9aa2ab8b7801adb1ff3b18da766a3fd7a2395a5c9999ef1c9ebb6d6f375185525382960fe1aeaae5edb6a6df01e4fc0890a92d0f71f8be1b30a821982b22d585c03e6efcbb4b10064d24c7af1a00d0f19f2872f7f834bb03e15f11a540ed64c7cf350998ab663d6eddf38306190575369263f896f867a04883f3686cb716c9a9d4bdf3e35a3d8ffd77374460ef2478526092917e51d98e1b43ab23637cbc1a11a53d08851e7a9427560d24eebaff98204bde5c11aa87cffa586543184bf813f6d81c223f1baee9376750b333e8fc9431b601016db196293a36ebe08324bea905de874790c060ea8f33cd62f0533bd52e0ff4579e8e942e8b856aa5bf21e564c4f8929d453e82b294ff7e8c2535f7f813dfef7e71595ebfe9cc009639b533f0fa6bdedbae49617f34df84bb57f1f2fbf9995b2ecd6270fa089efb41916ff5d45e3fb121e907975246ed0089c0fe460d6047c5154685ed53a346aff09f6e8648cbee10680e8a569854c9afbaed33b105dbce92a840efdec156dd52131051749c6bf8cd39fc5d35c785c5c81b047466ebb293922a5c8319fe12eab9e6b4cb609bcbffdd6c0d2e06d1a50b29fd6f6c278789c4b6d18b3f713a8205bd6012b773bf446475281c22b16196c0f6290beff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
