<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9cfe04337daa8ef1d481024fcdd2d0914c88ad2d32921d06e7da9283a2bfebe6264aec6fa189f815fb6f92e1d53bbd608686580bd2bfc8564b7b0e5e763cc7536f8945dcb1ccc20718993362be46893883e9035d41da929878eb535ece0f0818915cb861323275facfc72015d5f8cf98175d70bceaf6316913d7fa39ebde2b306e393ffa5e4fdd5743bb5486b0ac78fbd27f90636e93e4b324e48a5bbce3c8349ac684de75c8a69134709b3a5546116a14b424b7bd69cbd4c7ff9d308f40c68ba16f4ece1e33a9350a7deed8a0192c15fb6257414c6bfab6edba34a78c1da229652a66627239d92b8b4f9c0635e77ee6beb9e2946d8ff412f0b3ce27a233e6182b2857fe8d80d74913eed6cc5e2cf14ced7e376f468c5e12e4ed6d8a871b8dae1bea967304d04ca755e0b565a18c44590b2a5d0a305072aeb49e1371a5c5f6ce3867b0ee5e12f3f92a3b2c92f08e8ecff85079ab0b7dff73beea57bddae995038d11e8e7c6dbd64403f5c1a576729f16111d21a4f61b2ef639bd1fb7532dfad96c9a17756619a07f003216d10597d6a48add22bcff9f4a3cbcc042ef599b20a16f1a57b3ef8ef2ee985b69a76ecebb5bec5b9db2c238494028c5945dad1a84b4c3297ad8add6df02938377141c73fcf5a041351ee3c0d56716619722c98398f305cf9065e03b4d220dd9755fb739f2f4779743ef9736437617eaad1cde45fe004b365eb63857835c0411b62798d95a93494aa0a10673ab7f370ed4eca2465d03d7be75e80deb26f33bd4b711f7967b6f35a6349dffa237e21b2492a603a3cf8a87ee6cc759829f8f0bdfe546b087dd853e7fb96ca74f88e863f8b3499ccd8ac3f5a07dcaa2d8befcb692568a575ab45967b12704a80ff586a4caf9c3b5045249c3966bc8e12469c9787d12f4b257a4d4d06a99f67183cb7ded034935d35cb269e8e6c89b957cc749411a25ce707ba11a570e2de041f2dfdf2bf12ae8d2dec19b27d435afab95aa2d279c6a87ca826484042467222abd4de17b0fd01cc0e45563e539def988dc2d285d0ce073246cee1456fa485acf72bad7ccc7cb2133e46327d3cdc249124aa7660021def7cce84b0a384ae7056021c8235f0db1451fcd24b5dace3f67a4d488f9494feff29831aa19c8f63e74268a9fdae8c5c47acc4fc00c3e98207ae0ba3c5f1cc6948ea75af289ffb647acfd9194d59de53e64db7d4e35744925a5b7d7ebc14065b48a831fe8a43ead19c8f16cf49fcfd36ff75c5195b94087de76c7ef236e151d5f635ef479ef709f1801151a97ae3f2d571e83064d4db43bccd0f64a937f2a6ca07d56dc2cf62aed691877d28745a6cb4d65cf74b2a66381b2501e4a8660c636372ea6f8f2d5aafb9dfe9dc5faf5996162a5147d938360a07fe6683e3a8452c8f61b417cef68d6a3463621af3c8e25b9cddb382c89e5e71614a12c71e78d2017769ea2ce6102e55419bb4cbbcc14b09983ba8b848059fb8408cd780e5f0eadff3758154ebfc18deacc4b6118274703d107ace26426c10943967bd062ddfe21bcc819c49d63857c877a3d9acad265e7174a43cabb9be02ff77e00c08354f91ce88f0f60b4110d9c127b62c1aac1e3fd7e946010a90cb70d2f07ee8e72e127662226c22343703e735d6ce1ebfbc57f28761e1eace54d6102144fb2da20c9cd7827db709da025204f938e5e0b184a13ca3f084c5f08cd49dddeec0b25a4bd07d748fc5e8e3c5b6aa8eff9992be48bafcffd990b1dc4b55d2a1fd999b45e353bedd33f5a19d6f2eb5d59b369bcdb772fa212aca1eb5e2caaf96eb56e0c051ac5c819dd432e1cb71f0b4ef315bfd8dab3c30eed3fea2ecfaad9ed584713495b5f2f7e5c01ba9f510962bdc66aba1f254bc9b09a9af4327b26d25885bf334ec7ff8ba7dc21a9293a1683ae33aab7888545a282bc5db0b590d5db68d104a8af80e0aea4996650c05faa2099f1b58297e8c6025c40b5cd93b62c11b1f96d9fd7811a7a8242524a8db504018421cae92b38ad3b3c317960efae1caa911ddc2a572cc631ada2d66a15fd6a6fd212e0e14482799bdfccf352112a9a55b4b4339cb0193bc8069b976b9aa362cb0f9622c1a7b3fc63258cebbf270448284db68ac6dffeb98211f8149e274526f5a274f9af7ef9f856bbe65f73bdb7f3da7a44c38cfe9b4afeafb4517871aa9010bc39199adf03e1723f9cab5461fba5f958ca9c93d47ef279283a3588ef1bab101ad562ece69eae56dfdae2f0c9b35ec29c9d64c89be046af73a869f0dc4a088a7252dadfcea9c8a070f8e603229e31976b53076e2fe13eab539dbb11f13a5cf74178e60c24382fa45e845dc643550b829dafd044646bd28c7cb3c5f10859f398866a6a105a7eaa428d2f695743000cf1f33cff9e3efccf675a39244d685d2e029473afd9783706c0442effb8ef1ee0fbf5143715c069999ce08022882cb29a8dfca800807e9f9d193d364bea8bbe729e7754ce82a54e0c3cc27af2cd1f69dabc4192c6ab46be5b16465c782c9a224a9d9c74dd559e1872f57213a4efee2a1b760be92a06f4d6e84c8800820d82b674cf36e12037fc8ba7aac1bc2c308a6b780cc59b7616ffa4ad3f629230d697e42f42208165ac540ecdaaa3b80d6630201e740b3f9d8794099a962b67e3605587d83597de02b7c1d01fcafa92d3ccc95437d8a2c0dcdd9b359230cf4e13b8ebc188687f8d5253c89719e1c6644c5d0ac8c2503e066b563e1dbd27a62bea765ef0813a7b6210be81fcb8346754292e7e1f7e175f83d40dec09e5e2cf91863cce38661e0eeb1d79514435b0973e2e11ef8078ee3d0cf8ab2c50728ef3628fc3391ceff0c3d1e2c64ba28684a857f4472af627a25be3ad6826ee0c7714662a3113463322624f17d60be77eef55f17ebfe3e2b2cdb788ba3025d7067ac84c8a8eeb5a65738f4424d1f42501862c1a0749607ab5d40f73d0b35841bae405e96ab3956b40f55b8ad45a62ebb1ff42b4078cb651781e41efc3bc1743a74770ea362a4d7e2ca7d7ad9a9c6f3c1705efe7656cb3daa3aae671e88ed90004dca351552c1aba038a9675ee610f82b99c560818c7f104be774758b4d3d72e3a2b1c5d3943acfb205c3d6fdfec85e4a07a2d4036334d0a6d1b8aa1cab49267e8971ae959a653b88bbc886d5487df4c71b0cc020514f4d37c8c22baba4bf21c280ef5a5fdd180bc31cea8fcf93154a98aeef5c0d376b828ce2aac581ae79a135a9a3480c5ec611d2f04d6ab8d525be09a639f0626037160c879192a67e705c3df1e4908879f474dc81dcbd7b85c7768c6e0fc5c8ea8578216d5b12923d063c88aeb896f696b16124f3fde0eeb6c187be90cd3bcf258a1264d4754e633073bdf05433bac49278ff78c160e77d3afafb98791ab4ddc39598dbbcbce7fe1f6c8ede40d75270e0beb46db8ccc784ef21a1f6858c964d2fc1b5f9070e2436c987054149a9b1c772442a20c6cd210157ac07694f36ec27584e5c723e191dce55e0b9978f1f4d25334f236971ab3980fea9fab15db946f96b9ecb3235a9f9dc823ad6354dcb91df4cf6016fda2ca42557cfd6f26624f90180fc04147b59ae9561897fba00680eb7592ae6f638445c3b6b86fe35d441868b43d1964ec5dba34ed0b68aa52b72169e283aebf5d2fd80ae92833d6193c4390cf8376bef7742deaed6f0b04fbc4ee4054e81ec28abb03c5a9605d2be9ba8ceb78b521a55174c4c8bce0c8f1ca172fc0e4b588c416826b78fb627bf463caf0f2f9b770a47270c689b8d8ec469680b60273a6944cae0d37fe477dc1fef2b5575ffd55d096d20e794ca3aaa4515d9c7a0ce0722a8a6ff206f9927438aebaeba4609ac9f4392b0d654d3c25ca434ee2f2794cb1a812019d44648126e1c48ebce576e4c5e27d3a731701e0238f4e28d1983c59aaacd9a7b7ea2d8b1b2088ba0ac5a6a62f45e01b1a82f1a35397867cdf6031b8ece54dcdbc239061a29bc4592c5f4d37b141a013166f48543c6e89e7d8ca698cddcab9b90b533eab7836bddb35c2493059937310628c06e3b13a2f833d74bc4c0b21590e195b224589df5118cd074329f8e38b016229af676294ade6775068a0aa5dfc09d0b093e0ec6442f94c566353533cd1c53c6b685102664be5aabd7e3758dcacb1ae2f4006a9d43571979d450887396c31404bfdd58e3c42b766aec87d2ff276d19923020855fc65bb6cf6135ca6507585e600994992ef8e2e3c9ad2ac470765cd90497af98fe385416fee912488162a50a109df7a37a5422b05ae2f08bdb4d551167aef164962ec0de4eb6fab806a9e90a80a2a978dbd16ed891ea08b1417e103299c3dc9749dcf710706e5a63888cd6f6ad3ca731ddcd9e3e12f7e849d8e581fb32d2e659af628c735a8909590bb3e0b7ee6a5d448cb6c8496bb94220488abc547bcb2256d71153148971a9aa0dd78cb5cc9c857fe298f3840cebde895931ce2565eb6bb2a96e929479989009442eb00383010d8eac808532e7393c22aa26aa214d3863fc8b44532ffd0a9a13b0f4559016d9429786ac8fdd9544f0263a0114a97dc564a3284330df6f65184a45025c94ae27f568b354148f9e3006ad275be69884c35a7e20ad2443c1a9d9e31aa08d1f51227c843f4daf3084728696d4ac99cb857159c3a42e49c1519bf07c07090f9214b13f6fed376c33a74c11201a6f282b73c20aeebd150ab72384fafff647de0aff9ede883023f67fc84d14ea68429f8baebbcb042b7de10b41b52889b5d8ae4ada801540475fc636de312b3d4b616e9b481bd0afb2d7ceb51b57c349e0549ce298293fc06e5152ff22240bfb7c01c69f5d1d035b4dfcf4a75701db9986e517c7ba76df1a410f08d8d114be45eff111036726dfe90c4cf5cf047164bbb43c030b6b1f9941a0584cd153da88e37b7a3873c65a8efce1768642f7df26b615ccff8494428c7b039fe3cf590327abb1b16a6217a24f6dd7b1a454045b946ec6d2f0105d325e9d1a5377a74b7a0fdb76fb7908040b9bcc19dce8f3aa0a440ed74e0c9b4b0281f85224bfe536bb9e051cf0269f0a87a67fea36271fa261c8576dfca4407d8513473fbe214cbf030636ffacf57ca9306dca2a30659b41b98c73d5a8362bbc688ba1372a75dd7ee6bc2fadeb208713eeb5e33651509b5919ee48c960351e9fe611a5f06a3bc45da3a211a0272273e4ea67bbfe04bf4e54b8c9807e10208ebdb6643bd7d3a6d3c5afa717a57539c02b8b88c4294503eecdb9fe2e91e1de74b30ac194d384d108028748984127e9c028ae49780e6e47869fae53ec0221622919775941c501668013c76cd1fbd2d25d0ee8898427b31da7abefa5cebc7a7d5ef402f0e59b38f5f142d0ea04716315969afc55320b4fc1ec88353821b660b65660fcfb0af0332493e2c424d75579347198a670751660ee91895275a34c9b95b6078dcb85e3054fadd66183841c6c8d0ce6a49398c747730148d68c5740fac96522d58b565317f6489f39e1f212aff54e7e7ae178070a9906b42b6ae3f495ef1c3c46be24511a80040df79233cef061e994c2a1d80a042e85de35682ec6c597a81edf05c0ceaba64dc5d48e4198f48019eb20f4abc52fc727d5cd6ec21552d34b35e63cfff163ae687e6b5a3e2a0fffdeff2eecfb40780dc694212c3414726c9eba96172f45c387c46e1a3c30e5d1e0d63349114e018c083a11323c854079c778cd03b10610057f93c78dfab16977ce94b625df99ee0ca904193fb5fa7d5c27f085a3879577bef06f9e8e589ffc88a2d95666e4243672c1dba01919b759b4c8cfa5006b4e618eb960794667f1e5ae1721b52d85c5771bc78357ac4040204ccd077263efb70d6df0cf2646fda93865a9a3307a98bde8706c44deb56890fb5accc1ccfdcbe93e754ce4eccf94f6de486a3343737dbcdcc1e7c053f47281f3f3769922a48958aee6956d21321494ff6819da310782ae0ecf75591487a8c6ca76b16c9e399a98bb608fa4a944de3690b14063bc2dc5fdeb8598cdf448c012d5c7ce151081067bea7bb7f1a0cdf0024b9011c633d6b2cb6592ad41ee5ff205f11a2516721dc961168804a3da52fd4316a6c2be657292aea0e8fbad0fbddd978b8310b1216a465ab7d1975a1ea8c3bf8932a673475df782606a52c57a0c6befae62dbdc619499f7e4f219b79181fed4cbfe78831327de8bfc27f2a63e56951bebf4e769f89e4a35315079384a4db871e952b5f7494f503bd9edb367de9d18c8a0dfa7ab148d4aeba4862d1d1be97078dc454c6a37f69a2a6bd3d5f7b842237223fee59ab380c06fec8b703d0444da4ff695a974b33ded892dcb6e61270a0b3e28e803fbd665373093e0cc35c5c6d919c670017e1c1a59421535647d4ea336da90af22a019c887aaf8485f4f090a2c9c3656e2c60e60ddb0ccca67454e60c255693f8037a9f0240a7a2643b36e9037b6075bfbe2bc574ca172b82f141f8027e2162128983a4317f77a7403b3ff8f3045d577e4b89b844c69634f35e97e0d0ad0fbb747e4a9ff0598a594901ada97763814be6071537ffd4749dbf944c0d50ae140ee372f0622a6b1a69dca5ea21044f913ecfaff8b7d6907b43032259383120aca3bf21157ec5419e5731abec66b139b43dc1b299e300ab1354ba8d8999177720d729504cca7d8f35f2bc14143f6aa4616f3c80c64a16125d24338c36590b8fefd0606a19755edb9cb3b21f84853f1e5f0198f9ca974a63b017c37bcec75c56ff8a8eff91c3394e9306c934e0830714e46668a43f78f5c805c79042b630d5a43cd2ef03e52fbb25f12f14f1a7f7daba98ce41c1e9f6a50667ef61a8141e2ab6e8095597af66ff48f2a869382207c06bb98fed9d4353d1b5e08a5df1ee01f4f9855500d443ca0b5ca44fa8d811214b10a3288756b7eb5b45557ab791633c8ed7a45d5d2a3943b2dfc22bb7b3541020fd14fedd4038f4c5a4c1069a8c5f24ddd1ca8907fdd1578baf866b60934e6b4c208d816cd5c3fc2a32a9d6db25d8af3389d8760df7f4ca588755e4aa97ae2f4195f07a4a07b4b4dff743c6380b35777df5170d3d503be6dbdae81440786c53493ea38c3c6720b9c73653941d1af2c28661c969ac52905ff70cc6b12ed31f5afab1642ac88d7452b43eb68400eb001766e616c6b942da396c011d28c8b45a057993cbb0b679c54ea334560ae397aa2ba1f2c8a16e6e71307c50d95be9a0c5b44ab6cab0e5c5c3a8af131a02abc0ea471f979814e3c68c7c72836728b419591d3b3ef5eaec7b49b47922d87da812d420aa0a391b2fa620fa5f9dd5ea640edf6a06e1ae4f609ffe763894b155bd9db7c9911368d17823141c6f57e54a2aa2949bec81dc44f9573128e8b8dbc7123fac9c7b03da160a9daad4b31a765b4d6e31593e0177a98abe2383c08f4c3e6df702c657c27a3f40f4de30277f9e2641875a8668431e0db9c97dad2ae8d41c8b823a005ec56f9be1820cd832139b1f31b85f81801f975c98a69bacb94bcfbbdbe7ee8d53ad1739326e292c2f04eace9bc99a2d4106ea3ce84ae270d1f1116d678b87ad5f46b20515ced8a464085fd9ba135e363cdfaf0ead2a8857f19ff547ab2c1d875be709b1d46960c26d7f496e6b66214bf2dea1053f09ad78b4561212f1f902672887ae8a03d76d3881a02bdb93191742de965420a74c3a2c0577ee06446b48dd37206359e73008127528afd76b50bb1203ad59d27e3dcd39800b90df6af0f92ebea22d2d56dcb0dcf25c585406f0baa37d5beffbed4a51ddcd7caa0826760305c7efc2b083bfb8ab36c311bc5a959f2cd971b033bb84dd66b108a86f8bdc644e369dd652e2a10ce082020a514dc8c57950790f2d7d9d41fa63ff418901242de5653e865cf8fcb40242bb62d73dd489985d8aa059cbbe49dcc588b9906e83bd7dda8faa7f64e1eb3601121dc5b8dde061fae4f1daf0694f2970b2a77854278c2c5e0c2d424797231f5189055dd6c97b12c9fc184f61885a4913d43f82c7fc306d5132090b95eb05d7032f0c8293373372079e8f19c2756758ed56ee91c426125eb9015027302d811648ccb244ecdb92d5a5914d908e23ccfd0e00fbb85a6177e821c73adbd4395a0c32f9e69ddef4d3e35aff149ccd9e64ec7987f4b13fe6d4168f1ba0e0b20450246cf038a762f096638adb89d1a7b9a39a4b114f082e485e26a4677b73def32d155a671b119d65e968b288477f8ef7aa9282e23797294006492229a9b5875c9f170219cae858585829da8867fc9d0a21f461b1e68075a3aea715055a405b5cc8c4dfce52c5da3ff94f3ac45c154f81c64ed5229f85eca04bf5411a6bf2072813090a5355885abdc6643803b8ed656d8846379305940314d7be8741e5dbb843716304591c78ae13f328549c9d3c2af478b4388347e76be903a4e7069b2e50601b7a2a730b7aed72a192ff43154a1422dcb3b43a5ed4a35ed8d8f0de40785e1a501e5c4e770962f88d424aa723a678f7942abb3ced06ad8dbe77e9a3610e17f3d40b3b3bfaaf459fe8d87e6c6ea158fa09ad52e2bac5bc3ee5287d1ed833af6c3dbe49ba06ccf3f9d720aed5470ce32c88304558f784e4f07885990a7486e53535f0de98484c178b5e7c14b6ed25c3043291983afd3b0db5c7f991d34f788bf5e4eb8bf2e1f96f8dba0f74c3fc4a963a4cb5ab41d7bfa82d66ce318f3617665768598973b1c794345eb9d600b9979f7afb1efb98da48f419cc15354edf8646bf09221b5520c5eab0c50e47cab63031a3014a23f5673744f0a3b77e694d43a35c6d9b47ca1edac6b48ad692bce2f3ff7979357f62e6657a647b53ee8f3c516e7410042f276e4c4dc5cda15fcdbc680a2a099aa55354bd783657be98b707083bd89d11ec9456c155e5694ca3f95cf588edd9d2cce0abd65aa5787d3ee7a31b4f5facf533d2279937100ae5769bcc07fddbd067ead9910ef188c78c748f397d408b6e85b683c10556b649d47069923bc44094ed7000c01fde247463ca0694635597350ffc457c3466cef3e8450d08f42d230727a3e7a2d51a4544b208421b0358a6b058a78f01968c05a2d2ac24ca6891af905bdef643476966a4137ec7cb9103626fe00fe12998997ec9cd64f31416337d3d78cb78d7fc1fb7821c946968cd27110b6626f97b14c46bfd62b278c3782d33c4710540aaeadbc2176216cf517dde680f2f1691fb853c2a90ae83184ad252b7d6aa3d820311f5bd55adeecdd2aac98e8d6e25e14b7a8609e5018a696ba23ad823e58798eabfab580c6ca6f8f49505b13719d6f8c8bfcdd22c7d7ccea9a13c9840815c9aeeeee15ed7f23a351b5f0ef8155c1127595a533d66c01aa55e82a1cbbc59fac0462e86d12f248eefdab4aac59769818cde74730e452d939b0e243632f20f0f4642c3c5eafd8df43f23a8f3a9b4c33fc65e9a2081296ab0fe06fbc46609d3ca3fea42af4f6c5ab32022537a611811c13a8630eb5e56ae03a694752e834d6c54a430ebc749d9629a2f82df98ead771fdd209735c2bc936fe308e79b7cf5f280571de4ce755de6408fc601b43de513481d7e772047c07a0d15c882537b72fb33faf55bc215640ac894cbc0071e3ec104f1405181973ffcca6c88883e628fffd57b2e23d6d0a0caad568fe3bf8b24d051c14bd320595e6cd42b15a443bfd60742fd0beece21f583c604b30e5da03dec47aa50b37e68ec4243fdb266a18ac3861ea6e972b7c88ebddcad96081248e496caa9a6f657393c856ecf50953efa2c481a40aeedf11868e583b7a17c70f899f2e3585a00b4c2c00ae10fab03e77cb06d778ab17e6fba7a9ce80786564cc098727272e241f2749587937f47c75d21282cbab304968d6b898a1de0044719d7ce4cafd1a693814a7c3793d3eef47807a3addf3608a2ffb807f7ecd6327b324a7900f9de8880e3be7e7ab7f39a4a2a7d5bcdada9270327e2c684c3d4a2d8111b4cb06cfa8c0e2f63fbe46dd924b76a6336b352b33cedeb81f73c3160722120de2d5fa785eacb5f19c656c88d56afeeeff1085e0682cbd4b6ff253b9009cb12e089d40446f3dee32d5dc5fb8553847b6b32b1e2104c17cea4c46480785e769e238b2e9b9c2a2d0e7780835f80ab7f32c6f10012bfffb52ee3f4dc43fdfbf809e66a03a34800758c5775516cc35bfc396ab4ff697e3ec2380e0e02b0ecf1083f52aa042dd436ba5332064872b1edbb068ba1b0b1d3af2a0064b5c3bf832b6f5153c978ab669bc27f18b7078c7292fc17bd1e62f2edb532c577c0cd7ac3fd2ab5ad2e3a32c1bec22b54f9f7ad4c8fae22f352a56aaef02956010c283450afea945210eb684581dae4fd75511dc18ba46440c5cfa74b41c77213a08285dafd612709b7273ab79d9690e3489f091fa36969444ee638fa6d8e4360a89cb6baae4f17f7c5c6135f3bdd50ce1cab761b54d319c50b0f9ab2ecc23cd6ce68e9bc15e3d042744f369466b7974a7de46e1022e0963985a33b1a9c586997bced3ef524ea3cfcc384f60daacbb8ff5679d349dd28ba89f771d919bf14d2ce78db9c284bf90d449f2c98ad68597783eb9c547905c9dab60f43a52c561b68c602154eaf5c5180570b66e54022d1f2b70337def6adafd33f6c558d6ae29f323ccf9912f253295fbc434919538f1e380925e83ca838862f08188590ecedd67e43c47cfc5551ab285b3a43928d68bfb2c85536e141c6371c17476b15645ff33058d48466b5c5cde70f4a4e6377fc68953cb157c1892bb70d071ccea0cb4e6401cb3d4e6ebfa33f5463559fa2b1b75bd803fedd472e214fe147d32d47df5312b31702e897143c1f60b78860995d5800392c2d6895205ada22ee9166a87e5eba0a1ac02a960b8af5c066783f280fe4ee13514c301ecb1a9013baed7fe2061d5afa47a780af0a4d71416d7b49606b04dcf1ed63357219c4990387eda1db32b60b136557d83c5add7972b9e2a86e448c0bf87881b60d0c7cf8ed686bc232dce7d69ebd9bd04e6cd522b4b4dd5af36498002a79083fb9dcd5884742ee4584290844586441c06f02edf067fc5403ff828f3f662357b5897efc03bf86ff750b26fddb5fe5be55084b84f0354837c9b8955a3e6c6fa9c81a5985f3f0e746dbcc1855f257f61a78d4b786e46905cc94f1c03372ec2e7f000d34cbe50849519cf2258a7e354c130cb57b6d78605e0999554daa001121b056d5512c3d7a96af4dfbf82b38fde10c3e9f7e614ec3036a37b6b9efd6e9c5e218a86cad55885179063d2df57dee7d2cea87e513e3bb8cb366b79fc9f7151f9bb8ed1750790b1c4221af006dcb059c9f49844c26580e2e77b438ff4f3174b00d1e2732a9397e9ccbdc9aeee123560f48b48fb63f85ef121b3167a4b626dacb35a2db4eafe21a3ecb7b1acf2269d44148528d633b39844af677030e2a8fdfcf88e69d4d4fe5ef012a138f585c256898230076e446dce05ed8a60f055e83be95c16bfeeb40dd29c2c9d64dc4a0aea8616080227c8e2ea77b19d1492d4b57b4ee7f5e1df5097e9cf5d8e9d0f1c6d95ddd64296293ad6e392b57710cfad449627cbf09849283ad62eba9c8a57ae9460ebb85210fa34d0b89c23b53f876e178a5000f15402e70579e99f537621507a2edad7c4ad28abc9d2faaa3950c0061b1e27be096ac920bd4142e1f10ef79a51203071be17508a87fdbc48b981d33d0f8f8581c03e27087d67d9d0776ee0fc95cd0bef73c625c30f92a21403b1d6ec963b826929affccd36f4bc0eccf30921a842a3733ec16cbe89dec64d7a9989d3b6d6af641d32903b5a921badde89597628ea6a42e52213feb5cfa611cdd249ee8234aa96aa2a2d2722726d429721f165f376888f637a81b3d0ef889d8ed8a719fb7f29ea0579fb1e9919101e5ee1ef70a92c256b99b15a434938abf7e6c80f86da1dd3be0db85a9411b4f94822a98b20d40e9f74923eba584770060e75d6579e9f4717221a296a76a575995fe392a7962b2f7c3573c4f657e9144c3354d371ab5061df3692458de198e8447d2d303aa2a3124f1cf11a75a289b7ec3ee1682a79a06bcd77f005453b6a1070e3b4b8d19ffe8cb1b88d7423a2eb870cb6c77ac635414e7cf945c0df16dd0a816f0a200a0bd12662c9c3f3b33a42762db6f7fff84cbc3648e3e760f538286ea90da517f957a4dd91f097a84814bcab62a201248f72c5d84977e637545ed9609e16eb4390c8d267a61e1fbbf9a39dd5534f3ba35a1912a5da591718a23587aa98470d0b2fa371833e566cf0d2d120af645d3a44d16918d07b4a9befa2290a0dc7008ffdafc380ece736403b01b29d1da8e9f471c90a131293efdebfa61b0b2d36601ef09f8c1274be883af4993f8f1a88648df700453774f9dbf99e59aeab1d9a3c1a7b25827cc727264589c80e940ce23b21379e32e807e5be5f46fcb8e8c32fab55ae1d8702c2f6e4ab720b181e409464904760197c0406f34f18b2e851a03e608e9b701839a6f8f0f8a37fb0704cbaf3655a9e8dffc65a066a0867f8ec2c1373c1f20a17001a6320cc09e26818ec4a8951e826eb55db80da2f5a1b305bf7997d31158f26a00e10b9ae0fe6f9d1e0bc3ef10701f9fa6564ed069d9d970aef2cc06f78558687fb97be89b54e0aaefae6bf9e12650eca56c3b78fe07fdf87dc4e180cc8c5d386a01ca05a5d7ad3810b76bc9d3da593a1d48266640c81976019f3dce368a57b3dcb2de942ba94ea2c321dcc68753a675bcc937208c6935b44aa5df36378e919a5386c556cd787b720858a73c9a26807f0b6c6da25d5294159865e1d2c9743abf21853176d75c2148e47c2350d81615e61092e6d74d39f756382ae561edcc04ff318046702662564da073bca49230bad0413231c441245e5b38802b9845fec8074fcc10f8dbd90b01aed5498edf8964646b1d25a0e0b46b241f159f2c7f5611f00655d0b9511457585f013267cf0c645038897c1faeb0f140618aeb2bae9c9cc08d8f1d084cc867d88e517e6e85f8f3e2349bd16bfecea8a091b9aa5f22b4e38eeb4cb13fbe0c7a3417df90b42e8b623fc59099bfa8bf5649ae30fda176628c0924a8fdd2e86104717320c6b723c0abe77c9b23c07a8da21426383d6f93987f13071f49c1ae1d26884af5de47df649bb7db62b62d32f813cb475542d5de68fcbb0428430f5bd92266a07b39e33ee5a5fbdb39811cb19f019b3244d51e92f60b896f597867ca87b33d7b663b526a0da95c1b414938c694cf263ffc90834267692c97ab3b68d17c2a6fe4ab74c6e4a60c3a0ab0399263cf3d6d7493579682c31411ddedc8f80a28e878da0dce2c36f304dbf0208425867fb5bade0b27718aabca62dcc1b3ff398c03e7886e79f443c32e0604eda841b0d4f61587d1ede2ae854724f12fd8b5354923fc296a7e0fee9f454d0b28eceeeb1cb82c9aa372afd7a49ded27a7e05b0323974535a496d0b09fb2fde434db0313e10ea1f332135d4771545a8e21546cdb2e796f6a7a4babb41dd66d1a3f9993f011ff9f90068a9fd9b899a8e7741b55f98565a384e8a72176948fc256ef319cf1519511b769ae35e888da3cf30b2d043dc1c7d573a6a14d608d13a9da32e6545cb70af8625ed5513b079d6c010bf41b9ef9027f609b2259f35f5ab37078b0e34af097527e319489dc9a41d6be0e6c86a5f9875c498c15da641b21e8a9d2db39e3c39dd6b9d41efedbbbbe776be71b06214eded13774f7effa6d54a85c771afa8fbe1aff300516c898c5681f7f15bbba6d66a3846e3cddd9fc7152ba65bb8007c4c7c0bae1d24d2129f10173289ff6676d90dbe0c7817d4ce222728141c337530003aca971b442f4ecdc651e6a8a32b72b860f2921948246fb89b6fba91ac7597b2610114458ca374e32873a0d27b3c1876d73c6226e0f2fb2d50302eb15fee30c95114a0190eceb19176e2d1bdb27fc7a2f8d28018a1a9739b3022f2b40d5e64ace1b2785fe8d6b7f23677f6ee992590b4e6b6d624c2f8dbc647cc34f6ce49b0d0b5ddc2c7574487f43b30747ae31c52e45a381f32d230ffe645ce76d324065a695641d7975b25b9cec47529d0bd901f0066525043e4e5272d48fd39b564fa1676ab73327c2f7ba113a823ac3790e1271f9cba20a872d093470327a9af6280e63eafeeec1772d56c9c47349fc660a87e8929e0b6c31a5df23bb1ffcc1e4a522a97b8fe91c8de6941bc4e8dfa996061326e6b0e6c5b5ae22804923db37fa07dc81ea89906c617fe79a41fb1671bf093a424859b5d688e74b0b2c18667d4194a941b780a7601689d754dcdcb2fa5f958dd2e65ac80eee0b09b1a01a3b3d5764af60441372ad0950dd755a147b35976d58f962259d00937746c590e8f19463c3e49fcf6d5091a6bc80c7233e0862000109565c3fc16175d3fa229a06be75d99884dce321aa8d1933b767af9cd10d78fe5dcccfc3514a8f6dbd8dec604ee1049b3f54addb75d53bc8810ac3ae22dac94f9bc6ea17fd68d67c47fc8c71cb7ea63bb55be05564bf572a51d40128b4506ab9ee3eba4244e1eac64649d46dcc8175b35b0daafa809d4eb352ba1e74d4ced0a63f0d918a441bc6a913bc2a5ca17d07d945daa2b769a71b5e44ddc612a23c53a5cad49ed66f4da982b34ca638fe69cad3705f328a6facfc8eaf8abc2770fb6859f7d1e52073e3595ceeb05b7872aed625c02f3d4742c4a4bd61e8491031b13f8593ff77383f8c8f1bf3052e8d5726b43db46f9a528a7d0038ee22d5909668560df74f287ed1b841537213c24b3d7571d51057144fa48b876cef8ca6315ab5ad1b578592170b6fb15db5c68f69b03580e9dbe73967421e7aa093f018878b7011958ae08995522ef889257f737341b949082d3501306fae1935b3e999f9cd10c821fc772313a949a8407499e1ad599bd7996c2757649c6c8ceb502b0930c63fa80db487b9381e24a2967a86d68b697ffbf7ccd28c335ecaeef45563e9fc6a5a557dbdd30540d141651c4262a44d7823e051be051a5488b9edeff6c4321a6382415322668a7cdfee3b6ed01fb63803ee3834d35833b6aecba7a78e579b05ebf7f5bb33d594f7f211321c3a3c00011374fde9603d676b658037f40faab3f6c5e7d9d2b0d5d6e87e978db913e16bff3b38d82484cd07ae07a8abb2bf418b2fc04125ff9e2662f43cda5c7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
