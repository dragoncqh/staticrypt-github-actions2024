<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e063faf01ab13f41d92eaac0ddb6014b1581b75b304806b64dfb1dbc114e9030be59537fcdc83e23e841216b87b31d55d1e642cc63eb72c981fd7dcccb057e19cf838387fa6f74a313254a3eed4badbd089ef5604ee506dd60ef1e10bec934541e0a404bf92220b3d3744ff01cd886323e48e8d72520155a05cd907f2a259f3264a36b65e14b4c4dee1f7c9b93983174dce9f4505d2c86f4c5b27b9d77e31a9c102899287c371a900511420a7c587ecbd79a1ef9df5694945fa10d8a40df1b0b72b2dc10d2bcff3d03d409131627173a2881f9fe13ec4f68206a525fb5cfb4015b0981b07bf4b2d35061cbac36fe5b626e102719e61b47c615aaa6365a9ff55dad9f4f15a840b42a77673a476a048dffa6ef78d61d5ca0b2534efae16103d9a72160e7830e864395682b827d73eda9c6b6fd0cf685c644087e25db4ea6e6f586f558f3f3aad297ef36f2519923422d14f5645cd5458659833671e08a715d6c2757b94755b9de034813e29bceace6faf355690fb3e98228c31396d537552b3828a96e19b614a1877aca144c29eb55263904d1cd2fbb36eb5d9a48c9776b467b0fb60955a40932e1b8e36fd4d3331d4c90bc75e5207eeb6b38e5c5f487c5958e8a024030d2e23755dbc2302aa6961af7c1a5a9493883a97f0e92ecb93119105baa71dc9709aea28a681701fa51e8db436ea4f2ab25a18b6614e610546d0e334e8be798c07622130813093375453f5d259600566c89a55f6c8c0c3ddaf86f9511b325cc5f534d4351fa1073d3a75710e8335942a87c1c9a45b47ba75d62cdcbb35539cd9c954a553beeed174f5b9ed4bf5bb69dfa155c8b51041fe7f5483063c846a75d86ff72a25bae8c5f55e772dc3397edea98f211537f90dc28eef381412d045b7ac2cb422989aa66068f6e5cce48f66403226d049101f518bff1a7ee71f69aed9a6005e5cd97f5f17f05ecc7bbea7bf410e524589ceb269fda965c27ea548a6ed9843899a256e853ffc70a6e8a54eb8bbbe876ded13723685533a52c1c564e038090eaef4a0cb4374e71945aebbfc2181d0acbf46570fd469a9d2a0ef49adc8de3565c60380483421e919c5ed6552b58cffc2dd16ab9a13a51e843c1d9511781dd04259627fbc4abfc925e0a48bca6224f00ee02279f4c244c9adaea5c29f1f6325225e0e155d974a15ee694454cc5a699452a31a63bfdece0a1dae9a3e31cfe4f4d1c61a6d46c0d9a123d22e9340be583e98f91db5d147f3642e3d175d137b238e620fac1d58606a17603ae66668c6fb0a1b505f03d28bfaaac52d5c4ef2bc2c3251e81d230ef7ca65a87a7f09daf66eba0d099e40c449a13b6782ea856a0da93a33c0f6f2b547682ed961cfe59281b5043042f6b2853794d66ded69178a280d365184e78abe0d51722d01daec5c504f90bcea5b75a6493fb3f3c31ad53456c0782cfb342a512e7f740c768a3af2965f9f223912e31a22d5a4317b4de75ea82018e9bd3ea4a01a79997be648f9ccfab578ef1a34808406ec1698093a1dbe3b970e6d9d280cc76a547bde3268e9d9907428ba095bf4bfd1e8c81d39bd5fc1ca2af36185aa926dc19e8b6ee3a6633e433227a98d5f65f129c8e24be0aa6cb3db65a8846c27525cbfd8330361e05b75477dd910fd95db854973466b9c960cad588500a6fd15c29a1d99dea3a76072c4e4c522ba42ee5077ff0e3b8a4cfaf571d8a1de81bcf6324306b6e40fe153b78bb1bc51b01ce26da0deff3467a1131dd67a0bfa2c6bcb3ca595af70aec28e6ad18c467ecd60ab4acdbf9d11792cccc2088d457ecb5db1becd429e8a16c688d3ca34f092e395848d834ef54477944adc0f1a3c401686611498ed079032418a8662ed9c54c414e3335e97b733a80ae2872dd1713e634e12244d8c2582db14e83c0f99c195d5e2206b03b73d9d02247033e9e4c486636f3510176eb9a185a082310e033b615579708f7c774285e38a4656f379ffdcfe2816bf67a6d079a55e98dacf1f5d37780c84d1544fd8cd153328e005725ad3caa51fa05d843835be54b1209a629016175411ff7ea5a04e3dc9c6d4db0f65dfec8d615237ec3601ab88d4378dca8df1e8c2964a2f5fd6c9210c6a822ad800d2ab984c93020a5b680097bb23dbaad040dde1aa630a27846069ae04425787c81b810c5b36a4cd47843b904e4630730c44d478fd9820f5257b91615700591087fbab018e7112c73878f5ae066e3a5e8d6a040469a3ba034a7c541f21ef0acca3e9ef84dcefe08465e5f712a47426ae4aeaf5219da298e9ce96fdcb4e64882d7d8d8c877e7bf3e6a7618f152d62b551ea37d19ba7684f8cd5b79f8d44c5beb39480f73ecb1b6ef2773b95a211e996d4d2f052f1bf8fb30d4b4df0c287d55dcf64937da4bd8fb998bb6eec4c13041e9737ab1a703898defd51b9f3f17d50d538533236fba3adc3c91e28acc8d1c4cee0e4d610b2ba893e9515e84782b15fefad2d80b4d214e3f72073b2ea3052fd16830394071e74af0b7e68d223eee785338ce92b0556aba1ce5a102c94472049bb88fad8c5e5335dd032eb87809ddfbd7ac68dfd9ed73d9a03212d2aced0087b2928bb7e3266e8bd1eb377104a59199cce5a5aaff8f36231cbde5a2bc7e64b224146ad00b8eadf01e7dfc3797bb9a0221898a47a4e24cc43c9ce45c5ffade5f87b19d95793944776e54c2221b38f3efb9f99569a48b0dd4459ddf2ba6f28e0e52aec2c35d9bcf0e6322366061a3930ab3551b7806db724a116d5e88671b9fdd085e34972d07092fe26c827427445ffc6155a9b0fdaf1e59495bd89f91359108e5c2a0e1ac7027dca05ed7116d6db2c1dabdbe4a703d436697762b5cb1d7bee10266dfc2c0027ba81e33d74d4f08f0e4f42b2925eda744eb8921346951b7f7494e7b8d128c74af0c7f888f5b69129678945954fdaa0b24740dffbc8c77ff2c8121ef20e3dff6f45775e75e2447f31b92c336fe6b9f57a17bcce2046813792f98a06febc33a25bdd2fbe852c1eafe4cc26df5e796fa7d217511ec2cea2980e3c779a8f67cc9b1a7301746a3761ead88a54358b16886b39e25291c924b229e06fa30faccd09050a52e5e5fc82d70b9c9848426e7de8a1a9ea6fa99c6e0d34ba11e1170ed21970ba6e9631ce67609f84f8bff0263b276a6c1d1358efaec9891c7f4ca062995412819b6afed42a571166eaa7653b7df50a9cf656ae89efd192202f51d20539653a041dd686e4e1a2fa0107b8536a7c9ee4841ff9d32cb5c1c37c8260912c7bb9bc3ebb7eae096ce45b14a0caac7488b02791625554e4205f72bf191635c8e43cd1156f1d425449a3e3678a0ad090b61a8bad283bfe99db749ae287a8100fe2506727edf9bf0e75c8849c734c2bda8f76ee8776cb4a294bd6d043d9d71b5b866802d4a019b914a0d883d43a567a7813c8b111372e7f4668c5b76df6be259e57407f8a86edeac1ed4721d8926e767b2e9dddb6fdaa3c436a36823faa5471c8d94e43c142018a6223796f1f4cb2d891e0301eb4556a363bdad0fbc9114e530e95fc2252b5780060bf82e712a712edae6a07d6096f3b94c3f3d7495b0122acacb3346b46aeaab4fcc32529a7b3087f99185284607bb5e6d28639f475eba2215918ee7c9b91ea587fe5ac82b68ffde71a0a68f8b8c572ba3f8ad29536111ebd5275bf93045661cf42135d912be79fd83cf4f4242df66d6cd658aebf7f223354ce12458d4b5e90af1a32dfe45606944632dc48596b39ff65b2c28985f07183999df68bcb364776469174d65b81bc5459497881e8f13d639d51fa0577acc1805a558f8fbafb88be85300faba6ed1077a4da84d4264f20d4ee09eafa56462115ed30e1e2603d84df802c47fb5a547eeb20982c5dbb462a1d03369cb2c9530b7ef8fd8ec5bde0b52555b32d7f936dd83946051162b1442957a7df9f42a1bf846056de50ae2f5b8bbd0cf83acdbd1a02943ad5b8eab48f3fade0ec86ff421426a7a3b7904134dc70a0f67bb85a1c6406ba9739cd0182855626e22da04c61404e4363645b41014f859b80dcb729ec406d989b46344a8ec74f7c99d717d104e44e7c025a3e3a9d655633214533c89d703eb743cb95420d50fdbbb6e7513ea6b6f08960c986c1a9c78f65b42449ef5e399d60655cfa5f500e716293bbedb85e177a113d5a6a23f553af0ad5c3848a26d2ae6736c8c12ff10752be7c17ed164dc4579c7f468ddcbd5cc2a56a4d88b4039cf77816a3965f8efabc0f2ff5e3598bc9355f07990ee1da008cb84591c7c838eab987e89b9cae0d0ddd961acaa61d4d05ef6448826d22535cd703077082ecf528cc8c6041b1db988123bc1a30848bfae82e86a02cbeb19b00eb28c4a3d0743700f59a54e80949b9495ae4d9905573889e2cb0141546442c659b70e478ca22a4d704582c179e79982ac4e30375ca5ba97e19fc76c15f06246ae30df4d6154e2c5b43eefd914435342c64f4c6cb20c686d098e1160e9ad6164e0b68fbb840d66481a45299d45686c337efcb4d5e7f06ec878e53e6669034db433aafd3c3249f8208caf8f254ca4719a2c96095eda55129450d2e8909fb2a2ef08e04805ca146f9afa09158e69aa8848707869b30ff2196cd3d3c66e52495137845cf7888d15dd56cb0d3f30574ab49a86d74275f326ba18779e7e043aa4685be2dce5d44338c7be05bc8bc063f66a62128df99b16217f503483b9d302ce33119de1d8b753548b52515f5b74255d683ac3875f26d702c6c747be553eb5d9cc26cc7e8f3bd64f26d94f7032d17fc7ed74ac20ceeccdb52130202425d93b82084290954d8e82d87711467f0f9d0e4060a590793ca942ad84acdec5a7c005d6fc29f843aa225a0a28332c4b89085337254bb260cd22648d15eccf84d94f4ae28d3d1dc9ba229447101fc6fdda15617074aeb0536fbda7559db9907dbb4bb244bcba8d4bf8f5156454c1077a3a900d4424487179b05fd4e91eeaa0f31b1142f3f876d8a6ea2bd0cb9a7d9d7986af85be7ddd55d919dd0df9e8b5b640fc2af06b0c7359aa01628225a620d26b39ce4a1641161c94c5aae8aacba65917e77e68cb17896abaf87137508729268b60923fc439fd13574c5b0534c29053877dd61bd83d873a95ee61fd2381274c6891decd08bacdd532032f6e33306987eacfcf277d4d7123bf371a3923afb8af117da0170a6e85760c18433e15345b1e3449c25f8b7c590c88094489541c7583c5a54939bf3a9ea68bc2f49084dca4f302d1e33b5541bba9ec0754cac7af0a8009a68477ef9028a4c87a87dc21199652f5b43b17b41edf8aa80ef1c2a5d8f140a699641ed04ac9d22e17776eed2bab8ab9926b13cd1af2e9ba888fa73ba2f01594675ec973ec06d8c1bfd79297e9a979b795052e1cd518ee05395c2a470a3282aa1404f78a4ac72c2b9e352c4db847bd20bb326fe12c95f1c616dab1ffb6b36aa8267768b4c660eabf5ac5069fd5dac360751fa4feb690e352c407bfab020b4548a7d1d5a4e5f4577f85e603d7ee2598a13b087a5b7572d353454cbd7e920b203779778f27f35adbd67fddfe065dd93f72583c83df885278fb2a0cf7f9dff923b0df9f28242ce528b4e5178367b2ab344b05395db80c7ea186105d6db3da9c4449afc740db6247610535e318fa3dff913ba9aa43ca5467f6a2c23d98cb70dbe01ce5e9f416c6d2785e0758601f60a9248ebef049d5ffc8cc18de954be5fabb55bc6e85b484eff5ea24f0236cb3822c3729fe37ebc29547684ed33845d009ce7a5a6ea7cd87424d510d94a975805ac7347319475f18696e2a66771ad550c3e4e1d0b065c5332632a3ff298e98ebcbac16923d8de329699c4d24ba8a7eb49368ced44a2629dac56a03b39aa0520e4d1a83dfd42fafd5512266fbf0e0d05527db9db467e4d4a427391a2d1bb70ae196e20aec81c897512bc0e4912f5da1b48021258b60ec6aefb396c299fbefc78b7b37e61ca55607bfda5843478fe92b6be91778f009db7f7f73e2ed86bb04b209f63ed191417ea63c35ce2718786ac244cf7d6bec92ce3abfb403df16d8a5a36227416da5216814e2e018a8a17f55b70dec9b1884e5399fc9626a23c879cf2875de2f7b82b4d2fcc13363802e704bd46df98151f8ac4e5f3175306416657e5e78c59c1a9297db41cb68e4a165fa586d11ca77d90db8477547828927770589e90cbb634b70ce33eaae913b5946717a7e16836f11a324583c460253c21517fb5036ea87a3a7207dc3af8780d0904d32b13d4b65fb585969e15abd3b94653dd9ea0f8ecf99dfdc0647067a639d4fd716fc353d1e61a34b366ef9d0fd48e94f304bfcd467dca2645d270fa9e2a02aa7bfa1eeda7fa9ab908f9992ab09c63060ab15a5b1d6453a9277fb29c119699e1ae29915313d674ad0c290dd46f4117283c2410b94c5c23549eebb663f51d2d301224bbfb6d244269425977016af448246f8fd3ec4634454839fa29ac81ddf4858bd15e38fb2f5de642263051fd52d6bff2b26dbeef53e52fd32d8c2d354f2e5274acac636928fbeeb14898fe012c0e1878e0f031f9bd5b05c10ec9667057d669f52600d249ed8add5de97389557eb8105bc390dfefa2e07b140710bb1ff395cb7837d7e710851a4c5235d8e2164a1280cb6377f3ca9ea4164603349ee5c2cf8d4344562a28532d8ea14e62eb86e44e944e519c813dbc7af115bc6002dcc5d12caa7b3673ede5d9de24c767fd163c4a21857f393bc4cc40d63c60ef2d384a5d801773ccc3b133be65f5f1124b9a58b4e83c7b126c3968fb5670d1b51a7e27af0ce345897e23067412b2cd9b88639434534ee9058be336a422e1be5f8f72f3e0d31896dece315e3ab23456b842a6f70750411b5d30f8ebd89862f4e006e975c5dfc6a15d307e6f033d6899dc6fea026a0d2c8d3ee36733b47fe91f47f433a74100e1aa3c2b30815edab9fb045303b5bb4cdf57cfb9aa58f6b976faf7e3c093eb223e41e79ca8f343fa7c96ec51fc149cb84f248be8fdef45e47b40730d352d430bcdc847b5280462c3a7bbe0427ca8f398304c68dd97e4f659b8117d4ab548a2045ce0733d07e9f5c16088bc92eee19b679c52aecb1034fc727653f2f9b5d5b40e84996b1545270a3b3faccb31b15ffb260ffcaf8aac1552f1b592007777b52fa2d98b1519aadca713ce0f8424ed2b1edf8ef1d563858d6669fa64e8e3800aa021e53eff63d9f7ae44393621f2a1b87da7e76d6c25887fd77286a58db80ed38f322b475c0e498dad50132452bc8dbc6c65f49831f830306e3145737ffd0bb466127606a4fde07f693e6bc623942a1111d09b9b153e41cd18918097f150bfa94353a06993407546631851d7f56c7b6f850ed8a078914c34ca5344cbcc24d7d81a97e549ee61c5c9fbb57b9231fa52326e464099fc8e29cfe335e2c9b6dcaec93579a6ed4ec6d1094428eb2f12988a13489b2b465d54fb1796b4793a252d4ada1935c86effaa87709cc59f2a5712f852f155c21fe4f600bb9192ad7ff728a2a24c9137442f18dc4ee8c190afde756baa6f0e07851bb62ede12fe2ce7f02740e03ec9e99c63197ccd2295e74f241a4ab17af3134f25caca0b2ea43def210a2ab2bfe76ca8f34d0d80d4deb263662b632f813b57f1574bbabea586fbf7626af471dbda5e6f9132edf9d3f08c112c5eb29b78379a364cf30e0bbefba25260e7c3e6c6cc534df25add0498d46db70a734b6792741ce3f72fffda82fddf132c9c0f142cbd7ecb9ce2749718bf3d9f41453c536c1660bcc87918de8f0fe7b3cdb2b6ba189cc7bf687c6f0e116b8071b08ef52fd1e176e61c9dedfc1ff641d95ab065372877148b33c1f0cdf8526b3550a6d0ac82493b82f5780d647b057eeae3c505e8dc92a287a38aa1f532e6bfb65af0a7f7c0582c31d8b563ce53d2a97a5345c052d02af375d0337a73d8ff2d5e4ea9f9db1053cb55728ab6c8ead282c9ff0e25b6930e2013f3fe12316eb399a029d8dc8d9801a0fa07f85c025a86ee3b005f89654e568e42ad5b2131c5b1441cf57040cee40cde865bcb52eb8162be92bfe39ce82d803d773ab4929e9cac4a45aa5d6b5cb79114ecfed309b5888e32570924efdc93c3aae007b2db7accfc74cdef24b06962edc9878fb51d8299a55eb04ef4b7daa2cf7102d53bbb8d45f9668f9557745fb3125d19f05e167f19e7ca2cb8fa3dbc4cf895a9f096176fe729699478af4d96e9c6a3ed2e13430b79c13135d04adc5a5a0221ff99fe6c46f8c114e0b47bd6b983564e35cfc1c9a2fd17b6ab410c4dec39a1e2eb982e3200f4b0ef36371dc4dd147ede59554ab412f9f08db71e90426863564cb9269483e5d4278f5cbd54a06ad8931c0ad8ea83d2946c33528c9b54be8f4b8188f0a170ee3624857cad4c3ef05e0c43d53cc3b1dea9a8d2ad83eb866550c7cccb5f9adfe074e5bffe5ae2aa2dacda044e88db2150c43d524b5f697949345ae22d7b00dc15fdb219f0c2eace2150c199d05c64d18a13512a10b89527de7a6fef50f78a934ff4de15d854e4383cc975a63cde7aa9b0d79913fc94291edb8647415765859556d8b19c1005fc14a51d1e6eceb7739dd0bac04aabac95100627567f89418e14cff22ee34509a99c3f1288c342ad82d158f53528e0c4b18ec7b945c92b1c6caf5cfe35ae3bb1422d28009c0b925f72987ddaeaacaef2f0fed6c32fea666e5dbdb5dd3476cbd40eb57794c476ef2550adf506610959bfcd588a0bc398466ba6c7c466ad99c2573e0958ddcb012620c6ee741fea3d9c31db01865078cba1ac659c22267b3d3d28baa0763437916414cb6edd7ec86080708dbe72eb06487c2f39be1053ff521ac880cc2a1ddcbca4372c9cf05dd044c4f45b389d1fade0d4052e9cdfe987dda9417bc71246b8e2c46db3ec42f83c708cea58a22f24569177695eb136096e06fad538ea99238cb8c7d4a0f30cfd903a4a84a94b1aed8a718af4bd0768c4abd5aa1637cb0894cfd4c634ce42fb270612d28afdcda011b3bad5465a38760d91497ca9f422ee45b16d6385dfe554237a99255ff22a65910898671cae838a32162eb7e30aaca5a0bec160fec2369660828ebfcbb9305a3d6787924946f2b47248d81998ac014d2159ac59173d66fc05bb9c543b6a5833131ba96f2698cf23e39c4c2ce4eb4674bb6e451e619a27d2646b074ac83cc999b949395af5653d0e2bd209b5094a6171bc3d6f96d8aa6fc75631000dfed4cb1cf1f875f6afcabee3e3ace42e07e6e787a18ad20f8ddf498d43dddab1febb60b68aff05f1b64352f1de61c913d8e133e8fd745d4243e6cee94dad6428f9ac1a8200af111fb724231a4aa53026aab26748386e2cd8a705179e0cd147803b4d14e7f065cc909209a320c9603fbf7090fc891e18745cd5bb4f1744780d6da386cdd14cbeee30e38ca781de77fb89875873a0832d3198d22ed48300d46e4138ba10d79ad42799e2e85823fdf43e8ba4d2cf6f755e80da952cd1106ea4aa6d94d573fff477e6fabb391499229b0410a1dbf4994e714e957c69ccdb3f4473c5b3f1980548b634e86ec0f0d4125b4f0260f93aea879b33fac5c761dd43a3213aa6051aca13c76ca5daf9b9839cf4fa6ea9bfb1a5949c04415c84b297a6eaef6531602f5745583b9cc343fbe1bcf99ea4e50a7be1f34d8ab23d1aaa8a5d5d7e50e2066c406016ea99ac2147acd388817a6b3c8f40be92a8e3d84217bb396a104a6095fe33d2fd85da86576b846665e1451260415e75d667d32029c2e3a79df7e659954444b58b4426f699d0f7aecb13b2a93d32eca214577b9f32205374cdc2ee1ea3b83f568f32ad7675c9426cd400ef61c07cac60584a1f946bab7d0b2d74662cb551880b0511efd5799e809ae19eb6d485c2ae84c7fedf520b4d4d379cb5aeee3d2890dbed548920e102975e1fa4e635015d22f5406565cdd07b28e4410aeb73b882afbf9b834ace25bfeb325c16868e5662f6cc9c8e22017681d71b20f34495b25151407973a25fd77802085e2c92b982c0cb347cf382fbd43b0ccbc8b9020dd720abcd9d9684a94edf0faa4741f7eb1b6d65d64077849a9be691f86db026f3a6cf14b477f90445b44f94c09d4d313f7bf6810506d638d57bc069560c928336075f89a5964ac9eb1e1b28645d3b5ef8c902862a704183e10625e1e78fb58d95f9c61b4495094927de9ea637c7ee82ae315a192aabc79fc07cb3e19810ff9527fdf2842610d1f4ddcf3fe73085dc143da88d452eb9859aca0846d0f72aedf7774f86b91595b990a52c8c8b31caec0b7038c27ecb4199d90692a9171ad1459f0051eeeaef58b547c267f1cd2a1d7752b13b7e45350606aceceb15fe59eb3ff9da99c8c0a68453d13ee9d6f984ad36f0f88e2ca6dfb25f37719cd82e9079a3fff0dc9bd58273dfeb654132b39c0dc3821cc5f8b15e1143920538e6151f35143fa4fc4c06108e6b5e44d47aba03a3ab752bb1274965e097cf489744e069da95bab1972c4a18a722fdf624f3f981eaa9137d8ea536e82817017484d11ea44ba8640106b2b255a6238ca01eb7c11a02620d4b208df2654caeecebb8ef62c2768e9be6cb59cea0821d619b223dc51251a7c9783dbdb306bf26a95531e4aa48ded2bd89342bb8352ef3bed5aba03b058f73e44185be3446a36ffecdc4e22a16e54ed6c059b50d25e9b2ae8276e6c111d61a15a728f0c843862745fa8cc107dd16cd2fbde6b8ac61fd0561a1b7936c307a4daca52ba7c8ec9cbc5a643fd8763fbf0f61612c23a8b9faaa1e7c280eeacd06813692f7f35236b39a83b336c65db647c09fcb05c5c12802cb22db78b9235cd3e69516c9beea25ec02be39812290983b94c725fd71cc60d09bfb056a4378f21dfd58abf2085c519ff03b56455ec46dce442debc5b47d7725cfbe20fc6f21a0a2790e52927e5c150f8163ca88de895a7106f1661f987ac3e44663627307516f5b2e02eabd111911a4bee92ccc41422d410d7458235e17722a224c4a76d06fbb1047c290e13c01e4dc245f0f6e646c2ec1067d3c41176ff8908e1be822e740a5af12be9c4a6544a0d1d5a8e482eb9ea9ee3452b5e4efade2e8ecf27f43f7d1f5711126b479b09700cc1c81c05f13d83a80ee5f8d26cb0de0667427e749b4b47a53a63dd9c2f22e343a8c83e20d30a725b4270836dc69edc39c2dbfc08514f39b3e4d853f3f4ccd0cd35ed3cafe9eb2491feeb055746713854f9e49a5a8096fe707af115542b737dc253e1958437d0905a1492c36c044610b5ddeebb4b0863e82a860edfba858a483018f9d21984ce7175ce00a6c58aff09975a40de8dd3105c3296dc60636ae3f541c15b36e95e30a07f433e635343840d7ea6afca636576445a83f1a1afa092ed93b61b9cbf34b2da5f6245dea9cb1ecb7d79e2cb001e4d8332aecd1d0f611efb2916a3e8d5b43523af74874d899f11216bef218fa0e686c19139b89001398db6fa6ffd2e4c2aefb2d4cf8f24742f281f934ddc03c711f0c5fce89affa7ebfca9235ca280e8d3f27e2f2197c1ed0c435e0d6b2a66c978170ab990bdf022758500807b1219d0bcfc85dc082392e91e0fb026e921737e910597b3f31a80344eede018a23221feaeba19530a922d0be306542aca3c095cb074d98911f32e65cfd3e8220ad3b7039416369846390441bcd7e111ba100f5b3c42fa3eb2137f62da9466e96046de1e9dcc7c7ebed71a528a3b740f1c40cba5178a7a5cca08aca96715bc5bff573373e359b2e427a2c5a7cf74408f3de55dd010193c28048e937d7427bc93cc39cd70eac068477ef1135f9a3444c75f38165e07c0896ef8c88eef46c37a099ef24ea8121a1c29fc2865bf582560c258b3eb907c3da4435e834293e2367cfb40734962cd8e74ec256f26d8e6bc85005b3714eba49c37608faac8475df94761d7debbd04f2c8f63fda043ae0133a7e26c25123e74c14a9a5cf3cb3fa9b77aca76a2c027bfed1c94f9c9dacfbf1d331a6c0d5cd7866980de5b8e0f5d46998ef87382075a23b5a23543b2a9c5854a267801522fbe9efcf85ee598c94b3c33ab82169db9a103cd82b7aa91aee64203211039a805eee713d76149dab9f9ce3bb4fffebe4fa463969e2446bf49c69b268fbce397038db89d1faa94ec033586a6ba18768ea4a0bca762920d2122cc7232f22057efdc199771ea1b7f7fad40d76922e5635ac7e7226ca67d747f67e196449d1086874dfba55401f99e19341aa36f745bc59f7d8fbb2dc57910db92286749065a51e280c7ddd5d252bbded57b11b67be36690a51eb6974c82951dc4223493e8b5bf2ffec12d24488ba251dd24d865d82cf896b83f07e84cd307dbcbcc9dbf2ba65c5e5446b0b059996b6d5b3a7597ee34abd3a38637f80e638304c1e7fd96ab7d30886557f70fea0ea3f4e110637cb5cfd33eb9855e4aa4f25260023d7455a55986851f9bd4ec40b3fd0305a515ad98f3b76fb7b1624e9d9a878ba685736bd969494305b85ca95efce4705d72f5a8491d79f835f812b9e74b9054f380e827569642b753313d99c692b25294775ce569b3128e703c2cfc1309750f767c8651a71e53710e2d501f27f2f2a0fee4ab3ba0d5d9dac3b0ea5de546e85bbb2bbb06511db08b4c693e5103ffe4f48c61c2c62dedc7987dab529f6f0651b52737d1146090a7e5ad6597910c25fd04d6f37908dfbc25da3df05a88bbbe6a408732a81a503d9fb801de5096baf04e2f20faa2bcd0cb8bdd3ae825a163f1de6215c307f0ddd0823edc12f099c4a5ff8693d68003b6a30cbf2e48ec7aae1498edcafb8387e5476fd661b43541a2f31d72767a890bd4a67115ce1c5385f06f06560cbda030fde6871119ed81849a945ce659c76b393a18a9418acc9f14e39a6a73b0e8b4b52c2b39ec30f0c447113f6fa86f16311370a2e01da4aecfbd2ff1478a37982821be8be1ad745fd146bd27cb7557e322155d750e7b0bd1d13c759a60f23555ff2bd5fb3c582160bf96ad6e80c90c1a5ecab6d0a41bcfdd3df015cce1cae71d2a9cb58ebd9bb6f185dd2d2c765a5ca4c2472a49c24207183fbfceada0f29aba592f5429236b9ef3531cc117622bd245afde50eec9d2284bab854efa024e42fe39146446cb6a53ef1662465285b369d9c4d01eaa568196bd091122a1bfdc8c5a314fdb7bd7badb2e7853af6d905f9b2dc86cfe6340e306ca8a6f0d13c94d18d9d0873d7c7234823feac3e14b616b258756faec5e251da284e149dc3f2059fdca1c551fdf8f9099fb6c0ecea766339010e39333cfb49646c5116d7316e21f2de788e47ef431b2df4bd17c6ead89f05db44478149e5a8852304bb2b16818352b28ea2ce3b7e719f9405fdc3636479afe15b857aa65e7ac317b0f42a7426b53c1b8e4e74a5b8d2a1690f1202a563f5071a74984ed400ce2e8b2a2e89d93ffc62d2f78eb44d5ffb0620056c2d1513ef5abfe7d2a0fbcf7874891dda40dedc482fcd89f5315ab7761b0632d86a84e25880bdfa45c7a1103a1ee057bba2908b2b7108dd9a7475afef3887c558937b19bc568860f66c59bd94ae5c775a39e40635582294d389e80ce9e62e43b548cdbbd1e555ddd9a12564aed5ee3f6edf7d2e906462294c11dd1634d7b1c6ec720465419f2806ed8eddbf05e5d093aa6c824a9993dceda4cfd41a02ae0ea721e519db17c5d8380c56db98eb3ec62aa32557c1a15110d0afdd9152d8e38e4f946dfaadc2131ce55f9c7ba33a15f247bfec8ba3837156eeb89fd10f904f7c82e4612a767871c64149c3470227e5aa02d9fff7ff52abe8fa581179a23fd7548e516da86739cffbca0b9a0b6100c7463521755b39a7a6963f99d570ef8c415c313065200c81ca11e065719bca4e126cd39e845cd09dc81c7061ff55b82ff8d3998bee724bf7da7071bf025e2eeff4cc98a3355e3b6fae30fbfc9a65fb517641d4ef4f04281db8c0d53fe8bd377d60a1e51ed3917cb0ee60bca62a3c29a712bbc954e2ac18d4ffa7d74486c7c0206c74ac67cab0e369065602eaa637020529ea6c1a4507bc56b0d8441bb96bfaa4eb11ea9e40d14c6f0c1cb44349b15d09a9d65b4d5d51e6ed13f6b69cdd60d6bd79cd93f72df19f8ae385aa31eb0511885bdfd754597c9299140d2b9803662d1455781cffa85dcb9af80b2a3caaeee4f6e013e2a957181b217d98695b8f39225f492f96038f530ebed2a895ea0ae8a72f9d2f0ff4617a9a60555886f2d6be1116ec8e5f680b6ef2e167b4a5b5d0bb8f4c3a1221319dc9e2784426919d565d287577a42ebaa8d98700affbb5852f7bc7d6cccb5002282510f1dc3bf9f85412b8d10b65cace5400da12260753106fa4f057ee2e9d023442a9bab86bdec8be55b7a319cef8b48403e15cfad2375c444c1b7b81f87ec16c7cab3f9bb0150bfb796cdcf6cf96f9bf86f86ed424df440e79b56cf15aaf532ce8a132ca623516d1434534e89d77ad9a03590cec51797b09b7f80bae115f79409899778cedd6b9402cad35d640a53b70f88b74ef679444551fab0210d397faf3995265c7debdc44befe792b7b91f6440fc664df99d295b81418917df6fe6197fddfb294a266dbae0dbbaaeafdb023b2632add79ddbd36ae12e07c944ebcfb55ae41d880f154118286a0deeb71a9f5a04be6dd7c4bfdf51a5ada16d7f21e33174b63b08fbc1fa62a9c8f6874ab18c8c57e97f8bf842e0c6fb8096a96f9688cd6c86fbc903044ae57de492181d2efe6374223609b626fa3abdf13235312221a49d88c9571dd4af35cab966216e16850401b09dca4ad491e77eeb64ccbe29abaf0c397954daffe564071d2c08fcbd5abb186b8e097f8b2dc263538abedddbe8f903206960ba35bf7f94173cd8405c895366e5466cbf5e5d3abcb30b0e3410e8837f25ed7efe3529492418c06594def7f9fd0f2cc84c2ae975c35874585f112a17ff74afd08e90f344634df04b76410d3c6be5c5d3cb6edd55ee0878b82bb3e8eab62c27e67d1682bd517d640ceb35340ddbeef7ac1b54074499fdd5c5c23b5f851a83e738c2700d5fd5ffb11daf84c9bc0294dcbd679a86c72ac8bb93ba0aee8a18d7e8fb152d4a1ebc04e832b1dd573b7c253bc71f9ac069836b175965947739b304b25379b62a4cf164f07dec3e85a2a5ddf55c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
