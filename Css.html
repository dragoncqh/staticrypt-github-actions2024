<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cf9f4d103ff96525d1c47e759af7e975e11758193547be09317c14896b610d948029e895bd2c396b00c0e8024a24001e699a13bdd6e5eecbe4455826208de15176aa7f6351476f184a395de81bb5ae5d365df1fcf1704186e332c197343e05f5bf883eee7e13309263032526c667604074e2916a1b2b3f5840102546a5dc4ee49b8e2ce3c1be5d906a22a593e1ab5bf876f3598ae89a33e0d2fb2e99bab01dafb0aed4a4be40a574ce357da3ed9e36d0215ecbc327d85a5c37e47f0a2a8bccfc28933c96f53b366c0914bb0bc49308d30c6eefc0db317bec15739a1aaa33a85b3770ae7b21bd2a26f9856c0848b0574379a2f19e124f87c6c1ae1b909a14e1d53aee9705f647f502c79d2ae8e2bf74e65616bc752fef622eebabea358bd99e425728a4165f1b0b9c44e1ff49e3394296fe367041272b5355910d91c03fb1a7276d206cdce7a198eb0461f0df7b7715f246335042cc01b4af454160a7dd9a3e851364e03a38d50c076e316b03f1a78e8b11af656c257cc1c60526ee5a5a78da73c04612ece7dd9cd18201af44367ec1507237e7d31b2410186531efd0e373ad9e50b45a9d3ceff62c09747c4a9adbd71c381c34a9107903fdbc195b347c6dde24bcef59303d8454d512e95a9409d4f151d4ba6c521e1c48cc0ef168f060cf9b7f6c62f439f636799d1994cc52e6f61a17d53dd60cc981a7400f721c9a4eccc9c50fc0ac9ca2db45b7bd2759741ecd504fc8eb8d437a3dfebecbd7d72d25eeab846f46cf41a3b7c65fe7d9ed41b93b3635a8ec44d6c08c9e87da9a12569a5d4d777a6133f2a2c94832308d63e1edb4695127b435623bb786cfec1f2df9267ca98a7bf504aa13894fd231b181c3698d1ec12f1ffff286ad9c30cd84bf769fa0e847edc8074005dd5c6fcd7efe41ee0b2da497e883da13ee98426e6ccd18f6ad03d85df8b2b5059f34611d1d86d30739c3bc32a65fc40ddad55568e5dd4be5cc3959557bff644c2f0fd80c3edd8497b516fa311a0425872aa39774a49eb1349e595d2ec092e042220f426f03b97d39369066d226b28fefd4e870f4b4cf057613009341d9a269bd78c247c4d01ea2906ac59da86947b7ad691b7a96132e274a8b750738a0483feaa512240e8d8e9c356399c571e0b42bb011f0c8c87b818b63bbcad5d3f58784da26652717b2a6989effb7fa0d0e58735f832d5fe610173a0087b0c3e4171ec6fb5c865837976f1b0debba36933d25062e6e917582d65fdfeb150a0d663134610321ece902db30995e468adcec4d1b5c19456dba1523db5fcf358abbf54c6c984199ca121416fe3f3fe0a80c78ec1256f63c3da1aad3b694ec34eadf6ba258b9b589f30f8018389b8071f68b66ec1a4fcdf5822cb355d43386c19dd88906665e6df5b4cb53be3f58e0800a6ad5da46f570f483893c62ef666ecdf535a03761c73b10ffa699fe63589b3dc442327daa50a9e92fd2fe2f649f38a8fbc68af9fdc99b6e1d38e49816689c33e4e8ebbe105c874b57e00c22ae153b3edc25ce0bd93fb39b7f68e35b3f6885ad61597b6789bb21fd08fbdb0fd6defc7871182ae2d9bf8692f7315869d2ef42fc17b20e32c96bc2ddb3e5a18aba8c5dcf76ee80692a7621c8d528709317de168909b59654a23b6c538cc78d6b217c1d705f3c18fe0f35cc9bcdb1fe242ce56fa6acfe7726c908b689dc62cfab21287a7a7d21608faa06eeff3a79e0d9888d1f2cde7f137fd8c95fe89ed4199b6d526e4638bf11c3c20f605b65da245432ae4fcc629f126225c079579a7adcc2e950c36455e898d153bc79a41e40b8ad22a969ed9c5b66dc32fe2b5636fc9b84f615b70675714b16b96876e0bf809d61fb5b342dc48d609504f41c061f7f5e2990524604c933a5c3b66d90409fd5a040567a06fd2c5ba6f59fd6fde1bbda4f1870d674dc3d56c9543aeaff541efb875a8321ec74b2644399f47f23ff18f7825e12b73f86080b34847af94b9c410d03c7c0ed9243b0b5904ced3b6c26add6e31f7673b85f329c89018f2c37a0ef7bd9c56fad8a40e4ff60b3ad3eebda19685532439a015e7c18ee922eb1ed40dc1eb2f69677215fd36dc6f419483893d53c4c15234190bb194855fde11450c71fe52a2763b12917192d7862d15e51e170317b8aeb0484f2b9a9d082cf986641cece43992d84c5c92dad77b1c02e56d89e2ce625001e1323f2688702f9086d933dcb574f0ba8bd6202d2c8bd559b571aa50b23dbc18bc1f4956b452f222d784bab78ac180206352f2f4e1d0bd02c2008c7d141c59a1950d143432e27a14046143e66942c8883f08fc37b97b1f5fb006a1e003080ced1022fefd56b3a95e58266da1c3752ad8402072151d40ad83580e7b0d29bdfe5bbb8b8e3ecb781fc918d1baa7904d3c866a68fed0d6a59489e94aeeb99ba9eba0cf7ee62fe7a59194ea7fc7c6dfc91ea4a56780f5e0a7754407e6bd7eda881ac206a437177e3bf3fd9604c6ce4000c8f918a1c02758d895f4adcf4b4205a5d680e224609d99bdcb8ecfc5bf58c9158f6532c9be9de4f5e9ebada8b0c79be585690b52d0ac8c3b643ca29a0ed62da4f75bff7e91cb6c2bd9dbfe3c18e089f5ac9591f2b19cf7e537fa27f6f7ad4b7c5ee2508a34ba14cd5ef718c72d8c5b473fa0d83d307ed16bc5658d19c3d5781546027456ebd495e2addae17868dd63a979262a98f9f334a9e47a808e476659497da1348210ab83bf9206574d656f5c4311acee20ddd2ebfb564368d4ac6737284e5319220b7aeae507e922d29855fba63bbfaf356f57d7ccd349952bc46da787bd0e46605ddc51a9afcb8851909da87086c475b008ec75eb33781f0c4a4a44947a46d99844bf165b1a8bb23746cb3efc2940ee6fbbf2bba60969cd3598735982d1e6a38e81bbc8d589e4553406039c96e8365db4a60ff0361e3f58bb5646fb4b409bc427240d8d293aca37e36cd295b445d16fcc2fbcde45562d92ee1a259a6a1c616c5cfdf6e3c82daf965843601ada034cdf3490da44bc8c89a6cf62275eaf7693ac0de52eb78af7789e397dacab22367a5c3cd3d57e3100906346d163e238864f29e20c497c84604a277d9090737da174e63650158481eafba686b8272fef1acce4239d5fb5de56c6e769504e6cbac685d9c7531f83477fd76c9dbdf1347898f62e98e7aa7646e1eb56a62307ae3f5797b967c371db53f1b634649e3070fd5ec3f723639c7e8b157c1a5dbaa5a39d65ba6122f86cc15f6bb6991953c98c355ff79f591547e2230501064aad0ff863ba8965d522c9e960eda6c0d15d4683618503ff6bbf2472e70d105655df82fa1f64d04a8dcc323626438d4c8f9f2b5925579a2126d10790b930e5ee0f979480378d3370e9809fc0c6f36f6841d7111ab4852d366d9abc05432ed6a8a59216969dc5ee6a38d273c4803ab98efaa377ec6e803eedaefda954c24ede4a257640441cfa9b63d739dbaf8a65636e6445bee51cb3d36d34b25722fa7cf991ae3be40bdce856aa40a972195a0a6bdd88fbbc59169556c086b2fede8ca0bb11c5b2670e487d17f03d52bfb9725f934f4fb57c7e57d514191f92ddad848f4a9b4828019523b8bd1c2e79980e727f2206ff2f213fb4af13a4261f4abc5d1f3ea4b430f9b7dbf05f5f7909f8b5f767cb26bb75c57ac16bf21ae94506b20c1f5e57d684f66d6ae9c6cc4f7c6397f2ccf3154ddc16488201a941f4c9edc0a6e9546edfddbc24e670e32035cda682fd2eb97c652fb80462161e5d919805ab2778234a4588bc53720fbabb97e1290ba3b9ac5f462eb5b313bdf43e27087dbd4ef4097b3386cf59b1bb37d1bc2f8bb09c555da6960e97922a35e104a4743043b76b98eefd8732b1de9e8223c53bec86d9c195812bd2686bc5471aa64b4127a707aff37b9c2a7dafb7c6653c36be52f6723eba9ae8df40f39b08873965d969175b7d7020331f1265ecd9c89b627becf55b1821a94b0b3fc25ccd80e4033b0f2ee6706f6c27f008c7d8dff4b266a0666ad1ec6742662273863e59c4711f18eccb5e864dcd6a8d12e8748b9596f36503e0f016e77731441d9428d5857fcb4322baad5a55c530422b0ddc6a135db80bcf2e136681e9a1202b1b87d045d0b4141eafd2d422194250eaf0dbed146c4e95591cf4b8af0a30678311bff9bae10ae326a56606335ac6d0e453672599fd9db29388d824b3922c7ac29fa1f426367e20bb6a19704abc8ac51d365352cf76f293a1df1e36d988f87a9e0f3d2c8579f07bf9892feb480b909f0742b3a99659d2cfccae81f2e04dd57453b6ef1d189facdb9e02201a13a199b889c675c4c4a75d165fd1e048fad2d1c10ca1e421ba29771935c8090f13e3d0c86b6608e8999858a06e5aed4d45c635e42af0487caea273564b3439acbcfeb1a8d443263c2d9b307699aa5456e29b63a907e794d87454d609c4b612a17852e8a4376d39ab798ec669c229db204a9e9a4af5a08b632cd9c37585d3097f801db468e42cbf83c85d42c2c2da5bf30744d9e60594ded214738b98c8647405c47b6eb2cc6aa6f712e56238135620359795a9f66986cf6ce999c4ef78aebc434d5d5d740f10c55b428eef0c4b7e2d3f3d9d5dbdb5362fde8b624db2f4f12e577ffe1d9afdec38ef91c084a098aa2a1a955b235a7a6c5820eac98dff53e368f8d3c10bdc1107500d48796fb373d87a11667bc9cc11c0f3507bc9fb3ab03354adc2cb5bf3675ec8bf826beccf6fa5cc3256809b984dd047399a21c9b730c450a172a6b19400d3557f47606246da4fba59125c2cef4448d10ccb42f9d20d94bc521a4a60c7df16f7499758b86278b61911484af64d634fbfa2a3d9c911be6d476dbd224ebdaa00c300b5f3dd49123b64e550897375a49580f0620d631c5aedd225fe5762b5d66584064b7073c9c7b531639b93117590710bdbf5aed439286d7fbce2eee9e0bfe2f446c065017ac318b3864ffd9df912740f0c1668369d666c07e394b08efe3b36296de4ff2b09620e959b4a872196d6c6fbe479861e43f72d14ad4367fed14c7c37a334701325b28151f196f44614fe951a94a7f0c8194a183a5f7ac5c17597e6c950ffb1a44a866919ec633e184999c30f4b56747cc04996b444e2b2235b263975d340848cf859b36b1f79e28679d98ea7ef91696d642c75d6ab4185fa1cd87bc1aa6c35fc9149c2d597ba14b4ffa98c297f38b002af5ef92691ef8a2ab020abbb45f8170f32e79832863c9c649c102228a6536b5f755619c6483de05f4ffafc8f7bdd2bc0c678ca81b7e2e891bdeb57174839653a5d0ae830044d4abd88d0efeb322e8d080bc5f154cb4da1482e28cac253cced9552daa67684e60ce8ee57c79833e9c891d809d2aac3a31563949411e0bd094fd9f8f41015ff87a8e0b5b7327c2ae93265c1b357c4974d342d3a526f6f369e04d1930810067f067b9e8fb121821ad44e5957b3cfcf45ed939c1632331093a9d6c8730ae6c74d9a5b56137d8c68bf67dfc3a9cd3d25c521adc772d27f6a9e8c5676e31d624b66663206c099db48fe66b8a331fb6a9c6e86a9ea4b0f40a2a7aa71ddfdfc666b0f43edf4c55d74a5d979ffb7d54b2ac3f5f965dbb02f69d00c06031547053b3c99cbcc69dfd375d950711c006d2da02dbb0045e371f55a26a1d24711441495696f3aa48a0679ffacf959ce36109f9a8026faf32404d0600bb2963bb6ec42ed1ca22e2d3450d0f43a35832fd07071aed69f5532f8d5ced828229484534ca227e007874b19fc51702b07a4ef0f9dd4f296ca4151e1f237bcd1b26318f3de711262800cf5ef96fce57b4530631018f5909dd071c594c3195b8d337ed520ace26d6b23c165372b0b6995e5cfc27decfb99c438c060a353ce3c824e094823895c32599f149fde7ad6a15e6d29d0cf6b6354315616f600541d1283cbe5f60d54018e70360a7dff02b3910fe6a8897c94b2894a51c15cc461b1ad0341cd042443984f227e85d2d28a151a66bf0a4caaaa5e9b5eedd84313c949b43041b91e6923d753515ffeb3abfd6c0cc9b0786b1f5d1c3ea311628c3a8a25e051b15aa190802544cb7d02b3df45ad3bfb5bf5809c9f9fb595a37400b8d88e7338cc0938b9798dcb7935c2b15ac25e37d2e45acca4b14c65adf21d81d76bbadf54e2557364669ba6a58579f17ca24d498cac7fa250ecaf8f5ef423bde71656a164578838953837eea3b21b10267a5fdcb3c3d9ae7870f6eeaad836298a06a9eb6d2e9201d4a5cc4cf52fa2ebb8fe12c727f0839786908cdfded75bb47a19c02c2aa599048a307cb73e6bd7dc281be826ffc79e8627681b8be073b8297fd0aa6cefc682d54e83f58409b8af2c5aca9aaebdb63ffa33b2bddd2f8e8d6245dd3886e13058eed94708fca18ac18d446bae48f9d98eecc2b77eb17f60f3e035409613213e7ac95fbc9c241a869d16eb5b8256015f743b530b350276e54c69f5eb4b95f3d0ebb6141a422588dbc0c7d044fd3614a1a9e15eb974fd5cf14b79c63940feae9b663cd612ee117d5e131845d338b242b32cd008090fbab510ac95b16526695a14cc06dd50c2ba50d723a3aaa6f2e66c352044d3b4e618236ffdb29f9b9c302a13e38cfa5e25000f11a72fa2e4a259ca67022eb1d7df78b527849e2fb2ddc3c683d8ed29ee5659b69a1206fcbdef712d5e909c216c0bbf031a60bcf38be7fd7d74db3d845d68289fb99a53b2ed8245486e8c2fbe3c1faa697d9559479385792e6320d346442bacc81c2781174aff973aca9eb5316ba1058f9a9638e109a3b9f346e6cc18cc5d676fb1f2b341f6c203f4b50d78b42b684708b1e0bbd40a4b21bbe73c5c23cb0d973f4314ae0c0f67ec1f63650a07f76b2356c07e88ebe604aa4a816ac9922632f834136e19e64edfb68920985a80cfaf78e3c0aa59f5b61ef50e0d7e3770b61877ce992d3f7defbbbc400475f9f6c52226700cc31d81990d62ed75904c4ced19257833bd78dce6806369ca47fedd35373854c37b379ea24da41d74b90b41112e695261167005cad1c7f62325b1c5d9192f18b2226f9c2de1ce9b4176540f56975234b673d5da827d4ac9bf55504a7acda215c9096f196b81f4efd01a5be726bbc672274eb87cc232bc63489753c5ee12b5e49af3c72b9da99643ac2b232f23307d4aca71e5a906afb5bd272e25eae516c856e1873792fa4f5cbf616c8b061c330b6cc0e2fbb979a49f5538fcfdc42ed3ea1678979d50c57019250852b7cd4440a43cd70d46033c65530bbec6926c5d825240cf4ca6271555d996ca0d74fc59410cd0ae4209ef16db3d8f4f8b446b616d47bb5243e67e3a194c986547aa39e105f2c5c15c4c10ae120d97d297229d0597340fb7dc9ebb4342d0415606f5d39fdcbe02b93d89bcd63fccb7b2046d141626a53593f004aa0b7fed18c4bad55bc7f3bf51962feae2b0e8868558ebba82bcdfda6185358e2d1be3acb1e54c1c1ba7a28cb1a6a9d1272de29257b172ad86da8d281deb85edf3c354f673cd9461e3eb00c69ca108cd499e2d990f68d5214a05fa07f0ce69c9209abe52478d8a0358c0d280f62aef31e13d83fc312a4cc7fa65b58d6d7509e2ee729518840f0938cd94e23b18a147b7b07a99a4b37b1dd78a89871048d0ef0fc498c8b51f507cd5351d0ccc0549445c68e90662c6ca9224f2cf8310f18677a168698c91fb14c5d3f8bb9ff34241eb760a61343fc766ee88bdb57f8e6118bf1921d8372a9f3ab43a301de1b1c937dec2f4ba94c88fb5d7f397405edeefb1db0d63a99aebe08dbc208f14b99626ac23a3e9e5084d914c19d0b348e749f696482c9f4a6b318275ab354511a250fd8aa73ea6b2ef2fd034cc8c016fe39144ac239e2ee930c04931c8884b2b64f320280ebfb44458a7ed26ad70d92e0e06c61999732abf7a64b1742ab004233b8ca9087cf6ea508c8f577dffc3217e89cc81d1f6c96daae7e7d960cb6615fc2e7c8ec0c8cef0dd9ce43c9a98467545b57e71df4de35499d117968da157b76468d658f3bd91be2451008817bdf9d80dd30020ce0bb2ed552078789808d09f7d586e200af2ee4c662fcb4ff4a7764101e4f881a7dcbad0a47f04691c4970241ba4c4faef53561eae4ef854446dd35dd3d2aeb3827975ba9c11e20150d0e63c26d75d016f0c7ef52966627d60352d5e05a80a5c496ad2b17908290805c2bc79a579abe754d0fbf46409cfcf0a4ce4421ab99032c22bdd2e4a3cf2ac05503f17945bcd070c92f7710e9661b766bf5f959b8fddffb7ddaa7bb1f367597a932a1c3f3f7230eb22a552a0bad0822bb3b45f01ca2d72678f246bccaa0f24f38fad7ae28dcca16c1386e963994d389d3af240b4a63b678ed9ef94c65c818dd61b3262ce407aff7cb8feea7e7c127c083807ab5253af2ec3ed2d07f43c7ccbce8d782d561c452eabfa00deeca5a9f4d5f60f88727ef607129dc06f53aad075490af8b32b3d74fced6df9efc67173f103310f97934e86acf084087882002f78049d06396776d95d2ac3b9fea78f5e8e7feac3ef1fd642fc9501c0d5f9fd2822110b9f4dc48a0edb2c1ce4e0aa800bfb93229585be5921880ad7d277addc5b7fe6b441d401ec79efa8c62e166eb59b9f51850d61568f494e5596f3e17bc59560ec22f1b250ca060925ed13f36d5a0e0a66da0fccd2e33ba9dc2df54b7ea35dd422b32c94a05dca6145cb9a883b22079b5fe9962ebd6e9f6f8051c4ca1aabe133c4ff944ace8a7c443fcf9a3cf74962ec22fad0038a32adfea97e1bf7c0b8eb71e9737f81ae60e576d934fdbb3be4ac464a675ea0fe2fb949015f6aa7e8ed3f6c826075b3562cc5cdb573be1097ad36aad3741b4663a4effaebe2260975b977443dc836a132054230177621465da4bb2ceff10663deae53f45e11f3e051f35c64a88e95353fa8b69224925c788ef4839a2031df5226713149ba01351efcfeec9b23a195228474dd39909e75c096673248411f8ed5f6caf03f7c0b05cd157a502779332608f4a647cc2de23180a8ea550b1d688ef17a2a26a1739f9aa34e0f9d8cf13e21100268f7806c55e835ac2fe65eed4c76377cfca3bbca0771391809cbd9c79d8ba42d3df8d18784c8747dc656988558903fe46c0964505fd4fbc7e1732c60aae041ea4f8ab51ae8eea0a4fd2e3d4158b318b2fa7e13089fa84de3fde7c32759b885890baccb50d621d2df0a0353e06f505442924539b0e181c9d76ebaf2b54e8493eff4909df0460aa4748b1903c13b337adb6a4f62d1c31349ede41c90301219f486543578740d1580df6177a3c1ac001cbe52fbdfe8654701bffb5655747fae30c619ca59b2d6dd1e139cd484f5393c7ea57bd17aab3a4a65a6e717580fa37fe14b053630a898235d0a3f00d6d60a00d50548155d3a88de1d3c02f9e2df33cf3a0cb154a6ad8ca6feaf130e1bde323dfe2e3723f948f43e173d18efeb64eeaa4d178d0fbedd735ab4039b53716fd7b0f771a7aba2148c197b8d6d8155d01c94e07605cb1009a9ad39a4eaa87e2f17beed6f0906427871575cebe1ef68bc1395cfcb22f345439c3727a4418c3a50315783bd951521970f193e7c9b1e46850793f1f851bf9977f50b480a6ba91afffe777daf30895b5afe16374402279b59d6d435fc6faf1e2769d133047324c0d7d211bfc41fdc93df88ba24d8a5399ad731e6b520de9a2b28ef1be3cb0a03e47dd3ce3240b7b507c5d0ee84af5f305af7be19150db4a6352debc0dd727cfa5e5a452581f0e799ae8834741fb15b3d882f21b104a3ce331e8f00a5b4b389f6eb74c3b443aca6fe0ee801a67cc2cb6a57c06dcdc2ee050256566ba126348d74375e6965ad5438c072e55f338405caa6552c71981ad5cd5a039a8061c9d0c2c8251ecc2c486d259d405f7777333fac2c7e8a54323a81d894f99ac65fae3fc4f8b4c69899aebc1694fb3f901e7ed9f3b71229122ebcddd0de3c8535cb8f31297ea556da63758fd60dea1074ed647e8097374955687410b6b0ab9364ea8e27f1f1def21e201a84ac9359698628b34d3a897c716509ce51dec974ab0a0756f29d0aa2db03f804ac2eabeb1f615dca18590a275f2077b831a2534387e0a42e2101b91e2ec3b29b9340510dfff9355f2f140723c1824956cc33d24533f42b2a79cf2ccd89b921cf08a08349987e8e2f7fe06ae350e51907dd284af2eb24ce7199274cc4c33d6f569401a054072a6326690692cdd835601e218d977780ddf5e84023b2ba5681d7c434263d6eafb514270c4c43f0a644454cc25a149da4fb36d3c7359eb392f715645f5654c125c1f3b73cb7f874c9bbf36bde0ff24cceeccd3b58981a4e85ee9500fe258ed4b23f3feede60a8a64b8a4d6af338dcd454bd70822f1ab2221f61bb4fb144c15b85f0918c1ce33e157606c175f7e1c28ab25a51eba2f7d2c957cfdd0319931bd1442349729c813872dc1105b952b960b7090cdf996bfc805c3129f44db765087c7ab83d3cebec35ac63dbfbd308ba843ff84107aecbc1815c5875425cac26fe128b2491bd0293f629c20b71e9ae74f3e0c0e61023afffe18e9eebf2b62ee86883280a0e5f651dc4f06d4db6d164e7d5f376ceec031ea3ef35631d07e2d3505ca68a77627c087fe682ef8f52fb16ccaa0ac4cacbe19db137831d6ea54d9de6d2235786541f0ec3aa784268ad29de9c982fe86eba77266f02f4ab17b5d7ba3cd72ed4223a82ad796518a54e24e90df5d6562db4310f403d3904817f20ada3b105100e2d0ef3d076490be1b436104a88f80d5c6c24b389ba003a11b8fb0ce60480284b1f3a1c2580a68270fc23ce0aef9c1853d004e0c6d4a5984ff8ba00abc4b89abffd6669a0a0c95980a35569798224af992951fc4ec4d396d149de9399df4443e16ecf8ba20dd054556e8afbcf6f11b390a1a00e0e4146ccdd254acaf745e548b42bd0a4d0a1043dbc9c719e5c5cbe025d68cb8ac0d8e39cc14114b103824ae102f1c8391bace8ba2a3068e0e435f421a118bc946e76db31c269daa13212fc5e0ea8aa48db1443dc474ab4030765af86cab75c05e2cbc07e227fac1ee044a8ce79c27343c4b04d2aa333f408759a3e82a3f82ea07f3ac5b2366dc0952b78dd252be83dc51e70891c454859279c9669645b55f27e41d2bf4afb98093a371e04baa65d5aea3c4700a6f9a67818ae2a5db22290ba1250f36b0e830ff9b4c741eeab87dac66e9f82ddfa87b32baa8d5ce89dd5f1188b724637d106ffc0bd0914ce6298dfd37f5bda07b18854cfc34da96bd4d4b085229a3ed3c906d376d15a2432df1b4764e13eebb0dc84c9ec22bb3147acdae6036dc05a533dfb17c067475318660299ee48e3737f679b273301cb5cad951d5c5c238581e6e5931ab51688dea650d237217ae18f7b368ff248a74afe03c90344b4284286923f5b9440160e72ff0eff9d993bd7111da8ec3a1be16beca6d75085d34c13562143af26330190752592ec2ebc0d4fabab9a1e141fcacd5afbb74bfe1d3a52fbc1687b9a0ce02fc697d9f85c86a52d9bbc06ec4d1480170ac39787660130963cb909031d5e539f3c8a0df1e6c34aeb6af1e8d858bd364d401475dbeb039040c3a7ce24c62825540b041e4c14b01c497d06078d650e2961a27fcbd8d06d5b51354c18505dfb73ca9d97859cf61a17c5371a1b285d9e040e5a769539a911b022f180024eba31db655a200a7a92ce7ee125c5e8ac594bf8d07c7b3602af5d4f8afc76d4dff419c8d8c5668322c500bf2462b8f07d28ebd7b867e540edb3b9e0523a1eafceb1905460f6f3533939e344864cedab651e31a6bff719de706b88215bc44ae36e3d47a12bc12a3d91b061b2522c1a146befbacf79915623bcd700a343ed55f3bfcff9d7995e7e5be102ee699f9c1b85eae5d0c2f5793b96731a8d4aa6968594bacc5461b2504be23e548e66182a086f35e0d326bf5be6d162e1893530654438c3caf53e41ed5df167204a0241dca61da1cf5ecddecfbf76d1a9c3f0cc2b50bf3a5467151bb928735bc08eaf6d684f04ad2a3beeb2695fffa5d38207800cb403df6efc99e1697076c47fc1542502cb64d5e056738c7dbc44fdf72ea16588e0455e8bfe4ebe4b0e572499cfe1780144d8abd0a3b5af57f9aefdc685c470dcdf7bc16a99c25f726d7db18b2ba185b37102f80ce45f3c966dd543476c20a85d844c5bc459c5d32aafc54e7f8f166d6b69c29d95ef20f9251a127cf988e8d6cd6c79cd7c6381f2e075293ea73b06db3da10cdbecbadaaad6d91bdaed85ed802d129e8beb0248500795d8855eebbaa144fadd978e2f7bc5ceb3231dfff546fb9df46ec9ee4ed3b1f39890600adbe38ba9480cf9c218e763805573614e979334c2ed69b85a291582d8bcf28c2389dbc8021834f3395d6b19e7674cfcb443a3bb5baea6257cd22ada7cd01d0ce326bdffd401ebf7ab576be333594a033c71aff71ea240f0dd691ffd02e635c276231308a758977a6a7c947432d5905c8d1b2ac27ed3cb5ec419b0fdbb9bbf24e1ef130fa5cce3989db26612e05a3c414be8b24a0e241262c8b27de1c8c33863f226700600a7c26666d76625d4f60e122aacb08db515198f86ad15b61211957a9fac8f23dd1f1c3ff91476c0d67aefe7eb50713a90b50d7af4698692e1cd93da91c22fc3223d9a1182017a03a3cc601add0b41270d9f1eca7fa82a9878270c2a2d97bbef8c251d2d00c9a0c744998d481afed6094ab758656a5f11afca6bf1d61177d4889c5edfaf9c1e772ba928ad4840450cd53ed34e2057480297c77f5b6f5968dd4c5276fbc4a045d9a45de9ff873e3b95173c2b3436e3c138639b9397b0d77a8a50bd44bfb1263ed844fe5c1df373760ee9f673854449b2067bae0b18b813de84b3c613f7e3491972e18c76d2bc3e47263416f6b0091af59a6aaa8506289f3f0b51bc24ef0e0d09c17c49497cf43be7e1adf6bc4ef8553fa15a81a2f12756e0c862cd205f81c502558683ac634176318d5af02cccc08d9f526843e0ac8e1a42c07768ed40382045a83e2b461cfffc3fe282ed729242afff67885cdbb0365aba1f19495f6ba956202b78e7eba27cedb62c9ed0861f78b86cac9e1ed96caa80025005877d3ea0b12339e19aa092d8e8d0319e72bc63b947ae0b15f858ed34d1f0eb6613a3dba34606eef4f68a7d6447e9cd202ee5ac5f01875bcbfba1c604f66e6e122273d996dc2e655c0a9297124a3788f0b5bd661b106c6b112e6d608620b08633dbec90537cc7a886d8e0ca8e5a5f0200f1d7bebba216350b74383c094b501c9c5f2b846fbd761480bf617042496813e65375620820ba4c5fcebd5a60c4f5fa37001fd2c7c85ae863a66da2099d8bbd579eaae95a116ef2544fb6600c41aa01607bd4e6d5db85a584b233ae263320307d03b38c541d15c90e44cb456041b128e05d8dfe58a9902257786efbe57f98731cd7fbb38b9049c5a03b0cceec34a4a22ee9f342623c4e64b3d37b6f5ed4030cfef81f1407f16d6806c5eb4042caa2a221c004ad54b17a682cc0476da48e13fd73aa35e3a5e60b03b6edc1737ae7d291c4f5d68fdd4433d1717b0c69bb46279584ddaf2644034bb8fa54f02d4caf3452b56d17ccedf3b68af7d16254f0d63f49b9eef0c7924952f7fddf5504b7c749fabbdcfc963cb0de6f5866964c32a4140d691986934a0db16e281378f07cca21947b26884c04358c28dfa454a0f2e65511b34ff270f390611d93c10307467463afc721b20781522c3261af8f143ffcf1b6f74ca8c9454da95831ba4acf7f6b8f94f256cbe394cc10f1fd119e1cd3414bcb6f610750f84012ec5dfd83bcaf4bb8d7358e6fdc854cdd5b8f66f753e9c9e1ec82b919c2553fb5d40e5b7f74358627fb476dffde4f410f8337045c4fed1aea226fdd6646225004ca90068b53ea0ce661e0e0a57680f4c88573e68c3ee77cd5760f51c01f8e7558c4e8554267498935349ac452767bdfafd3026ccfff513da8c922f03f9ae18dbb4c2ecec3eea522756c640b3513c1dcf48af392fe8e8a055e13b4cb833a238dc2494f504cba6fe5ec7d9de38441326a58bab950950a450763d90a99e080d27c875b7357b22b50224c9cc488a9768b8228f973afe595dd956fe9a17283a0085ef29551082ef4dbb2e453e76bf5427c3093813c728cc11a737bf8e687230d6c93099157ac7d3506bf6335627a4c7c0cf76f40edee0ad72b583a75cdd8d415a159b06a4aed8ce04f994a97d04dea0239a8675342d199f6047ae03c877b75aada28775d890092b2dbd57e17d4250dd268738cc914cfa79fac67d368bba69e3852823ddb1ae01a4b5fa82bc0e02d22e51f893e3328a1c5ca536418d194e86dbf6dddb8076706755a7efde8330a68a47a9eff38b4eb2aca0dc894abf650bd4aee7d0c9059d9a9de74cb1b6f98ef62a24b58a0bc3226b2341e9787d669df3772ecfb2c1d96003ec1aa5fe251ee4a1b79d7252b91532ee468afd7e02dab37bfdb26513e7724106f1d562708028db834aa90f1fc0d7bd755eb375aa14725ce914a68418fe587794bf3ab9c1bf24b5d06e60fd55f04f3cf1d96d04f58994007c706f340e709373cb481b6a9b3faec24007dae9c10822f428388cf455a3ad1cd6a9acdee9fa1c53e0f2a63c7c9c52617a2c875d3b574bb15123dc63dffd974d1da85f263b29f84064f6ac2e8782a27a62adca24c3bdd1aed53d935948a72fc4c2bdbb2c186725fe081ed6a820633be0269023bf199e3a3191d78380e52ca56131a5e40cb11190f8768eeb903f706a143a262c79347f902a87979f8a4f53222273caa186d9c1bedff36c9fcfb934c7c9d42b4ce08e84c114b18aa27ac522994d1bdc7c9e248dbea2b1f706a21cca9ad10bfc0daf9dd4cd0514dff3558c3982820448382b70a4609e3d283d0aa98e103dfd1668f8c6e0cdcb5619e714a4c72fc5cd7065d96dc33fda81a546867ff917d8c7d9e7832c19a475b8db03b4b27261666679be0663c8b7ea06157e1fe7ccaf88b8d97e4fe443c1e1d0e9730c4a30b2caea7069eaa06782717cd73a102274928cd69f29cbcce4be03fa58db6df86b558d0e6e826b738b8f75bab3657c60c17314f69dc0c4c5ded22d5328c6fefbaf30742eb87fb6fb3bf8f01515eb5403e0358512a9f82b735cb99ce3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
