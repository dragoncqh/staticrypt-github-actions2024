<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a0c65ff1e4de891e58929bb1dc198f71809eee796940b20a5e86812d228199813c8ffa2d8ebd76e97f35c324c2ff91cf6f5dce5c0539fa3502ef0d0d2513b401c056c6927b3b2d2979cc0b726c9efbf759e983c60873235ce98ec538afb9fc0d5a58de1f868591bc89f5636107d9b242ca5bc16ef1c9c5cc5284d5168e56dd2a927544a2b9db54ea48b18b20434a82ead608fa307947d0b3ed9319d1230c1ddfdc91939ebfefee3ccac0778080a754030c0860cfc8d934b332ace8c4852715aedd4c43167d06172f0109f59ea8129653d35da2c6a4ea66bd24fa879433b7ceba32fd39edb92cc387a634ce97cec9c2a40d078fab67c8cd6d5fc1a6308bc5e41e5523de9bd53418138d0b43e4c17a1a47789d675d38976004e676e2c6196ea4fda1b1a2277ddc3463a4fabaf421b109dc1e2efa3e6a29a379435d13677a1c51d4280632b98c9a25cbb4af5cb132524b4a256de8ebe5a8ce615dc0edb57ee4d8a5557df6a9f981929cf43471dedf1f07666a2e0dc09a0d3a0a59afe5b5c598bb716b27fcc4e1f523c35d310a4604f6dc7f68f876e7899da09c25cee159b4a62f934ae56d4cc897c5f5bd28415f335709a17e4db45a028aa4c60f386f9f4f4f9767bc0f0af4c234a88130fc3546c8455374be32aa2fe696ceae21ba9187e119de5ff096e9214d9b3c2411042a9153b9af998ad86bf1f50b08e8beae53773cd329324a31d169bcf359eeea10f62e0bbee8d1a10ab6ed21f87c3530b9bc92c2248ae34ebf705347c208b541fef09a5a77d0fcb060040f3a4a68bee7e5df5c86e3df4c481eccca37a0d389663e04125663dae0b6f2e891ac8861e189e1c8dcce106dbce7b4b9a37c762a5d3e58b4bb3f191fec9253400164ea4a02e64e690ad2baf5d9a01ed3e9d644b0dc9d14e1ca4cb70037a17f0a64ee1feca6d2e19ceff5652a2feacdae49c1e62b134bb9f75bb45c56cd4bf839c9b79a495ee7d04d25fdca49373be40c9ff1f99f5839dd610d6e51fcc25232828c9485de87c4c102d127fa9f3c54d07b1367894cd1209c4f4162454a8167a74fc1485ea28020e56a2a93b117410cc4ab328195f2b685cc101431f7c6186a1fab39605b0e0ca826ef13c18d9351a290c5dcf33142dc2e946801b3687cb12777e80acb08c0f947a857054a16717e39bb67094fb8294f237012acabc1bf93f197d587d0740b607a2553391b1a49aafc948f9606b752b3ffb3260c0d521356a6c66d99d6b75b6204163599fdcea7f21112fc1b53ff4a1b871cba346fb606aa5269494c55267b8100f11f1d1e2e1a934a03b3a04ef30b0e5ca2c081adae5ecc9aa277e142f3cd0f113f03c8364230c234101fde258ec710f86f41b5bd53bd0b0d4748f4f92784806da688d879e1c60a76346319cde74e4b8022b9a350a5bc1f5852ebd0f8c83c4c588a74f123c0902922a27843c19582f86ec30b0bc1d18f82327ed792d1c851412d3756ffbd90d9dcd81fa3450b5983770b6ccf6824c9990485b2ad8eec98c4a46a78fe353f2c60e356a7b16ed789075eee7147e7496d9ff765239c946bd7f721521e11edd6cdb4fc5bea2e27849a750887e3992a16004e515733e9ee1b48981943251c92ae54c7316e821e7c9d1ad93256e2d3e4c52a9049595bf72e38b53c3109c689d18d8f65f2aa112da9a3d2d4e475ee4eba71ae4332c5a1ff88b11dfe92b25bec9509480c7bef413a1b34beea9d99294350e594780793f5953e93aa001e116bb30439a5e2b99ddc019e000446dbf174130537106ca686c09f4782cfd76ebad6c2a9b4c098b56984352873914d5097493b474517baf0881898515e3af3dd625fc6ba1ffe3843c475c633d714a7129b1850132589ef8eb31f391abbb201b5f01ee078b0783e9467f4ab6807fcc0b2c8f4d4fc4d8a3ae29c3a553660a00a2a1dd395c03fa2a158db8f599a313cf6bb8aa560801235a10663299050c569074745c6a6ae916e21d57355af6e2efaab81d4bdb1ac756c95b4f968a44b7710b185a2dedff9a27cde424febf92402f28877fb05b134b6ef04a263d85f085cbfd774bf139fcbecde4e961abb911c5f361ae99ccad83583b8542cc84ddca2fe6cdb78da813b2388b815156dabffd7cf5b9969bdc92cbdf01c7dfe216cdebce2787a40bb6471aed0d6abf31317752f14e69e4ed0eed3b8f10a398169b2db03e4c2298f0b00246d6333c4f1bff73a68a6970385616383d1d0f27a6f7560799b686e6474ed48385a7663d6bb054818815d997e2b8e7b5fd158c37ee719a9085a77c8b838f7b1ad5e4d9797981624c123ad62649f735cb8224ce1f17d1c3f6c3b6b0043b56c313d0a5d42c701899a0734c0a50990ebb07404378d2eff46d9a9ae11c183beddb0edb24f3cd5a05a04717121b45fec6ed24891e07dc380226cf53e4793aabc3f682452d395b4032b6f3e27c5cbf4b9ea09faf75b46935d51d8a2718ca698c63845dfcd416eaaf6e6d4a4f92702a0ebc901ce64faa24f6676dc5b97f58d64fd8dd5df5593a3758c65566beb904350b488703a4c8990a984004967855dcda70a708f9e00dc77c35b73ec464b025e9e0475eb784a6f7a61e2b7d4dc97630c30afc87939ca8fc06ac352e398ae5271dbb0d1ded343e56096870731f0043400ed0b82fd1afff400321a49a4e020494a17bc111be5c934e437f7e41fb97e0d43313dc1a59341713b0eb474432095a5c3b30c3583a8fd232d3df603e604bfd4ab5760a2995420d6936598e12d169009ab89d70ffb21aa33b571cb8a5bdaa9708a42668ba57bf87a478b272a1f6281fb7c96e03eaaf699d4ec05cf5a672291aaec51a28ade922f773ed87c533a5f7bf8d13c6ed22401b7e461ef5766b08ccb241c8ac9b9df619e874d15697434f0fe9a84ab812f1a509207287884c22986c37b90a02639398baabf27d19db4a749a43ec8a915dfbed78856bee8dfdbbb573fc1b03494ade694e5d7c6b414250015f4549c2fbb55c554a5de14ae14790bbbef26021c523e4784ae678daa2d661560b85a8fc867bf00e389bef19ccc6d241e1e31238b7684eb20419b3b15974c19b1be6b435021621cf10c53e08640f7bf745d81c9f7a6c5ee076229481d43fb198b20f576bdde0051dfe690612d0abcf7b4eb50356a88fa0fe4b25f3ee00d35719df5770b4b98b99db62767758a0d69344a1c8d6a0211d2d1820e8e44c3d8f9485365dad95bab5bc148a305a371b30b70f86751c888347f887a459fe294aa4e26d5b64af109db4f565a7abb07c26aee15c1ef26c3c381aa38fee5bf6079a0c4c8617776f333f55ac910eee23c3e8fe30bec5706a31d1f93d64a89c4669cebb58c2fcfe7f7160dc6460a44c00b200c2681973f7754b82f615e604b274d983ac3af0799dfa1f3e8ae505f96854817d65a90cffcae63c63e2d778571eee2a3f3831378b63969a2bebd5fb154a38bdabfe2b6e41b1889363edf0a3c1e2908b1ddcce904079b9af60eb0a4a14a544105218b911a9310b5a27468628bedbcb20986562905234b0bb2a31c2d4bea791e65d28d1ca399ca6269137ce3f0277ad8c3c91908ad745dc3b64a041403908fa36fe15d4a9affc26a5971f15ad59f96bacc1b63882d1d839c65b4a4d703e26c3f85956d29e76a6b0ee867332528db4178702c473da50c8cdeded38b354f4429aae1de35ab425749d3fcff18a137fc216fde8d6e4ddb37763efe2292de96f5b7d79c5badaca33ea12cbf6d42f9209a3e779a56386c57634686aa06cf5b269b9c3077d9a43ac3d7d19b1c3955c503f50f2e41b594bab23e3902b877aeb338ef72f6e67f63dd7193cd3ddff8aae9bc4369a7f393a3eb6baba9ad57db95ed469a51cd2321bb4094dec95694b071706fc8a982ee4aabec7f3e39366e1e57fb9ef90eb380a8ab08a85fb02a927846d64aff4393d050c34daf2397cb4afc44d949625d1d42ce2460b06aa1cf2d11749c55e2a3bc94def52a2a378cffeec89faa1d8de2a3cbfb49e5c81c90a104f4499445ce1044e376aed471c865cb663faec6bc07671784b66bfa31cd151c1b16899cd4e1b861e7594e840854221fe1ab3eacc1f72318826ce66231bd34219db8fc4dad59e5d38274ecdf9c7bcaf8064bb081953ff696b3edd1847f786ba521c5933ada86f31eb0b2a0b3426ea34c9aaefde215645319a3df03d96c972d1fc2785f279af344f86bbcf26f724f0ab642aaa77baaa7f8c28e36b2aab90ba43a044802ad91e2b8752d85606bb0b13cd75a18805955c9340a0ff92f7767cf9bdec8b087df893b24ce8508296fbe00ce496278f9c5a4b2aefc01f8883ffceb9901f85eee61d007ebb8aaaa904487ed77e43a20d9cff3658ba9a6e79c9c2f5255d4638f4f487dc6bd171f661e1db9e3329cbac2a398a09aa1f61045e7c0d0aaabfd0f092830124676aa5bc1b0f3c16aa6697b3b48230af33238a4af1f063b95918bb2b4fb7f0984ad77f57b3c9d56abc580253b9e1fa2239a73b1860aadef85e6856045f5bccf4b2ea56ff0662331c9490088a528273352560139c44988cd27d31883d1aadf0e3301a04660404915bcb0820467f7a06c91dd669e3269b20cdd6bd30390c87335313fdb2d1928d9b9c7367d26f98a523ba3691a2dc482bf98d77701d1ac722110b8e0b6006c36874cbe47efd99ace4bf8e408f444378235c83c7cbb68a0b41f0df97b106524bc057477d60474abb79b2632f15fa17aa7ad970546ad6d7257cc3f8459fc0c8bb2e5a503a880cb2ba2bf04afbe7f64b0a9a5317e4442e3656bfe4ad60071389a39084b08dc9e22a879ffa2a5acc74d61a8c90752b70dfeda5f46e65465f57060194ebce347b55d00210659e86f5fa52bfeaa35eb471f99c495f74692dd42549fd120520c2ddf828ee16b6a13ff7df01e4c2b7be175872fd97642c67449dfee2278c7f594f061ae05d37c7deeeaaf8498c33f0eb34bf88cab4771dd0544fbf302dd2b15c68317599eed538b41531ad679143c9c8d4add8510a59d33ffcc828811ba9756ddeef2801c38165aa8a55de060f63ffe9cf880decf3d6a29ddb0b4a028a196b02ca53aefe0dec64f170ef9b8be8309985e8a0494419e4563980b906e2954fc14dfcf7d32bcbaec6529d42e0bfedaf718351b461db5b65c4ce7d8e5b72345731655ca18897268a00de1dfdc7478079ff29e5e80387added2f606727c5bd927388f7ed2ba9e1fdd0b21535f6b320050bc6109a23be32724e5aed3f74eed37e1ff9a9214b7f99d4d0776dd71ae987c46682ffc0986736840e02bd581dfe21daef844c8ae2de304cde9fa212d573f4b23eba45821b2c9431053f3ee2d148731f839655c9e8c583373dc7485efb22ec00c7e8aebc6cfdde7fa61dd08813c6fceade2c78f2ac910e7cb44ec3046e8cad5d26e96300bcc73577c2e9c688d472b61c54295083008469d96cd607459e1eed9c07968aac2d005b151ff597ca20d8c2906805ce206ea546ab78d82caf3e65780300a100dd13d22d2ffae37e644eed88eb38d6f239b30d7b64580ada7b9163740a6017a10498c23cfaad78587c7d84c09d7fa8a889e47be5f1ad54292f91eba64926629c67d0164ee4493636a76fce762facfc26c99eff7dc3158e3583050c3226363b4e4a606808d6fe842c3ca62e1c444d679320547a7dcf87f4bfa041de4ee849452a836c32f5bdf8dff8999da86487c43043194e5ca3d3d933e420b7c5fb37ea0c73b00b244a7efb6cbb7d1d4f2811ba04cf7a83f4899f0798007ec62d4985faac2e35e66639f617e388aadf08fc7bab2bd0f69c06bcb149ecfb208241e3e71484874241b1acfa2508caf8bf0126537fe949ecb241425abb515c51a854e4862f518810c1a5c5135a9542a6cbb357229920ccb1194932dd7501d11d6c36b2695976d088cbc36f714b966ef3434f30719ace47249a66bab0796d3e7e80840ae4ffeca42756f2d9d34dda64fd2e6799d6e21c1f89868312d35ea86953fc7810a35970f741d557b2def4da32750eb7bdbd8d20bbc1f24ed78598c5042d6252056073c53e7f5ceddc18d356a46ceb9be820d2bb60ef0475787e0d3b2baf1ecfff3985edaf6d0ef699043b9954caf2b7c8f5c1be7e3c4d4ade56d84979b30185c57385589092cac6ef10b192d29f54ded47619204931e1159787f920160bd2a309d511c46a4144405d26a0c5bc9dac5f453fb44085cdee03b042c2fba97b39640d36f9d87cbade1edf9b0032ae72e5097b8129e15f5c928d2de67034828c263a9c708860c35cd0f5ca7cc430dde5bd80364a4d3401a960e43afa086e8a53ac68ad6dad356242bd19a5a37958b0e8b5d332cfb1f2b6a6b45bf58c21ba89c51e605707cbc7a9bae1a8d802cb928fc00b2d7d7afae2b5c9682004beec07d292b3a138632443a7d02bfeb4cfe18b0a8cd8f5231c3fd6eed08e5eb27fb6a23e3993d44d0f4d0798054d44c7985c79147f0efe1c23c0fef81bc5dad3498f144888d6eaf7e7aebf997f9dd6a37ecd425cb8ae5fc273cee404a40e99dc124770b3a7f4f0827590089d8945d8bc7feaf379d9507f050e08012d25488182c8fcc18f9508063cfa9eceb728ca6f4c24fd4eca0239cf7a4297dfe1ec9b0bb479be5a5430f6c2cdaa01d6b27e867a7a74954e8136f4e09f4358bd1dfc9aaea7dd2aafa18747fdb78401ad0de84f049be003933c3938017795f3ee97916c45e14dc3e6eadcf611326928d5425dd3d572a70634319e5a7dba773b9c8d763faac5f6c8b3b55db62a3dff8a14a2b3d2b3b0a406b09492f5bc83a31e60f6b0cfc5af6683d603a5cabbf7967f303cb619f9f92b9c16db4a74892c38a4db15087d05cd6f48e3d00452f064396f370fa458078d226e750e4b19b48a6f325bbf0cf68712642df73e5f592a76a057a7c57a0789199e3bad2cf8056d2a937c6a5434370e9e0cc98bf542cebeca3d6dd24ad02678472e9ea2b9074fe8024eb98262a557a38c6c0ff42552beea6c4114abd93c13db1b0d1769beabc2e6538c508a2494237a2659a15753c17819b37cf2284cfaf96e28a694fe91a4865937e28146546dd5014d437814f1a99936d60fe8cd6e0be2b280043130624c4ce79d223f36994853372e9996779370001be33420b92d776dda313b525f6d5fd8c4df9a58f104f8b7281cf5fb5b0f136145662001a69e68fcd98465065ee109440723096b1dbebd4fd31b1a6695cc45da2178122b2bf194b4da4ae943b8b77a8be9a5cdbc1e483b04f46a594f8983256ccfd9bb420efa16a9ff921a1bea05616ea1574b37f4bc2a5abde932e1a7b634d4f53e2cc0bc2163d560e0e4a3c4a902c14fdc1aa2ecfd737998f4c667c5c09537f9063b4959688f05c82530cfa7fccac979092c7f7791b3aef4c03a9d079d9ea168cad9c969ec9ef569d814c734c8165eca185f5c881988f226d0d3963196a16dc555f3c9c5d0d0fb4db14a4cef0c9413a5344e2858532b7bd60713f0030e396a1bbd8a64feea0b6db226b87613c83b737906f64a5db6bd71c925e51c269e1d4e193197154b726dd3c9268eea6521f75e0e283c4a20c315862c4eddaffbfaecec76ef5c02382f49c78afbe04277b432f58d27d7a2a113941911931469c4b27bebf0e548434f00a92c67ddeea04fc38f3a203f033a9ba448b1531c9a38816815d4acb4a3be7aba9cb5315beaf45435779330689771d280713703b34c0560e894288cbd4328449f86f962b2e88c51baef71135fff47a03c92bdd79f1f76f1aca7b054e3f55b3eb5643bd5c6c05d512284899576fdad32cb3f9b986d9eccd696e9495f2c89f5da0558210c6839b2c0cf57d86d2dda833b8c630190944a0dc95dd3d6027bef729490f860bc35e825f0421ce408a81adce7c8c38075f6f54b4caa3d3d7bc484641b60a9ae520ba533a13c960118d2d93ca38663f62c30a1557f6e8f95762b99c3b4a83a1ce06cb206287e2a21dbafe8b429e83dc7d33c3d46378a83e643da177df1232c7c4c730ca0f9a04a3ca5b915cf407932459b9fa50fd55eb12f5388142d84cb6b890d54b096509320a974a965f111c7ea17ccc6f41e64859469d25cd71f5152679baf2a3e4785ebb737cf2a5c0328a1c0d862635ed268111f14f1bb4a2cd13bd661b29e1251a8207bf8a380bb8027bc233d04acefd86fb40f88c569de9e286092f6773972610a9b1d1cc82af37a5ffe012cfab2090d3f956a0a45249e9806e52bb0bfb7cb80681d55aaa50360f222d104b0155eb00d01f54c7eb3a0767148a1327a7b2033765bf2f4677e58dfca8233301b292b12c67e3ec685e1dd01176fcc4becabd32be92e75bdcc5428032dbdaadfe10e6ca6c38daad44c37e64ab2c9a1e9d1a12fbb806198e190bafad3bcbab5ea4c9f470f3b890261a36832903f3894bfc8a198ccc5f98fcbf8ea979a7fd551cd6aed9e18d9c48a0b962afd5053d261704ae335ced17df56b9f587dfaa85da4e384cb60418f169701d9b592103c3ef08dd3a3abd3eca1de573ac67eb224e8f1cfce421d10f4e8b4695d1c9a90a7da24157fe6a7501d00729dc8e1fbd0eea3749b083105d75c87a3bf15dca27c1f3fb6d391552d59b242db3eb183062eb2a0d388f72e8d5f4bac646077e2a5eda23817148e5fd23b12bd020e5ba1bacb5538676e178d702023f3596c229393a6762df11074a9ce318fd920400b8820b42c3b4acd35f9038e985d059aa77c8408ef2996918052b48a5b29164e7768126e1ec752b84646c7362cd3b328d99c0e639cdb8b9ba61a2604a2f9c5cc258c8425d0b318dccee2f0126f3421b6c2d1cd2dc0d796e42516e9329d06f7e518b8ea8b13bc64b8cb14d31501318f41648ef9d666e4e92f3ffb61fef4b4a6ba3977a7e24f5eec1df36e5aa72bfdf67b479d79f4600119dd89f72e42a04f7e80e70fdfebc5a5a8bdc186e435f3bdecb99e887cdeb5e20c8bd1504ad1ed6c57f8faddf92365508502997355fd19a38a9ee236e0e4e78d1f7e17076d7af3559852a31a8fbab089d1eec911d922aaf092ed4e8797ec3d2f6dca7c3b85c27e545e7f3abd706fb6111cde3992b9507fa911ae38b5e05d4599bd74e255c83b611c45d1eeb1318bca55565ac92caa86782e0fb5cea2e27295c62e81803b0a59294e9fc00b0b73db6679b19f0bbf9715c1a8c1743d7fc5c175441d0b056f41cff1713810f09eefd794e23d089332ef2805389e7d3af70c67f3bb67848895a654ce75b05607251bf3a4b366986782de188cbc27a58c62232e9c377017af628d194c137f1618e8962435204b16d74ec0fd98e9b07e814a4d93c5d80d42a7232196a984542cd4c416484d84eaa81edfad0f93fd5db2832fc64a4ef36927a75bcb02e3601af7345161a640631f41f760045489c35668c9d323905427da8d5aeb57d29b92646f99c1996b76be700d4048e063cd1b2e09850f80b393ba4a070ec08172d9e8298d07d1f539cb9151bfc374281fcf25cfc9ac971a1b3eff1470cc70e1e646a3f6a31e0ed921a4398c8817bd13fdf1752b7c1177f2840135061702654b22df420a0a681279252089a238a5a22cb72af88cdbbfccae474cdd29137362e632265e5e2ab79fb61dcad17a1d4f8b1dc37a5e5f207abda511a674f35b6cac9e8d7b07cb55b1dfad00cd586ec2fe302e6fe3fdefeda220be58974251847f7b7b84b82530f4f769233fca8dd2ffde28f9f626d4f3d1de34bcd56d963705464825893c0b438600912e2e18a15400db870d54bc1f0209bce8de93932ea7cabe9b6f7cf597d4bbe1172a5b3bd9515449bcd7a246e30fc5b7e93c0ad5d4345625f9eff830e28ae0bc9e815cd409b4842137cebdc64b82f98dda69ae7574697237d8f281a6a61dec836d624a5bbb0a383a470d0b53f7b5c1c9d68d43e5150baeb3a40c965303749a05251ebb2a77f03a4ea75a6e07e61074822648797d01a9205c3c76a668a3e8b9250baf85dc424fd8ca9f54c6c9623998b3b0bd66cd8f4e42f4a7d11283850a7b219891db90a4773fe9acd99b2df9e674abc0aca76d519e5cd2e15b7631c068e04231a84a36bc420b87f47be37d359ad4b0b6d86d17e50e7e31b9506121e2e6d8f36ec12e9a3c4c71dd227053fc0905db7f71f38551c653eaa0d86c74fcdc10fc3eed9c0915e3d9531f337098f3c3e42ae63fd307f5b484799fdeca8275c11fb364ea8b289665619b60fdfcab5f71551c38bc168c8ceaa9a1847c92ac8c2a07daa4dd4ebfc485f3aacc495adbf8697de6243b0911847567d4d42d3453b11d23bafe17b8c1852e31ff6c462c5a7614dc86a3925a81a7eadd175da55b1aa006f75a832d8d71da371f918af2c3c56c9044a6bdc79e13afa2c967ad76bd209cdacf9b4c828032519f28e4df8f42f9940443869721f73de593eaec7652775325abf9159c7eac64ea0aef866cf43bcc9da5a985f14503c20a7fa7b2725e314126470b41878af6029537e8135c0e1f38ad208f650ffe7d1599e967a2df11cadf25e0bf9ba31c2a92087376ce34d5ef0903273f94f7dfbe89086bdfad7e5f31bb538c398c3b3340731c59d2b740dbbd686cb3963dc383aea2044f8cbfb4b771df376f5b1f16ab4bc47631e75a5506dbc89c5f9de8ba0fd623592c1a5c9f9a3332b09f994eff0b5b2ca987e6595840204647da30eb9045e1bb38d6a8d85ec7f67ee757933e41f8aeceb4acab94009d0b70c9acd7992d75afb3ca82e87ef9e7ee9aa8673ca41a00636e409f35dbd013ec8f97d6bc80528f6b357052d3b9a9d0d8fc36408de5d882bf1acd75aa2a9297a4cdca903069c2c4b9ea3eeb906aaf6cd9399ff4dc4c38579f74284a4ca869a8d5ff5984e9c67b610efbb060efaa57a51f22fead03160ccb9b1e8e1766a5b8979df72de5b96b759fbbffb5403c3cb8c84d2dd566d19b12eceb4997d832144063b57c535a8239f4930ad6bc00b365d4066c88149a916af3ccee73de07046f202f2fcb62ce10da5fec2cfbeab66c5bec0bb7146335b57bf9ee38c540d966487ee794f60482398066d4de0fb9500fc69b84629c0282a841b60fd43b5268d3d7982c0e6dc92fc82168d0309e2fe740d95cc2aa7b4dedcd8a48929a2772126c5069e5c06e8d5e049fbc33e580783cc714d0575f22cd8b7b6d435c06fd2da561e7af9b235cb16a5815df6c6bac2ab32811c0e9a3f0ea586631bc1b007dc51ac6cf98fc067fbd303f8044ad55ff1c955137dce2b7122feb002f0eeec5550cc44dc8566bde9fe763c79905ae0a2e2ddd10573a05abe8c9728279faed40a84c4cc8e715de203b9fa62479717329535ba0d102f8b738bf1fa02a3ee076bff26630e566eab50a1a0d8a511a3a69c6e776272ec244a6929d793a3a1dbfcea86b6fb4d4c4b9e51ed78f229d3cd307fec31708be81eb478b4ef80d670f344c18580b9e9b213af565ddb790c997c0811e3d53521cffce79a2b7970ae7b7490fd9567a795c5bc94a11ac139a750b9211a352bfe18d3efe544ce474b180499f2405a9375f909f6a018f47788d339f3fd6a2d3de17a54d4918479250e7926fb339743484dedde5e00a5dcc2989d6106d2bab31778d6c54f937a88dc153b0520dd3f12b1385eafaa0a868d4e9db27b480dcaa3ae4d22a1d993cc8897706cd1c472106edd65d5401bc605cc517127611911fddc43f0489da7a395dfa76adb5f1f80ab4bdbc6ffe49a6d37c67334cb657b149805b61c5ade87ef76f1c3262c6f8986967d437deda22cb6314c64dd59348a8495d9b2f2f143ab1b9f0f105ce90bfbdfb7e9671db09eb33c70eee1eef283a00263e9160b9fe4fd74ac53defbb5f56d84333a238f61fe9557b408e472471301f7a92e1d7e28ea0ccb70bfa520a883283728f8e5b0168fb722b4b84edcd342955c27957a1a8a094bc8af6063f63b658e6169443297d4373dd39b7d2ea33aa3356484dde670b144484cd3f174882eabb1b730e0485e1983d70a73c9a7abefc630271911628ff16032ca3a04a59befddb764bdf3a347056af79045f96541c45906d9ff2d7e96177de20edc86a57e62b1efd6204ebb1bea3e8e30c57269b4e78cd2d3a8dbcb028b86909ca660f8959584d3fbbd97befa9b3a59095f007d8c68e79a67c7427ca58c4382d31b649e2347f338da8c18fe07f9a6cdf2c3c041942175f8694cfdcc9ce34cf0923eb0cb3990fb25b8fa628d0d169cdbcfba52c1d70cea9704e85e37f9d5607b6efe963513e9674e5bc05de34e25e3195711bb8b6802380a804b6a5632897c518b51e96355bd1ea2a161c5f4b2c7b2cb46c18d7c078c68136248350cd40ec9ac24ed7c33862246d06500f9420eca1d39a4b7a92f2df8760db50904d6d70335741d70bc669f3b415a707316c08a16d7ae53d86f36d3915aef6775ad96abc4334753be3627decbf0b85366c52214ee11480fdab7f5dca24c084957981e53c896d500660ef0d1536c822dde6f4332e81275dfcd38b757b5c71194b2afd17f0fee78033d58b7f414b33f16ee03495a13ea5cf49b30920de5cd151e6b9cd7cdd9da0a041a8a24e736ba4ffd3ca28f16d279d816c0fe2c64d53785d201c64dec4f4b19815e458afbfa8267bb58f88128a035f1b7cfefcc285c7bfb0f9fa5988199c7b683e777a1b35ced9d66e1d9fc535cdfd6210f3b15865cfd3fcda658b38ad1f7876da9df74cd29abda7201b14f588aa7f14c7300ea5d6d4853088469cf2011fa4f15baff1ec34c93c76af2b9da3d75351e3401ff684cb164fdddf03ec840d2446c125dc816046d49e768c91cb0e1dbda1536f998083c2abe2084a3bb2b84c54907cfda4b4e33aa75bc71f5dbf3da8952f93ef61c1030348ab43bee4eb2bc3d538d722609c3726fef5daaec7b8eb0073e92d079e23da6c3691d9ad2d7b6f1cf275669725b37f76e3ee2ca4823ff3233dd06ad46c71af23f60fb124911bd362fc4ca64010a7e206508978250a2d90bbd649b0b24e083e878e2796831af391aa502257b8f80d2d6c63394b69bcda8f853a2795a4d944676f140ae427825aa41fbdfeb0b0c37ea0578442893802c7b22a9da3db9e58f933804f345861a0d7be2e559710ccc745c32723c88bd595e8a462d92aad2cf339c686170a1f945ddc1e228d2e9e39f198509d18655fc2de0c61c9dc64e17e582bd541df808a8a54e404a79c3fda343145a3afca363c07048c3cf4935c6875fb3b7d522eb9169a4bc9d5ada0389b0f1b9267c8b4bd69839d62cd851b1c7d90d8f75a96104003f480f7c1e75c5866dffcbd9d4ba1f7f1e09f0bd75ca879097a9532dffd971426475bc4a692c87efd6ae2063f0e88dbc37a97601b58c2aa9df0241f2a1da898e9dbeac4698dddb91c452595924c08a7fc701988888a3227924a17fe35795ed26a21610ba5c5185d4ca7a40c871f9434eaf8aa1c047faed0e6ba65c4fba209b21ee680ef9eed990906708e2a944ee23d8716b3919eda398c6a6003cce44bf13b051320b8d46ad7bd0e30df077df6bc8aad342e6785cd2fa650fd2358d52f951163ecdc3b99220daa36feaab1a47706f9f9b13fbbece9230a3d06a73afed94347c4cc2f1ba5f9f473b0aa6ab1a05cf841d53580bdb36c9e1dc26f0430fd960bd2622c34d83dda1b90d44f1dd64f9c0a3f09bf7d44991460bc546ae9ec73ccebc63c7fe45a2760f768b78dec4a2742a0bdb2a93322454a39263b2b5dbc6cd4e4308cfd4fe4c46bee6e98ab6a53a0a21ce90d2a9a6da6f494c877ecdaf3e47986153c65ea09f13a8d67a4feda3f95e9f192e45ed902b2e6fe4462716613831425964be1ce16217320a80d826e17d5d653190e10113abeea0d79ba02520fb553c1e1d81570658824e3f5f042f9b663e272feb64ccb4d6d1a6be09d9f41c655500e977160c01a40568674e68139e1be220e6fb5f9d4e9f8a44977e65fc1e8875111c0473302ffccceb869e9c3be8bf2a1f1bdadbc28d2eea8319092711f51626f1cbaee08eac057eee7be18fc54b71b21cf64692f9fa8a49dbb26f79a92a839377888959880fd0cd301626792bdaea2a1b06665328b437b5866ec24d2b932f9adf0ab085f5b4346d85978cd0e9b1aaf2e72ac39f171acd2c74b6abace0e01d9c41d94bac3667c228de54ab4f86222dfcfb6ed1e9832177e71bc12a0db0df48a613579814db40389fd8529686a275feec816e78958c1e6a6cbde095e14b45e6ff8a87f3fd36a866e597cf7842d0a383f43a21750809bb368f2fd8b3300b30b562afb222f4b6b871d8cb933d63433dd6f6810ff429a9f59da2afd62d67ab3a60972cbdb3edfaeb6e2e5c155773ee1fa7a96f3f4ecf6baf275a4d59b809a6e05631493f99ece55df6767f1cc96f6b264e95a3886e3c9dd807a5e2abf376e3294c828498ee71a8a28335e67971034d31039ed3815af06443216a8396809b7ab34dd94213e013e373ac2c863df36598ac6f52b1e161d9f221c926ecd085f182a88334e85a687170a34fabeab3ecbcd6a45a9752a8a07b05326df0ed6208354762e758c4f74c81f8be340fb0922e0dd37935557a436439cfabe9faaf1cd49f14cc05058c2ec9e020fcd284a01e389957315ef236913120b98dc9b330d754cb324a87a3619bbfe35d7e40151648ab3a7b4be6b10f2b562028","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
