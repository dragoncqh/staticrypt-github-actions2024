<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de875c6d700f4a85df97e6dcfff0ebc717196bdd7982089f552fd51bf1b7a0e4ed1bffb507c09d87fb8ff3bf81ca0ea2efc381de3c91081d5f2b2b6da05c4991786105a82803432d29bee87ad269bc76c609d3e814d3bf9cd40533cc968efb43f4a348b42948a24a177078e85055bbbccd355e2c1296b5250ef40c8a5dc6eb226e944405dee8af95b6ae378c2d133dcc896b455ee8d3b35de87f102c5e4f2ca0d7997aab0a94a9f9a75ce45778857a7e0b59cecffef5df8e2e17cd03e6377e4e1b82c27da4306f37e44f89d0d9fa2275269290519fc7a4fb64d5568140d21818e34fe725ab4a4704556032b96292edbaec639f6faa09300871a0a19c23e98cc132aa55b77c536173a408d848f8ac856c864d3e12e2a62e714f431eb9869d1ea0e71d708698269870c104a09093f7f623e97a677cc1d6193909df92dd2a8288238a51a0b0b4733f30716e8b732739ee74e858ed04d76815093770a07fcd7ad3b1aba88540c62c79846b5f02f56e569c271fd0ee5470aa2a7be26032d5e808b5fd311d68bbf856273debd7f00fd2dff7c00d91fa36d396d6ed6bededb4626a50024b15ffb32679e9d91f459c0edd212b91bbb13da3df6b16d71e249bf60f0e3bfb98b1b32b784bc450762fc5be6b8267a1ab28289992aa20f56b922637c0b10baa7c2c4495b5472056d7da58d8d7e2c0e7f2ba6a4c3e3dd9c11d3e5aa8589c19878898edc12bd91bee8f0f1f45f1ac6cc6d9fbc6f7e5dfbfba7371b7d13b5e5c2f1cd13ca08438da91e75f35d5721d9b557ae18b8864a478b29a7036631d1ea3d93a1f534b864a9a00ad28bab0ce1324e3c71e901377b8d0cf2aee602363e336ef4c2e0737d30e4b51c25e2bf29d5df4f0519f78c5d312da3e6102536f568b6e8a8dfcd8b5222202cbfe744833fa540267d1fad74a0c9938eab9b5a75a70cfd9a45e86c768773029bc3d0a101ad07f7933b4fa96b1bcd7a1131c37baa3cca55d6e7c0ed378e90ea060f12d2e29589522fccda9384239908dad632f54a9fda8e1eb572392b1ef736f85970d475e992adb867158f20fb4a208f7087b832678dadd50e2a9005020cd8343e0ad70cfd6495d22a1e2ec00aef76ba5fb964e3d697b2e4881e84872fad8117b7c63fac25c3573e896b1d25f7fd1bf0ad04a8f83872feb9970e22c5039b65e3fe0069d2c78457e2849dcd8f764221febf943c813b63844587365ee47a2f0528bdc77f2f2bb77cda75e11c2b72af89ba40dcb8adb95c095ddb3b30d0b661bb525cc3af38f4b1141317e91ac3df687ba413aa2a0756f4f37bf675f7c91cd8c0bf2563191da311c873f5a05bc47969d749103e7cb542b6ec293b3763d1d1c5bafb1c18fc5685bb30d6d6798dbe05f2581729555dbaa2b6da9b16bfed909ffc561f8a78bd188d8ca1bdaa7a5bc40e20c86761e6b3d58740eefe739b086a4f08ea3e9fa949ae87c0fa9a53d1a4b757c7a4e4a3ee10628d24e56217a7213f8c7e772e349f204fdb2efa428d5424fd6223c15ea1fc289fe0665d18e43f576f03357a948517ebca545a7d6db13bc21d5ea50e9ad897e53be0b9b3ee2a2d85eca5435d98e90943bc885ba65e37e89d29a75e8e089490482f43d694d789d998e871f4f9c34a9fe6749884a37fe813efef116c5c154cbe4e59aada8b471efca1b18e803dcf7bd574ab5afe4183b128c4767c8592e8a323c78083ea90e45c68c05fd5d3dbe69423e7bed732a8e57454109c2109e4cada779320dd8bbca2807979859108b549b80709b156a0f5e8ea074bdef7d647a0611aa36dfca6268705462f8667f6f99614ebd2d1260b06e77bbe1096c9cfb1b990fe84b9bbb347ca2f2ffcef506bda948d9cdb2e1af11973ce33fd671016635584334939b94b391300aa4eac38d7cf531f59afa7c674fed3c4bfc43be653d2c00dae43ab89d6d8461f01368cc2674216223064499c6647043a24d424ba3f8425fa2a628d9b685a580bbaa148fe816c34802b5ce6412afa8cf7d78eb9dca04e5f41269a431a3254ba813d652089923070deb8ce73b25ff10c579a7fdb80b83ca04421823d16d118b4ca037cea2427d0069632a9d7388a457a6d6d46e2b0944c8b257a09fe9e79f157a6a020295b60d83977fb844d3d70d99db9a521bcab6c96396829db42c1a7708c07cfbd4de7c6a0adff54338169731779e8efa43ddf63c46c7cd3af076bad2d2202a7f460f0d3fbfb066006658276e22c4c813ad0f07afba0cda97eda84e0b490c2debb49b8ee6eb3cd95f43c4dab0e57a124c73051f94e660e2a1eb2c77d9571cec899cbba357c119edd41d1b3a45d6e046f0c07012dc08a6818ae2b65cbb83186d552cff5f02f406e1f8b90d1937c0953036419551d6c6dc37bbbe306f71750aa3fee4d913016ee82a6230b885bfdc71946609e1ca8998f1c702785c9944fb91c4ab53e52b500f23de984db959ed6802d36331fdc27531b0f9cc9691a42316a032daac85d637bae4b229700fbb40b7b973814d564203ad24a827d376c52cdd87e886b019b390c32decf85f71fb3862eb284bf95f5e30cd7a5911b842b24d46117294bcd5840de8c26aa7b3912ceca266aa5db07ec9eac57297795f500bb9ec253d384cbad664b747f0918c1874f371d30d9001a96a79ec4d8c1900714c77f929587927948fb701d3c58aca05eb88dc3c03f0abaaf9411fb67c0647da5b3186a92cdd83226501354d3c5eee13eca7db2f46e448fec6edc99b415fa55b5fcdbdfde66b604c6f8c05aca7f350570e87b0f9d4123f2811322da03424cc17043889b1f08c5b61210f67604c9bc54973ab25988d02b04763bce3316c17d136582b9ca3af02dd2d89f2dd2b0d0daa9bc66ef0b0c0d7ba9a9db276f5f70ebe3ea54d0dbb2ece1de8e4de80ab9a09833459cefb625fdff1ba511fb972032462b4b9a9c9f56dbd88595a78c57825fe6fc09093643b6f735918308909c2f6c195cfb44af499217e051ca797dbadc052781f5a1ee764c255c65d617f603abdf39d6be374076ab4397ac04f3cac48d613cb5a8d29c3d3bbfec3b6c3f47c65daac3ea1e1f2700b11bf56a78d157b16483c06061bb591077d29bf60f9d7dffe5564523ef59c3c661719d970cd0b900ba233c715307c1144bd450e9b59b006020fe076f96e90c7679013fbe99f7a7d1e1c4825fd3cd946a9b30d6b790626ca9b2718962192173fb5fb435eca08b123db40b46280c8744f79af034f2a0478ca8e551b011fb17a09f86c169ec78580101e44bd1d243ed02ebf478206de7c5b5d39460577861b1235ea75768f4a408f12b7786e1e5933cb73cae90af5d6758b0dc8886d4844bd077ea4091821cd0cbd5086f3affe7d4d1fa05c6f50977dc31613a834db07899878d3e261dcb11ba8f8a7fb11ecf60f0efcf8e53a1662e6d2359e559141b43304f632de661164d622bc357f37aa1cac3a70a758498cdd5b5b60372061d97fd04a1971f932fc0e06de6956f47f07530ffd27c83bc77d9f4d9ab312f3d44af10b2659273c0b5d672d2429e1683b63468e09165d455ecd40e298ce558cb38ff9420ab5c2baf1e074946e9deb0aa9d8d48bf6122031b76cfb44403970f4ee6534d2b1d646a671c48b51b9f3ed74baea4b560646f45303e8a8b8bd28716fdb0964ec84fd0e4d8d8ca8bbc90b97f01f83ef6c640746e2530d1c589ecf64fa2d4258138e440c85321d2ad980a740bd54ae139b7a3ea0f3bce72133812ae103e6452dc5a8423ede98b7f48e1db94bdf70a91bf299265541f62b5b35fe3f7b707334cb0b55712ebcf1916e510bf5c4d02282a0103ddff7f2868ebef9c7f3a57e5429934813b49243d52e54f4c116b6a71352d1fbc2b4513b5428dd12541801b56c3bcf2999c322fc593b7d10833b14e42bb871c8470aa0c801d52216262923f34a52e9648de464c9b7c6e96b761979ce538cc6a5723c093a6cb0687d09899b2faf4cfae653ec43ea643955637aec91fbd8a8aa5226a2d96da7ddf8f70611922c9e1f3baff7abc55eef1fdc86bc49308d535f530e1381cb1dd2e668bf83aa80fffe1ea5573916b81664ec421bef78df2c292415b19ca2d7d5f2afadc03ffec1026c38817ced4b6735b500efd7eab4f2e4ecb8a47eaca95270404604d0f3fe7625288fa6a366a507cfaa64eeb00f72bb327d64defc096787abfa097b56e5c1c60d43de2f6d199a66e5347e9623c181aa17591b0c25866e688ce5b1b94b0a8c0248714225866456f33f6621adb9c75934727f64392c6a518bbaa69a1b228b55ccb4d718ede863cabe310cd333bced4964088ab481ae8ec320491c2d6c408c5533f89fc2efc6b85b7b3990637b9e1e786eaf2f038e2da022f6ee27e8e59d236d3d6c3bd7105d3e24b7e0b325f8f83cfad998fde64f00d7fbd71a1fa91a5add62842f7cc437c35796f9fa5bc59b115fc400e279b604e651c339183dfa060cbfcdbe5938bf5b336074525170241cb7ab0c9a7789c3b234ca605fe3bfad59312774894a651454e9ec858138db15c48cf8f73da03f8fe3ec5b2c2981c0e6a4679194bafe4cc80355c9ecb4f845613055c3cc3a921f3eaae7fe964314333d9e9af9c94eaac43516e042c49e963df6432703a7a4609f91ad5a1c1c3749240315568b6e28a6cfa8888adccc240ee5c51a2011d67bda1940ce9328a9127791a9a1bad321968d557eae7f1c6dbddea05234ffaad60c8972f5015485ed3cb4082f38bef2bdba2bccd67b3df131b1cdf9f5d01d77228196c4a9d8271a0fcbcbaa65b0382ded5bc9ef00bfa5ddbbc8da88c2f7a4ff952a2d8f22aa5d895af81d837f3904fc2af391bf7d179ac1f2dd7ea9dd811967d5a5872250db2606785d8de61175a4491e48b0ceff9d3f312eecf451d832895d5d5f34dbdce266ebc1d5e0b0f84328aa481b30c7e6db753713d58ee8f581edcab0cbe3b65243aa7ed03d3c139ea3d5c359192c0a0e9a3a471e45ff94011f76e21641fb1eb61ccd3f552d3a9a15a0ff64cded1c126c8bde47460e83d001e9752aa6cb4f754c4b97ebe97f984b9af361d04448d74145efbf5d17c09d155cc42dfbb7c77c6e81eb428132140c80fd107b14acfd7e8bf6055a40d79913648350e8d915cec792a06acc158b7ff0572df360df1faca1a38b3dad2b14ba3b8d34a52739b4498346a07ae54f32e11dd6be2809b1db8676f5f1ed1cf21279f23f545fa3c920c54dfbfafe72e02dff71b060ae4183e813fe2f989c7fbaa976fb2335ad6b629b1e3deec7bb1ae55d28e028d33035350a996ef1ff00c7b1382cb43a8a9ef9f77243bcbe047f2e2327fb0c023d9118fd04bd693f63a90240a9b41af5d51338f1c1c4f8ee9b9c06ffeacf3329516a43d8f551f0056614fdba5ca9ff377ffa0360d508a5dc5b14386dec51fe63cd1c7a2d7bd1c0076a6f50e95d57ecb32bdcf21cae29125fdb350e2908e92508f968b95fbe546e9da85cf8ab00d502c44b28c8ae20201b08f9686e54a5e562bb1191c103163888822ab250f03d51eec00e8eae01914a3a193197158314a77d5e74d92a59447a88380017c6ba4d23124d0fd6ef0f24b9982ab01c1c27f2d4390e7d308729ea40247ea3a4321ec7836b254a4fe8b639688fd4cfa3871bf0c76dc37eb7d56cdac31b6d961ff655021bba7f9e3d6e51dbc5207e5d75ce22ce953b1d439c35f389c5146013ed094d88b8f6f76246217a23f2029751e5f481807572532a3496697ed192484938875f74312f6287a87b3fde42a42b508ebf5ef5d2bfeec0541cecc373c62b7fd54d25f066aada8f6218f7dcd27f22063c30c12ba1602e58410a2ca18d7ee8d79d77cf36fed594daa09edd679f93bb9a08a3d1355532a791bfedc7f3e33cff48acc799bce372143acbac0ae3239de347480cef0217bea2c8bd29c133946b0c6cbd7e29ec9f2a8e3be357c0499ec64b71590212e4044d515757f3a0912db514da0c630ab60fc2db897df799a9396dba1c144aebea4faafac115047692d80302a9bf1332539860570e4f562c3443c67b41167e0f57f607d28721407cb17bad701e8c53595b9384a63ff27b568d6c5095522f70904102ba38c836d0aff9345e704023679eed172bd3e570974a5d425673a39567746ca4e634affabd58a045f1e3ee57e3dbe9f05250854fb2f31a28169e5db098cf2d3d3b1d90d0683911f549edddd7ef0cecb42553b5c336dfce74a69e8523acd2aed47564c2b13207ea93af7aed387d4d5f98a82d0c35e027079df57ddeb1764e8626102342b576453b13516b0c5c66c26c5b7347fb71582abcfb1da4e04097547e010ff9e7d7ba8a7e790266a98ff1522673db2625a636f76aaa222ae17d8be33e8836663d791804b0c787ed01e81097dd639e08ac5f7cfc1bad26c2c441713c305263a284260cb32da45f48ffbd40360ecf1f439f45ac2b781f2ad7bc358c1baafafdfbb2394b86e7a9193bcda51f7706d77b668002dc29350958cb30904294e6a40b7595b2b4c89911b8c5b271bced7ef30934b1c7019a4d2d7c9233a4476f75c3be2d6fcb7ea1c3bf0e5bb4778089e2e1d409af7c5ca4b392def38ad347ac6d1f7a14a6985acd9034004a9af211b8ccb12210d481871e55d330b3a9af7c233ef6258ac639ff93d927c854bdc0ffc449a5d7b187b759dc565069fefb33221e1726347dc60db73b6eed7c9d8238b22f932ee4e5ae36aa272f7c8a66ec897dfecd6bcefd15ca8bf0b52722c6796a2a60051501fc93bd305d3c01ffdf3c4813e1a2792f94f8363f314fee151aab672f75232bcc32069dfdc491b664cc734d744d8c9d71fc46971f3d0c10343f94f35a2a405d79b3c810394625efdb0981d4cb557df8c60119da3f89b60700d6c4b24436410bc02d2136a7a80bab26ca55770bbb922cb76fd7ee443418baf3613d42d31e1e0f3dddef9fc891f68b64a9d948c1cff26aa2846ed4b9e1a7b567eb3ddce05d2d72850c0642eb0e1d6b9cf3d51981a5c2ed0490b27165fb4b7ebfd4a83be5d7e0b12d83804f5e0cfcd3926a07de383e2bf732380d21b003e8529beec001583737dde580885f7cd443855dc9fbb95ddb01fe9eb715cc05fede501b3c0526a3159bb4c4ad9aacccfc7fcac2c91e94268c3885705b016abec6dd85edf932b711c4fcdeb04b3ec08ad42aff83bdd5765d7f1a7491100503e793a25e5355a61181f38b4b85311bebe030ebd1be484e41b6b3e8ad33d9f557c8409d7403f159f44585f0c64565da71772f18eff66113090052b8663e0be1f1b84f5ccf75fa618c4f4c32e4b76b4f4d860e06c264f06282f7afc829aec99693a2277053a49ec22669fceb52acb0f8f28f6b6c844a399ff1b2b69e5f6ac09c40d78719d0250d72bf1b5cf8bac48eacdd16aacd7382582896b9f9221af95ae763d44c875baddc6e18ff3f473935837d31f10ca5a2843e399697ce0e482f8e09e33d4f2591cc2c1b74d2adbcba932c111095082672acb2d2d805367fcddae3d95e15a4b959f3d198e8d5fd5aec96a35d3c6343a287bb22aa8dfb7ac7754adf48ae6ce8ac79b38ffadb06c0030ad45e6ce0135b6bcf785e9b05e08a8a09117e72effab5c68111f2312dd2cedde3ff269e90589e11a867a49c8bc7b940aa99fd01f3759f1b971b5df9acf0c71e3dda34dd72b6cc94e7e6d87760c1b2cd1aa121006cd09e386cf76ecb40b5fe75136887594f068568e4ca2dd99d02683a9b5b5dc6246dbff8741139e275d24313f13f9db1bd097834c8722fd0894f8adcd0fcd126790af11c3c88323060db25251390fed09021ca3aec3de0b5dc31be25b18fd185a9837f74869c0ad63ae6f7097ccecb843d1f1127fa473ae64e4598d8b607c03dec15b04359107fe930eed54119042a79bd98846069385bbd336eee8ab53629b786f5e2a8065e9f221612e30534dfff0e19159d0d115cb745a10703349d35348201b703ac4f7aca2552cb5988caf35baac131b3bb7ed045048d027e9802d5e280f2c65206d93ace40fbb106ad980164048cb68c7125c89c8841a4a5baaa467fa55b2391476828132325f15574cc830bbf3409e6dd795ae835e8737884a7d8f95bf02b0bb3aae7a6700f7236b518f6278ad9a614358442b69b93a94474500145d296ddf75bfed34d32daf70dcf6e7c698bbc16d3fd624edb782e99a4afcd07d01d77272ae89ccc39988c32f8f8ff2b5ce8d101ace2c46e0ba81c33564c05eae5bde85a577cb33ae57ac1bab32e3cea84e11fcd8125a4a2caa328b7feee34a38a9320e7d1db3a8c4652c1d9b3ba404d01a97432265725e0c5c67afb98134c4fd57800293bae58bff39760161984871e9fe09af88888b4dc78498dd62e7a800891f191038a8fd70f98f9e453d4eda1f294e1904dee33a4a7d69032ddd394b6d8d50ef4f9f1820ce3724fd5472cd87f47a78fe3c2f4c8d7835d126d7ef0d1eb511ee0265a3dc675ef1683238bd4ae02c74366011580af2afcc81deffda981912c8390ec6888ac7a08825c7c3b575c949feaa13fa38d56589f76896f60d1a151fa129260fb025a076094bcc1079182a0faf865c79949c9e085ed490fc117222edc4035e3bb77027eeecb05e1a4d00f98f5dcb4048705199ef60876cb39fee82c866d8ac1154275679299d060c62d4aae03d7ac2fe3d3010936b01c8c32c82d7b6a6bf2ba3345bac747e50557af5e06063f20ce156cd5399cc554737430b852f08fca28b4326456fedc7c45a7912b83cee8cb505946627b1694c3b3c69a254d8bd4294b1d088ec1461fa26d6a862cf867ae33562fe1ae89289dc3797d87a6c87eaea2e18c7c4e2e2102e861b37f69cda29148f31ec97ab1b98153e684893416be833dd4ea3c035b95c0f362465f4fb8b20da8e588a26c8ecc11f152da44e2905b949598ae94144eebecf8683f62ccae9c6225b34460a4fd7b082456ceecc87fff455e4f263373460672eafbb1d52ccb20c408af56de0630e60364c18b04ad04f96160bb93e8025ef174b0fce30a4f7af0355bb71545d18872f8a4b9307fdac3843c3db1859bfd3eab1ff4b96d9356bf26797119ee692458795aaab61a3ebcf4c1d6dc194544a067b58d75c9f88c1f66f635f5e5007e836c870a523ee1f3727b2f641d77b0eac611c319f049cc5fb9ec50abf7c0d82cdfe3197b490210dcb9ae0894e8d46fb1e2946caaa219b722fbeaa796284586e87d16567d770995ee17747f9abc350cd1ee1c748d9610c2451495b860648f9a6e3e30603230f21e3dab2bf863dd07260e15f6df8555f6dd478286c9d50efc9960751b1b7de415c1ba125238d0358fff40b86a61a35e50a400acb6c57a8fc9102f98523f414fecb336a349a35e48a0b735db0d10d6ed788a9ff5794b9bb53959282df5f84d68d80c32ebea13cdf47d84435bb1475ad2b06c46f1f4b4d42a7e7ad0baa52a4bca7f22cb60a226c8c13d7a74fe5e4251dcf7f46049cdf09971b6be46f846d6f81fb9e0380fa59ba2c4e3ac7d18ca890e1cf87c83dbaa9b171d77dede7515aa7db976cbe950164da99b1a3e9b5499ccd7205408a93b8e56b9dee32ccce48aa9cf679fcdcf15a8e125dcce73549808380c947015f61e8f2c39d1f911669ebddba7677b38bc6260a31cceb694d11164cfd693fd30daaa646c79b13b4a90853d55260096d52e1bd5731cde8a363d36d202de027ab2bd124e8aa8ca3d8cb03006a85b18f372b6635c3b20bbb6234c58d835b88a8c40534c555068ac5da087b2aabe318cdcd37d732fd968dd666cce9ecb7c17f140fa2ab0a8cdd361771b6c2fb8876bb3d6c2e7f784c70715cddf20a5e239ed72121c3ddd64e1adfc48a0ca4d3928111d20bc9e1e2b91dcef7dd925b56217093a85f82d92dc474172321544a4948ce15e691dfec7f1d94aea02c2de5672e663f05e0fd83d5af55e8b5a48718ba9ece1b120f2fac55776d308e0709d918caa37df56ac55c162706d0705554aa9940f9eb4a926ee810f346c98c2e53d8f665aca7a527cc6209e7ca887e66327acd650abbd898dfdf67369306fadd0ba047257a6ebd917ff808856996d5051c5d2af1611f124fb4d82b11d7273de8644bc1eff1c0119bad1a037686d716a8613d682d81690033e4fe796e964c312c8fca948a57dda29d0d2d8a55a1f69be45ae3d439f5adad61452d80776700fa48922cb2903e361d7b1804871c88156fc564b276b71737904e1c7c7c4a7e1f37d500dcbe23f40c2e3c630f8333efda97b1541725483bb8a103ad85acfb733a38fa9e429ad75df42fa38c34b296edd4a44c2fe6f5d825cdc075c9891e37456417acabec1859a7c9297c925722ddd2b135d9fad375d31faf9349acf5884c0c0a7686882b08299823e0b7d9962a182c56aa89060399e57f91adcf647f56d8100ed9c7c753a8903ae74a5f88fd63973e14fd15af9dd2f28710efe3990a4067a39468e83c5b6f97fdc83e8aca1dcc3c3d305f9731965526368108d80a2f05a772382507412f59c07dcae26d6da05e708240e09e491a9054856655cd62ebc0e0b6e0cdb3db38b4ff32a434db3be6ef7c7dc5badb394286658b3873fb2b2714079e44055597147ac7036eb69c9070c78a35b4c6a12edffbbf4c51b5f08fca8c029dffaea51fb68a1bde87d64a63b73873c1aa53f982ef0f7c9b4ce1401abb0db24bb1ca9b6ec80eac781e293de995231837413ee8c32d3b0e57a0c7b1c505c5c0a8816b1428987e591c1d9b2c0fddbb622360dac5a0d3c8431d5b24a3dc24a2a0a2f6bd22c6815f67db2e26a58489a19aeb93554cb311ad63eb6aa3ee1b5483e7e2f7250fd7b72d1d4cc041d4a984e886a304987b1c45e689c6fdb02f548f09caaf7cc97e7abf41b0f27cdbee1601afbfdb0b724f809a5d1253a8e176e6a9afe5e4fe33d38f564e5189e8463bdad8bff147fd6ec80cf179951005d46c9bc1f5e8f53ebf02e38d76f5d18e763bf7d8d32f0b316061a4daf4c9c6a2a7d940c814473c3d1618d9a55ea43eb20f36a5ae85c4b53be89a99755d2ea7ceacad04a4f9e47cd3638e5b0f010f7b3acde5e5c2f50a853238f1c6d8dbc387d6c5ea0c2cbc75e7e6b43dafc1143ab42ade264476bbea15d97b0cb6dd77334624483a3b406a66b3673d330b4c9dd08aa7dcaba2125f0ccc7011f32f6227bdaf0ca9827a9aac05eb17ecb87d44fd3d56bb481142c477fe32cd0d35f4eedb2d17adc22516b8b9582a8e14cf43be7e4d58604c39b3da1996e1b0196098696b709dc57b22f6670d223bfef08803e3c70276b6939a51d050d056caaeba2983bfb57b53f049658a89308ec1e14a6d527913666bfd67c4cd5038f8a66bf0ff54706c262691a614de65acdf327861e4d00323f5cec6c32cd8ff976ea68fda7aebcec56de2dc2afc83b6bdf9d18c626a7b3a77bd54515182cccaf1d53cbd1a7cb43d53ffbb94b3d06f2c7f445c994fb4ff4ebcf6eab7b01d10ffe2cc90db0c8902a5240e9969a6677c25dd3d8c86df8c22c57987348e5e2987a0475c9332001364c5057e30fb227e5e59cc5928079d0ed301d3bc99a5e4b98a01c5160b66fb5b2193c13df4a6bc2407528ce5cb5a8e6a1b1d388c5aa5cae4e20c4a720b677c65f5b4a5cc1b27550eb568996c9b881e378c621fdd5084e93a479705ba9185362eac8d2df6f4c4add5c4dfa6ed8475d2352f6c3f9558162f94b169c81fff2ee2c5c91eb3f079b26da9437b7929ce17ac8e7e664ffaa317474473fbb46b8475fc089c496c33660dafd282fac7bcc4e6af08492d6838577d7e8ab8357bb9fff6b828cbd6575b84c649f418b686e0fdb58f5fe477bd791014bb2174518711caea908c12321786a6956ab4710966d8b5f3265b37bf0b97d2d0f64aa267b96344a3d7b386ce6bfa67b8d757697e346099b90f5353dc59ac90c6d9bfb85534479af2c253f08cedf972b5e2c2dd72cef3d1d6daf0d63f5ec9151edf7d4d34bddfba3b336184ecb4b982f70267bbf9c6ccda095a570b10107664f0e30bac6f09c1831fd212037f73b9c61e350b3b519ceef2190f3ef6aa928dd260fb2771616788e8c8efc3b08e0b38924fca5b5bc6edc2cd27f1067711a2a7f20ab61ad68d8a85c3fe791ae23b84ff03966995cdd0738edb2073458de74277356b5a8ac34b390d13b108c0a3b1f646b163a393c9036ba3d960fffa42e62ce5e65c88622488d3434341b5368add2e66596c2a8193a8f365aa4e514abd6766237912a59fbeb13658ab2604b65524bb314c4f3afcc00391bf36aac81515a8f7ce72c5ddfdb97edcd12c7eb51c4503131f4d89dd3d38c5fcb28bbd5ce4a5c0aebdd61ad5950c18b05a2fec5e6abcb75b66dec107c6c98af30bac8b7f2a0522467c789e6e5d52dc276eac69a4c0ae66b81ca0b084669d943d23686e4b69f56c79e08f4d969755ca1dc030e291ce2004f77f95d957aa721125e1257f8703369d670049f8a2116e292d1a9c4ccf98d9ac67275b2dee1e32ede31e34bbe371109c701a70c35cec160106052aac358536749d008c9eafc29f17f88544aaca45c06af62f350e5dd904ab98d9ddbded59f921885ed1bac7b66dfae6905e569021d83e5c892a34d361f202d0528e55c7b777213e58eaebb58959c4b01a1913b640d75e232b09f61596284b61aa088bdcf30da9aaf77e43ef3935f1593a7f02821cd5a080a09f17b262cdee3d1052149bae19bbcfa4aa17c4003bb55c12f0cff89b9a3c4e010e06938da7bd5fe91f5c564363f2bbc7d9b3f10497d08e973f5009b84444cb0d571f87900d98de75ee15d373881f4bd68d3160c02101b8c691c08c392bccf11266ee5acbc7f03dd0b8600049686d078932d96f2f0e496aa4247c24cb0e0a51ac4eac98cfda26509f7724041e51bc5f50a58bf645332e03bfb7b0a78c98b0edd65255c55e56c3f567c66816e86163bbf425c0ed6d4f03d49e9ef52396cddaa4260856c72f29e2435122462f7872ceb805f63d0abea70b7bd95787ef4a8f35a996a9b6f2d8fc1f9a6454374f18e4249919fee624804677790063de68d22aa2e17f9e63157b2f7a684d90a8b887f85b9823db3b57f206d11df64d56272864db5abc37b84d269c3903946568e121ebd941123485c7f6c537446e96e31a7a863bfe3c270475ebe817cbf0b5580effe86abf0de02a38104dda3aaea2a0240e8aa33b57039aa245f464fe41c90fbc2d3ed5f6294fb003c51733055172baa7300984aeba3ebe36d21d93aeae097a582931c8ff66750c534659e739bfae4a8d633ba7f5b2ae44f86f0171a1b808344ebbb9bf10c07c208cbc05276b527cb8a28d44b5bfea819689b8d55087bba45c15594dbbf807e2df19f9626c24f967102f9ff26d6ca65f32b1d729f7c7d7504b3d61cb90309c1c947a6aea872648b5a26b961668f638bf40a406288651db36c0372abe2c5f2d7ebb818c655b3ff992e2919febba1096eef5907fce5daa4e43bb833a722859ef53385abaed56bb479c5a26c41b2636e414a0b1da7c84f4b7afd500dbb18d898fc61d335b369e2ff43cb03414ceedd544b2a990800b13de2b44da1459eae3c555d27d6019b4d22aada664213e80a52f8d7226976829f3c6aa26ee5b98a031fd28ef8a33aa1b8f6b0451d7099a7a46b1061de8d1de2500be4ea273c7e08023a06c65f7a787d44922cac0ddfee8a59ef833dcc0f8f5e871bcead1918ccb68fc808529be60d46edec1198f6db2b75ae199b0aedd5f072d4cf985b96926d354ba80ccc992ca82fe33c2ebadc4bd0f196a5b03a8cd2f82d5089615718c8f5d82685f6f8b3ff796f1410d7b34a7b22e7b8180101751ad5b564aa0a901b14141d41d255d54c319a061bf2c0034324531637f5986e98976e85cc0267bebfe387f6cc06f35386adbf8ac0904cd499dbc41841dc27dce6b73dd97f7b9fb4f20797416b97aa07b6ca0ddb19303ff905b80531ba0375eed2ac6089f0c0f358ecb5ef5eec4a4a4a3ba8518963457a326185d46798f8253b9a3270469020893d2bee71ea6fffbbe46715f34fb56fb18bc0db3f7f9a14f0353f50852a4a9647c459eba2806d1afe995aecad8c3f6b05c84d80219609f25ae8eaad2ecdd5da13a9fae0c36ddfeb5941aa806a888fff62e298a06fdd051fe89a43d8562493f9f3173b56e933fc914e21472482793d9d862ea9ca2cae004399849d8bdf539c8fd9dd45d897970d4f0d8700456e4303c9ad194172df93cdda1ddf73ef63dfe7853e5ed70d361fc323fe39d757c4e82aede0eba453fa9f42254ede0fca7ca9ecbaf55ff1107d3563861a5bd41586e34f01f1506b6dde6f4ce4774f10593f2f2cd1698c08bda81384fcf896687763f06e4534f1d7887af74fdc07d5e34fd7770944aeddea65fa7e51572f5af3c69605b2d20d161ada92447aa18d3d1d85050a288d7938c6a9ba2a6c398681ccb7155fc091d9442d1ce957263cc5fd65caa8c3d51da531c464c373b81ee524f31161194f4dc3e6c100801c8325eac697f6eaa7a16ee70c790ab0dd515461c5f9195cb57273b9947722dd023d3e5a20e96b24e168c0d7939e0438fd502dc591fa49b4ccd7dec0952e2fd708238834120860d6f62ac720bbe26b743b58655417b3f7b2d85865ffa955a7680134b2884f73756e7c4eeb39bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
