<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6438d8bf209aa770451c1f5bb5f3a22024f759f2435120457884401bb0b6adef0deb3415303ce9fff83da87d06f621fa30a61b78437b91cb67fd4118d65b41c5866bfb434c49cc94b0b79f77596d32a14aaf1de03f60b25145a5610bf718afa964563a96283ceff3446b65a777102bfadefdbe39f0c13156549354b4d2e67a299425afe947aff27641225dff98650ac5f10e2a1c988ee7181aa0fd4b1fa4219dee4b74f91da1a063005bc89e1eda2fe17ab5867cbe37ba3b75ba19ae1f0980bb0391205ef1f8fb4b24fb8a463b4f561273ac3cffc7474a61b5e530f82d2dbeb77f8c1e61b2eaa3be2cdfa691e506c3e62486512b6144059f988135e13d3fd6f8f5a1acd079f08bf75965ac6cdce31bf18486a9a8b6429f744418fa113e16ad77297c282ded1c7caf1177748c5c80f2b423ebf22714c979e9a3643b6a05ab90c62f10efe075cf2a331f33302de1c3704136fc71afef10383d6929e5c4b2f8c94ed94083fa545c424354a22489a3e7e0c21aa27b93217a22a6ab6de8ffa6acc2a2457aec9183fc861309919eb8f4bf4921c0a199d391217f8861dc972ee7e6e13ca5147ed812f2b1c36b1ca215195a538148cceae727fed1218f8f4ee7405a9cba5a54282ba85fd8bea6b8837a85205cfc50004abf3f76376e59d4062cb498bdd622b3ec6ef0656e1b22e9ed3d99f741f17ea5e650df9bc9d5aea36feee7e0aca3d8d7c50e9751242cd820caf5dbe12b757673dbfb2d1e81932f54e93dcfcf9c4e6402789bfa9d7dfab9e3f5067d260d38843ecc74d8c2841cc645181d287fe431e7d98fb55fb2ff714846dac6cbb1ad1e43451a77191a57090c990ad87938f9801ab3bc1495d6469e68446881dfaf742e184d6bb57c107115f4713e91c8f81381265907482ea7d7194b0cb0f30c8e2d180aa905e378030741d159762d45836ca46a04598cb681872d08246226409d0eb707c1ef46885f1d62c24e7083e027be59a448147f89dcd95eaa9359927e4b7b84b0000d9c54c2395270a9b663051538a1641ae03b9a6b8afdf7aea64c9e8990e194319db9522f08f7abb4a5222121189a6ea79120488c87014eeb2478999e4f2e26e7ccecf0583c7a83c5e992792f1d087b6555dbedc4fcd251ba3e0c83c040782c4c542e11c469f3bec70a4911bdcc0ee51804d609f7bc2a468b5bb13370d02b081983f947ea26702aae5377a8723cab84f2a89ca95fa3bf8fde93959ea8a5d00dcf5a32a093b2fbbc8fb319cf415e308a74632534e035afd787259d8d32abc6ca64b83cc25135771672dec775acfc97c3a54f759e8b937ec2f5d7c75fd9ed795f67dca1e12bc0d73e25cc0aae781ac63067d96bca0159d922760850fb3136615add24ec9d047db70fcd63f04ca42640a1d773cd4e95a1968177c1a50d25361ad9eb8ebbcfec4fd50b40c13906b2018d293003bd07d4df4431891c88d261e20f6d3fb314611134f172bb734cbd32c8cde57d39fbe88ec229af4931b8b07330d48c6dc155cab5fae1e874104bc590a35c1d068b59c4fd39132782fce2599397cdf665ec148c09e888b4e3d379faa09c06cb06eb2905e4a1bd0ccd1a9874fbed971af750a6b359cba2368574900a484c5e90d83b079ed5b70d61d1a5640f7adcb22f2c582a1d7befbfcad2d2a3a288c942d5c7214b7484750a9660f0b1d69063284e00e50fe50e469d7dcb3412c61230ce1942f7a84973fae4ea1b26ad4c009e038ec352a2e297f2155d9b059e1e33bd3773ef6ce25e5983ac1c4135d803935f6fdc1cb993b23aa74df9bdba1d917771320ba67fe6cd4b97ce6abb175a1adbf13576cb163fe4d19d04b776c06f3b3220aebd9f217d070705713db7bbd5e01ec04b0bfb11840bb6eca511aceb0013bfcfb682c56523cfff0edf3fdf97f5f52c66bd42de493a61c06248ed655da82536ac4090283b6b1487d3efc83d6344f720a8a1a232ded04af7f11d42e7859e203c7dd4f192120b5488200bedd5066aa7ed354b6c4c4fed6f5a22583c2912a31c79d9ed465f80ba14b386c325abf12a8544b467388a0f7c564038bc1ff91683e585611a3b7fa3a521c4713c56f7a4117b8dcf3672499441d4c5e969a14d52cbd83f5d47823bf6d43db3ccd6f0448c5ae8043a9a8204078b372f8bb24be7c806d6a3d295b9948f360cdc0a7e8f3d52f3003d93773376e9181b2df7ce7890e4f7b165671643380decd8b283e5fa0f5ae0f0d98d37346bc7f1eafed88769e06585e93f7f1a2911af5e7dbb46a16cbeb902f9f482c0946d68600cea8b3b03ebe82b695f99b139499468d6b1a8a68b8771785c84493decb0db9aaca638ff0bb395136f837ad6367f6c7f8751e1c47e9133806f5c48caeeb93524b5d55a19c333ea86a1718db076aefe5c6ba11fc6f1cb4f565bdeb728b0a54c0b42d3d0ce19a05d5e582607cd3fce533c1e7dae1697cf00f48173719b030075a9ccce3671903b14f4acbb8dd42629a4a9a72a0ff333c2ec5cd5c1bfec11b3ce9ec34d94510c51868e596da337ad61a9e3b03c38053123ec621e18c21ad8b3b29efa3fd9ad868d39bac13e28dfd48c9d0ca1700e5cb30eb3fea5666a0c918cde1637f4e3b5023caf6d90ecfeec0cc4cb9e48d474a55b28f5efce17dfb98e3711c3e447f2752e2cd9a248fdb1e8169a281f97b24a4503cb4fc1e46e09072b4b2fa189e2fb20f1210554262b37d31706115264fdbdf787f959552fea82de97f5ac78749eee15d1f444c3b1fa40bedaa26389ebef7552df6ee2822c013ac1b8a080f0dc2d7887839b241b8987bf60f154f050061836147f2f90651429c3f112734bd48076d22bbde46b121cad472b925898408dca12945d71a30cff6c516a7e0a4446c0c7418cf452443b0115ad972ffa78d4d1b485dcda9beb70788c23f43be18dada02d25b55954c54a0e551ae3907842fa14b3d036b9ede7e1035c5d6cf7e3251cf8f962f3e21455e0b96d978bfa4ac53796b306cdba65274a1651659cbbe9eb3fab0ab43163c4d6ac6daa2839430af995175b106ac15935d2a83ee7844989e6dd8428fb4a39bd224fb60a2c22b6b9060ac21f810eaeadecb3397011621c3f43d89f272de1933a54cba5e5d91a57420687ce3409d9ace4d89dfee0e6258552bed9bc0c44389ad5748d15a95590cb1bd2313e24b14751123eec92ad9287daaa89584e6a6463d493b1b61ad56a586b87713177f0f58307a9777e371c73918c7c4fffd1920b10279a101d3bae0fea2dad25dd915bc326d6d20aaafee3b0335cdfd49ecb883e75f5278742d184282844764845437d7a72fc13e851258bb17a4662653deb619dd21e604b9c84de8bb9f40b904dff9170d39bb08383aa4a763352a275d3cd19fbd38e5e37b3a2bd48aa8e105bea85a32274c51cd1399a3e952597b247cd5d4a788393d3ff8e63f43cf831c5d6b608017493875e39190dc1f4f9d0d26f23c98aba6cd6677dc0640de069761a2f9a329bbcdabb85d01f4d61d6cd5f13c2e8efc129829af5a4b9e6291798c1c3a71bdf72186321b951548b597526261831240e839eb5c8fa1ebeef24b1469d24ddc9ee9c8539274c407042c4ec2b732b266425aeda285865979b0b0673607fc836e417f6353966277277637f2e0501730b0b557fc5713e6a3fbd2b1248678219a0d59e0659f2cbd00965e7466d6d0f74ae2d13e0a0ffea44d3fada06f6d2a8cf22ab444b95c7b5e8c21529407bf6fdbac788385a3fd405ca0848240bea42ccf979f4ada4cbbdc290c8c5deec0218d97c3b95c310cf4de3507eb228007b158663ad1c4264d05acce4854cdc8ffd6d9daa62afa6cbfc35acee52d501a8ccc8926402daca84b6fdb199fa89ac2c9cb92aa8f3a30b3cf30d6d3e7dab11ef8717240595cb5a224b0f009dcbf25c8c8cb77f2e38440d96230ea1e7f4b099b4b3eb5aef04af014392700b83082932b80efbb98a974e5cd58c7d1579d6d7e62565638ab8d0e32f8209b492702c72455aa7975e18bdaf9cff54dac9ffd3fd25d15f6ccc9be810d6ca7cb6ed3701622df32ff9704bbcc905a6072596f495f6ff161199bd9ee6d3ec447b96e5917b95e6545ccc99eded9f945b073dafcd3d87c036ad0d516311f2945ba9931793a0f7e9755cdcaa6de46ff75b94034115f33f8b68f2e38af4849e60c4d3dd67c256932abd475371a0208061e2a3fdc23c4b07754eed86987cc0195607fad3d67fedfd5672ca18ea278b9d17f16ab42eda442729fcea52313b3bea625bcedad0e4dc1c3ca8c2cfd80de1bdf51126f50983d2c47a0704eb6bd84a713697ddedfaa7c5e7d38a43eac93dbeab9d13528049c9dd801618c61a5dd8d2a2e5d97a5b530d220eca1363df1bbef72202308f5c360019c48675a54865c6fe57fdd05d4310084931c133d7a44d7267b1784fe21117c7dc9a8aaa04b4122199df35134cdb2158f1ea9e87f4ecdcffe32643b589fdf66285fdf406646094d92ccc221d6ff0a21447689b865cc332d5c0048d8ed56ddf689e13244165084c874d3b3997051da086a5fb44eff38238f623b7b6d8a68bd76241ccac5e4127c04af62843905693e1e3d141f26d9bd1dcdb5c2cf7a4851cf5c427d8bf6aef543e54c20bc5fb746ade8bb4298be67612efd69418537edb386b9928c6513f3b9bfadca5566962fd9b614df9dd4299ea7fba0feedaecb14949d36f53772f17f114e50f79c63d9ce48e8b58a1aa3255bf9d5bc7b0e193d8184d412b2ff212e5c0bf7c585262f70ff656e0b136d89540fb7740a06d0e6995d6b1a9ebac731a2dc59502576f30f1438b1046f85400bc0783b2030ada233086a013d7e9597bfae57823d1d8216a7a24962469959c24323d6660d09059e6616b72a670ba52b9ef5ac0ce365d675e4095e0812abd86ee8a871e8db490143b7a9bd99c410825957cebea19a420966e65b5dfc0e3757adf468bb5cb4b4513fac4e046072827d0af6c56c85767954719458d5b000c07a9027232b6584c8f767bf6ab2adaab82a5e46b16c62e36e02389b836c6fe86d03c601177632329db92d7a12d4178c0b711ef3587eaf7085f0548b8bebf5c7c6c5d1ceb2c1e416e1f8238b37c86bec0fb7a62ed510b0522fbd54d5e1d9e0a3b235c53139b8985c962978b300c9cc053e7f7440a1c840d9ca982c8fcc1210caa3f36b84878fd3182664e7aced1fee16ebe67b76b1ea42bee0a62fdd6711c62a8c0b84f3cba520fe5e8565bf3238bf3194e075e44a96dc2880fd1e4e41f85cdcacd568545ba5d7d19bf6f96c93be828b0665fce2d5e4e9bc8db2b5f3750d4c3d89f3d224ae1e8519f88f0d803004f2d1da491c4d05a33376ddcf341dd08ea0aacc5b601e67578b52d79a0168ab67d675885caa2d104095575c64256deb34e2c9e5787a99acd31ca0bf9df06013556c9254db7d93261ab1d8e6aa4721e5a1479173fe45591d27e593ded66d6998b50f21b6aa48ded537f2cef0700308adc4bb26efdf2a042fa83107eefe38234860fb8fbb7d51901b773377d16dc09df6679ffcebc78805201635af161efb941141963fb6929f4d92344328226d49c0aa56f04ec1204db906b1a1de97b9228f90bfcddec4af81af6eee791f85f0d5bca8eb6471a235abd01d9fbfef12151c3d5194b265d845194b1252a55a27f488730b36ab0cd6f19fc25c5b2e8e85077c9b030b88fcbaf7f65f4b3ed3f1656f146c4e2caf338e8d94208893ad38cd6f9a678e1cdfdef9d0d5e8bd735af96d4a03bf42aad9c50d9fb009edfa4af31d180b298b43138efc03cd83984e0ff3558a5ab65319c4b78ee4b23390d7a526a9dc3f4f06f006a3e38413d4a326eb8ea2dbb11668363457ab87b42ec6da9c5f1c93592cd2da53c5d18d78a49aa035559bfa7f06951945d1c19453c1328ae468bfafa17046e573a8155a51683a70b22553229cb16cdb796db9d40f86e02a20a91a4e637ceec59727c0dc5aabe80eb00397e443e950d17d47cb2bf276f4b0a666ef1867bf7aa1e5edbbd4bd8f304921904ac1ebc8a60cd72fa7fc4172fac635a0cb7058898bb18951724ee3fb52269944381c6c0d9a1936a84eb0882fb4326ceea2e633d6ace396d98902d59b660a844e71557a1d3d2b680ec81c816eed0b34c6ee5ace8c6c056f9549739ab6a36c17f07640cc64825f85cc1dd1f45a2ba67f87214bd0e35881ecf0d4c1ab1c49a5a812675521ff7f2a159095c5b667e6e4ad11ccc7098d2b880c7babbd767ee810d79858ec5c70fdd75df8eee83a99fe1afd5ba3719ad154781af762a4bd3c31a79410a2569d5dd586415de9eedd99dbeb93bda87c4c3395ca55b849e085c0619d160b80ecc6bd9be184d2fe0b05cb887deb7a172c04cfbc31242fe7889586fb6fbdbecc58f3120904609513a3ec7a6266187a260731dab1f7abd761d68ba81db6d2f7e3b00e49bb21846d93602decc6d1efeb4244a5be8f3898fd5da308f9a7a6923e2ff0f8711815dfe976b109448b455c70b67a91bba6a7c5acb6dd7c570bfd870cf127347d0a261875fa4f88fa1cb55a22d20893aee585dbd11ec492b8fdc25d6924f44a2b74c4ea9cb34de86b077b8adbe793ef81393a6b0e6bc3346fd5aab93f455a4a9fa88ab254fa99a674a17354272da49251a4dac4270783bea4e3900a8258d291c69789990a9213709905df57ed583ffb4b69da25ca8db9e7985f709485630bc7cdbc67899040e639099b076c2d48de560fb1a8cd19f5c04a2dc366c5db4e404b07f97a8d8449b54f86bd16955e615bf682c57e69976f8e80e1b90f315ab8272d83a9fb94867f4a412fafd5ca91d146ef474c27f5a4e89189258557b9f0ee54716571541094cebe81265fa083517b67fa9af482ffa401c53ebd0b70c83a742f9d050715fe77d9ef1de0fe9f5013b2f3ac57c89839bf6c4283de5e0cf2495e37ec34756e52f6c526923d5208b5d3feaea9cb6943a532a42500c0a005caab501883eb156e65bc02686497d44080fadb6e781a6d4919a6b504420e1efaae187c4097b989603face365b35e9ace3217a39b4514bfbc8797a9d352a5c1553aab9ca5ad101a43ef772a4476ffde49d7993d6ff3dcdbf483a78f173f58d612185e99b9805ccc8ed39e490128824a67a775114e38cfd14e57bf74aa074f0e5b8dbbf3b494c0304c8b50b84a41f20ad9e80006613387b1dfa3675c1a02e8b8072de26152fe0b1cdd9a7b208d98b1b04d45525af145ef13f64680445a71597382478ad61c67e5aaa5e7933d34c8e28faa787fafc41685117be72577fefcd9b0d9066218c11d172cb0ea51f6f48833484a5adf69d1b70bcc1e3baaa8223137ed55c786d67e43857c73e0267c4fd79b8110dab928773c6a6b8383c682f8906131893e4d14837a9b947645114eeddab9dd9b099af13715c4a97a2cb0d65778598663ab4877b12dea28ab91e1cfd7f80c66872e11c53837ae29140a206f8486884ea6a6118f33fb8332f26bfd09739efef3d1d71ba5a27deed31f48b7e374752969e37769f9c477e01a5df212bd70c191400c589ced0cfef70149d604d7d5f556ea23e760aea43a2de2a77e45995b8400da5c207e392234edc8b3a58e3dc84b3b912f26510c984b14e3193d853ebcf21c4a20688913502049000727b87f0347b75b733071589237fe716313e60262cf1fa81ca2e3bec1dc2d78ffc1a11648bb23f246374ceae7b09f35b2dab226c0b24b891bbd4897cec67a178c76dcc547f374b3acf57c30534573d1365fe497a7c73c8738f772588b6e8a490b8e1519a4f809179c024ee851073f1b89543c3ac56055850bc52347646d5033f4a31c78a3b6ff5e01316c0bbaa698c9e1133c92c5038af7a649ec55540eeec38406bb565f94a758a2411bef5783c4325a3e4d62afdc2207029d12f0c01a0be92798246c4eaa6e869c676bbfa361e13142a5da7ec385f5aa4dc90e2c3170405b099474935d8ee8ff2febe2c0be25373518981ced157f79186c6c0ecac4cd4bfd45be3977fc158ac80f7c9fe0e80c3be7510520ae85b3f34d86b72e93e9b50ea3ebd498b59893ed4a46c9263adb80774f9d1ea3756619d08715c114522e04dfab935feccfa218b03a2cfcb57c31a3870c20071fc0362098232617ec1ce60ea25c1952bdedb624ab2854beb21b42576fe854222c83f31a4ebf34069670cb5a31bd27de8ca5887a1ccc2decc1cc44385ca880bd7a77061d01032132085d53e60b49407b2d2f7485075c633ae83bfd9e81a1bc74a0e1766cbe5b225412fa05cf4f5c648f243ea8c0f9a39049a12dbf5a918675705828bd82ad7716db66a104c60c90d425a33ee6389e34b8add317e179d6d7e9429a481d5b4efc7895624dee7cb072e724bd3973db477e54e99d74c98bdf066f06610b30024f6cda5d3bf7051f07e8fb1198d053190bba44502bd9e336db1cf48682543499468a715b9ffacd1a3f7f009ad440c0d3756de6ae5c08d6ca928082e6404327fc15e8a12681d15445907ed5597cdff483a003db96846a9172d5c2ad78ccc99db2f5b92a80d62da85d7d22fe5c375d52fcf93fc8c687ea3d232107c0e8ccdeb5ef553e3fe43fbed6fad978a9abf562f4f9129d42d6bd74782b5d6ec71a14c5a22b5ab9d974536382c62ec2e7776716b2e4c16e5702199b675558173241ddc60dbc4064e2d304267e2b2dbdfca0d918574c52fa2e438c63e008d2f6522a479bfa81b76161607d41244ae7e19beb9c1e989eed6b72be5ad1a2b7abfb77b8e0caad558bddfa565fd1753d865d01c6d787bcaf2bfcf60128174a2c9631b4ef0174db83d6027043ca6fb6c2405a84a2c71a9eecaba331a0f690042e9f868038d9cddb2be696bd8c0fb892f1e86f0473cb2846c2be06d7f1f4fd39331f4663d324782266ee327698f5ec9413ff3a5af7bc333f06307c0c4639bf9ce61f023fe96f8e384bd71bc393c9fec4ded5b3d72a2257fc0c3a7e64d4e1b34d3bce75d8133107df9d8b321ee3b18ee843531eace5642ee9a40ca3b12dfc561bf0fe63290c4b12b3905dea219bbf69502c333c34932e6fb8a22f48078baf598b5303dceb27bffa03e1d99bd54353279f13363a78f295c8585e628164e84e6aaf07824294eaf655bb76c9cd9799202c092569f2e9d1594de029e05ee77b138c88a737bcec71ed9b78af7ebeccde2ed70d88d3670a800c8333ccf1b37c70ffd56647cfe1f31e3a0d228c625a258ea8d17edb3173e640c237f314e7e5f0ae9a29295c3e1b88e268571f9525034496ce74d356929524200b15d1d75dc95aa05151657f07c8b9d25e0f636b29828f7bac1c43f3016f7512f3e5d85a9412fe05ec3b9c6513391825932d41b028c87876006ab39dd3ee55e65c44ade08655eb34c4198d5fe9bf7b4bcd25685d57200e7a32dbdd14958c9b0b3f9189047e4e0536a4ec10d693f1df9e0ac92e2cb49510e1dece9a0191d6999aab7711b25b2adaa455acccfe53c072995fccc974e93df1298db10103dbf6c9d62e9e06c100a4a57ee9dbe96f0542ddd269784ff2f5af9a48263ea64d8f4b0a7276bfe115cfd52a7b48fb2da7ffd9b6272ab23bddee1a21a12d7c0575ba96c3c73e9bdafce2d3df61b07500599ea656372437f32338d6e39e029ce85cdcca98150b9cfa4afbb851d6a9e0abf8ed7afa23c7d63009000bdb285d5d17e8c6b061d49c1cca47f3032fab6102d84c0281c72b642da24ae5b070898964c3cc1a94e9babbd5238cb986675d8f55bc8b56a75fb7b52cbaaeeeb7d6b42c228170ba2d03af56bb7bbd4286862fd0336ab4d71909978ac7ff226dfc8ee3021c985cc4b8e1f3a19917308549f29705fb7fda11bf3d79ed27c3f450a4616a0d5e78cb9a9a516b07d6b237e3cf713e29d8ee85a87381b180341475276e3c3745231e526c33dc50b5532dbce479d110bb175cea2d41c6da839403f18415f3a4efdc50f9237b78681e2cf2f0c65ce89febadd869899000a8645cefc3dfc70c344e459a9a4e98a11e6cd8ed91bb75e0b1b577e7b673b6aff306a9d54d34c302f34d31b12796f671b83bf4dbdc9beeecc61eae61caa3a303603701d7a47f7ada113e30aa9e5469d1c5fe89d72df160d0f7c144e44d2e05f20ca5b4187de4a669a343d91b6133fd9f65e5481ff959402afc6b8bd5a3efe615827df61c2992fdd4459a7516d29b381d9ecc54ce819c7b5549fe1fd43f5e11bc51d13d6b3c2f5dc78ecc02960ade51ea9e1c8524e41975681afd9341e34ac6d2810aa06e7b15130170017896ba96fcda257a792f5919e153ec9b67dbf4798286b2aa74d69b62481701d061d388b282800501e8713cd0f95f0e8fac001caf93e70b3434ff4234e7861e92275098cf09fbeda0458722975b2caec26c650c4da01f46b58545274100cd8473bfcb52bd12a24741c52f8d1c2d6e3754c7f5ab9af3dad457f47d2adbd14b682aa28341ac5c1a2a719b195c673270b2e3f13d4b5b99f80570b78b1095b3ed643d704808b47b7b45a66804eeeaefba51193bb6559cffb5deb6dc0cd7a3161ba6ed00e0ac4354a67232a326a49b038b0783d5805544533550b0e262ae10c0c4e5d5e22eba638b45564dc8340561436899c7a468321b83f22b837d5df2b677e88b5a2a22b19d540031236cbf7e9a045f56daee83e50020889b053a6224da663425514d9f7739076bd155ec5c60fcbe31645fdc38f59ec5f405e4068bea0813a6d3d77af308516700cfc05fef8fb1c29cd9c650a3ff11cc3f6ce338e8458f7952f100716e45edd1e5a278852b989c68ee7e9041150677f7a9df528b53bc79ea082004406674838563cd988a512f6b78076c8f1c66f1be5b66ac74cd5d0c39401702e52264b4f197256c6f32e6210e33ab7796482ef13f0fcce760d8696ac5a42d8d05b02497b9b341b0d873eec9234e1c43d6861d9fd7384f8077dbb29318e1bda17a634757c834f5c22eb35df78f8d5840ddb19da73275b143605b89d9298d7a26f6f8edb184a2949013928307a4e44e27ef022cf32955914c51cfd19076f4ccd4e669fdab0fdecd2626282542fa4725cca1fa5aa807bad9c7597adebfe18d2109561d314bef0558a0b55a25986a4fc313a90657c40064bc3244ebf9ef752979c555948d1f0c8fcea871c5f3c1753f7795ff59c001c4f150b29bce00cafa37cfceada425a96b69b4eddea8e897439e7db1b1cb1ca3442aebc3a19edf7375c3024da2d962d254b40eb06435b93b290b53f7be4dc6471b92b67f12146461692e07d250de57f20c77470acff8ccef73972f36603485d0347b7ec4ae2af09a68c62298de75e0b1a97d2a6502496cefb32deceeac4b6ab7ebf9e10f029d4e6754fd5f2fe734b5b6f2c56d4936ec50fa825a5598b3ac053c8b6318b2515453a9770899c0ebd61c4b712afe6f2c9e632d2652ded5535a1534286048ece011a8337c2a2c967fc0762308304b75b3016c7ae0b9e7350041fd5008db430c9ca85dbb62941be527205004176616646675f45b858edd4445e681d530366a01922d4a6f1b8e0e54fe5da566302307d5d82022d8f809fd821f87c9a7f05dd92a3e6b0eb2c24c0d0fdcf6564190cfdd9b5b509bc6ea3081b7b082c9b29ed16f2ffb2d7132b31978dfa4b646b58e696df4292e3fce64651d19fc4ebaaba4c41d5e01b779320c280c14b6cee80d719c3b1a06df864dca55cbc136d3cd5be9e2ce9da91df9f69970fb8010099f1f004df16e1e67a9df442bbb912791aac1eee12e5386c6847471f3a86c6474efb4dded8c028bfe12808479e3631ebd84e2fbc426463907cbaade1097f28bb4390319aa4531aaaef9f07afa58a54a2c20ca21fdc9c8247965548ee6eaf41f66df848746d240cd1198a63eda36b78baafd23ffcd63bb3c4390030aff9312ee1f3d1e9b484b685ce0efd1aec2a0f4038d723879b8dcdc8af26676cf8608709692e8fb4d429dbb1642293dd63f20af25542df41179acad6a9abea016e47ec63bc8e461656e0ed9f52f902acda94a49c755aaaae20fb3ab1ebd97a8ba248fc67dcd137fa4bec0671d8e8543f5cc4fac1374ceeac6fbcd2f9acba61b2d2bf72d007de60c65348a60b8187ebded83f29239c039c16393344a771b96e16f06c761e069a223cc1ed130e4425ec3fdf41af69ae0e20553226ff50aafeeaf090571d3053430cec405f5345349295ba9ae9edc705d88947111e26b48d33cceb90a96a12a85f15724b9f46f84787cb126795cd615a379d6f885b866d8062780e8bdbdc6b4a02edbe188011b687ea16c1f90175894fd0232ce228ebd99109a4209cfaaeaab935fb303ff51507c88b5d564e400805b235b65fb27ccd1b71518147e4728b9dec34d54421dcfd3e6b5e32d37218eb45a3390fd5f7af42d3387545970af8bfc22b3d46c8a71934659f1d2a7c56cdcbb6f5d16b567121586202bf44aeda2c05c8809897f3677fbb701c8d87eaad3885cea3e7bbf5eebe84d6a10c672d76b330259ccd931f52fa12f1249e8e93749421f86035491c35aee4b254501276a978287a1a3c6ddf9dd13ee4588467d9a3b35ac802004cd096c5e2230300024e20a24934cf3fdd7d4ff0cdde0c349e6be63dda421afce77517f88652f0123400b01a2662dd7e6c5fd4a71832c60adb2717c9a4f7e4321db68b3094a7d02c4d02be9611f95dcfd4555e67db3d9ddd8bf9f4c41b7c54e356c4a0148f71d47d0dbd4b6ad36447ce72a4d4e7bb1962f76a204f4752660ef11b7ecfd1d1b5f076117493abc69a21db7da8b11e7f80f403c3a772f3ae517709f11c6755123c4c9bd5a2dc00e95506ba3a745dceac61aba1ec6c37517e153292bdcfe699614d1993ebb0ba25e2b6af6e6cf8e00bd41bbe8d8a48d767c2b7a0f88f906ea8a950b4302ba490cc9b57e82e6f137d98e758a3c441b7fded1e2887a2bcb5b55f7fa1bf8c2f40ae6dacb73d51b3b9adb5bf2164745098a56486aba28f2671fbf53967d4d4fe1aaeb9018f345fb32c122dd9184345ffa2f2b59c7d426b58985b20f08dcb7a06cc831dfbf77f6fa750ccfef7d4ff7424d5b4db89ed15e752b38764dc5d3fc1bfed80192f062167f7c2635f0a7da971813b2affff7b142305b2f11cbc53d0f8ec02993b8fe2ee65b42a9e2add001b451443275de3c0bd4c82c45ceb78f77544b5d893808672979d4cae24e17b1ac82788c40b517d7a059dff0af7845ea7eece8ceaf9953e3cb44cbcc04fbeb246a79241a72af19cdf9b83b7d1b68bfad2a78d93a99f284356f8c4972acd290b50c8b57b674a7dc14c75e961925de073d7e82bd9a96ea5a2a0ccee0591c23d09c53ae2c395efaf8b0c1d731410ed9f3e6bd0515509081c4bf97a110c4e6b28be9aabf2a1e8fb3ee5722fdee800836c7bfb59b9b0c63da74a7f0f8f6ee263e06c15d27277f82a4ad8cec84bcdf874f66fbf885df91d7351b4d689f1d8447c75e0c94250dffc8ecb34a7b364c0fef179e96f2990ddb0682df12b557d297b33f58e55a4a70e861e8bb2f88d8b76ad94b52e21092534eea45f3b3d98c4c1c7806a3170024fc03b965bf44e5c0d43507142dc51160379afdcd3e3973b05b74dc5281b4437aa51c04a65580d4fffc84600e08d81bace1ba59f95dd4be1e99b68d4bbe86174a675d4bccfb8bafa47184002e64327c8a59d37768cfceaf1949d85b1f9aaf923a1cafb09f196a24ecf0f742144615e745a56dd590b091b7dc189afa1eeedeb32a1548c6fdc53d13ddd4b927c95337b511bfe424f6c13695a634d2f96ca5a0bc0ec4622ed91901f907d81a883c7848b50ad3dfb3330840f0010aca257dfbb9c0c6b0106b6e3da02e756ad19b12f1f3136001ba569c08498abd250866fb62c984eb15dbab6393049aa979c2402e8e5d8cd5139f9e59d886f8915483d79419284a0213c3dddd67851ac577f98a735baba1e66e9b40b70221a1c376c85d12b0e06cb6fb7c7f067cc926b67ffa8e91b385f9461fa8b23a2d0378e5372c82eb2d85651cbfe7b3c96c3538c76c969815473b6c07f179634d979ea56bdf9a0b8eb104b13c7964258c8743453dc16bf4ad02c2ae32025730d5632e33dad8033a6c1f566f580137736bc5d05d8e55a9d757813a3492475d52045844fd9db46bffaf471c85f64134d58e1f9f23457d706a1a4ae1af24e2a84cbc781c894e33c9879b7c766845d9a0be6a0c2734e595ddd60ed6b2344ac8dd40d30db84bc3ec9f849df2172a9c064e031a91a9ad946d3ae5c2ff5bc57b5fb245cbe51f9f77a1ed7ac812ebb3f68fff13ba4c4f50253a4c855c47908b1acc3c23af88ead865808d5c37230e2a7973ca1205c40d253587e0dc8c119a0b7412d2194b1b82afa1c6baa74c07e7affc351956c4d6e54fc0d2a091d14695679016a30f8b7876f1c2ed2ca879bbe70fa321e515980f2ca4a0db863bf0849688f1804c736b0f96d6d475552cba54a312ead4adf7fc9ef53c0fbfe48f2364f76069876ea0abebd5a2016f128e38650f22688e063cc2aaf07fbba56964da3e740f3bd454c3cea5196f0fd46c213616af0cb6d6b0970267d8d4a27e7ed712933ea4ae924a97e2c5aa2b5888d7873198c784450ae4f78592b22","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
