<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f1ce5d8f8b562066473009b6a9a3567374dab648ade55b624fc4fc75eeef7b44b2b20d2034c52bb586eef2b139cea078309f3bf1cb437431388bc29e4c2e293491fc0b07c622fe35049a9d7569dec22ec6d41b5a0d2897a569f6e51b74ea6bafc08c1590e8326cbbe33ce9b5c3c675b4ef209bfa69cc6d74999a00d7ea47fa3b95af2e6ea6baef8a7af6a04de30c223f56c4a8ad1e203ddce292e426e4557e4d3ddecfeb99963f7bc81bcd24d3cc1a392cfaf47c77b2a512d5d9870995c06e2f0dc8d348b17d51208d3d46bde1809abc3cb358628db318a7601867d1ebe7a85c175a3abbd2ba0406e622ddb846677a57d44b24fb9bcf37c96bd9e53a3f0f11334bd686558c68c21b12afdc177ed96de0eeea87703bd4f2bb82eaecaefd01505cfee0813866a238301d551b688fc502051f445b00b3e36d922735f3695e9b011b2d967272714ba118cee235c7846e39ebe1bdd09079e4bc3a531aeb885c6dea4b6e46e0c300072d3cf7c9005d7b553f82edd108a59ca474d9a1c0734b8e1cc66245f83ead2e0c4c09143306a260cece0c4655725d7d659265cdb4a4cbfe5ada2bce75a84c00e722e5d9f3b485d15d10c128fdea06a2b6034768b57d1899cfec33975dfa8ec249da209f20a5af75088bd592e43c8f7693ccb5fb711710ae5b51dfebf5469c4183002f76cbf0823e0f1e8b64f020caea45b6850e953b4d01df49f48390c04a0736e33fcc1d5b184f93af61eab6a471efbcb5bdc041d5ec86baae46c8b9428ceb50959df2fc8a4ea6bcca74493bb1c223e3910cf99bba87acd36fc6c15f020971bd784ccc8e982259c72262589f19756064de04014b87698be50bfd3e144ebdce77a017068b870f75ef774298acb1fb275178541bf0a40b6eca4f96e909a16b41ab6e0a5ffd39b7e2d718f5c7565e63a9c3e3cbab75511e38f89d5511ae77aeccee8927e8c3412f50978318b444b14735a6698526d1e7f18ee4165f1e6b0acdc9cc9e3c1547ff9ecc4f3087fc22ef95ec5412eee99e8cda25bb74bbb7c3b38e9a6cc4ec21790ec63a747a9108d510eec1294dac98db9611d86c00c51e0c2fb27342e14e5cb2bbc77f583c2b97ddd6160049754253c0857547f249296bf5be5838c4880044daecfff676e10e08beca490a8d7ba2588404ddc93d04e2e75860f6114e134df48c27ee3cf7a59d823142a2f35d1b675d324b807899cb533a66add1e29efe27982ac1ef889cf15eda3213ee8cd9f481a18a5b533a928500ff5793a2dcce63ae68a04b5dd1d94468b34f14a0cb4a80723fc4835f6d2b49b0ed9b2795853fecfd14c884cd28c066071f90ec6df084666d1541a12cdcba01dc8ef92ec2014b0be774589fdca2c7f6864512d32dffe73ecb4f014917f3c507a6a1b10b0e2156a05a0fef911b25704a16cd253175c2ffff4aaeeeed4990846c0d7942b6c4c68db0469d34cc302d56e1ec523c9f216f7a2d15f6705c49c291ee2b3f43d1de9c424520399fbda6538cfcdd1209c03d7bcf970600d68514ba5008d9ffa8d26da2fd5cad5ad657b812d003e163b2e4e632556c6e6417e3280a15c22fada89b1c8cfb1e1d269b7f1c96f790d8ddd7a285db0e9dfbc19e4e6614b4be377bfcf0d203340223f28d8c93f245238ce2ed40c052a0323e9c2a882f3bdcfecaa4ac2dca98601c4fb3819c3a3c3191c1afcfd4afbfcf5584093cfd65b065e2b3a2d80d149e4b71c82de132d4252a2f8239c71366fa3b6736d5d8b1ef33bbb534c069ea21b315b621de264529812869c8115969ff815ecba8cb248ed9d35ace2236c7d36916171c42fece987156c3dd2dc576f52eda5f3d10482f5e427f086845407ba12bb5830638c97d75f1772da3136b90469fc9155d4addd7679fb066f10525253dee6ec5c308cbcda829a01f487e5ec07029f3cdfda7173bf345ebfd0c6dcec0c1e835f8047c1e5328541e8212e679c13b5c6c48ea243247da903633cf9388cb5d48fd9d05be8bcf055c0d1b897784e7f6ca2d64cf8b426b94ddfa8af291108783c598014c719e5e1372b8a5c8a54954450d7c3d2c0973c18b625e82cd5849df3b54bb88ae975ff3d58990fb89f884e2f3a73f398581aacd828a4f390450d08c258fd402dbfcd9c470b48cdd2398c09090cccf01f1b310a1329b8fc25624439f6f9a4317ab0303ea2925ae35630b78da3323ecb336773d88b43a56d4747cfbdee37fe9aa472dbf8b10242ca5315cf571fd2761b795a1d72573a0aa4977a8b97cfdaf853704ca3216a9b990416083917050f5f516e2e0252e819699cc87a604b9b3ada0e22912ffafabd2f68d6bc326dff2944c7349c7bc6ac7b6729c1d88a21636b2a1ed9a9a26faa2d28bbaddeec4100d1b97a35c25804837527a3c8ee3c68f3590f8d9f1e6d262ea5394879b84854e22008341091305170c192011e02514995490e2cdca36f67bf0e97040674902f3514bfd916c25e73a3e53be911731260f367ae4eec3d550d96024a2af06cd9b84d0265c3def955bdd9719b11d64969b34d6d9ba2d7e0b04ad278b8cf57cb3505c9890172600e21d6d989b6a5d543239579ed7dfb3cc4ea0b08fac917041c274144e40cd20d6c007813af0062c400dc8950f8d5b3c5062fe5c4e10bc89a6a5d5803a6c28bf2090f1856045a6615b435b2a4ac760c33efca076e8c053603defb6d015231980de5c0e54d02bf1ff6d2dd3a0aa25d25e96caf3e6e53aeb8ac70758711f06d2f85bd67fcbd8726ade414c328fa257898496ed72b4c39f5b2ad64452adf5855196366e5b3b466330a01da76a3b9644f65d664a38d96f91f25a212fd035e47c4bb827cec4b96c4f2c1a1494d1b2ec58b4c81ebe01822f3297b9c2d83963068945dd25858020097fca61cf517fd71ac1312efba95ac04e9494ea28cb35c02225595aed2583311241dd0ca2bc416f9b589b744fb99596ed12eee30cbaa192d006983aac592955aa15240eb7349b22c055e6f3bd3f712ca2cff601ddac7672c74aeb66e86d3a4e404b2288fb4bd2f439d5f9ae73e386548b372f6dd1d69d53368b64c90075fb3a581fc6c59cd41a097d4df2503135c56b01be719e262ab3a35069a814e396feab6b2923a8aae7aeefa241ecfbff36d6927d91dd9db35e05990c555794a3ef3b3bf7d57a3ce1eb5bd8f8f71906176711cb360758baac41d59b3bf118d22e31c99bc1321a9cf0a750648483b7bbcc68a0c6e194d6ff71e0e723beb5369dab17d7c149b0b7c4f16124b126cd3359f088a4cd454e1c8601a3e8e2736191c50d5283027540ed3052b53dde023877773b1f5d4dae3db9b21e9f885d8c4b98048b85b3d45ba742a1e5fc4247d2b1b233bfeda32bb4e3bf8b2ef98d6705dbc68253de952bcd9f340a0f15af99e57abf18106f053c281a4c967885a5874245f5824d402b2d5acc9efcaaf0fbb195003ffd4339c286169cabd45d76315f3ac09da841d6fb32b6fb8b94ca1de26f0df6375a4b5e102ec409d95bd9f2561da53dd24e78c6ed7c8aa35d2c7538d2be177b18a16c85e8f3537c7caeda36cf0e275da7df5bedcfd868d7efe4100366fd438f5663e80394d7dded32adfb08a193e152458b3a07ebae9a5aaec8ef1fee113ed4328008449ec9e690053f1e2d3577c4efac242c5da3a463b2e0d38ada30588bab211db903aeba8af4e11a84483ac6acb77a83f316067a03823d8744fda72bbd4c41350eb0ce7db782a9fd24fe47b878298e24f1e15027d87efda59658f14bf44a5611b884cfeb7b257bd339d171e692d27788b89b3c2cf6aa7f2184d6eafaab4b274f4144105a0ee145b14dc9f42148f36b386af4ecca466e39e4df565fe9b2a521e89551deba3a39b177ebbed9e089e6247a412bf1d908f8527da810286bdb77fd8aad7a5d7f8ebdb789f4d47dedcfa6c33645894ce3266c2de3ba7869150db4d684e40b1cd4c0d0f4e38eca2530a0777c51c14f8e0d3f03dec39f14872d3ba888d601d9d0386679d4dd59346bc2846c330778cbf5144d9cb6f19f564a1a90a1c8a4666c8825c22e6aa2f9aa24bb92e4c79d3529fe9b54b2cec2c6d573c607e59425f66af916099abd9468eeef64b4c718a29720152448ece2e746e58067ce1b46e3e9e34803a9eaacabc8f722c20f354f85e2679ce06a6706b82638840588c587c21b2e7276bc420992ccf39053f929f6838413d3edc821befe74e5e1dbc0e9ed99f9911d45e8d99a5ef10370d211961632910fdf64bc6942557c1a713e0e3794b791a0c41c9d462eeaa4544e6ea9f93a8f2037c6f496328a7420a6a4f3cc554a70ed1d494a7c2dd0e3cb66b0056c86c6be5c59ee3b9038b88c364a22219c4587c80f6a433bf1768ab5bb4da3a9cb725d9af3dbb37e747a319bc72991dacc72a02e26d6bea4e15292c57929fcb8d9887428d8fdf74832eb1b9dc364acc5ada1406d62fa639e850c568421a162c917f6d740525fb2b8f94db0af11df904bb25f562d4a4950039a8afe316c6ce93a8aa82e7687811650acb65df44ef9b2b51539390fb18f87f4569bbd5701306497aefa007aed180308ce606aedec9f5c8381b49292fd3e06c249b3c103ffc1fef84062139a6112defb2df7963b04cd6f3a57ee62ecefeae0dd01ffad6426568f8fcf3b51c6204ae9b47325a7393c229e1cc7c1ff5ac45b106f30d9335eccaf134aac398b758dfcd13794608e98ad10972c03518a76be5ab422e620b5aa5ed434d477f55e4b22b05656b408d4d5e80a2da13d61a8d702df1f6e21f0e0d1b0b66db9fdfac13405a74ecd4be498e25e3916d7181e94289b70fd96177e08c9bd82e4cc98cb48eda117d5641399f6a6e7cc5b68083a8b2e8645d31e26dbffa1736be58b2ca90814fef6a911ae959e8631057711916cbb908f5df79b8b43e72089ef669200c7af7b09166d415f03d2a53ad494b384b4cb18dc0c8e09e0bcda43c965d493098421ee3380bd5be08399921f8ec27a3e9f6d373d017094c52d37de62bbdd6af2bc921eb8b6d8b0f4f558256456df0d76afd1c7a878221a202c61b6a7b42d2235bb932840ebc90ba0ee92236f27369d9140adb1a92a9d857773cd89fe89859dd07c81525a39ab0b932432c080716e3338ea4ea60f3367f5affd384ee5821d2e2c28bca4a9c608a0edee70c85d7c75abcf2fb0097dddaceba43dda300a696a4186ae36992dcbc3d2e645debbb9e4956ea596b54f1b56540c5f2135daa75c03721e2e058b6ccc7e998cd1e74d6485c13fe4dac08b802e8ee29b478ccc594d123944036b96e04e264adce0986a18566ff28cbdfa461446d3e34bc58745f58d0680dbe252e1f74eade9fbae041d5e14a6d44661af27b8f4fd201e63c1d412b377cd5f09e570375f5bf666d650fd1aacbca9dbebd6a691fc8333677ed4b033d9f40f91368507bc9832596bb9de98d285234974e03ec463ada2b787ace2f1d6033cca9d9bbd8dd8fe6508d11f3857f0adb55a1a37ccdb106a8661059ac3e34e9015f5e797e5eee0bca644187d6efe1aa4e54922d37eaf3aadf2b0e6a5d191d9639154c3a79eccffb2299c71dbed824db1dc53f105e35020fc88cf93f5b9dc040015ac82be72fb1d21b82436366fec19fe297823f7ec1e5a8a7299af1092e42fb3cc9fbc9250ca5c5f8e472ed1121796633e207eec687d1bc5020a95bff7a9492989dc8811b9489e3a499c87f60d953c6bc7c4291eaba96c4950fae34bc83e09d13871effb89787afa2777488750b96948450bd0d34e07a0d35061a6705a6c9c2b89cd5fa6057db3831fb0512658437d127a7616398cd702302b95974d42498d78a470eed1e6eaf4ea79d9d50d5b44ab516e3492894fe0f1192603f384841d57e29295e429b269ed2871d6ac9247813f59472dd20ee7ba107a84a758e497c6e13561d8b600096071a03143fecc9d39393ff2eff648f55d6356bcf7c1b5693a9e20bdc895254d88cc2c3846ada393a75f0615dfe101456eedd2464d64a46a6a3abddc3f76c47179a846aa55e67ab7f91a6c8e63a2688f0b754ee7ab47347527be75ef2f45eef651d2209012ab5942aaccb2af353963e2170cb171b9c7ac0c9b4a8a1af2cf55dfa5ce05389fb7da9a91a008e0e66197cd0d2a471b8c7f9bd4c71ea01dc629c4cfbdf1ab3fff1f45fb4ac675802e39eb54678d27c54935d8ffc95484f469a6c59ea8deb2347f7c6592594500ee9e9233cd5cd8dc07f64f0f7145ab8b73776cecef1823bd4a277e53dd42e49669e91e55add0dece5df14bf670122d9ecd03c3085c2dcb4602051ffdd7676b9965c0d095288467d637c1c4be583f67e28bda7c65dd2e18c262f69db071feb25e919ec9185e811a103935e24b9d789eb5dcdbab7cab574572f0aefe923ee26265cc32ea97f51cdf55b9c9e93a1de4e456c5fe682503f39b02fb8975c7c529c8e8c49716a00374d824534e466696bde097bfb5195d1eed111fd9e6d014ad88540146acae875dfba66920cc50726a7b623745f7ccb47711b8db94de09aa14456ba3655f9fb999cd4191d89c88a6506b7cb3edb50defc15d94b563a2c1cabdcc9ba6b39fb5868f39f836c77d14559e330b73ffd35c3eafdd278ccb0f9b7b4691e7db2fb972b84c91b5e335ecf3a5f0fe4bb2d4737822ec46c14e7976f1b8f11c514da391f3f0b05025d2def533eecc3d3719b015483c0d6b728a13605b9d47a68f28bb6551e5fec6a3860d225efd59b95a3a9158c911923ffd6c518e8fde435697a3e2fc104ffb444c354b9c167b12cf3a066ded578d048ffcf8ce148dd1c8b6942f798e44a6b3a487799f91ff2a15223d5c6ae962f3fdc2c91a77b55bf55ddb249e6ec3ae39fee6d28560834b34f880a2a9067ca7ac6d8e3a69a9de092551a69482d63b9c7fecdd3df7b99ec17fa542b9cda9e3629084bfe6dc73885e66690a8c416f6a6ed882a5007c4c26c9896d70b809fbe99adc52e5410897723bd0b4537457273411bb8c89fbda15bf32569e83b565373ca6cc954cc0ee075e707399c8f2d095e4de64af835a3e0933a84336b8260a4cd85b1e02a545a80535161c970b2cc64721db78349dcc10bc2ea959485bfeef0af8eb05d94d985a13d2d695cdf4a520098bfc960e42202d3bf2e18d16eafee65b2d34f4065b9de4712e988fa8c27180f75843b471dd3dbc886852e55024a9ead0a0eab3a862cbe1c6aca711ffd5654888f4b77c3250c34518c6e0c364a3007191da5ff3e31f4807aeb91f711b2b8df4763427492568a67a9a33b1e27b95627a36447ef12e15135e903c6c3408e399061fb7283060f41120a51e878965ca048f6a9e7698526ac160ada18d378a1b758a0ef39242c2d7678ae34a955354aab7cd9b88c0c5ef516a2da31234710f902c582d2c69623a69cc03a2b393fb57d3f81c3cdd18251934048286d17a7928618163d91f7d5914e6a19e8d465a42cff3de44f97996642321b3ec29c1a7fe961b0f64e22884d6c4019b49d28da9d062253ee0f76a1600ab4b12e8ff51155873416ee41211caa23906b83ad145db28d180bcfb4ec90f6bfed2cbdef924ba74699cfecb46a7ab6c6cb04a6835e30d0f48ed463e463a6f0796b30216f55d2af478b1eef019e79073fc32a161edfea5af2e7beccf96a978574c586e1a1eec266e1c9be0a06fcdd4790cf4e0454e587d2189ed736e4336cb25f42f291fcaf47115561e5e035bf1cf7f7e42c6bc1f88b6758fa515e0cf6d52856f241c34634ae7ee8a6670737b9d5d32a9a5841504d55354c85298334533224d29f119d4001ede58858176651b127ff597e09052de3fd576b89daafc2c907475eaa1c1bf7dcac7fae733fdaf91a6e3b82d82a50523cc589dd6438edc41048f1e8a5b84b4bd4d03455e0f146d564aae1ff673f9abb3c8555955a10a4e7877dc4051374f579fe9eefc636c5ed19dc4f76ca60a7a0059213b21ac5ac9804659bffc16218f89006a865cede965045abd27c8b774a165ea7246f6d87a642abbf29bcef1bc15358b92b3b1d3aae47207d1f6e1054172496480be48c4a6cdf7e9d576557e0bd078b0e8dea0088b790190186a280db41579c3203deb6c12f4393d75a8727232f74731221e96043d334ba1a14415baa5099077017db8b88cf4150965842ed13f6d90772c080e760206e87b13b542749810724cc97ac7299758fd848e0eb19ef6d754a0f7453788bd1cadc95380ec2484c45b9d974406d634947b771d5f29c88ba050cd3eec31945007244a68e492531110c33bb5581c6b531580d36e91bda31dadc2fd6f364b30b662ab2e4897c21b21e42b0d60ac5a16914e43682149e183d735483f5c0beb87306c4d56db0ac9c44c4202db36340534d29f08b3703387f1a7c384871aa20b03a0f7b6f8a9101b591145354a580f51aef2ae2e0ea4051f15339c7c08e8df9433fd17838b7b905696af1286e69172f9df2c19a8dd786d14047018de5dca6b7a5e23dbda411603ea4ab877d752a581fa98b77189a844dba630019c76beedb1b987dfdbc597c21b8f110dc52c4a231de4cf8f00c3e78c1b95a2dd173684a10881d6b6a27bbc0476e915d3d05cec18565fe6de034ee8e0e6bd36d4a470127da0db20eed418d8541afe26d70f3a0e2006ed0af2dc7693b481f012abf9202013f89ab3b5118fe7ee5925761c09324089064d8eb8cc2d81123d06064af0cd2d79b8bff066aa4f7959625b41839ad4a869a4c822384a75f550f9b7977c5560dc87ae3b1914459c4e39835d160403a83d5d11ffc338a93e5b0a4c6832ec97a2b1d3f9122eb942b9896039f7808c7a6050ec982db019b675b490223f0aa9424a359a583db255682bfed48ba30766f4b5f3066ad8531bb95262617819a760ae8886accea1cc848c7fb7681485bac0e63c0595a299f1b31774b8267480d8d624beea00fe826b4189b16cb4a279f3b6d990b361a659644ee44f569443f7f2db89fe10fc760effdecce765fb8f962f4a317a0449b9acead4180dd135ca49d4132db4973a3726266ce7dd2f50b9238cd820a6503ccfa8c387f9d0eb708002a34b18136c7767ae2f5c4e1b6bd2b7aced01f8fe28882288893bb64dd5d086c20a24a722fc8ef2e38f82d9cc82cae31d399949dc7ea90bc47e4b78996a9cd6ab006cb145ce32c631e80efa7b4a91b116ba49b8f1dba29d71015c713b803c9b030f91716e598c0a80ce4b2b0dffca741105916d8761e49536b74a1e095c03576ec9f4a101c746bd91203a4d15563b3ef7a3a0a13797071a977400e586d4657c417705aa24c7a37d8b114bcaa3b0a81d755d6026547a5479afa613fe8263a84a1906f6d2771884231d6869940ec14c72620c3fc3fcfe48163e5dac2687a8933786e73baae14eb50201b69d5a79e9857e575e82aaddc2e48f9606c392c6946c7c9bf6ae129f28528f445e3174a9febfd0c281c577feee0a569c5a61ff396339609e66fdfc1685fbc296b49b7085c5b1af4a01ebb98e658bb6f748cf94d27fb6d1e2892f70f240ecfafb5d020181396d4e7cf52e83316d079c9f4ac01c387fc07b2670ec63117a9d840d5a22832435a29e6af95ebdc38729c4c56603cf9bf7ebc22219cbed7fe4b2f8cc45fc70faa0d067133558be9680bd27662353a2e5702e477b88ad0b86599a2712884299a365f9170fbfade1863d392fafb176c3df5767228bbc8ca8ffe5167ae95f8695d948f2b234057234dc61f9d02c64b5c99ed8501d7bc99c6e33261af7787eb334602bb91535119a9517704cfa45f07538d908d017ad3d86572b24626c6d38a00ecb5cdfdd9c04f12b97d1441b596a63145c7996236f1ea68a0160038b775485fb83e4072cf336661e10912016bffcf3444ff9fa5982deee97423f487df7a01722854799d7eeea7a80c2221eccd71e3364767a7d7713d54d05407aaad5ea5a87bcc8a281ee31c92baaab2e5108ad08e67312e047e2c58d7ba6f64995fa7aab1afd37090795e45bde3f55cd7805c102918f4667c456a69c91ff8049f5c7a579fc912609262a45e0617dbf124560a44783804ea3564cb8eb36a817a4977e99a80770698c836209e1f7225d54701d71ed7215f299fcc44b2c45d066cd518a6c5064259b9ae59924954cdaf1f435f6d02e57436a7ec55f11e15c33d2e1d1f49b82080c81c3a578c65d87ed1abd4e7fc3ab03c75fed884ca60d2e8bac39a64be8a3f3e3f31ee4af35811330f0ecd94c5297bb45ea710047338608f5b51269f9cfe7f7ac6c952d63fb7d7332d33fd4aa4712955c3503f4c9c99e320a161f52cf74b04582e5735bcede9042520987dd9c66472cbc6d90f06a529e3ea5c75eef0a0e98022b377824f28842f91fe1e009bdad95570037575ec18a48c5ea859dbb6f2d1a9dc201bbc40a89e652818c2e189bb55cf519fcc0c39c757d8368b1d60762003c6fab07223489afbc12b2386bdfcaa15bcc7f119d41d09d36722ec8a139a68b1003a09392531b03c719e9c5156d78656797217ed3e01a101bfd07ba5c43f9333bcdcfa7ba5bd1925f6ae34c9546756192ba19a4c6044560024d09203f6648c5fc3f5dbecd88c8f20aad45407abd1fa74a1845581dd9b37d03d752c20e91181168fad4ed8b13ee33b22cac32a43f0ef365822f953e4a6631bade698449301e9b03f38e750d82c79cd0940b0abe1c3369ccc25931704a2941f39490b3743fc514647fcdf44f65f5bf29ccb5c79b2ca274639f07a4510d08e4ab44420089d7a3a918b395558a524aab618232acd0f30632e50fb89dbd77fe60e85ebb474970d112373b8fb2d57faad73622317cbe3004666b6da76f86055a1bb3f0563b9ed8066f74d2d6bf8cae2dc1b7fc9cb9ecae3a5be28a2ad98a007fd955fcb3089db0f4fea3de31f264cb7085f2fb53693a18ae2f1683c940dd243e225a6c3a300ad1a890f88a379eae7f322d7b887893be7b21c8cf2919a1b138b146f54019c2880b9f108162b7f43938c217b1dd716789a77ce8587184da99816059ba0e0843eedddf30b7071500d0ed5613d88cd9379c3f0ea32f32fae6a1f6c77cf9d0e9c228bb8685612ca9be88dd709997b60eba3010cf0d41b2c7d8fa12db6691a92cdc8599abd5dad4672fee8b6eed9fd17a235ec9c8e0444bb4079b9272238eeae32cc5463b09f0a4d8fc794e562f63f7748ce2ab418310f747afc5efad85afbe58f2129eafc346fffed03ac9bd952a535838390f8c929e5000adcdfd83ec84579e1ef58f0654a4189defd40ae775c0467d8bbfa7fdca4ed137bb4873e68da9f9461eb6bff157e1cbc9dca697a9018250ea66c4d945be204eaeec67e63cd35d0df11fee9f16a4fac6a513139bd7a3ca6359fb1cef282f37a40ade2a54284c8808893e4db02128f93d28be699e993a56e17886b38846e6bc95d9596f0565aff548f418744ecd5bb47540865124b1ae2a6668ac52a05403a9ac8797cb407c251da6629c48caac15d73bb4e250cfd761bab51b738083e28ab68808df654d9b936cf4d7f0c7c8585b39c52cd4367978aaa2709d81caeaf22ce99e3692f51c1583c31739ab52b88034dbf29941eb20d2473d3823e81a869843427e98f774ef8839d0e0e09955f214fc7d8c9e55669d21cc54548120c2b1e476fce38826b08ee592d7c1eae140178e9c64d8da3dd1ef1b521fd0507683006d288901577f1ce33203522f8285eb59af204fd356202920f4df03c4806f60fdbedb8ecc7625adc553593103c3f502fc9e427def304065f8b05981c2a88c5ef47c9676708643e0073f7708a5bec26a676bed2bcd0902e330a1cc85a679d818e14672877c8a80e2575fbd420d011a98826515becf2befa6241461bc8b404d338d3133d030ad9c0610ca5e1d0b4acaa8900824009dae9ec7e4fa1eafe359c662695d3627e431bfaa93af66f723bfaf9d88fdebb2badfcd0f7ea60eb03250e1a9607495177b0344957228e40fffe0dee0d7c32f6c71398dc8afc503d75363e436dcefdfa0966f1ad6bda510249668255cf3074415754605c3febf9cab8927b59d66509168e2075607ec1cb7433a8ca4c36db28b9ca8e755355ce6f395c3226240dd5575b7a758b9324e096e03a41baa825697fddba116121590b5cadcb2f519d0b461aba3b4983ead95072402c7203fcfc456b4f4dcab3544349adcc3b5a61a2f1676aa0a46d6d83b7f91def9d877366bb56e4e0e92e0422bf8aadfbfbcefa4807528a04b03dde857a7d572a2b9313158e495b160d22e10aea0ac3a659326ea9e3b77ad3d105b1c8923dfbe521a04c6a78fae49275a43f3e8ae8757313f409fbf089738a98410c56638cd9d627ecb9c942e80754d874b0ec2fd4bb8bf23bcd6cbafc5c27a90400a43bdd7726ffc8f6a8b6ea3b614b16e2ca9c773b85c6b271ef7b413a090bb0df7883568eb273d84dd80171ca9d3f7f3639574e3f9b0f01faa62988e7e992c002911cd09117c7452d3cb02f883999d23619df20b7d2ed60d31152c5b73cff7fc46f4fe8acd19626b843067db5048254a627f8d0b156461c5f239aa3a1c395f433f809f5179e1231e137bdbd477fb636aae636ae9f9346c5ba074c6eb54847a8af627aeed896b03756c7d60cac1854a260c4a107d3839e8a3983b51cf772f5989b03b02f3b4f4e054eca685390195d57416189675df53910e19d3bf60e15b4f7348827b023d75b9e20e9b905cdf6d2ff623c1f99fc3a7dbfee3e0a3c6b6216aafd68a3ea25bb26ffa308affe2a7fa39069319d64674ff1b08292087c133d9b9d2ac3307d6f40244eafc5e0e60a2cee3fb94e899a2ccf8fc6fb30688d72749dd403853fd0629ad24e74e93a873459f527e14620ba3b8536ca7ced22bdf6f270a805a004ae5561b23a92577512736ba0fd3b438e495318a5d8e8c17ca5f878f72de719e71f779c7e30c6fb1122708a3515280299e81a4e5a966bdd36a50e9351178441cb8f8b3c1e674e712b477f0a15193c0aeddd97283ea2831065ace0a515379e601effad65df0654d290dea409ea8e3060534d6159716c7ba10ccb8c4013e288ce9b85d21db5fefa06deed2d1b8e759ba589cfd2bddec080349bb8b978cbc431225672f3d79bdb2c419e1efc6cd62fd2e50ce85781c67de8790c2ef9997c22922deb70282dc4076b763d8e0c7344c95fa55f440a986829df328833527c0d62c0c57aa9c1afe95af17ca3ef0832d6c5dca81f59810dfb7dc533285f6b1c8fa2cf22980b14f34dc7b27b5167d52adebf865e6220e96e7d64d608ce38afeee7e6ed7da28dd298812da2a399d026d89c48b64949d553f5b0ce9a4ef9b8835c0a48697e9c5ca090c5452173ab2dfd91c76f3748c23997646909d8d96f650e8c6ad0f7a51bedb605c46087ee5fecfdc143af59bde450c7d10ce5e4813d509f4a96c16be57f5f83134f34b973d90629a77cdc6d6bea20cccbd5b7789d763370e342633c8dedf8afe702089ab53c512463f1e15a1ab3f4650f6d5f1274b20560f7f599849dbae5a843ad5a636f86517090799afb76f1ad83d1ddd769812e74a124d6ee8896f5362655386ddccc12d4c120baa9c186d57ad161c1082149392355f08d86f384b74adbbc157d80bf1b3150b2a95d78f061d9dfd8604b5c1172f6b36f309a5f5d1ad5ac7dc28f56ba01d0226162d35aa7c6ed7d3f4ca99b401d0161485d32c5334771d22e8e8382cf2a12c6319ba017e3476a70e27406c0c48d5d3bd0d809078a9ea05dda448a5ebda878bc18b1c8d50ba54f821adeebe2b659490b2721d845871c217472a64459a7feb133f97a805fce4f5f680559a196711fd36fe4f3660e15d3b1b49fab1556a52b72cc30bb14f0a8f407110a391f4c1152b9c29540284efc844f22fbe66362cfb4023219c521f2fab2a8f57197d45080def9d5911afc22b90f4e300621514e53bd9bae7539e96e2ed91f1d987acc3294a915b2df7fa2e24f35e4411c7ef47582c3592f7a1409d40681b4c73ee8e3376d79072c618a77bfbc921c2a2e4921efae8c787b73444758f8e92abf2cde5e68d79f69bbf8e73500b5b13424866e15aa580aaf350fcaee1cf4bf606f8cba13d54d0e5bfe2971b4b1ddfcb0073941f270a593c3bfe5748f4e165a475feb0e64d2c92dd18eb4124b78fe674232f01e3e6ec8290da3d411c5f54cc69e2413330a01dde01f6b7c75dcc5391d19b93fa7aaf20357344ebfccb14473bb31df922e6bee3ff3ed7ceea3887b0767e6489486f15c991f84c0ded5bfb4421361aa5cb30addb7c602677aa14a805a9bf519eced9ba8838e794c842e628517f447963814fb3f5d957fc00a6b6db047b14904a23ef2ddab97eb4a145527b25adc0c578751ab33cde5c115cb009a34f65e67dafcc9fffcbad86e1abf9db384529d6d814be71edab3a58261d114176b77caf50daa82309672d1082affc5ceef4b9c78b6418c10bba0bd626f1bcbecd930649c6819f4ba67896f809e32c235351f7a9fcc7e9579ffbdcd61eaf7ada52892ccb16847b9ebb25ab7d29d64adf022763ae2801ed0c78a46504f902ebe75cc344c0db5c02bc92382b81389499f0b1b5ee84a8c16cff8d5ecc2d5162b368cf998ac5ec1f93d2e5e36c856169a968a2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
