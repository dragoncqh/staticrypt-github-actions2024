<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e464fe8fcb7d19bfdee69caaf9b0deb65b1179c62a1b63c82d3386d59f47d9c9c94425a6e762c8fdf16d03ad748cc44aa0813a6207ca5207fb6f7ecd0f5e91902b09a85c45ac5626fa08bd0733c61c2cd1b32cf23321dc22719e1f03a39c48f1ea48469e48f2bc0605596911c7dcb16859a4902edff904d5a9f8fd8e8c3242a4af195cf915b29ce3eabed8a6c5a7e6d233ae755d3789cd8fa2fb3fa1112f208640bcc8e88c422a8ab9ac55671fd84a8806e5fa41e1bdd4596b8c6792322ce45c6012355d4eed4eb3a2d2342a4b610091656e5f8ac6b1fb8eb64eea797dd8a4720345a2ebac34b100aec7d3036d6f03f3139805ae1842bbd6b42b78aa8a052d82f925c254a203fcee6260c1f8525dc5c255baca6d28bc894d2b85996c939f60ba53090370bf52e8c74322ab09e0644a97f34ac54096cdd36168f6312a9666015aac095a542c69d1db173746ed72396a482d2c6a3692d7e143d16956a37522527b6648461f8d2709427a8b5b4aa0c3c1ffdbeb3b1d65632609d432c651516385ec4de17e7338e6436dfea724de982a2492a33cc69654083debca605df3565439c02dd65871d25353fa2828d7d581fb7cc23f7aed6b355246ba04e0e916ce267d707ba51e7cb4b4fe18dbc0c4db39fe416eb35d69c5cc6be11cea908c9523cbcfc73425997f74f36679122aecc1e498918d7bd42c46e03603748ff479e10be863070a9819de216b9f68cb7f48cbd0b259b84034b729da8aa84e6c31499a8d0d7751ac6c4a81ccb795fe4c7681bad27d1a2d2588dc0c6be0b07e96c654138a5c7044c2b35265101f9e5e63b78d6ce0dcab642391ce30212f619db8f338979605eb7608499502f60f59c3b8fa013afeb2cc7b53dbd7e071aa85fb7e3eead609c53aa94f2c1e9897f2651d8005a7d070f6585a24544f28ebff62251e800deede280141763b4205dee4459c9ab637a4da59008071ae634425029dcaa7806f9917c080fb45f45789e2c65016bf8fda94a446e08f9dd12834cfaaf09ded2c6b39aab0bf3831f931c3103e0fea0e510bdc0d33174577d81cf9a2850d2d3419e29a2943f48b8c923aedef27f307d9431a8463ec4906c056eff2bb8840791f87af4ff567ededd288be5c7b7d1eb104adf4e6431e7143e951b01a44348f30b8964121b090c6a1ec36bd3a37d70059504d05b78ad6f0702971ad449c6a7302328553528cf4e8b1f5209a4fa11488268314e2ae3236108c6d65d659ea8bf624d403ed84054d124d103a14fb2404be2db718bc40abebf705c152320f913e224d6d0bb53096bc67a371101f1415c72c4d1299f459ab97caca6937ef66a54a7e78569a2379e08e274b8be8b7ea9da5f7f6bcd52c5a1a48dec69a201214256854ff199743829fc0a8042c3e2bb115b28d9a24da96495dbfa258a0df556b0ca0ebeaceff79e1759e7d45fd0b71858869cd3b79515dd143bdad60fe5ecbe570662e01984331af4f0cf3499aea2f889c4e07142a3f9fb45acea82424fd5afd9b68339065130857ba29d3b3aa98e1ec1821a09c5cbc62c367e2c77147c2ffe5706e71ceb4cbf2194d27ea8f6646efe28b0e6c29fa301cfaaa2339a09e8caff42de22f777da42b8f25b2d157f44baea35bb007fd75941541987790dabd91b381522e7b9afb4f8a33915cb5e30da1c4f59912e75aad31b94ab2d0d214ac1491ecbe4879058e6ffc9b000e63671baf7453be62b6a324bf476e1002f4bf297acb75fb6e87b89120a4ea3784be758ffbadcf9254a27c9d5c9fcf33b2604a31140cbff6bf666b1862d259d7c5541b8ae2ebebb46d604df522b25126f528d79c0aeab0547bb8234a383a23f5bf81448f40bdc92938e9b2c5aaebd5ca92a3504ea2e62a3d917386b0fd7cbae42e5238d6cb8ec1c760b35073310dbb0f296f0fb7b4fe7e5ac51a676bc93cf57778d4f5c63e203cc0e9807b747e723c523031a6fe44657d241cfeb7c79e851c2956538b3ee8e86d78ea46c6d9b95b3b17aab8edb6da507405f821a15a9d0e84b40a5db038528cccf74719a3672f7e01802ed042d071cca9e3d825056c790b00a6fa2c2b8fbe14ace1c34a853a6b27dbee861d050842141f29cc9eae57ec2726ccd381a7d96303b1f4e43a6b833efb411944518d891cbe8aea35b235c14dd085a64fe4f5558e501e8a5dfbea7973faacf9cec996daa8e5bd01f30a6bee3209d638f7da07cc07dcf3c83171316435004d229f8598cde806f30b64254d0559f75b7e05b8d9fca026710742f28c2bb4857363d5afa4eb853a00446a790cba62cd4807b499de141c316a71d12e6b89df4a966f03ace50b28a9f3dfede892c803a862fbf66008a965b3076fcaa7adab6f8297894926df1ac47c4f3bfc495a649aafccbe23ba9a72c175a30f66a8d737c8e2fbb7a6eb144a8d2c86b99fa619cff6353f3a45d9c106dc5737d04e52467b78136907a57c368519910eca3507afc46e2c8528da44fa81cd065671f0f0b8d1267c602765efa2d3a9bb7c489cc6d7cd380d5ca649b40812aabf2361c6715a0f79227e8d5f48882cb61c85b0748d9eeec47ce0ed3e587764d64e5b41b1f47e3c53e955b54e073bf5c193870c7e5c45dd842183b9c1573dc863f3e53d0cef780ebd04530921bf242f517b1d7dc99df6e6ffc27aed200bab50f3672c539ff98381b31957c11dd4d4b0ce733dd21718c869512e13da7de14912ef84005fdf6f8aba74024f7f6e9e2d473d8d5a3ee56c28c015700a2a76e7b4c96c8f988b5ae229558e82a59769d7fcdf882d10d6f32925967ed270265f9517ac055b2b78fe2dbef70804529252b2d335736d82ccbd9e09f2c5976241ec36004b904ba3c53eb3a1608612a81ec287772d5df1e9116cf2e7ef3c0e1b211721d16491a777fd2d849d50c016029dc63d869a4217e3face6e30a835d9f1cd48b5e0f3d07e39dc63f89436880082c219401163289b49cab4d54bdfc667c51012760497d6a9107d3978e83dd3839612f965df148791895c83b6ccef9e9f225c3f484bca25d3ded8cf2f67c7fbdb7ed086a99418c76d0bf09c60418ef010e5563f051e849576f36aa2ba86fbe25577af926398419f1669c4bd144f7708a25c9f17d78e954b6c93e44685d2623402fc2af2bcbc46635c05ed81965fbde5ffe375f1d2cb5ed0072cf7ce960f316ddfef6ae59e192a7d3811996fcdd09478d881678ab21ce7b4980d838699d7a64b45023a1861a64716c786346922f40d26dbe39360507155392c023fac99cbb687f1fddd163b8491396a1d29f82000bd081f0281d3780c33cb6aafd9203da626f2ea85c861a2c7d549ad1ea7f2e38e764d6c50a1885ae6d7c1f428648a878211de081116838b973aff55889d245ec37420b4785d42994fecb2561252230ddf6db48bf6d13bbcf6008c3159471a038abcf3f250b4b33a724d344b61e2ffe520acc4d28213c0783f0c547e25f46bc11583b99794cd64c7016a2483e4a92e12dca6a0a754b56aab9e11a5a8de580d78486608a451338b2f5263fea88911fa364418512356fffaddb3a3a9038fab8b0d937d0f5191c24681164fcd92be398770ecb7d830b01c2f7dbf9513424b619634ea77ffb0737d19307b82c35e176fdac9208674c804e90b247fd532e0134d7d7a5ed951a0acf2571528000863aab8a8d01015d8c4583c4c093fd0008685915ebf471cbd3eb8a44e83d3b10e8adf3168ec3add345188132a8c4d273afae72a31f31b426e6b61dfa8be22077c9cefb3255cc0a68062e8da761885a55ae279cb673311097b93838f07bb676e1d43834e9728c1feb6fb6b6cfd48d25d5455246d7bed4d4f0609836ec6a9409ba1e29833293eba37d082e3275501b35f5434c4493c535f476681c0cc0a55f4644fbeee555901d6e901a8f7f5bcace5e3c151fc9677b1f01d6a5ae8bfec46c0244d382516791471c6bd85fbf8267d9fe5ce602225dcd0eb1c67330cb33976735276ef472e9069adb5eb9ff80225df54393a0a0f91be5359df35a4acad0264bc317408a694c4862d266c76ee86b10544b1c5a4533cbb99435b33bf76a3199d06f29d1d8082e879e4a14f62e10284d35cce9cfa90046e8c6318a2b445fe57a398aa50f6f1f4aaaf050a247a1bb35bfab419de32e7158d998c7b3669aef02c8ae70877d47c2de2ff214ea59b0145b534bf33d2324926ab86359d772956e3a74b659d6f9daf60a30c6c8e132c2b0eb2c7f0df8077bf91f1447b6ea5aa1a1a189662194882b75e06ec099bcb6555b819d34e0cdf03ff9eb74e9e186c4f825a253ce566879cb8193a4fa8613dffbf00933283c0d0d0c97cfc700226383903733f64ad40560c77bc4a427d3b48b9740e009747ccf8a6e0adb466ffd9e102a88234d97ac824691f263e4b2edd35942cd834dad1faa906a5861f8c67a84e5d6c13761db4567c7dab52861858d21b02c08d0f1f239730da5fdb0630ab04d367e757b326b651ecccdc185612e982fb87a79d3f253915243dc322663e3f3c9d4ac6cee6576304ff5794c9ec43ffd139dc9294ca3d13006f7bb481a8c2aadcc3d9b702c64113fd61172076fa442366e94c1535e9e7cec022f233e6d60ef7fa9f64260c2c3da0c280247ed3c11ce675afe58ac09ca2c4fb1b88bb5be3335f217713c8c864d0cb5ee03d9b59cb54590e3ac7ddc0e999fed064a72dd412bfc56b37f12e06f346de5d522905cb34fece1ceeeac8c0700ff41d861a410770a0eca4c06d6a3fb72c27305bacc700cd1bc3d35fc15063ffa7cd9638e39497957bad222780306e0b9e0a70100a54d65e585421a3eb720aab84bfc34f0f0b3a87082bf57362464f3aa9672492b3cc5e43264469441d8858c29e4b43d955fc672ce82c56928df89a219e63f4487c7bc5602c6a3a552dae1752dfb11322777c2541cdfaf6e182b85d3acb6ff22d8bd5fd7a80c64dd953fb0773644531cfd8affbecb4d77be62e7a61f9f267736d17ce96e04ddaef8111b0f82a03f8137d89f9a02e671cad6420037c671ea664bcdf1331a9a14a3b66240a53afe34dce4977c7d8f2190d8a7e2ffc36d4554de94b010e97ad6bdc0425ce5d7b17d5a734fbd779dc880edbf639dd1db4fbd425ec9deacab8d9f5762fc73fab8f8b343ca44b057b3139f6641673463ca4613e84fe9322763d0d9b7f826432fe84849f2ddb419d3283bf60e1a25610d3f3eefe5f5cb0ff0ab72440b5544f49192440b297678915abedfcb96b12072169c7a7825e70de33925963d73510cf1c8e297158337467bb64477727f1207410ee587dfdb119c498ecd167f15ff87ea3f9aa577ea9b3cba7f8979dd7f4f08554435906a4f74fbbf21e3bff97f390abe7ec9a35a4fa4568415470dedacdce2919452b2347fca6cbaeecbc3697edcf5d0daadb19a26e2a8363be5ede199dd8419ebc25b2a74ea36303ce1e4c3daacf057e2be8a2126b112eb8ae6171f0b284979b3edf0234e6c917f09a0121cfa53dc7bc65a5a537a54cb16152564653392218473e21bdfcf5e245641e953a024c1a4c32791e26f973f38b0814c3cc79dc85b8ef217158db48d73ce970b2bc16fe857879436ac118d6801e857a76a3022ce6f0641a5f4e2fd55d1e5c46ec1f34b239247766858f08519e40c93711fc17f54473cb3cf647a011d48bbbb90e6af85a2d81a4cdef00034c279b8a9f9ea23de01ddccaf9a969f1f8f47e56fb18b7ce47d950df5b1ff9e61d70881b79028209b4d4d453a9efd1948f8835ccbdabc655eb398ef5627ad3e65cbd9fb3d355b5a15e522717a274ea781db642ad2336460f30ba90963ad6bb30faf26820f5ca3989b4ae32409a6cfa8f5b9935724be1c4f61b930c4860e56f4f0acadbc358bf4ad3a5eb9fe5fdd7c3f13a4861547dd74a58c604b1e7aa3a6b9671958e5867ab987fa4e720cd67baceced0cba6ae1b2f0d0b991685575f847e28dc3c94b0b92d5678b82bbb8fad7868aa4d2aa4488abf4bd7a61daf503c2be72c3854c424f5596600e8987f3d1b79f3be0a2916ee1078dd54f9a83d99553f34e501b49853b9ade37f1d3d8b119dda78c7258b59ad79bd257d1ad6ca0713b2e05dfb5362c5aec97aebb0cceac6141b27df8458a3bd0279bc4b64f7c6b5df1cf80b796bf82b6e0be631c1439f1075a76162360db2bfdd962f7d6cdb76115400df526fd7e3114ef7be42dafbddcf474ec63721f6a7306503b55b79ed6e9ce8f7694682cd8a9181e42bf90ff38379b2d2b5abf19ea153759c4b9bcb2060f0106ff2c420c6ca339718f3864ea164221cb7b88f4d8d343ce449699ba341700f1e4fe3cdd0bb856b3b8dae9755aca65c56cc74c59c8a4b3d1df0b0be4f6cb733c44b9a0d2dfd9e312617b2a68c1e8e1949d17816a87388f769c86dd774dbbdbc737f69e0df0b04a9cfcf2041a09c0a0b4e57760a919c4fdbfc1b74e63240c91104cc35d1e15d770cb34e1bf4818de6b977264c56fc74ae8c9010fd82908f1d8212d202898f15e5b87924b219e2a50606baa5b8d2c61f77b118ebadcfec15cc11526c6c28c7c5bce285ade287f90334001d7b3f60586f2ffab9f98c83c0a67d45adabc72d67819cbf0519a2bfd8f310f9847c856c4412ebe4a3baca9d4ca03e5dd0848f97f4572e0f18164e486ff7722ee35b0bf92111514b5c600a863ec350bfb1a32cdc04982a650cc98354a4c61f5fe8fdd3b2a257f21e472cddc86dc6531d2c472240495274c6158cf4bc1ae1d3ce97a9d8dda6d7666f8d8f748aa4265e6547c8a93d6fdffa0a873054e3420101823198d3b1689c53f6d58d22bba45cc7f6813790425904f38464d03b34a7e47bbb4c4c0192d3064f79b836d5a190e9046c2cf05b54765b9fd1158f53b3a9ee9d6bf68eef9e822702ace57e384ca9f36118a7e60b105d92a8434019ccc1ff7d6458d164663497b21f56f4ae5267153840b9a38d497730743f999041f40460b18462de7ab925dd4764e0c088afee228dd6a06446166549ca9ab4ab006c5af6180acc4ec6aa285afd92795cafb36a32cbf8200365d51047b82407232aa0baa5f71c36029781228ec7e3f13c044c86dc59752153540482fd189fe3232e9ee6bcca2bb64f5c708f26bc0ab98e76954a3a055042da97d33d4e219b83cdfb77b405dc0073ca5adbf7b39e37471ee7806ca70a1f1f0f94d45f8f35fe8e7f10f6b572e4482e8f4d9335427035d9c433f50e2e216414b2411d69f1b67b9e81b6e493c0ae8d6a8fb85653b2ab97d386416940f9fd5606b8ab0b6737df5d479f4a44c0efe06cd850ae92e8317d299b9e1edbe9199fa6e27b68eceeba2fcd16202ef7060eebff3fd5d717947902aaa7333c766f60bbce96f187961bfeb1e7251abc38487d717612ec381433b02346984c2dea0ab9f80c003a52da77ec3ee482eaa738822426e355e447ce2f1815cef1389cc99ba802d51c30986c7ca6d9e754e4e1bccd39350c85f8ada31534679af9a7a3be57bb49b7e034d1be61813d9fb8377721a6ecb85230f3d406fd6e0a2e1a932dcbb3478d905df2aca1ddffca1b43d3966c24faa6a6df523b5ec108602466f5ad73973d8c792a7e974cfd1f55b6ac5555577b8aa35758a38c99e4e40785e7a4160165eebc1a6647faafdda9ecf02d35c0f9494d6ad16f2dc84ccd75e99942e0d01c3b65faeb40887ba5c1620561fc98a0f2ef1503f39f471d78063115cf73018d62d9fdadaad64624ae38497c66bc4704646dd01e03b9454b6e16168802b0fce6415b6c6fd70b7eeea99f364ce0e28a8b860c3a13a6e53889415fe85fb27fbd3ad850bd1a703c5513a400c7382620dbb52c624b18bbd71241fb812c2747704154f7f4519e7c469c184640a0640ce115549ac3bce83000f47cf4e749c0811b9842169f0ae0cd71914468cbdf19e28517a24df73ef0d89b6154ceae4a6e7c5f0a558d7eaa9db0d9fc10bf45bc7b2ea30a2db8aca3ec4c42b164fabd7d385a35f311062d540c20133942b59c943045fb27a174883ca5c2a41e29f690b233c6ef8fcf495b5c997e20b326013ce0b19244990f47b9e400f316349a06231da00a093635ecc81f29f3cc7f2e15fbc421fac7d596aae46f4479c32f87239911c1214eb01b282a3a29f81e86a246b4d5553aac79e28617c11dd3f0e000e9b25b9da0a4f552628d983efed3bdc1b653341038b71ec78100f60eb7f7bd5d24f5e3b253f8df14c56b2f874eac88953587b6dd014fd4e239ff0de2f6cca6b73f5f65fe03f349dc99838a90b0ab78e0564c18107ca751a4f31e1860b6b42980775b32541139d59acac5c5117154e070e53de454c56bf62b4b2e8fc004620711b94df4d7f91aeb2ada4b83696072f3dc7d329de8076f731a11b4a8e1098ffea0a898dd07b612124d4dc369ab8cb58d2ac3a5998d6074404fa1f0c5df86e9be7e63b9f44d9da42172797af2aea7e2d74832630acde51a265e5be6773c5156efe32d0b1b40d1e2171a5087fbd1be422a85e1f31d226e969a32ec0981779ab1625aca6727a70364a68df3dc2a5f94ddaed2bdf7273343feca73d4e078b3957970fd55524adc93da0718727fa3d8e6ac2c312cc32884aea2d4aa3c1dee8647a28317a28488ceeb7746387de5ca927d8b7f25c9d088cc1af93e746703f458b8b9d8668fbbadc5d00eb98ec84c3bd20a57c6c5bcba935fb7aaecc1528c0c12ae52a7e2ce84aff618192ccfceb2e73d987a4e15aa843410faea39d0b47d40dbac90178fec4f7f069ec37cc33baf5516c5beb0a740ea5cb9114524c579c178f5a3ca6285c7b8511ef81d87784172be21ef0327c5deb2b5c8cbac45c9c2f8d51801245b31deee193902d22026d544948db2487819b2f357db534f05c236ca0e3c761139317b0089b0ad24536ec9d49f0d0c0fd4bdcdf20177606bcc9c18cc6b797085f04066fffec4a935f2cadf5a732aba12bc0ee8a878517b14c3b7dd46affab9a5b78d02bdce749d4d8c1c6e8fd6f0607ecb0a4a35a793ecbdf64fd42b1342406f975dbedebdc20756540049f24e88aa21691c1ced268e79bf61b9f1fd931d98869301402ac754b1cc7ec8865cd0b66c1c5f2ec4a08751e6a9e0df024ce7bf6a21ffdb4b149d08495ff8931522fb3498ac1126d097a40f88b6a0be6261645cbbc2a0f334dff0a26fffa2b3d635fdfe6221671dd2147674dd396ac3150a8fbd0ba1acfc790e4e65ec5be4e10a6dc4bd12d661cdaca3c2e177da0191e613a70bdd1e3359f6a9b7939b0104c66cee37464a6409a46290cc8dc97692086834d2370b814dea94cc154c8bbb2d9bd7c473a8a8bcecdd7cd603a748ea2e3d90cc4f13bb03f839f8cdc9d54bf5bb0a8d6954f48c77149441c978c91d5c9433f3f1430be44ef42a7b045b475f87ccfb1c891040191790e186a79f335c8bd43ff2ee63eea92ec41987cb9aa9174fbbba789f8f0576bc1361b342361632e98f9ae28144e876e72955975a4ed25e493b40c068b5df5ac242f24c0b9bd71e41f00036cb01e5dc75c28155db849fad26190b4f1df9276c39dfc0b10d24ac53afb36b2d8cf93312091fd935e7b51272f5d335a874388019162cdb8a8e2bfd524460b27e1c7d4393015b49c655c687777e3e4fe4d6f93524f974b6d6266176c682122b9a70b22e0ccab9ca83c560940271d485b77c84395e8292a961217730b43d77fb0bc65c82732f91f2cd2c480d6bc598e20ae3e741d3b0f46155d7387a73988ca95f2aad5ab08337a8e9ebfe338c93b1630edff316956bf587e1204468b3f71e0e637ca83a7442835621e892bb75adcd60599405b15cf29250b72756f9b8abcc49d3848a693f002f3534a2647ec5de4a3d3f21ceec604398835f06c99dbe561ed07e49a40138ec610de4970eb50d3ced0e2d6ddb2642b6e22eb2ecbd105d1a3b1bae08407e81d26b21bc772d8813bfd2ac02678c6de2246d3a1d64b6a27264161c501bbfc4f11b325f527c5665a485f35dca959327f8011b5ab1f5a80121e49d5cb915006d29b14139dee2372c62e493918d16f2c602b346d2fb1d486ee47482047f9550be6923336333297abff36c299117268507e9eea7bb77d7508682185a7c0b7351004d1f10cdddc85dd78cd67b0160bb2bddb43a97d289e919aeeb4b86e5c42a906373b3b3499e7f2c2cd635fc46c8b7a63449bba60ee3ddc883be1a798411b6291fbcbcd00ad4a50922fbf77d6201ec203a092f72251844ba2f4ceb4b46b8c8cc8538e314d2025b8a5177f7213c6ae658d0e2bfb8dce2ef0a5ceda54780dd24d76ad78d75fbdbceedc1cc7740131f1716f1f115ea0a3ad70a8f54b210b28e679099e26dedf433fbecf351124007db476c1d025d3ad510cd5b4c620f2580e1c9e1af3bb07f81bd222069aa0ee039a92bf135ce5c8f552cd1015205f569b1cedeb391d44b95407c3f65be7feeaf6b80130a2bfb924267b4bdb9b35443695428c3501dcb4621b12af57557e894a215026e4bd74c6bcb0bfe20444a6d1bf81394e6fbe6475e91a31b6ecb0283b9c8248151cce3e31b059495474bff5a428cdea2ad38820182accd5781443a003a9fa2705a51a6e697c598a2f34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
