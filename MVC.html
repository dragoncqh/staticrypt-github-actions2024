<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"045fa6ee433f62dfde5bf35063a75ac5c05fdae01c1e8175c39abfd4581569040c1f4f61b28ae010152dc1deb8e5a50eac97650c9c9aba24bbf2524e5f5d22dabb9eb0db3f723f12133bd9840c27644c2c26f9d628399bb8b80966eb521ef0485608262732cd2eaddb381652cc107180b7402f4201c280a5bffb54e9e5ed8735a64486e540f24710f86fe943f7c59e3b2686a4ebd6e3bea6ec1f3c7ebe3fcc68553caceb979673f52efe83eee612318ab9838eaf7ab22896b57862efdd863b901e77a4c3e3fb9c7a9a657aaee22cd985363cc7b8227b28a5a34c21d053c60ba55c49d08c95067a18f4dd9ebfaec404742668fddf5e6a5337ebb56fc14261b857b943abd272f3ca8228d2bfd1892225af04073f4e75af5a9b07443074f1b00caba8a0854a58cbae889bd8ddfe925579bc26e288037ad3e6978e04b9ff5b87b7ba62d6d98e1bdf66e4fbda11332cef0d76d757f6243249d612f0e9457b0b25f51d5fcac41cd1e6583986a103071149c9bf175b8a53e317903e2b927144a7b925f3d15e75602cc7ff20db1e0d654ef044631733b95a20307c5d22fb2f57717ba0eadfd03db272666e1140f793ffbf7ccf448c8947eefdf9dd75baa84b1d1b42009998f411d4ac081630760940f3b124bf7aeef898eb3cc299459509ec1da94a0c9253a00d9399b7caaefa349686ccb8b91e177a208946039bdae2a78039c1e35c46737150df7ce9187853f1ee61bd56ef8fd204e5843c4664af9f363770427f70f17c90eff0b03ebb38419cdb29525441b69565ad8458d94e44eb082711b747092db3e3956b70e79488e5f288b1271f32e98ad0e34b29371c57eb7e0a184ad73ad1d05c51ab8c7bcba17a2f644a853a19d1bb624ab46a0a8e255fbc0d1d5bfecbb091418f49c6192a6e0f093d39d011f0d65b05496ab68635ffcea70167d13b343e954ef13dfd85008eac040d80a3605d4c20519534cf1933c4714347a827f10446b9463449db5f48fd29cd864f22c9d9651fceb18cb594608071707eec1840ebc6384abebb69e7ea922252562f9cd92d28888171bd4bfd504679421eeafc98908dfe2a4f836776c84d3adc3200459d6fe21adf0743bc1592856d78a8b7b493c4ccdf993f65be1046a49d27abf4268d115fc1e9666bf3bc64293f5619b8ee6b4149e6a693ad2f770b6a20431d47ef740d59a7555d2df98d44c55b9116e4f4ca6406a57e5c218dc3fab698e3d09d137cd8712e953d1bcf07224ac413d6548fc60a4ecdeceaff954570154602a1de3793770b4b966cc251011ac590af991709c6f22aa3526a4ff08677a137e7e2fa7141b1ce0186c5163ae50d53cdd3eea7168626616b70ba4433eed52e5bc5291e1dd887733f4f426ec24383f661f0972650ab37f3796d58d8da66ff4b4e56b4fc4adbac108913a0213fb389babec67ccbeff6b894b5fc3e5373bdb3f7bf911dd927305a7c99fdbd6578ec3dff13a5fb0dd9e945fdbe73cc3f6b3f892ce270532214bc9af6f1c64f77a7347f8be9b25ccb191caad50090881cf9471b7f3ddbaddf949f2498f3e0d083572f69719ee4e8b2d077cf770590293446d345312d14c0662a6ad2e382e62a46608f76f7e793771acbe58fb4e5f7717c6ec83fd866af173f0f1fb866b291ccf2cf293c8575727dd5e980cf7bc027d7cc228c136faa1bbb18f57bf0a1eaac130e110aeb6dfa6b8fe86418d65f31657ab68b8591b1b4e7b6038fccb4322b52e359e76a5ecca8e8ba16878d7855a10d3710ff07ff5d6c0309706c56a6a902afe85487982a772c0704145bdb54177e812da352441e26a1949edddcdf5216c328127f109af056e2bf3b4deb4322a6f8aa65f764c93bfdbdeadc46f99df2f6b9853b2551d710714636c9b5168aa6313d337ea83946ed6ba84fdd967707ef9c4f323392681934e3605abf4073e9a929038a1616dbe8185959ba372f590379dfd1f71bca103a6a064a457070ea33b9abb9367cdbc8ecf6b7647aeb68e128777dbbbd278d9fbe44fdc1b39c0d7fa0cfcb17a4e0dcb43f7f796725b306bf3155a135b9e3f6f306ae9f5c10ff2d6054d8ee5ca8758d6ea4b18ff6d9bcf278b81e44d3de1e3fcd60df28f27cb32b0ac0c82ef6a621e61b6b7996898d6c410d0139b6dacdf5e39a55b5f207aad999375c0357c31cd2ea87324d4914104fd319ac80b7dbadbce50d25285c85a80ac91e4920b94354093fabbbea02e0e3290a5a8508106e45c658ca84c1fa64b38a03b622cb844116d67e2be8fea209520f459509b6f102d3bf75e5ad9c21a5d2ea9f3dfd9c2748626e3a565e3a4e50e661c4bcbfe5c54a99d8ad0454e72de7d94a4649fb3feb8fec69b3744b08fb3c10877739bc465046ec7803a3742876589bade0ab2e0e16f7bb8ad055df7acb3b617898aef881d2843d76ef4242d72d9cd35c9c05a7450406441811df958ed8d8730a8b7d64f4fc295cf094784f67f01bf1da40b8353408e026b49b946de14c967b07dda0eb94cf26da2d3e73ea9cc542af7a68c14b4db9b56e544299fb217b3b90b0e6bf258c0578ae703d0f8eb6fcfc573fd8adf12646f4918b3a35b860336abee7fda02779e9862a6615961c4bdeaf4c2a5bc0e711beda1eadce98a5542bd6a4987e5a89fd8103545cde654e6caaa1261b8804c84f4dd2ad700ec7d89232b645e6133e6b402d46f8e7c13e4302d5b6f3640f13f454c1c76b77dedfc698c2d8bf41add4b01d13977a7f834cfb0361f0b9a9e3012fc6e3afde027dbb0b6aca01f34e087580e6b73466bd72040641e4c220bc3e9527f256f716a937f416dc12c4ff059ec5d8b2d54baba10c89466815e410e42cf18abab3885ab05e5bbf073ae3f14d1776b8344f7061f17d8ff0a440afadca13cd534e67720e5d9db6942514c5c5b7414f3ac72a0a4470c936cde1d100afd95ee1a83bc81d1975c54a2db8ec8c3ae3757576f052ee0e866f51707c9bb07acf5e4f9bad9396b796a13a27f5644181fa2bdcc921df50a3f46e70fb370adf23f4562cfcc649740bc8201607a2852be375084d79cf2f0ec1d878a3c81a424b077e93c11ab6e0297f82a52f10897e63e8bf8a297c5104da7f9aa583e3c8efd6fb1e7aaf7a5947d4868f6e473e38daa9102cfa45093e993732691611594594a62475ec15750c356028e628e5481a40c18bcb592638cb8e86e53f51da1d33341bbf548a024e51e4abb2dac831683fedaeb53866a695f672eadc90d2ad1e612430ee6ba0b1cdf5ff0b6affc2fbde84633aeafe7c5b4981789480b56d0c4e64aad611a1cc3ea1b585d0707c8496f0f93f9cafd4210fd7c679a20306c1a43f2c9292e12304bc2ad00b6c022b1beb78a98af22ba6294d0934d6107034b6be830397c7593e43e2167c7dceedd5720b1b8a0fee37f11227dbd2005ccf741bfed83028627c2689178eb6b0781662778dd6f11b32e310c63a270f6a253c5d37cfc42d7474775a773ff1468f8a79a9d2a9a65531e63a958f19b58828bee0b2f0dde377fa2a50cb38705a3e8ffb3c791556267a9ca00b6d15ca38ecc87f23fd27b06fad0a38075b418361a9d5a76b47b108662108ceab8e9c102472870bc2d43ab1cf517a21e9978d95545dbeb4d71117ad9a38a8953997931b63f842b9062733e2b165f78cbe1be5902672534ffe9cbd150d50bd5f34c868cc09c906b6ef728340de0627e342418609aa1b15a25dc8664af1fdb99fded694192e838e93a18f78768ace7df3d33b8ed6a61477524d662932393d98d28b191c673297340e6720a3493fbc48e6ce25af92292613157ad03555fc66d0c47285b3672b503243838ec72c08d7038ec1057b2bacca0e84d9e90ac8b75e577c5691113aa4b54bea8f29005879e279139bf86521863183698d935eb24eb1080aa820697ec68b3577ef7448d834cffb8385138527274c3db94945d4601364f44ae3594fe901308424731156ce9d3746e01c9f96de600c4d6da79712e5e364f1beb1f799f68e22640d716d5eea8a66eac007249eef717ad118833ea935f78b2b8eb157fbf32878301db0a4de25784d0c8bf554b3487afcd12d4898814343ff5f1b0875cb858ee6b2d1bb2028f021880257e59f3b2cf54d99b7f3d7f688b5c9fc626421f5d86a1fff9588013e055bedd56057d42c493c9e4730732b3be2f7e47fa0d92d80ddb7a9ef267610c17f75a7de0846956b36dec154be5913d8098db3fff1ebb4f97651c66791249f25e7103ed28ea0929b0fb296ab538588f41e782ffcdf8ac8f184922322c1a78d7851c03ccdebc26e21ed44c2f80c9feb335e591970452a5374b5be939bf28307fb9e522d4037417e5b84cf332b22fc4a03ef3ee4b4a1958fdf808f397c2450fc0e77395333d1be09052f1478c807a2b6edd93f714ed8556300bb42c8adee3409d084b95cbbc1a928606d5a9c530550619c405e254690520d3faffedbc2b7338c47d681df4fa552320591015becba3f47fab4bca129880c45fda38116a1271ebf4c1bf9dfe9701470779b3f38c27e28ac5b8ad64f53390612700347cff7d2fc7f58c9fb79bd2da8b7299cb303068bdcd5aa2a85cc879c4b7ffd9906dd325622661dc01bad26746f9796be3300725f0af96cf3c1e5f90cb3730d46f33f1b45a78cd26f4586cef65b89f5f10f6233b945b10e04a9ead419fbbc68b5c968dfcc282311cb3d6240938a7322fd3b12f1c8527b95a77a57c94256785a19644f24952d6ce640ebffedb4dc2bcca279e0c2bd9608d0b85bc8212245db3c53c1e9735c49b9a16bea6fe0919e541a59be92c5fcaaeece57239c4070f65ccbce22f92d5a058a1e95f8103d17334bd2f8a14a1ae99e632e5626b2baa0ca24c77621ac8ac255f29cc30b01167397eb809879ca91b7cfe6d52e35d675b11cd26eb3f2cfcce35ce671c9e049d27ec9c50d49154343026f609bd7138cd7ba7dfa6825a70eba1b95006e84f39c6422bb7e93a0d2b9a664c8f9037f9f83c0dfedfe3b4b29db5631fbf9cbe40e16ecefb58f91b0abbd65d52c0628053b22d840fff5d7c74a257b360822ba8e0a8cd2377ea525a2e014a25a9d70a75bae5294cff5930c321cd5db6a2dca8f3fcb7b296f7e41ce97deee44c0588d4b739bef107585fef769aca674cb9460052e517737d6bdee23f663fc64b1772d984b09861afd7b8dce964d4a1b059a963d42053f94b7be9dec6ec738c53654327da48381129c0546c766b3e26226d9f38ecc7763fa867d2af4d6924cf738d9b7995246dc2242aaaec465819d1467aecac5909d379d793230c74db427a10a680dab8c7d40bee75042edc6ab2ec52f62626b414c339de4d325bea89076869fd9922e53c1515ce06d230f6c95c3d1ba57c778551af52ef812dc1bcd32cffc199a9ec55f842636c15eb0b4c3edbad15b80c5d3b0dcfc66b66e5e8f7d80c360359966dfc7b0feda3f57a617d910519d8c99fe013c694bfffcbe84176fa9e3e2db1aca929ba05788c1346f0dea5e5564bcda05bce306242ae3d6df4af3997610c1eac7f2a0107bf83298adec6db5e84e32cd55a81ab81248d64ec871df245bbd7816d273aa5d8674587dade82856eeb0c3f74c4f22413e7b068737597067545c5231a4e93ebc79117fdd71f00d88e964704481cfa5d2991e076f9107dc3c225bbeff88b655d3a3be5596c4c06662a9cb3a322181658d59f9f4bd793651fda9697301f7911bbcfb292c493931910cd0dd8b16b5b8d91c41a177faaef863cdfa662d6084ecf55b24740ac76d94f2a5b8662c57a74477c24cb3e7239983b8658759e80584e05fe231b84102c33cc37a48fb1b9e4d533c0e94af5759e8dc03ba0df08a4ae7fb590c4f2220a049bfe7b60a903db56aa87c3249ccb6dac5b0af116b0f7c94f5d5ad9d126a70d78c0a36fa170ca1f149f856bb699a897e70b95c0be848add8f62b55c3f8b61a3e622ea7d18fa579b211b9157b5f02aeb1e43100ccd62e8f2b33a9ac4b814588aab465155ff2776729039352a871caeee8b0b9b792fb34517a1b8d49e01123df0264146dfcb8aba9225ad57ffeeb3439498cb82f5764b6d32eff573379f46194a77eac712aacb155fbf2dc68f7cbc02c3ba8ad4ce1f35cf6c59386d404c32e41ada37c5a15c2321a1b22df8c00546cdf865575d6279e812bf5b1dbe55ace40777ab1fbefc9c5d5adc5442aa44ad2263f1e7e92bf23f4523015be554787889c165682567d77c5365345df0c840a590e0fe1e016bcca76c407b34255754def3010a2cdb104865e6cc57b6db553e154b47650952eed80cf88cbe57523f6a227781ef39f2ea826e3ab73922ba814dcf65be67ff2659c06035d60a0e55e02212ff61f4e2834c04d13a4a7ea078236058b75dc950c1bc91927534ef01567f8e4ec01e2a3cf5fafc6e4e588f95acf7bbeff80080c1fdaa97ba63beea662ee929e94075d2b79c9238b113dc650f5ae33f3ff60c631cf8779a59f376d277a5726c607041fe04eb2adf2086a5e5eef522560c5bfdc77f1921d87d5abb8cab4d17ec087b9c23fcf92ac6608649a71574ae611aaa063ce6413f431ee5f2e20b07da890814c82f9f7799cddd2b4f9aed63bbae8c59fd3cc82baaf150c3df58b23df7309a853150a5521986d5d83ccb2eb64f71a52094cf8df13d8d0cb12fc9cc1551b1adb011610230720ea397fbaf487d0fd12183ef4caa8791adf2e2b3593a5cb7cea14a7b375df1006e7fa3caa2d6de6a5fe6ecc283bd4dbb8a4da1e07dd7aba69694564f8067b9d3b4133fa7a8bbf58b37f0a067d242405f1d060cebd590f72efa546ee882490a4e6b3d65754beb15b3c972308b2b6a65683e65bbcc236cc9dcad9ef28e45c598cdef33e46a4fa92e37cae56c1240259d19323bcf84c2edb1fe596644a81ea7cc65bca4606dc80b13eaea72d060df4dbf4383b34ef58be1df9e049954d22ad937abd85fbd446086c9a25d66511d4a1a1969153345102c9893bb96c5506404a691b59e3ce9bb725f3ecdab964905cab2d74abb72ea66dffde0e7bdde4aabb138808d4185db1d889abb02d5e976d92123f1d02b5a7a9581eddd87b8b9c3e615c82e3262c9abc19a72970c8b50d2e0445d814012b6d10d8cd21b5a3a85d9c0757084d6affb1c204153c3813b4ff37b1c8fa08f16b8316fecf5b494a4bf13dc579552d04408b96fa92d2841119964011122bd5419f09b9df3f2a1faf1399ba0910e7ae8c8bfef67fea33f5e867a5d74b2858d67631da5d4f0b6f6ffc99d043f55ae4898f049c2b6c9ad164050e33fad158c5f4116d86e2ae4dda53f8d76acfc15f1f58240a0bb1ee5f965dab55b28879f22e6abfe51a6bbc5c536d247ac93d542f78814ff8ea6782e05330de0d0de0a6010e51a84286d62edb20d3a7f48b3f15fbe36bda0615dea724ed6fe1f9696134f8b11e0534946909d8c2431640d76ecfe0232fe90a339a9888b8432c7cc0848bf2d015fbadc043619a292e3a4a8caa3e42b1398251e3c6fc9db9757803163741861e7fb8b94b6b43eec5fdba9bd1071d6dcf520ff6cdcf4b9c40303b36f5e9ef3f274b5078cdc231b3a9add807089504c8d8a917bb7ec90ff3a8a45f2842e5cbae71425fc2afb3a4ab83adaeae080a619d970863896d5d8ff91c3151787142fa5f7969de16afce4decea5cb3b26ee53989b4b5e922793b7d5cb51d4925832689717804e60136c9b947f23f725ae9f8f3e15d32f7dffddcd11588882dafa8f2c11e143fc7bd90b1977a614f9d48ab5fdb2556bbc49dcf1bbba1af5fa27ab16a5210d80033b14be6f0fe1235661704b6dcf07fe57e5af0bfb3d5e80d8d129b9e381c308bb0844fc80ceea5284da6a05cacbaa8e64f228d668d3fb8554b388243bb392af97ad33cba85338bbcafdf41057bea9646a7e6f0e716adcbd16d46f08c3a0b4e1efd48794d8db5222890cfd986cea54efce07968cf9ce305ddcc06ecaf6e8b408e886e5064793fe31fa41b782d8aff30f2dd6999d0502eaa31a1440e51cbdb633f1c2ed2f2154bd68d30054fcb34266760eac76164c28ae343ec753adda9d93cadfdcf5c34338ad6b0f7655ecbe07df73496962c5b8f2065e3ef260e29d53c5f3da53161e0baef0a3b15495f40363da498bdcca1ea57209c5a5d7f6d8ccf603220e4e5d6b89c6ebb76caae73b0eae019ae764352a7b397a3394a3449b38b453a15ff65960d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
