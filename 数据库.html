<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"504c8337b25a167160691cdaa8f4ac75bdfffde606f5adf40f1289c797e43e33e1be2c519aabe6294da31d52594b518e460980287a04da80c9860ba524bc3386cbfbe7a132d56a6bf8cc8a1ed5c86415dcc2b605c5bc58bf5ac735acbd986c05df93573b8b160612ac42dbbce6ed4aca221d11c8e9803c1dcbbc9b2c9bdb15bd557975eb6df079581d8e32ddcdf89dda6ec9679d353dff0ff8a3e72b0e05351038d12c37f6f23a6d48eb04701a2447b383cd494cd4935e940a928884faaa75463bb6098b180156a5bf86452e74b3266c71c287f600fbea6d9f2da31f22501aa6eafe47179206f7151232e7216ba4ae26da1cdc667994ec4eb9c2518a5497922d57bd52240a3237aba7aa57ea586e24e31abe1be72cd9da501bdbfe742f450e5755bdd1a168662f3318be4bbc73f39ef7cd4a32df023fa2d2ca95619466c5b23948d1c76c82ecb3fa6ce936b3e6e4f92f1dbc9e7ed4481db908e33254ffb398ee89f3f1fa7fd7f8dbe7b11c9c0580ef063883d33b8e55e72c1d68ff2f37984cfdb47fa46f1565fcd5f5fbdf719b0e614d3fee495461e8488606d7da38a73f51f7f334676988d2219e6de1f66820be7a7901e9778b1f945c32c983965dac079a9d77f92ab75a6cd01080dfce74608ec8253e4129291d37d181393c0bcdae48291b74f3db1ddf373cea0f9f5e2355c827129aa6e7947783029c31aa753268c9c29e91543a5f468db66dfcacd4630fecee343d5d1a36c341604f565e645edd30d9f61ae96bf8e2cca660d8e5c8589e16ed76dbcc282e352900ea783236232a3e3204fd15263f5007463348efb6148f917a6a15bfe2b62677c56e65df150cd1973c33498b1e2baaaa6b73c8679a166fde4c6c6833ecaaaedf31822b2dfc0bed881e9dbcf5911efcdfafa15db6699b840cbb645986cf3ec47cdd109948ae2914751d9ccc7dd2fdc6272c1921d42c2d56a2bd1cdafb7e9a441fcb70259af8fc97e00c11ffa67ded7a21d3f9ff3e43a23ba2f7a830db6b499440816380b6c6cb6a8b94cb9dffba4bddfca61a76ce1831480ed0804a2ad011f97649c1cf745283bf287ae4db7b75f55ed4c9b874b79f108e142e00abada0e04bc2aa958561398ad6e544edd5cd408b25a2b4542e7aa4156afd00fcaa34e0476e88306eeefcac45eca01772541ce265932b022be4dcfed2a1cada6d9522284fa5f859b14e1f821a13007f14071ed0a32fbe5a94a88ad2162577e5590c5dab41fe166d059f1ef58464746b48d6978425acd9153179f175f1fb0a419d78d10c325399b27f3c28de431913a29142953ed71f3fced1d4b2b077296bf69ce72825741e25c45a8046e2c199f931b9c76f5613079c7ebe540d711051c89579d2bec9b101f55eeca7c8d21844fa5ea9e6797f103f432e554bb859bb5461b25da4f55be7e12ee7121c86b00b7a00a68bb9aca51f8ef649a1dbca78f04fe743804f7bea61dbe0137b6f4fc4919790ee09774df4341e633b4efad4c0854a43fdabfbca0a6fac7644791b4d6f0bb7898858f6a10568a89575c9942a6d3dcb92e1f370c58fcb74f06bc897feeb4d49df9379dfdf9a3434e956b4b7346c8e620a3f1cfe2674b4520410b18f664a057ffbc355770810f21d2635a561618f34cfadac8bf40f3ccaa1a44c50b0337445a7fd5fe90a665efe2e05156cbbf2dfd780eff4ad996810e5c5d5d28ab7538861b63cc00d5f13d04abd2e333d6d855aa271e963a5446bd1d8706f0f88d821bf08b2b14abc1b9a760f9dbf244cad51ad18977c31d30b95373178faf26add3c73105dfa0ad2b773b1864f2f0797f4a85bfa7dfbe37d5e6ee8611c85533edfe0e00a49d8eb007cdd5c9506f1afb6148c50c62ed63bce216dc9cf76d97694639560df8ee338ac8616e07f775297306526506c7cf810ac87ee6460f98fbe2c20a87bc8c84ec01c6434468f5b088785818426c296ee57b00aa1f9443340f6ec72aafd1ac28e5c7cfd6a6aa906b81fafd2eccb4134425ccd05f7776c07e9f1d9ed46921e4d88e4b5a958c1be468faaf02e80aaadb6468a182921f2bb38c90178dc2d8360fe6008b5d44787302549475324c3a1efbebb38f8874b32f4ac083eab29f9d43b1ded57bb1d48403d5f3ad99bb86e01951dfe6670879f3f12cce0def3b56e87e698af86e6d14eb4c0e49da5bfc233a61c62094813b2059c4cd1b8050a22a2ce5c2929e6570fbfb68e2813fc025cf50d8bc3c85756e93ec137c5e12a8ebc15bff7fa9bfafd8737abe983b414b4e01468b7e82e1c8e7408e032ebbdddf49fe5d44ce698dbd243b8c792a8ea65bb03e64d11a0de9aad535e2dfa22bd33c7892cc7fb24b30580209292ec08928d4056e60ed189e2a061f26c2c8a23b47ad44130918b12b6077abb406c9102c6ae1a6212fe8b422b1c1413eed698d34ae5ce91a9ae873fc196ae0977b2ac8ea347d89430d804a99a7b7d5db2278782f868fc28a681becce39c1ffd716136fd5cead72d5e2709ba1a01dfc0276c4e94f45627f21fbdfc6e938f3244eb8ab693983eee9e7edf9778ffde6c9bed5d09f16fc1ce257046b2eba6c28fb0c4566eb3333bf1a1f6022ec72167f2c835b5d8168efc4f7642bdb5bffe79550486c1e2ad526045e5f32e95cdcb0d07cc863644d67820b158a062eea2055823e3d69b3f9dc0f26a6d81c347c869ba27e357fbff2f8d245aa3f845f0072ec2997e535e257af6031c92cf52e52520b3b72360d961806cda7835d0bf72a2c11f1ff2e39cde46ae4a836f7372de95151d1ec7528add9427beca444780b709c2627c63958f26e369bf670d47ab61e2c06da99d2625a96915647a916a211225cdf9e6d512f5033b962f81700603876a875295b9b634871033f776968e2bc1683656882d241a9d207435187f483ac08952ff9bfa122691012702c84f17531cf1a667e3ffc73d103d1aa51c45639b9c7290739f99c80c1ff82002bebcaaf54b5438601ddc17271ca54de9b95d8c2a22aa0b41b11627ab105593947bd48107130e052dce8d05b9f7aea985ddddac27249310f0c2eef71f16195ef0b2d0452294d2dc50542fb7dbde50c67ec8871637d57b450662528c8c56c2e30be36cf26b7f46aa390a72ae61cb856169b62d701a65d23543a842a729333f488e486f8367da926eebe3a552746dc2a52530d3f7264f4a1e7be2de1077e24215962cc29387f70513691ddc0a14f6a7df8033f3b00320d5c1f3b74be75945057c0d0a2ac0acef5fc24755e671eddfe0f29af6cfb56ccc586a9c05486a3b8d8d4c8a5d6cc6e6844fcbf8d747c076fa60d5336ce8d7e7662c3c67ac7f07fb4ff482800dcac9d161f0eb8686153221fda0cd6f63c58736b621095fceb6be2341039f563734338ca2ba0377daf70268d86f0b5fb49afa4547d84fee3416fd4460403c35287d6f911973406467be437dd12d62686e1e8c6999a7644f0ec13f4068a090025d7d1cd9e05f456780021c24280c650bf9c93431c63c42a4ca42544a8a9d81736a21515c844e04d88fabcd543b28913c3aaea6ecf1f8b49f05cb97f41771eecf22c275493940ac2cbca2bff41473a27a18388a0ef13158f9540ed9289b62aaeaa6ca77b1b837a8f37242232d4c475d43c95a176b983a4a0d624bb75c327a57a49dbfbda83e6805d553ba399d8126e5733cebcb13e2bd000caa6559a977ecca0da927b730bda5fca752270140a3c574f891a5e90a37122fcbdfb577b0405377fd8e878fa4dcb0711490dffd7a2626d1c0285875130ef95ba45a974a559418e41ed631cbc16cc812cde2390f53237377c4f4976ec0635cbc898cba1c97e002a05f52db1437b1a27c1da445abe4c14e2865683811a81c5db0651c9f3c08ee3cad91ef8cde34a3cc72c068affa75ba17100fc42d50af93c0bd96d856431b5d4b1b6839b4c03ff411094a557ccdf9c4c4bf84b8c80afc3abed0375c1c3fc06cb74ed5fe14ecec3ae91bbe2ef9234cd9a1a4304293d83d1de6cc6696b25c8befa96d99ac186bb7a539747f49f9460e0ef4b5b95f1593cc32a8ae01e4e540fabc6982d8f0dda78536751e1e4fefa6ff343835841df5703fb8b0bd26ff1e1f1f93cc8a0600ae1c468425acfe403f992e6fcd1b1f5414791c626b1c8b60beb8de124f528725e20ec70290daa0bec399dae03bbc49c36fd9d0e3fb3192bd17fac59a478fc2524a493d32ac31df2fa377c4e31792a7c089cc31bddc2f631899619eeb12d4da9859dec5530167e11c84a45cbd06baa55efc0bd4a2861032959070ef4882fdba5f999732d6ef41a51c12e64cb8b8325019e550e4068609d6893c7aa76b66dba5a072c971a0661bd7c7c5dd6c88082db72c3b6198204251a1eb43960f22e888c3c4b5165a178c047ecbbe47f35b2248cd6762e9cad5c8110d304dcdd171918fafb3669f44593eaac6606b47320a72e633b46ba15e0712c48cba59bbc6f9cf881e0472123b38192fc6d81ff44b58ffadd4fcddc5ad10f81a3be6e06264a64004007c807cfeb3288f463ee2edebd96325ff6ecec63f37b884ff580aef32370fb39964f9b1b34b9dad4fbd29883e96e6ce19e01f2b62943b61fe478d477f70ae0be5c0d176ea08c5ea59f6123ad107c743b5a5b9259b6c5052b843178de5d00d58408b08bdc2c52444ee182abda15db9185783a4d6af37721b8c686a5a69961c879e5a2dab72cf8d5e5dc463226f2850d82be7dbc3c3dccd6f1b6e23cc33485f6ee1f8f006847235d5f5f57ef1ff3f141ca24c6642d93de661d288c1f777400c11648b8fd79de74a085244535f943e483e166a713156897c2c817cde01d7bf756d33e3eaa98ba1a2b37134a0eb723d9f6d112b7154c28d41d6e01c3fabb6bfedd727dc79e7d6f182cf31f551feb6954cf93b39a01903e64a602587ebbe5b44b94375e685f2f2978dd0f25c9af045f352ad2c966a2ffb99b5b9cca501b8a5bad515f92b39f93ab1c19c83a09b770f76d71bcf711e15ea6c52e6ba5afb5c6fed33029f3983a10dd7e7110bfc0e4ab1c94c6a60430c6ed65470e6702c2fccf314be986eb836f5022d63edb95b94861984b475eede47cc07c883fb04371b202f465a2c0d11cb4495bd9077525083a4ee73b2c767a34ae0d980d3d644dee422399673d43e20f237367f8f33d75ed3edfdcdfaa4113968f39ea2f529da59103c7e844c7918533063b057d2a82744b1d7e06bb86b4127db63422d73e6ff22136e4586b9b52afb966b0fe464884f9e4ca22ed4ca252d6b76926a8e37f45e45c6d5775d88a202c1f7834c9271c5fb6906ff1ba0482cf7b0c51f4513f3606b4943ffbc3ca846f0f33017d27aba66d7477f94b9b9530337ef74953b3439b14115fbf1d6c48e07600b1758da88d6c4cffbf9bd7973e369b9ae8330d18e420a1865be061a2132415b5d518a2d29ddc47043c0aa239bbea89a032ccce49b6911c138ec2483c78dc114b906404d0dc715d7ef4bb073aae5c48a9d9f0f760be005380193f8f71166b67507ea9eb93544113f1bd7091432019dfe6ac2eac8d6f5cced1a370b0bcd8d0679b47e96d66365f948c583ab5aed59f9f526acf4164430256269c91864cf480dfe2859c0e66117b867649f844fa82332d84f70f4f750e4516155dfc3b2da707a4c93d51f81cdf9c398001defe9f5f77e579ebd7cc65debee3b485514c4a2eedf6cb3502a0f9badab6b58d933220d272a028a63182a0214f3d9e78bd5c2a7a53bf50b897449f261c2bcad6ea0b34d8295d4da04b897f24e39ef0053a759ccec5b3c94f2fe0c42046d87266c63d3649601eefa0e4700be37ae583650debd7426c8202e1ce68db9f49c81999cb0bea27bcfb0ea568765bd29c95ca3c009d2f2fee344382eb0d9b6fd5ef72ef8bdc888d3171f08f6c98942c092d7b0ff1f1cc23152522820ad0e099ba4deab894d066faefad7b6d2d548107c9d4c4279687ad368d36b9441b241784024042e1788bd3da2cb2004d7dc9e2f0174bdd2e6f3325c53ad42474d96fb7d5f574ccfbf838e50096eaa0a3112f2566a33ab1bf71032684679228d803d8206510d80101fe3a797e19a7182aaa1eb27195ef01a76466d61c41865fe1d65453b1f308e99b76050a47710029fef1a8667a7231a6374643b00c04c44f1b03e589a01938149f15f27797d62f279da93d24214707577edfd25cd216896bf4e3d9058015cac0dfde9874e00f29f6cd5c55efc8d2b5da823e2a90b95c98cd44878789ebec2c2e8e61d9a5407f828e697420d27d691db258470dfac515b8bccfbf1fd2861f99b2d33a303b7f42f13086b74bcf45f5fdf6a1d66fce73cd8cb890f0de40a5bdb8e79a37d3a937e86daa2b4a2a63d4862f10c0f9081a0a877e0d5031e8b3f7feffd0e65d91f917b4a8a2e85e0d3dc2ebd219ef4fc965935718aba7f8b1a9b5d14d80debe46f6b0bd625a10ac1ec1a4ce9b4dc4fc4ed7f34771bd901cc136984590fd8f959186469a0b1a4ddacf3d963284f8aba5b53760b20cce82e5d3cfe3d4af684ff4634933faf67511fbc161d0170000745b4ef31f9940bb079edddcc960632e439c162222e1ad440449f0709dba629c702d7b2c557eaa7670d5ed11de281cb90b869f6758f9a76b8aff5d6189e5c6930711204088e7041850b4d839a4e455585f7d7107a6cbfb565ad770c4b9d5729e1ca7ebab54985c902857e4c314eda34700e40ab982c88d043abb3c481b429d44790dc82cc0e5d5275d6cba1fcce9a4c0ed5e6cc7c3692c34abaa02f265786db24de9ad01fcd627e55992169503ad524c5348aab148cdb8f0046543304734edf0401a186c3dd4f2eff0d266344cb62b49b75b40761e628e4986fc16c651b36840d792b247d19e1564b79faa58d0a83dbe1bb3912f4957f1ffeb5acea87c89b61ee18935e8732ed77eec905ce38402b8c7652e32122fcf1c66f9382706e18b3a139907944b5816669a67ffc7f01379944f76cc18af5435ff2e94710dc2256ed41cd3a1b8d5be689316a3d53d0f388d2602df64c52ba41b68a46c189b3fa454319a559789e8bbc4dc362af6547f8cc1635067017cc96be1bd9b2fe061f699d76027240233fa01d925efe201b63bdb652eb44ec39dde96d072a8082f31cb04e7d0f6ad7c1c9b5af8baa5c25f2b2ef97a7dde40453cca8d8153b38be714f54341d739733b471e8a50efb78fabbcb4a9dc90c227098cf57c35ec23cda37e3b5cab23cd4b63737ed212455f414ebd49fb2d9f76410449356ff6e8da3f5fdef85f49cf9ed46320c0d047615da4ae1d20e48e0dbe485b81fe6855817418e3c61b526ee87ae358fedd8192899528ca8d8e6a4e2ef4d645e8b34d7989040800ec12e88cb42ce556fe77dd1ff8975d7b140a8b23b265ab36ecfad1cf2f345eba95680e5ab514a7e2e7701d2854a621436bafce76713fe329b347808fef08e1f4e1822c71f03742a2f84f12947c1f5f202c11335ec031acf3a6223bc638f576dd6ef374bca6348ed615bd2dd4f293000fc9129dad05ad19ccb8f69d5a796b405e2ad50c5fe04129f6f47965fbc04cc56519d6e8ae44324c6f1495d7ff2e675c105cc0c465ede0b910f8ff8354fa2b77645feaa659f589d57d6ecd0b1fd74e84763323c1320c8b2e35586c83433c435f11f74f775bd70966281d2e86ee139aef04d72bbfb25bf59e3ee4c3dd23b06c562ff875f8063060074564a2f386ecacd12fbc29a3723f9b8ce2060d3e96d16fb68adb15d2344f8c1a4c085c74468db735875a8f82fc41c73818435e2cbf13babb1249112112c56fd39df2777183305a8d786d8e0f851ab00fd06dcfe14816e51c694e549d420a87c6a0905a7ca3a46ddebcef47c8fee952d5e8933a79f4b763e37706b8bee339aaaf919bb773efa32dedf58ff699d419c6e02b2b1c23d709bedf70280fed2912b29d2ce2c29d7f7bddeaf5bb21314443bb23ea6550dfc7614a1097fb9ff82a75d7775586facd37ccbe1515a44016bd249b1cad432bbe754b670600bca09608c0e9ff1665b1db918fdc600c441532b2f5c0826fa8f978a722881344ff4ac9dffd4c410b5b36372c4ce0a50fbe36232e0ff6f7460aa2d1cfbbbc3b5792ea7d9647354421078ef4952e490aea366fc94018cd5ec7d3373a48057ffbc1cbad760d435036695ee15701c5cbbc782c2a36131f6d186b03b721044a4878a585d489fd9aa58e13d5e49cd5540d9e63179d35d5b78950d4d7bc803f575c90c675e12a0f817621ebd7894781fdfb3eec255e4a7be08b76942b1750dc2d051364ee4207639bf15c493b600e000076ba0900340d46181e7f4fbf1d13f2d6200bb541ad5fea124598cfb4438c15bc0e13d7f5cef2a7c36c215fdedd329079a2c82172942b1f63afe62c4772f6bcb5f479c163b7a821ff50ef7d564f608b6558fa45d46c6c0e76b3321d467e71b7cd19bd484ff615be73092a3eed1bb22410b95988337fe4aa55c2c7a4ce171dc074418db5c0056ed0b0c38a27359b1d4539a752a84d98f9ddf51f2ea341493be8d49b171d4c8dfea671ed5c7ed5e46aea80132fe6100948cc73a858e4527010c508c0be5e72a240cadfff0f126eb309afe438996d085543cf77ae994f879d10b52a89f9f1c82c8fdc447733ffbe629b374dc08d3f972b565f3a3ebe1131e7d9b12cf4b4ce644ec6a7248d89ee8517441be07ed43d733f5eb3728035605777ae68364bb1fb24379a86f132fbfb85c24d2b7914e15cb3851b72344a7e908a3ff1250896e0d617cb1346c9ac05388578731c94cdb0d18528ce9c3ce06bee902c7e4dbd7dd62023a4744868c91b2b3c0173a7cb8cc22929a5828716068e99950900a1f19be683ed2d57d5070a55ad851243624c04de0c6a330579cc381b8ad6df0670cd3d337ae75a1232079ad91ed0616a141723ea60403aa674648da795468aa08e1035ed057927695b2c7661bfdbf215c722d23c51c026ccfd747ee5f358f6510ca0275d5147b82ef409af35ff81241a9f026bed9bd8ec9bb7adc4749e4e71b0381ccd38cff56de7c60783918ea15654253a014ed3a2bc06b80e97292d286d71fbefc5d52ece0046e3210703bd6b1479600476169d3b9e7c2b6cf8b13d56a60663e47e856ebc7c877c0c5d7d2a9b01a644338392ef5709f053ce741cf1a0832e22f181693a1321a44dd6258444c34aba269e378e3f1a9858d5fe49f8d29facce97b0762a60a059060dcea28297398f14eeca5fbef9fbeddf1474670f1651c82c52987c8d9d34e59a8e9040d3fd44bd397869631f553c9e98d0d491f27cd36599899ade3a2f31b7dae82d817100a95bdd1cb44fa1944da433af60cc04c30ccea7f05baae75d45060bacd84c4c5d919d2990bc60dc912d80de9a3cf43cbd2e2b40acfacaa66443f38c22034bf8ddb77af3b242809d435984a59957b58b2e8420941367046d8b367f5ee6687465978e167b1ad87389ecc891bb645de42819037dc1ff7334b71b780aca890f8e7986809ef7fd3aca8096350e65134a9212575680e6d27928eea8f7ad402b397a0667f521838be1cd08262e1378fa35be50d1d1ad3445f8efc715cd4cd4860cbf6f30681d871fe7d8623e12cb9a92ed95d2566ab1a77396919823a8b1549795d5eeb51b152c69f6354913b3239e0ff07da52ea73ca8de953cc4e3f4b7c1a4b57e46e6eb0d026323e4e6dea4bdbb21037bd9aca95b8a886a241ea0e30bb7392c81f84e40a0fc1601b9497ded6e00406f070e7c0edf22bcd54d0ab12dff749a9e1737b7307709fdebaa1dbffa106c738fc5a9874f09d85cb9a98f20cc9da043fb25bbacad9796e555cb237ef75cb93ea464254f4d4f78431280dc216bd5e56c77fcb4a569959ae99fd1c68a35fe5a6815c5a5c0420ca11eeb8f9d4a8afedd93a89ba21f06c9d8d2a03327d0d90617d13dadf10a8829a730c868b9f04ad847bc8763456fa5ede6c9048a422849c80260dfa915de6efae5888ce2307244c204c6694c871956fae5a175556613a339a4ab296efb2c585df6440a3c13d03b7a4887dd1d484b125b77900889cf2958dc65ed388d8a6eae18b42cb85abf6375d2292bb00ed725df44d2ab6efe0d5bd20149c7dd902cfecf334fea7a04b570055776b772b582172fda31842c999d09da9ddbf26eb82fdf138a1d123346ec4b32f8960c556b2fb0ef862635c41e4c24c2fdbd7973e8e2f83ab43bb74b74051e629ec5bd29a18f2103ebdb95e218179a193ac11089abbf1905e9a4a2106098fab08f30cb01e1cd384ec6ea39bbb07cbf3a3734a977a00265bdfa30897b4a622e6423e61a9f2094e120d34e2decc0d7f2ef3bcbe8073bd539aa6ae1e90496ab53a26ed2ae1aa396ad57dc4255c2e51970f7aa51132ca6601559063a1e2adc32ab768efa21e632086602f85499e14fd40c03715cf917eab6f003f423306cc6c335d1f26616125de17d151ecfadcddd7d76f2563806fd2d059247e87f0d55cc413a360d25d585a96cc31c0b360579268a34fd31f75a71ce9e6a4641cd04f5db53f62a35b6018934d4230edd354f096b5879753b708dbddaf9d7d40e6cf50d78ce33eb16cab3f94aab36515c77879144e3976a0a7147e9d57c66570839daa3c31492941b4f725e2231a523d53b2a36d4c86bd461b035d1e46ad15419a53e80d08db273fc7c979925a560e86ba5441690c6de36767bc56c2ca97ce76498d3c039d6dedc9e742691431f6c7842d9d07e462f8097e529e2b84200bfd29037da58963b97345f2a646597699915b5d49e3c2f7c8e1a45dc55a4bf104f9171d8f0e82b66c3f0e5b4432eb008c9c4ae9e06a64ec4b694e6bde5ea992714fe52354310d98b68a2cb96c906201da619560dd6bd2934690c75d8d86d1c234fbc714c49ce29f4fd145cbdd5d6dd041bef6b8e93a74ae76d475ff93a894f64393935577b818319fc6fcc87c6f4643b5743097a3a6f9819a002b37054ab17a86215e595864643a338d51620010bf0809bda06d444f910cbda0ba3fa8992ce7b774e9d68ab979f0c9c8c794c1bfad264ea02f095c9f7988c44448791b8ac3a5ed3f8b29afeda646d082b37cee4680c308f9b383722f80d2f3db6539da0335a91fdaaece24ea3226474e86c240a476e359f9205a19ca3cb61c75fe8d1a7773415424792b80f65df0119b295d022b20b997706490d85d2db3b7c97f9a74476288e1b4af6db101a4c473215077ea1504504b839d409f3111942509464c23a9d0a02fb7b3964107b1afc3584952485edf1847009b812f11944fcdb7792b8e51f13d1f5a3859205dae525ae7d929c150d41e1f95b196621acb3b21cffe4c328fb2ed382d9bcc5aef1d60815088c6fd7478d979acb69077ba980768a24aae921ff7817729ddb0876c516869be8a50236f6c5f68530fc7df178e64952cdde8c5cf94e5b8703c656b41cf8d04532c80e1d33f743a178627c317670611eccb11133f24efb55913fed682830bcbb7703d1c45c3f78f8d8562ee5c081bea04b01a09f1a05502691d4941cfbd547eca65e648f31940c8dc83414134a63ab22b551142878fe5f97c67977cc61ec6f15c209c36998c14db78a5d7c73f890d45dd96e266c5dd41a1cc06c365524ca4f3cf6d224e96fddb9013bd205c6cb0ca3d3673d6858cf570550b222ae205a6386e21b49a4d0f9cbfa935b32d4bbd40276e3824f554d632b835e6bca71d9b1168be5c57415fdf2f7f667d6cda68d377389b4791746800f33a8374426275436b589e2d6f0a4bf8f0eba9d68a4bb81e3ac72a1d4c50b82f8e833853f6bb2092847cdd48cda2b05c972bda12926929a19ed380a6eebe2a1a3a427dd95681c6a767cc8cc309cae9a841d1e696e861311f4ac4ff1cb87b1597c000aeeea173329806ce03ee1f55c8b88e3632492b282f1bbbd8d98e5f35496ce930c309acefe0960fdf4679dcf4a3d0c8b51f8e1f1825789ce163eb2512bb2be4d544151b519b41c04889bc788f3343c6821c488d1d560e8dbd552e59880945c809f7d17847d56e35f0b1718786fa1a0adfef407058dc74fe98f9c29862a18e58f5e82e7669b0ce6e5e3d1a44468f2d13bbb934fcbeaaba91dd57fbbf5705aa73a63ca6145cd51e6c833e73b4150204d9433dcf54fa9323176fc359d627ef711ac4fc977bf37f8d2790f5a9d172cbeecbd4a81d7f4307553e7f0d6a3532d2699abfe52a144b9d1863cac719f907e9d11b6db9a04ba0287c0baad86ed29e75c4f1ed7afd73c8feab4ba9ddcac42ffb242b99d97407de447157cfbb8f338af69f205f46cd3723e863be4124e1199f10a62525b864e54494b27d5052f203367f417b915705f528a823b451fca9b97cfb5f7650c8908a31ba207acdf8c0c71a411b2e4c519bfd77eabed360604ff4e90dfabc044bf7d2eb5e9110c0015160bd61fb0b84afd48dac04d62152aff180ac345d4504e76cb931ce697dc70bb1af795ea84b13be1a6fa220270a1246882e9a3007d633d33ebe763c469e6e79e0f0fa0e05e729718f2761e0d275580a9e270e923d545596c0c3ddc2231394f8a33b6b309546c07b44aa0d9a451b0403bd2a2302a982251f3cef26f9b4a8b39f46b5c587f43de5ae018e030b0519012a1bb6968c82253c6c1b2ff249fb50abdfacbfb641f72988b0e1f93b0b71071d6bc5ec8aafd613b11b58d405b7482953c44ae5305c41a2223a25e1ffae8ccd145d78daade217854eaacf5117421128d6aff0a2f8f83bf4b2b58d22bbe4c72f9e10f31469968020af1f4676c7c7ea86a57fef75ca8fe464d69e6977bc41583d3d412a05f2c9aaff8d5ae0f14aeff0603565fb199e2f9b5e96238d44565c6e87f64be8e9a40199ca39f827d7c752a6f03595fe37230c7a675e50f21b2eb8fa246fddd2f09978993922364245583e6cb587518a0c6dfb36f344e0998255548e7b9cf519a066169748cc811e9715e5ea34a6d842ba081b0e8861cc809defa730a5759071ed28ed7a17e6a76d297188d4e2ee052b970e152f24dfd2613d22cb8c82309c880134af6f3c046c118b2e4661a0c82bde437d929f2e7caaa1e2dc29696ef9db995ec86b5419433c2131d92ad9745cf21d6e9c85bbed3475377fbd6f032a3106b75ad21acdcdb5abc536158ab7154171b0f70c5f300cecf88515253d6bd7aa7044d3dc503f8ffe6054faac1aa3cd503f64927f233be4408571fb1e1be452d72c2677bc9045347adbdb7bad24f693960c83a02c0df60adf966deb959a8cccacf394abae7db62e95c2161dddb8b059b83ae2091a647fdde29a381366186d2213bbd478a57da85ede1254a102616a59fa8062ff56bf44d893893532830639898685cd788667e1cacf1163be81289d81c78f6c2144610e91ce834ac1b3c1e72d3c757ed8dab4bcc9a2963110627522576df972acf3e931b7c4b76b3bb52b06573f8715ebe44032816e5714c8919eb2179efd360a77a7d46b3db4aa09f617ad4126e03d61ccbe6b03deaf81333c5024a8d436ff6a78bb86c9171aa793950665b57b61f15512d7eb674f30d61dbdeb48e26f7be764d99add43c7bae2b5e850a26ca71429ecca4fd5e8d5f34c7a391436df6d14ae2c85f454eda184079950599ed881740818dc7d5ad91bf3e663859a8f53541ff234e06a5df5bb04983c68670831c51b06e884a7fd4407f2783c2c4d8b447b6828144db56ebd9ff0caeecaf427715e75326f533ef379794fdccf5ca3e2c484ffe0dbcbdc4dff4e7c4a22000d6ac72b63dcf41c515c4356c8d0cb4b64c44767703327963ff2062a7d75c00ab418c37f5ceba95bdce9b4258bcc50f5edd2eb16dc756d0a11473219ab02dcdb3fcbda5dcce539f1da017f7462a3bcaea55a5d1473cefc6c2530fc882f0dccc4661933d4b0ccdd6f4fbda861cdb1f6d20f4f99999c8a415756e29290afa02b799a6586837ef073773f25190e021f686d82d65ff87d63b29b1373442f48116d9ac52c8fbd56f85045d6c18871b1c7dd03b0796e2ebe10579a05484b461140ce9b0dd0958580b4b629c277e70803a51183ce37bca9e5793136dd8db997e1e9de13664726dafdf307a18dec509944b5cbf532a73b964d932d160903f79cba9dd3982828ed59f7b13c4de1e5628c45ab06a0f7d2365b2a8935b329beb1e25ceb913131db8099f840bbd04f8a2fa1e9f5c167b4057d394668a3b5ca988e27f9bfa880fdb3a0b43090b3436983df52581f765ff208fef5544f197fc0087b7c4b4a0ae1bcee80b7766dc3d1f5a25769b0a1e53772bdc68f06c0f1eae3540eece765008bac36cf40c40c03993833eeb228c601e6ce84f634b3be2752f3f39e74bf4cf8ba72572f7721d670ebab358a7b805bf80c984382d15bbdf71f25c6564a6bc5b07907a7e40305966eb64c222cc69a56ac5d0ebb7e57890f68d8ac531c615d4d88071bd7b48d15ee871246cba2108b74d23e1359df8462e6a585c93f9f97072e7178e44050ff8b9ebb836c426752a5b422e847c0870c3649bccf9fc9cd4aab7d0145cecf05a159fec885c3b5d23d5828d20ec85b56165e455e6f01661497afa867fd7081eddfd63830e0df20d85e64654abc3a7859346361b6884033b0a4797ec8a95ab14c4d9693267ed4e0ba87224870c421bf282bd34dabbc836f92d954c54e4c33fbeac8667d88565eba80d96ecf7c06a8a895e52c53ce3b127f26477a64cc08944f64107ad28b9addd6bf79c9434f116ca563c51fff3302e21bf9c61c5daac30cabca51affb7c68c18744af4ae0faddd6e96eb20e510b4b408126e3936504ed7a9687659fdb1d3fefaaab4ebe9f34d10065c3d754f9c4be563b7240b2b378cc20bf47f3d05a95f3cc6c5dab94ad092c9a54a82134454a8fcb2b6d586fc7b3c625bcd57d4a7bd19354d0c221d0b34cd80c650b46403da5df90234b9fec2dd638396d256122675810807fa868b81d06ed8f5150858f5430c023a5b84d7092dbe12cc6ea1c64059e250d416c9836c7e488aa8b247fb07080da988a62f6dbb6625583dad51b50633ad3de742f6e13295ee9bb593946b42ce60527bc4670c02362d355826ba31782bde4687acffda4ba7120983ad72bf7cea088b06547f42d74cbf76420b5ab8fbaee855eb67becd9705aea8504f077b0bc088b3c790178fd934af09e70d63f471c0ecd3cf28f2139a7d2f8a82f9b9f2f08828cc2188b2024c632e47b27421add5939d238d64a5aac513b0578d3c88dd1a46a1ad72a761d938aaa8e3391186046e1f228c80576f6a30b3e66ed6ec0105d0bf296bb40b6d0a5b17c7f20eef390de9c53a8c0fe85598285aa1aa22514ef53b579400c2a0233b7b2ee5cbef2ca90676752d4b4780bdd2c8db56452f50e10a635e4fcdb14b43d9fa1240ab49da6cf3fb50f431bfd3da32ebe3821f2974286789285e85f456f971f8df3a22368670dee666bb5c0beec8586b4222aba1f91a6e5006895622aec0253e7852377554396ef5d3c0273f5e11c7fc53ed71b18bd97bcb44743d6db0cd97b2da65a9992af2e886aba9416a73ef56800594bb5c854d73b7ab1993f14d863156f499bb5e0e5b1e2e2125b2ec2e35972c572058990fb641365093338deb838186c8e444f7e1ad9a65cec08a5bfa73e57daeaf3052b1c72661f0eb3203fd8b947ea514ec75427f000ce49ea70c0640a2f2c7bfe6698ef8f240f6d81ba74734de5b165da76f82d7aa367968e666ed927729ed3c58ba5e9c87c403616b799c09bfe9ddd2de63d6b6b52556d4b03ff562cfc06b015f783b80877a560ad7d48354f246eea4a67deaef0f5dd8d6c8378a9dbd2523bee7e6f7346bc83536154ddc4f5ad45018792f49f2b945c46ae8cf7bc947f766173e7f10966fe7ec716204c894d8f968adabce03996768c50c6c4b248ca3417348ff3f6909d7c4e7094f0fb22d22be7ddde88144b2903f5e4fdaf995368b7433e36327310f5e9fb0c1936778e9f475bd703461be98821c3a2abbde57e3daa02eb6ae73db0877cf4d0eb0c8d6de51db83aff994e30b45ad67aad38e3e3d6e2bc79cb56f5b2149ad0ace35a79fd5fe4f9f21bd03ee701a414931cd7c8bcc878cda1e583ef3a7f64017bb8d51c43036fbd08460fde8551a1147880fb81e2d9e934bbe82ee92112743a885d342a6e5fb76d1190ebe082f88e6dc8d5fcfe77ca3434c9f45ec97df0a14b41b6a2472776dfb99988d1af78d96e414a495906377325f5358ff83f7b25a43787ab72f863aa80cf63a4b224628210f866794e6ed63003b5c5fec33721dc2d7774efd6b2cf1964d25323f1a0f6fbe2699dad2b1973d82f20df34595654539f462a1a487bc36fc2f4b5049a2465ae42895b85d4a3cd5ecdd49db02a364d5e947699aa019379166bc2068d6591d566ceb4997b1d040e48ab2b9a1a8ec04a28a7af29860e4e3f9011c3d9810652eeaf2938ca26b2d316702601c3e31732a65151df629f4a09532fc209d86f74807dfc0e9e692a4f1d3af13d730da0570d9eeeae7e84012d40a29599e8cd042e272bc7bdb4bc10c8385db9b02815118e3ee2a5913534ea57f10c930fb2956fc2965cf67fbd0f980035e7c049034ffdb4f5a67f60805ad6723a140d86e0e3432672ed7d05e80119fa8386bfa6cb42c0eb817e361bc9e91e28ff08072f3f7c5ef2020bef0808726e5d50cf0319f8de9ebf9f7a8433b41b1d1ff65a39116f136916c9d068e3ee29118897413d576028b71617d5ae2615e6207fbb6d5a18b35137a4efaabad7b3644c98e44978abb2bcac244873693eb29da7ebe4a731f732a90cb38e3e310de0e4c7779dd74e3ff4993b8261b231cb1c6098d0e4d9b1b465baf20e1da630df6ef6f862a0b5254bfa9a4a4d7ab241696f2e4e98e5c13b33e58e96e83ee778fc5a6ffe2ad173db91b490112a8b5b81a5b080bfc0622a9e7535343adc103cc8a8f9ca140281224e20320c4c607cd4a455160e8488df7e290309a84e3f20625dc25ef3f6a0a381a16fe8943889b6dce16ec472c369979ec315d9865fdb44879191233a26542fc2206d1417b80536c1723329627318d7511526ff16dd62b41292005b53e8ab5305319c64fca05b13f7193f2571fb9b9624ae0ff52a6d6efbbeef75f990f96c3ccbe359ac33bf730ffd3f5a855ed2fdf7bf54181f6724df1d70c82792ed942c24ecd285e09ba21e2eaa14aa4b61ebdba05c747c915e42d38fa26ea0b99414f38954e8186c3529108914bbd63f1f82206a884793e6f8ae67050781999165bab0ca6bae6d75560a9bc511326a12f34f66540db438378cd7fe673b1b5a566d2e8a227ba352292a0f6e1eb46a122a6aec90650ff5998086bd3ad96579353a96fabfafec4f3ad2e5dd936ba3bc61e6eeeda4cc8cb0d031e1a8ef880346a5b91debd3d3ef6b153fcf304f0d12776191d52cd59b46b1df4381752de8584f05ae891b483d3935301d440c00e20173c20310e6d7ad7b14aff8abefbdfaf0a8399c972bea83364230984d434cc7dc1730fade53b9c9443ee38c279102ef919423623b4b9e653c3bdcf22b90ad1688c32bf5257d74015bd6caebfbebdd5a977aa030c5af3f0be0fb403764086b05af26134607b794e04a93cefef81dae7f1a9c1fc691101281bef455e48683e44da2c41547755f17e880f2d3955680471bd9966c72934512f7084ca1fff5fea551302139fd29fe39abb9c3f214cd55cbd2e7a93ceead12ce60294a01bc32b0a4bb117cb8d5008b47bfb72ff440353487aa86f8b0a694f562575f426cdb6727f3fbcb4eb5ec14e65b964d9275b7815e2df987d928c92e91d7d5f2da7186bdf4105e08e22ae758f92b82d9c780f669802ec74ebdc0e24090289dc5789d1e6e6a6b274c1405b124f87b7fd56b3b8c0633bb6fb5c9c5d20c04a2e2f9e67e38540e4d226ea33e64df25435ef61343072e68f1f728587b330866f4691342180a67404e838006e62a1a10b6a569848530f81c403b5fad185736b3329b829b771e308e7bf18da3abad3bd5cd874b495a7fc470318f49672b503de59ce9572b4d15e26fadf0cb20645fe61fb7618448ee22fb56bf687faa1cc65b4c68424c2a58ee0bcbd989d5a0b78690b4e69bd9f16d2b6cf70765181b00b93733482359d400d52d76afc66d4be8937633841cf5196947029d9e37d263c6346d14017fbfad330affd02056c9825807e67c2ba1150d2b1c8d6b20934b1ed8d2d6c538a6ff8f2be857acfbbd5b2b01092727d0d146672e26eaa1931374181a4a6710e8e8b132b51a47e88eb13afdc1358d2a1daf03195d93e7532c9100780df83d08f06660e92674c77ebee1a9326ac5a3b2e04188ef5d7b4c6d39dee267c74851369c25566ac6fb260d7dc78cdeefceaad77ed017b9cbbc2fe9b54a14f202941a08f73bb2f590ec1d419918457bb0f502e798ef373cb242e2fc19fedfc6137e92487d977ff1106bafb1464d2395818b449b6c217e0e70c36d9158e1f50042f68a55839574a36d2232f4db0bd7a6d1794299ed86fe808506a7877e20312e3a8ad89a8103045f9221e34c7f44968143f753b6c35e4d96d3643b8794a74d1a1fa4dfc273c62e451f85aaa6c199712ed727d7b38aa4b30f6c9b7536ff571721dda8fdc20be45ee35b1e5ad57b30f0849160fe1fcb580cc5259ce2318b48015bd2e59d892d7246611b3412015ff93896fa128b45fe23b095c76b8a3456e34754efcd52618b6e185c6e36323cd51bc8c7d321ee86a6d2b0a11a724f7bacd9ff9bbcd6237bd6c8784aeffef4f40eafe501e896f2720fa294ecaf58a4cc40e6be90e193d6cd5fe905b9911c3fe086157d6c49a27ff5b3ed6f5e335c044a59d48ec93597eab781c6b19d3e77ac3caf8c3033adbce0f28df94e5245ce3fb82b46b0c5f8784769cb6cc94634c77ad849d1f82e0de018fb2a38ebf65aa7aceb1828e5c665492a8e45246786d47badeac093dd7af67882fc93edfcedebf9ba29ef42f3c94f893bebc37dd61b17d1d8cda2b6a33bd604f599a7990a5d88fbf348981edbf77a12787b7ddea6955a421823df54685b391be77b1d78fe1623a83cf944eded325d69d11d4fb7f0c19f2bffebe0f09a67fe33ca3dc79f2d8cd7f67d47b550870d1813f17b92508b45791a35defed0b591327eee6ea44e3d79197be4b2ce298f0b6a06c3bc797469ce9fa6ebf600c73565ae4e7bab3f18fe53f8e2cbacc34dc28440ea8fcd13a686644c52e6840bc6ef305bffda5686de359e7bebe75d5c4c97c8d5cd998a5d033a2328853a95cedfe90fdda0523c4f68bf8e5703c74a98ed53d6af055b8f4e73c2ba2d50320dffc9b7c638620650d6c3e38a799221f2ecea428a6d00bb7bf61c6c6a17ceb8f1e86436ae19af7db5b0e2c5ebc7b769d44a02344632fa7a883a246eca6a8200fe7c79fc940841fe0b867b90398a48a2d7f63ef5da5124e1b69c82ae436684ca95bff784059d061ae192b1939c23e3ab1efd106305a21261db69ba68660fdab86eedd63a0e06ce89f303a50193ad623b4e64733ce50a434a0c8679d4e46bc55322c5c17c22414d556a47b668668fa5fb2a2ca5e46635b3ed3f924d702cc39a1d7ad9c686376c4c0b5a1d6988b23bcb2a853f7e0bc3ca6bafbef568309ec12214df6fa78a7be708f8dad33c35335ff577b9bee7f5028f59fcd15108bbe5395c8000833d31155c2360a28c5aeb4d07a40bcc8baa1036abb7f13d4db6e0ebf3763771afe8414d5878fcba03b1ccd2f8c2716c35ce0c94ee82c48f725a08bbc5dc3b0ead62927351ae52f8eef63f6ff067843c51b0d85ef811c859d6ca7715e901c15a793e1720f16dbc955e72c0f885b759bf5a2a07503800fa936ec8e82e9c0f3c6e4ffe7f3f4ea9fb5572bed35672a26ec65e5e5569690f19795ded263aef7e77498fbf597c1ad2beb4396e5a26171a59da034c7d4f3303b57ca74a4d1fb951074e29375d28f179a9a4ce7f13ef5ac768787df467871f38ea9a9459a38ae970c7a57af817df6778920394b8b2ac4a36a18a2bcf133d99b10c3ce9e9bf514831f279a9ea9bd094235b8109820478ad3dcefd19db58fa882266024b9e70ea5608406c62da6a94a71bddc3d5449ad25b98462c45014e7c256a5b5a6d3703399a9331f80c3e55bb29fb5dcd5ff8f21223a49a7216161dac932e6a7ac464c924dc95830e59fec1fd4ed05dd12a50d641147662500ebc335fc6a935ea5ed80b9093f5975d5864e9f1cff4c3340123c4cf30eb712cbf5212b6e2805afaaf7ce3434958da4bf796d375a0cf8c419d1fa3a13883dc25a66673b2a57be05d8a539e5d3b17ba9b1de204e67533fe2066afae34cc2f1519e10d76a0167de2330646cfd45cedaf42016a420b1e6255c3d385e934d532d1b07363713d7f7513ec52ff14c4f4327fe15d3cc746c7ffb24f80d82373eb60138e312c889b56fee0de6bb20255c410631b828d136ecbc52565db6f58d0930398a8dcf47e34b770123404eac5f90032a455ae0122e0aaf389fb773f108c08ccb17524f49d7462af0eee47830ab35e2befc35c9f7959ee16b9fb0e4cba93bfabfaa3d143b88fe5ab19c3257b7017bfa352dfb554cfd3fb0551b1072046d164fb35cc202709416c476864c8327d83f272f7d54769bdc72d3b176d64d6d17b4ef7351249921399389e124b3842b8ef6036db64c8b2281beff58728f0fed68d37d0c9e4a741e1474e3df2565108162eb4c15a1b30f136c00455ed6506ce35c876d43060019f9f8418f0acd0dfa13247292c1ecb9a463c6cc7396ccab20a33de099edb0969fbb89b00e64779ed0fbcc6809ef9963491e38ded319d83304babd4a05405b5930f6103fbf1155c620e235cb81cb7c421012057799343d169d87d1c58cd90fe586ac194d4525e775c1f251fb1304ec006919b968cd58ca1c2329f6ae9295a128f93e25878c3ef85c15cdb4df710e02ac530010882af6986a7fd08aa53fcd6934db4653a3b5aff202c7fb809e3f5a9305beb8e37f0cd1a0af15674ab504213c3a8af90b2c6f3cedcb3bb55ec0fcdc8427932d5a4a75ab830b336b6f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
