<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6fca0368b7d5da08ac1899fa85ab6ba2531ff9d7d926ed278d67cae97436ba4bf8acd8eae2831fbe5ee7dc08215d7f425c60013b9c8ef32f15f906077af151d95f9487c659b908d49c4e49698fc111e4c1bddeff6a9cc8634ca74973152217b10d6972ea207da14c5867aa5c1de7590bd83903d624a338786dc2556f22bab065ef298235c7e5a3fe2d7b2a5a91348a4aaf89fc8e59609bd504103111a8060481503720a20e721e8df1adea744459fb67e8e0a8ccbbb668c0864b115d57a4356813cf276eab7ee7a7e5f01eb1e25d7bd613276ada3a4ab65ad5f24de092be3799331afc6ac339c4b48c69bf9eff00af2320941cf571e57c6f5983464d76f94455e3db37ef956b7999b78fe0b1c772797397a4aa958f169dc516eea3772d4ecec5214bc14adf67d862fbb0414cbf7a05c6976ae57e34a9041719750ec9695db0fac3419e0d46858ff17e039d7e52336dc4fe01907fde3d7bc44d6eb4d7c20379e2ce4fc0b6b127cc30f11b93694499f0146ed528ff0420c9cdda2b493ca6aa0b4a82691502cd5db7a9298135bc595aa381f7c57b4b8345d24918695a5da2a223227940ac5d5d70fee1183c764528e1ac0c72c933ca3cb187d369c52d5dd434c3963ac9b7f784926f9a4a18055b2f0ec6f5697ab28ab075331a08e67756ff824900f3ef3a51c7e015b22dac41630ab5fcbbbe3d3d0df1ea3c8ee3104cf95d7ab756c50b06c47c540e7d2b2003a57f4a1c0d21c1ec9f0b33b7c0f6bc9c56ba381965ac52d3875d0b79e62922c8df2919810d9005407b117e31119ffb49c9d693c393218e53af30f9555527dcb41c55f058d38ae0165175971188a01286822985a7529871b0a19f77b4738fdee76d5b05e0ad488420672be99fea5a7d1a63fc029e772b7fe134ee8d86a0a7cd0fcf7a2a2833302b514887ce606a6748ef2ac4ceaf1ef9e0a14c0cadb23d9a108f477633b8567541840b69318c9c3b32563a7758afe39e48923ebd280153583c8f90fb3ad07c7ebbd18491c812f5e12b90dbde2d2ae5f8c3528f9e3768637501cb95f57175d264d0665bcf35c66e4b44ca812df3b31087a5ea337e667b3dd692f336e5aaebf695b5d5fa64daf78a4c4f41c81ed22ae790067390a523e278dd833b936d9e2d2d8ef091b6c97267f1097f472274d1e0f700f95ccdb6e671de24dcce0ef80a78d97f392384ab44ec8bee8a0f9d1d35bd1060fd73f952e212bc881a8eb6700951bdf17f2751f3b25d6a4942890bc45d39685f682cf4e82385cbeba4338a9528d59de50bec5f83d0a8bcf402d6a5f05767d030e1c3e92ff2e26c2e11331fd4c58db7341c2614972c25562ff1329ab4ef5a29b694af4658ac81fad38ba53f80dc79fcd18fc8ba4c8b668b05c81aeaff282d5fb73b0c131bd778338573149dbeff2566e9f5f09d95627145a13df492903d28584e7fac4699b4c1cef274593d0077faef70b1213c5e672f0c3478cf70710119f91d953a0399286433a01b71b13a65c3f46881c84a3d2e3e4b0c6e5b65ef40fc8a8c2a65674796ee622fb25dc762df35857b396b3a11e7865f154207b2b32c76a9cf0f5ea49d56dad63ebf71138d4d9ade1187cab01621b4319de54ac3e756b8cfc4f6f04f6e9e338da4ad286db092dd353bffd4054c9bc3ebab85a746a81ca6ea14231d31c330b2f039a53a847efa36f03bf8e11afab66a8400e783bccb27dd4f647d56aa5023a9168b091d3fe0558d63403df4e4559caa3d8b404f1454e94cca0801952ece924519a025ad216f45c84638adc22dbf9d6f95c5a9cb4dcc947261a73237fe82c0a788a8cea4098d360583b9f8010e05d51ed1ab5129e9e707d8126a65a0fb5532f8439d17c13a5b633481fc680d3e237d361815699a623c418612120bae702728793882fb617bc287a77d3e3274f742d35626dc68ef6b94a9dc74750c7988141ce9c5558cd83ca2b1796e76d228846d2d038db58ba82f2914d856269e9011afa4759dc5ce89f0d1b235a3047fc6906b92914895950ff886b9ffa2ea4bcf16fba8a651163c61735b469e75f2c57797a118d2bfa044afd57ded3575c3a19f8244f862f290b501daa1d8b16c9653a6f4ce3d9687888f02a10fce1e4c3f923e650132d4071fce9917c149da080b47b15d65bf842ee79b85946c9816556a9f5713f592ceb705ba83a1a902c35d3f25d5853f19bf501bee5b19d809c7aa79b73292d8ad18ba2d3cbf0040a8e40ddf0aa6d4d3cf69091d90d699a52b2a84bbedc140bf5b1adf1ca40913dbcdd86d8ef0c0989fcf91ed58d931318d7a3c16ee20c87e330daf7c62e45d6be70f88267413994d13415b5be63787fe33b5eacca69db8dc4a520ae8d39b437a076fc829c720662e22986488d6738a1c6a1d09105210ce0f62c95a0e4930721eae61709fd8cbdc2bf3676b3d70c70ea7919c5547a1ff19d87bdb49adf7ed2631052b417f4b3c9a4c2f72e3caf297862d5afba926a61851f42e0f1051878a46f94f31e314a219eb833317756c10afb1708457098e02d45b9d665c6bd9a6032b886d4f4d378fe6b61eba9cad815520e88ae680686bdcbba0d285ffe6f533b67559106702aeaf9158ef496b8f4fd4af16acd7decb2803859866799ae50c3232d245b8bfe0a74763ff2f15c3f24386218523271cc57df2a49228bbe302b2ecb1752b0ea4bb58020e3901478c1b59bb4ca6b4ffde27d981475f5fa20ed870e40e6ca00d77999dc12c912578f104fe512352136d2186fca273baac99e58de1f5ec23caeb216cdf13daffcffcca99dd7deb886222c502151ed55200247339bbfcc9d6a13a40bb8dea338e5da0701e3bde1e37faad98aa6e46d151289838d338d7e400a4a629a24405089d3b9db9729ca71ba6a21c2628c858d43651382839152cbafdc80d326e39679347dee32d2aac55aae7a1601352b7a90ed551b8b26eef024b4e3625d2f911f9ae00c0c4c3c7ae3f8884bcafdd3837a9b091d30be5bbda7d390f5583def5135c819123f6315a67f81ef05fda8da8da9469e34dd80c20e784e5ee8bd7df11c55ea0016be83384b5b3f5b6a10f661fcc6a01a72c3a11b578a81ac7c22f22442ded8a61ee35acb113e674cda662f8c5f92df754ac23778e21c532902039f93eefddf1c0615af758203c7e7e39bbc43f341a5ead1428096c7feada323943778da111f0f6a33cf29d47b184253a8b7ed6a2e3992568e9f84aed5d8269b850ce43de79fef9bf75f1feb29ce4f91345f03644f27581b527a72ac9055ccca2d648df9ed5f28f528b8b1a849e256371009a1daa9da1fed9be066f503475b549a96561bb53773d576c09b0ca1014b606fb66ef6800f6f5a680d4d59e12459fe17f4d0875796fec1e8c2077ab7a350af6ebdec10ac91552d9910d5c0f1d64dcbd9b81d9ee659ce813827ffb86fe262f20c195d0e8760ac981f34a410c2f66884ffc99f690f3f28aa43ac624a9232077e1a6506b9be3a110aee51faaf2a6206ec4c923ba8b9ce2e42a25b93a00d5620b1558697932f2f7356ff08c45dd2ab97d8145c9aeae71b31f42ce47d0f1db639eba809320473e7c0ecc01611314194e1380624579eb6e7b25d05a6e6474d02325fa603ee2c35d7a9f81b434874eca9a65e0fcbf74810d8aae98c73ab4944068b3e2e7de736b1c9267a242c6d961a08612d0c707dd4cd6f3b64b3ab62cefcea89acd1711cf7bd1a6ab2289f45579f43a0f39a9810fa9f7c6049fb046e3041eccae8f5d56b6e5a74583fea3b651091ee3a531d147ef8ea1580a76c3e5f56882b5d502e1bd27daf753a45ed6bd4e8231618e0baa606c5ca613eed0f1ce2a0b40d3e0ffabe36498b3b3d41558979c4cd1861fba4d950cedfaf10fc08fdbbd7bdcd7796ec0721114281d1dfe07d6a86a5c5d955b1093c57b50d9d16a8af6c721b103ea4cf4fb8e4cb26282694e4820019fe368ce20d6e2818fdc7e227bdc3c6dfb001e342089413cfcde62828646970d11af50e9688dfc3ced971729ba8f2bf33ace5b8a82ff9485f4653d69d9fec8c877f59cddba9cab61acd615fac4eea3507a59d7ead4871ddf1086588c2df3041617773b25a25994b08487dbdaa0acb1343229c2746ff38d17f02a53a8657dfc45dabf614f58c82a6a3a8b131fc498242b65d6772b6f388d77653401abedb5b32b94324bf211cb59154284ad02d911e879ddc684a69ab7c80d508fb63dd1b6d2aacafa5dfc48e877c246ceaa336e48b584e9685d673b44ed9183688b671a9071d91aeac65feda2110a7b2714c4f5aa4369ba6c4a0d987d985fea95c8630d58d7cb5a7b79d662de7972247969b7ddaee7b298228bb5771ee1c4737fdcc9ad83aedfce584ec3eb695bdc06b02abd4715180db8eb1c0e2f877ec59f89b0f03f0c694f2be2ef46a641ba6fde54fa972a13020d5a1ff618ad0a87eb15075f77e2aaaa7ca1713ff46810f7558198ee52605f45d7a45e7bdc91a766c3f478e94a34c4b6744dd6770193a604a93c278891d03af1855c0688797b895d8507d3ab6a476cabc5eaeb52cd28b5e7bcc862bc3839690f0608942a5ee412c7adfb4e8fdc7b4b864f85ec31242304b053f8fb0798239051a39eea7680f146eb959e9cbcca1cd95a620b58026375024f5dfb638f36297d0a805f7021493eaed130d4221b92415a34a016b89a4a1dfaa166cdc36e3183fe872f7e0ad0933516c0969a3b88dfd284f13384f7cf62dbe6c036b86d432514c0947512edb4a3c7183bc751a53dd82ba26a11ca73f59233e01d776872895fddb5735e935e53bcbbe540b67fe0400cc26e826d3eb39cb381affb524f4bf93bdfa83836ad9ba3f7fbb00feb556ce70e696bcda4d469d407ff054bcfeb36444adf1023731b323a575269ee5d62b6b01c23485cf529620166c1f857e0200456b5131c8c8b92632fa202cdd4e61ef679ab5e0424f46bd866dc1b0ab44b9b61c4a5fd5907f664f7b77b87282fe6bc767a62ee24d88d547f0f6f2b6cf59f6c4d62016b8126d3cfa1c13fd69146f2a8833a60d9de031df763bc6eff702f47466365638bc52fd192989753eee2bbc68c74db7077f790a7c266e3550c3ed50ce52b8461c7a99db5a28843cda5303168add005284e0fbf5560c199fd386eec7d7d808c96c16bed73364060f212131bb90d1b043a9b1d47922e280f1915a6e094a5cecb3450e1567b8ee556be9205500232c911db3f07e56e4b7f5799b5f6360ac2dd11dddda22d171ccc93338c2b2c647269fe4e373432f81693f9e9aad94e731ab40f8161333719e1a9a076c1a89757d3f23d787a236385ce64dc5aac0d68b0847bc8ce66c902b3d9dd248973c5b3dc4489b2f5a37fdec8edd26dc1e252d99303411f922ca4c181a938ad106009e16d02e24ed3070541ddf019c291935c88a132c10cdcbc0e2b5136ad815c9f3a892b9e1beb14a1a53cf6516f7de16e9ef57338276b9436cf2f959a8735f306d55f9ee94a5582c887c0ae4166e760a38e0b665dd6d9914e9a4a473a9ee770793923a82095ad2da97b7ef4768b66d310a3e483f7ef6279c801d9e1019cc84f3a14fcfd80100fb87c9f5b2df861e48ceadaa8c2cb664c3fe1bb954a3ef546e14f4e2bea0be147d4845b629651e65c0749b06c6ff8bd7e2f790ab72cd6ebd41d4502e975ac61d45b4fc9bc5427b2b92a03e0ef2d9ea57e6f5f37cf0441924be50186749c5a8162780edb1bfda14b1ee8e5bca1855d8a1407f90b789a040c94b2fc90bf4109d227abc03e76654c409a1ed295b36ba52901219b4ff55a6db9600e5e37ba84bd306c9958b4ed3d718e176eeaee87c700b7c40f6224c5a55ec25ddfa2a40cf48846fc1342fa1912a90d343a09ad45ab48f482418908c5fdd333bc361d5335f3d5a2aafb87d194f8931e584fd89f1a2997072b914d736eae8850e241f1ba4b3279fd8addc141ee27444a48c761a33cd96fe5b81298f71376adee79d66bed9d668e04a304c4f8e720080129d31513ee65b384869845e794e83cb1518e9914fe7e92dfcb2744d891d016af613680640d3ed583457c1697efa126ab1a4ef7f8dcd4c7700978a84fb2c4e9c06d4d7a091b158ca5b3ee3d5ccbe946cb54aa42c00f20988d1258a09cdc6f7b08c13955370f21aed32a1d32647dac25428e8a0b7acdbbeb50c4c3aee5d28a08fd75fd8c913ff8bb5a0579a50899de33f5f5fc0d33c388badb2996871c7931d852455c9a026f33900f6248cd0d5e4051f5d17fc0f7042c687ea37bfe97f5e09464a27e3d78043a8b8ba0eb1adb33030a1ec84c9ef96c9461fb9f0b17d1e6771bca52331c7bfa8c28d4e753c4f50a59599b28a3d163862b5193d73f55501412bd4f521170ae59c9e67668f67da381d54f1cf56c8012a12b5c0ad7498209b36804e44a19dcd55a1ecad6759ef95e9f0371b3ae6f42519720a67155cfd51789a85d8b359b7a15d1fb8b18ab07ea0fb8c961b84d38cab584f6cd5c7cc3f42cf6707f8b176c1fdfa8c66de5fb43c21c2dac55d749d2c013c243181c39290682d371008ea6ab8784b56ac4fa42a616b0fff84096fa5de476f1e45c1a5908cfee9f1fba616115b3ada1d1d514ed902b68f9048a7e2037cf0b4129fb9fa7c843fec587477975c3b9120592266a1d9455b8a6932bc8518ac49399d5442c32e15cb03ebc3ec953c88646fe1e1fb791f6cf92ea6fea011a5d7799d5f15813f05600f44ff91b3b9421fbcfb67efb49bf19eaa044e71a4ce4a5645c3f0d75db325309141198a3d15817c3848df75383fdb7c81f82685502f27b795c4175f6b636f556483151cebd37af2e5422a1776505900f8160378cf8e0f2e131d2b00fff64040dddbe3b8ccedf04e92d91536e0261d92e4432c7323ad7cca71342471f71063512f96a1d620775dd2e4730614eccb034d3171d8f016722e42761d3ee986db93a2859f1424c268239e5cdabb592fd8de920210a83e0abe67480fd5a96e3f6f478999ad4092059b6b1c9cd2891bd024d63c224ea5d6f516f3a6bf57e208b18087cdfdd5c9dfb81c145f71f39b6c5ad439af82d8aacb8a53808b68e99d010a0cf4e58f22d5fd3445c3ca866e2c4bdb9167a333f77ec4a118a7754efd58e64e6818a31b20a858c6b6dca90973ac990148d167042e0b04a473d96839a83104c1e8efaa3de3ef90d6980d5a5eaf88df8e27b8e13b8d7b9387343b1073900539e2658f8b8acc711818a1ae6683b802a866c983949136cb47c7bb0f7fbbe264aae06758669c0c1af0670dd7ee3e661b1283d1a6ef96940271c86e2578fa6350b91b29cb4a443c391e84663f4918250e7fadde3dc9de0f37a8a548b083888714943fcb8834a9a5c356eb9a15ec1260487a13551ce97a3f0f0ebe84e9850af59c8fb7e22e372e590fdda61b824fc10bec0dbc8590c69d80b98601383ccf78abb6811853624c1c7760da277a52cc19424a1d03c93c8a1d45c1bb5f29fc5c6a990c8144b329c47bc1a421c03001b2dc0e6e71acffcf70115efdf1629322ca7ca377e62b07e839eabad11c7ab3f7332967e70efc7d428ae63ca3ce0152b08408516e56184b4333adcb6e30aba206b752a9156c59e671506edb1c5acda649ccad084eef3ef547cb2cf2a617c5d356c2c3ec12b296b7388c5cf372d4ae0bde74801f90dc11a4ac6c78ee00216539094c779b3f7d9af01e84d0ecd746ede76254cd6e8c76db0556886ebedf70138a43b083e611521c0d90324906015f3910a163125775120ba6b246714b73f270e04253ecec12fa74df29409020ce08c2d41c3959dbfb8e7a5a1288b0044fb6c231e39089b4f7ef77b59f4c6f75a72d3f486404b1bdd54ba2115d615eef2c69ca1de4f61902eddd34280c793c9f91b45c3022372968c57c2241b12e2ee8d48173c69ff1d9c1aeb40fb9745fc2b7b1f9070fa82518b425907851999a22fdf6a1ef3312a2a7c19911743e31f7243acd71a0d195d3168f06bcf0129c13f24c580ffcdb8dc74f610fcdab4cf577c6017cebc796e9d949a2799081b885bbc4edf66c7dab704fb32c382ae66b862cb04e3e3d65b85d93e316089261b3225b7cc14b2818b5b157236c11f9bb0712214ac62b159c75ddb105911f732c87dc2c00af759ba1334f9a92c6efaf67fe26f76b62f9a5f8b067af70a085cef2991c247a3d202a811bc6d278b303e16d6e9f02fd84cc4eb8a2584f61ed03fea138574ef74410819932a56daebc1f90b419b4aeb4c1fd984686a2aa19bfe98464bc427b8515752fbb4da352457d7786f839bc4cc6169f0ae8032e4cebf5eaaceffd631c8dea321bb7b577b0f1d4b63a4cef11245d711bdbc1a7583a0ee29e0b05308f9198e2b7e0c4aec39b78dfa6fe3af6fdd56aaf00c43c2857b26e8240606c08612ee9521917f507f4fd46d911922a5ce3f58b9e56312be6bb0a8568e0e0ef6002faa59cceaa80f3be2c9eb165a87aec9dd5ca0e326ca3e742bf3be35da8782d4e9b73c88a309d6a0f44a90f83b1186a44ef34d8f32c7fd7d76101469205de07b469c5556f135c330dac586c102fae19e8fd4565d3eb962914f84546b5525a46bf2f5d3300a575fc91586575aca41e3da95437f12cf32307dcf50da05e0bdef5db069e83e409bce12b81c0fe8fca55fcc1b57e18d26bab9d3dd38a1ef5fb144b3ca17140f3f80648e8d540cd749959508231c9c7485eb94fd0238d66036511ed9d8afa4d935e1c9c9b498f323006bd89eaa3024c3d44bed138f7f711ace1c81eb564506d78628954bd1abe4a7dbfe52afbaef9befb43aa7e15976b4f3857eab1962a5e9fb23a6e7708104839025879fedcd8ede3daaf1da8776d508a9d26cab21dc7ce674fe7ca8c1144138c47fc1725462b2173ba3120feccc324466e7604e71bc7151ecb9b6b4d83fca51078cbdb706daaed49268fe9a3cc20096e26a2cb0e9080a44c8bd47dcbf5e79e089704c89a15a2d99e9d5f95b9958aec8e4609cc1ad57458c3e0a71b7db41f55ffb546604e8b1e8bd8ed37e2aff256f68f5d1bccfcd97b1260b09c6b56fe0effd7f43e7539635c38c58f350c93138c50940dd4de15166633e450faed06e56fdb807e8a0b12c8c283f6e0540f10e221386202bd4a273eac3b482bc054c22e742c39549f14f1ac41cf1fee6b03eb32a34284d80a40c01976bc5f2753cb4ee76339502e7c7cbf3c7fe09791bf41dbe3d9d7fe6e5a6f5f25458b2c38b09dd0aed289e42fb52473bdbb87dcb3bb624cf527327e3c34220405dda6f09cbd43ed62ae418a6286d9a52c05d16e6f5548cafec4028b21d653ce6ce8cae7c36a3da6718a1f134ff8a4f22cfc1c1c8da3a045130e264580b9742382b1ea581027d953e809e25c85727a519372fee3093ecb0aa84e79dab86b670ed52577e392a6961115f53e58c93a5f7cd25d2f4af10dd650d688b77d6ed4d4398e91868798775a7158b949fabdcc0167751afcd76ebe03632dde01c08b723d979e8900307437b52f84975c0ad46e0c948821e4ea929c5f6915cdd5cc5ae639222243f2178eb73fdc512b153fcc032e4a5e88116c61e8838ebf2c332a2d24bc39c858cb8ba2925e41c18a01229d4393077f43433ca4d2ae6ba805613d5f9001031b0210c474028d2b1e98ee06067210a9d9b2b2b48f1fa0b851eeeacc6fb5298f8339aa690fc8211a9ae5c1177bcb12c0cfdf30f669c7aa83e5ceb7cba47adb9ff32c3646f7f5615b42eb1840889aff3e0e56abdfaf0a516010ceaa02b7d383b4e6ca7048278b77b7ac77e93132e647844c50aed6440528ac5a43206743d150f2117ce88b0d8c97c642c8b649bdfc0efae052a50ac02ad1d419819530bd6abeafb2b7870fbfe27d8a58a2fd42f1741ce5f73fb422bf8a1d037a42da39aa568386d42375459a48c4cd16875a11d74dbe606902ceee4b545badb838b172033b75a188d59f734fd1af51c369245104a2a13fea17200a5ed1f162632d3f96786937c59ab072c646d1a43088471b1adc50dd19d0d0449028b17796a485fa55d2490b6fc4b53c772f8bf35c58e1107cacef06ee096d323183a85e380cb4b0f40a9566814e3dbeda81514795175dc8c43eea34f8b0f1d3768acd43a22d45b9adcbf2fdc3f6204f68f51ba9ff200eee8af6bf4a6548720082abf922747d146d39931e09931a684dc9a78f06625ac3e3c9de2410cd0846b0a1789fd634a3480ebf354b13e413cc61e2dc4097a994ef456836e619880df889e9c37007a13cea7b4c31b03a4d8b28dd2889bd2e31eeb758923a9308ac6bc60eb2e3b7c8d84f19ed5fd6cd31ccbf1fa3aea2846911a3b764b77e0db9c336e16067f30a5bcdfa3ce6efe7722dcb34c47610450bf0bc08e2fdd2eb89338cf6abec5a2e622cc4f2e7b4ca17d69290a860c90c6f3e85ceae50fa2946e8ff5487f90e8595a195e2e4844cd3fc6b6b088181b27f743f54bbd6b6b225d645265fd2f060d6ff70d391b6e6a47f1be050d2ae9d6bd77f5ababd038eaa1a9cdcdc496f9073139c9b4673596a16396260e1ae82f30fd48211f7cc18009daaa5a2b1c16c872e824ff392198f008f04be658c5f9107a953286075d2a9a87fbf5543860b31bf99a95b25c96ef1ae91720d9b6fdbd17060b9e542f036d35dff6a6ba1380784ab7a1a38d447a1ba02225e6fcd8f1468c126a855c62608456ea101346a2e684f234fa7e212bcee94cfe80a143f91b0dd372ef9144bbae52162454391ef5764a7ebbbeaee9c28f63351b1e4ee2747517ba9862d23f0bee62dbeb72281704b5f2d927c183d37ad5fd1e79f69e2dd8301aa00d234aaef1a84225f046930a032a1a9b45613f8660b1b586d01c44463d1c250e7b02d0e6fd22e817cc9dc49e27bfbe830c8077cc5bf7323516dfcf17c00aa217a15466cdca07cd9f9b552e64720cbe1ffe8605db0fc2394f57194a606267ecc5c0fe19d41245b7eff73ad9e478ac51290d0a4367882a06740765a60d80bc7db4ec669d55f7a26ba5fa413c786d4b5841c0daed4a6f8890ea9da6460af14d457414095fdd234c53320aa23c7bde1fd35d141ee5102f8e3cc86f8fa75bcc29911fcb4e1970a494e01bfd205981b23f0f32dda5c14f11a0ca2c652cd9ce27bc3118e3c250ffcc7a590f9569df552bf87f8097e77059ceda8c071421da835bd46de0b353f889c7b0d2feffe2a16062039993608055196ea4a7c19d536e968bc614aebc4f54891cdea05bf1cea298499a51ba716250c960d5f4451eff11e5ae4b4baa7d8d50407ade77b1c77e1fdbedcfb3aeda65f81cfc3cf9f8efe75249abd09a7386b1e0d633885c2e93aaf356ab99bfa67f912d41850f98deb19c61bce62a2cba2fa8f2c349a152081329333acffe162e6b9a84ee5d6b8676303d24ae34d7ba5697bb5c1913795357ed3b4b604da1c6aeeda50d0a8725e892b992da49aaab30d4cc4c4211c8adcd4a40cd5d298b781d639cfd761892b4583562a3faab0892ee1788386bc1bfc1734a6f8a713c0e9b1d9424b919a92a7cba03860f0a728822b56c804a4ea82b9b915a7c5c40e11bb1dec4043dfffb8c169c5dd6948b8215103d26ec1c836bc31f9d8ce8cd7daa89a3fc0fff378bc33ee3bf8dbda99db62478278f017ff21c45a272c52e1f10fe6d856ac78016727729bc9dc1377db6e53f02e39639deec81b0aa983c6281a9c740b9f525ee8e2ca17c029e245866bf1c55d23f66af4f52856f8d5baf042fcc7e7c85b49ab18df9f2fcbc1ed542780342efba11ccf3cf73199aed5fbb81ef499b68c17ac6910063605af3d2019744e694cb4e82f2bdb5753800d0a7d3ff7fc7d111903224e84fbb0d675efe95af99c73213729308490a7172603e2ab195f9c99b95a253037d909ea17827b1e65c551e4ae12d5b56988ca9bf7c51ebe4f412923e495227a0797ea946eed43fce45f3811205dbca3bd15b8dbf3f6f4014c0dcd37b937df3b0f182ee500b0769dce783aa60487bc3286af34302d6fa411353ade6e6cca2b106d55283e6efb637c820cfbf2b2af98ef784bfbda3025d908eaffa2efabef799577e7e7cd0849ff2d2b3c49dd36a8800da6e5bd73f3b2740ef7934fe661f7d6bd3e42196b4730ce273079fbc9b876ad1177d4ea78c73243ffd929b52a7a6c8c487fcb1e6a89bf5c9977f9f2e6c5c4c6bbb6eea7ad761696ccefffb4e3dc3922c6ac66f3d70b616826af69b6cd6952b0183611461cb622ca62a0814fe386ad096c75330a4eb0e1017d918b2ae4aed9e3ac481ce14f9b905060e0e8fa5d6dd8a2c7f1c3e1aa331114ef480a7c60a864c31f158a978767aa246e4b69765fb28e7d875e0881c2bcd42a66997fc351af221baa530b94e3c330e87035bd0833712ef14ac861c17638565a5a165af7b11bf2562ffd7c299b8b48b957d5dc3924c2df678e227a1e7491369007e62546f173860ec4a7fa90e7c26e8c9ceef886784dea83adedb16d0c9eb3625e7fb0738aaa85acf2e58fee6e455648d020fc7f47ee95566d9b80ad5730544656a4a603a7ecf4f7ed52ce75844806217fef5429b906420f7d5bd8b4987891ca9050fe818aaa5b98a507015991440e9847b5640b37886860ff6f27304b8da1eb7910bc5044d2d85c12c6d788f416f6ba64274d5bd0c3155f3214ddbcd852df9145c43931c481c622fc8126a3619b725607aa6db5d45bd4545e01fc6f329b4a6893321dd2562dc5d57a5f02cb5edad32333fc8374e0ca34a5c8c166a0c5eb2bcd2aa5da36f357a7f6e06907202ab70b9b04c9eac5f73d014a531198b6440cd1b39c93629495f681760e89ffe53c3da447a3eb249c0de7de925692382e078f333e5a89b34365928df48c51d3d2587dc2f850ec18f4033d99bb267d78ba8502e1a90d4a50a0dab7b137349daf31ec7ad39fc7c509bbec04e58b965326e3fbefb46f54b0faef45b70e286871b042e787518d823e2e150eaa2bade6c8097f0de022c6ef78a4822ebd4442326a17460d9600f4145750e0856c057bfba7fc28a5de26b476ec80ddba8ae9e612ec9d2a6971fc59feb43bd86661563f72b04bbb23c3e9950bcd50137f385da6c3e7adbe7022066bfd61e595790820353ca1af43eb62b575a48b1ddd5959477d8f8867f9aa2daed658c744d2602b74d8a22c72a1b67ee0870fc154a65edecfff0716e95a4f541de898a442501cab79721dce5c1b791143587c56de33e2b40b5f6401d7aff729b77b7a056c5a574db4af5edee8473b642bd66b4f2f9f5effb57d6373fbb49fd9c94895fd03ef090bcc638d7bbe9881ec9de90c87add0ca96fba4088d546609da79657d3307481fe880d8dbdf331733f065ea929bb89ed94214495796041c1e96faad62bca2b934dca944a29d3c8e4350a82de40424010a8e5f7d693f0e93586815a17f0b5145db79d45fcc5853e6041eb770db80abf69d8c23575fd0c137568e80f2c6dcd8b3077551694308d5c79b5a73b67f08ebcd8eab94e107c2ed388f27ba2e1753ac58814b26427dd7ee7c8062db838f27209cb54865f6ab14308456ff7df820ec0495f66a8cb4d38033ae0353e1d03d2b99fbd26f3b30a8eaabc788a812ea18ec023c1c3d151662a7f5c9f7cd57e5f8e2e0ccbf446f0070ff5be66884d877e9817316e9239c7a6b4c334421fb4a0a36cb5b381a94ee81c96af786fe2ddf8f3f34d0d2976fb5590010272e76afe038bb7d675dad32cf489ec09ba5e72f6c2ba224ba377de687695c852cb517ea2af963f304b4c04af430eb9a53ac15f916d3380b967ba294ab8dad10f7164e30b8d9d56421ab862dff01d654415e342ff2379c38d5574fb358a91bc61ebc73c5be3854809d8c1635a036397c4f1f10af2fb9b77a914a85fa6b7863f7134c6f15d7ccedb316351dc52858cfd6033d94ded61e4220ed2b03be0e9e05ec0f258df445a8cfb49dceed4b15efb417a1e4739cafdbdc8c9be2cea333a18a43f006ed8e3c64bb9ad93f6462fd7d170242b5d87519e8354eba01ead2e1c189247a7d447fb7ba287e609732dc9d937291dad88884e49d438d9c0fa00206c47424e30cdd36922e5053d0d53f29cbd8c431a1a313d802be8526a5fa505090c519e4591e1d7fbe2f85625288f9050c6b8741493762f4e918450ce8855c6fd2f2f56218e491102b07a2efb83af2a9fde2bd155769a3fa76227cbe229e5358e847e5bde7042a0c1a7be581586a98630a1e03f868203a71519c828f06935c86486c7456ee8eb4a69798bbf5f988b3fc2f2dd2dbd8c391f16deff5e473f579b1f85a7da2dadafb4d51b190520b604e91fa0df5098cd48189d8817b7ddf41b5c5322529e5c3d6d0f0d971efe833497e8da178dbdf95a9fa58290303ae40dcb44ac7355caef1cfa3e72ebb702fbc3a22785d3310e5c2872be5751243fd896cebfe8fa2b0ba2109625f7135cb8d4c6c419e4ccf1a09fc79aef969eb3a8d5cebf8c4e52cd0da8c90a70cd6b2318caf7cec2de66f1ec100ba620525ac3c500bd9eef9c9daf565242aa956ea0be3934967a6f2460275848eaf46e3756c8632e0bcdfa4d80ac0e26b60c5dfa07c0994997fced72250e64aee3dcfe3ab2a82c612af308157fbb77a24e5e8fda061873f08e5889d5fdd4d4332daa7486d6aca6cf66315be603cc0160bfdc9dd472279391c07033c116bcc4f8209b85149e151ad3656201e9499dc61a4579350c02f4cf17c020ed9b610ef5b4b6427a6180eeeebd35a64625b70320331c5b192690c184b782fb8bc54404dec964da65342e6f990ccfd644ae8c6d98a9e7c65d977aaa9e4e5f9e508d50e9eb490c038093874f9acf9dcf0ddcec1b8c4e480075cb51b55a4ffd0e7383072a7124f649b40c69c3b5fb065b843b07d6604262cb0d4f50072ec456d219c96ea3f916d56ff356b16c8b34741ed33e595007164a5ca49a7aab21fd7f18a31ae90a141f54730ae50bbcad584746eaedb23123eb28e2284a65cf1e5b27476334cc74bd790103f93002329bd5fe74c2ab3c1a8d7e7afd6c7cf6f8e40d06a1efc446f1e9be563794e716927fa5fe00b1e0d86352268ec33f8be8db4152041d4545a03132c66a334e959390a275dcabf81c8f9b86d3a5c0e177ff0d74de2ab80db54e4f5dde5620559de5c3f787dfc5dc31914b6c8e9606edf6c8fad80a5c7e3490c313870500aaa4d79a0965ab8d4543b990370c82568890cacf7b5b4edab39f7febc9216de1fb1917b25b80b1f3c480eacab30baf276be802b09edc4f965088c0f060716288f4d64580692ad02495985e106b64881fcc82ab513af7e990326b55052d0b471915ec30d66d491dcb367a36a8b2e41d676ccda0a5016c438557ff5e61d8d62f51137314dbcb6ad65d6b947bc5fa8b702410277672ed87c0c8bcde0f2c1ac7c9b0c17b09a6cfa537f7d0060514e632517d466f87ece40b02152abf3b5188c97e37c8282e3cb5e39b13a4f51da010335319ba034350d101580cf7d19ea2dd3fdd3aa8a7a13bafa25516bbdbfec05b23da04c5f3791fd780c29a4a05a1b7b06dfd2bee114bc62650ccdf291d9ced54a96dcd02023caac23155efaa0fc0d983fbcc6804e1b1401d02b3af2bd4818c1829d185b398f427b50d1f305114a12f4c6db8b19648d4b2a46e905121e8452f5821e510990abc46a22ce05950e13f4a447b6523e8f41d46e271df61c56cd2a0c8700d139c4b43d1e7d3a914c0ef8cbc398a94e5993aa618a1954493115be7d8245885542226d8844303529932b899df4b04dbfc994cfcd4157681a4f46bff9e95d1872313a2615d3d7a29e6726252331f1562b80418bd6461c6c15b6c1cdacade11acfb900ba2636d2cec520cc56a3f91e2bbc515d5131aa83094ecbc35c83d2f4948c05b0786a8402ca4a3dcfb2df4cd0f68e57c2646b25b62da8ab4a1f0a3d5356cf8d450722892661410882d6c46a2d29a8bae3db1415d2c66d3d92f05093c423ddbbdf1905a54d064cbbdcc4032a1d9725aefcf0754166e00374575a777c51533135f20aea6b80bb023003ca879b3fc10dcea188e7ae527b4aee223d22d0b8df399ecb8b2cf9e1af050dfba774a5d4bc739ef2792e183c64dfbced29758965a8016e3fbe42b2c198bcbf99d380e4d7b4127533044bd3c92884d0285417894495302b92b9605141dd70da1197fc898743b4703f31371c98bfa5198280d100373678e0d1a7964bd3c59b54a0095c08da7a066e1bc2357a0e0c5a8d5a5d6bf19bfcd3e679f556db0c6b0a847b27adce6613c6e8fa80dd986c35ef4a3115851f030ae217d33a3d1a81908beaa3adf812ed345d2137b4530b752434db8f7c18474f912ce2ba45f1501cf56c665bcbe5ff62945281de279b76e3e105e09e5b94c257fe4f5dac4e3a875df6959242de4e525c387b7118133c90963629229065f6f21f715175490fb18101063fe7caa4b517b6c03accf918da21f691ba8a2a62d39731a3ff0de6ac24da694258e8d92cc381d76ed5664e7c21d478b98a428f8843b0ce8ce54d315e0ea669a1d5e724177c37ba4dcbe3abead684562076ff3cfd5e5451a8f73bf459bd59ce35cf29ab25ecd3919583f2ade2f96ccecac7bea2f9ee8ff2dc1f31d64c776afed574bae5824ee88794f47b04d9ce1569756dc7df602440989ed926df69050f8e9104ae44996d70af9712fad32f71bb2d4d37669311508123e40ff00c60c3f4da29a6be31fd79257965b8de88f35fcd94514adaa8debc0f8e919f056b15602dc7355d719dc040f92d3555640eb439d13b168c37ecc06d2b50be57fdfbb25db437cfb4347dd91a4895f9cf5255f07d5235a0cc02ccce5b07b7db580462b7dbae9b463d7ac7f4b2a1c0cf587ed0a2ff81280b557063295ea5d7c49db5ef409f1badb1ea599cd078af19ac028cd9a4d958943b4b683d8a622ddbf3c3ff83e2d16bb9d9c625f45729223e422e1a4379e060a0c44a4dca725d10d6e3ea59cab848b8db21ba949218f538e557f1c92d1706463b73d5a203e6b6d05f9a3b5771f791747148c5e14c4b83c6f0c43ff40a6101af80747f899629d478c4b9918dc964c638c848352b8e8ee17f5402a90cad9d39156b98c69d0e53a26a68904b1164b3130c5779e9338edf83105b917ef92ad464b792e4560c93bdb4012d51445e6bb219da36794455aff0698ee76cc7cc9a8fa8283aa4bdfd775b413b24ec9aa2251b73da8edd4afdfde0ed21b4e1cf7f33de153dcbef98adf9aacb503ede613e4db7b828a37bc62305562a26ac93b07340aaf7511caefebfee5836cb6cdd37345b60e98f327202b58ae9220f8a2cc7e8247c977fe77271c7e2c6939d649b7c7f0db9aae4fdfc5f31c2c53c31404b4ec527ebb07855bd8309a2c908d4f776339061a03a581e519939f0d9f24e054ccde4db574145d161b1679f42b75b1cfb0b5548ca16664a8236e977f9fca040c998e845e9279ca519fff69cb4de6f64f25bc043a7f3bae3eeb43cc6b61c9473fe37a3f2edc7c5eb13de6c1bdfbd429dc9bb8fe0520717439a2b5ddb1e9ade1ad772ef2e0f567a24b8b692303807c844d6aec501c8d52cec61b367b95a0d400298837d8fa7b16edcb1e4de6675228a67e70a448fe2cedc22c7ef861254eaadb52eec332a9eff24299021fdd949b3149fe585b42b33f3e8fc724b792924efddd13526fd95650df02dc77e67e5ab392cf36850c258a3feb35d31c4700b6cd6f0e791bc1ee6e4dbc0c65ff5b61b5fa7e4780fa060e75263ee78ff17a9b8e2221d679b07fc543edf53c3e7a443dc7fb34c87b789189442b54d130635c394428724cd405a85fa20bb9a886bec75e91161ba0c89625eab89d9b08c8a3c2da01d7f3130057739dd5142ab868d364dbbe63d08143c66220af2f186adf78746034fde49b28f47e0faff2fe6fd5ff58a2be4379e2e977c566210f57b89c38d9672014bd05f8e07ec65e12498ab6da859da6bafe0150c9429d4debaf474b72b0a913dc963411acf1359d820dfef805f47c5dd2a551174e0da50169117992cf554d13cbc12a024999beddcafc1ccf18774bffac53a3820b1c4fd00d66c7e2981ad6356c28f134a1dfa0ad9b05ef5640acdeb6e2f99965d8457005e66f4d8529460c3ea38f75ec0256e5b2620faa50d0b735feca58785f85356bf8dc024366eaf8f4f3837953bb0883fe69ae640ff60becc1621a9e3a0370d2ade79069dc76a20c530192601bd5eee1c8d5bdef076efaa9e4e0e55efb3d3ee0ec9aa67ab15b59163c190733b01709d88d237b9e3c17a7b3cc436c428418e3163efcc7a279ccce1f0af28d8def0ef8581c63eb406c7547ad0f47ed5ae0ea1c806a43128b08065995aedbf01eddbe3985bbe8c35a0ef5c475a203b6eb068f09e6d9e576b0601ca3854645422786518ce4600b30955e45972aff9cfa3a3ccad773b4619f51ca6c582c226be175380dce14921b63509ac2b7067f787bc590a8fcb519a4aa1e12257712ca1814c5a50cd508feced3715036bd88988235f2ca680a57f3bf404b7f420b3e3eb11f255c71a223eb928d4ebb9dc5cf83d65bbd23e7a7e052e53452a11a7314f4a676abb0a1bc0f3032a20e1450c1fe19bb8ef15bd6a4730d100aada852407d741e1c15b23050469ff78d2e0233c6bdee3c168e6894a38c6edacd827fecab1b0ca42ddfeaec1d684caf825dba504fdb29553d9a6232a0b34c4917ef564c4215daa665db404ce33d183e7aaa9f4d441cdc9ba2b93408b23518a30d0dfbec28dc854a6dafe43877a8409a1690d86f46696fa132c2aae1686a472a36b95f6ca37ac6069d2fd55b2bea6eeec4d45a831de97049fd9c3d757a73374036afd8d4c8439f4d675fe7b3cd8f902ce60da775a4a633520807441a3c0ff8147b60f83df8090e08fbadb9b34f0469407cd9d4de5392a75624087833777d8d081e5a2eb15b3a8ca2a6f2ead38970d0f29095f8fb8e7741f3898418a29d812e0e3f86df6314be114c57f47444ceaf09903860007a0d80f8274d06256d5eae56e36dcfe9ad1728c50ce10011caa0592ac53070cd5ea0c0a95c8d5dcb2a1c7a2073ca31c12db20a2883dcfb83b05174c1f64d9e31550c870402815bf8aa064e8a3bf0ae6cc3550460ed11bd7199887c6c32ca771888d846134004096880282eb03e5a26428109ccd47435bf9471e9563f9b41d515c9e0d03c4dc0657d71cbdcdea9bafcedfc46e8bceac6ab8a7b9ef512f20774cacc9022e7d94507eee86cf6e9b09add1d99145956a10de30094efd940650a83325433ea7ff22d483effd80b915e4d40e53ccba962af3a496fa8c54c3d3893e061dadebfe55b9a9159e8d858956e95146bba26d37b914fbafec12f123641d27225c6558e9cb9ab781bcd0d13fc5c7e430f7055c96f568391af3e8ef454bd1631f563b2a2a67d51d6dfcef719d827bbab03e0caad2c6d920c5fb8a0bbe8863449c9c3b5dd7ff81fe6eb804a708219a3f1ee70df6df1b0ff47e13c67f429a6ec24907cc357cd17865f4220525d3dce6f934b1d86d6c9f67e596a07b9860eecb1d4da140bd7ed2d1c3b094d6b038f6eb7127c66e9502d6f8a12461413352aa7d7fb9c739d4518a0c05ece8123a377e3b58f9ccb403179446fd134be31e44a8b7098749696553a3523835a33e6a894f619a41a785b731a85c74ac97763a1dfb29e682f3e8c736eab15a81d10df79a514e84ca9a069232800af85eb4f02c5e8bf4626f7135b3449fea00205e45c317c33ac59be8e74beeff934d38213cc0515194e7db0c6259d7812f6fa54f3069a7eddcbd814c834e1db36f2e51e56d04cf571f3fa32286ffa28f444d51d0c65d9356595479cd0533025d4b98e3befbb1cea755e85247a2635959ca90aa8c9fd36fcfaea7f5241ddd0c35ffcb89ec4db0c57f754a4a8f505bd91b14eaad00973a25365f723f1ea1a88bb6c4822adbbf0f26aaaacfcd8b4f02b1135830ca18939bf68a815b5d09cef238b9806e14cb9932d51a970b2b6fc8383c2bfc891e08acb9f0cb89b4f0432177ad490307292bf0ed420cdb69e09198a7f469b0d2c22ad2278afd9a7e5d4e634eacef521f7adb8d38ef97a54288fb29d48cf32f07db3b792197aa561905d41477baf81ff66d17cff64e7e102967e68e7afe5dc49c5dbf84d671f30c8e2bf783455ba1a94d79248101dff8281ddb443031e9da89826bb21a3e3e88f820702e0777bf7ae233114af7a459966b813038724899a1e4c2c391dd1a408fdf24527658e5bcc8b1bbbefe974874beafc003022c5385a7d1f98c9a2fc80a628d0c4e608bebc1fd711ecf37a70b3b8fd620e6927a815110f1362e0d20e992577aecafc52d5b6917ce603983ab5f9673452d71e2db6eac9467010ba8d23280b0b5b57df56d526b1f53950c9421cefe2b46f17ee1f6c3a18e3f56d1599c138e18a44ad8bfc641ead6f591fbc9d793c3b9192e49af5e2f14e9c0e82907038f3c192003c8adca1415573c3f5b5bf13edc01d87b3b22913bbd9668fc54cbe5b0c9fe8156c495d4b7b33c441020766b9386fb4d820bd67beb079042a76e2687fb1e13083c27f4c872ae14165ddcc79610d880ec135c0805e8934123c76d6293fb816c63c3e93e28d4854ddc5b6dc91fb54c0f8753990139caceb732a89c9daf8567d8f7172d3024e4c1b87bf66e15196c77fc8f9cc0c0d93355e2faef2ea54820e2d501ed5744dc5ffc43397857d60b564dc0f11e4c46c5dc5d2f3c86b2392f6718016953425c950036bcabe5a0a5863f9afbd49195a9d27776d9801d135544ec89bac13553345a69da371e152eb8afbc53f178b7c0cd1ec07ce54782ac1cc54180dd68945d95d97389c096a96e77df63bb08ae119e364f6e4dac404998e5fc2d00a16577d0e32130ba1c2ff6a9bf2fa4a1e64196844801622abaa2c6ffd3e2330e85ad0a1145577c46d07fac0f0ed9ad82e9b6a8e7508e775a2ab7dcae82abf5ee2d270f11f81b246cd7b6345f78d57fd0be37365ae076c027cbec56593dc7b5c1cdd8c8bd128b8aced6a92541c9b0e7658042dc7619715cdd070d85d4250af0af3bb0c908cf644c49caf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
