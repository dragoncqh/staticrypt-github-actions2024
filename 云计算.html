<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5e820d9be31f879f79bf9c50885e74c15e5df5c856d2941dd2dc265cf6d02d63388b7e24e0c775a4e5a9915ed534de6e980dcb23c7a81634b04f455f6375ae9bfbb8fb6944ebe2c1343a667638e98fa71da0439f9c7e20f37a1712105c208a30285b62f472606ab6e24dd4c45980ef08a61a311ca55d0100c0895d9f6a84801f4b88e78128b64316e7b1ae70b7fd99b784e5cebfb88ba3dadef30a656c21bcccd6b56abec91629a0111fd05c57581964353e1b26d33bf6e485a05d11311816f9e7af3ce7ac7f4c8b7d57965504bb06eaec51de4e3b9a5b31d1f50ab1d927fa8791c02b50ea004e0263cefa0e87f191b87a58d0a4c86541c43db3ba504e96bd2b5201a9381c7508d1c12ff5683e0084b1c9b7c0909a4192f505a1414d8d7c3acb9cfb81498379894b4f5006b0d6b1e03e0d9fd242e5f1258eedc55b516877955966650e1ec3fd7ba1c80d5f8cce2744835af8346db193b0185db306e806b07916b660a1f78a04dedfc1eeb76e360d88439a4e0a61abaabaf86c8021fd8ecfcd14fbba7ef1ebce6187d531483db53db0b721d54361ff0b939601af9ea12965579a3610b502cb74208eea017f60f5e4ba37920542835c8dc443fe6bfa0413ad21e5abbebd4bc012102f2697a93f276a5b9c145dde7677748e1802c43606bc1b81f8ecca3783cfa1a1e3e97c3bb792cb3d316f4f420271abbf027cf79656fd44832805112f7357b312995a68d600626f1f7ea01098c8ecb79c2031ec7698a8f48c766a0473eeb2abee9351194cf8f5442609317d1279c983a2f46d4dc27a90f41f46c9efe9e18e76be52072e8bc3bec452c8b4d6caf2a28ea74750cabae6733f84e8963c93116392896f7cf442c9e1039ac1a789899b48602494858927b4913b6cddb835cc5906dac70dbd6dc12ddcaffdc09e82b622f1f9e459be5b04ab55305e66a088dfa899e68c533ee6a3229ac6c3e09da52fbb26ff9b7c559ae5e96648041fd19109406635ad80753154b48360c68ecf4cbacc0f0e0d96e5778725f8304bae8682649c2415e3380f09ea26084c4a508c24927875e0d62e77040c85588d3178f93b0c0562ca2b9b817ba961ac87250303a56bd0e3fe3fd47d7592036a054c1f4d9714633f5467c8779b41545373637b0547a9a59e2bcaac5d62f6abf80e95a5808fdc0b569c53cdd2499f096da120adc8c904fa383a1d17851a31e857dee8c5d12e720d1a9dc10b31ae3dd1b6355b6b059b60e708f7aabb8a831453d5868acc080bf8328c00495e7831676b9a25137f74ae128ff4a75e8c08ec1f940d3caf2f3e2c5508acd9ce5d731d87416d2e7c625ee0ffd5843f39c9124e4494593608395a5a8031fbc77c39ef77453d1630044282c95cba422ea4caf90efa60ca27b4155135a6daadaad46d992c6b4c94f90c8f5444cc73fac90af29a757d8f5dc28a8c9d2a86077f420042057644ff9a24be2018ddf3f1d277fe1d64371118859abeb0e2c6e076123c567fa6f6dc8015b22cef5bfdc8c666fb3c565fa53d63a2d2154f56096a6fbebbae3587aa1692cc51f140dca0154a6e5e3eb3e491ac6912ac44818913e809d9b6ebc55ce4c6bbccf15cda540b34b37da93a9cdef6d30238be1e2663513d0d64992da87f4a44ea30bc9212f660668912bc5330d7304557aba5a64dcfbc78ea6a1d034023254c85ccfc415d0a860e801f25fb463eba05f9dce964257563794cca16c6275aff5e8eca004c55b3a191a0282cd580007c3f16adf509275b72484bbd9d40c246578de07bb4ba893fd119825821aa38c0838ba4148d28e2356286b4272bb1dc0975cfc16d310b6596b8020c4b15890b39fd78a933067ff408d6e0aa0f0c3cb8128e6654ced5275065ab10c54df92e06c0bcd7db0992e881b80fb7a8a96d503856f640b68c4eb58b2f20c5986a19d1e502c0d83157b4ce2e1350539a894941fbc05466c036ecf2425f3bad7b4aa2eedecb1f62d61e83d6fb00b8eb5848226d76d5c0546dd68bfc88390fdbfaf5d4ccae667c5cb2c02238a8d8f589a1378600143a30aa07b12778caaa2667bb08eb6e745d9d909c50a73390415ad1c9d6c90cf2218623a8ca0884b15e8f584ea298f4e24461cedeb09387e059047a8969f073143810831da8140f71c7e88815957de04876682652e7b82406eba05f3a9dc8d61c16f74d5b5d96b4d177527e5e5c37ba2f22c3dab9285f509ebc6b833a4a58803bbaa701026ab85d7e78711b854c7ff9cb02a7533effe867ab6975c4b0ab87bf5c7fbb6153c63150d87092156998c16280957be6800cd088270f92e6610d7d4498e7a6e23d78fca0dcfd81b6be60645e0c98c5c8c68670be90df1f9950cb530fcf624eeaa1df9f6d8abd10fed0d94c9c6fc0f73c12b9a7dec0b5bb87cf5228d79bbf84764d88f7e562784cd0bef73bfd17ba013d82e03ba8038ecf3190f0ace7e3621f1d6cce600543e8de2268ca3ef3c6c6c267b9681f2e1b2f84aea6218ef739faf4696ce89b9f2af156b838ed7400e207654ff5e67bd95f665bac617c040a35f38f07b939c95878e1d55516509f6da68b353412dbf9419a3276109b6e694df582caa5c7bcbdda65dfd0a0befef388d95679ec3561ae588d9f5c9fee7ed502f4a3b222e528ca872ddc595d2b65a78890b6ea1ce397a6d63bc5ade8f46dcb6efe9ce393c640d7ff8c2bd074ee463c3a90bb02828f40e1bfd8f4cadfa71fbd949e83e2bef047cbca25143fd0c34a277d930857ef0a30ab880656e0708d6b771cb3a78caa868a676ab47a98f6b88d0807afbf9812481dca26b9d66f7b1f81fab9194ee47b666723be3652714433eed53fdb690900227773cd90915229f52bb80bf38164441baca12c97233f04f040be44f38505cb23cc91d43c6b20ecebf7a7a7268feebb487375852d0b517e47d6b6f0eebfec1369525b0f6a539a84535dafe4db2739844b3bb618ce319071a394a2a736bf898c3379501760a8efa237e2d8a312215d86016c9f414acc1d984f28647a96de0ebe0840e1ba83f62687fd3b1c6d405b90a077fb1a12dd10e55d0ac1359bd2329d4c532e76ab8abba835f85251c91b78e7d1483a5749cc11d0b46f1364d6e7c4b0a5ac55b8166f2621706e95ceb9dcaccc9a51ab51539b63af71382d2c29ac28fa18766d793b162c55d0a74459285b83cf3310b976fdc7aa7f2de7cfb39e3fd020c24db3b04c96e54d45d873075d048a759ffdf359149e3acb2abf203b79505b99f3d0f88a10e25766bfbbe3ac893450fb4455b391577e4d81f093a3dfe7da8aeea3bf1174df19f12b8e949def501029ca220b6a8ce99a9978b2398d694eecc8596f879d2869151571433b1871fc4de80200e3b7ec184d5da664387ecea6f4a8c5bf53786dbcee5f80792fdc2f566997797bb00779e507ecf0922ae3d1bdfb45d612a3ec11f1aa37eba74b2a541286447e986cda6ec4da1dd78a8abd481db31d4d8e48882be0654f553a92b03c73bf72e082caf123f94c0cc2c97c1600b1cd78c2b9df0b9eec11f552e3beda68b966bcd047755103d33c0528e65b1af1af268fb85b0aabba34db968ea66463bc6df53782217da1642fb5aa09608a1ce98e2e919030c6e0e4d5da95e08728f907641d996c3f8ffba2749ec2e19295cbc9767ff81fd76362065acb53214482558330d5498de42e80d3472464bad0b64aedb8bf7057bbfc400840d1447762834b32225cfa40d447fd0627d4b83d49f1612f3bd446cb34d183cde478260192b412050e390a9a7c3063a8d58aab5ede9695636a6e810e5776e983094afe418232f3fb0a40cf0f96b02372bf99594ada490fb2eb9b9cb3cf6edab863392c833b5249e632886fe23818aee19263343ec3304c199c38e9155158e900cb08f73be28d60e7caac8669c1844788079d3b24fa7973f4b7bba55bc87c4cb18bc565be5b72b79e08c0294b7fcf5cba6afb428f82a742b85c6a8e94ac38a70cdfa6eec526dabbb1c2e2f2c2a97c57721ee71562ed756bc701fcfd439b34d91a5b83aacd54864ccdb2ea2aeea9449f99da9dc7acd5138534ad2097f3f7860a59928b66edbc7cba51d49197083ac3826b2c28cb649fd232a9fb28a790d279df281bc46b83b0bf4e553099264cb02ee0399217dffe0dce9e2d68c5c2f1763fb17fd256d9f738c1b34d8e81a6f87bfca0a1d0577f3339c365eb9b5f33d6753d732304cd4f6a6b1c284fbd190ab388ce416c05b79250cfbfff236b35f5d431cf412ed928b6c6b3f2ef6ab2db1faf4eaeed35d6c166cdfb06082d3093844028b46eccda392395b4212e783eab15230aeb0c8cf5db7866ef0d9d588c68d2f7b7201f8e3ece3eab02089325cdada5e087a5bb3ddb3cdfc3ea5ddf8baf8ead3aa061628069bc92f73ddb75de61cebe26c29222faf83bd9bc1ddceef16d1478fe50ece6ec0e32f6d3f07e875b57a84f5114e66d852ae1deed2005e7b615e4fdaad2fb1417f2025c3cb6a76e747d5fbd974ac42bbd2caa52f34c66ccb36506b9332de132cec7f28e19ddf742d621efd9736335c0fc4920528b420bd5ec38af098fc2a7e05d4f745e8060e8b42a72d025b53ebd250b631184226a58cde7aee807d9a1d91b1337225541e0a8e7b0f8605b84e04f90fc8e2b481e1eb0a949d10e6688d4cd6e9a66dd7afc054b03ac254131437f3fb5b755b9ae48c460bc60d038bb0986b24ec630567201e7e05a2da0823b34d4e7b0add945e6787e9b028c9e0780eef401c073b545d42ce02dfadaa9ac073533368858867b23fd88c34f06a19fb2b212bf1087454b66c34f5a94df016dd9820b2094990df26fd1a982deffd4d96bc92a60c242c4f0b212b3ac6ddd9c6515c60b7f6089996973ad76d4af183bd8fbb158b32e06a755c549d5780834638778cc33bda30d08440f695dc4b56e937ddb3cb55ebaf8ea6c45a36317b36e669a2d1fb213e15f13ecc43acde426c5e4668ae2916c57890717482534b96bab15a416c0bfd3052276acfdf8a27aea2167a9d363ade22014d4b069c0df30e2f97198bc3fed61dde518e88fcb3a032a41063a3359a94a590054a824e1b1fbbf4d0d46d1d9449a21dbe79441057fc64fb251c6729d5e9e28c5f6484de554cdf13c7db3ae4fbbc56c10a16ed8a564fca4955499d09a312621c1a2418504aa59d79d6644c4b9075b71ee320e86f8cf2a75f50ba1f2e63ca48b5472df707d3e504d3381593ffdba757f40d61013b74e21a5026ff3ad27e1a8a90ca4844010e30d2ac8a8fd0b622d9c4435d8ee2ec3896a89f71a64389799adb77f20e1a9fd15f4f49e799f748c639c9509070606732d1eec46b96b324d2c0808b283cc56ea510bf2b4131783d9fec188ad96964da6b1ba279e06bb81f70959f377b917ab8b233d831c969c818aefc39dec45d2d2fa7a5b03dc57afe3c0b6b102766c4dcc797336bb5451f510e78acbebc3d2106691a69104fc14059f7b9ac2bf5f1d30ab57787660b182c40504dcd0b3e9e2b885d8841415a1332b7e6bb35667317190847cfd508079341ebf363109a8f2aa408893b7078b1e14beb242468cd938c884e5a5dd386fbd52f18822411abfe4970d42002ea8f1320ca229be060749db4bfca35ea6220779af0003fa4dae9017c7f581cdb8c68d4ac067d5982a9a023c0cbd036be1375d326f4993eaff84f319084f771f1143c393add5fea7990edd53da239d6c7cd41733b13e3b816ee24cf426040808dbc86a74a89db80b0296690c1426305562ea6ee7faff06d1b59292bb530915e7676be901e7d20b3607f800e26a1f04cb513e7d03303f49cc24ec35cea07c0413d232f66eab556c4fd6fd050a9445715cfdc49ef7c3b96466038df7357a629f73b42099c2806bf4c138150ed35d3772e9291a12a1507ca68748e8426f4870b733e48bd90e1057197461dfcf5fc058b99355aefb8263bfce35ab6da2b860092ac4bfac233ce22e6d42f6b5512482b57ec000b46999504fc5be4e4dfcbe65f10202aba7846569c6f6349d437739594d5fcbbdc5f1137ec7f98cbe19583ea284415e79232f9f41fdc60d467e7261b29832ad5f83a5ffc5bbf9daa140f7820d53e95aafcf868dac8e01103e3f3a177fc18fd9b52c62e6752efe85b4c44527f38c8bcd4377196ead6405feb3d8f7d1023295be111542c62414f6a7e7aec58b2130168477a8b2fbf86678d48ca01c63f4bbf228c3f515b8fe4da742e828ab6b98362a07f8f1286b0cf19919db0484ccd013f39cfe644964c7579884704a51bb29d739ba15b5fa525fc9e3592b7a997439b298a98356fd6de266898e185269a4f4952533897f707d7f833f384b9a1de1806fcaadb7c4bb7bd5cec02d2a752a5ddb4410274e133c632036a61ab805d21e6ff5e7dd02548ad822d8fc90c09412f3b0a15a5c7b083f0d55896e99d365834a3189eb0e80a822abf25deec6e89452c023912f49b16c126099c50a691beaa0d56bff001e4161e5e76fbaaf16d128d7ac4acccdced7c82f00f80a03ae456b5a4009a36e7813526e5d62aff511c1fd62d802d727d55c13c54440a6b5971f51e846f3d50cc448cc562d181b971cad9be66f9ff100fcbd5358b22ac95edf68ca27bc43c397c6a9a53151ec2fa451b6cab25f735a2f5a76f822560512e56370367b6992a5e2aef442ce76f40a11c4c02f22bc29a72b1015dd7385331b05046ff7dae03e00ef8a5eaf07a55028ab1494d338a1087028e2048bbe3e2f87ae8ee62daa4cd9567e66f26ae31a032746e1c624ca3d0f900cb635dc572c1ac8bbb624b86cc13e23c65c8cf4a4f93e474ed5d0ba5ecb16f30f78f6c2c28de6501d251b0daff3562e96b4c7704a33c985092639b0c0aad6809784d4d3ec8d657b01f47194aa3a5059b013bdd622750b0c9247272653ed0e7dc4a46e6ba2160a64de862491bd20b623c0f4f9dbe370280f5865326d3d7bed3f1c255f853b93f8aabccbd56f14c488bdaa5bfad92788708c23f6db1ce853bcd305bd938176068d59916591eeadcda209be595f9970227179c6e84c3e089bbd9879f92447be8463b8f912ab3b26fc1e2bf40cd74806a57aaa5bb5f53ed821317054dae098d6e522a170972e700f7cb87913bfe91c0f45bd4a1c2e83e871ab8eae3c1cee546779f68cb6fb3dbc6b6d925bf06384d359ed7cc6abb112432badd0807f20640f9379d52ecdfcc0d892e64568ba93271c82bbae28084becdbb14e58b5d2f784f28626fb1c4559abe988912c533f70465b9c7b07c0054a90645368da13fd88c0209dfc1667d51a8460db4e4a9e72089046dec34552c6d4e1687b2066dbef08aae23e294c9d274733c5c9edfe4f4c80e535a6df0423bad4751ca5e3fbc1fbfca50614d15bd399cd5134db7d19e0de9945dea6a545c4708147d5b6264a363cd9b0c81222fa74d349c708830725088716c91889969a41a4d6f6987d3505d7352798567aa8af1bc6a1fc4e5ce84c2ad78be90c82697b80d5aeee6f007bbf7fdba4c4778cb65982412ebde31204f9e0e173e7dfba139a1df7ce51c255b777380c719533ba8a6e5cfa701dffd9907b9959363fca8c82e36beaf840f3d7815ce43011b1bec136fd78c44e235d7ce9412454b375f72721609d643d669c26a00e7824f2cea4d461b8a718e748c80e1312c28a518db275ddfa3c3d955d2a4e434fc7d09325b349876c413243d3ba6b5ca9ef2a25d5e8d082801ccefa9b0415890928523c5c7f12143d781034e2d385585a565e11e1a821ba1fe3803d100ce7934095780e6dcd1fac3847aa7bb548ed6e7d90462ec49db5302494b01af7dab760bdf3dac8fded706d986585d761899c45f0f95a095b492fbe0ca99dba93e1008602363c4b004f572a1ef653758ac67655e83ece61178ffb093925bc1e2e7cb180abb3e1714ed74228baa3386b57201b3b031ac18e511028d1bf5ffdc88053a7decbce814bad1a5ea346aaaea960b0157bed7c8e1baa70cc072d53e7494937d5b896d36346325da82a1a3ff199ce097c3ff3b837cfcd922ea1ac8d32d7fa1ed7def9ee09a6d21c5564f1f950d726c1267bf7dbaf3a13a8af61e448a02224a2dd4047d582ab6788dab3a3b5dd484b5b16e3873e4fb49c87cb8868659e8e2acd3f474d69acf11901bad03a088d5ff32b9f345bae57fe3f5cf1b12f32eb833a3a12f6eb56abe57b6a3dc7ff844cef977ca313894a1abcae8a00afc745c57d2d8b1b2d61ec237457bc4380432c312d9d6eb4f0e6219ff5d6c3d626e11d9a0a3a804b6efff9a9502c641a6f619e8dfcd263c7b6ec3eb235ee564a72ad79861bc759efebc117ae0ae8ccd5cbfcdce672a6e6f6d0175a794d7612549725936dc13643b55e09030a5b75af72f55b1a6948145dada7347b9b0ad903f15de45117ce1cb92d9213087562a0579850882451fce0877731af1aaf08cdb049a35e4199509bc1de5919f2bb80e6149e11eab564e16dd55b5bcc0889177936d6de7aab4f4cddbe837a69f4a452309d3b21b9eabb244f0243fcdc7f534a8a00bf6b87fae15ca5ac48588aebc97bb75ec321e846491eb4ca30bece5bbdc96ee4357dd449b76c3443088b0bbe08be7ecfb502f2a45ab7bfc6cf1902a0f18974a87f38d5e49dbacec78f82662faeaefa57d07d077169b520486c9c507b9aadf099c9bb2e97de2f8cb07fdbf34ee2e852baf2160668595f269012f92d611daade6e7875ee235b5aacef664883a1cd870ac70d41c79cd7d4b5d9e70eb524f3b281369902146357b6850d8dca0abff0e9cf3dc27ae83d16f77a9a495eaf61ad53c11cc5d3f6c436cce5b94ff89d9da733c67508173846a0b2dc77aee71e3278e1c9b630c2eee93a1f6d8a8ef773c267665924a93378bfadbb78673c6bb4875eb4db3252510773d40f35b6d19a5571b0e3a1a87e46600a895526855a275c63def5de1311eca0d6169ea39faf62c45a2f4a8d19532cc613a89339bb3c12aa0c8814346866ce1d30cd65a6c726dfeb19b3e02bce4c9dca88d869bbd4c77f0fe1bd246048d6e6243b97588b4de30c739e639f1b652b1fbb207d289bfcc90d29211e0a7e7a99b70686c7dc30761b829c51c006ab48831c6e3bb47f5ab198cdc95a54a9f0e1710e923b4db340e809a19f94df998f3cc9c20f1a4dbe2ef5a40cff0cca7e11ba7e8bc5102bb705b3111d467dffc2e3f319e9a8a65dafc85e0cc7acd70d0c75cf11913c8551cf9fb18e2fcc21e9791935bd563907a7abe72a7aa9da49bfb18b6998bb9cb01b6aab732744d7d01c8920b3687848fc282f804ccbd37e7dfa99d5a9f069ff0f512aaaf18915037c1f1e6a713937725f4bd135682ef07afcd3bf6840c286f0163c3a6420913a84b442c299e8b6c383bb2c83d96b3420b84e7db67d666f090a32ebd90b8558b0d25306d664edccca7ebbb611bc303c199dc63e2844c189e9fbf80c1c6e915043ead407c1aef10d819142c8c3ddc4154534b23f2db9bd9cda45635fab997072e6f9ba95c566a32f9d17542177c3a49e70b156fb5766ed0222796f0a65741651ea38d8de59cb4196f061685f3d1f1a4ec015c22832ff06f0ec3d43dc63763c7a628d550fe40f3584ba6008ace96ce7e71699ca76e2dd58e261294cb34fcf5cdca09b065e3edf44e4578b61d00eb7d7396937be73b8aa9f1a83ad9a15468d09ac6f268ec1c3380b26e66a517eb76f793e4fdd9bed40ad7efe5ab02410508ea3f1238cbcdeace547abf7d40f207bd30b42dd2a473511c26ac762b06cf0f089bee9d6259f809e75cf8b020ec52f97c8e14b5f39b15ab8feee2e35e803ce343539e619565a47f79a99f5a459fc524507ec272fc1f537b25438d21f4e3c493408f99c0806b7684ceb0344f209b7c5ea2943c90860277c4a0d0953d593b057e7f22b550aef1d8aba778cf19544565a9c47b8028ff21592092304acb22b4653c0da98c75546a794043582f166e3dd18a2e90966c9cced46c4232c5280cd5506c1c7b718a43e93463731f3fe0c5d526eff90a7efdd5dcbadf1285cead7f65fb6f21caeb56bcc7715b5cf826e5773e2f48dd8963a320e0931529fcf093c689a319a6904e0927e93e800b345f9624d4709c7e942f7708526813d535264199620e109121824a40506e16649c49347595f0f00d9ca7a34fe9fd89d736cb86e8927cf5bc87b32ba40b49fa43ef38ba788cfe9508a023a7b78f192d11d859dfd5cb084173b1ca4292d25b669fd62725ef494865659484ce3cb146fd06d61818264f86d12bbf08c9d7c752a2e693053e5d698d7c92ac1e0061c20624b770f844e7d2702434cab4c805103da508b4470abf22e71fdc35db9a3854c1c84a3ef969cd190de58e6fc33230140c819909cfa192dbf74355289acf2c90c042eb4eba1e6384a1d7ff95342985fabc4af20245a27db539f97ac87d79543d22b7475b171eaa941fb30d0488f275ae022bf0520bbc2773223a0944dbcfacd4f39c9cf07d29c0d12c70a8afb2b7ee4b92929f57cf6e9b2b4be11c4bfd4d2651179b60beb2e4d431b84c4f3ce8f618f2593df760dfd0866325733ee008c712a83810d9e9ce348ec2a7850f2b98ba6adb76ce188fbcc44a737a92c3460eb2b4e193605adf7ec4b0a8c356f0d4d09c28a514d97bf8993dead9f8fc3984a71dbbf7633310b366293861f704c1b5c1992bddbca7049ab6c95139e3ade20341f7b03c0dc574f2b83576e1d2413f7be0fddf0bac5b818ebaa06189a9f78ff5c7c56c2223623cbb7da0eeff89b7b8205b0a4b33bc21a10546a54efab02ef4b787aa50cb5afeac442ef54d7c6cc8c928c85c5bd50be5a254bbe1046ac95e657533659b1c3b9c923dde5ad43b208f4639d10d6cb5ad2bff8ddb24bf016ea7c73cfff3c9a700b4c7f17ac11a2034c99a508a3ca3afee9a86370eb266e86e7e13fd97f4b3392feee44d5b85f5f6dee26238da01e0ead2c211e5aaba49184dde456ef4a827680166c0e3b006b785cc95d89eac60600fb4d36b04ceb3f233a375b6a4aed4c992826c11e04f5fc06192679b455d1d074c98a3c33ce24eac0f68b87e8ecc6892c5ec42d10ab011343fe2f0a322153263641da1e0c19a4ee5aefbeba71c2287273ead724665821658ce7723ede5d914ef5db559e52a67dc0a415e10e8aca12ec221ca339fb70c3c363cab0d440a382e4d34ff0dd7fb3f240e59ee6e134da1ea84b6bb71b401611174aeed9f2412e8a6ccd6b162d54e83e28764f5a920a6cf9325e5ef7b3122fe2c1eb18bf17681f9e1f84bfbadde427808c7e8dff2cb503a2dd05d4ec04b7002b3beb22bc1a1705608067f1619cd5719369d725562f05f045ece0eccdcd018c76edfb002a2ec5cab3d9df49178564400df9cbe8b941b406efbb6210042f0e708cae1df71643c05d2463ac653a937a4300ca08e8001d6f08525e4d90383926511802bb2f9fefaa7f57ab45bd2e0dfacabab9d225b41fcfc81fda7fecd9fa9ef171f4b1620c9c25e2783235cb2226c6170475c104058a8b4c2e447afb909c815e1b707b9aa241607b444d499bc4baca122ce2f0523f4b73d3176a50d2d7a81e8aac555f1cf7e85ddebb2820010e796f35aeced393cfef15fd10a0fd28ff9d7cdead8e906bbc89cef4580ace2806bc093ac307e942c00138692532a25039977454f436bf04f5e94f609314c2f3f519a39a606df53ef6b2fa3465747f5d43da5b9e9f5fa297c48da77fb2bf89ddeab49730c3422aa4aaff10521aee960ac2c306c7239559ca0f38356ee16a8fda41fbbcc6b43b61ac2e86390536332ee55c135591f6bb1865df20854269c6f8e90e74863ded748df9eeecad3e82e5f424112b61dd79925ecb8fd26f88af9e3e0de8e365c808049a330b3ceca776bb0883dbe64ce3f2740aaff0d57f1225dd4e91f6a3b54ed5b1c4aa148ff357f5e3f3870f06e7404c59092e2ea55128389ddb3ea5b65e33fc5e7c7ac2965509dff0b389c7f89868e5831a63917fba527673caaa73c239a9a4623c21c3f6d0df76d97c04142b38099c4b2b696885a3991f682fb0f6f2bf0995bd12527c4cd31c17be8f134f596b95b92c8d745fbd8175cfe79e4493a61da2bcd3de11740ccc32bad53697f331cb233ca16d7f52e42da65f6890fe0918ff067232da70eaa85e3f543cefa0ae106ba99ac6dea22ac62290d8179422130f7eb8b434174a53cf5f0ca1a6fafd4d44e3b6e7cb9129fcdf1c84b26bc82ae10e59a88021d6ac2fa7b09419a406086c1a41ebe01111ab7d5e46f14ac990480d733d1a81fd1c1803531fb32ed5e380a5e5eb85dbe7ab4d0be07f7feb8a0706664115ef5b1a30ed9193d9695b8a003318faa2cdad0a122194ee533af8055c19112875dc7e8dd18aba014887e11d64eb779a7c52cc3abb893236e3f1fedae602ff583db982cdf6b8fbe74879e322e22df14bd25a8fed0b97878ebe59f4fe35ab2b2a24cb515d3a2016ab69e2478225adfd23f456d1d537f03f49a036432e7bf896b91d2edee813de2b67b2832ba712ca4251ad6a9199fc7215fcb83dde60bc8e77831245e26a3640b543bf85bb60119b8e6663cb35fb11af405286542e23d87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
