<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b00f0a3bb65b964f16293d5c069e8e79c80b09f8f8ae7da6729f0d7745c62384dcb9771350e4c180ee243319b28d5ce8a21edaa18db998272bacc8e6669e303e6afbd7d1f9e1a99de11eca5a4ff914827075bd63d9821bb8f1c1e72ebef7a4b80fd5c118f063731bd449820d0e71de18774acf62b7e432b717d850e14ad8a107539e192f2e65f4767a843ba60b5ab2c59f7764d6cc7d11ae11cb9f73118b33e754e6efa20995d6c2839af01bd3347ecce21b300b2cc40939e515f0b18abb0b50d562857c59efecbcd9333d0a82d10c9745987ed180a2de331705b333cc04fd9d5edc301bfed7c76ceed0ccea3e16ed0f4f91277b6099e5e2573a4b35799e417fa40870585a26ed3634569e0b2810ead58799faa4288d5332ddd476d6e2ef970fd9e7eb403ab2b08766d329f232d0940e05a4e1286cbd84a0d696988ae4a08c97a8a63924540f3e8f9e2e5e5b14e5e25ce9c34c8c26d4240764cf1a6d67ad37886b0f7c0896be713fd6a4dbd742278a1180251ac3aa687dc33ccfde4c6456c4e33ee27b6f7cb88d987d66dceb73c07dd1a863250f22eac47ae6fa20e1dfce564c86e873a023927ae89ee8de09190c2503d4f7eeb4fb2cb5242491563facd2de8a6eed2acf235de73b31c28c57890c322c0723b0a3b1844f04a7c0c54c128282417c1765cbc0d0c629cb881d845ceb45ae282c7fc5318ed784c2ebf36f314d6cd813079d2911a514fc365bbaf07971feb9ea0f140bbd43725e53ab4ba8728c57e0d1d4556c7c7446eb7a87ae9130ded479c58bd4488991472519905a6917a633dcabac961c8728a3b63f7a3d0534d818edadad18f253f45f2d5b9bfae10ea6c71c51882a378402791139fcd133fd269359123490853093b948242c4b0b090e5098d71f4da5ccdc1c4cb7dd18483bf0c9a8ca486ffb4a285fc4199d0b414d44894eb06b50816260943ee3faecf6ff0960691d0a0efdf7dd3efdd092c9ac1571274c2ed74ae11632da55929f4963bf62963742c913e94df2eafa43779abc124c9551cfe40a3f73afd0fd8b28c7ec3d1fa6a623f8b7f904dd86480a6677a61a1d6aba743ba2ee72e9acd8e3453e14e9d1a512918e639ac5efbdff76f938494efb6aa0bfcfff32e65833379d0216859653ba7f01dcd2f4bfcd74d84ea522b69b2eef574b79b7e101db30ef9cfad8c49d70494845e40f4920b9da1c243e1cf4660f42a4f1b488663b7a58952955600da32a30c1f69e63278336fb6202c9350f2fa72f35331569bf3c3842504c2cd80ade57bc480627382805b8229d8af44745baa12a03b4cbf3d0d93d2022e0c08c30bd5ce221b2d2fe32cfb59d0fb04c6faa7b1a3891003be8ac9ac0a90bf8da6d7766dc12ee163fa0edc9c0ec1daaa823445c88bd23840555162d4ce8bd3dcc40b972cf5da796d5ae2978b261ad8a054e5ea7bcbf6c771442cf747bc17d23ccd65d91edb7e5094fa1a4a908d7529d5734a32e0630ac8b24cbc708490b85d115676fed34d04fc22a32b6e40b134eff56c53fd310e6e0c047110ca1bfedfd4a9b875930568d3fbf135944728be15db8a7530889fbe9fd6b0c026858ebd15206714091ed12655f3a565a9937f0acd21b1abc039cf05314eb80d2810c319b8477cdee1a6485b8446269a4f5b858712bb0ecff82b6b261a08a72284bd9422a10568d02e8832b51c7f9b6556ba634a621264012467f41d06e988f70e5b82e2d3f4f5c6f7f0d694ac6d895d05ce6b2ae631d4adda86803013e88096453d473333c46f95cf2bd4bcc2f51efe722c0714b7914e6d87a75d4de8bfd83a9d7bc380975c526596c22e9586ef5e8b5ffaf0766d46ae74e7fa31917f28c6208b920149c9742ab43faa756fbc558a58dd5b01a02c41afd4e78d07112d7d47cfaed1ef5a5b204548b2b3fce5bdeb3f174b2ae55a2e90cfde8a202f71c1d49ba70bce07c99bc76e32100d88893046037a807b69c0cbb578c293dcc5906e4fdb9466041afcc11ad284f1271dd51a7bbecfd807c15e52680dfd92c52df8448e8102a34ce111f57fdf0673dc91eaee397d000982adab2292270aa879755edc911b168c36937b3b5a8c82803e48c71e02d1592e8079c1d2681975f3038f241de9931021209bb32f6d482214e2550a4ab03fe74d34264f6b0541116c56bdc58c42cc89a956bba3d8e6371149fe3e429457ec218c5f9b1aa955675fddf0a5fabf89b2b204eb86aea9d1a01204a074e515e87c81c106aafb2a25ce449d19ec921099ed00da5848e7ffbb43b83fb99b4d799c52da43fca0638fdf50d13219034fbd85024f60a4f789a6ebb276832f49b414280b47e738858283bc55184672a175bcf934c75cc607ba4788615ac8ac66e25af152c237f833fd7d4dcb03029274307f287bf53821f8af6bb6b68e6969bb25a70692c9a6b540b735fc33352b65ced728b843a8e53bcf500053b77cd16a330d51b7081607f87f26cbe0b69205a9b2f415fe1b030026250936a6402f5afd99034a80cf6d8f126f89e6043df90ec5dab90241d064dbe888041148955a3e4a33ff73bbf1c07dc5a28639db764a27b407a1e2f79f07d44389b976ab9139d01d2d754c5a1566f22078e19d9a40529e8d441d20828f11f4a4543bb86946fbd20c92cb89ce8409f4b5b65ff9f247b691ce96f454bfbb63c9b339c335fab2ced59ebdcb850dcdbf3b6c67838559b5d997b082be6e18c7383f9e780a68fb28be45520ba0a4a5daf2e7486124dfadce99a62dfcd288bd62ec3799c129e943ea4b364c6108aa9e68cad08d1258ac4ec7c342e63df3cd946b7662a7082c9c3023737705515392e0189e9aae137b5a2a0f8c8de460d2c03a93579d939ec0b31511dec7e2954356a216c667bd6bd884cd44ce61043b44a85b5dee39eb07e0dc250e8ae7cb03424e9392327826c94ba124a4b7cabb841ea3f1de17cea3c8b0beb008ab4a4dd29c6ed6a3fda0d1183f9d3d0e4a1eed83ce930f9266d3992509f89a761ea383705037fb6b7cd0958ef3c76c1c2752e7f675e8342e333091fe2723c733c9bde055e54e50240c97da3d8ab8b240f2640e9342cf5da8e170689ba9df30ec41e9cc49ff7007b2a8990189fd656a4342bd9502e78b5272f2fe373694f8cb7c1df35841c885b900d0f2cfa6695b3db797afa49ba6fa93ed9c638b9e439a0c6bd13f524977f6357f7ef61bbbf6b06c81a439b1147328430e58d81ded8249276f0e51948e420606533026f065092a990be34d38c3a65f336732775cb78b3a99a3908cc56cdf63f60ab8884024a24f79eb4d6414bf5e007503bd09b9e1ad89c07fb48541152b507bf912839598fc2d9b595b3ae73a8680d95d64dc62e20e5a990479d748034533a70842bf883e929ff48539381b2bd601b95bad83d0dbc3d5dada835e1cc9bb1caacee4ec74879fabbcbe0db94768b0a79400525aa4e787d5c5dc65a89283506208106298bc74344e4fbeac3b049db0c2f98bc308969455fa985a78fe907753b44e22aa5085f661a32cdb7479dd6d7637502696049b9fa121765e8bcfb0ec4cc85dc81b21f9dd79f72f12defd93a13bd0e881cd03fed425735b8b94aab072df93da3a2c9bb241c55fd8fc1f596bff2070e08fb7dd83ab12813ce9cb4e9fe8786b66b23171da283d3dae235346631bfdfee145779f2f3fe10b2bf7123bca4c84b64696d4b22584a02ab58a690bfb2d187bee7b6effce6c8aca1526f7a02cc53d1c9d6634b197dde75b8ea2e54e9afea0ebec1b339bc0b767b89d9b247bd541e0028db73ac0933c5ed209239b927c1f6bbda74a9880698294b6d5ba0a0a6730867d3d5d135211d19e3c861b6366dec688ab6b533fb4b753ff19282977a4667a173970c9f6e7e0f404c8dde063a373bbe09a8965da8562c287fe190ac42b9c9f1fb42189cd7b626471fc17be7efd060579852d4795e72deea6206f35ac5676fa4e5fd9eaf24b7b937cf54d90c3aca216de986ebe103daa10b648cdc31d4d5264b0e3a2fd992fb974e6a4c0bbc509c558739784940c39b1b8317ea9baecd8757365684b559b9b25243d7af5cc5540285a6fda8153dcbf31f924017dce58f6498cac3d80e6268bc848c13881c284faeffe1bc560b52b10c9d647c0200e6bada12b1729d3652b7bd8293e36a1cd58b050d108ed243749ca4657a4f1d1d6f6d0f9e08b852bead62efb49776961b876b687200e8c5808d79032c886570871c073ea6894e5210c415e6f6e922240a63564637b24b5a559ed47119a56008a30ababa375b8ef8f5d4934aaf9297353db9c0a85175fa2a5a546c1c0b5c3d7bdabee9bbd2183c63df4e810bfef3a0d38c286b8d5513beb40f3fb185eb5643b351771cc3a194aea0eaa187f9b4a80e69c601fb81070f067cf64defe5e431efb8599e1cc54241174dc8115094092ec7a2ace2c7734e5c2943b9166a8cd9691f1c8fd429b3b74a16c65de05fec5956a580ce4a75cabf6a99ebb7b1c6c1ded7ffc70d21549d47b0b678071a5983560e9a0dbab25afe623da5c0ec5d7691d9d7d30346f273f769f780614c381bab65220aada6c921f6ba691f878d5fa9764503cc0aabaf37061eb7f7559800901e11e5d6222cc9e91f98bcb7f6a287d3eead4d534b2085b53d7a4700bdaa5cfe3ee61d5d9457eeebd8e7e44b7b94d0fb3d6b134018908aeeb22773eb5f460ed4c7c21af74ec012fc047239eb189a4e87d84d30af9adb391431181e412c25b1df37f00d0c19799ed6c828690c36c8c08b64a1852ab8e6c813c21ffc08ea86e8c6b3b9e9df9706ad9ca1f81e8a4068c5f3825e53af4fdd6918f1dc5b805be45d07c3c730f604590b45cc1a09306fbbabb389dae41413e1edb7b8013b790663e72b8dbcd3615e924b5164833154f553224f5a85db48beacd33dab6702b4e7bd0048b6177e5302588e69eb090eeb2230ff4198dc2687427b74e71658d524ebfab8be32de46cf28884a7b2a2ee4a69c43cdb0597616bdc56964f91c72c1e744630d7b30182ce76b1bec5c5ea465ea13766b27684239c976a64b8d7c36b5210885e23e84c9fdbc9c2e187f62b759868e1ba959342e94641cbe58f996ad0532cbc48520a77953fa72ec705416053052e591d25273f5b0ea27d9fcde1c58011bfa3cc4d9e1dad88fd4860f9900a6a4d21706a31be8fa29ef100a419c7e59fe00d98da093cd3e833b3a23ec5f7e96287609d24a13a2717ab449b68f774503fb9211a9355a52dde7f7cbe9514f08176688a02621af8e06f56dade448adae1ec0430abf1ad96c4fa4bc9134310906c81e849180081d8135f73d3a27b4181838184b0ba53388c7b583a9f0698fd7179be6ea715a771cee099eec76b432f5df3e3d4119432e7226332e13a3e41774c924956ee0dbc143b6185afc3f74cfd4954da13cebb7573dd64f526888ed89e1f59b73bad3977241cc0bb77105ec07f89cec8fd3e6271c2f3a7b26adb5af425a127bbdad97cc2f7b92ee782388ba7005fad760d5937057ac190587875c58dd5d6a07af5488b7791d08c9821ad3c18a9eadd3fab9547a20a61c0bf0798d7e14bd1784fdf0af805321353b97ca3774c01ad1aef6ac96aca5c21a6ffff2450d9335b9e58afccd0270d67b265e004e5111ad1876f06cedb9d369af471b9ab3deb7f6d824fa4f471f0a2e84ef99ebc528567afae4fd012d890769b7aa5cbc9c567981f7a3dc0f6c05fa8534312f725e325dd86b2fa8e80c39eeb14fd11c56363c111e26c282e440e8e7a56267423ad44a84f0aa1e2c72208c56bb501c2ae3648d657af920c7ba30cedb252154155dbd8169c0ccaf0976d5a9ecbd8a9ff8ecc17e706633a84827b71d6b1d4e7f27d6b29bdb8f041b9cf972f23f6d71118727ef3db4ad0e7dffb8bc02d82f368a3a91ae86006b27bdd84a1e48cc6ec544f198a5c11c52d0bb3c562c2eb541f8eb70d28da41963f6cbf747df3ee8f3ee07a8aff1eb73b50760403b5db3a5463558d93617dfd342523ef3d439a47183c4d9341234085ef852ebe4c83232de9b4b33db8279063210a77d2b584183faa2dc783ebe320d25371f204ba537ef35e02cb6a70236d6e1600fab83e56c718b4af022a37cf4e12c3226db665c687b6eacf3fcc5dc23e70c36ea24c6cc58baa66b43bb3436bb526fd0f6bda8cefd135ec844bd8f8c773e5dad5ffb3fc403d255a4ba63d7be0ba71ebe18b4f2d7fed0bab5d6f9c2e3c0ab346cbdc08c655d0f3df5c4ce00bb1d0160aa4839348b87915b5d226b3bedae4b229f4433f1b7599b14b75472438d88f23a020c7c9464e67211ff7c48328203333caf4c1ebec9b7a968443b0f4d4c0281a2d390d7df7f2dd5d0a9bed74cfa28ea6b0d047a4592f279c0b21766647acffb1b17bc7cb5a50870375a61ce6960c4b60c5deac9b44e626e05529750e50fa71af1396cca01c0be33f5b835b2ad6c3aecfd0ce93e7791307789d3443944fc1becaa0404a635410807914b1baf13c4520067d8ee555670c1d533537c38a6b0c3d63464b1263bcddbbf0aa69cc63b192594c05cde4d30d6956e97a934f02b1fd35380e79418031d085fb0fbd87b8048cbf29a5b93b7a1cd21906baa4492c0a462c4fc67682b3833e9be576674a786a11e18ac679c63dec3ef174a4965bc2daa55a659db7bfcc390ffc72e82621f039f10fa65ede752bca25fa94fd0e20fb1e72413fac05ed36d48b57d39d29cb0c9000202d36ecebe6640d9a064c1d6001c3604bea9fd438be1b454b6e249140127f07b925290c6f949d5cb067e9b7eab75a6c7f717a933f0fe09576180b1b03a34cb9504ef96f638a4e1e67deb1eb85e1d5eac406bc6f1d40a6e68a7d21c000aeee5347916fd0d8ea4907f925c92b67b08b083f850e606f371dfca3fd09856cd0e7eed3d038d82b27937c16fc44b26172cb06d53994308b88dbed980e09365b47581934ff8772c0b154c2777fbd13e3a99f21a8192f5798da841c2a26fe1fb2244c07b50380b0cd703b81011da57c9b95418d3ab9e8de4da9888d28f215ef8775884680cfe49b54487f2a827fe022eedacde436df62cf9e8748422ca8784c62a21526004d938818c4a501e413eb4626bb057e41d6d8b1b8e86652723dc1108e58e1abf7004782669491194d1687b7d5457df6534d22ef3c339dbbd8d6f22f1e2d9b43835ab7b44d10f8d60339090e356a066b507eb759c532b2484ca4ef172214350c2892c2a8d0476d32428547334bf6c3247e56814de1c70bb032cdd9d5d54f39e7143de18b6cd1a98b77b960b561b1fd8529eabe4ecd548b35f315a40a3d1f1be0cc6651d6aada40df6efd3c0f1437b56f48cdb8d2cc1ee5114ddcf201854798a6b9c399982ac79cd8b1a87ac1909830a92918fb6efc8624c437d5afa897faa14e868048f1b0166eeb2b74bf865cac0d2fddb3c73e6519eb2ad42dc6ad45e9ca98b8307308cd26302a21480fac0d048e0462059fa84c7a057aebb09a215c3e826979989004ef2663e1b95f21a1b225cdcac22b4e65afdce91adedaa13478504eaf9c147c2a51c45d6c0bda126a7ae50d231b03a769965810dd1ca577054503448c88c3faebd156d84f1c49a12e4df02cd9c5358b2b45a73a3e636330c919ad5a16a71619bb986c8fa8047bbda0f7080d035e30dec4c5ba9a3ec8da27f9650f598675e1e56d5639d9556","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
