<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"874de9fe4714f90f80a5abd4e77cf647084d70da263731c39e360dd041142ea0b368988183b05468f104c0b8c852cb04290e2edba61574b9b05f0914db897f754305284e212da6db80b3445b03285b6f7e0afc7790d416dc9dff0b7359ff7f61c55db738a15bae14f805d1efbd06ef60c793d1bc0266f81ed245ffc40db5a9e8cd4df2ae45acb7cb9d488034c444a602b50cc0e11f99c3dd67011c567a03c9ab74f97002d9bb2595681664ef2ed3c0998a23bec1c8d15df742d889ce74d4493574327b74947aea3193f4f3580deb5377ec2324ed73ae785a9bd26b2ec96e9dfbf8b74e91dbe39b48cfbd01424c182a947cea132f8522c9c6c545e81e19770da9900747730cc56241782bb3e54b916867e79164fb241d593570582a73b400e4f2e3910628c0292888669d746589e3eb7e0a06a8b82fe29d121cd42c5fdad5a2f228cec7388917088e8a941dd62ebe7bad68d361caac22d7458cc60f9b642906641aac0ee1dc1bc7be32174fde486cf11168f1b16c843234029ea875446ebf65fc78450097f630841351e325069ae95c61b4f0f83ccf94b9ae8624c347687249334485915ebedfd0fa2058ab8069549150a29ef300b88af6373cefd63af962fceb3e8d0c298fb85a4450bcd225e3a631f2226d676b8c4c6347b248c502062085010506f694eaf74b0ba6af35059674aff1e88eaa72a6a3b2b5c8ba4d4edfc0271b24e5926713767e5f970232f43753657cc96360f6100779b56e81116ed28569ec186669eb71e5f5dd311cae1f7d321769cfff95cde3834ae2219ef3843a9bc531a35927018721d9f0c8b122a370331c2d06d461876a1796f621727e1ab360e689003acace1226ec6e0d7590cc76aa221f59876e81664d35800e7101d9a9b5094a98d7f7293abf66aea04cfc2d2017ab860428087eb587b5c8facff416aff1640d1a0c89be9a394d00af0a3512e7d46c5499c457e7ffa2e0bb05b63e3299cea7430c617828863a1d88b1696938ad113454f9c97fd40651e9e7f4fc69e2acbd017e8c9c98053bf269401733f4061d107093c3223ac29f5a961b76f6e043b0211375ae10c4148c6acacc4df53880086f61035b06ae7216f526f56c26baf158c9f180f2829114d9a0cf8defd067539f2f2d12ce40b85bbb171793a0b2de05a2bc3238ed182f5c0026f5a644020622c252a615245e589c5e5bbe3fa27559f1f77b9d51441c186c49051c9c63c6ca0d568b0d947d834b42f991a7ed754018eea9acfb35286bdb7caa0ec188242bab5d69a076b7153e1c464cde6fb04e569d19f42426cc1ad3176f2e33bdb0ae1d4fe8923d7014ef1b450710c10ef141adc7127d048a32e0d1574ed8d1c7a5dbb4f2ee36bd8330a9c4d6c297172740dfe487bd7757a4f80cbf6aea9e923f7dfb0541f20647bb948dbc0d86ef1b3cab6b47bb45f5d40a529c5d9f97f6f86acd69c94cc97b11e8303efbacad6100db5d7e6324da49f69f00b95399709f9ff389ed2ad2b22e8f055e8bda880d0481e0826e95b6959b7a8ba78635b0706bd5ae1f02e07ddc8de9023f8a974cc65cf877db4bde1c728898eb1de418c52dcf16c692ae7c5844a8849926a4f466b2bc0cb3e32458adb1dc482e9adf44f4e551e7791fe34161f730e0c21a56db5c2a0fe9622c8832771086e75e1fa94ffb5be292c2fff30f3030b088e8aea45dc5d45bcbd4ced4f9963d047ae372f70ac60d27cea42fe608e34e5886174a08aa706d663f5135582794a08fe0f2916a2d40f864189c583f324586e42bfdb1096d92439ff6be911bf3066474be5553582ba2c103d091ff46755c81073b164b08316db782adf150249916074ffe0f7cf7768c98c94e6a980480c5fc50c322577f6d6c6fa702c9720ce98a519f3f6992fb1876dacf4aa8b04bb1bd6bfca180837dfabeadfc0848c68c78f1e274bf3783940199d9b49140c7b716096be9775b4db80cc902f3db5ad139b82e1eed3d6634fe32fe426fa67656e5eef53f83f55220e6aad5fe6131ecb03e074175f1094b6e656ca6ba7a78ce3faa36a073059cfa382d8c22f452976da4f0d3a55a1aa8f16ddd71f8eff33c80ed4c3d455f515149e015faa06538f79e5219abcc6cf4d086df1233e30b85a6e3d7d08c8c8d7480715bf0beb28e023438504bddef802e91e929d78b93a4e84338722ffa7fcd25c9eaad76bb43ce9353c0c238c875bf3ee82fb0f3c797e02d78005f08eb0611979e9c98a25903c481b4a5a5db781a13142715244f80cd452fd7bbfcbb200c9c29d983d5b23d22d2524e16286b3bb75e8ea90f4d6f0b449593dd8a6f634ded8ae811ad42c7d2ceb33cbe0caa8b27946b70ccc17d3accbc97af1600cfac9e5fb27da158831b51b0755518f5642b255216ff8ea6364a9e11e023929c25faf4ca61dfc4e47bb67670e4faee6e768e6db739cf79e12de132bfc753142ba91769ae5aab2de0ce60221a4a564fe41d2ae4e07690c94082e41c0961b8c2637ce80f0808917c2805551dec1ec5e872bf40b3f44e56dbbfc468f67840e175492536ca86196a4b58274e848c70a3862454f048c097e064794b0d0b496fb1f00f600cec13e6a70d45f3ea5da3b83ef8487f9f0bcc6e42f2b6da5e8c74716390c96057e72fdbc7c6df38557c0e072a3759f463b8aae36ea5ba6e68fdec55e561dc3eea8eb3d9aaffb7f5edbafccd72231b1ccc301bf5683f0ef3ec64190d3185e6de3e7e818011a40151b8fccbae6e4f41db1fb3d7ff72b066c78403012f03f1b256a5b67ed56ffa59e5b4b94106472d6b1e847ff57f5077509b873e0de4a5fa5606ffc40ccd92d29866668b4fb00a4aa11e986511b9c1fb08908751a353c85c12b8b6fe7a2cec41ac1e9605d5570762919a09ca8733a4049238d65e79b88e8d57dfe07c560282a987eea9bfab4ad672e1404fb887ae1d51d55209da693066db3a4d7510f4c3e21020ffd29e036aba9eab9fba4b21d555ece271cf666cbccd3682d50b1686267916618a0b618da00022129aeb8968388a9482e38ec993733b4e55ec90173e33053e7a6ba914902b2c9ffbaf95b7c1cd69f6b14f879e03f31f7613d5ba3ac8f054c703f6729659c5e5d6149f27fea2c286823afb97b19b724dd93c0c91c17212bbdeebdf5351fa760725785e910a2d007f230b8d15c3e737b62bd61ef267515299147b2fb35d6087045285b8b5610775fb661265271cf2ef4fe437fbc698f6e1495cfc44b5ebbdccd4143f96f2bdea9eeac8e85827c6079615f229fa76f28422ccafe92f99b5f607bd9f104e7e6d5d61361c1369eea880568a3b48929e456208bf8da7ddb844fef5fce11ebc3e26dfc69f15383c7754c075b562c6b37a18bc121c933f02e9b9b60f7438f26c99513c9a6ed930a7c1f27a327e53ec28cd8a47f02d08172ddeb75c6c6b59154ccc71c35a8ec74c4aa39d44d73e8a0381d4378b655705ec2bfff1f654642f9026a8284ceb554f838f2703761680d7d9b71e8b412b61168bf9731b8e4d71c43b34d3374e043a9664c3a68eda308401cff879a61dfa8f20865eedbdc7147113d7755cebdc230cb9183b59164f8a66b5e135819fd14a4022538543cd250a10c7a8cb2ef62c98056974dd7f8b15a6722eaf38b5c62e7a798b1d2171847cce3353c1fef082e143144d25f8b4df5fe9a648aea7ec4e326835d93005c2fae0fa5e6c8003c903823e3af19bce77c5e1fab65ffa5fc44b6b1d782a7f068faf604fd83a770611c2005f544d1b039dac8fd98fa3ccf6e0508ac4193a134de2db28fb1d2c2fb715eca038a48e291d59360ad342e01e800105cdf86c9f286b4438823a3c39986256cf9b481a11fcaa1697ad035adb2274100d8d2ad2a2fdd7e006ef999a00ac6e6c14f9eff96bb4b8d81509e4baa9713eb5816a81065c86c5f18593028c1a2cc6c34846816a039b24f15e1b9ed1218f4caa0fb5227949f807578d8b342ee6ed1293128717b9a9fbe9bfe78e3e14af69f3958613698fec1c068c14aa41b851fdfa0946107d6059dc0bedfce0e48a3c142dd3fae3f71cd80fe4c90309a72854a114115b4c7f6fd6154e53ac8da349b00258cd9188e2382be7269a918d7da4a2761645e9ef861814c7fcef16a24ec8067a5de2b87a49a63ea10dc6a9681f1febce91862052c7159c60e13ea7f9d912bdd2dae5b73c2db16490a16ccdd4d44c10e5d5ee3a29452a7cef2c1aee2dcee979b1d5f9ff7352926e92e018ff8d142298fc553bb3804bc8accf5f965a0661dbd11de840accad6eceac098c98860b92e3f13a9ca7385ce7ac76a5fb808c99a062b8b1365d968a92caab4f07782bd8023d61f1c31dae9a16de8fdb54e9e1dd8d528aac92efb33a0938da76392431b0952d50c248cdef01b61f75dfd4be3440af17879f935bce212b3ae94333bbd619a9ac44b2d28da19b7df9a6503e4917e45485db580846ba5e125ed1fc0e70bb1df2b03d11ad6b13b6183025624d58d10bc996f2f179302bf764ac47c73a7651502e340b29c133036287d83893e2d570fdc72070815fd466c0c4e7c295b303457c9bf85deb0ed7e0721d2ec5834d42fd41c007a237d3e1c094b107af26ea21b1ab360a830ff3444d4f5c56e89608ea5eef3b19d6223e4637eb016b66d37b82494cc5059a1f10c778c83e5344ae52ba35833d5dc45f3b7549507b0ea48a98dcb41abf64d037252ada9298ca6c6c066bde2f5a564b06954b1f5a051a2570bfa8bf14cf3a011e038cda58bd1814bf49bb5619497808ba42d04f882c4c40f4f1aaeca0b50866bff8285981943379b7735052e10b9ac7303dc24b32f255ae126e3bd1c493ce44e145423579051d5fe9ce93c61ee3bce6fa272014fd1647cfbee79c57ac32c4eac6354e0a85e12a824081acb0e1f996723adf97cde8f517fc6d44866b9b750331d294aee3370363f9697e1b782d039f396532055a5dd85bec3c9376e91a7af7c3da636583ca955eca707eab7f429add6494968948f96a4bb0d551fc09936b8d845bb555382f982a3647c6e78402e5b3bc1804e49e7c22caecc09819b2573b576a4d5a4f9b7de41a9811e1b7a6f43b7d6740d361805257534610022dd4d9de2b95e9ce6ab6f6fddb47b5ea751f7e2ab71787529ff9e774a2d7541bb2f6b805d11e603191e36931d10036143f2399d9998c06b1fa2ca25ab8bef8fe6f56b1cd6b3a0b2e4b951c9f55d420a77c7fc635ac6e57186183e57a5f05727c990d84cabebec03b3de9288c510767dcbd277916cc3e1f7181bdf718140b785a58bf634c0a6d551074798b1989d145d99e52401276f9b47cd83637634b38316a276d078932ae255af969a1739889e3735a6045469f07ce9fa46a8d32f7839c4afae84eb825a70f5b7e9d3fba3788ec74238148c6e45e168cbe2079e261bb2ccb0efc587a7cbaabf687b36a6fad2a48e789dad9c0fbb7d53aecd582733e8e38b5daa2bb98540b52e4ba2bcda05479e9d37d1dc6daba2f1e49c8f2c0181d8d6f55d248a01391ea421c6db8f961b6d4c79e3fbfcd9ad3f3055b055ffbfdc0be92169aaf5f2bccb185a1a0449ab0d356579164975d9502db26be2982649ece8317166eaf78ed880448a2fa8953971c7ba207033f43a0a17abb6bfbce60c97971f1909a3031029c561eccd5f2ca5feae4d2ba25b553ff5d60f182a6c9580bb84985a2ef732da08ae5f48e6f3da2087f66e928ecf5adc15099f92344177eb1f71bc59e92272fe7aedb0ca3d30b746989fc610adfb094b6058656f5bc970ffab73f4c59eefae0e13fba234e8d00e63ce08b245daa90a151999e270108c22ff70faa3e88973c5c5b4dd5514da73534714822e0fd2cb14214bda9ce23056e61a0e3b5c0adba8f2240801909be17d16b7028d5a022e8f675a28615ca6e00db79b13adbc3ebe5901c2993a676473ce7cc063781fb4475d1393a03aedf7dbe1cc10cfc67e552ce034566d0388e0846c1edf97dbca946dd98c86ce64b4d3cfb900494e90602548d271443b468f57f3e1f765abf000c70e21d31546f34e0dcbe1261f8e83b4273da71a96180cc553152aba96d2086d5a739a9f557c798d77539372632cd36394edfcbc6af52b3337b45c0e61f214a7bd155983efec1fab92da5311564cbf677eecef03d601ba4167518975bf30202fdcf1660e9f1e6ea69ed6d13bc88b38acea8dfe07c8e4ea8d4fd4df73975f014ae1d19ebbb3156f75eb876504cd7b534c6b5cd74a0d18823654b5561a67bde090173f481a2fdad7c6f18e64217c411fa8c76d5b75b4a94ccd9afe1937762a8b96f8755e057d7645a31e479e2b76624ec3b64f084e81c6b84bcaadedacdc0bd53ac08c04b99c34236f95cd4b8c9d54ae130dac2c42d311bcf30c3dfe51b3b95c8bb048a6f088d31420239ee93a1a640da50841c448a15452827cbf170616b9d684afe17cc64d4c1905906a2dc441e44e3e78fbad2d7070af175ebb7e8427604cef6c2a64fdeeac38dc63a00c5147d513681768ac7ff503f744c4c2de34338dfbf1e3775d0fee84a3b7693f0d37777e319111f179bf8ac9bd278945a2d5c5922fd54db65bc03e3a0f96e6ecc3b42c0b7cbe41d1d24ae944c7939c3170e4fc2e4efd904e79cac098308c0cc9e794e4eb461233f27a3ad835aef5626fb08ca238329bf7e3d100da9deadd3c8e71c80d76d9ca999bbe60cb54337d1d45b23d2ee712f2f94fc2bca28ffb62af5e703655b8bfb4946ad735e04c22598f4597afa4daa7c2caf216654f2a35a919c2be7019de375105812a01bba4266110848dac3f14959fd61bd146b1a09d67e7f52c5e34c664779c17e875b0a4c468ae5a63d9b54cb5840682e4f37afb66491cd7cb5144612e1faa70b64e5a7f0d158332d38e3d395e4163e323203d5e9d8272c2685300f6b866410fb5405884f7b2a5a687839fd41f0fe6a6d7c3e80178a7a09d75d5a9fd75d3d34cb9a39b182a562b88204a31de4cf34bce5e5e215ad6d028833b3e8f7365061e67cd7a965785230e4efd33f8c0f788a3f2c3a283b7c1b55e9cf199463a7b69b4028e7ba45a7e093f647147959b6e79bc89d032c104234691b80d5d7dd99098b0c80f207c36a81f5743919a533f49ac1fffabbc2bdaf57de390f681561e6ddc394ac6c1e4239f3ed7932d7089415609cbdcfd8cfc4dffeb1a32a5693f3bfb090bd41a67c264af75ea093c91a67a51348e019ee98c821d640cfc442e02c75d032b40617058d27a735532eda83dc17e7e3698ba31631b0843132e123c5e537557258e5b484c73a02f9b6a7afa02dfc9b12534e3834aeba8fde0843ae2dbe65c68d2cae570b6f7d6527b23cbf384f20efc048ffb17059ecc3dab8ccf86f9f6663ceac8ab1a2b26a705546874da39b95458c82c00a1e1ba4f33f38c244b4c7028fb74018739b2a8287ddb7f3f7613b6a4c55137dd81f3477623201c7f1050460dfab1337914c2e8ae7741123fbc2c78af4f46df3d13aca1411ac6b90a7d7716502634e5c022439ee57b6cd109c1f496f0bd560f4ff3365bd796a94bf93c47267e041e79796b54580fa292eef5be60a3719ffd6bf9e48a7cf9f1dbb173b323d9298c4945a1edb4cdc8b0be243548c17e9717ee18d88e23cd5dbc0c5fd9cff04f114aa272c1ae1974daa3d58409e3b64cce88067e4281240d809577f7490d156f41e57ed9cca06d9329563287dd3bfea54f12569384b16b3472e87c6588c45ca14ea761b687358d8f9e452eecabc00a292ddc758eec6e23228777f8e60f16462c7e6459493fac5b1d787e3231e8bdf5c55195b0ce06b7bbf162e5ee80c43a395a1ae57351a60279b3748de4b25e32811de6c1b0f17dcb78b8557e13ec02f9f812e549b1631ee3c6b629e1807a9361d76ebfea213a986062137444c0e4943c241ddfd53e9f7819a98fa5719efc7136c2d756dae05da6fabc58da5a8b498769ee29cb0926b1c243ef5ffbea4ce317a27e41bbdc45b492e16928dd7b205609d4174f1e9f934bfa48e4f743e7a84afbc42421f7ee0f454b1249bc441e29030c321cd169d1e39eadba9a83c4eae07752a9ad39d5905e46ee2801ef365c7ecc1eb7b89d0068b5029d1974562612ad258f2f978aa16ce0fe3e1696c1d1bc0fdc908a6478f6b87ddcbb20d6353c75f90c6fd463452da0d644d093fc8b50e25046f16f14ae2e9834eb3d0a61e27dec4a7027f20fae48aa5d1bfba2c75b572944e11826dc4d8a3625a755a26906c908b6c347efb8f7b3d992c95535e054c17aabd72981becc16d26c86108c17d45e4b4f7e34755d010a107b0f093b41509eca93fe1b00cd91a60c362b18cd641f5f1dadd4df6d686db47edbaa90b079140a3d97c190545d427422e535a9e589aadb63bb06f76196e514661010541b9142962665b9b9e8bfa564b2c8a2568a6f403362f7347ab2da858a3bac3e507529f2a03f281fccac33e96a4a29fa8fd5ea091b4e11aed1b6e80b7ec8be65beb3307c75eb97afd23e7edb10efbcc009fe68de694fd8964241fa25422e2f5f94cefdd95db955f171b28062829e6d4ca673bc04d0bb87d41f2640f7b9f7dc156c6349d1257cf8fc7c5a03389081fe5a6b4167b0671eed44de23bb786780a7497d2cdc613e5750bf3129f746a996700e1f80267178ede87e6a2ae2071c0d4e1568573ea0fec65a62cbab0f0f0d5cb1a49d0bc832c208d4933c0a582bda1c511cc8ef624d9e4e945109d078225577037e7fe07234d3f91ca3723d95297a9dce419b6736dd70ed1a972d4b3ffe428fe9bf844668f076f5e0fcb7d0b47167d8c9ba5ced525c48fddecba267c5786ec8bee30c510e19b78a1456b42610fc24c68c5056b93fbd4232800f1ff84b4109b2d67d9b0f437883d92498f371660a8af79438b9e638d42679126297df874cf8f0e0604fb0b765e494200d92e4dcab02647b8c3e76ad18843d316d4e6dfebd5867694c14a89496c086c26d66d940da7036b076d513af32f85c60924004b169a114f2599af072787c0954d81785c56e92d7eb1871c9bd28f2a69dfeac333b6b4192455b0680e5e4795a601e65013d40ea2a101e2b96c2c2a6acc9c5add0ee0bc9e3c3fc246494e51c8470ad923db60e45b0862bdf933ffe59ce32ea23cf61ceeb3cfcd0edf48ea0099179c10d4d08d12cbbd57c68240d3b835dd823fdc452eff471f7af512b02ab63cdd35d26af109be0c25033c1f983a9995bb63df20c2ca693c8c77b528923015acbebcc0acf957261848a1234941a05c7112ba1eb4a141af2b5bf77a90dfd930436ed2137c41c2c8ec08962af583f9695c50c6855a39dde20927056b789930962e0ade66d9dd703babf29bdbbce97d3e4aa1ea1ea30898ae81ab7a05a53859912796bc7938171ee3b7c2d3d544c808c12d2588e205c3a25ea485cb5976a15446958910b479956cce0f0be3a04179c6cdf6974632f3a646e49665d3d91f6b090e737b404c7a9e035d3d330cba1277e6f021c61d14b5d57d0e21f1d45af9db12941234f851c407c887af084d52260dcf3c6ad31dbc707f5899d9f7c5698b2bc12c9fcf0553bd6dcc60feb023829b4b14703c7b2def0dd861730a7fa01c6d7f3c22dea324f7bb165026f0fd29e781da769ec9ca8b2abc0a7134c6d3fe809556e216d127c0047ebf3f3d45c26fd19f1218990bae338f9fafa8cc11060835ba883fa838ef0a54e6c3e12ca8827c4346e5690cf809840fcaa77fd82f35c9c6dd8cb4f53aade395f1394cd41052cee4829ed2c89c0156b7a9b1a7249f78d71c62ead75acb8466e31e70a28df7d8b08305c1afd9d60b5a22e2aa65cc9343d5aa9f59f267981f65a2728c4268fe2ccd33fa57c9c8a9db8bb105e2fb79d0ed3fd2e2ec3a2fc3fec027b8a246984913722e21e497848c93c2780edafdcd3f798ee479526531ad7c6981bc215a153a6c1893e1caf026a32b7c39796a52515236d085409a7edab56cf91cc1f980c78e20da50b0983026d8a52099769d46b0b6ebb7e8a6d9ff5dffd53c7015ab5adbaacb0441e7810a6bde848a31e128da37b625fdaf48ff95774ab8488d0ff4d555d5a7cfcfc09b65ad9a21a97e448ca2d1247c0481203ba4417bd8446f07a7429f0971dfced95d2f157527ff8c9dd8054bddd929616ecbc67d09e8c98d6757de1a62058d1c42c24985d62bbb6580e3948ff3a6ec849efd4f6bd17d03f6e739f9dae1c8cc39a66e8bf0f0187cbb702ffc77a6c880a8ad9c2df1fc3d8a122f5e5261ff63e0a47abdce821a5fc40844d28add3952028871c3d49fd8769f1c2f0d6f95af42eea6278314175bad39b39abb3e8cab006b3f0f586b3fc6e88b72d08cb98ee710d651b2511528cf8aed7596aaaf5f459280fd902d6671e4d5c11a869cfb113f17153ad422b9d0b5e45dc5a40bba8bf5492b5318a6a161720d01f0018f4d7b9ed993af92def43b1d63300bf77f43769dd1ffe85235aa55590fe57019b5fbed9a522495feeb6f441b6c5524163e3c877088bac2e12bd9985ace0326470db7fdc4e070d2373eadb556da881003150980de149b56fe4d6b5f7ca22fd5592deb13ffdb0df63d7242eae33fbd51e4746449c4ebb2779b7e4eb0765073146e404b71cbadefd541273d35e4dbf4528505c71436d95b3c0d809a110785894b4430b0a829bcb06fea16ebd2026c8ec5139c164e36955223e1b6c081a90af229a52e20f815701ab5aee9d7b0b3750247ca0aa6ce2f0fcd0cdd26ad92876856af3c291fded3f408a86f798e963da16ac0b2f35546e74e357f9833e217a7d139f46f9eceb08ff406579949d8f5dba9949b531b87e1d23a5b891dbcb822821c7ecc935e13d56775954ee2f88885862a25983ceace1608c56ef42ce09792484c1ef4dd29c6b9186c11c259fe43caccdfcaa09e7d6cd517de13e5bdce61bdba67001006adb994c94fc2a96d6744aff4b30a5af3a4c1e9c68912faec996400fb1a1340594d9d8d3c5d84c3d59526f35e5b84db2a59faca543e862a3bd5c9e5789c1427b32ee428b9ee3704c95a3d9a1be54b09e21195aee6e45986281374d886de401022262bd0f25346c3b71893987badc16bfcff6f9586af9beff98f257ca5a5a893e4b1cea1f5108ec6beb1d2bccc72b070f12bce8dfd3243f01b16284a7efbfb7d543d37977b23dc03f4b0a37dd3453b6453ad3a7c7c360d33963a6e66461507b79cd3aec2707c7830bb14a4d56c30958fb1db4ab8866a69d676f1e00322d852ca89c5d4d97ec8657f0188f31d4a778cf3b80a9c6e67a089aa7057eecce5fdd3c0ed509ab758f8513ba85e4a26276f94734b0fd776e74afa1605866ca95554460798beae3e95c6c1405039a1b60fed24721530f979a012e2fdee1768fc493466611eb7052c7fb8f8d65c36b1c8df6a7e759a8dd3d712542d9538d1a97a1813569e4209061476ab4c19bcd7e530dd7f4f3a37be73330b70e8305af83b75cd712cc1d79b158d7c082080ccf1863753a30f70969cebb514f3c1133e000fd534811d15a7f6254a2ecb743df6f4c9d1b81de4d91ffdbc0de7653f4d25c27329d07b3115dff3daede79c592c50938ea581202305e9c5848799e9a1c93909ce2cd2e3ef1615b4610a789428ffaa5b5ff50a18f12c6386ab703bf0d0537a337f716c39c4897d005361d57e2b890c4e45d36e5433c3642d0d01651db7ebeebf6f1476875c145c9a839f80ccc85247cf24020afed16fe871e793aa27aed8f43fe1dc222a49133f81d555fb3bc42ff21a0e49e984f53d128870bbc98cf25ba8c5b6f30717caef84be6342e2702e5627663ddac1f1997b1204ff32f030d3eed206cf6acdaf9e4e1005a101f281c87e4d8952f40fa152b889f2ee7dcad6f8b1808f5a2455bd305bab24b7aa39e3e43ed5fcbc097d5f4d807013d55346d3d5db7e2627b9b2313adfcea5d374d06718a348c702862f46b1b5d0001354f5cee13eb1e87b405fb882c8b54c31059c506d287f3cd4e36d9179c842f107ea1a9819fc9b13d318c2a84d9b01ae457cd590ebb77cc2df6cdf58b05b003770a88aeff638c624139cfb621da4a78e3184acee769ff1b2e86aeaa3407140bb270fe76312f92b3c03a5e9ea1d60d3b751383ead795cd865a870e2ada1bce797d3b81d59687425c531f4e560ae2a3dd8288334e832ad936bed4910251bdfe583ae761ff44b045b3fdb6f0e43addb0dbe037d8baf57820f9c55a6fd5bde7d3f7fd5fc90400dff7d761f0f9683de98d399f0fdcaab7ea69e91b0681e04314d2d9ebae3c356aeabdad043aaf3efc734e28edd6aad1bac8aad604d7167d11058f945b49f21a6b6c911a5136cf5901ba98b03f4ffa4023c5ee96e72c03db2df6ca3f6ea5844600f4fda289099033282592041e194d1007082c9cfd13dca45d73a4e41967078a72f9c880373625f8d61a9aef3073507616845f149c07e39a597da344e239fca7f9b05204e97ad3d7d1316535fac42e5987f7bfb71559d7074674a2f23c6c3f7c0b3aef0e0d3eec88a83cd2b6a2687bae82506334c159fc1c27055c177ddff40c74d37f690e940c8f91d25d8b4510e8bfe0ef76e860e338045017dcea6076c0e6010f4ea4f50030d954f7480d15c538e9af18ad64a2fb6141cb96b9092a958a5d9f941a14d9080239f99b85e85a12ed086c1cda0540b7052494f6bbc41e9a6e807876308db69ba06e4f89bc34fd763d477a4f6a26b854e33cf5988cf4fab3ae11bef3a8c4f1011ca24107f3381bcde448953f708a4e4350cdd4fbf29d461de386d7423458d5540d1c6c1a858ca6f707ade057e579220b0c8923a7b9a2084d2b2dafaeb9dd9778cb200f5f21a600317f56daa51c390e02b0facc9d9e186cc69177c1b6d16b7b0b2a2f5dcb46ec5d23860ea86c9d66a0d699f887eb30cacf0a6aeb4423a8f25b13867d9b221bc0aec1da4058e5265d10aae3c25efbeec4f4e6acd15e8ccc1ad9253249de67e0338a6c70e91dea7776eb1c7f2c19e7838e987611547b86e6ebba8a9a35718f7927c8d21f31fd74c4cc0c1cda7bcc4233156bc5c86ec4db8969b8add0d625d88d599298d55f54a4c7ff27c9d722f9b4f482d3f26cef808883c5c93aed4781591f263d8e1c77a27a140571bfdc509aaffdbf0ccb41f7d052769a8ac361bc3f925f1361dfe08246fb965c69d8280700b52b646e6bb04fed886f296a4d4e596a7e62f797d572c87efec165592c8946a681bdc6673ec91b5119c3e2a456f8797f19099dd222b4f29f900fb27fb52d0b6beff4318748c1036462f1f3d414c4dfccaed7d68f072aab391f6381c2a840cf49fa4843a8d577f37ca4fdf4e74665ccee4476ee537796129a27cd2024b76e7f1626342483d4a39e20b6d371e2c415e0a3a13364ffd3c629f7f2f1abd3e68c847528286df18ac91eae150548ef7902279d9b70faa49e1b2f95c3925a0a345c8f76b553b30cdf48b8bd5d2501e7b03af776f326a212285fdc1421636b8cb39cd53708b3af97c8f95a223e4c9f39cfdb79cd1d3f17047bf4f2f2fdbc0bfa515b65eec395cc28ff46487091a79ace73f38fb70879e61859f4f1edcec902250dfb6bcdcd9a79af6068fe947939f9ca1308a0f10dd3e498a5b9c7388dc8102fc08e8acfa9a48720753fb57b0fc8763dc965684859c43396af0cea2f4c5d6853b8c674a132f9acb6905965fe1fbf010891ae9140bceb574f6d8c226140e6b67be63a5d55412d38ebd9c60a68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
