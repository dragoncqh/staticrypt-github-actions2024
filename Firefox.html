<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c0db65d5be76c79fb5c288d1e30c1e2671aa76f269b8fc77700e0bf140ed1ace097490a241939779b483ac220fa0f1a6f6fa64036954dc5c9bed36081dfb2ff51eab8bc0b0a6b5983c88294c43c5aba842c288b56966e293ce75a8af440cf4e5f49476e4e2c9deccf773ec9d23c7fbf2ee333cbbbdee8526bd5f51e723b376063d9cb1386e20f16a4857acc795a25161923e5d28852720f7f756aeb8d3a6cd1ecd92aa95a162b8db136d497c51f847c40dee984a76a416d2bc1fdfdce4bbe03bf30ff65ec921b0554861f6d9391b9f2e0dbd1563055b37f5e3a50a6240fd291fde4c33d4c08e0391be65dd35eb8c6d533cf35ccefce35498be530a0c780d2219b43daa05e023ec423c40bcf26547cadefee69404353128085cf1960fee49af2d3c36923deccfc16310bfb88a5cd22aade3b3781e841768f1f5c3d0a3e84755941019f2d7c5e62e60dfffe4ef7239c1c2cff5839058fa6c09d78c1e1da8ececc30ebb030177fe30181dfc606b8f8cf05e8daa731167a11ec0fcf3fffd4bf6d3b4b9570f2d9c6cdc567d662f49ae641728eef7de67f61d0ba1735c8f238f2578b1cbbff3648b0764c2b93cddd19720e49d3e917e5a632c8cb805ff6ea35538b9d8c48ca063d5b9e62d3c279e4f38bec591b56b7cfb2fbc0ee0e9d36f2b66826555b20fbda1ad77faa72e9e2df5172081fe0b20541802b5e6b68c3f7ce1d717c273f32fb7221191bcf0a157bda658f9a342aac3b88dc642eba9fa45181188ca34c337e4f6d437279b38b78494f75962e38da7591357a4b76cf2f38e0e50d8e2f7481e6ee3c24517cc21a31fbba7c769ba5237e91643df455c66d6763c591c1a79706f4c56a3ab892a6fb6dcac169069f427ba05731e8574f48940f14de4ffca85b0fe7f115b22469c2ef021430159e3e1e4a690c2bf1b72182bc0e6bdb389c7f1f173348dc5a66f9d9d3e1ae05dac8675073723dc4cc44429778277f6ab21b2a3e3fbc414d87f84ae3e5d2e6d06e1d0e73257277fcf1e3eec23d3ffbf295cbb7bd7dfb85a237197988b41b4cdd19855c5f9f78b0d2861dbc395c59e2e5d669ae6d93087d4f16e27393d62483e5744b4892500e2cfc25e08c1e77534db9da8a7e9655f31de20bda895f7d9cb56ea3faa0a549d86f24f262d8d1b6bdd7c669762982820d62379dc55017bf18ba7b1e764cfafecf00cd5adda2c87c3c15b0277cf31788741ff2ad427a40f658489bec5ce838c8d1cb57028df94ed76d33616bad98e6bdd1df7ec4dd87a105025111e5f3cbb32c16b8193ee0f9325e80e79b8d6a1bfc850686ec24da76680595ddb2e06b11877c886105c26c68b53e1be1b38b8c02786e8ec3e4dabf55e70113e2c3eb478a8183d06c91436c4f27f30f5ecc8b20dbb5038e91aaa9969dd482df194e4ce50acf9e8810120c63cdc17a0d3f1bdef355d64cce373c3e37516d82d41630845143a521e128f0673fd9576dd72ab37c37ff393ebfed70e9d623d10db05fedb9c8a0d01570c455c9f139ed2051ef4c2f2f016ba35d2670aa3d13f109c82ad5f975141299f1de472da377166cd0faf25a9a3de6bc66a5a632fbf707bfee7eeb1fb1a3cca77e9942d1883fe9e02502900b16484a78cfc2b178373fb742fa2695925bc277d1e6be71b3a04e19c1c4a817c24dd590521f4ec8c26a0501f34d323d8b224b20feb434d8913556abdf292314926e29ff63bc70fbb49861fc16297e7fa8559567ce2d4d27d48d37e6f25493def823456b4ece28016e1e4d02b8626d9b600fd2578899e365c7fbe8dcb35aa0199d6afe2647eed5b0fd06c3b7c03a13f534856ba7d65a394e16eaade45a2a3afa1c17c94d9cc0586ef283bf46d57a07c8b1ed3802d0eb64ead76ea9c68d2dff04c1b4b5db437e9ce3c86a804da8b3c3cdac9270499f058c2c7d23847335eec99b7cc380da78a2599efebdba6bee9a071db9b71f6cba4b6142bfc7e03cc190c985428647014201e0cca6f8915229bfff983a4b628fa54d097a010fa1271a84de78881a1ccf1f43b78d6cf67867ae4a378dcf5fe51353058ca845cd4293e9bbc1642d4192ae868b0fc4f9d9c3e67dd1b8ad8e0b84dbfcd516d394d2d72a12e30f9db7c75db595b74391a75a6336d889808b7500ace567f1c9a1575e62d79b8c473d5a99cbaf2342705f08ae3e833bbdb2b959fec03d2bf05147555355da444da55196dc85ec91d4b541dd60275486d66a937426c00d15a59ad9d7572fae57a6bba81132240b605e3459ec017bc9f29fa8e6599b952d1daf14cbb052431a4493a80c155f48f6897bd57a42239ba71330f22a4994c47068930da46391b3a4c27f87ce771ef5364f72b914b6c9faa6f167787c4010865bc03ac253b910b8ab2dae3ce58c6520282c72a7b5bd3e4d445b769a6a62a03c487ca60c719f1ff600782606e337cc6d3ddab900e3bcf11559a3c4b96a62c4e36ce1fddbac4aa56139611c7d24a94a82c08c81b9d146ec9410628960743b56c2598bca4e36b6655654f231809ecb702a8472a24176b5e32ea8e42df644a77c71c4e7da24bfeb7512dc1445b75b7f92f55a3cdaa6b27d3371ec1bb01ccccee2e882f8b09a8b2d9f5bdc362290af839a5380ea36e89596e73ab6fc5aab7f20b133012f6b88604d08c761e4039af4a3797d4b9861413f4666f7e2fd7ef993116d3321c385da7e99bf9e6da8e82d74e3c05c55d2b168c3f979bb304ed6f41901513a07f3787475131708abf7b9548aaeae0f80cf4259642b203544a7577be85aa3f32147a705e03f72b780d5725477f9c68956ba6025f2f19d870df06337a06676465028d03042b2c37f0a23a7dbe773cc0084b0d488b72edc1fdec33d1778586a604176e8bdba9ade7d2bdeefe94ddeec04eb1780bd36fd4e216f6070b17854030b4514466637baa563b655cff288c43c0b5ae5617cce662f34daadd88c5b7b14221ef9ba935c3b48c6b80084b098f5f5aa2964b6bc20f589e83965df30bc5fc4ce37c9763c42051a37fa6d231e8fb7e54201c158606bd6d104b0e2c42b057e9113a230dfd8bed9449bcd8d8fa44f5f07fdcd0d6c960d0a61ff3856135c5719014f75e034d8f1613f18c4f102bb406aa83234f7f5567839e03a0d1b6cd08c4a9212b9fdea8bf169d49b02fc13c354bb2edba0706e7ec460e04588a0d3d9babf8d302828a96f9193f5dffb5cb98dd5c7eee6615e2692e470f167a2ef94809b623e5d3f1a4ba7c2b684af49c44ba3fb5930cca545f626151c654ab3d4d34cc4592ac0db013875f7926c2561eb7972f0ac4f81040f76e2d3fdfcf8499d9f20d165d4a23c1c288d0e199fe65d395f26ce88d608d30258554588b3fdcb1d53d0943bcaea718154ab1c0ab8d2b89f4626b0998661df557455a177e4044f9346af24951b04a41371003e929d56266a1051834d6fc37260e7b8989c526aac6ee6fd0ebcdc9456851905ddf36edc5b68453b67c9d266d1ff1dc863665883e867ff93ba8f837c671b6fd24abf87b8b5aaaa8ebd1619fe17e00e6eb050696a1c881e881f51c2fce4629105222bacd5433ea8a425bf5235254406f792a29245b7121a836425d9f4c61b68df8a494cd506736e1f5cfc736d2af268597d07d5e087e5ece99375f072ae4fbd4e2aeb1a225b1f8e3adbfd2e53248935243153b219dc59c88e518c2eeac8f31c3a81b0c8ee97c343e06f37cbb4d24b5d57037b346cd27ee526290aa9e035fbda359bddeec0d1fc42f4021d671b4cc96bde4725d461f41702c3bd2d78de2ddebf6076b3a9f0bf77905ec4ed1a275bf7f373aa249f773a93f16046bddd569022d8984faf4703334aff68c97ed8da939045d3674430ffd4051119d467ac51b1776c0ec41b7e95e360a6df3a7d7eea64e022d1eea8abed410a7668a8a4eb045b39a45bfe42e7cf3075dc0a58dda8ee61d01224ac84c771fbca822cd00cfe2799fd5676f1644d0171c1a759037a93775d6fbd9534c0c56ef00ef34c5d242a76a2af22c6270bd6b8b508ab0de7e94fdbbdc15ffdc319689beaaaa72a5c3f9eb9eb6d656b66528a7f00a4984731049d3aa66edb0145364bb9782bf628ba78eb396c67bb83bfe22cc5a2542fb85e1d0d6494a60990f310252dc6ec3ee4d148635453cdaa8b22bf57886f3797761e88995af4932ba7f5d1a2f9ff1b3135719708718b94401e9e3a85acc7f5cdb74b0b62b0c48e99d5afb4f37cb63b14c6b98ad0805ed65215ad5d376951efa18e55d558dd1f46bd90215faf39512e71207d79449351d4de006eb742538dee434bc173afc01295f2febb3dae65f667e56fbe8b05c7304d5e323c0a004ce072cb4e4cc2387e3ec8de5e95af0a51d8137f248b15fb3ac5c0c7422d33d02e396f42347c2f78b9d0916b9c1a3f4c7a3d5f39c2a113b6bdb36907783263f0ff1d9f78ae5383a7b6ac560f61d212e56e90d593b740ba82340a2d3441314734ea8dfcd5a6261aba091b7da2a9f47b09c0aae51e24810e9f6e3bdcc0f3b54cf1752315349beb663efeab6e5f4ac1bd454f0b6ac717a548f9dca911998492550963eee2de59cd7c42560cfd945659af2393854b19dc05daa9f57a8df3d80c74ec7ec26bbc86ca650586a09938a3b53d7ceb8b12e67b950ec1350faa06a848a0afbd1ac7ff8d52d9e0f5b65b6cccb7bead88aec2097f17a4f0b05186a7e157db1f692bfc9fa962244e3d2a0a3ef732c469f231c4f1be3f37687706f416ca9a4aa6f27c9a28c42231eba7a9d03c0e7f1fdf1d054a52ab7f344e63791c99ce67bd691f9a609327762e4f73a2c17999fb2d574f1983fdfa31af3fff39fd8f2c14501f6c48390a306728866cf9eff1fcf325277339ff75a77e2fa373921e1003db9c425fb5e77c8b9f959f773047deef77599e1f6e673edd05f2131fc478158820790d81d87441a09d89529de11dd7524b6ae69d0b9f78f310a94cd46d37b7fa949d80661d143ad08d48d7643615b0d50d19b85d71d4bc748e3bed7d36413a9eb79669c5a0f777b86f28c2f0a9404e603cb2cdff8cd73a965fe85e848a9d07be83271357dc4726a48a72e24ec1c8cab80612ceb35ff5b4167d154de7f5baf5e378cbfb470466526952041e298e7b99061b8e9e94842d545dfd1eeef804c97e1adfa76df299e613ea1a04e7c83928b8ddb7cb7a8932ab5415a5dc8da55f70a7ce24bf654a088965121821817ae616d92139cc76816781d08a63ec4c7db04fcd8699f54cd8731e3e50ef7773c8394f89e497627c7373f6d6b0f74336b43898fb276626633137cf22c3ec55e3080094cfe288c826bc5fa9e37556879107a972050f6bc466e68f6ebed748a71fd2eb8a9de23d3b31b587b52be34aa7274f96120cf145fe9bb03d1611f7db053f52674b2050c483c2e08ff2ce5bdff28beb2ad99e27a1dbd7fa9e477fdfd2b2321cfb67e86ff6342d92d208ed8edb320417b7db929700c274aab79e49f0e47b9adc4b8c8db158fe1582b1d30786f5f6c39e1b0e546739fa3d19f2ca1890418fc493c9a744f9e924e3092581db5a03960c418d1c0f9bec6ef8fccf8caead6d422b61c4f056f1e2daa623bbae780d601922f1172a005f802e61e761a76766d3a6a294f08f32ad79016156a0fe303f025c70df9be5817a534ad8ee6d6e0c3fc8998e8d7a097cdb0049f7d8640e3860d8f25135753d14c20ca58bb134d460c4d654969a1779a9a06907ce433ba6dc7aaf1a54596de0d053ca535bebd7bce923e069864c861b05ae7e406a88266171a0234642f6086e2452f316103405d23dca82b65bfb93c4946750bd125ec49a9e98372da67d0fecf4e3a21433d3f4a347b314a09d8154680e83339126503b67279e55601ecfcda98d6eb08076c941a711c81961b3cd5b7a8795112d715ec2669f272c177e5d9a5e456fa02e820745ebb65fb4ee8ad4e9955e733794952d649a6d719b078e32e001174ae3e6893def15bae1da395f4e3278fb3c7b7f99a78c6eaea4c9a9ac0f52f4446821a05c0732ebd5490f24485d3ad76328f29dc64cff99dc9198c2558110148b0d9d0801c923a28c006d91201cd2a2be35c450388f59fbb017c509c5dd58cfdf07eccdc5d0bbc0eb4fa5f700179a245bbfd53866666fcb1bdc62776dc84a1b9a13ebde84c0998211bd4e994c6bcdeae9a40ffd5d3a62dd254a12f51a185e1c18e2c5ab08d5a9f696968cc7f6088831b74767b768dbb7c9444d15b30069ee2a7b4bc164bf5be74adb931e6433f9ec47bfe57644af3def9feabbdc1b2c23a1e8df8246a335f15f12b3efa5d56ed1e3e568ac330a1fb4eff1d8c680f145ff1328a314dc849a5830b94b9481af67849c63943d2303918d2576e47381fd153d020d8061bcae823f94761aa228a9a512aa5f5e352a4deddbdbdfe1b422a3942a4d281a56fd95b50cbac47ef9019b2bac540a418a26c46dbde8b8e6c2c1d8b142ad3b72be6e51312f0f94386ca6eafbc0fee528ab8247e9244a85823cf1d633cd8af8a0a8454f719ec6f2c903d249e6da9d097d6e818f546eaa5ef9ffa6b94e780ef48cbccd277b915c1ce9995e9bc9794607bb941fd5e3fa51a150c7e1b0bdfbf83f6a0eb42337e2f7d7226be8db36261f162632cbcfee9e2073d5003562f3bf898e390f19b3243f5fbc1dd1d66543ceae26e3a231f04ebea7920a4deb87d05a06627f01570a415497cf38c1daa96092165c4ccd854554bd9d48deac5f300b25d4e2054fa5b39e2d61302e96727e5250751359d53260269b2f3afc52a5ccc14b3cbf21950595756612590943fd2a7facc2e07ed3ca96d9c8ddac993a08dea2378d7ea6055d945854774202345ca8e989e35612b869c1b96e204126737182c91f3989b317b2c943f6dd7d75b4f59cf73a2d1a816126a45efcbc8e09964d529e33db15a20e9a1a0d6444b28af0476b8c9b7529fdab22ab1109c34091e50b7d1736c57975a5ee7e8b691164dbd80f7fe29708c62f5c3bd886c7dd1636e4ff69487dc77358145b08f80d3a63a485080d9f6317b0af5a3bb2ffff6740b8ec8d5f52c85eb2a664ad214db2e91c8ca5f7fff6515ac4036e7265c5570e0ced9162d8d765b2b6ad82e4e49ef5ad9fcac0988107c9e1eacc6f97762dbeea2ad7f07f14c5f2c5e9125f66adca35f29fad6bfc04f9cff147e7efb312235a7aed327d67d9123d8275f1819dbe41f1453260d6569932927b05567a4521f00cd186fae26660e5db9d45de1af2b0f42a583e8dad62154490867f3918d33ab1e99f9640af22370cda1a4d7b1e86a1cc1f1cd56d3700d70992a883dcdbe0a598a380485ab0b816d84caa63954f6e84aa4a8b83aaf6d5720199f934c8e874cd8ab530f2737d2c145b989feded256cb00adbb5c9393d063f5021b236e41abcf60c59c10c30b60db1db8e854c41b7404436e293e56910aeafdde6ea782176fd110a4404008cad46576048bb3f68d053361f8f98ddbe6271c14b2ab99ba34d1c40f09772ec101279dd558160d9ae50c9f8950a30f3aeba35ee6d93a46abf05db86c2fc038609da892fc07165675bc744aa6f82bbe69386a4e3a8ed348a260b9961f2893d44f2787b23f478f45fc67a27e5b74fd3e7e35f318dc508f29cd4410664e102ddbdc3a4428125f984d31fa38d34b63e39363aa45870133cec0bd91d97dc0c658bb09f4ad7f965376af84920153d296e7f9a9ff95a4da13e6ca843bc143318d45bef92a24a456a63929e7eb579a3cb0d412c0c758031e2836c60424f7cfae6c8fb3f75b0c41cb3265b8cdb1197d5a8aefcd935138869d86fbd1609db0545743719916a2ed89c64072452be15dc37612a3a7c37b7f9e2fc503b2740becf32fbb33829f0714d2890ec5e7701639dce3a5f2fac82d8998d48113e6bff105f1a7d2873bc718cfca04afe7c256b456702d19d2caef4a088667366e2321ceb2bef05edb09c3babaaf128bec2aef602cfd26c1a3012de303348bee6a0bc861c14cc4f23a2adedc7fcdb452df35e7b6ad0e74c19d8765595d69f852a4167e62a0e46f4e11e2475efc01cd48cfe11f7ed817952f6fe43a16bf3efe4f3792c88ca2cd2b1fc92ad07c2b9de8d745b23df3bead7917795b371fdd1aaca16e8d584f9db7113ab1dfb2be2f40d31ae7187f2bc18dc832a02f21210f54c945055ca8c78f17c34060aeb287780895564006d897461b31ca908294b09da04ae6f582a4089f5d7e6fbc6741f0523629e84eadf3797baaaa94687865f979ef1213e9be2d5c054d55f61f6537742d1fdb53b4d6ae17fb540c962327eaabcb87533007c989d90603e50cc101f4512ad0b4592a2bf41b42e2108321eb9d0599510c906d7b3d9646c89b2e3ad7e283f877994adbf28433d67289186d5ebb9ecd1e0cdfb89f9f9c51f973183e4e674c1d43fb489a2d283fd62a28b9244252bdcf7d8a880d2fe24d2f3068aa30cde3a4bdfeee0524647fecc1722f4d66ef027109a971988d042be1cb35d977ec1815bab30cd10a19f1fe81cc511abf40f3bff8e05ef26ce6d24ee0a2c8de6bc37ba57dcaff951fb0f20eb3b7fbfc6b18ccc5c88624dc9a4ac89e28df2f18276e465dca8103e2cbfc4d41a49f454848dd2757137e9e2d422516c521f17c40ece3696be105520c27291bf683b66b2005b927d74e25061842f5ac98a3289a8a29c735c809a2ba156acca4f0eaea66cab65fa31cb2a40beb4b1eaf5d617d376e7e391240553146ec76e7cb4e93ea5d69646ac235e7dfc9032bc4e3bba1b3b9e1ace762c9bef7aa9f3af8a62b82b6e06d4b9e8cd84121cccce25535f5e89414a24cb8eb2eea2bb8510fd201cd8cfe55f2662746227c3b5b3c895644f9f0d7e95e53dafc597799d3f99b83304413140f4ff00766752653df5bb88c65df0c995f9501c6a050c4caa60658c6e7be3e2f00b039f767379a310342fef74c8f229ed97fe15cbdfa9c65c08b479bd02590f34f2a5ccd3dbd2d059b3ca34f421ea9d883a264178906d8f9bc19c70a75e82e9f3b633474378a5705864819638479178631e568751973ba9315ad58e3ccc3e0a7d163073ea275b6c23abe8a8d60c69a81107932baa17d649f3960fe2d0174a4a0716f0a953954320c9cfa3cf7584128ecb9a0e40d68fdc67ae8a9c1e27a8d6cf371f7ee23d15930f6594e1dcc6f154de13d014eec6adb671067375130a643ffe0fe0ce04356271811edb5ddc3181e61b17ff22fe903aa64cfb32e7011901a0be2934ba3770d30a3ec442bb6130ff9d765c21cc6bd1a033d0eba050ca210959a47681d379e6c621c4d9fc425d574194a09ebdad598f87f96a8ec640bc03361852412c3e70b3b73e74fae19446eaa3c915b3d0b3df845c296f1f9f54ac8a64bfa667a3fdfe961265128d6feba50cb371233f6d16b9c74a0e3fe68c96b111ecf3ee8c086be06a44ac11c7039a1fdf74d5678eee18f676be7ed10910f3cf36a5ed008a7b7a44f063facc255167912554980340bcd6453f7005b398e0d298b9be44b639cfad08334002e3a8a8bf49b2024f2e542c5f11d6237e5cf013545f17c5e9162d6d48e1356442b1c82225772303ba75552ed053f1cbf36dc9aa4e3e375ffa0a70e2985b7223c002c04e0c9a06fbe590571d0ea74b16f440de7287e3a007057ab745a212cdef8ce572de8efb87da11ccf94d1711ccfdf0071b9022371c79736572c150cf80ea57a40b8ba84048d45b1b130dcb1b30237f09c0bd41e65477d4efd7d053805e2ba061ba802438a8740d935e9b1d961cf3cb7b4fea367a7942820798fde5ab40ee8a4bf047595011e645110efa859bdf96ab4ac32beb78fe84266992938da4fce7a3ad425fa244c761a5f9120e696ca93e389fef0532cdf8ddbd6119ec2e9d6238bf70e7dd6fbfd880441be2d880750294541757c4391af3f844897191c5b0f0f98fce9a94d27fda9ba9552217979da6959aeb41f779e2f5c634b910524c7e03cf2f2ac2eca2c2a1398fce3793d28fe0161db6664d0ced7e22fb53cd208d4bf2645e3aede023f488cd89452150d182e7be941b0cc21989829457d173da96dd92ce6798136f920735d5cb63dd0e1628a2b58f86addf1acef34ba1ba6983cfae005e67c96f17a946777f1bb60fa233e70f10215425e2d438a0c7a6ff7712e490aeb8d41d02f0b11d2d02f3673e61bd4b63dd644901d5c43f51a560008ceab7984c9bb4f9df1d401defa611e8e19554865e9ca62cc6d07cf0774ef643e976defa941cb41775af004149e7edc91c7d1593985011e1e6e62e221860e9e0ba35abf1b9c01cb29aa034b7f8391b2c9b26f56e3d448e1109bc0c2e3a607eb48c8c95e7544fa7e345b7ce4e4dcd4457562021e8b2bc4b7a460b107058f866007c43e23c1d063a193cd8499dd0e112c0ff6e891bd16b7b7907e60e8fd27650794cb4bf39906a6eaa466955453c97d2662d2e70a44c4d8fefbe8f981096185825027030355e47f13421e9054f1d7ab8e71c2d604f38617c2ada2101257033b08217eaf423d5f773843715dd55333ca7f5a79d27b564bf69f0b3a4bdd44315e141f13bf34f1419be79ac3ee4f94b7b85c76dfddbd22d8761efead241912fc6541ae2538a4541b420be14b443e5920d4ab7e3009520526908e17ab3ca8ae5a578863bb27f4406f33151b9edf591b9dfa3a9e7b6d19ade3ed6f7ba4702aaa2468e4a5cd528d1ceb3c83b9fa1fce3a9d920111d4a755b91d7cb9f12e43df7328efb59872009726633c6d91f23edb2b1f76799560684974fb3565df6a296f0241dd12b86960430e18c8c5b43b7f077defacb04d69a645b19403ca292a56934f1622707b6010435a74e354de6c67e118fd85a6a89784e84073abf7b894d0d3db7d887be9ec6d6f09fb162102c70d15a544cb02930e03c371194f2df48233157fde128619a01333cd3ac7d860f79fd3cc622e5d3b8e33341ca47e63b252d79e014027e8317a3bf6fb538be7194be583ea0d86705c9a5080c67d65b776b0f256781dc1ed934647e046cc04e073331008996590691c80309fe2ec374819f74767c2b56f0b6996d4c4fda8daeb2b70a904519640ee0ed939c9338e69aed42c0a9e7e1afedbc1932c64e0172257b8838cf7fdcf771a12bb811cc15b5a246afb11f2c82554d813c9576b6026cdae4b6afe96f1dcd1573270b87f441497a7bd999b367c8e22c6f7d42a4d13a701378b9d81f387d26f7026a9a45eeb457eb61c9fd77e5f1ae71733b7d8f1187f795c3b746a7575a9314c81324802b61392b5fc12ddef898cb9f628b3811681cfc19f6de988c6102c3fddfb8d8a86ef8605f5547822031763be635a9627d0f839e540aebb57e12ab0f761b59823635d13b49a0578756be1d351cf09340a1866f9697bf4108952843e41fae27338c4e3a7fcf52ae06f60fa1d107445ca78544f2aec612ae97d0e581fc3d1bed88acfd1e74e324276f7628123e7b980d6f4017763ca691ad42414ccdb4930e848d10ecb3a94179d586eb90fc42d4f51cbc5d970ad1a17504f0d3985795ef8235fe6fa79fefb8a79ccde5ebb018557c6b416a871b7c3afd19fe459ea74a22ab1611664e5ae3bf24bbaf1884ff132ffd5e105e302cbb3beb3789360d6b836ee090b5fda01687240a595d7d3b5fb42ed3bc66d49808b5bfe496f753fd875c356451242c8cf5bd90ac54b550602b9d1f88b59875645457cef212b65f20594eb776da69ce5adaed79aa0a306a5a961939478421fe513b267f8b8889cd17abfa824bfb8181fab063b169431d057faace414e7d07ca805a53b62871726d69fc7faa37d2b8ed4d5cef7c06715963e9ee2bd23a3cefcd34afa34661c363ecea0db0997b75189f8f85ec11827543fe567a64690286d77932bfb6ea9d184b4dabad371845da103b88cf1f9a106f97e2fd283d20140a5ba51a3cdd7b724120187eb859db126b1b555e22bd8fa738725f98bffee4a2fb56d321c3fb1519e966b6a47083e810eabb1935cc650e944167f186f395080acdb2083b9b0d682068d430732be1e802735667addd25b78704856d1730d6481fa490614bf81477cfc9da6cea8409a14ac5cbf9b7c10ceee630a5112cc6387c0869b6730c8f4a2ddd5583ea5f5924b23db9ff501d28e46b8ac46822d2944708e2066c155d7ec6faf7595fcf207d262f732e45717e65d52f1f887c55043630d3724b11f57b1afb0e42570f0a0aedb1ef66e33af3f8dd3738c0b5d8284259b30d7d1a933d2a814cf61545a008f8d4723206b0e0b5aeb86890b626c8ce3fe4c8b952cf0d17d15cb2e06f14261f53975c9e77a799f2e33624710b28a48c9f1b939093420e887b1c60ca3a60ba23eff34b5e65eb0d1f5e41ca565a31a648f6d56cad313c9f4ed27d08cd54e1263e09d37fcff3f251f8bd0961190b325756a08f34aab80a769da7d08a6983546ba34866a827bb2cbd558bb1668472088d7b7ac5a1f2b20aa20e915fc4b68293b5bdf75952517ce7ed37f5ecd7af8dae198bf0edd6dbbbe5d62c0bdf11ada51bb8ffad9ff07122bc5fb927041dadd9eb920f2a2e2d221caa1470e1177146acf0ff778bc2a214b54b251057e6ad3c9bf6e39bdca687433fbe809a524b84b072a246e0cce642fba2aef923c225df7ff17aff767b52407e175d3dc3100871873afae6b8622e9b90d0504e44e5a4195218e1c2985cdf76cf8065838e1557d1baf8caddec1ab4184b55e917d6340ee8bbd9a5432df21d109109f77e37353783a150fa8d0e8530087c0302f8396a074f160df6c601a987329321465463c09d47000c8bc451e7e7acb7b011c81ddd9c620a7e03422922fd65cfba9ee1779de314d61735143b58de04251790dd3f844a007b26a782e7dbc073afe4e9b8330ebf8cd2fcd6493a4e1800ce2ce5a0a02f66f3fbac08945ac26f736d5ed512b8754da3858fffc087123a5a9eec3daccf1c84011cda8de689bb86ea80af11ca40aa088780b73da1888b176d1977b06e8b0a47e69caad3b3509d6a8b3025f9bc946f821a7f476da826c2f66dcccd8671fa9555297c0e24aaa4e0c0e6813e8153e68e3609a50af2e22abfa59b7d3129f916342011dc1493681877116cc22fcacb6f57a052cdfe74029403090d1f85823a2ee9e06e6ce0280e71c8fcfc950d322bda4fa33641eb93c923c2d12b8b64af18abde490429cd788aea4b2aa0b29ba510d51017a46b86296cedfb8b124b7fda0c62530eb5b3c6fc8116cd850f8601cde7b43aa90975833210a888ffd8d670315a1d40b3872cbdcecc04084ba72904f0674eb62eacd492ebd4e3c0f722319e13d48a30e16fd926d6f6b26d085f5c53045412accaf42e0919312d38b49c8aeb435a891d3443f56b4fa453a4bdd95e154320733ca32d0df36b416abca0e3494784e3183a7bd41ec7c49c7ba000b2ec6b162148f0a5a902ae50490bf4c3475ba841b0cb9fca207add2f9b696d71c3f37f22ed44496f4193f1150b7731247da7bc3865accbfddc737fb262e2b085489c5ae44109ba53a079119961f7aee30939d26b7658cfc78668510bff1169b5fd22b0ef1c5300308c5249b0400ef6537ac879a8c44524c370576b3ec843aca60b5c7c14273005af27375767b03a86c0b86722186a076148c1534d9dab6e8c9c6317df27f4ce4a8b5b08f1e688aae5608c9c483ef5ae866886f0931dc7a5c557a6a49169621753fe2f1d22889dfaed0ff8f39ff597308e721b5c0757b9aac342","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
