<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64e6ad91d6fb6885ff5657341d1c63fc1d1886733508cfb1f2e6446f021953e479d70f72c84e13facf2214a29ff59428ab8b26695a3d75c1b9e7fdcce914cff52a0338364e7d595377219c594c4a8ac273ad91cdf62d87657b572f0fba8d0777278058213c1993361088f04e9926fcabe1c7f3c1c81f137c3b5ea0e8f562388b3cc82ca687700713cfcb271b87e3a6df350b77dfce420d9e72fb7abdb66259d4744aa0cd423ed035f26e91fa9d2d0aa5d56751d870ce59cc73abbeed5a6fc9dcb692926cf1c3fb1854547f8e8ccefc6b27c25af6d6d835a5049b93bcffe0b47fedd7d9dd43242446a72765e6eef43bf510c5e39d0e3eeb736d4182f5f09291ad9390c4910b4d197242be8f104fa20f836eb94d7c5145db25534c7906f06082987521ff61e9dfc8030169a26cda25fcabbb8a66067a8150933d5ee8a3158ccfd598d2f788448fe4c7c88896ebaf403656a3f40a0f08f0c79582d5c6633b2f2fbcdf176d9674578f92eb48d10e60b7aee86a66890bc3e5d8828ba387dfc8dfb4f03c42be68c921013601a346c82c605285909b01685cf6505f1dc8bf27d8275be006827e5548e90c0d34e60b5c0a72860d349e162f6e00dcc0496f9824abbd1c6782442079083bfae0f1d3edb93bd65c761b467357b5ae21ba9ca46aafda169d4c9b39c0aca693816fede009c478f86cdf9c1a2b003b7bfa8795386f50c60bbdca29f7e3b8fd39277a63d5e93bd062d7dbfe9d83d0714f31c35413f73189863a934e0c54d0a137cd8550ae59d9dbb422ee7c01d71b7bdafbad46dc54872b845140ddcd81d9eca8cd1328f149642a2596f3ebce088416abcf571ef76b322f6b102914a92ff8732c2a84028874e382a4890f0e96ae7a5c49f0b0bdb93f4463c35a00fea02cbe10b3f168a7a7186d1db30bd1f8639d5921644706db65d8607cb2868926bbd500e85aaaf7db9c7162c5b3a75f82974aea670eed3a73767eaacec7b4110f8fe74cbff931df0ea97f3885c40982c9b18ecb265f5e36cb49d12158dc50b79a7f883810ec2f455b3323a9c048079276eca6113d2298f77b5a59b5933e0b6a69c888e7006ffc1e284df9be9e52d880fa4628281f54d78b16cda25f2ea6b9df5cce144032538b37ec70aa579eb021dc6bfbf0e76d1f77ada09c32cdcfa6ad26ec0336c2ab6ecb4d68a7b8a3bdc01005e17104ea4cf58d18223b6f808c5b164253e42876fd4e11d0107375b30c864230829420123349e549e9f5fa3b1d1f14d66437f7e3672aa48d620044660cdea69e5093ee736c5df32b97449aea51a99ea879ac147e998a58d3369f07aa20c7b2aea3838b48e5bd72d156f111d80571e3edc3bcc047e9f1ae66af82a1595e49319dd7f078e58d4263726cacb17323d9371884cdfc92462f56fa599c2892880b1244ae64821ca9771fe0a612ae42a5b7f0bf9104c859597e0b0c7ba3857a15a834eccd774966e58eefcdd49596b2c7488bcfa298f33403b9e4bf053c33df595ba843042992ccb6aefabd1062a108eeefbdee619de021fbffae0688e7ae71cdda3d634f2c8eef6912be3a4ce1f80413bed4ac595a6448e086217f06eea6e1eef6c5b46b45dd96c377ab220e3b24a5def8c3de011225e0dc7719dbaa26c05da5f1fc870d3ac51482496c931021bcee76fa5da6a2a2af5a56bf0524e679b685cd990e62c6dd1e1d2777b46bcacf2fdf7caf226dcde960b1a0d87604bc182a6230798a3238557b42895ee232ce1071e9718feb108c79a8d272772fae8e1514bd7f97279be676c3be70a0a4adb696479469e6219fa4985ccaf5ba7068f0956fa87f841e6fc173a5959a368b006c3d12ace80a832138cf4a12d883119101c3ad510c2bedd20a7cca51b7d5860075441fd3f07d9cb2e55f9ff2cd2882b3d23d7393cccf203bced2ad901fe37145ea049868a90b99ad7056b474e3482bdecd69ea320e40a171c7502d767dc0a9ed68638f254eefad20fa5f76bcd96c494e5e3dba9a4f29ebdd6d599ea706737caba396b9ae2dc6f642cfc54c9224328a4993ad046247d8eb04d036460232dbcd4688079729315a814c6284609b3aa1b54aff24802b47e96f15f2fb01a195269d5d9661507ad55d6ec730db24232bd76694ab1f7d09d19af9b0ed64eaeb8160625b05fd08481ed210996663810383d81906f3756992e119e880084304aaf320e1c9c866b61137086086e460c4055f2252e0535e6db2e0efc33f7f0af664beae1b1bcb3e323fc83f9a63a5b65a4e3363b389cf7e9e7a6c6184230352845e4468a0cb315c60ceb5186d3c34edd2ab081f8fd11643ed6c396979bfe1777f0079d5be48e1774036292eff176a20bdfb6eaedd43a2050649c7fd0d6c37a8dbf29877d994d527ae12fd9c5fe7fa561e497f8a7927bf94c2dfff8de9b4341d395e4398b7dc698d2e5aa871cc55c1075868610c34eb0565bc32f2421489dd5d95fe820dbda8d70abab0d9719ab1698f7701be336c0a8cd734eb13fa7bef8035e849ebb96510bbf4e5f7252fa70151238a3ed734f3e99a555ef9e8166cf5ec3b36ed2990d7eb4079ed09a5c66ee90fd7ea6f2e90368d8857144a7b87c488e8f3f5394e7ecc34f3dcb118287d982b278fe991da7feb68a3e3ffae88d8a1e0ce07782a4f4711fb0e26400fa215167c05c77bcf0a3f751c211b3c7b7fd0f190cc310fabaaf36dbf22cd637b50ec39ebdf3a57e5788f54edb2b4e60e7b45e18459f29616bce1cc4cb860f6c26f4aaa92215a183aa17cb50606c6e25cc36e55413067a87edbfeda5802c09ccac9fe2235a9f1c10ae70a104f91bebcbc75acbefce5263c0e107f5ca70773645ebc82ba3facace886350b8af434eddca2368854f9eae4e781b1a3187caac5b045f7697f9604fbaea292622f530b9086491b1b0811c932907ffbdbf50037e33b4444c3382052195e378ff2f1f9f96683a4bd7c6d898c676bbf295acb78a9ea08dde51b8046133fa89935a276f211c039cdf6b88882a9dc32847eff4bd4360cf346016c15e0fc6e05969f2c39762749e26ff8e4c6c7b62b4971620d7db85019fdffb5864a9de843d332bb50699c7a854cc4dbcb633be4529bcebb52a2ae6b864541445da79b8aa8b9fa261a9166c6dcac2836e21a9fa94cf5b96c6197a08e946328be3899e891d07997f408aa9cd14e10e69ec285bd950af81676074601165fdcf2f5175831007b2118e9c2caae4e92fdba26469d88e1c948392646c04605bd6f863519f7528c097ddffc3530951e6a8352bd44b7ff33b688595ae40661d138aca96905a69115b60044f9708f005cfbeb89bd5c6b9e33a1d974a634d22b93c33b870b2e8361a769ebfaa36c82841e5d283661706097fb1400ced5baf3cf507cd67f549732f1ad75e961611937924daf6d10fb8d66bddaa5872cabc6870b72027cd151912b349b30d5b32557a6b8560209be6c40efb91585a27b97628ec95faedf07280e9ef88cb73d41c14cc82cd9b6bd217308406cd3a759a6a7c01a94cc44a9bdc5c1c1bde58b03b7128b463e5a176f85c80c12025b1ed7c2e8cf6264be58cf85e15e58ac9b844a8ac38ef7816acf1532ed64438607e0377678ffb7600cd6d32e052025af3d153b843e11e6b9c4d14f19707ec6d88a2c81a04b63e6e39cb35843ad73fe14465a4cb0abcc6a727fbf986bee8ddcfa333acaebb8ed5f5b161c88141a64548803933b2d0a40ecf80104e1d97a0b26e817176e7a76f300bd28259144d515f6c36b5b30a360794fb20cb04183209ee64a45036039d9707d1e921d68b018a6a4e45680d725e6b11437bd946f05b6e8b6d432c3fe79ee24fc002d728facc3ed9aea9880af01fea782a011fc9273798de0ee71ec59a353e7eb4b1a60d502bafdbfe9a01eca0973715de1a53231f2254d54b556db82ec47b069ed9f784c9a6701e2c5aa24546ba0e92c7b2aaa62a53df41a97478a3831ec513c57bf978c92bf693995aa2771a23ec54f418ce77fcc5114c5e988292264ef1e9b536e469635e323f4cf6ce7766e98f36812db1f054dd0945f019dc770370af6aca2bd3b8f0d60b2f281a1da37510df06a61bbbbd360aff041a4defe2d709eb329493c5226ffc40376e87787ff32e4fd1a7f9a9b5036a772f7d52db92b3e07740a537dfb0b9fea1f927c0a3c0219875b4ec89322aeca38cca069f309f68473e70150368ddbd4626b10e869a49c50265f6c37c8e60181738cdbfbbbbb4991a811920b718f4c1f4bd93fddc8c2078cafa64fbdb13299023268c673b93858a1f86e1340b7e680be1f85a9829b8fcb4ba07f057211bb9087ca90dddbe285cbf47b5efc50e5b505d33d4775d669944545aeb96e0de3886d86863ba7a8314afd1b19f14f7a5a21fcc50b76f80b8689d9d3d76597de60771814bd653cbf625ba33261ac0505c426dca95c4f5fc19dc39b9d0b32796d560000d2b314f56c11b22c3690f730c014a8bab7e09ace1f24bba5b1054015c6c3c04bdd94d945d2552d4ed84c6f368840b8a6ac8bb9b4a9a25a69fe1cebc7b306f338bc8f4c45a7f33c506905da3d27af9da51d49f87f6dfe355f38f899e1fb099400469f9df707f641f3335b7bc57d2d7f1344594ba02c71a946cf781403220f3d291f8fe7f179df28f760d9aa0ee52faba0ed6c8dc56c933a602c294c748899ee63b879527b531612bd1d934b9fec0cdd092dceed51d76cdf21649deadd30fd959078eed10a6c9c06b0f21c282d27343e3e33d6c534a7c1db54bdae1eaa53131059781b91683ce3777763e442618f35a671327d031151cae0414279eee4144435072fcb764a9fe69ff7d89a56f2e9dd991867c783432e634621149d2555c61ac3ad9b07266cc263a528db57125a34d4d268ec153c2d51a4afed6d9bce601b7efc3d0cbb6834600ba60e2fccf05084b98600ba1119e936ec7ba90ece9a5397085e5d1e40dd9af6d75a229967ea9a4fa14b591cd3f7bcf87e2974051a4a2937fd3524cf3672ac760d049b680aaa2e2a9b50c0502d8e7ff246afa0ed93583ee71a950cafed4b12d5ca4a87993b8835c21aa4845cf1a62745e1e1c968acc03722021af6cdbe4b50f8cf205cc5d50053c5c3356754f5c52f57fed8d90cb3cf12417cf37991bbc9d6e9e1322cb8d8bcd1163b58727d1439ab5a93d494e90fd54a8e96462724b35044aa77693d26423ab39956c088adc776a13240909101264088f1a213ba97599aa15071506d43f4d0934717d5b8a9a82fef5631075493ed371c824e658f405837996778a9cd91f924dbc6c3128ba2aa5bdefec316d00c68c3d8ff71920bbac4774a6a326c7fbd126270b032e791dac03dc8a614a8d7f36ca7ff7568df586735d2f7686a9439a402e1b289fcb28dfa82005dbd9af68a2f6507484d9799000dec21bec89f65ec1cb04a25da97912a5ab27041f4528053d7c23b4e8976f5854977790905e0ae3dbd23829093b87a4cf16f24ff951d3e04f2e9644726d60fdde8b27692489f819e9a9d7bb402a2f4cca94651341b55a7da27fda34b6069fe9564760b0708d3c2e049460ccdc50943a4ce5fdcca1862a7ae7d0fe93f550bdad2e11a4dd736f76968f654b9ea21e37c29b4d6c68a3d80035cc4338cafa7378928491b45ba0a0bb8fefb861b18bed36969ef37b0948f69595bd5a8aaa0470e4fd8475551951bba98f7e13e7f0f3f32b2d2ef2d9f2384b4f12b11cc67f63df31b9ea989cb92e0958bdbd3d1394647e2194fb97546417f94acf860357dcad208e606667a087ebae7651ad970546a93dee5442f4f3c8068d48304c22790edcfbf7c675f6dbb8832d7870303f29977f4e662f940e9c4e0dae03567c45dddbef9b862a48069940ee60479402faf3ebf62ac6fb8cc4724897faf5731a95995dbaf22ecba62243f8f547f65a6c78e4991cb921c9d466c4a23db4e385ad1c32e615bbdb6c2e882229584f67bcbc3d53322d4a848b4e237c0b812f1b4db51aca421917fcb6d6b68953678d1f464d90a6a79a772316846a366e75340272160a394bd78792ca88a331cc23e28667f69150419bd57fcc6047e96b8221fb7720abe3262f6ea9d66c2e39f72e44ad9a0529ebc8fb859cb5d7cd3b27447297a547004683c3bfcb704c4853b933435d1961643ca0862e051e8112ed3b13f4d9dab573abd36bc198db563c3d35576591c724c34bd0a79da4ff89319c282704d5169b6e728d637350a299549bf2fe503c9b6d280dfc223176d896ee0bc468c3490d6d489e030c21898add3f0168ad1b22bc1b96b0e3b6321d72008131b091d7bba0965fde3e2795ad0cbfde319a9b3040db571628034b257df53727ab5b0d3f5fe66cd31ad5c150d390646e44639b536877b3b0d294efb5980e6b4fab8ecf6c258f22e5c59224f074e6195736fe95b735cf90780d695897173d81b390380873dcde04b2915feb2923cdca8e723d323768faa5754ce0fc02cd97978fd28b4bc39dc7ab7bf6ad58b9b407e64e9deb3ac2b352d3d92780e777dc220c63fc5c6a5a36b5163bc2fb3ca5dd19f8d75249bbcd71db95e0b399622ffab22eb3d0fa6486bb5b303ed6fafe5bda0e01f24275044065c40e0414a03c9e892ca5ef039e352bd59f63f608db1b24a04c8027b31a7e623a009b06f8a3822ffff98a079cdd49bf0aea2a7f594183fc41d76958162d28dba6a55158e0f51a7fc564e2924d975044530156af3e10be55665b7fe6bd3105557b58792afc54a22cc08234f9e6e48869f50b0813a7ad09c37815886de85489ab2cfc356879e32cda3db1464385f58b5a1b109ebd2542e86e1327e2c039222b84fb0b20865fa5bce9df2e7eac427ba6035ea940adb877f45896ef96eb01c94910288e38901c4fe565dfd54c424ba0499af789bb41238c7bba84a874f5fe4a64915a3a14698f1e97c1ea0fa7316c39c7caa4809186b024441dc38576d1497f6973c90cd6018f5a698be27328e79e9c75582c69bd8e2def805fc8ce721f264b90fe2fa907a80b316fe86843601684f3d20ffcda6e3e8c63d09df4c338604dc2891cb5bff71768fa66ebbd84e99a45518c3a6d9a5c285a5889f6a92a1ea533ffa7f87aa38ac4bde57605bf07cea0e06444244b40f65240fb92a17f2ad39bf693e53bbcf6aaf987619dcde767d92c5071a78a8bdff067f2f3b4f8cbe0790d9d81597719c606285c30c7583a656400c61b72a044804b7957a0660cbb20273b2642bd2fc5ece98be884321ff6c0074560d912ec30340cc045b9add8f5c9c8443df595bd443279a6d428993da1ea5549b227cffbc2a01d37e8c5ee87ccd268ef7c6da2fd7cdad428124e63afdc78c129a5d779f1acb3d0570afeba37701122853c2726d6f8b82a020cb0dae35969dc9e99fba7e9ae8f87ce26d515679b99fa09e457efe309792d050e488d89d81ff8d8beb936515591dc4817568efa918fc193b0ab813f3e752ebabd7c800c1972802fa47de4279bec3daed7adead44ba1830d72f4b58fa0a2c5959d9bb0df944d1e2534250cfc576e19490d359d7192361bcfd09ccd4543417da9e01eeb129b18181bc39cc48f84f2d7c0d19fbb02f5e0d787cf5e7401c4039b2d791a8d2709192f0331c2c06dc76f0b4b6ea7021fd6a8024f0f7d3a851cfd39ca99d140575a74144a59e2b35b62d1042fb81889651eb3e8604b6fed68160ab43bcf8ecfa5b7ed204a884e0f5e4d138e2c8d6c5d2e61d0b5e263a9fc4082406877c8fe59f045c2b41d3535a384416f5047ce22e9f4e39333fd3e197da064f0a644ff99890b7dfbb4ef767dbc4eb62e43b054b2f393d760bd149ca99dfe9739d6bbd5280e3107c780b0bf406cd860702cf11e8aecdcc9a51b6c71d5c44b33b07cb3445ca18a5cb0c903d1778ef5b7dd50ab8baac24e4698e11c5d99a3e9a5b8ef7a6b97783ff47f9e277172068e769c5e724fdd0de300281771de3fccf06960cb7ff1c208053fba6d976abc8df9579ddec08a1e56dc122817c38f711cbe4ec73da2594f6a220ab1a50513032c5f4c787bfe0562f24dfbaf8c9c5d0b4f8e637302caceea1f154f6800e649f0bd0a25391b841f27bcde3a4da53f49654966da2b245a23d5c962c13170d72cf198d45dd6b2aeee40e80ece5d2ee297f9b95eaaf7dd7311ae8e49f8c338cd76dbe17e88b443acd9d384a534c098ee124388d26be586ac52dddb4ea57ee07ca4f01feea7d67bfd40b3df6c26f80b1143b14ac0e4dc2ace9e712d3f2b0437ef90b5eef3bbf33eb5372fcc235c7e3a967d39958e5de12343de799b8643762d8a97823c9ea1e6482a6b825aef15183f74303d57a3a0caa0718bf636a885297f9ded467051a231bb06235f9c41fb250abc4c38868d5997d29bbfcaa4a4330cc21e66453569443254adeda5edb370c05639b83974bfe01dd0e2ad4548a2614ec922ace15e31438d3df56c6803156ac8848f4619bc444019f1dab30cc09c2509037f2c59b9874cb67325ab2c73885217f8c0da805ce88e2c1205264a4f70b6f2c09cd72d343aeaf7386d8594b343900bdb53247b36629767f5dfa70013dcc12caac07c5bee48bead5baac771590d0bd8cf54bb7eafabc0c4a19374df4e2917c6a97a72ad8803de5029053de1c7e1ce14332e199808514c4726462a908e9ada9529ec13603b229d983b0a0d0b4d04cb1c75126422ac757cbabe7d963d28b06693fadddc4c9a0c6757ccad5fb5452efd1eac6e209f3d8abb3ad17991ca89918364a94d139b6e66d65794ea2ef977762c6a4e0461ab0325b45c010ff1da3735b511a3be7fed531a8117d108e9c21003278ae320e3a9b66c8fec2f7f96cdbf61d6ce28990d171bec3768d89ec9d0cd252c5c58f0841af6e089cdd55f5ba541a785c4ae54af7349efbc243cacf460d4eca2df7cfee875347b59eb97e05db4077ca65b47ab251bebbbb34b56622c027a4b15146a3c9437c041c1a680cbaddfe504a0ab62188250890fc646023bf49586ab2d19e246cd891a554a669c8b1e4253f37444362f7ddac8097f59726b3c56a550e49b415b066a1dff4b8676ca92a247813c188cc64643733c58619916c4ba28c9024c15a786e95526019315b65bb424cc654e092439b94de1f10540cafeb73c3ea4810364f775689b73a42a4926b47a84eeb00b1c571a5bddc5cdf8b26a89c79655a43c1da30c57c3a3f4a8ecc6d31bc291f7ac384f5fd4fe16a1115e85163cb542b585d0292c7ac0b244216b8c946dfa4e67b0e0f71795e98bc5dc7a3c504c87e01012467401468bce668c80454ea395c61a466efccbdebe59abd241a4c085a18b21bc1f2b67227d8625826fa6ecc49fbba43e0020bf6606ce835eeabfb5e6d5d5bbd028d32ed94ad486bc5dfc672bcf0307b09f598192b641c394b4383850c38f2637f1774c01be40e21dd5514b705c544ea306f72285a2541d3af6a585ed3e817e698757d6252def9823cedb94c54a93bf3270f98773180f07f649b9a846a50637f7386fad6efde5d4059229ad7fe4db9bcc410087feadeac07f0cc94c13ed138f9421e139850467b779bb1205c2926348d6cc4181e665a04872530a59e819b964b334ec2ffd0bacd2666fcfa0659491206a5611bf6013f5163def9b1b867af35156814b6512a79f0d83d5b69a1d1b45b0641bcdbedf560f82d9ba11c2e3d34b3d45252dbd5ac3a62bf2aabb02ca2a9bb4d0beaf248ced717ad49fbcc4b4f043b4ef243afdd5fe31605520f95f80b07b74c9c158973be24db0a92f2ee5b7b1590340938e107cfec67f90d3d9186abd630a86fb75788ea14804eec91a4ad8866bccb9b3efcbded04c08b4c32171e736f5f5330180bbe132b0673bd88615733ff977d34131e671fb50faf76e0dcf3379508734aca05e0e32d28e3730f00ef7e340ba6329363701a2d4312051d21634485f6296185618cf7098803d728a8b976dcf892793fd9beb1d353c8ad9353c8473e60af00fc66abed995280568e457d7ac41531d186b2e054d37e7655d4395c04a1cc407605a9716a7cefa966aa7390d0051c9b119a8b1d7afb67d99c9f8241fbaec92649ad16655da9b327598073c4382282b0dfe3662637a9a59181bb9a38270d583c72469599c8025acd8f6b13d4703645a1d5c87170b73e6b58a7a89010cecb91472ee14e46729a1b137f6f67a42e58ab2fd2e7c7dfd3b4ab28819a227381b724db684fb53f3f3a2626b4384bcd0f5d97550686f1f2bfbe283019bc63576c8c0b695366c327401b084e354de797f4a175324d08351c7f699b8afa9d7548b28bdf00fd7a260e6842087f76803f1eccc37fa857b8dac115747da3be3e60822fe46c8fd909d8bd42d76746d439402253c2338bf190611b2fdebcbb1cfe44c67274f351c4a1bcff970baae18a715dd9e887d03d005e4e41f2ab92d590d922e9201f9a57bc676faabcfd9c90dbf2b9b0c053786a6454f7259ded45f24176b9fa3296190742ab995cf93f717413091273aa5701e13393d861a4409942845675ead9d190d7ebf15dc6639d7ee41f29a2bf582059abe42bf0557155b6a8d5ad840d05d3472ab7b200ea6b8752db51cef8e4b9b2f3a9d82a3ea3c8e4ff3697f5a6a6ef85f26fe2014d89ec0ee60b40a5e1d994b884658833b19cb8917ca5a1c8d14bfa3bd8e3126e11446b8ff63f0455a4dc6854e8e4a733aecde690a72ada391dfd5343e44b87f20324a4ecd240319109a71464e932baf46f3c210c94156a4841f9ea0fcc545445e41361dbb21f8fb8fb9c67326326bec60f602e260ce41b2af4417b94da93f367f58b6f5dd412140c86e4ca2ecfd18f7bb764b658ee197610d3ccd9235a783fbbf86c55f1507bc88d647c128e83f32f7e485434e3af7d8dc3e1b159c4bf30fde9e6697bf4ac7ff6d3c7fcf9139ff49d2a3271ea96f0c9b3f5e01dbbc41242c5aca12508668606b1e5605b39c76d4de990a797897bff9ec4c914da32f81bdc7a97e532c29eba6a263bc11e611b92e41cb226f215f07e80e3bdb86ca36b1e77f83b8e1faddaa8fd583889a5147402f99a1a3fbd82cc87c410ba803b9f6acd2b0c028c25a2ac9f305da3fcae0e1d8f0e926d31f73768ecee5008cddd4f203aa08b4b6c5e4f041bf4c4e1d1a137e4765ecbbf20cabfa6326c7102cc45732e6798be1c61e3652faf87750c7ba917b528ecbcd103800daa1789ffd7b55158b88be4f87f9e794a87b195c4f0b590098be5a31ea0ba908172c9614ac8c66ceb2f65ad0ecd8d9061946aa5c525a19e157b751d3a79135f8dc6fed6db1385334a68f1e5aef5d98f3f778264452f0abe2f012296de6aa34c27e30e0888b940ce1f0a5b7b320c47346681046439b10eff99409bba7ee12d22da1140fe80fef75c9b5761d166ec95147468ea70aff0f646e1d131d3edc60fa18df486e2b8853e5111373e7d18c80543eddee9aef987caa58db555d9e7cf97e49d964c2e72ca76707d24b0bdb92f74b96ad1dcc83d1495551fe7449839ae76fe1ed5a98bef4cac6fb3c11370a4d656b51f4cc496ff9dae9a1564a8d996bc5216677eaebc3764b17f1f89c8a87e9381f5903ba0cfab7bdd7de4056d8f15886f1868a74960c06d4bc2c6cf739aca668f6cb91a01e48c89f91e5c591f822899a0628dc9624e23f1879b0614f5df8dbb6e19171dd942612ee3b61c822a2c00449c6d1c98099ccaf67696a4b881fcb7fd507e15c94803b8826feca18aaf207c4feacfcd6ed475f9ebbf3287ae791c57c3c038f1ba1d96d92a995431abda841488dbbd0d094452cca3203cc00c9a03b8d95bbd37cd52ba2881bf0ffa92014d43bf17c757606ab643e0c268dfc3b13a8c73ab6b25280ed89f9c0df75833d0171fef79576b87f3d1b6abaa9ffb65d18de2845665894502c2a26eb6ba8d4dbeb8bcbf4fb3de5719045e7337b41fd30fc9f34cc2f8a6a226a9a0046d0ad9f542f429387e15fcb91aa7cdde9460f27d6d730a73a7340a7516c02d3c3a371ce54ac91bf1e8b465786945ce80f554622b6f38ca4af46030a68b20e7ca18461a5c5a19ed93447e565bcd76174093be6ff4de146a1862d8d6aed2c5a3d9ec0ce2c0ca0a16b4f99c97fc30102a532ebc38ef76deba46a9162138f2d20fad773287526991720e0af9399d415fd9adb5ad50c55179f6b925d5d972fa4cf9cfd11f7661aa3f63c21f59d9635d18727add69d16d09a5bf82f186f796ffcb1aefc242e5347867ca008d1a0ebdb5c5bc13b53f64b5cd76eb45eaabe527af28c0be35eeddfe002c5971369348997b78ad2641a29ba421c70f65325f88b6fbf6409e53f290071b26d72da5db8073cf9cc0a2feeef88bd5f17a4f51b677821e8fdc9baf5888156998a5e251a025fec90233741ab61be0ffddbff905d7bed052c1b9492c45649090e486dda81bb276f459d180b7be1991b72c05e182e214e13e5d5d975179c5ee11e58c0a743e7ad079e5fb4a15cd5ec9cf0909af7231146a715cf9cd5d7bbd917fe02ad3c99011e57999443302b86fbe5606e0b7c3ef634bf6f331d096a4052ad8541333813fd32fdb066e7b7d6d361b4210d7cbcfe807f496463c1e1bc48954c6cfdcc1d28e7e064c7dea56c733932ff197d9fdebaa16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
