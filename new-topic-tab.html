<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ac23b6a89a3588757718ca5d0cf088285024bd37b436f07187eecb90497896e3cd327c9e0da9b4bca39d0d154209c5c7929ff46a87c3c18e1fb476fc846d12d7e831befc481cce7ac9f5037dfc5f53f5b2779e88581e78a47c22870694ab6a1850c3fd1b8c80ef822bed23be3b15194396f9a5468b30e958b34e89a52284b1670f8e980bc128a236bfebf0bbbf4261be7cf0ed5ae83b3c631f402da74a09522b92a6c18d5f3874d9af98ccf2625c3c2219bf745f52f25b2d22e17141e3f110c76ce0745a453d4c927831e17f3e74d004764571d50941b75aca4c6de8e1d3d83eb6e4d0222b743a24bba4eb7d1541daa9ff3d3eab8057614969682a5e1bed864a99092319770625afc9ebfde3aeb39ae97949695ec0ec0bfe733d07f44e190216a42becc54424e862da3980cbd65fb88b9461c4f2867ab799e77ca88c607ea40c54c55a5b730d26098c6617724439523e636b66f641795cc573a8ca859f41c03f960758e53ff8f838796be18de10aeaf167b7c81b5678ecef00af570147b24e23bc252a5efc76c6349e167cfc3b91072187f1a216e741e7ce6e48339a3c2849c8770763a4d926fde3cf8252fa152c4b4e6fc84ef2bc5c8d5cc568b0b032ee235cd35a1515a94c98c8f4cd0ab956ec6d02b21616d18fa17cdc5d1fb9e1f0fa3698327fe2c4b5a293e808066b6021a7796baf83405e2536fec90530eed0fb6aadd75dacb4f65fadd5c201fb293fb48693407c4d771c834865be7032cd8a3561d8557a2c17cca5bcba7a13a79feda55f171b96043b5f2efcce6b028f5126b3f8304863ecbcb437ab002865092a19657935ad40c1a86d468f0040d3ec2155283588d46c5b3ea3bf464ba0742394eb594c14b3a6fbc78f51b0f395f15d7b38fd2af7596cef78343f86449201ac9fda03ac3a29c6e4382ab5f342abfc2524d9e90adde913be6395e1a7c521838ca3ce1382b4bb8300aa88c16c1d2a5886a0f22d51df2ee491846f1cf9711f607bd8f59a0f4ae26ffa4e4faf3e5c43c044e865c6c8b3f4e0e47ff4f1386575adc1444b8701deaf35bcffeba8f2d40a409004667f92d4892fa77e3ddbc83def6737b2510387b561bf32776d08c24138a5097da3494f0227c57c81b8bc22f68a7334dd06d511e4ba06a23efe71806e724c17bbc1dcace562f6aebd49374a0c8b2c2498f9b860292bda7835e317d88ca7b6e02de9d33f8553e945fc0bddf020d95ba41770d87f304323c7eb6ca0392ad438054ca25f9b6b37b209b3e03ff165897b202505b3580275858ac064e621685543c8823ddb4f2bd7cec2daf49dc0a3a75c40aa4cb98b6e53d9051865b5af1e2891111f7c895423487abbfa8f735d5147291deb3ec3032dafa69764a360428e389c59c2b7fea5ecb842d38c4fed7abc112119012e7f7e8af4bba63b759c6d6e8a086c7f52007eb925b53493072f2df7c1367be2dc0e8ad280a6cf2414b9d072399eccded9bfb1dc9e51e5ad65b392d98c6b733d21cd4378eb1514ab812d0ff895a3956d589a6497ae03e6ae408ace1379da7d7c0fc72b90020351ab7e2e4f255ecde774662a6b75a8ddc1e6682bccd5895af6d1f28256f86e710c1a6937806ec0d95b92e1c1c9af8074eb0fc42ce7fcae15511c185ec5026fbd247eb325cc62a715ade8bb65c06c0ae551c0c7fa0ab7622939ff4b94cf1251df13b31cb91d5178b1db321fa04bc74552e1eba8a310c716df920a712b5e33420bba9515dd1392564d9a006e57777aaaba7d10379606d77a211517391f435f8f1746c2058841c77f1b996abfe1ad3a40f73e9b87650e0e566476b04379009ca34ccbacf7d96d25279972d403b12a0a78c5bcc3b7d28d1518465083a246d9de458c7d0b5d64300d2b8be812c15153b866f3cffe0f069c30a5c690092f39fef7f2530df1bdedeb132fbfaa9c26b13e2eafdd03836917f7fda2a6eaa1156cf2e2c29619f825f86923df56097fe89a13a1ff33ef9675237a56e87243a5eb753454873a12cc1ad11d91e9918724c4ea5b6292b95d67161098c7fdb02720e059090a1d194c016d47dfa279f9a7a1fa3288f9e674593b3203b65ea280b41a620fe894dbee1ff72220e5158fdea697996b0c968099a21fae47e2acf6bc5480946d7daa1a65f29f136b76a51e01a0f45e77e393daf8dd2c0ec97806eb22757cc1c54aa82dc11a776307b1675210da3bc663038fae97a9aa510f2816a5bbd4cb32e161566a416af6e0f8080aeeefb7aae482fcea7405f0844e499b54bf811f5cc0d07d9263be43bd2d82c9a9ac82d202ba97277098c3a8180f3fd8ca886c2a2de854e456a1ce3c5320429344e7bf661880e2e7efd616585416c099ed564cffb1fd71f360f650ebcfa21d7e219d09cf9999cde8d07802afe7feb41e2d960bbfe4ed86de5f559244cf08dc7f821852199e348474db2685d4ada8a4d7303034093ed50a55b0b278fd5dd87ead9b1bc197dafb6daa428f1fb8b9ba5f5f0e7814ae7d0bc8016e5a6e5429e245ca22364579c8b8a4af871f4b5e17fda46d196f8faacbaffe3d582d3ccfe3908e212a637b423655cf284e89f042ab5f2ab955065fc07fc5b253b4b9721ab2ad27af1ccc7c0c2106a73b2b19118f3521f1985076c6f4e0a54c54a889ce2bf427bf1ced13fdd82c530cbc8da2dbafafe77db0ec12213bb8b20efcbf7f404e7a41cb4d9f3b6c61b6c5bb61edc82313fe67d2c300686b5d2725a70440f50aa652c6c274aaf2b06353014325dd3fe2dd88d0e368023ca6af02296f1d533e77971d09bc49b2334a805b754ec87542cddee70cc3da855bab1f0f5a43b9e60cb1141b3ca1b300df1180882c83d297f0eee9a3e111bf9ba271584409294e1ed158a7df259dcd6e34b87fe1740cb892a6446514999c845ba34c32a88943a983efb941cb661a2736bf8d2fa7c927c0e5241f49b93ce03df970779e905d1695a9e71de38505b70352bd8344e0764f946897f554b667956692c1761333327899e0bcb78c9da0b24266f0dd055282ca6c40baef047e13f9a9f8e103e74f41e760000ba976a29d16e71189504c29131f706178086eec1cbc91c5eb54b9f3704ebd45176d74cd43ee6b0fe85dcaccefa896abbf01142c931dbfa32f4c05c2db88c3d5fe01e5d67a59beb229ca979e6903f269d28197b2ed2d200127413783127615c70c2dc91ad1ef8ae0ab790981f1c9c2a4461b753eee03178d687f7a0e05fe3a975a769c34352412c9dc19f28b07de310460d35ee007455c290f746d7de1a155f5cae7a91736b65412c8ba053f897e9c1cd42db012689c052276298dbcb26b7fa0e5fb5f9d9a865b9ca9a469ff91a6059eed1ba9a887024f954cc962bfc4e10e0907b723266b9c356d6d788980b9a2fea3c2caa05c5bf1a414bd8f3c36a0cdac3dcb6faadd653085cb8063cfd14d6f1dc5fc09f08ba710848147f5779fa2988d5abcab3797688a8807224ed2688f152b2dc59f37929bff7e4a6eb24a55319e0a7ffc6ff1cd062d36787f71a463c734e37d51ef8dbc17a03a064269d4a02fa14ed88881ab2093de35073ad9d7310109f9975ff024df16cfe5543dbdbbacbfdfcb6236237cd534502d35b7105528178c0cfe018007edf5f232c7348f2e987d71206fb5130ecfe6e396f122b0d027549e3d4e9935977edaf0fce2a733d99a2b3476c97a365fb2403d290e0efce7be36be53e211c5d6ac411c10bd9c44f653f6b6f21f3fde0f7945a6a0a63caec91a41fb46dd3d35dd5335b440ff263d923a9b1ba82ffeba2944ae8e9049e1deb45c759acaee9ecfd261823529fbcb72a2eba2e177ded8edd4a4c74112e0d23d468b7e52772accec2ebe3c6e7135220294747a341351016eaefe025f642b24a60281a09ade1307775e7b6cac07936a1d27cce71f8280c6f7c12fe8fd64c53533638fd3149f21ef4893732af75916695a7f19ccf144bef87c234f01749fa12703548dbaebd94d12677a6538c6236402ab36203b58489ba8f18480298336298bc4977e5ee13dd910d234e29cdbe6b9f18b4e492f99d1a4c34a451b00bed863a7182dd1475440819fdfdf30364e2a37a9708a4f3f21c556a0cf453ab8f7fc022e629bf4a3085fc2be320ac27178a61c053a24a3c95fe37666e53f99ebca2efeee45bf3e0567a5ba2df63853be6fbcf993fc8785c2d682f1fc6b5f45607bb187deb76ec8e4805fa640c3ebc36971aa922f602966b985abf4d3d15b803fd528c1adbc21ed4659f0352818c936411fd6793f41117b3369d4fd22c9239077c0475ab4a166162812c9a58f50677b14ae91ee017e6feb8ea407c87de9ce7f86e4508c75c13b6d740da9f29ecdb04a35fa800b29077d21ca7e654cef18ff9743238c203756a84859da9fb85023faf58ceca86a68f18caf53f234a228a307136c866fbf9c70e7eb8a21c475417bf8ed35cd9bf57c55c848e7543999c0ecb34b6aabc308a8677cd1b1e5895c791339785f29e527f08e6b0b18428a25942d7129d99743af7093b953aaed363184daab709f0313e70b35c5e111ceef9bd17777b8577cba653ecd5794f15188276f495a98a8a3762597d91c55fcf2f44b372d4a17b52f4a22a6935472a7324da011d7a47382f21a153436d7b589efc3bbb2a1105617ca01edba4e13cdba4a5896e7e8d4e8d32da61d6ab336d86c659d5fffa49be029ebbba16f191a291beb6bbc21edfbf5c85bae2f5401ac569a606e4119c92040e27c40390fe2932a689cad864ea8c477b655ebe0a8ede4bb278f0415339eb5b989d8e806a7847eed3673c0c6a7ac2ab8f9ca007e6cd0c10937352198b508bf574e1aaf4729c96992ceec2b018a062b058b7ab98ae0a6b8e250b2f2b026bdc739d67b168f484078677855c912ab5eefa5e45977b9cdf9e06f7b131e592d25d91fa1bfe600aacebd70699335005d298a53f839a9de53892a82421c39a2f89cfdc5256955d583a48c981abade17286f3e0c4e07acc31ef8eb1fd870326a9b9c65623a89051f688076078e43b282933876531326c0e51cb18455a1f0632f5c108256c859734cc7e6d791b0bd287f702cd5905594b7b65966d52ebd3076450b4332773e25eb644e123b7dfc301844f795038510df43229c0e7de1f7b656d336bb571c8f9c6ab8b8c007563af8230a411d0a87332ababff5c7325c4c4c8a0261ce77d95a973c563203192693f371aefe10beb7fd53d522553ac530185fed3b0a995367b8ab903f6fdc23b15997acf3203d73b2afbea31ab248871c9da79b63b3837612dc62da3160e9cb717f98be6bb4ad26bd659ab34b37479c6891ddfd92176b57d560d9611af1aceeca26d50079fe6e70447cc9c983dacbdc4bd55c0643b55892ed25a3540c89af16b3c145434320ad425e14f0d57e5ac4ec9ac10dacc974bb90a802ad7609705c082316149b96412604858607452796281279d25491065fa4eac047f9b1d3d6d0a066718f0c18eba656b772efb1bd379a114f0f742d36e02b811583d2111eb3c6e4198338454d8e7de058c2b118793a3b41e01e437fd3f95562825835d5fcfc78c6a9d7c481716fcbbcb3e57039adba7da1c1899910efe1cd49ccb51ed856060b80a5d75b5e9b22676dd062927a199cf7c8ac4573313849dce83af1f61f260fb898b1e29d500da7532de4f49f5844781d029c1f3f6f1703ff418676b5e5e77b8377f4d9745a6210445a8261b64f62b2cdcafe9767360c6c0e8618042a3cd32ef3a6a0114ebcd37d253e372c46fcab98e1829402c165a320304b0bd4e27b62442ea49f33175863a72ecda48883358f3f9c65ec0aba012a26a2648f0aa2188c6b68fe1dca6cc0216ded2ae3d60fef61aaa2e8c1020ae206840ea1b1bc1a6f9d612e56833a432c1ff3e591abbee4cc7574c66157ede9f72a1a19bc301e2530a835c89c696260810ff6f2b5b85c3d538d1520be6c08f804dad71e985c41d43001d25f9e05b29f74a71d586f85ac073367fe4d79a3889251bf1356388543bb9edd0bab582369c6bb99e22b72de0850b0f6f52c5d9dd2a4025839a2e3c04fd11c0ac3ed642be79c55b64727cc1cc314e906bd486952c165bd52da080504061f89c44888786cb502c0b0585c9f827c24c50bdb39775c2e4f939cfa4065b36dc74c1f0bad42cc4dd4b0155b15ac35438ac917c2efbf0eab5947c6f6eaab78870a2c7078efce727dc5f8a57e149760e9a8f3416e022355d937bcf235d105e4f6f1b7715d5a3d46f4cdcc065a8417a1656ab1f3af5d53199d82ae7b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
