<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e051877be5245f265da7a87e8bdd95919f9dd0504806fe8b968f781177cdaa469c1cf705dba315bc3c148a887f407b9aabee4e1024db9918000f533595e5e251fc32cf51700b4f8460ecac73bd2f91578eda396cd1ee3cf7176ea1979462cc5396c2a486d9f906abb2454b4d7614b266001607e9401d7dfd12b0de9cd052c5173aedded8b7b6e62b8d3fcb137e450003e7597ec31b392650b5cbc8f46c9f82fa657a10f0697cf12bad419d71b762eacddfe3dbaa3ed3a18254cbe06b0c48233bd8557c2c0a9655878a836dd9f04bbc1c55ee54788d940c0a82593220e325deadfbf7e8ba1edd5f2613d1b2785d5f0f3c70b02b5e5f59a2eb20e86fd6a700e130cf718fd324b1a8d1a3b3c200a481dc14f7c462abd2a63884412de48cb0c6391d7c4feb37813b12a4c0831bdb5230d3b91fabf8eb440ffd81d0afbc2e886e8d4e99053b6370e95ea612a8d18db6c088f55c13446206ae13aa06ce622752be9ebb08b0ec4c90c2cb1dc990840d665478f4df8515b0ef9453fc8f0a8f05041b3e2993467a2023c131438b7cec99847692c15c4e386fdc8be96a4d00be6da1a2c89ec30852b59c215ad750c1ed005da41a1634308e01843cc01231f28db08dbdecdc28c6bbf7388e1f39671df2a24c755618e024c8ef09b2494123bfacd23c258bb745e55318bf45078997a1eaccd0ef2cde8191056062b9a13a22e23a1f319a9ecc99f156a21526014452e907ef5dfabfd842ebce6ee51b17e4bb976dcb3837061d65dcb3e04f9f4777d1e8c27f1d31aaa8ffb444a9eddebeb7e0bdaf5b8743655e5c981dc142edcfe5f1c985c00b56c82df9717d713042189092912160cd152c349c0ca73af9b3cdaa8d0ec32acf1ebce1e5831f069107d273fa48c57cf8beff792966a4b5506a3151569ab4e5a7bcde449462bcbbb1d9801730f4aeea1b57da82a92d6077cb84c327c189bb826805fd3b44511c4ed7b10b2db50ebd45554a4975f45b323182211351b06dc58e712d7095e8abb23f5bf9dfbe600389ba24aeb46ebe53b609882ab3e385699c34a50d2e7ea4a46f73425a01fec1e5bf1fe4cd13084c5ab205f308cb5400a06f21ab49396e75815dbfbfa543014a5f8704186138344a4e4f3c6b2558c652d7f6e4f3b8ab2dc39fda3441d19652fb06a0b831e0b633c375adbeb11d1f02b32d7be8165a2fc5073d2c91515275bd1471b75480caaf9e37b896e1f18d38c6d161eba8529ef52d88cda531d08146202d74bcc4317783814d101e2107d510293cdf8f59cd0437917e867b05de377f50d731f61cb9bbbe5c5f6f06e6899c3f460233a330c92d796f9892aa9bbb96797da49d95283af63b02bdcc5d542c0eca2484ee4306a9115682140df80d448582a8dafc6f7e885385beb0524bbe21762dcdbd3622a2f486682f1a34752b2a2ddaed50b32377ccbb3dced120308079a2b6730c892623a980586b35065951ce48f17b565ef69b41835fdb7a27469a6d1f439a6db040a05ff8d2fc8da3fdea25fdeb095a8d57f8fb1bd16e11b0dc51e8b657a1b815cb55c698cd994a2b1a3ca0d5e2872827497bced3145fc378fee6323a689ece9f08125da452288bbe11d6ca48ddc8f52b022571c9c67a2b8cd41e76596dade44eeb4ddceb35fbe17e109f689daabb944c556fe38122d9e908d8d44b5ff56d1f559b567f7c1349a3efad27b64f58f945a6ea7d3e1d3d27da05d84116d5477abb82f70f513bcc96f67e3252c30081dde8111e2379e089d76673dfda1e04a092881777df2f576ef98fb1b6f14a2893693799489df6cea58b02971253c0dcd03aaee5822ea7ffcdf5f716ebca4e57ca2c8f5bd8cdcb37cee9f7dbbad84d0e4c2e26718e1de1dce16fb5b6639d30e0d2ceca17f71628500bb770fa23ffa47e7233977e4d0e02a0ade42396aa2c4835a19c464f57b5f51c629c027a36312c428402185823693bf49e6baa831302d0b5d4d0098913ed137f0c8b9dcf9fe92521a902424db3f2e4fbea91c05946c6f6f3810e72a330e053774fbdf145305952dd729c17c126599b89c7c141d23c314a0e7cdbdaf85b4445deb4ef28a83052f780281c77bd4c7f65a2ef9ae9936c25895d04ecd1d123d492498ec54e2a946bb523d0be1516caa4bad3ee8444d4d267befc26e1d1c846615fef5c56fb71212bd885bf88ed8fb04abf78abd03972fc738055aee94f3446a64bfe8526696355d981ddfbc565ff42177c6a43170f151bcf1cc6c2b98ce67e5a896d45f3febd936e9943d2097a3cb030dd402d2353541d6b45e1429a9a892d579c97f5f78f3e25c289096f0ed02822803a1e7e7af979a5912aff6b5a4c4f55a1a6b73e38927c59c92da9c404227b16c36dd29edd23419cac45b5d8693b98ea406e6eb67cc35c056eebcf5ee90986221c1af3b381f8a881fe587f39309d97a59a6fdc6c4a38cc4954de67817d17916ac0b5f53411d3ec9b06de92eea1c8963e0e7338a23a642a549f059b0ab8c5e7e0563ee875cc796986f442b9a187dbf208670e56098dedb8f237e9803e40bc74afe1c0edd6a652ce8cde24054e178f97fe4010b5a086762497430f490bd10f28095f00c6d43e4d2ec6bfe1bfb285f284665f525c9eae0414b1c41e09a1b1179d27003890d641c518b0e9d127a6f7c64f5995e4c5253b2045df9108003910bd0c2d0336dd0718c88d7b1d33054369044306e0469682e6079e2d15230cf3f0189743cdf084acffaa39dccacbf6f2abcdbb8f6123e139fe9f59e018cdcb6f8e98371ce61deb8dd8c51106040948daf41172a604cc8152ad6e591dbc6dfdfde52051b8ce38c7ae60e89b1fa763d38354267eb4a32e2cb8ff240133dccf9559f62039cdfd9c46de72074af6e536fa6e55990bb425c9d89718d820d02a5f9d8a29064521520a888d61fb1b9fd720e6080deae8fa1ad89792bb5224b95bc373392e666d88764da36ec923730dd0ce225eb3caa56b3c3d4434b0592327a6ccfdc256c334bbb8fa7ba3d0defead79c3a416d291d73da26147162c7fd62b100e5d569afe950f8c9fb7705539e32927948714c2d304df7b8379dcd3c6e016d067a23eeb3fd6ae917fa8318f11772dfdaaf3f1c882884d6d635c6e386a8444daee58ca55761848226d0acd63e1d7e35cb1f7f562f46ee18a58102a14dd058233258c40b88368972474ffe16a35b0bc1013b4b4ddb8b64e07b8c24e956132bc72d2e8b389bad8e94b24c6671ea0b874857614efb3397efdf10d9000c7e91702e1a130ffc22164d734630462c378f6d1abb78eaf0e9736f29aabfd10c5c6ee8ed93e93593e9e70aa7c1d89bacc02369c059a2a65cead1bf2f07c1d3cbd51039a17908939d50d6d1102dcb99f172b870a34506594922f7504503f2926d5acc8a37853119db460193a8c571dda1feda749cda290fb4d0e9f0deaa0fd4e06db80b40f04e732f0465c6cf8354567df64d236cf489e5f31bacc878cd860da8ebd7a1484b2b905f0fbee3421fd4a17e07dbb01e66a30d6c97c38b3afef930c5a510925bc3eb401d3540dfa95a791606e5b98257b484180de9b5faf7d1b150b4796ad74b9ca398a5c027ecd1fa25a39d7a0c443a069b56b1e00e81881542d0a2ee487d9c6e86aaadae8a483d81fc8ea243c30437cc5586e09eec7e452f53b4ba59eff606e68812f3dbcf0b3f8d96620ed140f3915b09dc06e71fa1fc2c3cf0bf4a5b1ef768eb0c8b049b88cdc24ccb76f6338968d1f70011864f62773a726c39df201318926828efa289b42ffebef34fa59971351f01a6aa2ef1d416fe25341fc07c2dac3de77a1c3e67b37bf5b9094e18f51e906690c1afb11147ddd2a4712a1961f4f9becf6d0d5fbc40b3ea56f2d1ce1a69a8d5272ec9a15262cbfa75e0124b8b14f72ebac4566fa18a2e59196713d23145a46c81187d135e28f3f8f756e060bb2913d7da5769011c0055860c050e095db6a536417e28f8404372f740a2690643469319fdc56c03c0bdf30fb96a9f6b521f881b3fa92af9728a0d8a6298891721e0ec2358c77460ff314dd8d7a2ccaddda9708deaad2adb36222c62e27e68f9b5c252770a3ad091c0b1b8ba3b5e3072d37577b2a7e7d11c75824be88a713b7cde1a9c3ba209057b1e190c45bd64b6f0fd8f8c7a83076e9a4640cdd3b8d65422185458c8191128292f65bef0e5ed4a3c5130c73f5d1849036a7c7a392b23c6267424c7851c465502dc59987284b314e781327927a606db8bb33627dfaa5add41324f2d9cb43f532aeddf44677361803f94024e2297d83b780a3c088778b9aeced805e77f009371be523b44d2c49d73476ea9530dcb2c00ccfe711dd89a84f938c53b0f96240286dbb278741b18f8238ed11f1d1bff850ebb0d57b493f48e894b9d50c411ffe7d7eb060a93a2d78584c2cda03f1f3732ea0e1130d1306258a63370e88828fe4bb897fd958c70fcfca3ba334e848b349ebc448b3d4030e55df73d4b2b719ca97ab88c239d7b68fab1c2276806550b4d5741c9861a807eeec6f22e09b64143a9671cae394b4148e901e6886ecc29d76c63b619920732858acb122bf30679667a10f17c3735be526127cfcc62fa8c0c5e65ca2889f68763a01e237e3c36c586a71edede5076b70877797545273e6619c3c503d92a55462a42c1415fca1aa7317ce1759c19a3c7d2751682cd7292033f913e105bcdc17fd15b3c717c509e023fe88c9b42b185b2bb3da1c350cb36450512b8188b77516b1266452d2edbee513da7708c3f2a53d94088fafdbdf7e6840a4c3fad097107c8719f335c199841e42a23e2291b4cbee9b0fbe8cd2ebb3f2e58296343fd65d315ba27321eb0f8b4d8157f06672d5302dda00a1ac015909b8cffea2033c7ee572d63ab813312644c9ea4bc2f5ca5d94f3a5c7fd04684185a09ef285e059067b0eb4bf6ee82bfb85a7254dbffbc0021a8993535d643be6053c6847cf60f79922c411ffca8fd291a21ac0bec7da8e6540c4e1e08ba62f443762b8f329d8d4cfc393ed0cb4266f276986663fcfe5a9bdff67a559db88250c75fab29a11d42361fe13eabc5f0ad1719b76f4cae676a912e135ee844497115da6bd9c3ae29c5f837666a4f782ca9b316a0f6aac871921503ac3f4ddb08ad254b3c0d4e13eb322136ae1f442ce9490567d59b591fa8c03bdf5784a512f131dfdb4500bc83397984cd77083c6625cf2699d4a5c93baa5c23156613eed3d1e80c589a0f7e9ba132c6b3c761fd2f368935a98a21acd8f651d09a3e47690125c8e38ce0953cebf97497df42015a8208bfca0411e3830a4fd865a3ce7e457a19e2b216393a3212d69a4ff7abe0efbbb91dd7a04ef5afba4533cbc4914183986c1d81efd632ddbf713420f4423247c88a2cccada17b24e0238da140bf6d45aeaa265f8453c0fd073ac378f49f4d44823de6d0ec49539034ec4edf0250ef5ccdf6d103a3cdd213159315a58e8463b40d8b00134b46d80fc8a8c5f979e6b1bb04c6f969657927ba731f26ca7776bcd3a7a636b05719dd50c8c270c71a7a79ef87a26b2a76326b4bb233583e60ddf2206c7cd3ee5e408f6d32ea673059c7b4a9c3e5678367858e15f93e5799c819f30a4f00954456c240991764d354b0f74821f14ef22bac808344c5f589e728e91e10128ea81bd7af78ba0bc948106f4766a79a155265cf5f60335c35da4566422729b3c04839d94f96cf2906b07f5f7907a652e76aca00a91789b3e097035494ea7be6d67b302ead5451862eef72680fba74e7f76168f165dd25bee30416b395be7ef81777bd1f3d501254d308b2e4ed00a98e6b1cc4f8b76d96b0089e1ba768da10bb1fcc705f55138a8879026cacf2daad0dbd399345b136bcb1fcc9fa3aa24af94739e7d214ae7bb6ca017b06e2c2cdcbb6412683ac7d2edc518748883f32fc7a457b3f7906613b6ad5f24e919f7066fcf9874a1d4bb0d2d9c84ba88ed679c402754417190347e22a880ccb8089480ec8c06a45d8fc3627764ddb26eda8de605ea923446a7feedc162d628059e93ce10534c8093c44fdd1d485cdcc15ee43fb646e5cc048083298e2ddcb742324b2aaf20e5190859c6f89825ef33832ee35fcb57289fe50b8b66e465f7f1ed6af52339bb3c545d4f39aad7d8a8519d76db452d5f873e67df6b6b90923a22af5b01b99dce9aed9df442531b9087d7f54f913118c43db61749dc4eba018e565a9ef6c8f88e709834ad64f0ba265602e123e118c22c5d980050015ee794244e3cacd949d1c9e034fa6a6f60a1beb3f0c3ae3a11acc7f4e43cc516996c559bfee13b0c5adede9167a59c9c15a09a47e33388c561b3af2a2304f9977cb0e1addf7e38adefce000cd849e718d81598f2c814752c809f247be8cc6f037a7d83b5e23134ba17ff96579d95ef48aa51cd650591801bd588fba0e731d57ad00b6900eb32a7241311794a2489ce510c1875739f9186f800ec47d97173c60301d9da22d7585710326a83a7175f58a7e4e4185d9bff2ef6b206086a3a32ddac10e2078e5f95de668b637c176207590ed90328ac52f398dcd736081e26b3094a80f202ee64e7041b94a2e4c2f6b764e260dde27ed1929e083d6efacdc3417f560fc85c2ef901c257aed8d9be561620a30f1bc4e67f682205522c3b1ef22a9d581bfd9e4102a6be7a836b5225c189dfb8284c08cf6f80a2cd82a26bc99e2f81dcca77ba634f8a7c577402fffaedfbc03dc39dc56e367cdc9d1b54f6b9d36d6b0f6a0fbef6920960a6c1afd9c7b4123e06e174d442f4b6b6171d6420bf0857f38ba9c07de2958782b2ce8c9a61812e17758013ef76160096cbc270dba00ad3a1e3561f4694c32805fa660f23968a1364d5fb7a87e3f874a98956cbfd67b992da26f0ead552bbe0771c84ca6c8ef1073fa05d6bed564c1910f3f24f2b053cee0378c96339ff14fa6df2d8e90195e21dba206bebfc83c99b7db0e7769d0fdfcc63e6517029c49c8bd095ee84a03ade17047c2923029d29227525c2c2d574cc63aa61742a99995fc4a38a73172d7fe381f2735811402fecbc63fe247c73bdea308eb7cdaf6cdd421f79146f01e7efe1219d6c825942f4ae6e583fd81abea750b034826302e4eca666fe4cb0a4ffd0f5c580ba9e4e5b9b5277c14b7e19d432fb35eacd8d8decf1382f9752911929b728ae402f102c9aeb7667f7cf9b0884842218b99825bd7e05d21db2901a7eb4384a487f2571a660648412ebe3e4d5ae9647fc8abb4b60a16e23f43a04b2b107f20c5451e3ea9f3e44d196ef1bc739a74a23998ac989fc6f85811616ee86e506f1c1d403d222cdc5ee0b383f61b00840d341e595172d6f13251a68a48ecdc4a3f73233ab9ef2c89c25fa419937acb8082a838a3689b8f6c7b1c8f3f5c005eda84f8e1209956ee2c76a02f6e807733dd823a9589649271361235073356de9865a147b934d9f89855b0431f5ce8afc7e459b75b80157be7a5444d7fce72a0253b435987887478cd2bebea7495b964adda9690b379d54662296c2f37b1c160fc163c42dab4257b554efc4fffe898849b0642b12c183bb5a28f21ad3cfc6fdb28d3cf4c926853d13cb5805d950c9e61eac539fd462b0215da8f5d77a23897c21bc19db04fc738266ddbdb951c7450805d074e052e07014d0be8bce55cf2cd84097265c4a3b7b1ed9765a7da2dbcf81f3dab623ee9153467ab67777dd963c69ba42e7a3f526f588e0071a2728fc172bf07d35dd456e4bea75112b898262fd65539924da8a2f04035c19db54a9b235e9261b669c7f1a844244882f8c139957b916dc4a9861a4889d978678d626bf967190633e7c3475e63e22f0aadbbca33cf325aacd5d4a2022aef53f53feb4c207e22063c00f71b19e6f5bbc879ecec8f9815b31e72bc44514cfec9fbe3e2196fdef280f8985a2e4bc41800b5f7b4e220e5eb18e4f4bc8735a4381425026e4ee7bdaa7b5c84fc2e511ca5815b73a65ec01597e38886ac01eedb4a48650821769cac868a69fc83a998baf390611d1f24f81851fced08bbd536d4044bbc1ec9cdaa55fa91d24b13c97d025499aa58ca0ed67e23287a8d0f63982f52ce66b7f5269f690ba1f0cff25220a2aadc3a7ec7cf4fc4c0a1282ad2f9f534c79e2e66c2818dae6c04d22ce8b597bf3a0d585c0c35d6630b8f163657a30e3c6802fab84121b86df9071f1ee4c4b31992b2ed78c1dfa5bbeebf49a4f816fbc2f5ef154812d71c2277646ee855bc10cb7422bf68e809d642dc8252b599952e107cd50421f86bb3a4605f92c13a5252377b840cf6ea344bcc8d4ba17908571e2638c048099197426f3fe122d5eef820086a510ebb83e28a295e0f25e3669291e61a2fb181336bb46a72a41301a1f29e2ab86672782fe67c04fe023cc8949ad33e7cbae5c93b737c2de696c2daf1fa67d28de60260cb55016d391750e73a094bee0eb822c55b001008fb9265ef17b002c943056362f79d65e9d9f4d01568563ab19c481f8b9402c92c0c27a7030b65a875d071b2706d8fa69eff105858bfe3665c85ba614a5a87606c31d6567959bf7dbadc0bfa55a9d79e8edaa932b75f91c7227dc2d9177fd5303e8f26ea4471c19b5f8376d4957da41d18b3d3a8f9d21315b9fc14481d7a1dcb23274e51e5c4b0bbc1de3e805d7fbf93ac29d61f0e8a9f29d983b9ca14a426c4fdc00aa391993a2b47afa6d12fef357f9daa23955427ea308f9476dca94102c8d93858d4048a62cfc63e6185e1079c60ce4f4d1e88e25ada420a4bcc0919ef4ff2117cf7eca24f974dd9ea1acb579646a66dbd376ce2c5a6978166b7c3c2fa912b2e4681ea499face553acc1c9ff3615c90f6b1b190fdc0eee6a8969f03f5f8ff0202e3d4843c22cf7e381d8aa864947c2f01db8d42a8f2f2f370778e0f89d33c68055947d38b9620eaf26cb034f258f70fef6071d5b784fc863209084e0b1217e09392277ee6d6fbc9592c0402836cf80840a90b2d3f82fce5a71fc07de28f0b9294efe9b57a74702b043c2d7b36ab164f1a58b2f7d195b560848c7f87c21ab4e636dcfebb079ec68d412b60ec7e0be96aff62b0cd1a552652732349e63840a658e3af9dc0938210ba7b584f226af635706ec46ddb969e01436a12da58a2387fd716bae889a99bf17201e53274fbd32b9052efa501eac50652de3a396d097e41ff1b106830eff07bdd537775dd3a47464e4d638b443372e13509dd0c94970e4fd17d291523c9ac0a98154387f83ae5e23beaa0c72827c14fce73771f729d8f18ee4791beadce5291409843213f87ebe1ec40c02a88eba82f978df333dc6c312c48f957e6c76dc690b1eb6b35715dfdd0a248e3884a14a1a1299cc92999a4924aef2ac94c332197fda9f47fb633bcc80fe8dbf38ab90d1404b061217013e116a9afa7435788e1ef35f5832158c1923ee03a665df272db56f4e7475a3ad3f38aebc0a2a22e38cf6569be4e7a3b16a015c308e4370cdca9ffc412b745b5ca2082551e36232ed5b5a213204feaade9d13907f6e95b41430bdfbc40d9ccbdbdd21d896fce28f13b586391010a56d49113f2e7499e4ed7172a7f85c2f670bdb5f0ca7e3d255e9559f2b60951413e763447deb71b24ac84a81df1112f0273d7a46d9e9f2ec23bab4ec2eac23306ab99c6a922341b0f2169ea477cd6b544ab5395a320e22d278a37ad86ebcc1f3ac288eef68cd3a431b5ec8692efece4c3739128ac16101d508682dd0c92003cfb4d5a1f3b65a1d520ba6f063c80eacd2063c1a0146a3fab3a9f329d02342efc13d1228114b49750b9277967ba805bc5b9239fcc4d63c9cc3cac4fbeb4c19a97dc5bc7030d198efdd26b108407b4166d054317b12db42ac988bae925e04b1150bb08c34a3783eb1f81767cb843a08af750d0965d373bf160a342cd36cd240385484ec4c846038e58efaf87efe8c15d0c0e69a2f3de543bdb384b64f1237cda84a4fae871e5901de2c1e9de4137436552f60f978d4b224e24bbd712bd63535b3f32828d954c3b005cf8d6e5e86e50c15e03200702ece00136cd904a4d9bb30f0fa85b6994f2865e5d7613541d84ae19cccc1d84d56ab0eb7b253334d8014ef4c6be9a500387dc50b1910c49be33926887c5db9a55760f00910dd1e2f7e670a06050b7d3f561676177933d8b4429084e53c61464e99272bed7c6a845e3c14c45ec2a766b7c6da0b5d883652158c92ec286c005d5edf3bc0f02d7b45067b033aa9e403579c1a86bd1d1a7a5d2d2f80327358a61679e223acc7460c4981ec44e65037cfa3d51696c9f48cacd2355a9482ac1ad29d29674c717f33dff50739f893cbf774e9bf5351331db11ecb442ec2059b5b17c0e7bdf2cfef1e6e7cd59fb2b2bf32ebd1b190766f8836fc828cab178cebd25b336e4ebc4c6caa0ab9221fce953b76f978de94d4435c1ec7951bfd2c0d0e7760c2683efffcccff6efe927e58df8ab9fbd0e0ea54d0f78cfd0b9c5506b15a93c8af4e5fad32080a5e32fa8c7e968aa70b05decd83c5db05f4f5c7e5946a579b518c0efe3ffc5212255d469276188ff2602a1f9e03189b721035be439182ec2fc6ed44b1516ca6842ed2e10a50e7c29a39949dfe45c40b0e4694e69af806babdffcd8656029a78efb4e984bb3a374091b6c4556e29f45cb4bf696ae529358a701c70b467b22c9b308a4b73e84cade702b2cd57b3beeb561dfda2e1ee4913b38e20774cf9c8473b03f32a098db2c99a9670a1b184aceefb33d1b64e92223896d9de5605ac11f84662b6f51d27fff79d4f828e3d9d2a586b70faaf3a01c2657f069d57402664e173de701ffb57902652ae17ec08bbed32276ebe61948f844e7b14aceb6876c93442f76f99e8d548b57e672ff5ecd90371df83e878e4c4caa98ba52fbd4a0009a1d3bb9bb941cf86eb8d4ab6387647b5f51ec2086bc44afd99b0c4256695a1ecac9f06182f1702047adedfbbde22832ced96b961aec3143f4d40d8d5ac1342ba78093644f0ad8f999455b3419b396b1f9fa9f57fa8bc45b31f223b1812c6e03f5d071802624897b585f5f348800a5df8be8fe8160849c17f8b43dc290ed6c8a4b9aff08b55414eb139600911c0772c9f42409f12c99891b3d13cfaee2ae9737e1b38bf27acf656c85bbb816ab5aa65cccf02e81ef1b4300dbbd98f9bcb7502dd1ac81f8e21365f17e5d9fb7d3182a9f9f80962d7390311c794867bb065775bce1453c7f416d9fb705b354db4b1adcbc27211c42bb821f28a38af86ff446b097b54e30c1b26d76f4365017573e11ab8ad16ffe667be6685e0facb5272c02ba8c4260bff5ab9609240fbd36b62eb5ccc238bded81cb7f8c42e89e44c10d9f9b454e96f74b30ab31a656f22754a1bd0a3e442847f3883bbeabbf2c8fb496e8879bf8eea836e71541dc6ce229fc0602128695ebcc9a4c37a00138a3c7727e702e122b514c6b9553bfd0d33c746fbac605a9481db00275b5cdc30b14e49174e9ac9e950b6db3652493707b8b9305a59d50bf645ee91cc612ca4d77e7a63afa1528bf5b3e9fa5d82a25763074f442a36684a6e310d219ae6af2fa5d1749a87e682b32f87427b9e2da3f000914d1efe3ba1739c77922ee8a4498c4133f092f010a0b90ee0fabe5569b9a780c0ad1279ee30d55d15b04952ea68aa5451fd5aac43a04bad653aee4f4133df5954fa6d457595cb5baadc440c9ed458692f6b70dddf4b0a381a97b5c78a210fb978e5c4af3cf68bb14a3fb5c2dc58f1676755e7eb12638992abf160a95711bd22f8a5b923c5802edb1ceca868e5c8d86d22f162c2ce91907a2cbbb47798b29c5969787a5615166438a3543170892831992dc8c68b068459459a1bbad989ce72acfaf4a0b64726dd954bef0efb2b17a1e397228081237fd8f14094bdb0519aa0abb109a1818905b3435e6b832be01633d1b7b4c7f82d801fae1cc222c105449b0147cc55138d6ab8fe22e95b4117da8ddad0336c3071cbbb197e3b5ba14fc7fe8a29dc931a6b3322a30c168b5c1dbac9c28544959890ed731c1d3ef500862bb93c23aca442b19a9e033c7b67b987834de5fbfeb274ac56f87b73553836d7b0ed106e654490c86197119922cec93edaad2e2bb80728221565e06c32762015fdefd573e183811a8a298da81d0b2953555171a0b739bfcf7e86a6f41812e2a718dd74fefb99aeb4bd5282b219ee59f1603a7b257524ebb35ca2bf625ed2846ce764f6a29e4377f7b5c577d6ebadd9c41669f7542cc41080430bc71858699b2f045baddbdbaa740057b64a743a5dd826c3a914c236aef7a52ec9bde3b2807f5d5cb9fff25bc136755996f617c850369c6d42ea74ba68a665f895124efec5e1c13ad8b3bceb7a775bea9da9e36d6388a5c5b293b3fe5364b05fbd125d7c1f308881826b70d72283e1cc94246ee2663234dc14b54a91cf28f672941f4d48f690825d205dc47d6e34bb7f91aa2e5eaf1b4306c2e95666d45e991bfc93501454f192ebe92963a165b1ad00aa4d960883bc9b1d686156d492218dd28c8cf8ac358380b9931de41abd60067c3d6e3f68aa85660b7539506a3ab302f41230484c28c9e687a6cb35641159b6a35c1bbe983944c2eae7aae5d5eb45c52341b11e776270d3fe9b4286cdf9d14cb5e8dbd8ac17008f7546c5e0a4bab18962079c3d7a5647c3573f3a24133ca644634e857cdeb52a50e78eab4fb90ec8260376821479d6662f89e0806ac769361932c1284befefccec3d5463c11eb76efe9be6871cc5872398e11168cb782ead9a7bf53301bdeb76b174d1c943a058de814b46d89351d880736f34b61bbaef32a472177a83aa4a6063c5ebb97e4283fcf792aac82fc92f4e2047f399d23c7b4d061edb5154a9ddebbf89f7730711b142385df208da52417bf531cc22dbfc3acec4484a6bc0f91f6251b160f2fa67ec9633b21b73be80dda37eedf5babf595f2871d32e97fa44a97854af16bf12cd3e6e19ed8d2e5db4ba1d386494fbd6b4c61a0115ec50bc40bf0567030b68c9131a24ad94aeb6ea8a1f77eb3c2751adcf3fcacfd4408a97770e385faafb662befbce627536a014f53558cc5a725a489ea2a7c9124569bdd1ea3877cd32d1a9262fa329ac2065c394f3ad90f81dafde96c36e98dfc752f42649df23bc85a3933af1e070fa7a8a00689808e876f49815d1cc835abd5ca7c43df29ba8c0fae59b40a643a1df36e042ce8f2c143e348b2cc3de786ab6f9bee4343035fb68deb00a3befd02d3f64a0d54a2f6c60360ade73502d272d10eb00db6a02788358d3c7d4aa69498bca2e6fc52e4f8f69a81215afc82affb5058aca5d840880589e969d075167648091b050429f5566098a7b6cebcdb7d2b234dbb4ae80235a7ba13c8568401481e58b30e0ef319e17e19a522fd8cf8c450e72977e48bcf74dc9cc36e3449b65ded1154ddf16d9f5472556346775e8560cf1599612c85015985fb62d18987d278439a63b1feaae987f254c1aaf67e5400012b277d4b160fe4a24a5920ba2873848ae5ef24e13776f639dd4093f6a5ccfcff8191b29fde4f932f95582a2e9f05121b154bb9e84f5ea8caba5933557e94975fc4d690b227c1ce10fa6f74183fb9ab2ed9c9fe49333938f3b2534b900d6b310ac6a6b71d1237b920c4904aa2740c8b7e0c65da1af4f0d238df4d1b163bef683362f13f0789f2c1f08058b22d4acb95890e02b5d27e458b8057599a47d23278d7ca89117c53829e093c2cd7afe9238732ecda4ac857e02fc5b03ae5c9bc600756256cac82ecb03aaca92fd90ff59af3a6865c4964f6e2c30d7a8204ed8031ef0c8d4b15f553eafc817c6e793d6443d72958e99ee709d6f1098a38e771214609d0e4e163ce201e3cd4a38e0fd10289b25b57b91155941d60ccddec52564f070c42d02c1c4b3f369b55a7aaa9782d2a58121965b93f775d8c32956396e751617d34dc03b7a6c2bbbfdd9d50eabda56b0a35a7a881500f64b5339176c69b942039989f5727af89a061f9f6b3edef26598a4a7e641858982ae01c1e79f4e8077aad783d7eeef6a81e468d26ff891b2be6f963fb21ebe85cbb26adf1c9a003fa3bbc93e8c87a281f0ba1a62fe4b9e6ca6896f4dff7e0392520e13beb66e9df72930765c6797798dbe524d67db8f87e125ea6a50008f34175c188f9b4ab4524f3db8cd810262f932f1a826848851ce8c202611790a7d077388eff7bfcc669191b39d7d7c7b37f6704c5f5501b89363e1cf76645d28e16bd3777fbb8f865fb6584823dba5856bd176a5f0b7799d840f12366bef32721f27694cf777886c51d8269fd0071e75d1366ecc2e95fe95336e483fc98adaf2dc603213f7acc2c7cdbdded2ef56778aeeef8f23ce788fc2b85fed71a7f94e4eb0a438e023d2f757d4442822899730f14ea39bbd3a8ace1578026c89ba93690451e34186eaafe9cd20af7e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
