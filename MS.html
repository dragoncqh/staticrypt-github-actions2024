<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3e0d1c7357c118ee8e588e9e6c6c7da389206585c9c13d8b88f59a0a841b214dc7bad35d4f502a604cbd3b05b90b46b53349948829f45d013c8c3f555a0736c9169a013c26f916955c209c31a911fcd4d03112249f413be4407b405727c4fdf9f8ace067f020f8bc52030cb9e62ca148cd23d5493cbf8670d837bd241fcad5f6d9665fbae414f2d4516f224f23b0b8e2b86e790413f50675fb77e5911988d50b951b4c3f3ab21abc800d7d356090bb33649da59004b84f0889ca8f4bc1e6dd87d002e10d6b06bc45cff575094701246228b97895f9e330458ae9cfb4b082aef218fe5368ff4d74eec4bfcc24b4e9861aa8c2aeb5f0800645a80f5d477c4c5e7e210b55ae267b082ea9cb5722a906050b98e6bb2ad09e48184e8e1af7927b049eb1a5269ac42827c636ebf8bf0d5f3eeeb73ad54c1817d983f17a289290660bb71dc9075aab42d9f8bcadd8479bac8cc971b8e79e06522bbc43aecba68907f33e8f9f9cacf5f9fdfc6857a8aed5c748682647b9091827e4e5366d5fb9b9c0b2057670bb05a3760a2058e6c1befd3a493f86cc740d50cac3a389ad2f9e0eb037621c9195689b918b77dd99f5941c16c4942eb728388b5ec8a0282597ea7741b56522ea40efadeadf8d29b53796df948e86a112d2d3275eacd1af7c89795a0581064f6485b08fcf51646c1ad6469dcda0554273eccc9851192baeaece92c53b3eae868e9abf4e72a30bc1ab3578cb182ded1bf3ba004c1ff7a0b6b1a5d4446d6ed09f54ae41fc02ff326154a994d3ea283fd98b24207236c1f0e5ae3cde9c954264cabc4530c25e372dff36217e7cb77172c04cee6d75d8ac38404429669a32c20714e7205e2fe2c853818411cdb9c2b181b47160fd07bf59e2b94404c75aa67c43db9e3d3bd26dcb25a0e8c6d1d74cfa440e2a4023322aae8491c3b3dc8dfbf90fc1c1c909de24ad8936c189258c96b9394ba190cbfec59fb85a2ad3fc4ea212e54095a5fc06f916807187c1c99dd8ea75cd14985bad8a1ac56580e9652fdac0852bb013e579524b27a54096759ca43bfcf129bc5bc1e801d8db4e623c85142cf1edae5dea7f4d87b34c10d1b40344b31342c2c0674375bafd77db92d3deed0f1b4a6ad7a4a8873b03d56be6d48705c02e215cc81391f1b797abd8af050823bdcfbfffb0a74155038a214e4c640f7880414902939f4acae33837af12aadc0f92cc04d316b3d7689a10e365d18991777f488f87956de2232242c81ce2a34d2dab3c7aa3541fd76ff7cfcf5d3cdf32f6862f43c44562f051b39a71553f82797971815a6f324ef32ac5f207436fc0d1a311040cdc0685003d3111ad277767be5cd6f8b8405b32e9865cda7bc0e41680b32a113429290f4d47804e6caec850ecf210187bc077b3e34a7cddcb0e593c17c9185df02de1fe17523d60f805adefa2554e1e8b1607a4a4adc78de4e5cdeef59b0cf66c62ed6c4ccd09c7ab7c87c3bd8a7d7cd81438f357db772264390562a309903b8d8c0dfa4d45440d4c5df43fc67ccf630f36a51122efa302b2eb376a2394e48506eb7c8412c1fa683eeefb30856f66896621a7315a47e294a0a51e94a971e35a824725fefd70efa1282e3b702a3589d6e82041be0c7e953d646176347a9c28786ce8f641dc7d6118ecdf65ada9cdffc8069f18f6819a19354a75a97473e7c94e4ea6644a05fbd7b91bf20fc9c00f0f2b47890f035683d4a0e10cbb57caac21622c82aa0a7a3afb5ae6ff809d25c7dd9267085ecc6ed85cf014d5456f2d38f1ec089692e172133ec3cb044e44cadee1fb0834364c3510df88a6fc66f2ddd9f3398a8386581f4632449d6b4042bbcf4276b2506af980338a1941e3bd66cc85491ae915c45d47bf556867d52cc88146d963da7c7b9e61e7e0f7ce9b8f8bc3c0f16ec9124c8270abe286e928b366cfb4d893e0df2db269fbbacb00517159d55cdf28ab5b9309d1d239237442824b02319f70e26fb2575c75707ddf7c59923d17b67956f576955322630dc3d0698f5147ba7c55e012600392890031449a768996e1c64ebd113143eb6fcbfa34d088077067164b21bbf9dc33f6e3c78255c0d043c043707c9280044d14ea5a5fa4603c56d5a6883ef7152e62b5eb8317392b1253fd27a7543bb8e1e88bf74cb659320cab36eb1f82f0c1dd165fa124015d381fd7184780229bfc203a51fc7d90b6cccdbe70b9b545a8b51dd711c00343a175056a2bd8798421dc81c2ce1b7585ed45de07aae6cb2c8af73416ebf93e19a8f32dc723ac51a8cb86bc6e919f99a7dab5d0a958b3735a6f4244b5c6aafb77b1f08b5f8897ee75931280b0ee4f91db923e89b59678bd8282f8e91fd69d715e3ea882ef6c57b4e41f8644f8bec38ef71efab79ac77ef4a83e5979f6a2f6eb99519d1ec371993586f312077f1acf8be8e0daacaf8aeffa0b2d9cfa800aa0fb898a45babf22dd0541d80907dd06db1dd4cc601ad68bba0f5fbcffa73d6b24581f7ac7faff528afdbf14747c76ba06fc109139896a301458f7cc0558dbbc6272351b56102659ef78ffd81163a10b126596c00565ed76c55342f6e41a197e7165f803e8fcf8aaa040f79bb2d98bcc030c3800399e3f46079ae354e665c113fba1de6183fa517e2a1ff630d5a53fac0246c9f60e534341e3342ed788edbfb747d9e42535c1337d54f732723028633486ccc00cb662b46f633b278db63455fc9498a2379bd81c2e5566ced9ac7d40efca2a92fcf343ea2e53eb8f3f93ac61fd19f14939baa9985347f98663d17670ebaad3544904435ddb46e2b63e4f7b3efd3f6de6f6b98af4b516aeb86176484ebac752c856e26f8f42451fe8cde9fa95dba1e6db2d4e986d316db986f5595352f2def7b2a63891249dd900387d52092ac1a8d107ed9eaba03b7f7ebea4c44f9dc1a2c8a3ed47d70c6e4c3441e85b8f0f1bdb48677e7027ca60b1f85b03372a6ae0f8d50126d67d432b6c01535b7ec8996a135b75375ecbd5d7ddd5e09c80d24686634b50d6d424df4c6b97dc5b2fe65b3becc6b65ed2407dd96ff5d792d7bd6b75e710f5ed74741b10aa7fe858c240c7e3952505ebc74911d98ed61d949fca32d220f90ec27716a38ce00574e794fc65d3751f974f0a3277349d551c6c827db9ad64f0d83cdde01b0e7211baad8dea8176a111076aae6fe16547cb028df8734d1e64b7e9cab6e0ca1666694b176adda3ac1af36007674cbf21b8713cbdbe2eb8bb0ba507c837085eff9feb3b0698e3c39a587876a622992d15bef25a783c6ff051bd90e7b50aa72967c003d0c0b10043dd3bdf24d55b533e98058217c7a65283037ac409eb4abf2f1ad0b3d6a01a4090509aaf01160d6f518f60f72e0f72415c8afc85ded145113af1b708e005f53f7be21dec543375589ff0157d65bc1916726698ca978563a7dec703e7d7f695d97280fe15d89e9db9848611ac0b023f32c3f8e21636176134f97c4515df989ca2a1359b8b07f49ac9c85d992b56a7ec59d8ce9293d71066865ce7585420bdad5d4e433469e13446b2920367b94d5e5cf16047f3b3c09e43823350b53da260f51ef851c5a73efd9c3e3f7ce964007e76da0fb881231f792675576ab31822b6e18cb390da75323b8ced147f90778f1fd043cc86d2000bfdd098f33aaf468cff49a20a6207aa401d6bba44b98c853e6e2555961b659fddbf092ee55856a759829c0685c6a14e3e53a94194ca2a12edff6cf3596e18d8417e357b318c7c179c8d1cf65594f3cf86a5fee3b7b23624500cb5eee6e500c5f12ea96791b64703ccbd6e28a0b3d9b1b4184f4321369533d3d00e821cc0112e22556cf8010de1f912ace2add7c1a49a93438e989e5c1e0412bcd725a9ba9ebd9aa8a5bd97851c587cd4213bc9dc043b86162932d122ea2678c654c3c5c27ce5261f316bf63872b48e009b262473e0dbfa3b1541a07565866ec53e635e459dd87488a719ff9dc547b80af9b440fa91d50b1c496933a4d7f13cbb03a05babdd91a275e321c8644b3e7445b7380e68149c1b4b16e6fd0075848719c1735a2aa64beb2f93ab8d6be611423882f1dfc31f71d9e235ef4504e2c57dbca16b3baef449e6d52971caed98c22a9a80aea46c94a45bf0b018bfcdb5dd839a246399910e22671a58876d109e3eda6a28f1a25dda35e7a5be8cb06632edd73b58b071404a834a75e3407f77aa87fc2e67ad329620d6486eec63dea8dd94e1c8d90140aad42b68823836b3c21aa93086aa842b421b63c726e1cc71a6ba97706e33bd18e833d70ee3cb88c757d60fae0e4176da07ccc9323871a52e8a123f69845bc549b71800e979ca728c2b4376528e45aa7d61bf95e3118af88477633f0d8ca45253481c436c195cc370b974c626c3014f52bfa88b38b35a42f273a067de3948ac8810c21ca7f350a22424a4cc917975f1883a8b772ce1afc343b73545dbd027704e5f883780c2fefd4600091bfaa4c86bd60df7bbbd989c212e24a055e220f30050d69f1e32476681a06caf17a2ecf6a40225d6684c8cdb3f8426d9dd212809bf421fe8043fcfe9615b541fc1c8e8289cee7fc0745d50fd469dc930bfcee3592b5ee81493b69066bfe45fceb94e78f9eebc1dc9c026a9464634c37e7d0721bedff0a175a3572c70622dd54b359b863827d61c5dbc8d9a549e1f809046b0de41d948ceec8269f7f8292b337f870fc9fba1fde0e7117dfb288edba9ccdbb9db31965c7df802b7037718aab8c52d719bc0faf8bdc9aa0b0e0f7f5e0966fb5c7256171ab7b2366869a55269091b05851b16489ae00f20ed8a63507b57da4087983247573c4e56c712b50a046615c1ee8636faaac80e6a460e8f985020a90aa6ffe70ec5599a201cb25d3f2e33b3be5a3ecacc5168e4e8aec0a838aaa3cdfd930ac253f054436f3279214addc36cb9335b4559cb3cac9fbbe6effc997db6649de6e4462803742eae4313cdd8145eab73ec1cea45e6cc3902a66e8a873118def3c50be82011add040d875ecc02915c5336e2580649c78058fd3758ddd1f56eb770ce6d15bbe2aac4f8e84ab11e6b7de87b3f526ec5e3abbd2245a2179f300dc8924d30a65ce27bec70d2ce479e3ceddf340288e16825cf72c582b620f00c079c7e15b430dd0f9eaa2487580469ad878cbc62f798ca2616d5c304e286946b4a2756804ec06811d83704b188832bb3ad6a1a9558c40ccb834e5bf840d030ac5180f4d0e3905a2ea32d0b06c7679c2385323371ea01b6383f42716daf6a2d58be4c9566088f15cd38329723c2ff7f855e93e82a5c6927a2233dd5f48e74da5af5400a37520b4c752fbc101d8542e3a460e114866c50c1b7f0969f174ab7cc024c27a2e10112ab31d0c6d3e1355b6b7876c687b5c64f00edb91b4fbd5bfcc1c8932be62546f34e80138251998419d4b365e743ca9d8cc67023594b4e1ca0179dea6ac6713b5a31d5df23e72d5aa95adff79a91f83c8ad000b56c81d9aebe1ab7ecae99f0061e4825521a8db7662644e588d84db297ea2823c4c7b7765a2925930758c0380bd5d3ac4e8ae449c7d7b6789b3e20b7f1b0e7efd69c5636ad32e9a8dc2c331b3ac4a5373cde0aeabe5522b5f3e823fa9a2562c2385a3c9ae5bd457bf0ff3b12648077183e6a2d26d2efd3f987a819cb3cf369ab42bdb35afd29aaa11f44c6cbe528edb628bc3b4b4d78a5773edbd259b1837a00dd6d3ca61b82f3de9942c5152c32176765f129d6f5e550490abae0721339fb80311126bb42fc2f9f57675f8422af91df52e4e8e8c40b75a77e7db642f27ce78f332b744ce7241b913373e82f5ece77a8d86ffe4385c7b74f93f2757672d6150c92ac425da5fa94d139032b4d3c91f3ad7125e020e68e059a667c6a989799177128a92e08260a4617614783db705ace53407c69ea2aa1c3768ec3d8246fa0235fa91cbcc24008e21de2758281e3235ef162af543a4fd0d8c5537eda7cde48251bf89634a052c21994d29851568b05a571df024de8d82913268adae2570211fa2fb55b96ce9b10d156e4149496b1c8d999a02830c9aefeb3643ca994c0ad667718842da85e5b322663bc7dd9d2fb9a64542858574e1b1fd86356c8904c7ace92e1d51427efd572b568cae419ff09571f27097bf89ef53476765437b39a33d858100054596d9ca1eae5e1fcf48045639975e4794ed288c52a687fa900b3821ecde2b3329aa5f37533421ee421ba6a523a8878fc17e63ffc0f678e393eb58e128c25f0de1a83caa3b6f56c833f32d64f104eff78e9b5c53c2dc55e8f9705b71018c0379b692bd715fc8d15ff27a255f37b9a70bd6143a22e5d81cbe0c142be02c3dccc557faf7cbf140cb26f2cdade1e68e38dbf7ba9a61450227f8595846d36bb26a18c71a8e3903c88019db5e74b9ea48fe5986fd48fb5571862c5604649f11a179dc6c0ff03aab2a922bd267a915065e8cd1e9f64b443fba32be2c43ba748c3f4fe7073b3617f749bed2ed7c311d283c88806686779ef8fc0701b4c86917031b65fc348624b66c9593356d331d3b92c8c3a0a10d199735dd596a40cce1ddeb1d24e4751f15d307a20d437da5666298365df1d369f8938018106561f9f451aa3baf869a5e099ec6db07e31c608fa31ff5d058599a6008faba3cbb23ff3e7978928bd2fdc990f60ad6c151e1e31e870fc6fdea2e55fc07f7c7aa4a48457cf5b3fb293d83f193b7278742496706a066d32b1823cd922014c742249a7722f337f642109146a3056de6ec78c7c0abfc2a60a11b446aeeaa8dbeb27254a2e5f8c787604655b2b11ea7c90c3eb42ae91e69ec2b4bcefae4f46927ca92e286b545cd4888c78ab0b54c8e19e33f4290618760bd07c7c24050073f6f7d396dccbc8f65fd7c99b710d2e0bc3d018eeb0326a8fa3a43d3fad33be233b4dc9078adb6d4d85587d88a53a198668fa21b0062f466ab33ebe9627ec17eb62b389b27f7b1b5ca5e5e947ec4b38005023b70472b2b6bec8cf28c7d64d7087d6f66d8f609b16bf6421203dfcbd07ea277435b2c887d0c16d03a0a191b829b724df00e89150c794c6076bd10779fd16a356de5c7f8d98eccfaacbf0165843b4ee8cfffcd6b47ba88f0717f79cb9af9af6965b5731bc6874744c54d7394e9e824357aa89a0b3ee1ac34fb6c1fd79eb60d759f58c801feba4d1d30054bf1f55d829da4d9710afb37aa2f7ef4f2a30367d0ad99c47e16e2172f345375a56c8796612e4be898366323d233433b923a5ce0a1687c4f0aa34d6a8e7a6de39796af76e13dd0665c237ae03e9827d61f963f9cc1754ab7460437ba5b29d88783735045d4aeb91c2bbe255e38807c833160f1595c599991614568eaec5589aebd546f7a067351e565a000c2d0eec6b9c61b79e0fe02f4841af5c42dcd2e3b7e2870112c4691120feb7c6e74a8d9558d7976be866aae8c1b275a96916539219a21019a9cb403662cd32ef17b6f6ce1fe3ee7391df1a4ebcf615f4385130fa6af13345821f8996a835e41cddcd1d5ff2948bb05a57b00c5b64faa0e442e365e2f0173594679ff6b53b75b37fd21492aa7a6339a1625bca930c488b73a7f424c78e94247e941e4b6261f0f667804af501907d9009505a8f67dc50849ace0ecd3ee2127df119dd8656f2e6ce77a863038bf932b94075ecbd6640483eeb697b551a0c4e1766f658093ba8f5d6b055bac99b2b79ddd5c95ea0644cc4dc77afd0329d09d84b8ad30dcf5eb20458ad68d8e66d7ab6ecab3ca1525167cf6df2dbdc1af8ee9e57aba09af1bea3e9c12b05daf13b7ac0ca038defc79d190a9ad90ed1d2d57e9897faec19ed22eb2aabff30b659ff45eca9a1232b625cdad8b099518f55745e41daf3061fa9b4acd05b53333989a340d745e02b0bd27e423b4e226600e82efd282aa9d8a5537e035ab9659b390e0fe9ac84d2019e37ff0091c25d1f0156f23a6d8f1828b1e8e19adb26356a95c9b7dd1ffe6bce0a097aebdcb444cbab9cd0777c479705c1c4c84af011148e488f82e4f1e537f762dfeb0f713ab735b77aaf54f650c9789f216b4f6a2abdb58d7aa22c074cdf873388be880f16dcdc0efe7c02d44809be76aacad100d650e9d5371cf390b7fa29032bef269605127a837d7453b96d1897e0d774a47357fd5c96ca4e81898eb22f3bb4962ebe491128d5bf0824c0509ef84962c5b67887da30773fc449c246742b7e4dad1ae7b3695189572f5f640b6d86f726027b38b02bf86ac7174d09b3ebbe3c8b6aa15bfeadcfbcdc5c803312d4b5e7512f0ef24ca7c328dffd44d36b9477cf5bcb616be3e616ab362f1a0157f43d04089e88ce064cd3ffe93ddaa1ba21b38623053b00b571eed5c89225e7711bcc90703637b9c4efb8fe74a7c06afcc153a85fb79fec7638adf78d7b9746502142fdbe0af0d93ad94c3df1b8dd088f9344804316b5690ec24349e6c0b3b6ffb9640f234b24f39c33b5e82df152727b3099f2c6cd9b1ebc881ceaba06bbd31cf93785080f58433e76a8d530ea547a5030535d97f21f4f3653446c2c1720c5d16668980ebd5cb95f1af59a49fc5813f95f915688690aa0e9cf5f946ad94180217b0f40d46d9aa66b5fd99b44abb8030441b8c975332a6ded29ba7262a44c732be6e340ae8c0fb82dfd0f8bdd0709c2f09cbdfe49bb0c997154b9db71db6d09b908b3a535e9babac7e2156fe467876edebf4a2363b4bda7f000e66127a52bde1a44e103a1e04d96c7f364e71e1f406c45140698d8e853e5cf7db5b7909a9081719da1853ff47d8b37e9bdd9df74cbadc5bb718281393512ead8feee465e1040fce7104e1706ac355a48b85708fb95efd4a1719bbe76ca9849cabdad799ce95e23e70d559f3ca09935bbd15260b34ab4c0c22251b3cec0ccb8037f05a19c83155877c8ba7bcb347d78948cf8a9be6635f4645c7c824a0093125048b4656dcacd433101aed2f4866015d850d01db926ce7a328db928baf9b8b73a84b224ece45ef765d6b03327bcf587df2235e07fa3fa28d8243c47560dd5998c7141a643f677a173112b20b138f1e66afc68f43888292e2832cad094ad45d35343b5c17e9386bf20f93a7e0caa1427fd357da089bebda6b098a947c7b566bb7226dea2426ae79f819045a0c57b2ab67d4d528e5fe1a5d1cf089c1b5f6889228819a2755a54cc16b2db7523cf36dc469445183c6d3c11e8a506f27a084369914da23982e59a2f170c580206dffba5bcd997284dfd020f960edeb51760ed0b3882b9978f916f94047e6ff050297e9e5bcc1038b76037bba430cf4835b328cc1db5a3fccbf1f2d622b6646a885d7932c0b6dec3e14dbe9d07e249fa3553d9fc50f7d868b8720c3afdb506f11711235d7620ed371a4291af4bbb9abe00cd520ff127c2d3b55dd6e30c6f94683fd7f64d26e9b413a703cd3322a9846701acf8f4d7c3bf515d6cdab285dab70e9841d3bfbbce65d157720d4a12aff5237e38dd87492dbcdcfdff77aa2363cbd1ee7fcf7e6cc1a995ffde59726e56732737f19e0a8e0075583342a3e937557d220e1d8beb91a4a9c64268a2b431a2cf22d6beb82493f7097bed501a01576567a636d253f02b27a3d486fc9ebcd485fd69deaef93c3ce4f5213b9bb9793264d9e1407cfc6aacf2ffe75939727360864c4476c946089c4e2bf7bb4036e469cb9c6f4f58c33a9c3742264efebc2cb515ddb5111196652e731fe3077cd2d89d1489f5e5b554c5498ec6465cb0b246cb6abdc7b9c986f492b81875e850b3f8e6417ed8ad3be733cd8af9ae50fb4d13729be232f892e78e4e8f9847a1a3024ae9bedbf1a08d582449a1c7c30fb4bd3a022aae225ece010faa3d3ad95ff18fe56d79605686c8b238ffa0fd446a79ac823e0d468fe7014d425142fa53dda74ee19fac05a410b563ba8132defc3dd7780a9a8ac250aae4f981cbca8b8f51d117c879afbe88faaee69b79f6a931be70e849e3549bf8c76fcc0a9975349bc73bdaac60620159b391a3215c374d7f95564dd295d57e0f1e10b1c2e68f6cffc8c291450c28aee0cc01c1c7fbd036fcb8d6475953b0f38013abcf32ed901ee0ce769b85138e1a2a7bfa1d923fa8e2a5e2d057cc99915f382a2a336fa775e94d89cd0bea39ea0a38c45da80581ae11d4a70158a33ffc60fefcc8dc2c36fb8b3be6ddf1b4d5be52b7bc91aa5f33d672af3d736a85c3875aa7bf6f3218405c3e5128f2605e8327acb33f5f977393db92f3c9474cfa21f8577381c9186d349321d513e69d9c1544b1bf9247b958f184d4ccb12d1ccff790518160174a0577aaed95e974e65e43e964aac25b05381f40202c5351d9165967641bf4c0b6fbbe9e8d791ee5041862389f0aa112a1ce58a54d4dcbd67d61ba4280fc4099f0fb138ec76a72b56bc8c783eb12269ee7b13a83932420c58611d4c78f6694c686b6919fa4de681bec0e4f7406e5fff9f9c745f902e72bded3c21861d7165ff608c6edcfb9a360823971dcf12ba36b024a998a620a6e205edbb2bd278ae2737d7e241daae94f1e01e2c4dea9b2d7cdc5e454d276aaab4ce39c45b12af7c1ba70150a859707ba379fae756ae608613b213382863ab7706d0aa1ec9c695f6e5716","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
