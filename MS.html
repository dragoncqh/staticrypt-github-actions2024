<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37593905dab9945263f144fe65cd163d4c2a67acdf1f0c98f99e26637320b56193a220404654f2a6307b6602d1df22b270b06805a96bd82a1d3be15a73ad4439e078a021b17d62b4f4fb45b922e9cd141a5f739443915115853264b51b3d6ef762688637414b5659266343ef1173e282b391e48785a7dd8df6cdf74cbcabe3753b7388404712700d20a162ec429e202c0a8f605c160b0022600c766ad151614d61d7ddf2f0f5465919db7c90cd20c936355e1aae960ac900b95390c365e68f6aecb775a4c056504912786f99184bf074d0baad88db210c810313ec6f83dab27388d2ea132fb05116d1d84435228ca005fb3319d0b8526fa1f5da79de5447b3b47a71a19663949f098dad82251857c85bf3d6ed86fdbd3cc1df031e34e8b0d2d8e313019a6fef306b35aefdaab2328ecaf6efb56466834ad1b7e24de00c371666d90ec8fe8103ad1185995759ce7abf431a0d6dbc23533950fbcc935f9d4a21d7a2ca64caa9c08048b4044fec0ee4c1fe7294d7fe9a41c4a763367ff403be6e0f60412f17d3f4dfdfa408ac7ea62fafaac8d15b857414d1a412626b26b642f939e903baab2f4f915fe085d4128011354c88e8925a800bcf0957d8e4f3ec51e062666aa3646c558d7477c72290d5dc1b2b3eb25679119e417d429ff6605480ca1e8fc13a9ca89f478b37177147ae18975364dae74153dc9157df985a0f2a6e3875fef9bc5c95ad70e19f59f6c97bfc15ab095f32a0d2b27e5577cc36b3c24f85bd5f2764905aab40e06bfa2e18153996d5d24a7ada3fd2b907b5e42912c02eaaf646115bb2514016d5a7b7a86fc1b3d7480d3bbc665ca1b126f42714019f6412bf5eadb796e53d9c5e57ea0b9e48406972724b2f9f517c374ef3f5c79d77e6e3ed9daa5a8db08605f31f781ee248b5da80de47bb8c0fb7ad5e793c815c53e6660e9807b7331e7954142c0de2b68fce685609bbfa08dcf6f36ebf65e978ecc9fad4c6d5b1a5c26c03b586f2f80a6254b4fe99d9cb6b23d3e12e92fb79531005b48ff78f3d305352d1975e94444d9d30ef870bf675c70975030e6ef0f1b98666c0ca3d717edd85e94ce32aebeca24e43d880388fbeb01d8869695dda525d3be90cf8d08a8c69041e18b2bbcca8cb372c8aa7ffb3354980e090d5e81fcda520dc8136599f563e9ddb969907fbeec8dd20f29cd32a7a395f976215ab1b8523d3c5b670ed20a10bb0944668047d0e09cb8dd606a57a8ed740f640db22993793297800add70af08f0e91b13f9f59cd95f6fa26f5d619725d7ac4fc08351196adbeb6f4490129f816074f7c9ae38dfbc11ff53d046a7d11733f1a4956bbcd1eb1eeab0142f0f157e2d45ef5c9a0039cbf000e751a1edcedff3636972ce08208b3730d49c453dc8d136c3005eb60599ba41d540f440b1602bcb6029344ab4711b928b759f2860696daec06acec937c5907564e5331df97a80817f028a79bbf1fb2b7e4ead1fe9b272fcef4063af79393237006ea90efd9849b64e5ded4e5badd16592d2ee6d482dd9eac4cbc24c9bf289fea23e3f52fea591c9240b91c6dca1f42bd33feeba22de2bdf627afd316fc23f2a0602387abcb04e1857f870905916d532e961e463107ce3854f1d986500e46da89584ef626152bfbe80b47af1aecdb1f0dad7b113b29228b3f61bc2783ae40f2d4b70c29ddab82d42d4cf13c6012b4ece178fda44e82974a98d975c5a5893ba39eb3d51ebc4fd57805c18ed72380c9370e32a5b3dd7af1bd26e3728d9c998646d3a2c44be60996b44539bb8e104a5c3c433cc65efed7f489e9ab92d9f8c0ceed1b3f0f8dc576127e0ff910757811a13101e933d8596b52129803da0ae5cc08500c170818397e2c036f560ad284a6debf50f9cc04a7680ae61d5de758873f13c9b2a4f3798784794aada62d9fe1b3434c580b37d0ecb805ece6513daa10fb03aa6c9adcd02543f2ae58850e2f4c8e6b74eeff3a9cc2b8fd84e566c4169519a67563a948865400a3ebe58f65e4ef4f2f62539406d245853912f092aadbecd8729d6ec3713fe08994424a71b292c857ee9baad7db6cd68c47f733a0bd1a7c3bd138194889a4d9a0a88c531820c01e7c710e1c9334e67b58297183102a08a5a67f189cf9a13bcd5db423e9221b145bdeff5771b6224db26e1a279e2680ac311ef5ef12a69c475ed15cad8ec0c6ffca858bebfbb03e8278f5150b3b313acd05323488b03476c546ca369d8e0d50094bd10fd39e0ead3fa655f81fce068a613352c9d42ad7790105b35e83e76e25694dcd46b94ecd5c68ab6eacce2a8c29a8395cafc80a96e0b146102d506e9a92a8a0940567ca2b9921cf9bda532481943694c755c922b4b56c89c13a6b5048cdd76b00b15d591ff59aff13c476ddabb906e05b2022e82c87c63d5d2ab8dac0e55c34afdd3f3c7d4599f1ad33fbf5eeb27390da60c3b26df1bda1e25c685e40fa5fd99b0e35f09b1d6842e07c9ab159049a14ea81b112cafc57d09405be5ec1264131ecdcd360649a328056c30a000aed19cc2382d735f39013c940c445196e202118f410ab733dd323cc50a70989134a923635b9838dcd62c235186f06b2627b13c9dd6c9ef402efe59d3d076e1294ce3efc6deba5297324b3f57ff67bde0818a0f8d1e54e53d5a913ea0f62e5c13e40dbf5a6f130deee36c06e0e9d6d42533e38acab84e980db3104ca4808801222a3c5028e57c90fe4e175bb0eb0776d044ad12ef0eb1cb2354492cae78bb495f8ce11f17b9f3561266fac3b44cbffb2735389ee77e20f3b0bd5d5e5268836f27228d4cad5741ca6d663014086a30434b2f3da41c8db670d81bc54a4c3bad7b59c8fc52d61b66a3fd0c12ab52647c74812c66036984f44b74c5538640ad8d1b3618440780cda80bc6f558636a5e5f23d765337229a9fedf5459db1b7ca073021f14d01b241c23f07bb483ff6e3a7fb063d0010a1ec0eee1869ca11302185967187040b73a0229b04062cfbb8a150fed5ccd199e3edf98a49da796ca26f6721b4e41e2af92a579c130b9e29135d735e59620feb40603cb8476b52465b4b7059c02614f0847a3296c7ca55fe079e082a116856a6fe57c1dc7ab0f98dec797decb5fbdd23cee0b7fbbc6afbfabf5bb14444f6498a88680d6753f86629a0af0fc36f3ab0aa0e3e998104fd0d9f9995c5d4b843563873ae462ec97eafa499370c885928ee80495605745f959e2d36670f03f33d93f837c6b4386b946b34350cff1c538afb22a260b742dbe664c79fec7eaf4abb50731ea2baa634f0dde51388c4cffd0b12e169e8a5c56eb74f65c68d7b443eb648ea1e79c5f9fa097631647be253883fab449df414bc0dcbcbd68786a9f98627c08a9b8b43cedbc59876f14ce7e05f9844a30e8ab39d54e12c88fbe9c2c5009d848a620114d80606bd041b15ef485ad50419e30cf0a8db1f7d2c1f9d434a7934b18bb0c53c2d5e26ac33b7954cc9c51ac3072ca6451237b78987fa2060ed0b6450129876d301eb76720ddf7ce6a908ab584fcf2fb1f31fa8b75b3077ff23b3cb377eed9d9f7b75147abe119d7beca87f7245650cc058d4eeb30dfb95ffbcf291ebcd28adb52674edf367a222d82b6720c541e1e2011b50530befd6939ba4a5964d4cd03af41a4dc91964be22a6bb12fe9089f4c89858b65d64f9c231646d0b852e031e7e031a88def3e6ec6ab8cd9105fb9c7faa334e5eb7e67c72d645a32c067af07c0abcc8c04d55fcc4398b9a657503dc2641821196172fc9facd5f6f97ac19c2e9a1899e37c429b9284a80dbfff2c64cd1a9fdbae6a65cab99ec6babf24a90a750700238d87763855d60ab65b2e6e3ca999b60c3219ebcb1640a55aa7bd5ef4d5669952af8e1db0f56101261892987477fa65629357e1fd1acfc612b37fe3327c2ab570453287f52b154f9453b5b6f3b5e464a5a5a5bba3274b2c6f798e865e796f32033eca778b2523411ab50b3314a498964e51d60ad53c55a6e24d7b4637aae7f5ad58f36782bd20ba73f4e3e94c2588e01428804d94e169f9a2afd105222f3f0f91c404c231cb4dcc41dfc204bb3fcaef2120232c761c783e11557060e6deb79e3ee7e333caad6a26d2126eab90d23e7778d8166d5dc7cac8e330230ca9a23ac8bdbe7d44e98560e31cba2398e10a930671147b62b8e4764cedfc7a3dc6f4684b8d269e5f590ce462ef324db6f61945245d52e0464b1ebe0bafea736d0a10f7ca9708784142c8a9b3354bce21cd37f5e564d0d5919dac71148d758dae4a01d35d5742c712972331e07c5499e87a8d73b53c3ce4d4df0a7727516734282c49fc6897bf2166dd43afc6f8d03f457a00f7498ccd3d6d434b7f5b7282a61b3a983009cd4bf0ba138752c1af723232e33e0e816a4333572755de094fb34312e91d59c1a2e182fa126eeceaacac71a5f4a3b3ef86d8b4e2533a94ed5a442bb400ff66b7a00842789f1b994451cdb6b3a661a18d6fcf6e4c6e947bb40587cedfd3c1b0a89075afd24215973dac1cc5894285690dcd13c8fe7211078bf492d07a5739736e0ea2aa6f120aab9113fa1388ec89dd637e56d03627336d2dc223193c3f25fdcaf67a2e6d634e4b6de4cde05d6194aa833fc04f9a28db2588bfc4994ac15042ddb9d7b9120538ff1711b7b8b5d298f60895c7c350e2d878956da2b42284e3780afe4ca0458f3f87371d39d5740444fe76d36fb74349e22a4c2f29fcb91dfdeac39fdf935f44a4d2555a23bd27b7dd69ad1fd8dafe1e83547bb69c4aeeacfc599f45e27e8685478ca4d9097a95cc85a45de2896ea3b89501f83dddf39751781b4d94d0520f74ecadf17464c44ba9ec5a974b9ce1297eee660f1bc5c8529a42df31cdffe5eb70d8287a211d5e51514eb9428fc61cfafa3e2470c8b51ac7367c544e262a23f0d75ad67d660b23540da7a60939251e76111547ca456a846fb7b35ac86dc0392b0485937ee8d6c6c4ba7fe498a48d2a7087b443c0e5c161acfa57c01e8453bef3f0f39dfebf759277faf1970fea9aa09d290b4cac42fb032bab92e617c94efb5231733f9029414a0ce90269755272baf487f37aa0b5670be4b0d2a2ae7c29c15016ad1f60687805c1ed13b0654672e6d5ed796aedf54d86bf8ad7de7689a721f333724d444c506a05a5b32465c38ca9dbb3f1ab09abcf98b79833066b7bf2fae8f5a83878115eeab81c096002247e0e103868d2585b4dbf6fa5e873ba872bb76a860ea4e58c728516ac0431f43426cfb8f612fb50ba327f06e4f459ecc29ac7c782add74cb396596749dacaf9d2c90e520173f99b351d0572af2d48214469a4175d9dae76cf2bfb8ed41d0bd5df4cebb53543a94e61d51f8b875b6d5d78e27f1a47d46f4ff6916f3d3715707bb70fbce0384f3f414bf282429b9ac84fed7b1a80519cc08231d44bb081b5c2c39a5c420e1d1170566071bbe7be7c11f6f74aa4038427c9c449786b5f166447c7cbc1630f74eda0e8c8bbb4ecca1b615ccc020ef812bc2c33e7f61e21764cc7f37da6048432386a720c97f1d4db2aa0b6ce5e2bcbd4d78c06130019966e4b5113d9b414ac0bcbf2f198077f61ab310471f51be021e02400bb28294477bbfdec230789c9c345a52371aa5795a122cb88c569a75eaa90e41a9f4ec06afc387244420e9e3c0f4c0fee2c5d798d94088d097c258c23096ea6688822e4e2bda7b9d7b2dcb671b8ef0a9cb758f1dccdd3ecd8a863a9cea1a19d6f0e2c810e91f7054ea7ec9d2fe6881ee66d86c765266a8c64864a67a71551b59a28d74b260b19a8a7f678b2998ab1acc363c4234be60935ffb490fb01dc802818bebdaf4fc3640853866993d5c94292176f271e6defe402ba51e5a61d45dbf4c46c524d883db5311539429e1b17a392605f284bab4000d20ccd0f8ac849d89e2d5a778c2c60b60516d31b4f997710a084eba0cfc732c72900996fc143ed59606a0741690b6e1e5e2c2dac42828d738ecee64716fdf486bae41bcd7a178411e351a854cd4d8fc94589c112a0839affe6bb9168080aa7900b000421d4aaf56c6ed7e13e5c49690e78dcd47741cd732fb01aeaf55f6429f7e5cbdca8e49d82f15e95bd5b26514eb1220a196f42a3effe1445eedfc99cb6e2d0e9e83c8e2653d913ebac74a6aaf35f149eb9d81c629c0fe69d0649b2413d0094b0233e4aff123a77fcb249856ca7130d33df8939ff3e3db1ba3659b9facd541772bc742340859ddb114b061bf90aab8c8cb1eb115fc00a8e7153335339c5b872a83f73fefbcbcdd70d6149183ce4e236228f630668ac55a8af9872e50af3e59b21a57e2f6f6c407c338fd0dcd4b4fa0551e7fbcad3e169aaacb816ea57f2a55aa891e0fb8de096c02dfd176c06e4eea5a5ffe010ba6776cbeeac895d56657e729a076ce1cb77f83bc464caf3009976326d6385c6c5d6211f4f68de3c7196ae2658a79c80fbce7c692adccfcde5fd385e81dab9be3dc52f9dfc5ab03fb2610e0328f851bcae47fab4a618194558082bf77026ccf1b5e42ac56a5b3f53fb3c380d9a7bb9a1becb6ebb9083a7e244e2199c973a1a05e75a5eaa7f19d18ac23f0faf4cbf76da240d0186ff526421a154bdf84d7387584abba1199f71d526abfaaf72bba6219e77bf61f9ad6ab52a555561f33d1b04af78f66d0a2beac6f6dd5d5018b3e9d866334c7da220504dc6dd785f4a1a9fd3efa2a94ce5c68ca142a5f285f5beef71f90b7ab414a53b264d0fc359d44397d6b3667f7ceae7dbb7aebb682c4d496b80f67e5b1e6be41038dd7bd81662af89a6a01709f0c74c45bd41e9ca543250895cb57addd4941e25696f9ab29cc45fcd227ec4d88222830bb6b7017c0647130561ac73496ef155ca8ccb08189ba507674f23af9a85404984b4f8aefb34b7fd807e4df363281673736d28903060079f4cf4f0c7a28a6ea7fb8d5147bc245c84fd9476c693e6e37874cd291630b2c71184ea55ae80bb2db67f7fd627dda5684da52d0cfb2255a732d03b3b900e276ac8a6b39bdf8d132352c1400838db719f29e80f64132b44686c4008d769b7c2e9f990438cc44ae87d7ebdf5f10897e85c92a6cc44faec1f5d5cb3d450453d344d580cb5337b0b374920bb90559d51a9eec25759cfdd94d3f1007c5d09e289459569b6e47752bdd0db2d4319640279c8b9080b731c0d8a806152dd5af3589019fb7789340aedb111617fc6ea08c7e75108031cf54df5e642b37d75cc9dcfe706b87cdd291650069246b22a9c781fb1a09178c2453b2c8d5a0ee40c4893c0b435d846a8f85f79746f84868a2227934f740255a09d90ed1ca920f4cd1a9f583bce08ade7b2b1cf462822e33ebd599ee9b1bb7ca0d7aa7191d58742df6886892ddd2a83dbf82cf6e501b3be48680cd46c213b749f279bef259730aa38a0d6549ddf8e8529038e0f6ef315274c4455b501bfd8937949930dec08b593ae6c5d01f1ae635a8d31adc79c0974a4a11bfa5fa9fd5e3328ff266d0145b2d41939efee41564629c68a9893c4da0a4bca6f84182315b0b7e17f9a0f6090eecf573a2c87b91d53fc41fc996fd4571a5f08f77b6d5fd2dff2a4495aaf0caa78038bd8f4fb464b0ed628f66a035ba0d687a0a71f45259cd3d5de3162e27c1f7dc6f6126cf809b5b38f9f56fc5e23c4ccb8418a6fb147f36fa0f158d718bfc6d38650afa4d3041eef64c0f0b2cc81bf3d6256a699ae857fd876ed8ed89d90c662f4046f65d1a71640834abbf539b1437fe1640d611404c74dd192ee95cf0c1985cb4c8a0d52ae6ff1f9307ed1fa186fa44df3a4a892b6ed6defb00928aa02a0954720227009cfd1fa9786d0d6964d922577836a097f7d0199c664ccf87f9c2793a2ac1ae6b627d29a8983e54879d435a704f2e1bc5afcdf973539019c93e0df62e7bb7aa4702b8e43cd174f9b61856da1130f30044bcd801d4f13a426a2c576c14611cfde6aad7ed3e7380b24d5eddff1f575da8a4851845971e6b512c93c208a1a6752b74f99fa85d12b0f704b894c8cac6c046da415258ef9038ef106f9e45569878ffea8e7cb8f75680826da0cf8dbdc058fa6e9db9caf4e396213c598537a78238961a92391fc262dd3e3cf3e14ce0820ad7e1a6aadbe8aae3f5461972876b4e57d2a7c6e7f9f2c681dcaa22c8bfb3e971a5d2dddcb06324569e1de64b23424d6bcea869c75825d23cebdfc0c21b7ecca03a732c68f4a4966b00d38d2477948814d1d4a3d3dd629bbf201720239e353a18b45a43bdb5ab6e370eaa8edac3aa943ef83e6ba72e6f795b0bdf6f64a97caf0ddafafb542ddfa291fba485d514680d14ec5aa159f9b48658dabd8ff3cbe07f94cd1bac53539d27613debb32e9caad736448ced6daa5bac6c6dd661de2843573ef806279ddafd53448c36f0238e397c950f7f2db2550f95c00bab835cc83dd30d753736a091b9322e3ca93203a0ebe0afb8819701b1a846464fb8b0e6f77f1dd124aed2c891377c40fce64ac785527f3afd21ee2eea08be2174b253d4ff2b2494068b71b81c05eb038aa479a85878d20a0a68f65c9324e165f1dcf33b0f4a792147775f25c44a96c49968ebf2a31bd80c2aa6e3e981bfebd271217f732ec5ce15cbe1138e3a35b7cfde3689d777569765500c42fe830def199c5a5f4a7b155da50ec5309f10393114c6df8cacb27a7a865d707e7ce5fc216f80e0f2500c5d02a07abe0c598f28912c59a21268bce31bef60b900f8bc6d8979f93cea83e31139174eb90151bc66b46c5a229064543460dc2f54ae021cda95ac50941f16308dfb994c266237b9eac74ab6d4b84c1b63e7dde53ae70abc499b304ca3a45f03855c5c405cb3a0dcebef4087c95235257f62805da7990de55fd19b1a2ce5277e187601ce20e9bc433255aa655dba8a25aef35e282949899c8bbd434d6432dd7913e9c742feacdfe05c845dd32da20d774100ae39f06d72cc124f15028f0724c29e2a63fe4cb1ae1f31b0e06978e4c731badf6800a8088e4e94d78c140f5395a77647d824854807efc2cceb0422ea679f544f9c0f75c97fad84c4c274847f23fb84a979ea19aa2e59ad47059e589d74ab339ea38d35688f9dd468327e1f88eb59623aaa255c6e5371c33e6995fe883804fc6e14e6d53339221170cdf9c92a8549af7b10718078f19227af6b47ab9ca1a80d3cc606d5c9e6ad473da37dd3d3b0e01df6d664e45b4b29663d161b10847469ee0aedc40db749058c4fdf418f9f6ae243e9e5bb054847d7576270c0f5e8c5ae5583bc26889bef4d8cc28a234361dc6c0bf9fe710d08b8439035575098bf15c7aff464f5eb42a683ad407279e7533abce7b7787386126a72c7761acd4bb86ff75a7199610aef94e2dc0fcdc8d5539b0456281f59e61195f5d4788663f538a8e96ec471e06e86c3e1557a31f5073818ddbfdc9b57f86a16af7f48f80b1e5081b6cd55e9f73a4b31a22389a484cf80c018dc977b0bf9a7ae346b0eb8250c5f31cfa6a45be1e96a1c6b46e0f1321cc7b00c771f1e43d992b2d03db2c5a2302316ccc479fc67c24b627c770f8fe8a46691f7554d70d1212cab9b7585b85171321a5eac39d74f6c3cd477c832fde5f14454192a215a397ae1f72cdcf99476b959ad6a670dc38c29435a61819972966aa1e2f6b5f03612ddd275a3af631ca9648fb4540060134b204b7e61c02fb4ead452f26b6b38f804bd10ddc2f167b0ac923dd652e641044659e436cbd7e63eeed83d476339d76755c210ee8985c2aa97c1e3a40d7b81b9fa44c137e6e4201fdc46f4651275b0b03a6076fd051eddd1014db32d70a15dbf3b2fad3008cd058806c154d261c816fc8f7bab4e7be3fb3e941836d537c7ae3c49e8a9f4e70e0c106e049209eacba5566d7df6b12dc3c018c04ada6b14022af8a0e1985f6386e1dcda8022d53df8e968e285e30bb1beb391d8e9cf72589a21e79e22a40c1fcdbc4e22b3da914f339b7df1c3f64379994adf5628cbc03cf39c798b4f14c4f3d7b0cd594eb9620adc8f4b6742f8e0b0a21247e17130efc2a80147e97c1d781830d866b9c9d9b5daefd63dc0df18a416be61fcdd1ac2556b2185e7144cd9bb1a8a0753be71b22b7b7a2ddcc6a0a3aeaac3aa911d3f642d0e4ce974d60ab3e685e995a73722ff1132a060a1d98043df7f96400ad3e645733f9bace93fc132c07f6dc78b8317c4b2f1b8c0c9d3ac372daf91e7252f5b61bf4e9a99214217179974167fab3caedbb27fb500e561caecf7fa76b2cfb1afc06d311f3b376a5f8d09cefb326cff487a88bf6bb07e7b01bf642305d06925d69790353792c467b43b04887948078433de0e6009cea1acc7d3762129d72ad94b8b3d67e214ed03d06497630cd001e41c618e1827c71271f309b4c277d151b7df43c7f43491f719de3636aebd9b6e91b95c6a1e6fc6d48cd1b486d547022fb0a1949d124abcad985f744827d2ba39a7bc216955cfa08f8267b64234b59b3df1c932c70ce37afb64f79452a26b8a5b711cfadf0bff6c10e73b3a6209219eacb8b2f06a35588d53833db65b61f8f5653c2c279544e2d2b1fddacba2295fa1b0f0bb50ea29a4e5f7768014acccbf1d183f97b87d3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
