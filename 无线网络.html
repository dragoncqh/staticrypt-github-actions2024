<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f252d9b44c31a0f5f06ef4c123ade7c79d7ba758805db88bc45dba286df4db9f455a41e5f73da529b19be34c245a7f489513e50527db20e001bf81829b45d3c1823163d407267810a1fb41a2ab818ef4506424c54f57f8511afdab9f3445c2e650c8e37be129554036a3f6c5a62999e282f07845962f10eaa1e06896be2105e47a5c879c191e72d8e070c3d61cf90b2c929555b99153605faa180210bba3d689080b29ef0483856a813b8b55f24b9c00640e232f4604c9cb79fdde83051316902dfb4b8f8739c66f57b7fef0fc71ce6403cbb6eefcb69f5373c26b3b1cff1cb6f70b5d483cca29ce322a78ee6a0547ee8c986cb826c48cb06fe3538fff43a02a5c4ccb419ad84431c88f88be068a9f8e3f7fee4e59edcd72fa694526133145de662baa63447dbd06e31f929e21687434ab64815cf20b8e00827042d0e71536d2d74a5d71f73283b437c7fd5e3632d926692257b328cb2fb35a84e081fad97adf6f3ebdf9d9173122d80db7be1540b1832a480551a1d712685395b14d69041e5e16f983487058293099e1198e721c6c8032afd3532940ff05510b83030231298ccf684c21fb710fcd7698de3c1c94685c105e3969b85e59127c7060cf9a95acccbc430a7349ead2f9d9e3e297c4f670e794cabd9e7d4b4239a23481b6480a40006d4c7878fa0af60d6f1e8976791b1a771d02419cd04f0bb07ff779e513031675ebca5ff0d3de4bc864d3a3c2b1796fe25188e07606ab6e4ba926ce8c4301c63190950013383f902970622a4040bdd451d0d5498d85547b66b12dc71d415d0299fa214324a6ee850d6934dc8add3917a2e79cfeb1b74b54b97693346b17a83e41a4dd18a6b7b84638fbb24be94b8b41174ff1940d94552a8cb80661fa9a96b9989c22a3d7d1ac6ba017b2493092bb19c114c1ab9d5fc4510fa91f04da1e98441b09e557150688efe141356f6feb1447cbfc8f9ff8bdcf36927afe87eb2278d93dfc0a4e1308e0357f66fa8b149d6d1a3742201cad97408aced4b6e390f038a393ab374217af78fce0d9b3b08f18ba3804358b195813d22da3e44a8f362ae9dcae56ed3c93fa76d24550d367781d46cf21c6fc610c1af1016e06b554cef3161ab025cfe2194afb7ea0fb7b38ba825f6e74abf6feb7835e91a5f9f37c27aa89cd3143149785565cf1df899b6ca15ab6f6d4b4110bcfe1e47b0a5b9096338831869dea0027c85ec09af223ac8866874591e9a692df698605622f6e370caf1ced44b837e45c4ffc0c986d17138be92578fcc20118356d8d33cb230c770a7b93a9de08924e7db3ddc064c415078060c6cc45256d1443d91d660830bd566e44156bdd8e3253abaffd8e0f20f632009e31df107c2ab62a6d1689902cb58e57c81e9f7c9563e6d2af42daafc9efdd39d476048a02e16c9b1aacfad3181348bc5bac9e16add9b9128766bce9898f07930e8e56578112bb78c7bec3616aebe8f34262132d37bbfc7f2824500ac565a0feefd86829e301a3b84c5e784486e5e152c5bef86b8545a003f040bf607d9d42f97e130a25525779be2eda8f207b3a3506ed7100494deaa914dc5fdc6452eaae1282d1342b1b48c8dfd602dd4d4b59770a046325907fdef1ea258ebba6d8798075874bdcba8ef3cdd78a1068a5fc233a28807a1d32044080a74c575f70ca9007716bbbeeb212c9579d23af4d81e2d727bc6680bddc08727cf8ecf7cfa712072e5571ff2afab443c1776861e5039475e06f26f24cadeb28b2569ef46673d353ed4377c51195de7e4d5b81248ab85591f666a7ad54913264351903654d673703a00959a67d6498d12d612656df41ebd0bc3ca335be2a52aa2589c08834e9813bef50ceae8909ce5794b53ebcc6ea68df5f9a210bf1504de1fb4514d1fad1fbbcd38af62f81a8a06f328e7e3ac86f35dd2da126ee38eb1f56f815ce921ca9a5b12d0dcebf1515fac426101c82b92e89eca0a67e627224c8ec433849d62fb11691d1cdd2de6f104f2e9a3fb0f4417f94497344c5135f69e58ff51c4cdb29b4a4c13fdffbea6ef9ee5833f186c4c18c8fb464dbfd91c32fd45164b2e2d169965394551c390b03346d79963eaf86daaaa26d1683f88887ced32f92c004aeb9b581c4921edd861f67818677dbf71aa101cbf8a59e4a28166caa65f01df7599cd1ef83dfe1fe878e37b245261a110056aab1606f2494d3a3b90e2e0d52662883cb033d8d2453654ebedbaec5550f6b5d3a801cf0e00a48b989947c8da251b5502a45db5548ff5596c736328bd8d1ec5b243b90dd714078d551a4b7836cd578efef8d76b525592ad32073eac724d885d00066a4494d4befb3a518195d414c402d3cadfcb6c5ec5bdd40a88ae5556b0891de59ab6b299f61c99ddda535541a5d7dbf001f9132654e4b5e08b3b0fce9ade16adeaaed211ed346acb7389f82457a5649b5c7459ad93d84184138dfc607f07ae2f35f44f90621ee5fbcee984828a83b75c10930b13accfd9acbc1860154a989bf16ce8aa3de766acde8b22fd6279c7c2008df45f2d6d46652991b2527096ed394011ed28910ffdecae04dc5bb593a9582da2faea0ee64f188f3b25ec089c5a78e8dd6aafc2ebc84bbea3929e90caad0daa4c5c560629208a1a7d9252adc61bc11c3fe71917e93ed786d49023d5b5c164359c207a8823b6e893a433a0fa31556d73aef6102fab59fe3b7f872b9f5c287e71de4edaad22983f38a717c32313b36eaa871cfd763777c209ea8fd45ef4a88b3a86f7927316ec050266194001bd410c1b77ba5f1f177b7f91eb7cfa25eab499b641a93249dfbd19fce356137f6883138a7751ab3502006b1c6e6223141a3d2e333769e30b48647f5efd569055a82ce68492868eab0c577ffb20e6de8b6d29232c5581649da282da493883de0dd5146d5e7c60e0d0c9c01b11e73f5c3e3712c0470e382e305aab7c8fc3edc57f24a30c5d959681921a9b203d3a6b3a79c1947e78b90c4725b7523164d1321026197c675f94d67f41f97718c26a11bb3050ec2eafe35844f45a16eaa380a41dd3e748fdfe23c2f555cd6a3edce418caad5edf7c9768f04a8127411456a2e7a7e7db1453ddee1a5a50b0d73da31fe94613dd5ae70cf2ae940ed40b307c1cd10958fa8de20727e9748b3beb8f62eea511a05fcd8f0b81d057750f8589c872581c36538421e82263e2fac329e3a70146b528880909f70e8d74c7f9a8ab0cf180657e363e9c65de46b971fa62ceb809a302316449ef4745559b470501dab2a00e7d4dc05c99db91ac85ced0750bf1d3e83290f006eb9e65fbe13b1365f1c7f3507d7bda48a53bef691711c96bb7bc0a126612c2fdcaa9fb455c36052f58f924a8d2d44c41ba55666c651aeae2947711935da6711dbe2c8f20c5f34c02fc71cc141c68595f3c092ddaad5f89f21ccdd62b85c01744e3adaf48aef9e98217fc73bbb62ba541d0fbcc41180955b866bb614b8aa656401d5517c5a4a53476492d58c0f008e8c5f7653fc7d91d150e5df0db4e388ce7c196352c45b0af3fe66541ec4682d2ab989cfbdea640ba20512467812ae49f38d363555981296c8795ce51a26b030302f2df6e11d505e2a7637e582262fc8ae7e2c4e2a0575251bdabc11beb731b2d92994de3271f58c9a3432e36c2c2413735d4310c3517f66889f41b7fe7ccb07293a1e56a0a5307ec88597e996270bc44e55811506d8f656a3710fe2a79747e8c9c27c3294b8373eda41ad3957ff8b7160fa7906232756c44fbac20f85279d55c7e37f4e6a800b7c04b4c6e739ffb6b9949cd626dd43d13d606378eda033e67d8a4a377040e46f34118e5adf2b02d77a309db046c9e759b67131636340309c4841de94e350b6737a2d418406bc17e9b4fe2342ab3574255e1e8f5dda97eba49f3bfa8552913c6bad1ce5dbc3f1dc2741b6c9c3465a98bd2b4faee2d84e427b5126409d75d3037a80bbd9df22e17e351e57cecf8ea5648bb7788696db36f22117925928b6ecf86b5a84f4eb7f66872d122c7dca324928b00266faade9d5007219ef32bf6ccd15fdb150051ef35edbff9e4701560b9c3fe3593d3ab3af783a00f3ea057d0b9c4e597f612b49a6ac15a0f2f97c381fcf9ebd9e81f718deb8b1f8f27f1fc07711fb78ec7aab3549d7575940d7476662608dba69f4decb9787fcca288a8026365d0882bcd23a4576a00d61ac8212d482de55f867dc671e9d240229a83a91f0d96c8688a5e336efecadba226df20e56925735764a5841137f5f19168a23aa6c77c001cb3bfa36cc59eb0dd9eb147d8484afd4c2c1cd539da22bd7efa0f0f9eeaa150dddf2447587d1229804dec944ceb85ae240420068a9bc7db686ea3ee75612ef3a83d30f8f2f00b9066e4fc6f73c95f0ee0d2b087c4daf1899c7af323018beb61df88e3a8e49d61b6a6227b0a7721832a93e7586ffc349b4ac480815bddd43d6803e6c2ba1f045777a7f78935fccb61afe9ef2b544b9ef613076fc176663d67e58cd4e9136709e3f0f60f4317734c74a52ad929a439b6695d6c900f34280439cac5184f202cb9bbceaf4c80a5e81be9d286d77940f193d2abbf9d571e324b25489a82d5609fe973819693a06bf8fae169d91a770822322010a858368673390951c2a75da48896005be91e9503f02f52c2d66e71fbb374fb4a3a189f563d7f39ad07efa8846d0e0a4eef2ebb9979d8c1f7d3f1b1894ac85234a3f7689c4873b84d303194bc0dc341bfca8c85760ecb6d155616876ce59e1e093588d23b681b128fa1281c719dd79e6f786733a1cd36b9435e2626c6b49ecdd8289e47196f433fc4cf038c305c86c37d5ce87d96ba345e2f284f1820461cbd21f88175ac71de0111c8096aaf1e30abe42a74cd8d30752ed2aaa2e9764ce7da91a6a9e69ee1296bc78012f3043b081d74ed5fe7e1df2a84f2ae6298988642b2a07f85d46a350cbacdf6e89883788dbbe7c04412d43930c4ca035c48523066dd162721b57f1b950734ea38517f01f097d80bf34b10a0d33819914ce06b95e529f57fe0dbdd9ffb946b9af8640eeefdc19008ee78e4c97870292e9f5126441db76c345ebf73ea4cb09bf86a569890c88cf0cc47cd97d224346e083774002f6f278a29c2d50706621c1e1af5a41c69e43f1920cfab6b011375a4b5e552557163083c9112eef173affd72d18d9a127b44bb603a79069e848794c19947e043c11dad4cf743485cf418b9ed9f1c7cd475c2516f32c9179157e659e512c4de0bfeba328544c8a13994b78cb7147981e6e0396c5233a36e9bcbdc636e2e4ad186662c8eecfdc263a55835ab23ab158d6427bcec005b1206f66056b6dbd4bc2b450663fa484a471a72c6fc2355c8d178d5afcc7a4129d7f1e1f458ef51cf0290be085211d1b9fe42c850aeec19c6e2b334ce743538bf58d359043f4f7c2a2c127c965ef870d5216aca651ecda53b661d7ae593ec62f65e49ade65f50d20f63e8c7ff6db91986fd84eb3c31f5965e5752959e3fd3c7f09b8eb32b96cd8d7aa5d37196420e063b1543e71398072d278c0adfc3cf0c2ed9735165fe161ab70f9ec10b2ad19d91c607f9ab6e1f9113505d97d0c8e0496b54626c646717e830745f13fb3d0b855223a49dd1ed10f323e38f6a7609ea8d4b23372c7997af554b11c48daae327cc9c21f1bee47952b59ec3d86d9621c3143bbaeaeb8325661c388931b53bbab249d96d3757ecf51e5a2305f63794b245990f490382ac517b06893c86c8c1f3a2c1b55bc5d8a56bbd92e81fa36e8a5c3c1f85c20e317453d32ca6b957f8132699097d3bce2e3cf3208e62050885ad7dce0d864ab49152e2ca46b86ed87729b6f36a16295a0808636939ac117b51a74341839a12aa1dde418d54cb4b792861236a3a409cb1db2ef817161af570b348bb61e5b97038cc242629deae6f76385ef28984d746f10ac0cd301f21450985664ff411250c0c35dd2e78aa9342cb1f055126f0ec0c705c3ea0e1dcc14b1307d5f13c174f509efd0df0fe327d849853343bd1cfdc7949655d9d32198169c87a01474c0311d5bdc020f916ad52c47d20f1b3e547c22e0a4a321caee6b3f10cdc337f75c585b8a972a7a78e891f888bbc480a71a74b4e9c22f2c19794e486e5dacbf680ff57fbfafb8c288e021e525aafefccce87e36f16e8e5630d451af19e343ce582780f079d7857757252be0be691d34093aacd2aa98581541809032bb4ac31ab96968da3a8a10df2b8f9be3a8effabba2c6d7b4ee51f03572031b1de9d8831d7bf9d3f96c24c99326c1dcb980de60dd601883fcaf6b205763f13c0a6c60ed4ede45e32abba3fd4b5e24c7af2126f826567f066c4e245ac2bfc983408ecb2d160e09bc4803ed14d2d182b09f543c1abbd38534f0529bccdb3b24cceba81d7167630919adcfc8ab18421de7f230840d90d69424ab4c5fbdf5f396147be77128634141d0f0f3ebe5c4046a819453a2a33ab708a49e772c07f8467d3a9d66bf2e2e6bdf42120eee82efc19e7ec6b08dfe17d8009a35d7c357120478114a35bb5b298077c393c2464a6b8392f52481350a93dfd1ac854d4abc3429a1f25d377f45bc8c52b67055d71d0d6cf141ea738fd0f8f84368207958c84e58bb30b6a12340dc810bd0c120e21616b084adc7fdf40db9e18aa023b296fd11da4834e4708bcb8dfa2097a75504842793b1630fd2aa513c3a15db27fb9ff8b29ce6209afdf5435de93dfb92bdd686b255ccefcc6ec5818d9a33d42a9343e1488a8560aa2c1f1b0606b8fa1c2efc976ec4b9e93d41906d46dee4f96933f3c7cd596a392664bea4bf81be7041981107688aacdafc84e94caf5de42d4fd8f0bec277b1d3b53ed23d900a4e7f792e629b878482d3fad7157c2611d0e8023221fb1ce74433448e5936ed47660178dee347b58d46afda813d1cc8fc2e540ca7f410b03168dd099cc30fc989d5f54913b0b8dc6af115ede88fa17a78782aa7f3264988d315ff424d3efe9e8fe9b669e394558f4df4679e451d20f8f72be5c49a05bfe6c2218d4a581be3e1c92acee793b25713767d0dfb53c1a4c66a44615dd83f6a34416fc71be8f1603fa8c82785c81f43ed930960b2c68f5727304099fc5fd3cd0d51c1bc953e6ec3a414bafc1365504b18d9e0d1d352d7fb261a32ab93fb302182fbcff320e79d09c7a110df02f07bba383dcf8e8bc690629896e189e5dbfe3fd84cdad164529c5f8cff77ff2fa83f6ecbc8f031b7760d738312459e630dbf7731e1d1e470524d16e5d065be18b2020ca979a2b93a56a191dd998cd653e6c21763003331ae99d8d93d1096b646ebf841979e7d60176ae5b2f7ecb1e742190028762b82255444b15b1448b893ec03b94e23db2add46e0184524cbc90d3d09708e808095baefcc97ebb77406dc6061749e74f2eefb0258aa4d80ea3492bfd552ece778c3fdf93b2b383a916ca7386ca6584202107158473420c5b7ad57ef4213729234016d00ac6feda7817abf3143d0325b19514dccdfc70f224ec57b12d32427bac4c4429c4242721df604dd185000dc5de96528061d082de3f46050ea6aa79cfd6aeeb7fc75b72695fea5cf6ece9fd21879762ee0baa4d0c8a2abc6e1938b73168a02f379a23c6889824da48c68c30ea19f54eae0c011cca43e4402b268c103116c2eb665ac5ee39caecfdc7958b70f08a1662b140e440ec771a85435002716f19bf316d9679805c9b2fd58130e6d5f33b4df1bce0638c9797611bb18faa8202c138450783d9e917c882b909b097eb77a4d59381d7eff7499a193aabedf08b361df9e7d875801322ea86b89e42d2c34007276f3498b6443578acadb2f8d294d1b609c3a7ad3bb47e2f98856d9a4bb89c46056f8c2d2fbf2fbafa06374f6548e09cfa02badf78364dbe8659802266caf9e91973cd80db4b09f5c50e769dca4341bcf71972e6a5ed5c51af99ad5d25ffd1145498fc7b7b2ef520686f0b39b03e5a27242e3736c69e16b5e2b9adf4cb7a708b6d90cab0b2c29a33d7002a869d341cd0e332125f3941947f2de626e8751f6bcd36f3922f82a481742398b6e58cb5c2f249d52d56b3fc8463524bcc6073bffec0c3ce72d55f7d6466fa7adfc09e8b2a8da3c95a8fdf27d7c79a1a7175d3f4373578068b29bf6c2cb24b40045e14c02434f4c94451c5b9a0c99a7bcc80b96c856a8e72c21adccd11ecc7c9974a26a11f4075c881a6d0733810a856f5763b993e1403a0044c0bd258bef04ae7712a89abfa425bd6f21c03e302a65028df578509ba56bcf2ae68d0d94850393dfbff5d2f21f6dc53bc634719cd46cda6f86231d813e0218e9e51c9598dbbbb05d40c839a9963711791a40b6f6f5f4a26313f2267e14c9b765efd182a9fbe234bf5143a47a81bdee7216a1985d705f3885b4638737c7a10d1f4718753032830a38f3e10310ca8ad6a6acc1c57ee322c2aeffd4026819e6a5687665f85e1a3673834ec6beca7bea3ac2172aa0b90e4a4127791969bb4b4abed79060597c880369f0eec8d776033bb361671a7afa6c9fa4ad89a53654680b24fbce120be9e9ff865bcadbf18f9468fa11ce2c78875926345ed7d3d4ba4756f5bdadeaa39b1bf02ac88b5acb1a87df9380fd7d565568b9df014be5f3b456a4454ebfc294c8c902799a8b0d507e34d802ce687b9de8b714f675f043046a56ac60f8e52c19ea5e2fa8769355db82c78efcf5ced0b528c1e52d77d9bc76f9c6e0d0edaa808e6d0e86d64e52ba878f4befbceed77789a34e5a328a654d2e27322e8526e6e3fd46f87409fe0b75e1ffeb4386f586d7e38ff4f838e9515c31857a1c2984bf6769c73f5d02a7ba7345edfb649c96e58396baf32f9800c5c8f6693309a88e85f22b0bfe50a1b7e46dde9ceb25675a235f0b11961f839ef07e76db4c89d9ce28027cba0fe2e1e20de2724321077f990ed57b0b7e0981d65db29ac042b1a166b13e269558adf37ddd3cc170a8a7f21c3c691ce1892ff0fd8abf8059e7d8bc9f2d1c7485ec8fcd19ef3b4b85516bcaca59bb0806d412105256ef8fd041baa95275fee8a70295870e71a0c1cc7ab632e1e04cbffd994f03ec703b1a4cfaf7985a1ef3ccee0a89f7c7d271152920efbbc007b63c7c6a4742c1078f3f650ef21838df547e736104d1e7ec24c1bf741be3c1ec9b996e29834ac599b600d1864b8074d3e45535066e7360cadcfd642f5535115b8f9036ecaa46d7a15266ce9a5837aef76e1cd55ada356b42a5a6ef5f80dba5bd8c34622d29e99b2b39b2c2c45f811bc1cc20c7b1c05df1b9154bc9ab560b9bdb6b1123209ff38f41acebe7ad75732132faeab72e9855af33cecd5e6d8975c0e295937a68e34d21af55badfbce2f546f73b99aea0b6e1c8b0323df8ee9962662c256661cf46357b708885a7d5648a7224174ee5036e61a03fdbb00c23879036fdfa4c4985dfbd1c40ed2de8e3aa7c00d7538ed356c21afc30dace10c474022b3ec87ee85a94713442049cf9d60e742d5a23e6e68cf98b4bf884733f8943f3757d1d74d101e9de2f564a21eab15529a9c33d144ac0df5178ffff5acddcc2711592071125ad9f83b4b3021a979ef4833c57d9df9f33b74e4c133c0c550ebc7d77e119c71dfcac6bb934f55023f490e5303917d0531b4dbaade873d12f38fc73dadee7f0bb39d705a9bc9395fd32a0b38dadb63bea9973199a77923d70e75b027a4edb966061986adffb4b7e441e5b125737e15385ced73a2e5aea610d19d3058fa8d190618674e2539ebb814c51b9ae3d43488a1d5799b2327e7d2546ea6693bc2d9c892e12a78267ccbdec9f6947a909275dd96635d2d8f85ad3cd2234de68a879d461cd854b285cfa8744f0eb29135cdfcb98eec21a966015ff606cd87a5006e1fb0112d74e6baeff636227cc9af0983dce7655c16fa5f70d7eee1512de86cc165ca2e6009a145b38a162a9f82f52d76203f6c9f8f42e80bcdff75e86f0447f2c88c3fd62f08d7591a42f14499605b5d5a3b2104028a9ef3e29616cb0b2917aeac3bb27beb3a535d9acf41f769af2bd8f7399be5c7c4546d39a7a5e54de1981da3c6b5602b03f2073d7641177015ab6fc2a82043b85e61fedebae554cd9b1b1dfd22ca9304bba353aea2bedfd353364c8654d0e91fccd194e2872f008b1d5bb60093b341a73e6abb1f0eb3b45e79faaeef9d0113bf768f5c6f3b3889672682ad5388c630b549f30da65a66f802753a564afe4dcb761a51fa7aee0251655cbaf227f47d1be0797cbbf12b2e23b8b0cf810be405f3d49017409674d074e6dbfcb97939e664f7f5cb971205625e022b64d0395cf9fb823cb2561aa8440125ded7a081e100adfadc1e61c4eae0cbc33baa0272cde6e0276a524e1e230620d4e1be579b91c5b729d2928552ddc66d7dae0da19ce57cb56ef7a15bdb7f9ce99ae24be7bf31eccdcf4c541dfbf8be887868e08f79c4abec44d43a0cac673cff26f2425a0a480ea6da582a4832e2f85ba3616ec454a33b378cfc722b613da71e5b9d99c4f960bd31b8aaedfe5216ed912dba9392fc3bef9c5a220a4eded1edc18f7911cb7148039e52ef1d2628375f6f85041a7c7d7fd8281f222eaea1823e26e733c9afc3ca770b1084751aad2890fcfdcb6570f5630a8a28435c5ea753d89db4352399b61d8503fbf90cda83175fd673f51c647f3aa56989e715457ed69ef3764289c7d88bdbc794adcba60df18530191f3cfc69dd3d24d832dd27c59307878fb7cd40aa05dbe6ee75ea9e13dc04709248ed53c9ad38391cb509cbf04dc1b0b55917d17cb000d01afebaf81f7385ff22e0fc93c91faa556734aef18d2871df4576b9e19c9ec10cf9f39134c44385a9871f306542790ee43bfb5fde5fe6f6f573ea2cbf30c69d95c1ceab026732a7c56c651d95f2db9be9a6715814bcc30d366882d05436b2c900ae121b5887c07b8ce98e0064165935b3862f7cb3da1236ea3f372ebb72e071d58948e137863fde4af34f43e8e4407b537e267b6ec6a34c302ad69f3b0ba6ab8bca4e6af6cd89f32cbf5eda0dda53dcbcc6ad132f35cec5c94702e506898eaeb2eb27217f0f71d811e5688c33de1b51817f1c1d6d7cd27afb4d8ed522bdb472a767a173662e893247d8e993198c3b396cda714a9a1e3f3ab2dd18caa590d5f6fec09ba7d1d3de8cff37ab17bbdbdccf93918e83e0a159a9219b4da93cb4ca4635226adb29d2e64dd4d0241a7d42794fec5a89e6299971a3bad785b794e6a2fae0710fc3282487917e62a19a1230921067a2e3cd19e15329d139ea8e6aba63521a02b8b5c73ec1a55bdd855588e5ff04478894e9550204b59e25619868ac82744af891457d2ac2804727c504d021c5dac214216aeaa8e09834eb6f128d3d26d138887ade92001c5ba641b8dabedc5729bb77181361273f4cc51dc3241ce15f4db6c01501000159aef3cff4289f7ef56c6f6c5c14d06802c84ddb0f87d845e1c5fe0ddc74cffa757b3b4976f177e56a42d4a98f374f24ce00607f86a49c2c2923aa771a40e214ac1d5f9cde6b40177e6d1be22a8859b152da183fd91632c8c61c054ed8b129a8c95f17825b64ff900ee68ea024dda160cd95ce125318cbf5fab22c4d7f156323bffa71d6d4a95129e43eb280951442f42dc9b17bebb31aa5ecb13da3b5b22b17a1ef37939c4174af16cf65e1467c16193382b81f1aed893cda62cafd773ff2756c5dd505441935d7177af627a6dde7df7b846dcf819d7e4af55be8767ed4f052ee5233eae9aefafacdaf13a937691f7361185a0c379c4435ed957e826a5d02002cf8a40ab23b401d2800c2afaada1ea7cce7851702694d0d975704083745bff3ce3975b01d07222ceb2d3fb749ff5d548aa888b2f5ac40f2f457e63feb692c21d1eca0a57dc58470c56cf8284eb471c3908024f43fce08fe1bd68989be9a73ffae0aa69fd4b5f28826d0d86c9c6e491aff36063193da3718c868c19c824b82c57ebf72723455b5542fbf5d0cb61687d11082a49e76914edc35bb76d90d3f8c28e24092294d92068ae62e102c5e96da3b28914326bd9e79ec073871c3a94fcba3da95bb7f7262f4227f30fcc5616510a8cdd3c4d1944893bf85f5f46d66d458dc1746ce2d3f8672fdc04da6c4d6bc3ef24457cd56fd3dd922a8f8fb6f70d4df2be19cac7332cb0f467cf71960a86e23993e8c5234b00d5bb9ed0a9cd1869d090eb92638fe7884a3ef063f82515814fdbe6da0fff6c6dce3ea8a38d485c8ceea0a1c25450461fa726c006755795d3e95ab55f241255e66f24c56fc814eb0eefe4d356f81ef1470cafd04e8eafe7978fc6dceafca4097884223bca6ef235e8f0d9f3a109dcab78f99c46847018ebf89a7a5d2ed70f730b23bd4cafd28b3023fc2036c35f5967c726ae4b881ae48c07120c43fef5aa80d78f1e6f19a929198702565a5f64dfcf2a6c8a66703838c3cc64b7e7f37f71abd792e8962fc1de5fb07bfa58380196ece3d65485eed10d9bf8cf57bbe1e00999fc3a210d56a8913607d5c1b2378f8567e03477affff53acdcfc97a02f12425cdc21767bbe3a7abb4682f2d82a07995de20416319f61c7852a57f401c583a59a0604d7b2fb3c60249ab19d37577354fefca4f945bf167f821cb8b62d9df3bad577221ba2147f8d8c1ec49b320059bbea60b13cfe7aa905b7132dfc8b8e9df747a5a88ce032e698b778a35b6673a3fce13bb81cdbee8c42ae9f9977744249d9059cd5379f77fe6b293b108a8508882dffefb637f2e1bacc7c4ec002725c8eeeb1d08d383733398fe396161a8bb9073f835a1bfdd38dc140e67e06f98b9fd2c49554861cd2420f57d846562ba57fcae11f66d2677d64e4d116319d714f3a495d25df74b4570b33659ed77db09008fe89879826359dbd5cab5f76d87555c0e38ebf7426cfadb6d1cf92ee1b40dac782ba0a7ad43174864e8800a038028033cdaa0ff1849e42e02e1f416a8ec4d6778258037200bbed9c31e5b6ac5ea658c8b3298af460ec44594358730125fe6e531ca261c7186ca69dacba9eaed44b98a0ccc402f59c69d47178169908d1d0227beed6fbfb85815cd69bb8d5df8bab32aaf8dd355f6d4b3484e872ad543693aea2a76e26fb44657c05330b394f3043caedb4ff3f989b8b3bac9d3781519655154242d1e81f5f85c0f40d6eb895210795e23563f11c36200e2125cf3224f33124924aaa2f13d09acba54c9eb84038f5a161fa4eb579dc4f5a87806f2fb1223461c6078ded4ee1ba619fe6dda45222fe41c9d4e45aaca3815da7d103885e820ecfee9416d1258c40fc67d9bd302d7d248fa04d965ba6a0798db541bd2e93c6e163240db4fdb3ff1b49874afe054cb6a01df1396a46037455dd032511733680cecd909aa6a3f0b96559e4c211e6f91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
