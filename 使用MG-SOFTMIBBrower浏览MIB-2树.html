<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92bfa6c9b843f0aabae31204f250ab8bce1dfd61eb4a131e34f41c306afcbf828da70de8c444f7f772d790d4fb03142305ac95c02c2b7e6ebd23b53cc8b2a1bb8e4abedd2b312d3c004b114157403d883ab5205e5e9a4aa85417b9e867b917eeb169731562559b4c4b27006ba8dae31efa8ea7cd06610b3d5c97451d2f4ca0b4f410599b60fd8c61bc320668613e717ff06f79f5406aa7702450b3df7139a2653f4ed75b5b7a80bd6d149511e3161f14048cf3b2520c370f7a128b1a623abb34caf3546984248a83ca98dc35102fa8d7027d652251c4cb0f8ece945cff49918827d940dc23646f18f99acad06e6e3d407d682a8e8ac5ec60c5920cad57ffda2df46ddc76f959c4ba9948574a7b858404d420aac243f34abea0b0f3811c961e9f65a8dfe74c713559dcb51bd28c4c95b015abba159afe4f4da74404ad2dc582e8f5ede8b03e065e3189c194a2a35b63531e670296634d9d2723404b96d7049f5b769cb82b689d900f54cb132d188676a24887f3293425ff0289f26ca966bd6632c4d84234f97cc869daf05a5d54e95cc2a25779f36647546a762d9d989b3a70da537c07a294d1c92ae48cea03e7c2c4828388db450385d823d576eb57d76a2fb0995d58aa315fe81d2a1310012850577accdfde6e4d961c9d760ca61c3fe758a14af0075f01febd8bdbd2797074b5bc87b2c26a14653088e28f7d67ac7f0babb9862696731d9d39455974899c4530ae424fd8723d63f4950844a1fff32362c5d028a6539a25696496058e1c4408d55aa78a2c799f9b3740470bdc7108bddc0a716d7a4de31aa270c105ef1117fc78f1c85b9c85ccae1c99a74888c72c1c825ce61cfedb05b2fa0c93d14bab873f0ad6bf514ae30625a3d554abb406460742345dd013fc33b054dfdb0373916c8d348c38f2a6cbf8b1baaa28e7d32f4d9daf5e598de1924b468acc6283cc1619409201bdba058496e38550387efe5e6ced55a06408461032970253ef99e7a5922efec9bd09bb8f19f323fa4693f1f3aa6c3b160b3c32cde2573d932d93f8827d2b4d0cd7f8e2537d2613ad693f8f7870ef61a75a55efbd044841c03938e2818158a36dfc84ea10add849b0680cf61a5d2a2f9941487d328f6d1358721baea5000872de84a294382d71af378e7f0c79c871588babe58900316f70b22e125d4382f0efdf4d43a672220884d65d3440661f44a20a05c2538ac5e65254cdf8e54e36d1492f03ec920bc9765588bdf32015d32b93c592a5f1972271e2001742b9acd8565f022d219b56b93121214148da90efd5638675156f9bf890329f85b3c505f7e6c9baefbd9912d906ee2ecc1d9bfbef195142e585122b33898b0f34faf142c63d6967e468fdc274afd8a829ebe7e84137654c3de8f6e01a7a44425e12d2a7703561992099b438875f87b277ecbdcded88522130f5664efbfde7122b8623e9d9c3a70652512de0ee01dc15408487661708a820e09b7a9fae68f990d5015c0afaabe2650996ed2481bd292ee380541cdc00e6831df4c689514197ac09b3d8fbb1721cbc3f2b629f70bb030b35e5bf69d80f0696d3e59183090474520ae2f5861ac7a5cb8f7067d86bb23e586e8f0b9dd3a316b3c740b1a53e9c14edafbcbf770a4f4e154999d050896e81d3f860fa64a36bf9c125bead3c8315c50317677f3b401ee8e407876cb9eb015a1e37a282719c214dca1b0f9cd6a955e987106f62ea5e39ca23e4ee04baee488d1e462f9993d78648b44698a375019193d265d493cb2d95345d9068a3e121c32d10e286fe7a8eef150e1852d01b104d38dc17483f52327c32773213868907ab56705801ba5074818c00fb445449b6d173f253b911097a81a287410691264e33f440d47eaf37e80fa175507dc5384d1e94c7c4c95891fd4101412440494bf17503464c9c3bfd05cbffe572e9201ecb2f5ae5c25db39bf0be66ca2eeb3a7a45e50501962c7da95ac10d679b8969d83a6b1114f5e47652ef3eb9009dbe6b343cd8f2295243539c76c2cf60c4fb2f04e0f4bebee3b84c71b6f27154f379706d2f1a9b86c17a0acbddb5c4179bd1cd25f47b313544443b0377f7911b8573c40bcf4114ccc262e99a87cc7f7ad5e155af82404b28cf8603dfe0fe93f72b22b1e0ddaf17c96c5fe8a6b860c0ef24d87b233bc2b27a5891f214caa79a20d082f88b61610cfa1224262a7dcb7e19ce37c78a5f5588c6ead4de480fe8e43778ce216f93e1ebf67fcb09b887a5c0dfff77d544ac6633037a0801d56544d7b2ae7c9535bcec46c6acd131701e3bf10333b0fcb1819281cddb15b3c1f836bdaac2b0c80b7ce13d3a980f56f2695495ef749b76b17393914857f61a694177fd8fe4b4f6b84f7bdebbb65867193a098e2d0d4a5f2e3a1138db740c8e4060018dcd696f7984a5fcde006e482886983e3d0cf93b0ba2fc08fd7050d031ed5e440687c91f0490a3f5ff0a8e1b38c4f9989de026eab73d4e36db1706ce67c85f12f97b65a33b41cccff805f4cc65403c4dabb54dea94eaae3baa2c45b886369b0fc29fe50cc84a6d69420748b36d68f4829a2943069e97f249a5522513ad03044dbc3359fde8fca76e757fc1d32752e920a84ecfecc4bf0ad34d5024441feda3b7893c8c043c7d7731e8e809e2eebd6ec02478eef31255984fcb70087f2e9639365763a1b9f4cec578aadb616702a3e3faa2652e9fe827cabc9080be1e4b27f21f08f65cedff25931db6b39145aa86bc4279c0092107ecd39ec0cbc1c802ad1dd2d573cc057f34a56f0af8798bc6446a2b6ae4637f4a33fef048d8a8de922be3948bd0ed30824a3c31b2893d6e17b9e390daeec6f4068d504ed7143b1bf443a769e2f2a75b3e1730e627c4bb1ca6fa18c3dc69b21164527c5863f5ac6e91a96bef4f7a70d0b7fb1d48c260807a1a8b9af9657fc87b6a074e70fa372907d00b8e997d30e4e459d8b61bd935ca3d977d27611c3fa16452480b6562d876ce1209317d3877244c5f224081d778847c06868c9591f1db08464db22eab80477dabbbfa3d8e54856d116df1f47c0fbdfd2266c4dcc7efe1d243d0b79453511d4f7ce0b7975f38ef2ef49f2a450f173b2b02ec9ef4c7eee04d0b3953136dcda0667109f8792d584c7536ed19e398e6bdb8a13c6240d8b1878ea9efe0d86f6e5bf264bdb68600e48f313a2f58571cfb1d80091a10d66c1158125b02dee458e65252421dbe7c66604b71b430415400f22624a7399c19cc33f13ca5fa41ec4f8baea877d84edfe5a77586012410a2576cebea8cb028a2d5c14b95f7c28456c22b788bf86cf970ad44626c2760c7789b5ec0e2d5b6d1e8f04ad6e60c0f289ef28816cf6842aec13a455a0fc672ed8b668b81e5f621bfd8d0600fbd2425d9ca261a5566d9c391072d5358829a30761b55c4edbdf1e249f3dd62d30f0439e5b45945495d3fa9a0c52060fef0beefd317c07c0852eb05a9400581c171b5a5212e7d41af38393b8968a9855826c1476d15c5846a988624466bd9298d6c7eb57251d092c1e9cc2b3d25d90aa2347b47241a53baf173aa6eb4d07d1d9b045fb76af62271dccdbb1658552039a66044be60f84755fd9638c90f03a536ae76666dddb4b604cd6f72991210cfa0c3fa4c4e05f385c55230d20d199c8786b4a0847d8a36d7350cc4d07574d3df7288ec7aa9dae07ed93a858bf6030fec9b203b50f4f882c25622df2e350e01ff3573cdd29823aba46be6ebaabcd4190b56fe79ce1f6297f9f77d430585a3623f904640af7315c709fe7dd749545fb5db1be3f8f2886aa38d9afd10e44285d135e2ce880320cb22615b05310b1fd4072da665e8f711b7f3417026c3edfb0ff6670a5b18a090b4d869c3be466b2320d659819b83c3d318310eef1c9dd177091ebb3dc1e5267b2b549f24b38a5b5d11fa83c7102e9a10980abd6d44ab8ebf0ff6685431928fa13161de611748ec6f0346682f94b44f8d2da164809e2d2939e43c3eeb555396e315ffdd0f9e4d4b66569e67ab97d0c2beb919d0f5d6cdb74e741fe4a18b1a36a222d2179e83a98c7b7e275b0f8544e21008cbe7d4052f89371d9a26ad1a23535ba1dfc678e269ac4e99d1bb30d34c58defae867581c704090af2ed83ade643eb38a6efbd1d3f0b6f5320f3bb45b8be4b891228d701e9490a8082b79317d194b60bbe7c4b12f1af6c7dbf5b6825221e9e88f5d8cef962c7c1c091b247ebecfaa07dc38795acb6035e7b7bd40725548c03398509a8800185ece78d12acd97c36e3ba8c11ce8f6547695fcf015f2144d86fe5ab5ec382ff795129ff716aa70293cb30457fa61ef4ec6e520587dfed5328a7e0ccf3e2325ebabe4e6e3aa84e3d22d6772c2234ce76b475cd84df108b0bb83224656fd31a9f66f6a14f4011ecfde40ae174d3c60e652174051334a579688c89c2e76e2dca131e6f8338faf07aed97cf3b964382265c807f302526845637cc14a69e9dc9d3aef8fc8367fa5ec02f58fc41405784512f35ae30b9053ffc4c77f0b48fb696f8910e8c8a622b47483db6fd60c84f2ce82312f637e280918a10bf8058b738816e4acda602d490cafe0a8d9b8a0b027769107d7a9696e8367ae80053820d4726c435e2ada315e4d6a3673b48fad3282d4fd1b2406b1eb2672956b17c5aada1452dd92e1b4314ba2fa726d53ff9e66fefca76d1c5adb96a57e10278197b33316c05278b7b183e95258e0f0097952cc41c9db1043b0ba04d6538d54b452ce9799b26617dc1b4091169ff8bedee175a5e67e890f8af36d010835e017ff0315301e1e1fae0edcf23d4de02126e58a0a874e0376c75fb0f8d6d76e1a4722501c17b127e43da2c863c88fe08d5ddd29e0500a440429f1be4d47e45d7089771c91f4f98dbabdf230d1009952adc2bc681117d39ff39008f7fc2efb46966f91bf2064737007d231e138d45a5582760088b77421e4ffe0f4bf33f8143fb0a6f46fe65f26df0faf3cecb97fc603196c6a061f1a9d38aa3f14dff0d4286c4b3258dc275155a0b0e91a57af6c4e38a7ffd36aebe0fd02f9e7f2def0cfca985b89579450bac74b8e613451df3aec2864eff0d9569da0fef731b8ad8f7fe68cc7e611cfa8fd374ff581f77a94c44c4dc5d403bb998fb1f29f7bb8e174b5efcea1ca21c42ea87f7a9344d23732cb5a002d978aba7ca58521669039facab9240fe3902804c530a256ba50af2a41d48db9140879942f92c8eef7df364e30cc16e25fc06ec4ab8d56f23d4037e2b8a12ea03f5739adad7e6b003cd1e9e66dcde0e3df9bf9085a67a0c523842a9637d4c4fa8af460fcb840098573be5fe8fecb058aec101e8be2413817045c92f0be0ca4ab0fa9ea3f05aab85cc17e8626e2f9860e84f04e26d9d1f2c11e67f499e18e57ed517d6344e79c96f6b64730dedad54ae5a961117032c7e5b0198d0205cb011d5fe4078d16cc17834e82fd9c085d69889362b158162dc55febc8fefbc514ba4422b7e8720291583d7d7fe09dc2fe82f6e3e9ca9f2d036fee533f6279b7bf05b6091ad8330a6c756f9ef87423c2b6640101ac38c678f586700def461b40ce8c7fa706a53f627a5e8b0a7011445c68742f6e7100f2736cca22a421cc53c8dc1634b50613d52094591c04240d6d8ae6737e07a31ed5861ea871ba40e98e2509e5a193b2b03c2f749206bbc387e19584efd912f74e763455ab2640d945292bde568d4c5420e6382e427ab2bc62ecf6cee69eebbf968b9abc1932199b9324135e51de511710eb22503230dcbea02b3bb533fa2c75d144ac4d91b442cc8c866ed734fcc793044d576926bd3c186d3ec16075c0483f95416f27834080d1d808c53233079e58209dd32630f0485707ec5b6bef33688d8060bd99db64f6a45c0ce2053467f53ed25955ac94bdf9ffc76f3226cbbbf1f6e05c056fc0570fdc81c629039aeaf9eb8650ba3100e782e5c869f77a2b4b258061e8dc237821e6565b68e3f5b88c489ceab95a62494ed5265f314ffb4050b322cefb21a1c7d4433ba9d6c58b6e6d85b013cd5940138df0be6d57fbf0b1c89c0a8f6c00990fd34d79418e75fc1299077ad6e7958e939228ddaa74f7f76c7fb90d97ebb70bec4e4263202efe15fd81423fa6e864681272f1f6b84ad2fb478ee83fa8086022e903f72f1c264f1197aa7b8e0121427bb157530cdd6593c1d7908788071fc7154d05994d82e5f4ed0069fd9c0714d2ed9e4ace8f471648457e5d6ef4d5af129b11bc274802a6a2b483e8818dfb0b56fa3e4eadcfcf67e688fc84bdfc21818bec2cea3c52c206729013c820ccbcb14a2aa1d064e5579deb6734811fdb3deb17a89c7ef09321305630e5bba11e362ce606d3c0b193686582de94db94901aef9ff808cad57ef0a27be0185cdd445dadf13c445d7219dbeb8a804791ca1b1ccf1d36a88e17b464b2ba4fcc1453fadd81b51bd445084f7ae9e6453b77c9a2780ee546ad0098180a26a37a4242465533e455da801a2034fbe50d4557a8915f553659f3ea38a3f2f3dfb7b76edd0d815e5d9c1557f5c40f0a08c85a672cf407cf5cec754fc71d82dff261716304987b5ad0df33a761c3b14b08bffde2b79b7c94f6a0ab1ee2a4667ef21d260e962eb50309190de7a0e2b643d3dfb53f239a02b7ccf86203fd5280c0cd99791ee1877d67fc30b5c0b973f6d6c777f858e4033a18e128f7a05d1e5516a8d1d67bbd95336cf018340a492b67201a31c4fc48c343e30f6161ca355900242eaf4e894fb988e832a6ccbb63eb7ae543313b724389759e9e12867ca5ecf9ed412daf93f6a9b83f95a6cf2273aabe246fa75f842e1bff6956b6d8081faf2f2d7b3090aab9c575c70d3f79973a34b75fd06e2492e37a87bd72d868386b9237b6cc835a6f7def3f2fce5063d34f4492d8ffbb8d77231278d196c790b5611644947631dfd04a980a959735ccb65ba606e7a386f95bb17b23dd3d124f7b76cfd21e8d14c1518825a8ecc7adf735e368961348baf05c5b3dc63fb3cbc25ea8d30e61952e5ef1aefdda33be6dfa6194ab9ba2b5f45dc20e4ede2403fd6fc1e65876d1632af322105df935d29ae4a3f838b38558391f96942dfc7a90f155b629107920ff00abaa20ac5d655840a4b12e68b6a3b1e74bdc81a3d4c456a1a9ce3cc957c1580586e8fc4267cb4eda3f1930da2892dff712334343511e77d5777a1f6de8bed64c3862c2d06b72b7d7c478ef6b5dbbbd92e2d4b316712235caffca28b52a101b06980ffbe8ee969360c549e138c5bc99f71cfc13802f2016a59da18b0701494f89e30c87864eaa6773523b2e275d046a76bb0e612e91b152b8345ad19afa600914180af9eba95d74b593841275b52f1800b3f04ba22a2289267948257ccafc926dbd55698961914e81d9791beae6c544b2e38810d808662c90f0809043029b69b1d19954a2704ed0ce992ba46dc8ae10067f6d4afb9d6f67ec9e35fe2ee783428757d1ff7624978b6cd6e63af80acaeb89b675d41a7c93115917cf79a8c0d364c004b26d75747b725c9adb2f2a9b423612095476aee51c0e209321fd7e5d391701a97090d5cd07c6856f1453e2e4ab74eef66ec52623bc36757c7c610fce63b85eae67ac84c15af65e09a3166de127ceddcde362bfea540aaaf0a7a75b58f6fd68d4d7e435966f46ed7893fe7e286ebc7d24c65c68762dca173261a5ee156a1cefe12739edd0880d6e146cfccded6b5d05e45dce74931ca5b9d328791c4c2299d74963ba487ef17673c8b3045811bf24779214dd1bf7523e894df395086e8a81870e92c076592b5f7a7521a608d4b6698636212b351fdb006d54ffb1ec6d8994396446319b827e07f9a218d19c3b2be52609713323d1cff33cb2fe77ce53c372516a6e43304694d5ec3487dd051c1827ab908a6aa41a2fdfbc8023ea198b6d97f3eccedb194296c9561f6f54fa814fad4135abddbc3252a497f791590d24872902e670eeafa22601848544adfb6e76febc9a6dfd6ac8af54e2a3758f3144cc89ac0a1fe061d9f52a63b5cc3d3375ac325c36ce71c71e807c33a2fe2e5f97911a26660eb7db03330e3cb61ad2afbb12f6c8fdd842ca7f9315fe623072f58e96f9e2203c02144414ad4fbb00c3e8e00ba8fd76e3aeec74e5511f60ecf63ec8297298e9405dd4f15ac1ea17b32b25c99c0024a8815bf5413b7142df9ad0c4c32e9e9dfff8fed61a0b1c7a22bc70ccbdd8c7831a8cdd2697f12406b046cc13f7b40436dfaa41d3cfd57f9f526d861f0fba1957d0508b67523d9a8540a0d1a586737e22bc6a15c036cf435033e35ee62a5af2ec57a9bd822ba29f25773b7848077fa1f07dc8255acff23160e42c4fdf53f9bd13e91dcd75c510f00f54dd5877fe86ee17fe393cf013aa8ab41bdaeeb3195456684e78ed6006894155e8ff08c43b535977468c402f9904ff990a7ee59cc867be09d35153e8bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
