<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e287f6f954941a69e91bef75d8885fe67e4a9e6c2c393db137e0d3805107b6a5dc6714ff52528f9fc7aa00c5c3e7beaa50eb6e2d94f127861b90399f2cb13ac8772799eb4cfe6ea863cee97797c95a1018852fe0d38625170d5e3380daeb0e342e0ff1d3f9d4ffc29b491eeda7b36bfcb1d4e5029962f58966b5e6f677e648a3435c87d39003b5e404c08a0b56e79441650b48ba35b6d26c0310a4496b3b681af5670b5d8d822c3e6582fd51328265c943cfd54350cef96423e7a2957bdae21dde7c91dd43bbb14fe46b846dffd1348f60c94f8d1b881a0818338fdda2fc0a96e1081d3bcbaad05e09b8145738145cde2b9c24dd236de7b97975be856e3e66508ab5b970af065699f2bc7f91f8441af27a9355245400d2d91bfc830267dd9848000c7a71ba300b08a34ec9f701a2a484bc15f6094992f931cb417d453a987e4c9b6a0ea16d0fd8f81688dec748722d6de329c04e54bb0817b2664482e891b417a9555de89ceda2a26e544fb41994a654e4adeb2919e4057150b7b60e42b9bdfce7eaa96ba3dc698e6e2b396572413cf9e77545d059b008f7f5b95cea80c8f305138fd3f34703bc87cfcdab0c70979a5eaa19b8a4d895c78657a157f6758bbde6d684deded9ade21831ab8e550d0fc236b3cc11e981fd1abc8591a1598adaaaafdbe2bc6cf636488d2baa3daffcd0903151cfcdf4e6c641482b10d554c1675c973206504f5519611ffa697be6c71a46aea318036616aa04bad65cfef162b595a3628947a30b522a51eb3581efef6eb31b2e27950d4da3fe0e68697c896f7c29ce714c48ff1c8b580e748c3f85ca4f8a07d3fe693a525457f21f6c66e335e5714d5c7bd0c629d83abdc0e9c4e3518d73b4c9f032086b9fbfc3188bee94df2195ccf988a14ec7d9d1e8beba22c7b7caa0dbdbd0bbf8e757c0e96545ef582f9aa4345888a2108248cc28c4035dec521a92024f72cddc96fe982bc9ff0e40da66d0e91382165a5f44499472c8bd72ea98a44e8c94cfd0d49d83f081e9c2b024d3e2464e587c753cfcf2414c0e4a9b32b072e1a4c82823245098f6a16bf9967a018d69c66d2f2af2d251bdf973c28e01544792649f8cc33490818603bc923c1eb62cc9f7edef08a1062a791a02940560db481f0a59fb21a103bd6561b58ca2e22af630ecf584c4d096e388b9483ac932f005d554e4075574fbed48b9635c573439ba4ab6383969c9528448715e4cb54d02a4a5e8376c031fe134b98ca0c1fb003518964a38e7cc3b2ad7a0c87532b318be447de446bf86338711a2608398e1669b1400729d2dcbc43578ab05add4f3bf280910440f58b925e84dfab80621e22ab76d16006a9a7af333fdffc365c4ae19157bdfe5a6033c15818e2037b987b1f6f001572c4a221ada7ffd60ff61f9edd05e3e780bc1838fcdc25dd375349318ae73ec2c6d6e2caf64cd67037ea000c04a1c38407273420918f1b8f2a19c875c9310a7e51141e53d34e4b1a7722c2878e8823353b3d67fb8be04bb6b7aedc06535316c76bb53c127cf0b0f1dd0c09a6e719d3f9146382e70273e5373683ef8ea44e23c589df05a567c0c3d733c7df1ae95398fab611f9a3cf0a3f80d45b678e601450df8265671a918974f3866075c53beebcca9b7c7c8ea5e3060ae2d2a623bf8e4d6f0159bad960689e2aeb40ae659881a042ce9303dc516aa04e0e87e6389a64aab346700930ede85e6e8fdd72df5eb92b903a1d67d6e3dd04ce3fa2abf9907bfa9146f36bce6b9e78d8810fcebf75b5bd45e987ffce3a06361dad4ea8a0d528b485a19f0de7b1fc4071366c16f50baa36a90fe55b8a89d5dcabf2bdfb405fc1867e168a384be1d9e9eb02ff6e21e60bf8050a9a5c1ba374f9f8e914584f7de20950789ff8b331321aa833284bb585a6e42b04f8db6c23eda5f53cda12e2cdce258062c488d1f8b303a1e7121910a257feaf79c0a3e8478aa19508ab835ae9e7a6d8d98978f827ecd17ef9e894eee007b6db349379e682ef38a77f5d479c27a91b5e8cba400d2917622a2c2bbaee44ef13116f92924fe4b5710456640de3c42c4af53c9e471799ea288a0ace7c5d4306a0846915d5f7a9accb6bcb0665f69289157bbfe23c2658f6d42db80ce32afca72c2669b4bb7653b1e851cb2f42cdae34207ce6e190e9ab8c1cf0150bb295b01d9fc983d280a1718aa29734ee256a85752453ca54cd1313d8900d41f75bd4cf1f6a601277a79510c14ddd46aadc08b95cf96e945c7e3962617250b507df905256153ed39e0cf498bd125cdeec6fee33ba5fdb28cc6fcf2ef41036716da2a9106258b70beb32131dd091157366062d412d3f91a1f3cb4132c46c4a01fa8d534ef34ae89d9a27552dd20f6ca29278f54eedc84c6024349edd31bc20591015ed979b6ada778deae39ab24be2df2d24af1781f48c8f8dd1c67249497aa169a553f86c8894c0a2361c74a5b00ab652b5542941f9cef827ac361bcc63c44596bce19b9c1c4277b93942bb89787ecb326e19b6cf3df1d1a23fb8027e6695bc9242cf8ddc6b4b9faa26d576598f0ac7093bdc0b4def129c116c5cc1516df217e097ea2322d2887ab87f7b1710fb3756f7a3b275a8256d9149cb9552aa5f4a0aa4e616f69224f963d15f419e0b686efdb24750e8107fea9ba7a05e21b3cef79920f9c03859ab5ee632954a8d608e1ba99f5d06f11aefc135b109271893bd7946c1651738739c91aa9ed3246c550ee22f7cf446f8a750edc49433ed7dc9cfa6cd2205928f15cae6ed1798d18790d169af563beec641d475f30c4aa964ad40bcc62c0ef542397ddd1b8724f9ac1aea91fecdc3b9c8e9a579908ef349c15c5d53081951094d3ebdd56aef115d25ca5207cc9827e9d7b0a3ddc15d6b11d0db00133308fe68b5ac6c65a371dd80f733d025c9312fb9095360c0af29246ed783c9b13d0e9ea1187b000a4a9764ae62c0f2cd69eca219175812132f8c93614142f8750d3463d4d729ec788d56e0ea2fa0451b373756251ec37a6906fd59414625829b79f6d3bcbb154c47973051c96d8a585972224c8c17106527df25dbe77678aa123a00d53455da144a3deca0b9df5a0e2807fe291fa334c19548abca01a841e96ad5670931a192be016ef3bd8ef7cb18fa49b58a04303b009cc8e0fdf7e032c9b9d565938fcac9f6fca49e5687e74623cde82e4668202a5bd3573e14fd1c998671f02d5b1ef813b3585f93481517a3f53e8b04b1aa4288de95eeb2adee731281e57e6c75b32da0d3950af01d13cd4456d7ccd397dfff44a5424f26ee88e577aabff77b99ec47a478ec73c73d12e98c9115b8960991254df2c7ff62b03f14156161646525c4cd6b9296e8c55a24694c7af3167509cadf6aef7d79ddce8e3100957c2cb421932ff7bae9aa3cb98fc1041e2b7b96c70cf21783222f7102f0304ba1b93dfa66387ad7a35289b2203a9aab3b422993de8b477e2dd0a90c509fb0d533f70cf12364609cad940eebddd0923b7ee39ff523c0e4120f5e83f115c87e43edf7b12cf103d3f56155227a2b93de258bfc5382ecaa67cef6d9fbc453102ad10e6b443a5fa5665e31d3710f8b55ae9d3ca7b86e28569403ff3e6c88958512413d438380a755e6e636f2e82239639cf2d623aa1ead1ee57151c2792ed842a24624eaa9f7bcc394691179b7cdd958c77d3f98e7a088756cf17e0fab88a97b7b8906b16ee07910377a7e466242df3f1cd316c0a080aed01c66c65c3a927a7b6c795ac8ec7cc5e6a106957b22aeb17b53367160f4a4d20abbcd54496d395064afe5092be38ccfe02b9658a8108964c88250abcfe497c8741d6a7bb39d607c1ceb069c0bdb88515e25aa855b836f76a4949075ff4f93329ea934553376db3f5e5cbbc429d3ab384c1b617b876a75b6a8d794c70e718614f308c57f0f3ee7ef70d4c17852b2a1a15757eb58e0328cddfa9bc1515fd0bfb1e8339b0cb7231f3b22f82d54b315f17bb2953041f177b5c9811e1e6dceac2efb645a7c49546e6708bf1a4774046f417846f9b483216ed79abff6715fb8a27f389bd2f550b5a20c3aef0e98b980de8d6e345b1d3cea7cf021c35da7597326a7db624552b8cbdfd8d27aad49086729d165c1b39ca64ee8e2b0faaa96ff062b7f542d8fa2b7a4f8300aabd2f7d340aca333287ebc8e76262cefe836e800f1017c07410a55d3ae63a595e95dda3b0ccf3b24e94b62115a18e18c5b56b7bd11950fa500c888ffbb42d6cbad189741a2c890c46714b1a5575a0459a099ac596b1cfe807cf4efadba3fb65d12e4f748c306310af60530c0804a48ab9a16fef66343426d7c225d228c2cf16bb6d9ccd14631b764af6efd918cbac2f704b1b78c453fbf8f035b7dbefce397e5b52f817d5d183159feeefef95f25693d2e7b77ac8ad14991f846d91c31d4ad4864237182c790b1899c703b86b2ce467451f1441820dca04d4288e8e2e006c1f045df5dbc4a32d90d52da06c1b4d72b8663993095b3366c9e27fa393ce34ea2f7e33829aad29b9fa2a16d7644cb3fd81430bcc9e6679bb5539f84e4db99dabf8e57517ddbee65c555ca3465ef51c87d30172ce9f5b82bcedae57551e587e5effa815c153d302d090a118e3376a605894fa919933f556a1737db85dfea093b27fe91db04edc2f08353e7421d03624e761c59fa12290d7e7517646a74d263404c0a7b3aff9ac7b51169cc0ee30aa0b69b3b8a1ddef7775e61937ea0df9cb2f2cc99fdddc3ad3ad3ee409fbb43b2cb1189cd7bf98f1b63ac0841cbf65b5821262c64335d45979bbfb150c3bde65574e24ccf713bc149b04fdfb846b7be98d4be281f8954ceadf87df04144b29093079cb06ee09696bb2e8ad7601cbdd03c00a22e105317abdc02c3b1058e44b88c75a562705f503cf2f1d7aa1acfb2184097af3fc6d164e3a057991a25907f36855b708353c4a26cd7094011da29dd4f709ed6cf951bf705fc8d811022b5db0e8a1d1ee284b53e9fce9ea90b7bf6b1f309fdf310406534f60e8523ea47e165191b696b26b89b38228919836ece2120218956d25929ed89744fd8c91a5aa41a38728a7d757eb53e292420e6607c020228c3b02646b87abd1f65f7822a2f97c1e77fd1577762261f2a733d7a54f6a0c63d6d1a4b6f7627f763cc4bd7cd25d3dac4fc0d2871ca99f7419ac7e61b9fa8d87a0e47be0bbe1e73142c28b64d3db5464e14754c53516292fc5f2395ff016e26c26b92307cf3c6575c73ba519ffaaab8118d0a7e897e29f3b5e500ae1854521daa972da7462a537b9051d16153575f1844f2b36f85fdc122c35659ae6a3f4bcabc4c6ef2d0183d33b8ee5ebb40cf0b53ed91e5d78d999a90732b88c8849cd02aa3913b3bdaf2dba9ae27cf2dd5fde4998960bbc5fa9d536808e6b88bddce5173d4f5b8d9f44772246c95412350528ba3cf470dc989f10e420ed429decaded29f426762a56572bd99a796539d5d3a78ebef008f7106e58e81564117ab0160ae2e8a8a142d418ceb803b79cb1dee903d776a2f55b8ab7f39b491a0c19099c3b8542be59d784c044c2ae326887c2d96c9bbdb9dcba90e7be1390d4dccfbe49f78cfabdb669c95d5935fb9b7125b766bce9d494187c2a7617d47d7f81e7b4f9acfa2cc09b591d6933a0dca71540b2f674b5cab791b8053e21fb317a584b22df92316183a99596491631b349817b1ad7e4d86afef00f6788641cde1c8c39a22357a8f03392a3ea66424bb27cd49081085252036d829c1a82a260217b01bf8fbc98bcf36292fb0df399f57deadd0d40afe276c3930800ee2aedd5d34d8005bf135ece8a885ac58df53c29e93cba8bf8b1dd707fe58494363c746008416a6ac3e4d02516824c29a60e760ab3174350bbfd8822e7eda9eee16a4348dd9831ce99034f4b84456311080ce2fdd62cdabd8f47675e24146af7604666a702c36fd932181bc797dd8b1fc00b169879996ea75b3c9644f292eb1c776296a41c58e23e5e962d18ca4f07092acb0f56157dc212fcee392a163803936e6e22c3797b6fb129b756337d2140b7be4d85c8290090877c7e2b193227abd463a30dfd13ad14f42cb081418791abb8a0423f84d0fbd0b0f4538ac5a4165eaf0939923a3e813475ea9384ffae943f06dbcff468650384ff03309a5fbf74e45e74d16e729b7bccaa98b443bf74b313bbe58183b82bef768e8e852800f24d7fd445d5eeee106b8e50c98bfe9afb2b276731c1ceb97683f3d8984357c648c906a52f0531f4eda705d6c1de58ef5c234f839135859f497df198ef16ec895ac74484a712630823b1cd0d04ef169b75c74cbc1f6fcc4b5fccaac07b476677ff5d07a36c5dfe016982cc612c459da8430a486c14451c54d1b4f273dee865ceef72113521505d39e8a9e4dcfe93af8996256c3fd5d9f741736398f2a603379addefefd8c89b16c60bb3ad5bb2d0acb50ecc5d29d7bd0f4aadcca5602d60fafefdedb05ba27c55eee8f0654c2af34ef6e6bac64c20e3fabc5da453f5d03e4bec04aaece03941506b75d260752ba81172af8f038e12c193d16024f4390feacc037c3081012c8f72c536cfc989ca13c70ffff9d3053e9f10430d8bdddb808d64a1c607072d225d69e7b6dce13437c3c14753919ade8390c3766a8e1168dbe8f2938129a4b2b4c4c8d2ed0d04d45332cdef6a9663b83a7a75540878fbb60b24d504b0aff327d4162b7f1a12064cd8f9f4faca1cd5ee8122cd8fcc687aff21d9f90e8344fc1771d87959af945f400732d5668436bb8f5472b10904432617376fb0bcbe9a7fe85500ba443a181f92592a454b9c4eb399f00815e6410f4b9d25f7e61168f1b5f5f636bf9c67a54f4eef107c90417b09b4856b0fbf81d8325c7273b96456a11bb323ed042aac3ee6aa3ad0de51382194630fa0f04e6eb482691a3efb0426c316fe78544cdfd72b54b7f8ccc7e5fb51e64e5acacc7960b6417e1d5b9d7aec4e120245c88f5bcaeec7568c745eb0d57d88a26dec7649cc62bf5ed566a23fe9fd8d1b34f77434ef0abf73012400206712dd15d447b57b2ff131920c31f147216b5c2855d1c52dddd47147389a4d591834eb96d3241554f88e3716861ed462c224dfac5cb9693edfd857098821c8bd0f782f4db4c7747727bf6ae49b66f4a08cc8a5bcc96ce1c798b3a9b4791a5af8de1e7f9d2fd70fc8d390006f8e663fbbf1f1cb5970457038b022a27fef528997bafede4cc1ee0a5181bbacee027fef74bf18e77729e319263158192a25720d30795d6ba4e1fa550eebed8e2bd934e67cdf2fed1d3dcda941b5654d602218d51b74e0d5459af453955c627e231fde1d2e1b065a5cfeba6c67ac4975ec67091ed310d83d89c35968f5770ede009c2d2ac11444c575f3506a3b3483d923392c811b37eabab7a2b734998711377c5869feb63a052fe9c94351269de12cc92781f3422f8cbdb44bfe44e988f4b53d83188b53710850ece617ffea344f1998c6d5e15130d389e1e8c95a55a9066cde926a506f245eefdf01e087acd138a3b97ffd7d3839489eedf416ff5372100cbd4dffd7714eb514f05f25aa51b9d4b6658b3b6f7b97dbf0db58cb2f3fc195f700c2c39194fa897a10d277852f8f194b672e44ac3cc574ca0edaad0b15e4e767b333cd5ad962da6ec6e3c6f0b6bbeb10391a5efe31ba5eca74a913cf5e37161d2cd3e476d14bc94ce4d37159beaf968970634ed983538fff8299a1273aac0081c4d3ce7cd499977e31a49d91a29b0106737d238460c12f8e57d1c7c9be72173647370f4579f8eb86f83d06ec92ecf8a1151afbce9bf78abfccec3ed5b54b17a087808bb4cbd121cfb418d6745aa892cc25258432a0215ba57d60ce67e69acaed0c5cb228d4c0b6987bf8f200b28b983cbb6a6c2124fdacf779f27d54521ac6b44d08b3ccef2f65d1cfae750537497d93cd3d29b7cb27aa70088efb0845cda41e83f06b6bafe1be3b1169f750cab45fb9dae032ecc15e28b1efaa3ad54a035ed34206c2a3bc3df53ecbfe4ec62c537751729060472ca8595ffe3c4b9bda1e3222961c28ba39ae16c9def6f2b54784c319d744c4edd5ac83dd63547c5cf2184599e10392e647494114f8cb33af147bcbdb08911cd8e89efe17b8f215414c3dbe47478d5e8e7161186b85fe07734d0fe60bc1315c890a730c314e61ffc6949e206000b99a8d83d7b7c3374257a4049b8b8ee2ba069a7caa4bbcf5cdefbccebfac6bbc08a4526f708927a2d636d8d91758ca33eab37ea375862e9b435ad0025a7b9572d42cce77ebce2e3dfe59966a348b330f46d833a8dfa6b18471f12155fa2da9909b39c513a3b00528b578cb00ecf2a56e776891fd7b31c50690bc7edd4a8f3768fa75f935d23277f8c226e4ca7f7eda0be884973ce440c5853ad87f15c287e8be2605ed082a442398b8db4aa3d40bfb3f856ecb04c682dd294029094771c77436a2d406058b0791159d034cd6c6cfbd34b546e08f1fa7858626914c9cdec510414accffac300792a6443fc33f0d5b51fab9273608ddb59e71e76456e5eeba9d3fb3c498a19daad66db3dcd95ea4659510eb8d99dda59135d19b5cb40e5819d8b37032b012bc57cd986b8db1e7617b6375bef2f3aa0f3ea28f02e394e924cdf59ef2ca9339868f90ed96b6e491e9f6d7b7996a11fd9c1389db559389e7ee92dac1acbe3c7e0b1fde2f6f015c9e27087b272a4e24563f80b8c9513f3d4d8fd1b5f22756cf7888e52de50ca81ea586581f7a82894dd55f945dc76307fd258838fa6dec47c8a741a3f8f06a5edf86e46885926b12c4e2d6af3c43db1b77f0949c843bb6164f4931a33aad3cfc78251f81612928908d21220c75172064a51b9159219ffb78dbc10355bc36583540a0740d6d4b01272946b2b0c80424a7c0aef4d990fcb93e6945301424f2c442846dbedb0e04027116495ea115d42dc5ef8309b3c8635cd0f4aae022385dc9a47addd6f3eca408e84a06026fd19e659b372d1943cd8e23c58bf347453a63edadb1313211f7713d460aac1b08a71911be49e1db66d33990670317d2b4a1f8f96b6edbcab8cacdc3ea311b3bb3ea8f1676844ed2d90ae3dc293cae61dfa01100193aba93e57f8e8ae5e8914bfb84e258d458b8369c0b8e9ea879ce4239c2b8123f4ee1c0ea24540e43b07705ac9aa54a07d9956dbb6f0e4e294566105c4850da02ea90402c13f84d2ffdbaa161444cad28d6cd1cee342be68fb76ca981f08dd80c76918a25e00aedf7e38f66cbed1fac44d91f73e15ffb6e4d43501b129a14cb8e317b690ae67e84d17712d8d09d43680c30ba23f4633bc44f75063e412afdebcb56cf4e48fc0b289b8f1a8e3ea85357f8391de67dc19251590cfb2acfb4c1fe4ab43952881cec7007982af11bec037b62662759df243a0214423540d59aad2aa738aed9ecd839b1cf6fb0a9ce64e0a4cfca6e8f094f0307ba37c742ad467c6c8292eb038fc64a5f167aed601e2305659aa5f3bf51d22f49e830d978c5f03333c02e92c1f575541801024dd3bd98c67c02ca46b40ced1688062e7223e6fdf98e372e688128b8e31a652d15a07cbeb212fdbff72132d4a0265614748170c975fa98e2f09efd272679776566e3c3ffae3f56949a35be9a7eecf2b6713ccf07b50f6a36d535a7359bc427751950c30febbf61f4bd865da298b43186292f0116c46c792d20c818197856b8d5c62c9e45074d7efbec4e4bdf2b47c23e935b6b8e894addd02a984ebe7c3092cacac350244caeca7c24a67321ad835c8782c7fa1af3810519a04b306baba709aa38aeb778fdd3d66b9b735d6d0d5aad5124c0380f03092ee2f964fe8d9b668894e5938fb23eb5f33cefe4514d34e1da15ae81221e28e85010dac885812a08a4f9108801fc2ab36376737ed2622adc8e4ea2f446784ffce6811b8386c81fe5021ff5390f1e94b213ad3bdf5150781e9a11711a49ceb16aca775e23c2e64e1ea1a30adbe8dfb5b1e02823c5b707583a78f39c4b7d22a9fccd4b4e6665b74bef1ecfdc9eb59decd29137a81659a2a1a3d616aa80a89f084c71e4b909a66dfc3566cdc2db1f8037ea0ed6c91b898ff81e4c59a9e5903e7fba887768b43bab39031b566c34b63f0ca375a1fa7a2413e78cc7bd91b2cc3712a54b1ce50ba5966a3ef4645192da0f4819735a8ccf70f31c1351940b301840407b4bdbee5353d00d5f0fe1042d7afd606cb66fab9467e9cd9950e186fb9c3309254df31a3e00cfc5cd8d0ef02a1833d4975a812dbfcc5703481ee477bfb2a0dec51f62c6f9c21ec652f1f6cee89fbf9da2692bf3df879c56085dc6d04a81cec9714df478f46546523a75550598a294ab8803446d9bd89c6c7b7a2825466f554291280e2f58d9a5fb375d29c8752d68fb41e74889782f0549f5058504d9bebe4b17dad7f840a10b94f71877b1047edecd282cd49a110fa3743382959c4c84c032e277b9cb5d9a9ff0e815e601d81bd87b41fca92f59043cee89cf20b655e67adde85afbcf4e512218b181ae448e9140f953d07439a969be5ce289c145ea805ec77caeb77a32a859802afaf18c3af4074d912676fa6798a3c7cf553ac269b3d10e7aab1fa8973aade62d6dc53753ab9e04fac4b47371229ee1d2209fff0ccedf1f65d564916f2c84046f81f6ef46ff8b8c0b061646a0c3647f2e0cba1bdd4ae9397f46cb3c23c7d252343443456d70aa1d9643e7aa5f7c4d68c4dd4fd8dc4fb08f903dbd49c3acd5af15f13f407b578d8237839a8064a4598d5b88ba55b3771f42f5fe93822dbd057f4ffb47a89901be98da12678302541d6a38a707ff5b0ae48a70ed12101a5fcf6d020dd43b0cc4694897dbeeba51a0cdda9ead5512137f1b1458763efed6cfbd7cd1e0d3e673ba19f4427178697a7f005a0aa99564ccb6e07ef3298f9f7dca04cad730da2d2145b3d6d354181ab24b7bc933fe5913c7a92ad8226df7e89829671c80aba1a26eb276c89b3bccb39cb1163a9b97aa1680ed3b340d3e5521e28b15c3ffbe1ff29f6fcaa35c6de620c7a83e0e81710abf19761afd562745b73dc21b8cf528e0a7be3ad9bcb259b555490b5b69603c2c29e815a3ef55300646568628e142374c058316f0aac1695240bd023958812847ba2b66e5fb38a080e36735e51bdc761c0ea67ba5b04b10031f97618ec455f3a4e971468b72b86ee80c6bf2551984a95f4e9bca045a58fd4045ba7d85d7501305620ead24e2cc289cef87615131277ad4c6a14e48d8c491f4e5762011e385241122ca3f77779a672b986811a8745a4433fd28c4bc0e42a16953c86985c0fd1771f90fb9dc09e544bf81eb694139fa0f10a269dc134b4a4e7362f0d7455da9998362aefb29b0cf93c4317ac48cef87eb26089a8a9570958f4b03a2fecf6d02c3f9aa5522965e7615c96f5805831666f4257a58779d62ff67802bef454412c9516b61ba6baa4895f3531b91e251059515c12259a998d58ede05504bc952a254fe0a5764eee5534832ddcb2171a1e6f7b8276b07f5ed92ac16833f58477adf2c47610a52c1ff349f51b708e9617a1c6d77695ae38d3bb667666b94315ad330136a9caae1081faaa46a42e3287a10c066e632d5cce33af6a5cd72c4124c5adf2ca77e4e7be980f19b0573c92a766c5d4dd918d6650a7028fe6c3bff5767039a2d98cc4ff800f3770d7e2f481be0107e6d4d7d82c0597342a98e05459b047e9769c007bd105e4d1a0432f8bd83dc395d7d296e57a27d0cba3a182473490b58a64d739554453b7d76145ff8e04ce68aaec816f0c9b29ac92708668464e70cd30402e8e237b8dca8e259a3be675adf27931a50272db4537923974fbb601402198c1ec029bec5ea8ddf4e8b870a1435e5bfa42cfabdfeaeb3946a6ce89d478639bac47d15e23ead8893fb94766f1367c74c3f6963bd7d212824df33158c2563f19a770a10a2f381f865e60df22c2d44c0c49d3602dc301d5284fb95c11843921b517717992f2e9cf628bf2205da9f517a5d7c39fb42cc32a79de20a1a569ec5634cf514e6819f26e801f40c40b305265e66c619e6b60b294fcf7cb20faf27e237ad9cd6672b6d779f0fa4132c67c36667f8190a0a3f07fd434a612bdf81aa313c9ebb69ac3b2f9443a1a7c1ad1ed99324ce287cd83fec26ecb625bc2966ba60109f791e0b8c4e0f7f22e590e761ffffa6c7e7f44aa54d79897b0713732f9ab14138c097b040848139ec2271f6019862b45dd217c70bc4e3d2f9606e073a9d95e904234ab956bffd15ace7886dee1cf2b81740ea40553258f708cba6073c197ff4be47acc6fd4fb10667760fc11e7eb8a228a34ccdcc8c04b5b42783564d8d3617b870af3ffe91453b4a1cc568582e95fae76da5ef494017c1ae1a7e94111a3fb77cce0878dacd0e79db00840695b4b6e86e3daf65f90b3c129164a473a798c19557056a3424e117aea72c99c104ee55a6d52c6c0120c41e740864a44ff488027b89123211190a4a217014917fb23708b7af9be3916b540fa54f44eb40b76acc8fd413e6757a71862bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
